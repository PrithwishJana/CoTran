import bisect NEW_LINE primes = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( 2 , int ( ( 999999 ) + 1 ) , 2 ) : NEW_LINE INDENT if primes [ i ] : NEW_LINE INDENT for j in range ( i * i , i , 1000001 , i ) : NEW_LINE INDENT primes [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT prime_number = [ ] NEW_LINE for i in range ( len ( prime_number ) ) : NEW_LINE INDENT if prime_number [ i ] : NEW_LINE INDENT prime_number . append ( i ) NEW_LINE DEDENT DEDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def countMakePalindrome ( freq , freq ,len ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT freq [ ord ( freq [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if len ( freq ) % 2 == 0 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT if len ( freq ) % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if freq [ freq [ i ] ] % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def findPalindromeSubStr ( freq , freq , freq , freq , freq , freq ) : NEW_LINE INDENT odd_CHAR = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_CHAR += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT def findPalindromeSubStr ( freq , freq , freq , freq , freq ) : NEW_LINE INDENT odd_CHAR = findPalindrome ( freq , freq , freq ) NEW_LINE freq [ i ] -= 1 NEW_LINE return even_CHAR NEW_LINE DEDENT def findPalindrome ( freq , freq , freq , freq , freq , freq , freq ) : NEW_LINE INDENT return False NEW_LINE DEDENT def findPalindrome ( freq , freq , freq , freq , freq , freq ) : NEW_LINE INDENT return False NEW_LINE DEDENT freq [ freq ] = findPalindrome ( freq , freq , freq , freq , freq ) NEW_LINE return ( freq , freq , freq ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = " "
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import decimal NEW_LINE import queue NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10000001 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def lf ( ) : return list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def lf ( ) : return list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def lf ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def sb ( sb ) : return list ( sb ( sb ) ) NEW_LINE def sb ( sb ) : return list ( sb ( sb ( sb ) ) ) NEW_LINE def sb ( sb ) : return [ sb ( sb ( sb ) for sb in sb ] NEW_LINE def sb ( sb , sb , tb , sb , sy ) : return [ sb ( sb , sb , sy ) for sb in sb ] NEW_LINE def f ( sb , sb , sy , sb , sy , sb , sy , tb , sb , sy , sb , sy , sb , sy , sb ) : return [ sb , sy - sy , sy ] NEW_LINE def f ( sb , sy , sb , tb , sy , sb , tb , sb , tb , sb , tb , sb , tb ) : return ( sb - sb , sy - sy , sy ) NEW_LINE def f ( sb , sb , tb , sb , sy , tb , sb , tb , sb , tb , sb , tb ) : return
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE dp = [ 0 ] * 9 NEW_LINE mod_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( number [ i ] - '0' ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero += ( number [ i ] - '0' ) NEW_LINE DEDENT mod_zero += ( number [ i ] - '0' ) NEW_LINE dp [ i ] %= 9 NEW_LINE dp [ i ] %= 9 NEW_LINE DEDENT return dp [ i ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( count9 ) NEW_LINE print ( count9s ( '010909' ) ) NEW_LINE print ( count9s ( '0109' ) ) NEW_LINE print ( count9s ( '010909' ) ) NEW_LINE DEDENT
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( N , K // 2 ) NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ [ 0 , 1 , 2 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE for _ in [ 0 ] : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE for _ in [ 0 ] * 7 : a [ _ ] , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( * a , sep = ' ▁ ' ) NEW_LINE DEDENT DEDENT
MAX = 10000 NEW_LINE arr = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = True NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT arr . append ( p * arr [ p ] ) NEW_LINE DEDENT DEDENT DEDENT def isEqual ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEqual ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
MAX = 1000000 NEW_LINE arr = [ False ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = True NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( p * p < MAX ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT arr [ p ] = False NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if ( not prime [ n ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n or product [ i ] == n or product - 1 == n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n or product - 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT SieveOfPrime ( n ) NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , i + 1 , " ▁ = ▁ " , N * i ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE DEDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE
def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = m * q NEW_LINE n2 = m * q NEW_LINE if ( n * m > 0 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( m * ( q - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 7 NEW_LINE m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE print ( closestNumber ( n ) ) NEW_LINE n = 18 NEW_LINE n = 18 NEW_LINE n = 18 NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE print ( n ) NEW_LINE n = : NEW_LINE n = 18 NEW_LINE n = 18 NEW_LINE
def solve ( AG , n ) : NEW_LINE INDENT if ( ( AG * n ) > ( 180 * 180 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( AG * n ) > ( 180 * n - 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( AG * n ) // 180 NEW_LINE ans = ans * n NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT AG = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( AG , n ) ) NEW_LINE DEDENT
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE lenz = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ lenz ] : NEW_LINE INDENT lenz += 1 NEW_LINE lps [ lenz - 1 ] = lps [ lenz - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if lenz != 0 : NEW_LINE INDENT lenz += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if lenz != 0 : NEW_LINE INDENT lenz = 0 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lps [ lenz - 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if lps [ n - 1 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = - 10 ** 9 NEW_LINE minEle = - 1 NEW_LINE minEle = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minEle = i NEW_LINE break NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( minEle ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( minEle == 0 and minEle ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT if ( minEle == 0 and minEle ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT if ( minEle == 0 and minTwo ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT if ( minEle == 0 and minTwo ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT j = i NEW_LINE while j < n - 1 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT a [ j ] = a [ j ] NEW_LINE i += 1 NEW_LINE DEDENT print ( i ) NEW_LINE
def checkIfPowerInAngisible ( num ) : NEW_LINE INDENT input = num ; count = 0 ; NEW_LINE factor = 0 ; NEW_LINE factor = 0 ; NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT factor = 1 ; NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor = num * factor ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor = factor * factor ; NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT factor = 1 ; NEW_LINE DEDENT if ( factor == num ) : NEW_LINE INDENT print ( " Power - factor - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Power - factor - inverse ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT checkIfPowerInAngisible ( 12 ) ; NEW_LINE checkIfPowerInAngisible ( 18 ) ; NEW_LINE checkIfPowerInAngisible ( 18 ) ; NEW_LINE DEDENT
s = input ( ) NEW_LINE if len ( s ) % 2 == 0 : NEW_LINE INDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT ans += ' ' NEW_LINE DEDENT else : NEW_LINE INDENT ans += ' ' NEW_LINE DEDENT DEDENT if s [ 0 ] == ' Z ' : NEW_LINE INDENT ans += ' ' NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in d : NEW_LINE INDENT d [ a [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = i NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] in d : NEW_LINE INDENT d [ b [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT d [ b [ i ] ] = i NEW_LINE DEDENT ans = max ( ans , d [ b [ i ] ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if ( len1 == 0 or len2 == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 for i in range ( len1 - 1 , - 1 , - 1 , - 1 ) ] NEW_LINE i = len ( num1 - 1 , 0 , - 1 ) NEW_LINE for j in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = num1 [ j ] NEW_LINE i = len ( num2 ) NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT n2 = num1 [ j ] NEW_LINE n2 = num1 [ i : j ] NEW_LINE sum [ i + j : ] += carry NEW_LINE i += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i ] += carry NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == " - " ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "1254454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE if a >= b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( " L " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " R " ) NEW_LINE DEDENT DEDENT if k > 1 : NEW_LINE INDENT print ( " L " ) NEW_LINE DEDENT elif k > n : NEW_LINE INDENT print ( " R " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " L " ) NEW_LINE DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT dp = [ [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printDistSum ( arr , n ) NEW_LINE
def Subtorial ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE print ( Subtorial ( a , b ) ) NEW_LINE a = 7 NEW_LINE print ( Subtorial ( a , b ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif n == 4 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in a : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT a . remove ( a [ i ] - 1 ) NEW_LINE DEDENT print ( " YES " if a [ 0 ] == a [ 1 ] else " NO " ) NEW_LINE
def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < len ( occurrences ) : NEW_LINE INDENT occurrences [ i ] = occurrences [ i ] == 0 ; NEW_LINE i += 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT def getModString ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE occurrences = [ 0 ] * 26 ; NEW_LINE occurrences = [ 0 ] * 26 ; NEW_LINE i = 0 ; NEW_LINE while i < n : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE occurrences [ i ] = 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT i = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE occurrences [ i ] = 1 ; NEW_LINE occurrences [ index ] = 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return ' ' . join ( str ) ; NEW_LINE DEDENT str = " geeksforgeeks " ; NEW_LINE print ( getModString ( str ) ) ; NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT h , m , n = map ( int , input ( ) . split ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( h ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT break NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT if h < 10 : NEW_LINE INDENT h = 10 * h + j NEW_LINE DEDENT else : NEW_LINE INDENT h = - 1 NEW_LINE DEDENT DEDENT elif j == 0 : NEW_LINE INDENT if h < 10 : NEW_LINE INDENT h = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = - 1 NEW_LINE DEDENT DEDENT DEDENT print ( h ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT for j in range ( i , 101 ) : NEW_LINE INDENT if a [ i ] + j > i : NEW_LINE INDENT ans = max ( ans , ( a [ i ] + j - i - 1 ) // j ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 4 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 5 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 5 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 5 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 5 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 6 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 6 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT for j in range ( i * i , n , 2 ) : NEW_LINE INDENT if i * j > n : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = i NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT b [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s [ i ] += s [ i - 1 ] NEW_LINE DEDENT print ( ( s [ 0 ] + s [ 1 ] ) % m ) NEW_LINE
def printMax ( arr , n , k ) : NEW_LINE INDENT Dup = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT while len ( arr [ i ] ) : NEW_LINE INDENT while len ( arr [ i ] ) > arr [ - 1 ] : NEW_LINE INDENT Dup [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT Dup [ i ] = Dup [ - 1 ] NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , 1 , 78 , 90 , 90 , 56 , 56 , 56 ] NEW_LINE k = 3 NEW_LINE printMax ( arr , n , k ) NEW_LINE
def rascalPascal ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( rascalPascal ( 20 , 1 ) ) NEW_LINE print ( rascalPascal ( 20 , 12 ) ) NEW_LINE DEDENT
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "0110" NEW_LINE length = len ( string ) NEW_LINE if ( isValid ( string , length ) ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
def leharshap ( n , t ) : NEW_LINE INDENT r = n - 3 NEW_LINE e = int ( n - 1 ) / 2 NEW_LINE e = int ( n - 1 ) / 2 NEW_LINE while t > 0 : NEW_LINE INDENT result = ( pow ( a , e ) % n ) % n NEW_LINE if ( result % n == 1 or ( result % n == ( n - 1 ) ) == ( n - 1 ) ) : NEW_LINE INDENT a = r NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT n = 13 NEW_LINE t = 10 NEW_LINE if n == 2 : NEW_LINE INDENT print ( n , " ▁ Prime . " , le ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " ▁ Prime . " , " Prime . . " ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE while a != 0 : NEW_LINE INDENT a , b = a , b NEW_LINE DEDENT print ( a // b ) NEW_LINE DEDENT
n , k = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE k = int ( k ) NEW_LINE if n <= k : NEW_LINE INDENT print ( " impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " impossible " ) NEW_LINE DEDENT
N = 3 NEW_LINE def MaxTriceSub ( mat ) : NEW_LINE INDENT max_trans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE s = 0 NEW_LINE while r < N and s < N : NEW_LINE INDENT r += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT DEDENT return max_trans NEW_LINE DEDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 5 ] , [ 7 , 7 , - 10 ] ] NEW_LINE print ( MaxTriceSub ( mat ) ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE y1 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE xmin = min ( x1 , y2 ) NEW_LINE ymax = min ( y1 , y2 ) NEW_LINE ymax = min ( y1 , y2 ) NEW_LINE if ( xmax < xmax or xmax < ymax ) or ( ymax < ymax or ymax < ymax ) : NEW_LINE INDENT ymax = max ( ymax , ymax ) NEW_LINE DEDENT else : NEW_LINE INDENT ymax = min ( ymax , ymax ) NEW_LINE DEDENT if ( ymax < ymax or ymax < ymax ) : NEW_LINE INDENT ymax = max ( ymax , ymax ) NEW_LINE DEDENT else : NEW_LINE INDENT ymax = max ( ymax , ymax ) NEW_LINE DEDENT if ( ymax < ymax or ymax < ymax ) : NEW_LINE INDENT ymax = max ( ymax , ymax ) NEW_LINE DEDENT else : NEW_LINE INDENT ymax = min ( ymax , ymax ) NEW_LINE DEDENT if ( ymax < ymax ) : NEW_LINE INDENT ymax = max ( ymax , ymax ) NEW_LINE DEDENT else : NEW_LINE INDENT ymax = min ( ymax , ymax ) NEW_LINE DEDENT if ( ymax < ymax ) : NEW_LINE INDENT ymax = max ( ymax , ymax ) NEW_LINE DEDENT else : NEW_LINE INDENT ymax = min ( ymax , ymax ) NEW_LINE DEDENT DEDENT if ( xmax < xmax ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * 32 NEW_LINE for i in a : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT for i in b : NEW_LINE INDENT if i & ( 1 << i ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = a . copy ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE if b // m > a : NEW_LINE INDENT b = b NEW_LINE DEDENT DEDENT print ( a + 1 ) NEW_LINE
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def replaceArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( neg_sum ) - abs ( i ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] NEW_LINE DEDENT DEDENT arr [ N ] = abs ( diff_sum ) NEW_LINE arr [ i ] = abs ( diff_sum ) NEW_LINE arr [ i ] = abs ( diff_sum ) NEW_LINE printArray ( N , arr [ i ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 , 5 , 1 ] NEW_LINE replaceArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE DEDENT
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def replaceArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( diff_sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , 5 , 1 ] NEW_LINE replaceArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE DEDENT
def countDivisble ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '8' or s [ i ] == '8' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT s = "124" NEW_LINE print ( countDivisble ( s ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if max ( a , b , c ) <= min ( a , b , c ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif n == 4 : NEW_LINE INDENT print ( 7 ) NEW_LINE DEDENT elif n == 4 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 7 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 7 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = " YES " if n == 1 else " NO " NEW_LINE if ( k == a [ 0 ] ) : NEW_LINE INDENT ans = " NO " NEW_LINE DEDENT else : NEW_LINE INDENT ans = " YES " NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE from collections import deque NEW_LINE def solve ( ) : NEW_LINE INDENT dp = [ float ( ' inf ' ) ] * 256 NEW_LINE dp [ 0 ] = 0 NEW_LINE q = deque ( ) NEW_LINE while q : NEW_LINE INDENT dp [ q . pop ( ) ] = dp [ q . pop ( ) ] NEW_LINE q . append ( dp [ q . pop ( ) ] ) NEW_LINE DEDENT return min ( dp [ q . pop ( ) ] * q for q in range ( 256 ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT dp = [ float ( ' inf ' ) ] * 256 NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i ] NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE INDENT for j in range ( 256 ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT dp [ j ] = dp [ j - 1 ] + dp [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = dp [ j - 1 ] + dp [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = int ( stdin . readline ( ) ) NEW_LINE for case in range ( t ) : NEW_LINE INDENT dp [ int ( sys . stdin . readline ( ) ) ] . split ( ) NEW_LINE DEDENT return int ( sys . stdin . readline ( ) ) NEW_LINE DEDENT for case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE l = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE solve ( ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( w , p ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 ) : NEW_LINE INDENT if w [ i ] [ j ] == '1' : NEW_LINE INDENT if p [ i ] [ j ] == '1' : ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT p = [ ] NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 ) : NEW_LINE INDENT if p [ i ] [ j ] == '1' : NEW_LINE INDENT p . append ( i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 ) : NEW_LINE INDENT if p [ i ] [ j ] == '1' : NEW_LINE INDENT if p [ i ] [ j ] == '0' : NEW_LINE INDENT p . append ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( len ( p ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE s = 0 NEW_LINE for i in l : NEW_LINE INDENT s += abs ( i - l [ i ] ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT h [ arr [ i ] ] += 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE if ( len ( h ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( h [ arr [ i ] ] == 1 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printKDistinct ( arr , n , 2 ) NEW_LINE
def fib ( f ) : NEW_LINE INDENT f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , 60 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 NEW_LINE DEDENT DEDENT def findLastDigit ( n ) : NEW_LINE INDENT fib ( f ) NEW_LINE fib ( f ) NEW_LINE index = ( n % 60 ) % 10 NEW_LINE index = ( n % 60 ) % 10 NEW_LINE return f [ index ] NEW_LINE DEDENT n = 1 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = findLastDigit ( n ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = findLastDigit ( n ) NEW_LINE n ) NEW_LINE n = findLastDigit ( n ) NEW_LINE n = : NEW_LINE print ( findLastDigit (
def main ( ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 5 or b == 5 or c == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
N , Z , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT ans = max ( ans , abs ( A [ i + 1 ] - A [ i ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def countEleLessThanOrEqualEqual ( arr1 , arr2 , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr2 [ j ] <= arr1 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 4 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 7 , 1 , 1 ] NEW_LINE countEleLessThanEqual ( arr1 , arr2 , len ( arr2 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 0 ] == a [ 0 ] : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] , b [ i ] = map ( str , input ( ) . split ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT print ( a [ i ] , a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , a [ i ] ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( a [ n // 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ n // 2 ] ) NEW_LINE DEDENT
k , p = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = i + 1 NEW_LINE while True : NEW_LINE INDENT if x == 0 : break NEW_LINE x = x % p NEW_LINE if x == 0 : NEW_LINE INDENT d . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT d . append ( x % p ) NEW_LINE DEDENT DEDENT DEDENT print ( d [ k - 1 ] ) NEW_LINE
from bisect import bisect_left as bl NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = [ a [ i ] - 1 for i in range ( n ) ] NEW_LINE p . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == a [ i ] : NEW_LINE INDENT ans += ( i + 1 ) * ( i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def lps ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for j in range ( 2 , n ) : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( j == l [ i ] and j == l [ j - 1 ] and j == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( L [ i ] == L [ j - 1 ] and L [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GEEKSFORGEEKS " NEW_LINE n = len ( s ) NEW_LINE print ( " The ▁ LargK " , lps ( n ) ) NEW_LINE DEDENT
def printConsecutive ( last , last ) : NEW_LINE INDENT print ( last , last + 1 ) NEW_LINE DEDENT def printConsecutive ( N ) : NEW_LINE INDENT print ( last + 1 ) NEW_LINE for i in range ( 1 , last + 1 ) : NEW_LINE INDENT print ( last , i ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , last + 1 ) : NEW_LINE INDENT for first in range ( last - last ) : NEW_LINE INDENT if 2 * N == ( last - last + 1 ) * ( last + last + 1 ) ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " - 1" , end = " " ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE findConsecutive ( N ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from math import gcd NEW_LINE def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = gcd ( x , y ) NEW_LINE ans = ( x * y ) // ( s * y ) NEW_LINE return ans NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = math . gcd ( x , y ) NEW_LINE ans = ( x * y ) / ( s * s ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 55 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c . append ( ord ( s [ i ] ) ) NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c [ i ] != s [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " aabbbccbccb " NEW_LINE if isAlphabaticOrder ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printKMax ( arr , n , k ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] > max ) : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT DEDENT print ( max , end = " ▁ " ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 7 , 8 , 9 , 10 ] NEW_LINE k = 3 NEW_LINE printKMax ( arr , len ( arr ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LIST ( N ) : return [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE def S_lst ( ) : return list ( input ( ) ) NEW_LINE def S_lst ( ) : return input ( ) NEW_LINE def resolve ( ) : NEW_LINE INDENT n , m = MAP ( ) NEW_LINE a , b = MAP ( ) NEW_LINE b = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT b [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] == 0 : NEW_LINE INDENT ans += ( n - 1 - a [ i ] ) * ( n - 1 - b [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( resolve ( ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 1 + ( m - n ) % n + 1 ) NEW_LINE
N , K = map ( int , input ( ) . split ( ) ) NEW_LINE xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE yy . sort ( ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if xy [ i ] [ j ] <= yy [ i ] [ j ] and xy [ i ] [ j ] <= yy [ i ] [ j ] : NEW_LINE INDENT ans = min ( ans , min ( yy [ i ] [ j ] - yy [ i ] [ j ] ) * ( yy [ i ] [ j ] - yy [ j ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE d = { } NEW_LINE for i in s : NEW_LINE INDENT d [ i ] = i NEW_LINE DEDENT for i in d : NEW_LINE INDENT d [ i ] = i NEW_LINE DEDENT for i in d : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT
def pre_process ( s , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = [ 0 for i in range ( n ) ] NEW_LINE dup [ len ( s ) - 1 ] = dup [ 1 : ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE DEDENT DEDENT size = len ( sub ) NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( sub ) ) : NEW_LINE INDENT if ( sub [ i ] < sub [ j ] ) : NEW_LINE INDENT temp = sub [ i ] NEW_LINE sub [ i ] = sub NEW_LINE DEDENT DEDENT DEDENT size = len ( sub ) NEW_LINE queries = [ 1 , 5 , 10 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( substrings [ queries [ i ] ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geek " NEW_LINE substrings ( s , s ) NEW_LINE DEDENT
def solve ( w , h , w ) : NEW_LINE INDENT x = w - 1 NEW_LINE y = 0 NEW_LINE while True : NEW_LINE INDENT if w == " R " : NEW_LINE INDENT break NEW_LINE DEDENT if w == " S " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif w == " S " : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT elif w == " S " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif w == " S " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif w == " S " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif w == " S " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif w == " S " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif w == " S " : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT DEDENT return x , y NEW_LINE DEDENT while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE w , h = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ w , h ] NEW_LINE l = [ w , h ] NEW_LINE r = [ h , w ] NEW_LINE l = [ w , h ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT l . append ( list ( map ( str , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in l : NEW_LINE INDENT if i [ 0 ] == " S " : NEW_LINE INDENT r . append ( list ( map ( str , r [ 1 ] ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( list ( map ( str , l ) ) ) NEW_LINE DEDENT DEDENT print ( * r ) NEW_LINE D
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif s [ i ] == ' x ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == "0" : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT p1 , p2 , p3 = 0 , 0 , 0 NEW_LINE for c in s : NEW_LINE INDENT if c == " A " : NEW_LINE INDENT p1 += 1 NEW_LINE DEDENT elif c == " B " : NEW_LINE INDENT p1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p1 += 1 NEW_LINE DEDENT DEDENT if p1 > p2 : NEW_LINE INDENT p2 += 1 NEW_LINE DEDENT DEDENT print ( p1 , p2 ) NEW_LINE DEDENT
def fact ( N ) : NEW_LINE INDENT product = 1 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZero = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZero ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT k , x = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 9 * k - 9 ) NEW_LINE DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE higher = l * y NEW_LINE print ( max ( max ( l , right ) , max ( higher , higher ) ) ) NEW_LINE DEDENT L = 8 NEW_LINE B = 8 NEW_LINE Y = 0 NEW_LINE maximumArea ( L , B , Y , B ) NEW_LINE
NO_OF_CHARS = 256 NEW_LINE def maxSubStr ( str , n ) : NEW_LINE INDENT count = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT max_distinct = ord ( str [ i ] ) NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallestSubstr ( str , n ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT max_distinct = ord ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT min_distinct = ord ( str [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return min_distinct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " AAB BEACB " NEW_LINE len1 = len ( str ) NEW_LINE print ( " The ▁ shortest ▁ of ▁ shortest ▁ characters ▁ characters ▁ of ▁ characters ▁ characters ▁ : " , len1 ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s3 = input ( ) NEW_LINE s3 = input ( ) NEW_LINE s4 = input ( ) NEW_LINE s4 = input ( ) NEW_LINE s4 = s1 . split ( " R " ) NEW_LINE s4 = " B " NEW_LINE if ( s1 == " R " ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif ( s2 == " B " ) or ( s3 == " R " ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif ( s3 == " R " ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif ( s3 == " B " ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif ( s4 == " R " ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif ( s4 == " R " ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif ( s4 == " B " ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumberOfEvenCences ( n , q , size ) : NEW_LINE INDENT row = [ 0 ] * n ; NEW_LINE col = [ 0 ] * n ; NEW_LINE col [ 0 ] = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] ; NEW_LINE y = q [ i - 1 ] [ 1 ] ; NEW_LINE row [ y - 1 ] += 1 ; NEW_LINE col [ y - 1 ] += 1 ; NEW_LINE DEDENT r1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE c2 += c2 * c ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] & 1 ) : NEW_LINE INDENT r1 += 1 ; NEW_LINE DEDENT if ( row [ i ] & 1 ) : NEW_LINE INDENT r2 += 1 ; NEW_LINE DEDENT if ( row [ i ] & 1 ) : NEW_LINE INDENT c2 += 1 ; NEW_LINE DEDENT if ( col [ i ] & 1 ) : NEW_LINE INDENT c2 += 1 ; NEW_LINE DEDENT DEDENT count = r1 * c2 + r2 * c2 ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 ; NEW_LINE q = [ [ 1 , 1 ] , [ 1 , 2 ] ] ; NEW_LINE size = len ( q ) ; NEW_LINE print ( findNumberOfEvenCences ( n , q , size ) ) ; NEW_LINE DEDENT
def check_p ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ 1 ] <= arr [ n - 2 ] ) : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE check_p ( arr , n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = s . count ( '1' ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( min ( len ( s ) , n - 1 , c ) ) NEW_LINE DEDENT else : NEW_LINE INDENT c = s . count ( '1' ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == n : NEW_LINE INDENT print ( min ( c , n - 1 , c ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( c , n - 1 , c ) ) NEW_LINE DEDENT DEDENT DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT l . append ( a * i ) NEW_LINE DEDENT l . reverse ( ) NEW_LINE l . reverse ( ) NEW_LINE l . reverse ( ) NEW_LINE if a * l [ 0 ] > l [ 1 ] * l [ 2 ] : NEW_LINE INDENT print ( ' / ' + str ( l [ 1 ] // l [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' % d ' + ( l [ 0 ] // l [ 1 ] ) ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE arr [ j ] , arr [ j ] = temp , arr [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT arr = [ - 1 , 2 , - 3 , 4 , 6 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( arr ) NEW_LINE
def centered_square ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " % d ▁ centered ▁ centered ▁ centered ▁ number : " % " % ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n // 2 ) * k < ( n - 1 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def lenOfLongSubArraySum ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT um [ Sum - k ] = i + 1 NEW_LINE DEDENT if ( Sum - k ) in um : NEW_LINE INDENT um [ Sum - k ] = i + 1 NEW_LINE DEDENT if ( um [ Sum ] in um ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT if ( um [ Sum ] in um ) : NEW_LINE INDENT maxLen = i - um [ Sum ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 2 , - 1 , 3 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ longest ▁ maximum ▁ = ▁ " , len ( arr ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if a [ i ] [ j ] == a [ i ] [ j ] : NEW_LINE INDENT ans = max ( ans , a [ i ] [ j ] * a [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def find ( dividend , divisor , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE if ( n > divisor ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( n > divisor ) : NEW_LINE INDENT start = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n > divisor ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT elif ( n < 0 ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return find ( div , divisor , 1 , end ) NEW_LINE DEDENT def divide ( div , divisor , divisor ) : NEW_LINE INDENT return find ( div , divisor , 1 , divisor ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT div = 10 NEW_LINE divisor = 3 NEW_LINE ans = divide ( div , divisor , 1 , divisor ) NEW_LINE print ( ans , end = " , ▁ " ) NEW_LINE print ( ans , end = " , ▁ " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . append ( a [ 0 ] ) NEW_LINE s = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT s = abs ( a [ i + 1 ] - a [ i ] ) NEW_LINE s = s + abs ( a [ i + 1 ] - a [ i ] ) NEW_LINE DEDENT print ( s , s ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] < a [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT print ( min ( n - sum ( a ) for a in a ) ) NEW_LINE
def towerOfHoid ( n , s ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT tower_hoid ( n - 2 , s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s ) , s ) , s . index ( s . index ( s ) , s . index ( s . index ( s . index ( s . index ( s . index ( s ) , s . index ( s . index ( s . index ( s . index ( s . index ( s . index ( s ) , s . index ( s ) , s ) , s . index ( s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s ) , s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s . index ( s . index ( s ) , s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s . index ( s ) , s . index ( s . index ( s . index ( s ) , s . index ( s ) , s , s . index ( s ) , s . index ( s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s . index ( s ) , s . index ( s , s . index ( s . index ( s ) , s . index ( s . index ( s
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' - ' ) : NEW_LINE INDENT ans += ( ( s [ i ] == ' - ' ) ) NEW_LINE DEDENT elif ( s [ i ] == ' - ' ) : NEW_LINE INDENT ans += ( ( ( s [ i ] == ' - ' ) ) ) NEW_LINE DEDENT elif ( s [ i ] == ' - ' ) : NEW_LINE INDENT ans += ( ( s [ i ] == ' - ' ) ) NEW_LINE DEDENT elif ( s [ i ] == ' - ' ) : NEW_LINE INDENT ans += ( ( s [ i ] == ' - ' ) ) NEW_LINE DEDENT elif ( s [ i ] == ' - ' ) : NEW_LINE INDENT ans += ( ( s [ i ] == ' - ' ) ) NEW_LINE DEDENT DEDENT print ( ans % 1000000007 ) NEW_LINE
q = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT s . append ( input ( ) . split ( ) ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT query = input ( ) NEW_LINE if query [ 0 ] == '0' : NEW_LINE INDENT s . append ( int ( query [ 1 ] ) ) NEW_LINE DEDENT elif query [ 0 ] == '1' : NEW_LINE INDENT s . append ( int ( query [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( query [ 1 ] ) ) NEW_LINE DEDENT DEDENT elif query [ 0 ] == '2' : NEW_LINE INDENT s . remove ( query [ 2 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 2 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 2 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 2 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 2 ] ) NEW_LINE DEDENT DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 2 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT s . remove ( query [ 2 ] ) NEW_LINE DEDENT DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] <= prev ) : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE prev = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + prev NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def findN ( k ) : NEW_LINE INDENT ans = 3 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT elif ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k == 1 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( m ) ) - 1 NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += k * dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] [ k ^ arr [ i - 1 ] ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE
import sys NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from collections import deque NEW_LINE read = sys . stdin . read NEW_LINE read = sys . stdin . read NEW_LINE readline = sys . stdin . readline NEW_LINE readlines = sys . stdin . readlines NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def main ( ) : NEW_LINE INDENT D , C = map ( int , readline ( ) . split ( ) ) NEW_LINE P = [ ] NEW_LINE for i in range ( D ) : NEW_LINE INDENT P . append ( 0 ) NEW_LINE for j in range ( D ) : NEW_LINE INDENT if D & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT P . append ( j ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT D = [ d for i in range ( D ) ] NEW_LINE for i in range ( D ) : NEW_LINE INDENT for j in range ( D ) : NEW_LINE INDENT if P [ i ] [ j ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT d , g = map ( int , readline ( ) . split ( ) ) NEW_LINE ans = solve ( D , D ) NEW_LINE print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) == b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = sorted ( l ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if l [ i ] < l [ i + 1 ] and l [ i ] > l [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
from math import log2 NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = pow ( 2 , log2 ( n ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT table [ j ] = table [ j ] + 1 NEW_LINE DEDENT DEDENT if arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT table [ i ] = table [ j ] + 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > arr [ i ] ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr1 = [ 3 , 4 , 9 , 9 , 1 , 2 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 9 , 10 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( " Length ▁ of ▁ LC ▁ is " , LCIS ( arr1 , n , arr2 , n , m ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += bitCount & 1 NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBits ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 if ( x % 2 == 0 ) else 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Total ▁ bit ▁ count ▁ is ▁ " , countSetBits ( x // 2 ) ) NEW_LINE
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE j = low - 1 NEW_LINE while ( arr [ j ] < pivot ) : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT if ( arr [ j ] > pivot ) : NEW_LINE INDENT return j NEW_LINE DEDENT temp = partition ( arr , low , high ) NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = arr [ j ] NEW_LINE DEDENT def zSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT return j NEW_LINE DEDENT temp = partition ( arr , low , high ) NEW_LINE arr [ low ] = temp NEW_LINE arr [ low ] = temp NEW_LINE arr [ low ] = temp NEW_LINE DEDENT def printArray ( arr , low , high ) : NEW_LINE INDENT for i in range ( 0 , high - 1 , high ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE qSort ( arr , 0 , high ) NEW_LINE printArray ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE while ( j < high - 1 ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] NEW_LINE DEDENT arr [ i + 1 ] , arr [ i ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT DEDENT def partition ( arr , low , high ) : NEW_LINE INDENT i + 1 NEW_LINE if ( low < high ) : NEW_LINE INDENT i + 1 , j = partition ( arr , low , high - 1 ) NEW_LINE DEDENT arr [ i + 1 ] , arr [ i ] = partition ( arr , low - 1 ) NEW_LINE return i + 1 NEW_LINE DEDENT def printArray ( arr , size ) : NEW_LINE INDENT i + 1 NEW_LINE DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE q = [ ] NEW_LINE printArray ( arr , 0 , n - 1 ) NEW_LINE printArray ( arr , 0 , n - 1 ) NEW_LINE printArray ( arr , n - 1 ) NEW_LINE printArray ( arr , n - 1 ) NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_ending_here < max_ending_here ) : NEW_LINE INDENT max_ending_here = max_ending_here NEW_LINE DEDENT if ( max_ending_here < max_ending_here ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_ending_here NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE X = 2 NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE print ( minPossibleSum ( A , N , X ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE DEDENT
def printArray ( N , Sum , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) // 2 NEW_LINE maxSum = minSum NEW_LINE for i in range ( N + 1 , N + 1 ) : NEW_LINE INDENT x = i NEW_LINE y = i NEW_LINE DEDENT Sum = minSum NEW_LINE for i in range ( N + 1 , N + 1 ) : NEW_LINE INDENT x = Sum + ( K - i ) NEW_LINE if ( x < Sum ) : NEW_LINE INDENT Sum = Sum + ( K - i ) NEW_LINE arr [ i ] = K NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = K NEW_LINE K -= 1 NEW_LINE DEDENT DEDENT for i in range ( N + 1 , N + 1 ) : NEW_LINE INDENT arr [ i ] = Sum + ( K - i ) NEW_LINE K -= 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i ] = K - Sum NEW_LINE K -= 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE K -= 1 NEW_LINE DEDENT DEDENT N = 3 NEW_LINE K = 8 NEW_LINE printArray ( N , Sum , K ) NEW_LINE
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // CY NEW_LINE x1 = y // CY NEW_LINE y2 = y // CY NEW_LINE type3 = min ( x , y ) NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE return maxItems NEW_LINE DEDENT x = 4 NEW_LINE y = 5 NEW_LINE z = 6 NEW_LINE print ( maxItems ( x , y , z ) ) NEW_LINE
def solve_tuple ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) != 0 ) : NEW_LINE INDENT x = A [ 0 ] NEW_LINE y = B [ 1 ] NEW_LINE if ( x == y ) : NEW_LINE INDENT A [ 0 ] , B [ 1 ] = B [ 2 ] , B [ 1 ] NEW_LINE total_time += 2 NEW_LINE DEDENT else : NEW_LINE INDENT A [ 0 ] , B [ 1 ] = 1 , 2 NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT A = [ 3 , 2 , 4 , 1 ] NEW_LINE B . append ( 4 ) NEW_LINE A . append ( 4 ) NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 4 ) NEW_LINE print ( total_time ) NEW_LINE
def line ( x0 , y0 ) : NEW_LINE INDENT c = ( 2 * y0 ) NEW_LINE print ( " % d ▁ = ▁ " % d " % ( x0 * x0 ) , " y ▁ = ▁ " , c ) NEW_LINE DEDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE line ( x0 , y0 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = [ ] NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT a . append ( s [ j ] ) NEW_LINE DEDENT b = set ( a ) NEW_LINE c = 0 NEW_LINE for i in b : NEW_LINE INDENT if i not in a : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import sys NEW_LINE from math import sqrt , pi , sin , cos , radians NEW_LINE from itertools import accumulate , permutations , combinations , product NEW_LINE from collections import deque , defaultdict NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heappush , heappop NEW_LINE from math import sqrt , pi , sin , cos , radians NEW_LINE from collections import defaultdict NEW_LINE from operator import itemgetter NEW_LINE from itertools import permutations NEW_LINE from collections import deque NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heapify , heappop NEW_LINE from functools import reduce NEW_LINE import string NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def pprint ( * a , b , c , d , e ) : return [ [ [ a , b , c , d ] for a , b , c in zip ( * a ) ] NEW_LINE def lcm ( x , y , x , y ) : return ( x * b - y ) // ( y ) NEW_LINE def S ( ) : return ( * x - y ) // ( y - y ) // ( y - x ) NEW_LINE def S ( ) : return ( * x - y ) // ( y - y ) NEW_LINE def S ( ) : return * x + y * y NEW_LINE def S ( ) : return input ( ) . split ( ) NEW
def isNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( unique ) > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = " aaaabab " NEW_LINE if ( isNotPalindrome ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ n // 2 ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE d = [ ] NEW_LINE s . append ( ' North ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d . append ( a ) NEW_LINE DEDENT s . sort ( ) NEW_LINE d . append ( ' North ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] == ' North ' : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT elif d [ i ] == ' South ' : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT if d [ i ] == ' East ' : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == ' East ' : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 1 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT if d [ i ] == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE IND
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a1 = 6 NEW_LINE b1 = 3 NEW_LINE c1 = 2 NEW_LINE k1 = 7 NEW_LINE if ( canBeEqual ( a1 , b1 , c1 , c1 , k1 , k1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from collections import deque NEW_LINE adjacency = [ 0 ] * ( 2 * ( 2 * ( 2 ) ) ) NEW_LINE def dfs ( node , node , vis ) : NEW_LINE INDENT adjacency [ node ] = 1 NEW_LINE vis [ node ] = 1 NEW_LINE vis [ node ] = 1 NEW_LINE for i in adjacency . values ( ) : NEW_LINE INDENT if vis [ i ] == 0 : NEW_LINE INDENT dfs ( adj , vis , vis ) NEW_LINE DEDENT DEDENT if len ( adjacency [ node ] ) == 0 : NEW_LINE INDENT vis [ node ] = 1 NEW_LINE vis [ node ] = 1 NEW_LINE DEDENT if len ( adjacency [ node ] ) == 0 : NEW_LINE INDENT vis [ node ] = 1 NEW_LINE vis [ node ] = 1 NEW_LINE DEDENT if len ( adjacency [ node ] ) == 0 : NEW_LINE INDENT dfs ( adj , vis , vis ) NEW_LINE DEDENT DEDENT def printLeaf ( n , parent , vis , vis ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " ▁ node ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ node " % dfs ( i , parent , vis [ i ] , vis ) , " ▁ % ▁ node " % dfs ( i , parent , vis , vis ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE parent = [ 0 ] * ( N + 1 ) NEW_LINE printLeaf ( 1 , parent , parent , parent , vis ) NEW_LINE DEDENT
n , k = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s1 = s1 . count ( s2 ) NEW_LINE s2 = s2 . count ( s1 ) NEW_LINE s3 = s1 . count ( s2 ) NEW_LINE s3 = s3 . count ( s1 ) NEW_LINE s3 = s3 . count ( s3 ) NEW_LINE if ( s1 in s3 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s3 ) NEW_LINE DEDENT
def lcsOf3 ( X , Y , Z , m , n , o , n , o , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 or j == 0 or j == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] [ j - 1 ] == Y [ i - 1 ] and Y [ i - 1 ] [ k - 1 ] == Z [ j - 1 ] [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j - 1 ] , L [ i ] [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j - 1 ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " AACTAB " NEW_LINE Y = "12BAY " NEW_LINE n = len ( X ) NEW_LINE o = "12BAY " NEW_LINE o = "12BAY " NEW_LINE n = len ( Y ) NEW_LINE o = "12BAY " NEW_LINE print ( " Length ▁ of ▁ LCS ▁ is " , l , o , n , o , n , o , o ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT s += abs ( l [ i + 1 ] - l [ i ] ) NEW_LINE DEDENT print ( s ) NEW_LINE
def isSpilingPossible ( n , a ) : NEW_LINE INDENT sum = 0 ; c1 = 0 ; c1 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT if ( sum % 2 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( sum % 2 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT n = 3 ; a = [ 1 , 1 , 2 ] ; NEW_LINE if ( isSpipePossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 1 : NEW_LINE INDENT a . append ( l [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( l [ i ] ) NEW_LINE DEDENT DEDENT a . append ( l [ 0 ] ) NEW_LINE a . append ( l [ - 1 ] ) NEW_LINE print ( max ( a ) ) NEW_LINE
def count_even_odd ( min , max , steps , steps , k ) : NEW_LINE INDENT a , b , a , k = 0 , 0 , 0 NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] NEW_LINE b = steps [ i ] [ 1 ] NEW_LINE if ( a or b & 1 ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT if ( ( ( b & 1 ) > 0 ) ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT if ( ( ( b & 1 ) > 0 ) ) : NEW_LINE INDENT if ( ( ( b & 1 ) > 0 ) ) : NEW_LINE INDENT if ( ( ( b & 1 ) > 0 ) ) : NEW_LINE INDENT G = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT G = ( b & 1 ) + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT even += max ( g - 1 + 1 - min ( min - 1 , min - 1 ) // 2 + 1 ) // 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT even += max ( min - min - 1 + 1 , even - 1 ) // 2 + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT even += max - min ( min - min , even - 1 ) // 2 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT min = 1 NEW_LINE max_even_odd = 4 NEW_LINE steps = [ 1 , 2 ] NEW_LINE steps = [ [ 1 , 2 ] , [ 3
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n // k + 1 ) * k ) NEW_LINE
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime_factors = [ 0 ] * ( B + 1 ) NEW_LINE p = 2 NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if p_factors [ p ] == 0 : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( A , B + 1 , p ) : NEW_LINE INDENT if p_factors [ i ] == K : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE
def reverseWords ( s ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT st . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( len ( st ) == 0 ) : NEW_LINE INDENT print ( st [ - 1 ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT while ( len ( st ) == 0 ) : NEW_LINE INDENT print ( st [ - 1 ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " Geeks ▁ for ▁ Geeks " NEW_LINE reverseWords ( s ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif c == 0 : NEW_LINE INDENT print ( int ( a [ 0 ] ) // ( a [ 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( a [ 0 ] ) // ( a [ 1 ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n <= 3 : NEW_LINE INDENT print ( 2 , 2 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT print ( 2 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
from collections import deque NEW_LINE def cal ( s ) : NEW_LINE INDENT x = deque ( s ) NEW_LINE y = deque ( ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] == ' + ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif x [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT elif y [ i ] == ' - ' : NEW_LINE INDENT y . append ( y [ i ] ) NEW_LINE DEDENT DEDENT return y NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) . strip ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT print ( cal ( s ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( k - ( n * ( k + 1 ) // n ) ) // n ) NEW_LINE
def findNthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT def findNthTerm ( N ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( int ( 2 ** n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n / 2 ) + 1 NEW_LINE print ( int ( int ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) // 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( ( len - 1 ) * len ) // 2 ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNonIncreasing ( arr , n ) ) NEW_LINE DEDENT
def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 ] * n ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i + 1 ] ; NEW_LINE sum += A1 [ i ] ; NEW_LINE DEDENT temp = - 1 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( c [ i ] < c [ i + 1 ] ) : NEW_LINE INDENT temp = c [ i ] ; NEW_LINE c [ i + 1 ] = temp ; NEW_LINE DEDENT DEDENT maxi = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] ; NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( sum , maxi ) ; NEW_LINE DEDENT DEDENT return maxi ; NEW_LINE DEDENT A1 = [ 1 , 2 , 3 , 4 , 2 , 1 ] ; NEW_LINE A2 = [ 5 , 4 , 3 , 2 , 1 ] ; NEW_LINE n = 5 ; NEW_LINE x = 3 ; NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = list ( map ( int , s ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT c += 10 NEW_LINE DEDENT else : NEW_LINE INDENT c += 10 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
from collections import deque NEW_LINE N = int ( input ( ) ) NEW_LINE G = [ [ [ 0 for j in range ( N ) ] for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( " , " ) ) NEW_LINE G [ a - 1 ] [ b - 1 ] = c NEW_LINE DEDENT M = int ( input ( ) ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT s , d , v , d = map ( int , input ( ) . split ( " , " ) ) NEW_LINE G [ s - 1 ] [ d - 1 ] [ v ] = d NEW_LINE DEDENT V = int ( input ( ) ) NEW_LINE V . append ( 0 ) NEW_LINE V . append ( 0 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s , d , v , d = map ( int , input ( ) . split ( " , " ) ) NEW_LINE G [ s - 1 ] [ d - 1 ] = V [ s - 1 ] [ d - 1 ] + d NEW_LINE DEDENT V . sort ( ) NEW_LINE ans = V [ 0 ] [ 0 ] - V [ 1 ] [ 0 ] - V [ 1 ] [ 0 ] NEW_LINE print ( ans ) NEW_LINE
r1 , c1 , r2 , c1 , c2 , c2 = map ( int , input ( ) . split ( ) ) NEW_LINE a = ( c1 + c2 + c2 ) // 2 NEW_LINE b = c2 + c2 NEW_LINE c3 = c1 + c2 NEW_LINE d = c2 + c2 NEW_LINE e = d3 + c1 NEW_LINE if d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or d < 0 or a < 0 or a > 0 or a > 0 or a > d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif a > d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif a == c1 or d == a or d == c1 : NEW_LINE INDENT print ( a , d ) NEW_LINE DEDENT elif a == d or a == c1 or a == c1 or d == c1 or a == c1 or d == c2 : NEW_LINE INDENT print ( a , d ) NEW_LINE DEDENT elif a == d or a == c1 or a == c1 or a == c1 or a == c1 or a == c1 or a == c1 or a == c2 or
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def bfs ( x , w ) : NEW_LINE INDENT global sum ( x ) NEW_LINE if x in sum ( x ) : NEW_LINE INDENT return x + sum ( x - sum ( x ) for x in x ) NEW_LINE DEDENT return sum ( x - sum ( x ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE w . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT w . append ( int ( i ) ) NEW_LINE DEDENT w . sort ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT w . sort ( ) NEW_LINE if w [ i ] == 0 : NEW_LINE INDENT ans . append ( w [ i ] - w [ i ] ) NEW_LINE DEDENT DEDENT w . sort ( ) NEW_LINE if len ( ans ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) . split ( ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT c = min ( c , s [ i ] ) NEW_LINE DEDENT elif s [ i ] == ' B ' : NEW_LINE INDENT c = min ( c , s [ i ] ) NEW_LINE DEDENT elif s [ i ] == ' C ' : NEW_LINE INDENT c = min ( c , s [ i ] ) NEW_LINE DEDENT DEDENT if c == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT
def startWith ( string , pre ) : NEW_LINE INDENT stringLen = len ( string ) ; NEW_LINE preLen = len ( string ) ; NEW_LINE i = 0 ; j = 0 ; NEW_LINE while ( i < preLen and j < preLen and stringLen ) : NEW_LINE INDENT if ( string [ i ] != preLen ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def fillString ( string , suffix ) : NEW_LINE INDENT i = len ( string ) - 1 ; NEW_LINE j = len ( string ) - 1 ; NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if ( string [ i ] != suffix [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i -= 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT if ( start != len ( string ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( start != len ( string ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( start != len ( string ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksforGeeks " ; NEW_LINE a = " geeksforgeeks " ; b = " geeksforgeeks " ; NEW_LINE b = " geeksforgeeks " ; NEW_LINE if ( checkString ( string , a , b ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , " ▁ " , j , " k " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 NEW_LINE printCombination ( n ) NEW_LINE
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT for k in range ( 0 , ( n - i - j ) + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if sum % T == 0 : NEW_LINE INDENT return ( n * T - ( sum % T ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * T - ( sum % T ) + extra ) NEW_LINE DEDENT DEDENT def firstTerm ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE firstTerm ( n ) NEW_LINE DEDENT
def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def powInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE while ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , N // 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT maxProduct ( 10 ) NEW_LINE print ( maxProduct ( 10 ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( n ) : NEW_LINE INDENT ans = 2 NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans += n // i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = solve ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
s = input ( ) NEW_LINE if s [ 0 ] == "2019" : NEW_LINE INDENT print ( s [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 2 ] ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def firstNonRepeating ( str ) : NEW_LINE INDENT chCount = [ 0 ] * MAX_CHAR NEW_LINE q = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE chCount [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE while ( ord ( ch ) > 0 ) : NEW_LINE INDENT if ( chCount [ ord ( ch ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT chCount [ ord ( ch ) - ord ( ' a ' ) ] -= 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT chCount [ ord ( ch ) - ord ( ' a ' ) ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( len ( q ) == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aaa " NEW_LINE firstNonRepeating ( str ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE graph = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT def dfs ( node ) : NEW_LINE INDENT global graph NEW_LINE graph [ node ] . append ( node ) NEW_LINE return NEW_LINE DEDENT def dfs ( node ) : NEW_LINE INDENT global graph NEW_LINE graph [ node ] . append ( node ) NEW_LINE DEDENT def dfs ( node , graph , visited , visited , visited , visited , visited , visited , visited ) : NEW_LINE INDENT if node not in graph [ node ] : NEW_LINE INDENT dfs ( node , visited , visited , visited ) NEW_LINE DEDENT DEDENT return graph NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if graph [ i ] == 0 : NEW_LINE INDENT ans += dfs ( graph , visited , visited , visited , visited , visited , visited , visited ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def solve ( n , m , holes , holes ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE range = 1 NEW_LINE range = ( holes - 1 , - 1 , - 1 ) NEW_LINE c = 1 NEW_LINE for i in range ( holes - 1 , - 1 , - 1 ) : NEW_LINE INDENT range = 2 * ( r [ i ] ) NEW_LINE val -= r [ i ] NEW_LINE val -= r [ i ] NEW_LINE if ( val > 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE holes = 3.0 NEW_LINE holes = 3.0 NEW_LINE print ( solve ( n , m , holes , holes ) ) NEW_LINE
s = input ( ) NEW_LINE a = int ( s [ 0 ] ) NEW_LINE b = int ( s [ 1 ] ) NEW_LINE c = int ( s [ 2 ] ) NEW_LINE d = int ( s [ 2 ] ) NEW_LINE i = 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if a [ i ] == ' + ' : NEW_LINE INDENT c += int ( s [ i ] ) NEW_LINE DEDENT elif a [ i ] == ' + ' : NEW_LINE INDENT c += int ( s [ i ] ) NEW_LINE DEDENT elif a [ i ] == ' + ' : NEW_LINE INDENT d += int ( s [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if b == c : NEW_LINE INDENT d += int ( s [ i ] ) NEW_LINE DEDENT if a == b : NEW_LINE INDENT print ( ' L ' ) NEW_LINE DEDENT elif a == c : NEW_LINE INDENT print ( ' L ' ) NEW_LINE DEDENT elif a == c : NEW_LINE INDENT print ( ' L ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' L ' ) NEW_LINE DEDENT
class Stack : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( stack . pop ( ) ) NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT stack . append ( x ) NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE push ( x , stack . pop ( ) ) NEW_LINE push ( x , stack . pop ( ) ) NEW_LINE DEDENT def push ( stack , push ( 0 , stack ) : NEW_LINE INDENT push ( stack , stack . pop ( ) ) NEW_LINE push ( stack , stack . pop ( ) ) NEW_LINE DEDENT push ( - 3 ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 , stack . pop ( ) ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 , stack . pop ( ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE push ( - 3 ) NEW_LINE
def convertToWords ( n ) : NEW_LINE INDENT one = [ " " , " one " , " two " , " three " , " three " , " three " , " three " , " three " , " three " , " four " , " three " , " four " , " four " , " four " , " five " , " eleven " , " eleven " , " thirteen " , " fourteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " eighteen " ] NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT s = " " NEW_LINE ten = one [ " " ] NEW_LINE if n > 19 : NEW_LINE INDENT s += one [ n // 10 ] NEW_LINE one += one [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT s += one [ n // 10 ] NEW_LINE DEDENT return s NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s += one [ n // 10 ] NEW_LINE if n > 0 : NEW_LINE INDENT s += s NEW_LINE DEDENT elif n > 0 : NEW_LINE INDENT s += s NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4382345 NEW_LINE s = " " NEW_LINE print ( convertToWords ( n ) ) NEW_LINE DEDENT
def flipNegative ( a , b ) : NEW_LINE INDENT neg = 0 NEW_LINE temp = 0 NEW_LINE temp = - 1 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT neg += temp NEW_LINE a = temp + temp NEW_LINE DEDENT return neg NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipNegative ( b ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipNegative ( b ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipNegative ( abs ( a ) ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipDigits ( abs ( b ) ) NEW_LINE DEDENT def divide ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return divideDigit ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT return divideDigit ( abs ( a ) , a ) NEW_LINE DEDENT DEDENT def divide ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return divideDigit ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT return divideDigit ( b , a ) NEW_LINE DEDENT DEDENT def divide ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return divideDigit ( - 9 , - 2 , 6 ) NEW_LINE DEDENT else : NEW_LINE INDENT return divideDigit ( - 9 , b ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " Subplement ▁ % d ▁ % d ▁ % d " % d ▁ % d " % ( 4 , divide ( 8 , 2 ) ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE fact = 1 NEW_LINE while ( n // i != n ) : NEW_LINE INDENT fact = fact * i - 1 NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT num = 5 NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( 5 ) ) NEW_LINE
def CntDivByX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( number % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivByX ( arr , n , x ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in a : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT for i in d . values ( ) : NEW_LINE INDENT if i not in d . keys ( ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT print ( sum ( d ) ) NEW_LINE
def min_of_element ( arr , n , k ) : NEW_LINE INDENT noOfSubsequualtuple = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtuple = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtuple += 1 NEW_LINE if ( arr [ i ] - arr [ i - 1 ] > k ) : NEW_LINE INDENT noOfSubtuple += 1 NEW_LINE DEDENT DEDENT arr [ i ] = arr [ i ] - k * noOfSubtuple NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = 4 NEW_LINE k = 5 NEW_LINE print ( min_of_element ( arr , N , k ) ) NEW_LINE DEDENT
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = 2 ** n NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 ] NEW_LINE X = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubSet ( arr , n , X ) ) NEW_LINE
def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j - 1 ] * arr [ i - 1 ] [ j - 1 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT result = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= result : NEW_LINE INDENT result = arr [ i ] [ j - 1 ] * arr [ i - 2 ] [ j - 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT if ( i - 3 ) >= result : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 2 ] [ j - 3 ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 4 , 5 , 1 , 1 ] , [ 6 , 7 , 8 , 1 , 1 ] , [ 7 , 8 , 1 , 1 , 1 ] , [ 7 , 8 , 1 , 1 , 1 ] ] NEW_LINE n = 5 NEW_LINE print ( FindMaxProduct ( arr , n ) ) NEW_LINE DEDENT
MAX = 50002 NEW_LINE primes = [ False ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = True NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT isPrime [ p ] = True NEW_LINE DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE z = y NEW_LINE while ( x >= z ) : NEW_LINE INDENT count += ( x // z ) NEW_LINE z *= y NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT count += ( x // z ) % p NEW_LINE DEDENT return count % p NEW_LINE DEDENT def modMult ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT ans = ( ans + a ) % m NEW_LINE DEDENT DEDENT return ans % m NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE n = 4 NEW_LINE m = 7 NEW_LINE print ( countWays ( n , m ) ) NEW_LINE DEDENT
def smallestIndex ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( i + 1 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestIndex ( arr , n ) ) NEW_LINE
import sys NEW_LINE def hm , mm = map ( int , input ( ) . split ( ) ) NEW_LINE s = hm + mm NEW_LINE d = s [ 0 ] + s [ 1 ] * 60 NEW_LINE d = s [ 2 ] - s [ 3 ] NEW_LINE e = s [ 3 ] - s [ 4 ] NEW_LINE d = s [ 5 ] - d * 60 NEW_LINE print ( d ) NEW_LINE
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == " Q " : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif s [ i ] == " Q " : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE readlines = sys . stdin . readlines NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE write = sys . stdout . write NEW_LINE N , K = map ( int , readline ( ) . split ( ) ) NEW_LINE A = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE dp = [ [ 0 ] * ( K + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( K + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( K + 1 ) : NEW_LINE INDENT if j + A [ i ] [ j ] <= K : NEW_LINE INDENT dp [ i + 1 ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp [ K : ] ) ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE z = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT z += i * i NEW_LINE if z >= s : NEW_LINE INDENT z += s NEW_LINE DEDENT DEDENT print ( z ) NEW_LINE
def multiply ( x ) : NEW_LINE INDENT carry = 0 NEW_LINE size = len ( x ) NEW_LINE size = len ( x ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + x NEW_LINE carry = res % 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT res = carry + carry NEW_LINE carry = res // 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def findSumOfDigits ( n ) : NEW_LINE INDENT v = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT v . append ( carry % 10 ) NEW_LINE carry = res % 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1000 NEW_LINE print ( findSumOfDigits ( n ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE x , y = s [ 0 ] , s [ 1 ] NEW_LINE if x % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT if x % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if x % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if x % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT DEDENT print ( * x , sep = ' ▁ ' ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( s ) NEW_LINE DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( l ) NEW_LINE r -= 1 NEW_LINE if l [ r ] == 0 : NEW_LINE INDENT print ( * l ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * l ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT s [ i ] = a [ i + 1 ] NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT s [ i ] = max ( s [ i + 1 ] , s [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT s [ i ] = s [ i + 1 ] - a [ i ] + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT s [ i ] = s [ i + 1 ] - a [ i ] + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 , - 1 ) : NEW_LINE INDENT s [ i ] = s [ i + 1 ] - a [ i ] + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT s [ i ] = s [ i ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 , - 1 ) : NEW_LINE INDENT s [ i ] = s [ i ] - a [ i ] + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT s [ i ] = s [ i ] - a [ i ] NEW_LINE DEDENT for i in s : NEW_LINE INDENT s [ i ] = s [ i ] NEW_LINE DEDENT DEDENT print ( * s ) NEW_LINE
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * pell ( n - 1 ) + pell ( n - 2 ) + pell ( n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( n // 2 , end = ' ▁ ' ) NEW_LINE for i in range ( 1 , n * n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n // 2 , end = ' ▁ ' ) NEW_LINE DEDENT print ( n // 2 , end = ' ▁ ' ) NEW_LINE DEDENT
def printSmall ( arr , size ) : NEW_LINE INDENT copy_arr = [ ] NEW_LINE copy_arr . sort ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( copy_arr [ i ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT def printSmall ( arr , size ) : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 7 , 7 , 2 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printSmall ( arr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 2 , 1 , 0 ] NEW_LINE n = 5 NEW_LINE printSmall ( arr , n ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE k += 1 NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = min ( a ) NEW_LINE d = min ( b ) NEW_LINE if c % d == 0 : NEW_LINE INDENT d = c // d NEW_LINE DEDENT else : NEW_LINE INDENT d = c // d NEW_LINE DEDENT print ( d ) NEW_LINE
max = 10 ** 9 NEW_LINE def buildBits ( x ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def dfs ( node , parent , parent ) : NEW_LINE INDENT a = self . bit_pop ( weight ) NEW_LINE if ( maximum < a ) : NEW_LINE INDENT maximum = a NEW_LINE DEDENT elif ( maximum < a ) : NEW_LINE INDENT maximum = a NEW_LINE DEDENT elif ( maximum < a ) : NEW_LINE INDENT maximum = a NEW_LINE DEDENT elif ( maximum == a ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( maximum == a ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( maximum == a ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( maximum == a ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( maximum == a ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( root , parent ) NEW_LINE DEDENT return dfs ( root , parent ) NEW_LINE DEDENT x = 15 NEW_LINE weight = [ ] NEW_LINE weight . append ( 2 ) NEW_LINE weight . append ( 3 ) NEW_LINE weight . append ( 4 ) NEW_LINE weight . append ( 4 ) NEW_LINE weight . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE print ( ans ) NEW_LINE
MAX = 26 NEW_LINE def updateFreq ( str , freq ) : NEW_LINE INDENT len = len ( str ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def maxCount ( str , pp ) : NEW_LINE INDENT str = [ 0 ] * MAX NEW_LINE updateFreq = [ 0 ] * MAX NEW_LINE updateFreq [ 0 ] = 0 NEW_LINE updateFreq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE updateFreq [ ord ( str [ i ] ) ] = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( pp [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( pp [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , str [ i ] // pp [ i ] // pp [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE pp = " geeksforgeeks " NEW_LINE print ( maxCount ( str , pp ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n , l , l , r , l , r = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( w ) NEW_LINE ans = 10 ** 9 + w NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += w [ i ] NEW_LINE DEDENT ans = min ( ans , ( s - l + 1 ) * l + w [ n ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT s += w [ j ] NEW_LINE DEDENT ans = min ( ans , s ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def wastedWater ( V , M , N ) : NEW_LINE INDENT wasted_total = M - N NEW_LINE total_pal_palts = M - N NEW_LINE return wasted_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual_tual ( V , M , N ) NEW_LINE DEDENT V = 700 NEW_LINE N = 10 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE
def maxSubStr ( s , n ) : NEW_LINE INDENT count0 = 0 ; count1 = 0 ; cnt = 0 ; cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 ; NEW_LINE DEDENT if ( count0 == count1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( count0 != count1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "010011010101" ; NEW_LINE n = len ( str ) ; NEW_LINE print ( maxSubStr ( str , n ) ) ; NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE x = min ( a , b ) NEW_LINE y = max ( a , b , c ) NEW_LINE print ( x , y ) NEW_LINE
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , s ) : NEW_LINE INDENT sum += n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def maximumAbsolute ( arr , n ) : NEW_LINE INDENT mn = 10 ** 9 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = min ( mn , arr [ i - 1 ] ) NEW_LINE DEDENT if ( i < n - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = min ( mn , arr [ i + 1 ] ) NEW_LINE DEDENT DEDENT return mx NEW_LINE DEDENT arr = [ - 1 , - 1 , 11 , - 1 , 3 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumAbsolute ( arr , n ) ) NEW_LINE
MOD = 1000000007 NEW_LINE def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] %= MOD NEW_LINE dp [ i ] [ 2 ] %= MOD NEW_LINE dp [ i ] [ 2 ] %= MOD NEW_LINE dp [ i ] [ 2 ] %= MOD NEW_LINE dp [ i ] [ 2 ] %= MOD NEW_LINE dp [ i ] [ 2 ] %= MOD NEW_LINE DEDENT ans = ( dp [ N ] [ N ] [ 0 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT N = 3 NEW_LINE print ( countStrings ( N ) ) NEW_LINE
def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE max_length = [ 0 for i in range ( n ) ] NEW_LINE max_length = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE lower = min ( 0 , curr - k ) NEW_LINE for j in range ( low , high + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length + 1 ) NEW_LINE DEDENT max_length = min ( dp [ i ] , max_length ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( dp [ i ] ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE print ( longest_subseq ( n , k , s ) ) NEW_LINE
def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT lenx = 2 NEW_LINE mxx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] + a [ i - 1 ] : NEW_LINE INDENT lenx = len ( mx ) NEW_LINE DEDENT else : NEW_LINE INDENT lenx = 2 NEW_LINE DEDENT mx = max ( mx , lenx ) NEW_LINE mx = max ( mx , lenx ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE
def minimumSubarrays ( ar , n ) : NEW_LINE INDENT se = [ ] NEW_LINE cnt = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ar [ i ] in se . keys ( ) ) : NEW_LINE INDENT se . append ( ar [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE se . append ( ar [ i ] ) NEW_LINE se . append ( ar [ i ] ) NEW_LINE se . append ( ar [ i ] ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 1 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( minimumSubarrays ( ar , n ) ) NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE r = 0 NEW_LINE i = 0 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = r // 10 NEW_LINE freq [ r ] += 1 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT r = s % 10 NEW_LINE if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sm = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm += l [ i ] NEW_LINE if sm % m : NEW_LINE INDENT sm += ( sm % m ) NEW_LINE DEDENT DEDENT print ( sm // m ) NEW_LINE
MAXN = 1000005 NEW_LINE def preCompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT even [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i - 1 ] + even [ i - 1 ] NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] NEW_LINE DEDENT DEDENT def isOdd ( L , R , m ) : NEW_LINE INDENT cnt = odd [ R ] NEW_LINE if ( L > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isQueries ( a , n , q , m ) : NEW_LINE INDENT cnt = odd [ R ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT L = q [ i ] NEW_LINE R = q [ i ] NEW_LINE R = q [ i ] NEW_LINE R = q [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT L = q [ i ] NEW_LINE R = q [ i ] NEW_LINE R = q [ i ] NEW_LINE if ( isOdd ( L , R , q , R ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ [ 2 , 1 , 2 , 5 , 7 ] , [ 2 , 2 , 3 , 6 ] , [ 3 , 6 , 6 , 8 ] ] NEW_LINE n = len ( a ) NEW_LINE q = len ( a ) NEW_LINE performQueries ( a , n , q , m ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 7 == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif n % 7 == 0 : NEW_LINE INDENT print ( n // 7 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 7 ) NEW_LINE DEDENT DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE d = map ( int , input ( ) . split ( ) ) NEW_LINE x = a * 60 + b NEW_LINE y = b * 60 + c NEW_LINE c = 0 NEW_LINE while x > 0 and y > 0 : NEW_LINE INDENT x = x % 60 NEW_LINE y = y + b NEW_LINE c += d NEW_LINE x = x % 60 NEW_LINE DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT x . append ( a [ i - 1 ] ) NEW_LINE DEDENT DEDENT if len ( x ) == 1 or len ( x ) == 2 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 ; previous_level = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level + steps [ i ] ; NEW_LINE current_level = current_level + steps [ i ] ; NEW_LINE if ( previous_level < 0 and current_level > 0 and current_level <= 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT steps = [ 1 , - 1 , 0 , 1 , 1 , 1 , - 3 ] ; NEW_LINE n = len ( steps ) ; NEW_LINE print ( times ( steps , n ) ) ; NEW_LINE
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return list ( map ( list , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE inf = float ( ' inf ' ) NEW_LINE n = II ( ) NEW_LINE n = II ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c , d = LI ( ) NEW_LINE a -= 360 * 360 NEW_LINE b -= 360 * 360 NEW_LINE d -= 360 NEW_LINE d -= 360 NEW_LINE d -= 360 NEW_LINE DEDENT d = [ INF ] * 360 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d [ i ] = min ( d [ i ] , d [ j ] ) NEW_LINE DEDENT DEDENT ans = inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = min ( ans , d [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += p [ i ] - 1 NEW_LINE DEDENT if ( n - x ) % 2 == 0 : NEW_LINE INDENT print ( " Kilu " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Nikik " ) NEW_LINE DEDENT
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i , j , s = 0 , 0 , 0 NEW_LINE min_num = sys . maxsize NEW_LINE pos = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if sum == k : NEW_LINE INDENT min_num = min ( min_num , ( n - ( i + 1 ) + j ) ) NEW_LINE pos += 1 NEW_LINE DEDENT elif ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( n - ( i + 1 ) + j ) ) NEW_LINE pos = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( s == k ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( sum ( [ 1 for i in range ( len ( s ) ) if s [ i ] == '0' ] ) ) NEW_LINE
def nthPalindrome ( n , k ) : NEW_LINE INDENT temp = pow ( 10 , temp ) ; NEW_LINE temp = pow ( 10 , temp ) ; NEW_LINE palindrome = ( temp // 2 ) ; NEW_LINE print ( palindrome ) ; NEW_LINE DEDENT def nthPalindrome ( n , k ) : NEW_LINE INDENT temp = pow ( 10 , temp ) ; NEW_LINE palindrome = ( 10 ** temp ) ; NEW_LINE palindrome = ( 10 ** temp ) ; NEW_LINE print ( " % d ▁ = " % d " , end = " ▁ " ) ; NEW_LINE n = 10 - 1 ; NEW_LINE print ( " % d ▁ = " % d " % 10" , end = " " ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE k = 6 ; NEW_LINE n = 6 ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE n = 6 ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPalindrome ( n , k ) ; NEW_LINE nthPal
import sys NEW_LINE import numpy as np NEW_LINE def solve ( N : int , X : int , X : " List [ int ] " ) : NEW_LINE INDENT X = sum ( X ) NEW_LINE X . append ( X ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT X . append ( X [ i - 1 ] + X [ i ] ) NEW_LINE DEDENT ans = X [ 0 ] + X [ N - 1 ] NEW_LINE for i in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT ans += X [ i ] - X [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N , X = map ( int , input ( ) . split ( ) ) NEW_LINE X = X [ 0 ] + X [ N - 1 ] NEW_LINE X . append ( X [ N - 1 ] ) NEW_LINE ans = X [ N - 1 ] + X [ N - 1 ] NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT X . append ( X [ i ] - X [ i - 1 ] ) NEW_LINE DEDENT ans = X [ N - 1 ] + X [ N - 1 - 1 ] NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans += X [ i ] - X [ i - 1 ] NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 10000 NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE hashTable = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] != 0 ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT res += 1 NEW_LINE DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 8 , 21 , 23 , 48 , 48 , 48 , 48 , 48 , 48 , 48 , 48 , 48 , 48 , 48 , 48 , 48 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for d in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT for d in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if n % 10 == d * 10 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans *= n NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPairs ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return int ( pow ( 2 , c ) ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPairs ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a - 1 , b ) * max ( a , b ) ) NEW_LINE DEDENT
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( arr [ i ] , i ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE vis = [ False ] * n NEW_LINE vis [ 0 ] = True NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] or arr [ i ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT vis [ i ] = True NEW_LINE j = i NEW_LINE while ( j != 0 ) : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = i NEW_LINE DEDENT if ( vis [ j ] or vis [ j ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT vis [ j ] = True NEW_LINE j = i NEW_LINE while ( vis [ j ] != i ) : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = i NEW_LINE DEDENT if ( vis [ j ] == i ) : NEW_LINE INDENT ans += ( vis [ j ] - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 1 , 5 , 4 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( minSwaps ( a ) ) NEW_LINE
N = 1000005 NEW_LINE prime = [ True for i in range ( N ) ] NEW_LINE prime [ 1 ] = False NEW_LINE def sieve ( n ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( prime [ num ] ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num = i NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( prime [ num % power ] ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num *= 10 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 25 NEW_LINE sieve ( n ) NEW_LINE print ( sSelected ( n ) ) NEW_LINE
def findWights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 3 NEW_LINE number = 3 NEW_LINE number = 3 NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = number - 1 NEW_LINE number *= 2 NEW_LINE number *= 3 NEW_LINE number *= 3 NEW_LINE number += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " ▁ " ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT X = 2 NEW_LINE findWights ( X ) NEW_LINE
def addToArray ( A , K ) : NEW_LINE INDENT v = [ ] NEW_LINE ans = [ ] NEW_LINE rem = 0 NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT y = A [ i ] + K % 10 + rem NEW_LINE if y > 9 : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( y % 10 + rem % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT DEDENT while K > 0 : NEW_LINE INDENT y = K % 10 NEW_LINE v . append ( y % 10 ) NEW_LINE v . append ( y % 10 ) NEW_LINE DEDENT for i in range ( len ( V ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT y = K % 10 NEW_LINE v . append ( y % 10 ) NEW_LINE if y > 0 : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT DEDENT if rem > 0 : NEW_LINE INDENT v . append ( rem ) NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ j ] = v [ j ] NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 2 , 7 , 4 , 4 ] NEW_LINE A . append ( 4 ) NEW_LINE K = 670 NEW_LINE A . append ( 4 ) NEW_LINE ans = addToArray ( A , K ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT ans . append ( ans [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 2 , 4 , 4 , 4 ] NEW_LINE A = [ 4 , 4 , 4 ] NEW_LINE K = 186 NEW_LINE ans = addToArray ( A , 4 ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT
def printPaths ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , 0 , i , R , C ) NEW_LINE print ( dfs ( i , i , j , R , C ) , end = " ▁ " ) NEW_LINE DEDENT res = res + arr [ i ] [ i ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( res , i + 1 , j , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT res = res + arr [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT res = res + arr [ i ] [ i ] NEW_LINE printPaths ( res , R , C ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ [ " a " , " b " ] , [ " d " , " e " ] ] NEW_LINE R = len ( input ) NEW_LINE C = len ( input ) NEW_LINE printPaths ( input , R , C ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' R ' : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' L ' : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' Yes ' if a == b + c == d or a == b + d or b == c + d or a == d or b == d or c == d or a == b + d or b == d or c == d or a == b + d or a == d or b == d or c == a + d or a == b + d or a == b + d or a == b + d or c == d or a == b + d or a == c + d or a == d or b == d or a == d or b == d or a == d or a == b + d or a == b == d or b == d or a == d or a == b == d or a == d or b == d or a == b + d or a == d or a == b == d or a == d or a == b == d or a == b + d or a == b == d or a == d or a == b == d or a == b + d or a == d or a == b + d or a == b + d or a == b + d or a == d or a == b + d or a == b + d or a == b == d or a == b + d or a == b + d or a == b + d or a == b + d or a == b + d or a == b + d or a == b == d or a == b + d or a == b + d or a == b + d or a == b + d : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def precisionCompute ( x , y , n ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT print ( x // y ) NEW_LINE return NEW_LINE DEDENT if ( x == 0 ) : NEW_LINE INDENT print ( x // y ) NEW_LINE return NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT print ( x // y ) NEW_LINE return NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT print ( x // y ) NEW_LINE return NEW_LINE DEDENT d = x // y NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE DEDENT d = x // y NEW_LINE d = x // y NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE DEDENT x = x // y NEW_LINE d = x // y NEW_LINE d = x // y NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 22 NEW_LINE y = 7 NEW_LINE precisionCompute ( x , y , n ) NEW_LINE DEDENT
from math import gcd NEW_LINE def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE mincm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT minPerfectCube = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcmOfArray ( arr , n ) NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt = 0 NEW_LINE lcm = 0 NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube = 2 NEW_LINE DEDENT i += 1 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE lcm = 0 NEW_LINE while ( lcm > 1 and lcm % 3 == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm /= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 42 , 100 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printLevelOrder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( root ) NEW_LINE q . append ( root ) NEW_LINE s = [ ] NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT q . append ( q [ - 1 ] ) NEW_LINE DEDENT if len ( q ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT s . append ( root ) NEW_LINE q . append ( root ) NEW_LINE s . append ( root . left ) NEW_LINE s . append ( root . left ) NEW_LINE s . append ( root . right ) NEW_LINE DEDENT def printLevelOrderLevelOrder ( root ) : NEW_LINE INDENT s = [ ] NEW_LINE q . append ( root . left ) NEW_LINE s . append ( root . right ) NEW_LINE s . append ( root . left ) NEW_LINE if len ( s ) == 0 : NEW_LINE INDENT s . append ( root . right ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT print ( s [ 0 ] , end = " ▁ " ) NEW_LINE s . append ( root . left ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT print ( s [ 0 ] , end = " ▁ " ) NEW_LINE s . append ( root . left ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left . right = Node ( 2 ) NEW_LINE root . left . right . left . right . right = Node ( 3 ) NEW_LINE root . right . append ( root . left ) NEW_LINE root . right . right . append ( root . right ) NEW_LINE printLevelOrderLevelOrderLevelOrder ( root ) NEW_LINE DEDENT
def cubeSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT if i == 1 or i == 2 : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def cubeSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( j == 1 or j == rows ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT print ( " Diamond ▁ Square ▁ : " ) NEW_LINE DEDENT rows = 5 NEW_LINE printPattern ( rows ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 2 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE w [ i ] [ 0 ] = b NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = min ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] + w [ i ] [ 1 ] ) NEW_LINE DEDENT ans = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if w [ i ] [ 0 ] >= i : NEW_LINE INDENT ans = max ( ans , w [ i ] [ 0 ] + w [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if a + b < x : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT def findLargest ( a , n ) : NEW_LINE INDENT return a [ 3 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLargest ( arr , n ) ) NEW_LINE DEDENT
def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( " Second ▁ poker ▁ poker ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ poker ▁ is " , end = " " ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE findWinner ( n ) NEW_LINE
from collections import deque NEW_LINE G = deque ( ) NEW_LINE def BFS ( G , v ) : NEW_LINE INDENT G . append ( v ) NEW_LINE DEDENT def BFS ( G , s ) : NEW_LINE INDENT global visited NEW_LINE visited = [ False ] * V NEW_LINE q . append ( s ) NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT if visited [ s ] : NEW_LINE INDENT visited [ s ] = True NEW_LINE q . append ( s ) NEW_LINE DEDENT DEDENT while len ( q ) != 0 : NEW_LINE INDENT s = q . popleft ( ) NEW_LINE if not visited [ s ] : NEW_LINE INDENT visited [ s ] = True NEW_LINE q . append ( s ) NEW_LINE DEDENT DEDENT while len ( q ) != 0 : NEW_LINE INDENT s = q . popleft ( ) NEW_LINE if not visited [ s ] : NEW_LINE INDENT visited [ s ] = True NEW_LINE q . append ( s ) NEW_LINE DEDENT DEDENT DEDENT G = GFS ( G , 2 ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_
from collections import deque NEW_LINE G = deque ( ) NEW_LINE def BFS ( G , v ) : NEW_LINE INDENT G . append ( v ) NEW_LINE DEDENT def BFS ( G , s ) : NEW_LINE INDENT global visited NEW_LINE visited = [ False ] * V NEW_LINE q . append ( s ) NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT if visited [ s ] : NEW_LINE INDENT visited [ s ] = True NEW_LINE q . append ( s ) NEW_LINE DEDENT DEDENT while len ( q ) != 0 : NEW_LINE INDENT s = q . popleft ( ) NEW_LINE if not visited [ s ] : NEW_LINE INDENT visited [ s ] = True NEW_LINE q . append ( s ) NEW_LINE DEDENT DEDENT while len ( q ) != 0 : NEW_LINE INDENT s = q . popleft ( ) NEW_LINE if not visited [ s ] : NEW_LINE INDENT visited [ s ] = True NEW_LINE q . append ( s ) NEW_LINE DEDENT DEDENT DEDENT G = GFS ( G , 2 ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_LINE G . append ( s ) NEW_
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 0 ] * ( n + 1 ) NEW_LINE elements [ 0 ] = a [ 0 ] ^ elements [ i ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 13 , 2 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE getElements ( arr , arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( N , R , P , P ) : NEW_LINE INDENT return P * P + ( N - 1 ) * P + ( N - 1 ) * P NEW_LINE DEDENT def solve ( N , R , P ) : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT return ' P ' NEW_LINE DEDENT if P == 0 : NEW_LINE INDENT return ' POSSIBLE ' NEW_LINE DEDENT return ' POSSIBLE ' NEW_LINE DEDENT def solve ( N , R , P ) : NEW_LINE INDENT res = solve ( N , P , P ) NEW_LINE if N == P : NEW_LINE INDENT return ' POSSIBLE ' NEW_LINE DEDENT res = ' POSSIBLE ' NEW_LINE if N == P : NEW_LINE INDENT return ' POSSIBLE ' NEW_LINE DEDENT res = ' POSSIBLE ' NEW_LINE return res NEW_LINE DEDENT def solve ( N , R , P , P ) : NEW_LINE INDENT res = solve ( N , P , P ) NEW_LINE if solve ( N , P , P , P ) : NEW_LINE INDENT res = ' P ' NEW_LINE DEDENT res = ' POSSIBLE ' NEW_LINE return res NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , P , P , S , P = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( t + 1 , solve ( N , P , P , P ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( a ) NEW_LINE b . append ( b ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c += a - 1 NEW_LINE if a % 2 == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 ; NEW_LINE P = 1 ; NEW_LINE n = size - 2 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE P = P * arr [ i ] ; NEW_LINE DEDENT S = S - n * ( n + 1 ) / 2 ; NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT S = S - n * ( n + 1 ) / 2 ; NEW_LINE P = S - n * ( n + 1 ) / 2 ; NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT return ( S * S - 1 ) / 2 ; NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 1 , 2 , 3 , 1 ] ; NEW_LINE arr . append ( S - 1 ) ; NEW_LINE printRepeating ( arr , arr ) ; NEW_LINE
import math NEW_LINE def sieve_of_erastosthenes ( num ) : NEW_LINE INDENT input_list = [ False for i in range ( num , 0 , - 1 ) ] NEW_LINE input_list [ 0 ] = input_list [ 1 ] = False NEW_LINE sqrt = int ( num ** 0.5 ) NEW_LINE for i in range ( sqrt , num ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT input_list [ i ] = False NEW_LINE DEDENT DEDENT return input_list NEW_LINE DEDENT sieve_of_erastosthenes ( num ) NEW_LINE while True : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE if num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT for j in range ( i , num , i ) : NEW_LINE INDENT if num % j == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if num % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
import math NEW_LINE def solve ( n : int , angle : " List [ int ] " ) -> float : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT x , y = angle [ i ] NEW_LINE x , y = angle [ i ] NEW_LINE y = y NEW_LINE DEDENT return x NEW_LINE DEDENT def area ( x , y ) : NEW_LINE INDENT return ( x - y ) * y NEW_LINE DEDENT def area ( x , y ) : NEW_LINE INDENT return ( y - x ) * y NEW_LINE DEDENT def area ( x , y ) : NEW_LINE INDENT return ( x - y ) * y NEW_LINE DEDENT def area ( x , y ) : NEW_LINE INDENT return ( y - x ) * y NEW_LINE DEDENT def f ( x , y ) : NEW_LINE INDENT return ( x - y ) * ( y - y ) * ( x - y ) NEW_LINE DEDENT def f ( x , y ) : NEW_LINE INDENT return ( x - x ) * ( y - y ) * ( y - y ) NEW_LINE DEDENT def f ( x , y ) : NEW_LINE INDENT return ( f ( x , y ) * ( x - y ) ) NEW_LINE DEDENT def f ( x , y ) : NEW_LINE INDENT return ( f ( x , y ) * ( x - y ) ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE dots = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE dots . append ( x , y ) NEW_LINE DEDENT dp = [ f ( x , y ) for x , y in dots ] NEW_LINE print ( f ' { 0 : . 5f } ' . format ( dp [ 0 : : 2 ] ) ) NEW_LINE
from collections import Counter NEW_LINE def solve ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if s [ 0 ] == ' # ' : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def solve ( s ) : NEW_LINE INDENT c = Counter ( s ) NEW_LINE if ' # ' in s : NEW_LINE INDENT c . append ( c ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' . ' : NEW_LINE INDENT c [ i ] = c [ i ] + 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = list ( input ( ) ) NEW_LINE while True : NEW_LINE INDENT s = solve ( s ) NEW_LINE if s == " # " : NEW_LINE INDENT break NEW_LINE DEDENT solve ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == ' S ' and s [ i + 1 ] == ' T ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if s [ i ] == ' S ' : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT DEDENT if a == ' S ' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] > a [ i ] * a [ i ] : NEW_LINE INDENT print ( max ( a [ i - 1 ] * a [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( a [ i - 1 ] * a [ i - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // math . gcd ( a , b ) ) NEW_LINE DEDENT def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisible = findLCM ( a , b ) NEW_LINE b_divisible = n // a NEW_LINE common_divisible = n // b - ( m - 1 ) // b NEW_LINE common_divisible = n // lcm NEW_LINE common_divisible = n // lcm NEW_LINE return a_divisible NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 NEW_LINE n , a , b = 10 , 2 , 3 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( * s , sep = ' ' ) NEW_LINE
def smallestKFreq ( a , n , k ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize ( 0 , 9 ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m [ a [ i ] ] == k : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT res = sys . maxsize NEW_LINE s . sort ( ) NEW_LINE for i in s : NEW_LINE INDENT if m [ temp ] == k : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 2 , 1 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE print ( smallestKFreq ( arr , len ( arr ) ) ) NEW_LINE DEDENT
def areVowels ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = ch = 64 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' u ' or s [ i ] == ' u ' or s [ i ] == ' u ' or s [ i ] == ' u ' ) : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " aabbbddbdd " NEW_LINE if areVowels ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def calc ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sqrt ( i * ( n - i ) ) ) NEW_LINE DEDENT return a NEW_LINE DEDENT def calc_sqrt ( n ) : NEW_LINE INDENT a . append ( n ) NEW_LINE DEDENT def calc_sqrt ( n ) : NEW_LINE INDENT a . append ( n ) NEW_LINE DEDENT def calc_sqrt ( n ) : NEW_LINE INDENT a . append ( n ) NEW_LINE DEDENT def calc_sqrt ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return calc_sqrt ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT return calc_sqrt ( n ) NEW_LINE DEDENT DEDENT def calc_sqrt ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return calc_sqrt ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT return calc_sqrt ( n ) NEW_LINE DEDENT DEDENT def calc_sqrt ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return calc_sqrt ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT return calc_sqrt ( n ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = calc_sqrt ( n ) NEW_LINE b = calc_sqrt ( n ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return b NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT
def countOfTwo ( str ) : NEW_LINE INDENT letter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= ord ( ' A ' and ord ( str [ i ] ) <= ' Z ' ) or ( ord ( str [ i ] ) <= ' z ' ) or ( ord ( str [ i ] ) <= ' z ' ) or ( ord ( str [ i ] ) <= ' z ' ) ) : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT def check ( str ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= '0' and ord ( str [ i ] ) <= '9' ) : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GEEKsK24" NEW_LINE check ( str ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : break NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x == 2 * n : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( 2 * n + 1 ) NEW_LINE DEDENT DEDENT if x == 1 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE def preComputeCount ( n ) : NEW_LINE INDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDivision [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDivisors ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT preComputeCount ( n ) NEW_LINE n = 16 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ = ▁ " , count , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total ▁ divisors ▁ = " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total ▁ divisors ▁ = " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total ▁ divisors ▁ = " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += lst [ i ] * d NEW_LINE DEDENT print ( ans ) NEW_LINE
n , t , e = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t -= e NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if t - e * t + e <= e : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def cal_by ( h , r ) : NEW_LINE INDENT IST = ( h * r * r ) / 360 NEW_LINE return ( 24 * 24 ) if ( IST - h ) else ( ( IST - h ) * 60 ) NEW_LINE DEDENT h = 20 NEW_LINE r = 150 NEW_LINE print ( int ( h ) , " : " , int ( ( elapsed ) ) ) NEW_LINE
def printRoots ( n ) : NEW_LINE INDENT theta = pi * 2.0 / n ; NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sin = sin * ( k * theta ) ; NEW_LINE imag = sin ( k * theta ) ; NEW_LINE imag = sin ( k * theta ) ; NEW_LINE print ( " - ▁ " , abs ( imag ) , abs ( imag ) ) ; NEW_LINE DEDENT print ( " - ▁ " , end = " " ) ; NEW_LINE printRoots ( 3 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT printRoots ( 1 ) ; NEW_LINE printRoots ( 1 ) ; NEW_LINE DEDENT
def findTile ( arr1 , arr2 , n , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( " { } , ▁ " , arr2 [ i ] , " , ▁ " , arr2 [ j ] , " , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE findTile ( arr1 , arr2 , n1 , n1 , n2 ) NEW_LINE
def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( count_left + 1 ) * ( count_right + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + 1 ) NEW_LINE DEDENT DEDENT s = " geeksforgeeks " NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfKthPrime ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT c += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE DEDENT SieveOfKthPrime ( arr , n , k ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT MAX = MAX + 1 NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += arr [ i ] NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 ] NEW_LINE solve ( arr , n , k ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = True NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 0 ] = True NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productOfKthPrime ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT SieveOfKthPrime ( arr , n , k ) NEW_LINE
def findAllSequences ( diff , start , end ) : NEW_LINE INDENT if ( abs ( diff ) > ( end - start + 1 ) / 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return NEW_LINE DEDENT diff [ start ] = '1' NEW_LINE findAllSequences ( diff + 1 , start + 1 , end - 1 ) NEW_LINE findAllSequences ( diff + 1 , start + 1 , end - 1 ) NEW_LINE findAllSequences ( diff + 1 , start + 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start + 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start + 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start + 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start + 1 , end - 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start , end - 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start + 1 , end - 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , end , end - 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start , end - 1 , end - 1 ) NEW_LINE findAllSequences ( diff - 1 , start , end - 1 , end - 1 ) NEW_LINE print ( ) NEW_LINE DEDENT n = 2 * n * n - 1 NEW_LINE findAllSequences ( 0 , 2 * n - 1 , 2 * n - 1 ) NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= h : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def cntNodes ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( 1 ) NEW_LINE DEDENT def updateList ( node , m ) : NEW_LINE INDENT if ( node == None and m < c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cntNodes ( node . next ) ) NEW_LINE DEDENT def updateList ( node , m ) : NEW_LINE INDENT cnt = cntNodes ( node . next ) NEW_LINE if ( cnt != m and m < cnt ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = cntNodes ( node . next ) NEW_LINE prev = None NEW_LINE while ( prev != 0 ) : NEW_LINE INDENT prev = curr NEW_LINE prev = curr NEW_LINE prev = prev NEW_LINE DEDENT prev . next = None NEW_LINE while ( prev != None ) : NEW_LINE INDENT prev = curr NEW_LINE prev . next = curr NEW_LINE DEDENT prev . next = None NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = Node ( 5 ) NEW_LINE head . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for c in range ( 0 , 26 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) ; NEW_LINE curr = 0 ; NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT ch = ord ( ch [ i ] ) ; NEW_LINE curr = 0 ; NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT if ( s [ i ] == ch and c != k ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT cnt += 1 ; NEW_LINE DEDENT i -= 1 ; NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 ; NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) ; NEW_LINE DEDENT return maxSubStr ; NEW_LINE DEDENT s = " aaabbaabb " ; NEW_LINE k = 2 ; NEW_LINE print ( maxSubStrings ( s , k ) ) ; NEW_LINE
def ansQueries ( preFunn , prefunn , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( preunnunn [ r ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l - l + 1 ) % 2 == 0 : NEW_LINE INDENT print ( preunnunn [ r ] ^ prefunnunn [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefunn [ r ] ^ prefunn [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefunnunn [ 0 ] = 0 NEW_LINE preunnunnunn [ 1 ] ^ prefunn [ l - 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT preunnunnunn [ i ] = arr [ i - 1 ] ^ prefunnunn [ i - 1 ] NEW_LINE prefunn [ i ] = prefunnunn [ i - 1 ] ^ prefunn [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT preunnunn [ i ] = prefunn [ i - 1 ] ^ prefunn [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ans = prefunnunnunn ( preunnunnunn [ i ] , prefunn [ i ] , l , r ) NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 2 , 1 , 4 ] NEW_LINE r = len ( arr ) NEW_LINE print ( wrapper ( arr , n , l , r , l , r ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
class Queue : NEW_LINE INDENT def __init__ ( self , n , q ) : NEW_LINE INDENT self . n = q NEW_LINE self . n -= 1 NEW_LINE self . q = [ ] NEW_LINE DEDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n -= 1 NEW_LINE self . q . append ( self . n ) NEW_LINE DEDENT def insert ( self , x ) : NEW_LINE INDENT if self . q [ 0 ] == 0 : NEW_LINE INDENT self . q . append ( self . q [ 1 ] ) NEW_LINE DEDENT self . q . append ( self . n ) NEW_LINE DEDENT def pop ( self , x ) : NEW_LINE INDENT if self . q [ 0 ] == 0 : NEW_LINE INDENT self . q . append ( x ) NEW_LINE DEDENT self . q . append ( x ) NEW_LINE DEDENT def get ( self , x ) : NEW_LINE INDENT if self . q [ 0 ] == 0 : NEW_LINE INDENT self . q . append ( self . q [ 1 ] ) NEW_LINE DEDENT self . q . popleft ( ) NEW_LINE DEDENT DEDENT def run ( ) : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT query = input ( ) . split ( ) NEW_LINE if query [ 0 ] == '0' : NEW_LINE INDENT self . q . append ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == '1' : NEW_LINE INDENT self . q . pop ( ) NEW_LINE DEDENT elif query [ 0 ] == '2' : NEW_LINE INDENT self . q . pop ( ) NEW_LINE DEDENT DEDENT elif query [ 0 ] == '1' : NEW_LINE INDENT self . q . popleft ( ) NEW_LINE DEDENT elif query [ 0 ] == '2' : NEW_LINE INDENT self . q . popleft ( ) NEW_LINE DEDENT DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT printArray ( arr , n , k ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE modifyArray ( arr , n , k ) NEW_LINE DEDENT
def find_Centramid ( vv ) : NEW_LINE INDENT ans = [ ] NEW_LINE n = len ( vv ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x0 , y0 = v [ i ] [ 0 ] , v [ i ] [ 1 ] NEW_LINE y1 = v [ i ] [ 1 ] NEW_LINE X0 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE X0 += A [ ( i + 1 ) % n ] [ 1 ] NEW_LINE ans . append ( x0 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x0 , y0 , y1 = ( x0 * y0 ) [ ( i + 1 ) % n ] [ 0 ] , y0 NEW_LINE ans . append ( x0 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] [ i ] + x0 ) NEW_LINE DEDENT DEDENT v = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans . append ( v [ 0 ] ) NEW_LINE ans . append ( v [ 1 ] ) NEW_LINE print ( " % 3.3f ▁ % .3f ▁ % .3f " % ( 6 * ans ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE l . append ( s ) NEW_LINE DEDENT a = ' ' NEW_LINE for i in a : NEW_LINE INDENT if ' l ' in i : NEW_LINE INDENT a = ' ' NEW_LINE DEDENT if ' l ' in a : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT
def minOperations ( ar , k ) : NEW_LINE INDENT ar . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = ans | ( ar [ - 1 ] - ar [ i - 1 ] ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += ( k - 1 ) * ( ar [ i - 1 ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 1 , 9 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minOperations ( arr , k ) ) NEW_LINE DEDENT
def charCheck ( s ) : NEW_LINE INDENT if ( s >= 65 and s <= 122 and s <= 122 ) : NEW_LINE INDENT print ( " Character ▁ Character ▁ Character " , " Character " ) NEW_LINE DEDENT elif ( s >= 97 and s <= 122 ) : NEW_LINE INDENT print ( " Character " , " Character " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Character ▁ Character " , " Character " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s_ = " $ " NEW_LINE char = " . join ( char ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if l [ i ] not in l : NEW_LINE INDENT l [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT l [ i ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( * l ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = set ( ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE q . add ( a - 1 ) NEW_LINE q . add ( b - 1 ) NEW_LINE DEDENT q . add ( 0 ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if q [ i ] [ 0 ] + p [ i ] [ 1 ] : NEW_LINE INDENT ans = min ( ans , q [ i ] [ 1 ] + p [ i ] [ 0 ] + p [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( ans if ans == 10 ** 9 else - 1 ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE while j < n and a [ j ] <= i : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE
n = int ( input ( ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( x ) : NEW_LINE INDENT if x [ j - 1 ] == c [ j - 1 ] : NEW_LINE INDENT c [ x [ j - 1 ] ] , c [ x - 1 ] = c [ j - 1 ] , c [ x - 1 ] NEW_LINE DEDENT elif x [ j - 1 ] == c [ x - 1 ] : NEW_LINE INDENT c [ x - 1 ] [ y - 1 ] , c [ x - 1 ] = c [ x - 1 ] , c [ x - 1 ] NEW_LINE DEDENT DEDENT DEDENT p = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if c [ i ] [ j ] == c [ i ] : NEW_LINE INDENT p . append ( [ i , j ] ) NEW_LINE p . append ( [ i , j ] ) NEW_LINE p . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT p = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if p [ i ] [ j ] == c [ i ] [ j ] : NEW_LINE INDENT p . append ( [ i , j ] ) NEW_LINE p . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT p . append ( p ) NEW_LINE p . append ( [ i , j ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if p [ i ] [ j ] == c [ i ] [ j ] : NEW_LINE INDENT p [ i ] [ j ] = p [ i ] [ j ] NEW_LINE p [ i ] [ j ] = p [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT p = [ ]
def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ctX = 0 NEW_LINE ctY = 0 NEW_LINE for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT elif ( arr [ j ] == y ) : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT if ( arr [ j ] == y ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if '0' in s : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( len ( s ) , max ( len ( s ) - 1 , 0 ) ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dic = { } NEW_LINE for i in a : NEW_LINE INDENT if i in dic : NEW_LINE INDENT dic [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dic [ i ] = 1 NEW_LINE DEDENT DEDENT if dic . values ( ) == n : NEW_LINE INDENT print ( ' Takah ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Danik ' ) NEW_LINE DEDENT
def print ( a ) : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for i in a : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( a ) NEW_LINE
def targetCount ( target ) : NEW_LINE INDENT target = 90 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 3 , 1 , 3 , 1 ] NEW_LINE lengthCount = len ( arr ) NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if ( target % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT targetFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length - 1 ) : NEW_LINE INDENT if ( arr [ k ] == target ) : NEW_LINE INDENT targetFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT target = target NEW_LINE arr = [ 1 , 31 , 3 , 1 , 3 , 1 , 1 , 1 ] NEW_LINE lenCount = len ( arr ) NEW_LINE print ( " Total ▁ number ▁ of ▁ triplets ▁ found ▁ : " , totalCount ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE print ( n ) NEW_LINE print ( * a ) NEW_LINE print ( - n ) NEW_LINE print ( * a ) NEW_LINE print ( - n ) NEW_LINE print ( * a ) NEW_LINE print ( - n ) NEW_LINE print ( - n ) NEW_LINE print ( - n ) NEW_LINE print ( * a ) NEW_LINE print ( - n ) NEW_LINE print ( * a ) NEW_LINE print ( * a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - n ) NEW_LINE print ( - n ) NEW_LINE print ( * a ) NEW_LINE print ( - n ) NEW_LINE print ( * a ) NEW_LINE print ( * a ) NEW_LINE DEDENT
def finalNum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = gcd ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT def finalNum ( arr , n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( finalNum ( arr , n ) ) NEW_LINE DEDENT
N = 1000 NEW_LINE def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ ] NEW_LINE v . append ( a [ 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i ] = ( a [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v [ i ] [ i ] = ( a [ i ] [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT while ( len ( v ) > 1 ) : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( steps % 2 == 1 ) : NEW_LINE INDENT v [ steps - 1 ] [ i + 1 ] = ( v [ i ] [ i + 1 ] | v [ i + 1 ] [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ steps - 1 ] [ i + 1 ] = ( v [ i ] [ i ] ^ v [ i + 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ 0 ] [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 5 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE index = 0 NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE DEDENT
def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n * n + 5 * n + 6 * n + 6 * n + 6 ) // 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import copy NEW_LINE import heapq NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10000001 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE g = s . count ( ' g ' ) NEW_LINE g = s . count ( ' p ' ) NEW_LINE print ( len ( s ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def pattern ( N ) : NEW_LINE INDENT i , j , k = 0 , N NEW_LINE space = 1 NEW_LINE for i in range ( i , j + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT space = space + 2 NEW_LINE DEDENT if i != rows : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for j in range ( i , j + 1 ) : NEW_LINE INDENT if j != space : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 ) // 2 + k NEW_LINE high = ( n + 1 ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 9 , 5 , 3 , 5 , 10 , 10 ] NEW_LINE arr1 = [ 2 , 4 , 3 , 5 , 10 , 10 ] NEW_LINE arr1 . append ( 2 ) NEW_LINE arr1 . append ( 2 ) NEW_LINE arr1 . append ( 2 ) NEW_LINE arr1 . append ( 2 ) NEW_LINE arr2 . append ( 2 ) NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE n = 9 NEW_LINE arr1 . append ( 2 ) NEW_LINE arr1 . append ( 2 ) NEW_LINE arr1 = [ 2 , 4 , 3 , 5 , 10 , 10 , 10 ] NEW_LINE n = 9 NEW_LINE arr1 = [ 2 , 4 , 3 , 5 , 10 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE
class Solution : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . leftData = rootData NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def pathSum ( self , root , s ) : NEW_LINE INDENT result = 0 NEW_LINE path = { root : root . left : root . left , None : None } NEW_LINE path [ root . right ] = 1 NEW_LINE return result NEW_LINE DEDENT def pathSum ( self , s , t , s ) : NEW_LINE INDENT result = s NEW_LINE path = { root : root . left , s } NEW_LINE return result NEW_LINE DEDENT def pathSum ( self , s , t ) : NEW_LINE INDENT global result NEW_LINE result = pathSum ( self . left , s ) NEW_LINE path . append ( s + self . right ) NEW_LINE return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = Solution ( ) NEW_LINE root . left = TreeNode ( 5 ) NEW_LINE root . right = TreeNode ( 10 ) NEW_LINE root . right . left = TreeNode ( 3 ) NEW_LINE root . right . left = TreeNode ( 3 ) NEW_LINE root . right . right . right = TreeNode ( 3 ) NEW_LINE root . right . left . right = TreeNode ( 3 ) NEW_LINE root . right . right . right . right . right . right = TreeNode ( 3 ) NEW_LINE out = sObj . pathSum ( root , root ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x_size = 5 NEW_LINE getmax ( arr , arr , x ) NEW_LINE
import sys NEW_LINE def solve ( N : int , T : str ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i not in ans : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def solve ( N , T ) : NEW_LINE INDENT ans = solve ( N , T ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT ans += solve ( i , T + N , T ) NEW_LINE DEDENT DEDENT T = int ( input ( ) ) NEW_LINE for i in range ( T + 1 ) : NEW_LINE INDENT print ( " Case ▁ # % d : ▁ % s " % ( i , ans ) ) NEW_LINE DEDENT
import math NEW_LINE def is_prime_number ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def is_prime_number ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def is_prime_number ( n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if is_prime_number ( i * i + 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i * i , n , i ) : NEW_LINE INDENT if is_prime_number ( i * j + 1 , i ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def is_prime_number ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( is_prime_number ( n ) ) NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxOR ( arr , n ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def numLogels ( self , J , S ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( J ) ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( len ( J ) ) : NEW_LINE INDENT if j not in J : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE J = ' aaAbb ' NEW_LINE S = ' aaabbbb ' NEW_LINE out = sObj . numLogels ( J , S ) NEW_LINE print ( out ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def is_clique ( b ) : NEW_LINE INDENT global MAX NEW_LINE global MAX NEW_LINE global G NEW_LINE global G NEW_LINE global G NEW_LINE global G NEW_LINE global G NEW_LINE global G NEW_LINE global G NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if ( G [ i ] [ j ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def maxCliques ( i , l ) : NEW_LINE INDENT max_ = 0 NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if ( is_clique ( l + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return max_ NEW_LINE DEDENT edges = [ [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 1 ] , [ 4 , 1 ] ] , [ 4 , 1 , 1 ] ] NEW_LINE size = len ( edges ) NEW_LINE n = len ( edges ) NEW_LINE print ( maxCliques ( 0 , 1 ) ) NEW_LINE
from math import log2 NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = log2 ( n ) // log2 ( 2 ) ; NEW_LINE return int ( 2 ** k ) ; NEW_LINE DEDENT n = 273 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE
n , m , s , f = map ( int , input ( ) . split ( ) ) NEW_LINE f = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] NEW_LINE s , f , s , f , f , f , t = map ( int , input ( ) . split ( ) ) NEW_LINE s -= 1 ; f -= 1 ; f += 1 NEW_LINE for i in range ( s - f + 1 ) : NEW_LINE INDENT if i == f : f += 1 ; s += 1 ; f -= 1 NEW_LINE DEDENT s += ' R ' if f < s else ' R ' NEW_LINE print ( s ) NEW_LINE
def subsetPairCount ( arr , N , K ) : NEW_LINE INDENT f = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( subsetPairCount ( arr , N , K ) ) NEW_LINE DEDENT
N , S , T = map ( int , input ( ) . split ( ) ) NEW_LINE d = 0 NEW_LINE ans = 0 NEW_LINE while N >= 10 ** 10 : NEW_LINE INDENT d += 1 NEW_LINE N -= 1 NEW_LINE DEDENT if N >= 10 ** 10 : NEW_LINE INDENT ans = max ( 0 , N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = N NEW_LINE DEDENT while d >= 10 ** 10 : NEW_LINE INDENT ans += 1 NEW_LINE d += 1 NEW_LINE DEDENT while d >= 10 ** 10 : NEW_LINE INDENT ans += d NEW_LINE d = 10 ** 10 NEW_LINE DEDENT print ( ans ) NEW_LINE
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , ▁ " , int ( c / ( a * 1.0 ) ) ) NEW_LINE DEDENT a = 2 ; b = 3 ; c = - 5 ; NEW_LINE printRoots ( a , b , c ) ; NEW_LINE
def dp ( pos , fl , flag , bin ) : NEW_LINE INDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT val = 0 NEW_LINE if ( bin [ pos ] [ pos ] != '0' ) : NEW_LINE INDENT val += dp ( pos + 1 , 1 , bin ( pos + 1 , 1 , 1 ) ) NEW_LINE DEDENT elif ( bin [ pos ] [ pos ] == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , 1 , bin ( pos + 1 , 1 , 1 , 1 ) ) NEW_LINE DEDENT elif ( bin [ pos ] [ pos ] == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , 1 , bin , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT val += dp ( pos + 1 , 1 , bin ( pos + 1 , 1 , 1 ) ) NEW_LINE DEDENT DEDENT def findIntegers ( num ) : NEW_LINE INDENT bin = " " NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( bin [ pos ] [ 0 ] == '1' ) : NEW_LINE INDENT bin += '0' NEW_LINE DEDENT else : NEW_LINE INDENT bin += '1' NEW_LINE DEDENT bin += '1' NEW_LINE DEDENT bin [ 0 ] [ 2 ] = '0' NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT bin += '1' NEW_LINE DEDENT bin = ' ' . join ( bin ) NEW_LINE return bin ( bin ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( findIntegers ( N ) ) NEW_LINE DEDENT
N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] [ i - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i - 1 ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 0 ] ) + pow ( 2 , i + j + j ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = temp NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacci ( n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE createHash ( hash , n ) NEW_LINE createHash ( hash , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i in hash . get ( n - i ) in hash ) : NEW_LINE INDENT print ( i , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 90 NEW_LINE findFibonacci ( N ) NEW_LINE DEDENT
def countgroups ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs ^ a [ i ] = xs ^ a [ i ] NEW_LINE DEDENT if ( xs == 0 ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroups ( a , n ) ) NEW_LINE
def maxLength ( s , n ) : NEW_LINE INDENT ans = - 10 ** 9 NEW_LINE A = [ ] NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( s [ j ] - ord ( ' a ' ) == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT L . append ( 2 * fre [ j - 1 ] ) NEW_LINE R . append ( 2 * fre [ j - 1 ] ) NEW_LINE DEDENT max_val = 10 ** 9 NEW_LINE min_val = 10 ** 9 NEW_LINE for j in range ( len ( L ) ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) NEW_LINE DEDENT ans_val = max ( ans , max_val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " abbbbbbbccbccbccbccbccbccbccbccbccb " NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , max_val ) ) NEW_LINE
N = 100005 NEW_LINE G = [ [ ] for i in range ( N ) ] NEW_LINE G = [ [ ] for i in range ( N ) ] NEW_LINE G . append ( G [ x ] [ y ] ) NEW_LINE vis [ x ] . append ( y ) NEW_LINE vis [ y ] . append ( x ) NEW_LINE vis [ y ] . append ( x ) NEW_LINE vis [ x ] . append ( y ) NEW_LINE vis [ y ] . append ( x ) NEW_LINE vis [ y ] . append ( y ) NEW_LINE vis [ x ] . append ( y ) NEW_LINE vis [ y ] . append ( x ) NEW_LINE vis [ y ] . append ( y ) NEW_LINE vis [ y ] . append ( x ) NEW_LINE vis [ y ] . append ( y ) NEW_LINE if ( vis [ y ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT vis [ i ] = - 1 NEW_LINE vis [ i ] = True NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT vis [ i ] = False NEW_LINE vis [ i ] = False NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT print ( edges [ i ] , " ▁ " , edges [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT n = 4 NEW_LINE m = 3 NEW_LINE d = 3 NEW_LINE print ( edges [ n ] , " ▁ " , edges [ m ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE for i in b : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
from functools import reduce NEW_LINE def main ( ) : NEW_LINE INDENT o , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 0 if n <= o else 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def isPrime ( k ) : NEW_LINE INDENT if k <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( isPrime ( k ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 , 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = 2020 NEW_LINE b = 6500 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = ' ' NEW_LINE if k == 1 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT elif k == 1 : NEW_LINE INDENT s = ' a ' NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT s += s [ i ] NEW_LINE DEDENT s += ' a ' NEW_LINE DEDENT elif k == 1 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
maxn = 16 NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ 0 for i in range ( maxn ) ] NEW_LINE arr = [ - 1 for i in range ( maxn ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - j ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 4 * 4 ] NEW_LINE DEDENT def Maximum_Sum ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n - 4 * dp [ n - 4 * t ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = ( n - maxn ) // 4 + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE dp = precompute ( dp , n ) NEW_LINE print ( Maximum_Sum ( dp , n ) ) NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 ) * ( 2 * n + 1 ) // 3 NEW_LINE DEDENT n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is " , countSquares ( n ) ) NEW_LINE
import sys NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE N , M = map ( int , readline ( ) . split ( ) ) NEW_LINE A = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE S = A [ 0 ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S += A [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += S NEW_LINE DEDENT print ( ans ) NEW_LINE
def FindSubarray ( arr , n , k ) : NEW_LINE INDENT count_one = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_one [ i ] = count_one [ i ] NEW_LINE DEDENT sum = count_one [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = int ( count_one [ 0 ] ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = int ( count_one [ 0 ] ) NEW_LINE j = 1 NEW_LINE j = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( k == count_one [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT elif ( k == count_one [ i ] ) : NEW_LINE INDENT ans += count_one [ i ] NEW_LINE j += 1 NEW_LINE DEDENT elif ( k == count_one [ i ] ) : NEW_LINE INDENT ans += count_one [ i ] NEW_LINE j += 1 NEW_LINE DEDENT elif ( sum + count_one [ i ] > k ) : NEW_LINE INDENT ans += count_one [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( FindSubarray ( arr , n , k ) ) NEW_LINE DEDENT
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0. * P * P * P * P * P NEW_LINE loss = ( 2 * P * P * P ) / ( 100 * 100 - P * P * P ) NEW_LINE print ( " Loss ▁ = ▁ " , Loss ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SP = 2400 NEW_LINE P = 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT
n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( sum ( a [ : x ] ) , sum ( a [ x : x ] ) ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ * map ( int , input ( ) . split ( ) ) ] NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT c . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( 1 ) NEW_LINE DEDENT DEDENT min = min ( c ) NEW_LINE max = min ( c ) NEW_LINE min = min ( c ) NEW_LINE if min > min : NEW_LINE INDENT min = c [ 0 ] NEW_LINE DEDENT elif max < min : NEW_LINE INDENT min = c [ 1 ] NEW_LINE DEDENT elif max > min : NEW_LINE INDENT min = c [ 0 ] NEW_LINE DEDENT elif max > min : NEW_LINE INDENT min = c [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT min = c [ 0 ] NEW_LINE DEDENT print ( min ) NEW_LINE
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( map ( 10 ** 9.5 ) for i in range ( 1 , len ( str ( it ) ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE while True : NEW_LINE INDENT if len ( str ( ans ) ) == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if str ( ans ) [ : - 1 ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( str , n ) : NEW_LINE INDENT distinct_char = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . append ( str [ i ] ) NEW_LINE DEDENT return ( len ( distinct_char ) ) NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE print ( countStrings ( str , n ) ) NEW_LINE
M = 4 NEW_LINE N = 5 NEW_LINE N = 5 NEW_LINE def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if mat [ i ] [ j ] == i : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i == M - 1 : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 1 , 1 , 4 , 8 ] , [ 7 , 7 , 8 , 3 ] , [ 8 , 7 , 2 , 3 , 1 ] , [ 8 , 7 , 3 , 1 , 1 ] ] NEW_LINE printCommonElements ( mat ) NEW_LINE
from math import * NEW_LINE from collections import * NEW_LINE from collections import * NEW_LINE import sys NEW_LINE from bisect import * NEW_LINE from io import BytesIO , I NEW_LINE import os NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE a , b = MI ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = MI ( ) NEW_LINE if a == b : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( l [ i ] [ 0 ] + l [ i ] [ 1 ] ) NEW_LINE DEDENT l . sort ( ) NEW_LINE l . sort ( ) NEW_LINE l . sort ( key = lambda x : ( x [ 0 ] - x [ 1 ] ) ) NEW_LINE l . sort ( key = lambda x : x [ 1 ] ) NEW_LINE l . sort ( key = lambda x : ( x [ 0 ] - x [ 1 ] ) ) NEW_LINE l . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE l . sort ( key = lambda x : x [ 0 ] , x [ 0 ] ) NEW_LINE l . sort ( key = lambda x : x [ 1 ] ) NEW_LINE l . sort ( key = lambda x : x [ 0 ] ) NEW_LINE l . sort ( key = lambda x : x [ 0 ] , x [ 0 ] ) NEW_LINE if l [ 0 ] == l [ 1 ] : NEW_LINE INDENT print ( " YES
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d . append ( ( a , b ) ) NEW_LINE DEDENT t = 10 ** 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = d [ i ] * t NEW_LINE d . append ( t ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = d [ i ] - t * d [ i ] NEW_LINE if t < 0 : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE a = a + d NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE d = 2.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE
def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = 2147483647 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( " No ▁ triple ▁ triplet ▁ triplet " ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 , i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , large , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( " Number ▁ of ▁ divisible ▁ divisible ▁ divisible ▁ : " , end = " ▁ " ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 96 NEW_LINE numbers = 96 NEW_LINE numbers = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT n = 96 NEW_LINE numbers = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 ] * K NEW_LINE rem [ 0 ] = N // K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT count += ( rem [ K // 2 ] * rem [ K // 2 ] ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ K // 2 ] - 1 ) // 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 10 , 4 NEW_LINE print ( findPairCount ( N , K ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] - a [ j ] > ans : NEW_LINE INDENT ans = max ( ans , a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b = a [ 0 ] NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT b += i NEW_LINE DEDENT else : NEW_LINE INDENT b += i NEW_LINE DEDENT DEDENT if b % 2 == 0 and a % 2 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
PI = 1.6ZA265 NEW_LINE F = [ 0.6 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE f = 5 NEW_LINE while ( t < n ) : NEW_LINE INDENT f = F * PI NEW_LINE t = t * PI NEW_LINE DEDENT return f NEW_LINE DEDENT n = 9 NEW_LINE print ( " % d ▁ % ▁ Number ▁ = ▁ " % d " % ( n ) ) NEW_LINE
def kthSmallest ( n , k ) : NEW_LINE INDENT return ( 2 * k ) NEW_LINE DEDENT n = 8 NEW_LINE k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE
def printSumTricks ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT shiftSum = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT swapSum [ 0 ] [ i ] = sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSumTricks ( mat , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i + k - 1 ] [ j + k - 1 ] - mat [ i ] [ j + k - 1 ] ) NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ [ 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 ] , [ 4 , 2 , 2 , 3 , 4 , 5 , 5 ] , [ 4 , 4 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumTricks ( mat , k ) NEW_LINE DEDENT
a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( " No ▁ solution " ) NEW_LINE exit ( ) NEW_LINE DEDENT if a * n > 1000000000 : NEW_LINE INDENT print ( a ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( b ) NEW_LINE
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( X , Y , X , Y ) * ncr ( W , Y , Y ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X , Y , M = 4 , 3 , 6 , 5 NEW_LINE print ( totalWays ( X , Y , M ) ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n & ( n - 1 ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 and ( n & ( n - 1 ) ) ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if ( n == a or n == a - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == a or n == a - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == a - 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE
n , p = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if p % 2 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum += x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1000 ; r = 6000 ; NEW_LINE print ( countNumbers ( l , r ) ) ; NEW_LINE DEDENT
from math import log NEW_LINE def findGreater ( a , b ) : NEW_LINE INDENT x = a * log ( b ) ; NEW_LINE y = b * log ( a ) ; NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( a ^ b ) ; NEW_LINE DEDENT elif ( y > x ) : NEW_LINE INDENT print ( b ^ a ) ; NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( b ^ a ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " b ^ a ▁ is " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 ; b = 5 ; NEW_LINE c = 2 ; NEW_LINE findGreater ( a , b ) ; NEW_LINE DEDENT
def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l , r , ans = 0 , 2 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( r < l ) : NEW_LINE INDENT return 26 * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i - 1 ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] != str2 [ i ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT str1 = " cod " NEW_LINE str2 = " $ " NEW_LINE n = len ( str1 ) NEW_LINE print ( findAnswer ( str1 , str2 , str2 , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l1 = [ ] NEW_LINE l2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE l1 . append ( l1 ) NEW_LINE DEDENT l1 . sort ( ) NEW_LINE l2 . sort ( ) NEW_LINE if l1 [ 0 ] <= l2 [ 1 ] and l1 [ 0 ] <= l2 [ 1 ] : NEW_LINE INDENT print ( l1 [ 0 ] - l2 [ 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l1 [ 0 ] - l2 [ 1 ] + 1 ) NEW_LINE DEDENT DEDENT
def bitsInAltInAltInRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE num = num >> 1 NEW_LINE for i in range ( 1 , ( r - l ) + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if bitsInAltInAltAltInAltInAltRange ( n , l , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l == 1 : NEW_LINE INDENT a [ l ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ l ] += 1 NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if r - l + 1 - r + 1 - l + 1 - r + 1 - 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if b [ i ] [ i ] == 0 : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT elif b [ i ] [ i ] == 0 : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT elif b [ i ] [ i ] != 0 : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT if a [ i ] [ i ] != 0 : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT if dp [ i ] [ i ] != 0 : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT if dp [ i ] [ i ] != 0 : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT if dp [ i ] [ i ] != dp [ i ] [ i ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( dp [ i ] [ i ] ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE l . append ( s ) NEW_LINE print ( len ( l ) ) NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE
MAX = 1000000 NEW_LINE def maximumOccurElement ( L , R , n ) : NEW_LINE INDENT arr = [ 0 for i in range ( MAX ) ] NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] + 1 ] += 1 NEW_LINE arr [ R [ i ] + 1 ] -= 1 NEW_LINE if ( R [ i ] > maxi ) : NEW_LINE INDENT maxi = R [ i ] NEW_LINE DEDENT DEDENT mssum = arr [ 0 ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if ( mssum < arr [ i ] ) : NEW_LINE INDENT mssum = arr [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT L = [ 1 , 4 , 9 , 13 , 30 ] NEW_LINE R = [ 15 , 8 , 12 , 30 , 30 ] NEW_LINE n = len ( L ) NEW_LINE print ( maximumOccurElement ( L , R , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( set ( a ) ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , n - 1 ) NEW_LINE DEDENT
def func ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( low_limit , upper_limit ) : NEW_LINE INDENT value_size = ( upper_limit - lower_limit ) / interval_limit NEW_LINE sum_size = ( upper_limit - lower_limit ) + func ( lower_limit ) NEW_LINE sum_size = func ( lower_limit - lower_limit ) NEW_LINE for i in range ( 1 , interval_size ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT sum_size += 2 * i NEW_LINE DEDENT else : NEW_LINE INDENT sum_size += 2 * ( lower_limit + i * mid_size ) NEW_LINE DEDENT DEDENT return ( 3 * sum_size / 8 ) * sum_size NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mid_limit = 10 NEW_LINE lower_limit = 10 NEW_LINE upper_limit = 1 NEW_LINE increment_size = 10 NEW_LINE print ( " % .4f " % .4f " % .4f " % calculate ( lower_limit , upper_size ) ) NEW_LINE DEDENT
N , K , X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( N - K ) * ( N - K ) ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT x , h = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = h ** 2 + ( h / 2 ) ** 2 NEW_LINE h = x * h ** 2 NEW_LINE DEDENT print ( h ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = 0 NEW_LINE for i in range ( len ( str ( n ) ) ) : NEW_LINE INDENT s += int ( str ( n [ i ] ) ) NEW_LINE DEDENT if n == 10 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ p ] = True NEW_LINE prime [ 2 ] = True NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 6 ] and prime [ i + 6 ] and prime [ i + 8 ] and prime [ i + 8 ] and prime [ i + 8 ] : NEW_LINE INDENT print ( i , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT n = 20 NEW_LINE sieve ( n ) NEW_LINE printPrimeQuad ( n ) NEW_LINE
MAX = 1000 NEW_LINE MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX + 1 ) ] for j in range ( MAX + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j - 1 ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = " ABCDBCD " NEW_LINE y = " ABCDBCD " NEW_LINE m = len ( x ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , m , n , m ) ) NEW_LINE
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % a or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE z = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] in z : NEW_LINE INDENT z += 1 NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] in z : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT print ( z , z ) NEW_LINE
MAX = 1000 NEW_LINE sequence = [ 0 for i in range ( MAX - 1 ) ] NEW_LINE def ViEKESequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE sequence = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def ViEKESequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 NEW_LINE i = n - 1 NEW_LINE while ( sequence [ i ] != sequence [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE i = i - sequence [ i + 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE prefix = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def convertEKESequence ( ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( prefix [ j ] == prefix [ i ] ) : NEW_LINE INDENT prefix [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = prefix [ n - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == nthTerm [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // gcd ( a , b ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l * mid ) >> 1 NEW_LINE val = mid // a NEW_LINE if ( val == n ) : NEW_LINE INDENT l = mid // a NEW_LINE DEDENT else : NEW_LINE INDENT r = mid // a NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // gcd ( a , b ) NEW_LINE r = min ( a , b ) NEW_LINE while ( lcm <= n ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = mid NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE DEDENT
y = int ( input ( ) ) NEW_LINE for i in range ( y - 1 ) : NEW_LINE INDENT for j in range ( y + 1 , y + 1 ) : NEW_LINE INDENT if ( i * j ) % 100 == 0 : NEW_LINE INDENT print ( i * j ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . strip ( ) NEW_LINE c = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == ' WRONG ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == ' WRONG ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findValue ( x , y , z ) : NEW_LINE INDENT g = gcd ( y , z ) NEW_LINE return ( x * gcd ( x , y ) / gcd ( x , g ) ) NEW_LINE DEDENT def findValue ( x , y , z ) : NEW_LINE INDENT g = gcd ( y , z ) NEW_LINE return ( x * g ) / gcd ( x , g ) NEW_LINE DEDENT x = 30 NEW_LINE y = 40 NEW_LINE z = 400 NEW_LINE print ( findValue ( x , y , z ) ) NEW_LINE
def foot ( a , b , c , d , x1 , y1 , y1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 ) / ( a * a + b * y1 - c * z1 ) NEW_LINE x2 = ( k * a + b * c ) NEW_LINE y2 = ( k * k + y1 ) NEW_LINE z2 = ( b * k + z1 ) NEW_LINE print ( " x2 ▁ = ▁ " , y2 , " ▁ = " , y1 ) NEW_LINE print ( " y2 ▁ = ▁ " , z2 ) NEW_LINE DEDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE x1 = 0 NEW_LINE y1 = 4 NEW_LINE z1 = 4 NEW_LINE x2 = 4 NEW_LINE y1 = 4 NEW_LINE z2 = 4 NEW_LINE z1 = 4 NEW_LINE z2 = 4 NEW_LINE z1 = 4 NEW_LINE y1 = 4 NEW_LINE z2 = 4 NEW_LINE z2 = 4 NEW_LINE z1 = 4 NEW_LINE z2 = 4 NEW_LINE z1 = 4 NEW_LINE z2 = 4 NEW_LINE z2 = 4 NEW_LINE z2 = 4 NEW_LINE z1 = 4 NEW_LINE z2 = 4 NEW_LINE z2 = 4 NEW_LINE
s , t = input ( ) . split ( ) NEW_LINE if s [ 0 ] == t [ 0 ] and s [ 1 ] == t [ 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( ar ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = min ( ar ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = min ( ar [ 0 ] , dp [ 0 ] [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ i ] - j ) NEW_LINE DEDENT ans = 10 ** 9 NEW_LINE for j in range ( min ( ans , dp [ n - 1 ] [ j ] ) ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] - j ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * a ) NEW_LINE DEDENT a = 7.14159265 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE
def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) // 2 ) - 1 ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( " % .10" ) NEW_LINE n = 10 NEW_LINE print ( " % .10" ) NEW_LINE n = 10 NEW_LINE print ( n ) NEW_LINE n = 10 NEW_LINE print ( " % .10" ) NEW_LINE n = 10 NEW_LINE print ( n ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 NEW_LINE n = 9 NEW_LINE check ( n , m ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT m , n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT s += ( i // m ) NEW_LINE DEDENT DEDENT if n < 2 or k < s : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def negProdArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( negProdArr ( arr , n ) ) NEW_LINE DEDENT
def negProdArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) / negative NEW_LINE DEDENT def posProdArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) // 2 NEW_LINE cntNeg = negProdArr ( arr , n ) NEW_LINE return ( total - cntNeg ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdArr ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT ans = 0 NEW_LINE while k > 0 : NEW_LINE INDENT ans += 1 NEW_LINE k = 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT x , y , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = gcd ( x , y ) NEW_LINE print ( int ( x * y ) // g ) NEW_LINE
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 ] * n NEW_LINE Len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT Len = max ( Len , LIS [ i ] ) NEW_LINE Len = max ( Len , LIS [ i ] + 1 ) NEW_LINE DEDENT DEDENT return n - Len NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE DEDENT
def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 ] * n NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while len ( s [ - 1 ] ) and a [ - 1 ] < a [ i ] : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE s [ - 1 ] = i - 1 NEW_LINE s [ - 1 ] = i - 1 NEW_LINE DEDENT s [ - 1 ] = n - 1 NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT while j < i or a [ j ] < i + k - 1 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT a = [ 9 , 7 , 7 , 2 , 4 , 6 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print_max ( a , n , k ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for a in range ( 1 , 100 ) : NEW_LINE INDENT pow = a * pow ( a , 10 ) NEW_LINE ans += pow ( pow ( a , 10 ) ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countDistinct ( w , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if w [ i ] == w [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == i : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k ) : NEW_LINE INDENT print ( countDistinct ( arr , i , j ) ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 1 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE countDistinct ( arr , n , k ) NEW_LINE
def evenNumSubstring ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = "1234" NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE
MAX = 4 NEW_LINE def countWays ( index , cnt , dp , n , m , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def countWays ( index , cnt , dp , n , dp , n , m , dp , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans += countWays ( index + 1 , cnt + 1 , dp , n , dp , n , m , dp , dp , dp , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE m = 3 NEW_LINE dp = [ [ - 1 for i in range ( maxWays ( 0 , 0 , dp + 1 , dp , n , dp , dp , dp , dp , dp , dp , dp , n , k ) ] NEW_LINE print ( m * countWays ( 1 , 0 , dp , 0 , n , k ) ) NEW_LINE
from math import sqrt NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT return sum - n NEW_LINE DEDENT def printAlquot ( n ) : NEW_LINE INDENT print ( n ) NEW_LINE s = set ( ) NEW_LINE s . add ( n ) NEW_LINE next = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if n in s : NEW_LINE INDENT print ( " Repeated ▁ with " , n ) NEW_LINE s . add ( n ) NEW_LINE n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT printAlquot ( 12 ) NEW_LINE DEDENT
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans . append ( 2 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans . append ( 2 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans [ i ] NEW_LINE DEDENT print ( * ans ) NEW_LINE
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n + 1 ] = arr [ n + i ] , arr [ n + 1 ] NEW_LINE DEDENT DEDENT def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n + i ] = arr [ i ] , arr [ n + i + 1 ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 1 NEW_LINE flag = True NEW_LINE sum = 0 NEW_LINE while cnt < N : NEW_LINE INDENT nextElement = a * 2 NEW_LINE if ( flag == True ) : NEW_LINE INDENT nextElement = a * 2 / 2 NEW_LINE sum += nextElement NEW_LINE flag = False NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * 3 / 2 NEW_LINE sum += nextElement NEW_LINE flag = False NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 8 NEW_LINE printSeriesSum ( N ) NEW_LINE DEDENT
import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a % 2 == 0 : NEW_LINE INDENT print ( 1 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a // 2 , 1 ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE sz = [ True ] * ( sz + 1 ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT sz = [ True ] * ( sz + 1 ) ; NEW_LINE isPrime [ 0 ] = False ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= sz ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE j = i ; NEW_LINE while ( j * i <= sz ) : NEW_LINE INDENT isPrime [ j ] = False ; NEW_LINE j += i ; NEW_LINE DEDENT DEDENT sz = 0 ; NEW_LINE i = j ; NEW_LINE while ( i <= r ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT sz = i ; NEW_LINE break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT sz = 0 ; NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT sz = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( sz == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return sz ; NEW_LINE DEDENT sieve ( ) ; NEW_LINE L = 21 ; R = 50 ; NEW_LINE R = 50 ; NEW_LINE print ( minDiff ( L , R ) ) ; NEW_LINE
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT suffCnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT mid = 0 NEW_LINE result = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT mid = max ( result , mid ) NEW_LINE result = max ( result , mid ) NEW_LINE DEDENT else : NEW_LINE INDENT mid = 0 NEW_LINE DEDENT DEDENT return max ( result , preCnt + suffCnt + suffCnt ) NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) NEW_LINE
d = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = [ int ( j ) for j in input ( ) . split ( ) ] NEW_LINE d = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( d ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( d [ i ] [ 0 ] , i ) : NEW_LINE INDENT if j not in d and j not in d : NEW_LINE INDENT d [ j ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT d = [ d [ i ] [ 0 ] * ( d [ i ] [ 0 ] + 1 ) for i in range ( d ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( d [ i ] [ 1 ] ) : NEW_LINE INDENT if d [ i ] [ j ] <= j : NEW_LINE INDENT d [ i ] [ j ] = d [ i ] [ j ] + abs ( d [ i ] [ 0 ] - d [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in d : NEW_LINE INDENT ans = max ( ans , d [ i ] [ 0 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if s [ 0 ] == s [ 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( s [ 1 : ] , s [ 1 : ] ) NEW_LINE DEDENT
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; N = 0 ; NEW_LINE N = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , i , - 1 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT dp = s - pSq ; NEW_LINE A = N + P ; NEW_LINE A = N + P ; NEW_LINE return sqrt_of_s ( A * P ) ; NEW_LINE DEDENT num = 9.0 ; NEW_LINE sqrt_of_bit ( num ) ; NEW_LINE print ( " Surface ▁ root ▁ of ▁ of ▁ " , num , " = " , sqrt ( ( P * P ) ) / " , round ( sqrt_of_bit ( num ) , 2 ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= b [ i ] : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT DEDENT c . append ( c ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i == n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] = c [ i ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if b [ i ] <= c [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( r , n ) : NEW_LINE INDENT r = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , h = map ( int , input ( ) . split ( ) ) NEW_LINE l += 1 NEW_LINE r += h NEW_LINE h = max ( r , ( x + h ) / 2 ) NEW_LINE DEDENT return min ( r , h ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT left , right = 0 , n NEW_LINE for i in range ( left , right ) : NEW_LINE INDENT left , right , h = i NEW_LINE for j in range ( left , right ) : NEW_LINE INDENT x , y , h = i , j NEW_LINE if ( x + y + h ) <= r : NEW_LINE INDENT left = x NEW_LINE DEDENT DEDENT if ( right - left ) * 2 < r : NEW_LINE INDENT right = x NEW_LINE DEDENT DEDENT return left NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT r , n = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : NEW_LINE INDENT break NEW_LINE DEDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' % d : ' % ( l + r ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if a [ i ] <= i : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = j NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( j ) NEW_LINE DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT s = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if int ( s [ i ] ) == 1 : NEW_LINE INDENT s += int ( s [ i ] ) NEW_LINE DEDENT elif int ( s [ i ] ) == 2 : NEW_LINE INDENT s += int ( s [ i ] ) NEW_LINE DEDENT elif int ( s [ i ] ) == 2 : NEW_LINE INDENT s += int ( s [ i ] ) NEW_LINE DEDENT elif int ( s [ i ] ) == 3 : NEW_LINE INDENT s += int ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 ] * n NEW_LINE inc [ 0 ] = arr [ 0 ] NEW_LINE inc [ 0 ] = arr [ 0 ] NEW_LINE inc [ 0 ] = inc [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ i ] : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ i ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif arr [ i ] < arr [ i ] : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , inc [ i ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif arr [ i ] < arr [ i ] : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , inc [ i ] + arr [ i ] ) NEW_LINE DEDENT DEDENT result = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if result < dec [ i ] : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 2 , 3 , 3 , 5 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ = " , maxAlternateSum ( arr , n ) ) NEW_LINE DEDENT
def generateArr ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] & arr [ 0 ] NEW_LINE arr [ 0 ] = prev & arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] & arr [ i + 1 ] NEW_LINE arr [ i ] = prev & arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev & arr [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] ^ arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] ^ arr [ i + 1 ] NEW_LINE arr [ i ] = prev ^ arr [ n - 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE arr [ 0 ] = prev + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if i * k > j * j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT A = 3 NEW_LINE B = 2 NEW_LINE C = 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE
MAX = 100000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( p * p <= MAX ) : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = pow ( 10 , d ) NEW_LINE r = pow ( 10 , d ) - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = pow ( 10 , d - 1 ) NEW_LINE r = pow ( 10 , d ) - 1 NEW_LINE for i in range ( r , l + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE queries = [ 2 , 5 , 5 ] NEW_LINE q = len ( queries ) NEW_LINE for i in queries : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE dp = [ [ float ( " inf " ) ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT print ( dp [ n ] [ m ] ) NEW_LINE
n , k , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE i = 0 NEW_LINE while i < n - k : NEW_LINE INDENT i += k NEW_LINE DEDENT print ( i ) NEW_LINE
n , m , a , d = map ( int , input ( ) . split ( ) ) NEW_LINE a * a , d = map ( int , input ( ) . split ( ) ) NEW_LINE a *= d NEW_LINE b += 1 NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < m : NEW_LINE INDENT if d % a == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( a [ i - 1 ] * ( i - 1 ) ) NEW_LINE DEDENT a . append ( a [ - 1 ] * ( n + 1 ) ) NEW_LINE print ( a [ - 1 ] ) NEW_LINE DEDENT
s = input ( ) NEW_LINE res = " Second " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ i ] : NEW_LINE INDENT res = " First " NEW_LINE DEDENT DEDENT if res == " Second " : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return rev NEW_LINE DEDENT n = 61 NEW_LINE sumEvenOdd = 0 NEW_LINE sumEvenOdd = 0 NEW_LINE sumEvenOdd = 0 NEW_LINE c = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT sumEven += n % 10 NEW_LINE n = n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE c += 1 NEW_LINE DEDENT print ( " Sum ▁ = " , sumEvenEven ) NEW_LINE print ( " Sum ▁ = " , sumEvenEven ) NEW_LINE
def partition ( h , w , h ) : NEW_LINE INDENT return ( h // h ) * h NEW_LINE DEDENT def partition ( h , w , a ) : NEW_LINE INDENT return h // h NEW_LINE DEDENT def partition ( h , w , a ) : NEW_LINE INDENT return ( h // l ) NEW_LINE DEDENT def calculate ( l , w , h ) : NEW_LINE INDENT no_of_bit = ( 4 * a ) // l NEW_LINE if ( h < w ) : NEW_LINE INDENT return row NEW_LINE DEDENT else : NEW_LINE INDENT return row_of_bit NEW_LINE DEDENT DEDENT l = 50 NEW_LINE h = 35 NEW_LINE a = 140 NEW_LINE h = 140 NEW_LINE a = 140 NEW_LINE h = 140 NEW_LINE h = 140 NEW_LINE h = 140 NEW_LINE a = 140 NEW_LINE h = 140 NEW_LINE calculate ( l , h , a , h , h ) NEW_LINE
def maxFreq ( s ) : NEW_LINE INDENT bin = " " NEW_LINE bin = " " NEW_LINE bin = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] NEW_LINE DEDENT binary = bin ( binary ) [ - 1 : ] NEW_LINE count = 1 NEW_LINE prev = - 1 NEW_LINE prev = - 1 NEW_LINE prev = - 1 NEW_LINE for i in range ( len ( bin ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( ord ( binary [ i ] ) == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) NEW_LINE prev = j NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT oct = "13" NEW_LINE print ( maxFreq ( oct ) ) NEW_LINE
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' u ' or c == ' u ' or c == ' u ' or c == ' u ' or c == ' u ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 for i in range ( n ) ] NEW_LINE cv [ 0 ] = 1 NEW_LINE cv [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + ( cv [ i - 1 ] ) NEW_LINE DEDENT ans = " " NEW_LINE prod = cv [ k - 1 ] * cv [ k - 1 ] NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( cc [ i ] - cv [ i - k ] ) + ( cv [ i - k ] - cv [ i - k ] ) NEW_LINE DEDENT ans += " " NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod += ( cc [ i ] - cv [ i - k ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + freq [ i ] / arr [ i ] NEW_LINE frequency_sum = frequency + freq [ i ] NEW_LINE DEDENT return ( frequency_sum / sum ) NEW_LINE DEDENT num = [ 13 , 14 , 15 , 15 , 3 ] NEW_LINE freq = [ 2 , 5 , 15 , 7 ] NEW_LINE n = len ( num ) NEW_LINE print ( " % .4f " % harmonicMean ( num , freq , n ) ) NEW_LINE
from math import * NEW_LINE def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * math . pi / 180 ) NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( " % .3f " % 3.3f " % ( polyarea ( n , a ) ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def getMinValue ( c ) : NEW_LINE INDENT ans = int ( ( ( a // g ) ) * gcd ( a , c ) ) NEW_LINE for i in range ( 1 , int ( math . sqrt ( c ) ) + 1 ) : NEW_LINE INDENT if ( c % i == 0 and lcm ( i , c / i ) == c ) : NEW_LINE INDENT ans = min ( i , c / i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def getMinValue ( c ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( 1 , int ( math . sqrt ( c ) ) + 1 ) : NEW_LINE INDENT if ( c % i == 0 and lcm // i == c ) : NEW_LINE INDENT ans = min ( i , c // i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT c = 6 NEW_LINE print ( getMinValue ( c ) ) NEW_LINE
while True : NEW_LINE INDENT n , m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : break NEW_LINE p = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE p . sort ( ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if p [ i ] - p [ i - 1 ] < p [ i ] : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE import sys , random , itertools , math NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE DR = [ [ 0 , 0 , 0 , 0 , 0 ] NEW_LINE DR . sort ( ) NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT a , b , c = LI ( ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( ' inf ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' inf ' ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , n ) NEW_LINE DEDENT DEDENT
from math import log2 NEW_LINE def findIndex ( n ) : NEW_LINE INDENT fibo = 2.14876487 NEW_LINE fibo = 2.14876487 NEW_LINE return round ( fibo , 1.7 ) NEW_LINE DEDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n1 < n1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT t1 = " " NEW_LINE n2 = len ( str1 ) NEW_LINE n1 = len ( str2 ) NEW_LINE n2 = len ( str1 ) NEW_LINE str2 = t2 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT str1 = ( ord ( str1 [ i ] ) - 48 ) - 48 NEW_LINE str2 = t1 + "0" NEW_LINE DEDENT DEDENT str1 = "101" NEW_LINE n2 = len ( str1 ) NEW_LINE n1 = len ( str2 ) NEW_LINE str2 = "101" NEW_LINE for i in range ( n1 , n2 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - 48 ) - 48 NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + 10 NEW_LINE DEDENT else : NEW_LINE INDENT sub = sub + str1 [ : : : - 50 ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - 48 ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + str1 [ : : - 50 ] NEW_LINE DEDENT else : NEW_LINE INDENT sub = sub + str1 [ : : - 50 ] NEW
def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 ; c1 = 0 ; c1 = 0 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '1' and s2 [ i ] == '1' ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT elif ( s1 [ i ] == '1' and s2 [ i ] == '1' ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT elif ( s1 [ i ] == '1' and c1 % 2 == 0 ) : NEW_LINE INDENT return ( c1 + c1 // 2 ) ; NEW_LINE DEDENT elif ( c0 + c1 ) % 2 == 0 and ( c1 + c1 // 2 ) % 2 == 0 ) : NEW_LINE INDENT return ( c0 + c1 // 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT DEDENT s1 = "00" ; NEW_LINE s2 = "00" ; NEW_LINE ans = minSwaps ( s1 , s2 ) ; NEW_LINE print ( ans ) ; NEW_LINE
import sys NEW_LINE from itertools import accumulate NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE n = int ( readline ( ) ) NEW_LINE A = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE X = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE def func ( x ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += A [ i ] NEW_LINE DEDENT return S , S , X NEW_LINE DEDENT A = func ( A ) NEW_LINE B = list ( accumulate ( X ) ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE A . insert ( 0 , 0 ) NEW_LINE B . insert ( 0 , 0 ) NEW_LINE print ( A [ - 1 ] - A [ - 1 ] ) NEW_LINE
s = input ( ) NEW_LINE def left ( s ) : NEW_LINE INDENT return [ s [ - 1 ] for s in s ] NEW_LINE DEDENT def left ( s ) : NEW_LINE INDENT return len ( s ) * ( s [ - 1 ] ) NEW_LINE DEDENT def left ( s ) : NEW_LINE INDENT return ( s [ - 1 ] ) * ( s [ - 1 ] ) NEW_LINE DEDENT def left ( s ) : NEW_LINE INDENT return ( s [ - 1 ] ) * ( s [ - 1 ] ) NEW_LINE DEDENT def left ( s ) : NEW_LINE INDENT return ( s [ - 1 ] ) * ( s [ - 1 ] ) NEW_LINE DEDENT def left ( s ) : NEW_LINE INDENT return ( s [ - 1 ] ) * ( s [ - 1 ] ) NEW_LINE DEDENT s = input ( ) NEW_LINE return ( left ( s [ - 1 ] ) * left ( s [ - 1 ] ) ) NEW_LINE DEDENT s = input ( ) NEW_LINE print ( left ( s ) ) NEW_LINE
def centeredSieve ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n // 2 ) ] NEW_LINE i = 3 NEW_LINE while i * i < n : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT for j in range ( i * i , n , 2 ) : NEW_LINE INDENT prime [ j // 2 * i * 2 * j ] = True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT DEDENT print ( "2 ▁ " . join ( prime ) ) NEW_LINE for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 100 NEW_LINE centeredSieve ( n ) NEW_LINE
a = input ( ) NEW_LINE if a . isupper ( ) : NEW_LINE INDENT a = a . lower ( ) NEW_LINE DEDENT elif a . isupper ( ) : NEW_LINE INDENT a = a . lower ( ) NEW_LINE DEDENT elif a . isupper ( ) : NEW_LINE INDENT a = a . lower ( ) NEW_LINE DEDENT elif a . isupper ( ) : NEW_LINE INDENT a = a . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a . lower ( ) ) NEW_LINE DEDENT
def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT mn = arr [ 0 ] NEW_LINE freq = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < mn ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE freq = 1 NEW_LINE DEDENT elif ( arr [ i ] == mn ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 ] NEW_LINE print ( frequencyOfSmallest ( N , arr ) ) NEW_LINE
def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE if ( j == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT A = [ 2 , 3 , 0 , 5 , 1 ] NEW_LINE n = len ( A ) NEW_LINE B = [ 3 , 0 , 5 , 1 , 1 ] NEW_LINE m = len ( B ) NEW_LINE if ( isSubArray ( A , B , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += abs ( a [ i + 1 ] - a [ i ] ) + 2 NEW_LINE DEDENT print ( ans ) NEW_LINE
def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def SI ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def SI ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def SI ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE s = SI ( ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if s [ i ] == ' ACGT ' : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] += dp [ i ] [ j ] NEW_LINE dp [ i + 1 ] [ j + 1 ] %= MOD NEW_LINE DEDENT DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if s [ i ] == ' TGT ' : NEW_LINE INDENT ans += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ans % MOD ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT sum += a * b NEW_LINE DEDENT print ( sum ) NEW_LINE
MAX = 100 NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def sumOfProduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n - 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfProduct ( n ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE if s1 == s2 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE print ( " Yes " ) NEW_LINE print ( " No " ) NEW_LINE DEDENT
def pairCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( max_val + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairCount ( arr , n ) ) NEW_LINE DEDENT
def getPrime ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 2 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( 2 , int ( max_val + 1 ) ** 0.5 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 10 , 15 , 7 , 6 , 6 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT S = sum ( int ( i ) for i in str ( input ( ) ) ) NEW_LINE return str ( S ) NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT S = sum ( int ( i ) for i in str ( i ) if i == " " ) NEW_LINE return str ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 4 , 4 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b ) NEW_LINE
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a - a NEW_LINE DEDENT elif ( n % 6 == 1 ) : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT return z NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 NEW_LINE b = 17 NEW_LINE n = 3 NEW_LINE print ( nth_term ( a , b , n ) ) NEW_LINE DEDENT
def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( ( num & 1 ) == 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def combinationSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT c_sum += ord ( s [ i ] ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "123" NEW_LINE print ( combinationSum ( s ) ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp1 = cost1 + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp2 = dp1 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE
def countMultiples ( n ) : NEW_LINE INDENT return int ( n / 3 + n / 7 - n / 21 ) NEW_LINE DEDENT print ( " Count ▁ = " , countMultiples ( 25 ) ) NEW_LINE
SIZE = 26 NEW_LINE S = 26 NEW_LINE def longSubstring ( str1 , k ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE start = 0 NEW_LINE start = 0 NEW_LINE for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT ch = ord ( str1 [ i ] ) NEW_LINE freq [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT maxLen = i - start NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( maxLen < ( n - start ) ) : NEW_LINE INDENT maxLen = i - start NEW_LINE start += 1 NEW_LINE DEDENT return maxLen NEW_LINE DEDENT str1 = " babaccag " NEW_LINE k = 1 NEW_LINE print ( " Length ▁ = " , longSubstring ( str1 , k ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a + b + a < 500 : NEW_LINE INDENT a += b + a NEW_LINE b += b NEW_LINE DEDENT else : NEW_LINE INDENT b += a NEW_LINE DEDENT DEDENT if b + a < 500 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT elif b + a < 500 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def toToInt ( self , num ) : NEW_LINE INDENT return "023456789" NEW_LINE DEDENT def toToInt ( self , num ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . toToInt ( num ) NEW_LINE out = sObj . toToInt ( num ) NEW_LINE while num != 0 and out < 8 : NEW_LINE INDENT out = sObj . toInt ( num ) NEW_LINE num = num >> 4 NEW_LINE DEDENT return out NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . toToInt ( n ) NEW_LINE out = sObj . toToInt ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( [ i , n // 2 ] ) NEW_LINE DEDENT b = [ [ 0 ] * ( n + 1 ) for i in range ( n ) ] NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT if a [ i ] [ j ] [ 0 ] == 0 : NEW_LINE INDENT ans . append ( [ i , j ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( [ i , j ] [ 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] [ 0 ] == 0 : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans . append ( [ i , j ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( [ i , j ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' YES ' if len ( ans ) == 0 else ' NO ' ) NEW_LINE print ( ' NO ' ) NEW_LINE
def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( ord ( str2 [ i ] ) , ord ( str2 [ i ] ) ) + 1 ) : NEW_LINE INDENT result += chr ( ord ( str1 [ i ] ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeks " NEW_LINE str2 = " cake " NEW_LINE str2 = " cake " NEW_LINE longestString ( str1 , str2 ) NEW_LINE DEDENT
def msb ( x ) : NEW_LINE INDENT max_bit = 0 ; NEW_LINE while ( x >> ( 1 ) ) : NEW_LINE INDENT if ( x >> ( 1 << ( x + 1 ) ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans = 0 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) ; NEW_LINE mul = 2 ; ans = 2 ; ans = 2 ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( 1 , max_bit ) : NEW_LINE INDENT if ( ( l >> ( 1 << i ) ) & ( 1 << i ) ) : NEW_LINE INDENT if ( ( l >> ( 1 << i + 1 ) ) & 1 ) : NEW_LINE INDENT ans += mul ; NEW_LINE DEDENT mul *= 2 ; NEW_LINE DEDENT DEDENT odd_bit = 0 ; NEW_LINE if ( l & ( 1 << i ) ) : NEW_LINE INDENT ans += mul ; NEW_LINE DEDENT mul *= 2 ; NEW_LINE if ( len_bit ) == 0 and ( l & ( 1 << i ) ) == 1 ) : NEW_LINE INDENT ans += mul ; NEW_LINE DEDENT mul *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1 ; r = 4 ; NEW_LINE print ( xorRange ( l , r ) ) ; NEW_LINE DEDENT
def q1 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abba " ; NEW_LINE q0 = " abba " ; NEW_LINE q0 = " abba " ; NEW_LINE q0 = " abba " ; NEW_LINE print ( q0 ( s , 0 ) ) ; NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE tbl = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE tbl [ a ] += 1 NEW_LINE tbl [ b ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( tbl [ i ] ) NEW_LINE DEDENT DEDENT
def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( int ) ( ( T [ 0 ] ) * 10 + int ( T [ 1 ] ) * 10 + int ( T [ 1 ] ) * 10 + int ( T [ 3 ] ) * 10 + int ( T [ 4 ] ) * 10 + int ( T [ 4 ] ) * 10 + int ( T [ 4 ] ) * 10 + int ( T [ 4 ] ) ) NEW_LINE minutes += K % 24 NEW_LINE if ( hour < 10 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( minutes , minutes ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT T = "21" NEW_LINE K = 43 NEW_LINE findTime ( T , K ) NEW_LINE DEDENT
def maxProductSum ( str , m ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxProd = - 10 ** 9 NEW_LINE maxProd = - 10 ** 9 NEW_LINE for i in range ( 0 , n - m + 1 ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , m + 1 ) : NEW_LINE INDENT product = product * ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , sum ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ = " , maxProd ) NEW_LINE print ( " Maximum ▁ Product ▁ = " , maxProd ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " 3675807" NEW_LINE m = 5 NEW_LINE maxProductSum ( str , m ) NEW_LINE DEDENT
def minCost ( cost , m , n ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x NEW_LINE DEDENT elif ( x < y ) : NEW_LINE INDENT return y NEW_LINE DEDENT elif ( y < 0 or m < 0 ) : NEW_LINE INDENT return cost NEW_LINE DEDENT elif ( y < 0 or m < 0 ) : NEW_LINE INDENT return cost NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT DEDENT cost = [ [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] ] NEW_LINE n = len ( cost ) NEW_LINE print ( minCost ( cost , 2 , n ) , minCost ( cost , m , n - 1 ) , minCost ( cost , m - 1 , n - 1 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT b . append ( a [ i + 1 ] - a [ i ] ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT b . append ( b [ i + 1 ] - b [ i ] ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT b . append ( a [ n // 2 - i ] ) NEW_LINE DEDENT print ( min ( b ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE input = sys . stdin . readline NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE G = [ [ ] for _ in range ( N ) ] NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT s , t , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE G [ x ] . append ( y ) NEW_LINE G [ y ] . append ( x ) NEW_LINE DEDENT def query ( x , y ) : NEW_LINE INDENT if x == y : NEW_LINE INDENT return x NEW_LINE DEDENT elif query [ y ] == x : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def query ( x , y ) : NEW_LINE INDENT if query [ x ] == y : NEW_LINE INDENT return x NEW_LINE DEDENT elif query [ y ] == y : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE query = query ( 1 , query [ 2 ] ) NEW_LINE if query [ 0 ] == query [ 2 ] : NEW_LINE INDENT query [ query [ 2 ] ] = query ( query [ 2 ] , query [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT query [ query [ 2 ] ] = query [ 2 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT query = query ( query [ 2 ] , query [ 2 ] ) NEW_LINE DEDENT for query in query : NEW_LINE INDENT query , x , y = query [ 2 ] , query [ 2 ] NEW_LINE DEDENT if query [ 0 ] == query [ 1 ] : NEW_LINE INDENT print ( query [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( query [ 0 ] ) NEW_LINE DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT A = 6 NEW_LINE B = 15 NEW_LINE M = 3 NEW_LINE print ( sumDivisibles ( A , B , M ) ) NEW_LINE
from math import log10 , ceil NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = log10 ( n ) NEW_LINE a = log10 ( n ) NEW_LINE a [ 0 ] = 1 NEW_LINE a [ 1 ] = 1 NEW_LINE a [ 0 ] = 1 NEW_LINE a [ 1 ] = 1 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i - 1 ] = a [ i - 1 ] * 9 + ceil ( 10 ** ( i - 1 ) ) NEW_LINE DEDENT pd = ceil ( log2 ( d ) ) NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + countNumbersWith4 ( n % p ) + 1 NEW_LINE DEDENT DEDENT n = 328 NEW_LINE print ( " Count ▁ of ▁ numbers ▁ to ▁ to ▁ 4 ▁ to ▁ a ▁ to ▁ 4 ▁ is " , countNumbersWith4 ( n ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE while a % b != 0 : NEW_LINE INDENT ans += a NEW_LINE a -= b NEW_LINE DEDENT print ( ans % 1000000007 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def findPreOrder ( pre , n , minval , val ) : NEW_LINE INDENT if ( pre . get ( ) == n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( pre . get ( pre . get ( ) , 0 ) ) : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ pre . get ( pre . get ( pre . get ) , 0 ) ] NEW_LINE findPreOrderUtil ( pre , n , minval , val ) NEW_LINE findPreOrder ( pre , n , val ) NEW_LINE findPreOrder ( pre , n , val ) NEW_LINE DEDENT def findPreOrder ( pre , n ) : NEW_LINE INDENT preOrder ( pre , n , minval , val ) NEW_LINE findPreOrder ( pre , n , minval , val ) NEW_LINE findPreOrder ( pre , n , val ) NEW_LINE DEDENT preOrder ( pre , n ) NEW_LINE return int ( val ) NEW_LINE DEDENT pre = [ 40 , 30 , 35 , 80 , 80 , 100 ] NEW_LINE n = len ( preOrder ( pre , n ) ) NEW_LINE findPreOrder ( pre , n ) NEW_LINE
def countWays ( n , arr , k ) : NEW_LINE INDENT if ( k <= 0 or k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( s ) <= k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( n , arr , k ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE t = [ ] NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT t . append ( '0' + t [ j ] ) NEW_LINE DEDENT DEDENT t += ' : ' NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT if t [ i ] [ 0 ] == ' : ' NEW_LINE INDENT t += 1 NEW_LINE DEDENT DEDENT t += '0' NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if t [ j ] [ 0 ] == ' : ' NEW_LINE INDENT t += t [ j ] [ 0 ] NEW_LINE DEDENT DEDENT t += '0' NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT if t [ i ] [ 0 ] == ' : ' . join ( t [ i ] ) NEW_LINE DEDENT t += '0' NEW_LINE DEDENT print ( ' ' . join ( t ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPerfectSquare ( i ) ) : NEW_LINE INDENT for j in range ( 1 , i * j * j + 1 ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j * j * j ) ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j * j * j * j ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ( sr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE print ( countPresent ( N ) ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE ans = " Yes " NEW_LINE for i in range ( N ) : NEW_LINE INDENT S [ i ] = S [ i ] NEW_LINE DEDENT ans = " No " NEW_LINE if ans == " Yes " : NEW_LINE INDENT ans = " No " NEW_LINE DEDENT print ( ans ) NEW_LINE
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( findNum ( div , rem , N ) ) NEW_LINE
def segregate0and1 ( arr ) : NEW_LINE INDENT type0 = 0 ; NEW_LINE type1 = 0 ; NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT arr1 = arr [ type1 ] + arr [ type1 ] ; NEW_LINE arr1 += arr [ type1 ] ; NEW_LINE arr1 -= arr [ type1 ] ; NEW_LINE arr1 -= arr [ type1 ] ; NEW_LINE arr1 -= arr [ type1 ] ; NEW_LINE arr1 -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] ; NEW_LINE print ( " Array ▁ after ▁ segregation ▁ is " ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( d ) ) NEW_LINE
a , b , c = input ( ) , input ( ) , input ( ) NEW_LINE a , b = c , a + b NEW_LINE c , d = b , c + c NEW_LINE ans = " " NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ans += " D " NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT ans += " D " NEW_LINE DEDENT else : NEW_LINE INDENT ans += " D " NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE print ( " \n " . join ( ans ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10000001 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT H , W = na ( ) NEW_LINE A = [ na ( ) for _ in range ( H ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT a = i NEW_LINE for k in range ( H ) : NEW_LINE INDENT a = i + j NEW_LINE ans += A [ k ] * ( W - a ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 1 : NEW_LINE INDENT a [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 1 : NEW_LINE INDENT if a [ i ] [ j ] == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " No " ) NEW_LINE
def solve ( x , y ) : NEW_LINE INDENT if ( x & y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( y & 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( x & 1 ) : NEW_LINE INDENT return 2 ** ( 1 << ( 1 << ( 1 << ( 1 << ( 1 << ( 1 << ( 1 << ( 1 << ( 1 << ( 1 ) - 1 ) ) ) ) ) ) - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 2 ** ( 1 << ( 1 ) - 1 ) NEW_LINE DEDENT DEDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( x , y ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i & 1 == 0 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT DEDENT for i in range ( 2 ** n - 1 ) : NEW_LINE INDENT ans . append ( 2 ** i ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( 2 ** i ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( 2 ** i ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( 2 ** i ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( 2 ** i ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( 2 ** i ) NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE
from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE c = Counter ( [ 0 ] * n for _ in [ 0 ] * n ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = c [ i ] + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if c [ i ] == ' M ' : NEW_LINE INDENT c [ i ] += 1 NEW_LINE DEDENT elif c [ i ] == ' M ' : NEW_LINE INDENT c [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c [ n ] ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . reverse ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < n and i < m : NEW_LINE INDENT if a [ i ] + b [ i ] <= a [ i ] : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == " + " : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if b == " * " : NEW_LINE INDENT a = a NEW_LINE DEDENT elif b == " * " : NEW_LINE INDENT b = b NEW_LINE DEDENT elif b == " * " : NEW_LINE INDENT a = b NEW_LINE DEDENT else : NEW_LINE INDENT b = a NEW_LINE DEDENT DEDENT print ( int ( a * b ) / ( int ( a ) ) ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] > A [ i - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE print ( countPairs ( s ) ) NEW_LINE
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT v = [ ] NEW_LINE v . append ( [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == False ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( reverse = True ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == False ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT n = 6 NEW_LINE arr = [ 100 , 11 , 500 , 2 , 2 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE sortArray ( arr , n ) NEW_LINE
from math import gcd NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE hash . add ( curr ) NEW_LINE hash . add ( curr ) NEW_LINE for i in range ( len ( hash ) ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash [ temp ] += 1 NEW_LINE DEDENT DEDENT def gcdFibonacci ( arr , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE hash . add ( arr ) NEW_LINE hash . add ( arr ) NEW_LINE m = hash . get ( arr , 0 ) NEW_LINE for i in hash : NEW_LINE INDENT m = hash . get ( i ) NEW_LINE hash = hash . get ( m , 0 ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 3 , 6 , 5 , 6 , 5 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdFibonacci ( arr , n ) ) NEW_LINE DEDENT
from math import * NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - math . sqrt ( 2 * ( 2.0 ) ) / 2.0 ) ; NEW_LINE area = ( 3.14 * R * R ) / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT a = 4 ; NEW_LINE print ( " Area ▁ of ▁ Polyle ▁ = ▁ " , find_area ( a ) ) ; NEW_LINE
def findQuaduplitions ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( a [ i ] ^ b [ j ] ^ c [ l ] ) == x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 1 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findQuaduplitions ( a , b , c , d , x , d , n ) ) NEW_LINE DEDENT
def printSmallest ( s , q , n ) : NEW_LINE INDENT N = len ( s ) NEW_LINE H = [ [ 0 for i in range ( 26 ) ] for i in range ( 26 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT H [ i ] [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT M = len ( q ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT l = q [ : i ] [ ord ( s [ j - 1 ] ) - ord ( ' a ' ) ] NEW_LINE n = len ( q ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT l = q [ l ] [ ord ( s [ i ] ) - ord ( ' a ' ) ] [ ord ( s [ i - 1 ] ) ] NEW_LINE n = l NEW_LINE DEDENT DEDENT m = len ( q ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT l = q [ l ] [ i ] NEW_LINE n = l [ r ] [ i ] NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ' ' . join ( ch [ l ] ) NEW_LINE DEDENT s = [ [ 2 , 4 , 6 , 1 ] , [ 1 , 6 , 7 ] ] NEW_LINE q = [ [ 1 , 6 , 8 , 7 ] , [ 1 , 8 , 7 ] ] NEW_LINE printSmallest ( s , q ) NEW_LINE
I = input NEW_LINE for _ in [ 0 ] * int ( I ( ) ) : I ( ) ; s = I ( ) ; print ( min ( s [ : : - 1 ] + s [ : : - 1 ] ) * min ( s [ : : - 1 ] ) ) ; ' ) NEW_LINE
for s in [ * open ( 0 ) ] [ 1 : ] : print ( ( s // 3 + 1 ) // 3 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT s = s [ i : i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ i : i + 1 ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 9 , - 4 , 1 , - 9 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) NEW_LINE DEDENT print ( " Double ▁ factorial ▁ is " , doublefactorial ( 5 ) ) NEW_LINE
def isPalindrome ( string ) : NEW_LINE INDENT l = 0 NEW_LINE h = 0 NEW_LINE h = len ( string ) - 1 NEW_LINE while h > l : NEW_LINE INDENT if string [ l ] != string [ h ] : NEW_LINE INDENT return False NEW_LINE DEDENT h += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minRemovesRemals ( string ) : NEW_LINE INDENT if string [ 0 ] == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if isPalindrome ( string ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( minRemoves ( "010001" , "0101" ) ) NEW_LINE print ( minRemovesRemals ( "010001" , "0101" ) ) NEW_LINE DEDENT
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 ] * ( n ) NEW_LINE sumofdigit [ 0 ] = int ( num [ 0 ] ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * num + 10 * sum + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = "123434" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 ; ans += n * ( a // n ) ; NEW_LINE ans += ( a // n ) * ( b % n ) ; NEW_LINE ans += ( a % n ) ; NEW_LINE ans += ( a % n ) ; NEW_LINE ans += ( a % n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 ; b = 13 ; n = 13 ; NEW_LINE print ( findCountOfPairs ( a , b , n ) ) ; NEW_LINE DEDENT
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 1000000 NEW_LINE for d in itertools . count ( 1 ) : NEW_LINE INDENT for i in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 * 3 NEW_LINE if n % 7 == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def coef ( n ) : NEW_LINE INDENT c = [ 0 ] * ( n ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ 1 + i ] = 1 ; NEW_LINE DEDENT c [ 0 ] = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ 1 + i ] = 1 ; NEW_LINE DEDENT c . sort ( ) ; NEW_LINE c [ 0 ] += 1 ; NEW_LINE c [ n ] -= 1 ; NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT coef ( n ) ; NEW_LINE c [ 0 ] -= 1 ; NEW_LINE c [ n ] -= 1 ; NEW_LINE i = n ; NEW_LINE while ( i <= 0 and c [ i ] % n == 0 ) : NEW_LINE INDENT c [ i ] -= 1 ; NEW_LINE i -= 1 ; NEW_LINE DEDENT return i ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 37 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Prime " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not Prime " ) ; NEW_LINE DEDENT DEDENT
def count_greater ( arr , n ) : NEW_LINE INDENT min = float ( ' inf ' ) NEW_LINE counter = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT if ( arr [ i ] <= min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT arr = [ 3 , 2 , 1 , 2 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_greater ( arr , n ) ) NEW_LINE
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < len ( l ) and j < len ( l ) : NEW_LINE INDENT if l [ i ] < x : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( j ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = input ( ) . split ( ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT if i [ 0 ] > 0 : NEW_LINE INDENT a [ i [ 1 ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' No ' ) NEW_LINE
while True : NEW_LINE INDENT T , L , R = map ( int , input ( ) . split ( ) ) NEW_LINE if T == 0 and L == 0 : break NEW_LINE a = [ int ( input ( ) ) for i in range ( L - 1 ) ] NEW_LINE for i in range ( T - 1 ) : NEW_LINE INDENT if a [ i ] <= L : a [ i + 1 ] -= 1 NEW_LINE else : a [ i + 1 ] -= 1 NEW_LINE DEDENT print ( a [ 0 ] ) NEW_LINE DEDENT
def minimumSwaps ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT while arr [ i ] != i + 1 : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] NEW_LINE arr [ i ] = arr [ i ] NEW_LINE arr [ i ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumSwaps ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 500000 NEW_LINE MAX = 500000 NEW_LINE MAX = 500000 NEW_LINE for i in range ( MAX , - 1 , - 1 ) : NEW_LINE INDENT if TARGET == i : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( MAX ) % MOD NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR ^= arr [ i ] NEW_LINE DEDENT set_bit = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & setbit ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is " , x , " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 6 , 1 , 3 , 3 , 1 , 1 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE findUniquePair ( a , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT s += s [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if s [ 0 ] != s [ - 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " YES " ) NEW_LINE
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT print ( line . strip ( ) . split ( ' @ ' ) ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if x >= n / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isMajority ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
N , W = map ( int , input ( ) . split ( ) ) NEW_LINE ws = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE ws . sort ( ) NEW_LINE ws = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for b , w in ws : NEW_LINE INDENT for i in range ( ws [ i + 1 ] , ws [ i ] + 1 ) : NEW_LINE INDENT ws [ i + 1 ] [ w ] = ws [ i ] [ 0 ] NEW_LINE DEDENT DEDENT ws [ 0 ] [ W ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( W + 1 ) : NEW_LINE INDENT ws [ i ] [ j ] = ws [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , ws [ - 1 ] + 1 ) : NEW_LINE INDENT for j in range ( W + 1 ) : NEW_LINE INDENT ws [ i ] [ j ] = ws [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( ws [ - 1 ] [ W ] ) NEW_LINE
import math NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == - 1 : break NEW_LINE a = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a += ( 1 / ( 1 / ( 1 / i ) ** 2 ) ** 2 + 1 / ( 2 * math . pi / 2 ) ** i NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE curr = 1 ; NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT while ( count < k and i < n ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) ; NEW_LINE curr += 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE printKMissing ( arr , n , k ) ; NEW_LINE DEDENT
def printNumbers ( a , n ) : NEW_LINE INDENT mppp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE j = int ( num ) NEW_LINE while j <= num : NEW_LINE INDENT if j % j == 0 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if mpp [ j ] : NEW_LINE INDENT mp [ j ] += 1 NEW_LINE DEDENT mp [ j ] = 1 NEW_LINE DEDENT mp [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT if ( ( len ( mppp ) != j ) : NEW_LINE INDENT mppp [ j ] = max ( mppp [ j ] , mppp [ j ] ) NEW_LINE DEDENT DEDENT DEDENT maxi = 0 NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 12 , 15 , 27 , 27 , 40 , 40 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n ) NEW_LINE DEDENT
s = input ( ) NEW_LINE if len ( s ) == len ( s ) : NEW_LINE INDENT print ( " : " ) NEW_LINE DEDENT elif len ( s ) == 1 : NEW_LINE INDENT print ( " : " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ - i - 1 ] : NEW_LINE INDENT print ( " : " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE d = { } NEW_LINE for i in a : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT print ( d [ n ] ) NEW_LINE
def checkIfStartsWithTheWithTheCharacters ( str ) : NEW_LINE INDENT if ( str [ 0 ] >= ' A ' and str [ 0 ] <= ' Z ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def checkIfStartWithTheCharacters ( str ) : NEW_LINE INDENT if ( checkIfStartWithCharacters ( str ) == 1 ) : NEW_LINE INDENT print ( " Not ▁ Accept " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Accept " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE check ( str ) NEW_LINE DEDENT
def getAvg ( prev_av , x , n ) : NEW_LINE INDENT return ( prev_av * n + x ) / ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE DEDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE DEDENT return avg NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ of ▁ numbers ▁ is " , int ( n ) , " % ▁ numbers ▁ is " ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE primes = eulerlib . list_primality ( LIMIT ) NEW_LINE max_primality = eulerlib . list_primality ( LIMIT ) NEW_LINE max_primality = eulerlib . list_primality ( LIMIT ) NEW_LINE max_primality = eulerlib . list_primality ( LIMIT ) NEW_LINE max_primality = eulerlib . list_primality ( LIMIT ) NEW_LINE max_primality = eulerlib . list_primality ( LIMIT ) NEW_LINE max_primality = eulerlib . list_primality ( LIMIT ) NEW_LINE ans = sum_primality ( LIMIT ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE lst = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 ) : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lst [ i ] ) : NEW_LINE INDENT max = lst [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 9 , 21 , 21 , 21 , 21 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ lis " , lis ( arr , n ) ) NEW_LINE DEDENT
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE import sys , random , itertools , math NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return list ( sys . stdin . readline ( ) . split ( ) ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE n , m = LI ( ) NEW_LINE if n * m - m *= 10 NEW_LINE if n * n - m * n > m : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else
def fix ( A ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s . add ( A [ i ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if i in s : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 2 , - 1 , - 1 , - 1 ] NEW_LINE print ( fix ( A ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if a + b + c == d : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif a + b + c == d : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif a + b + c == d : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif a + b + c == d : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif a + b + c == d : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif a + b + c == d : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT print ( ans ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = None NEW_LINE new_node . next = None NEW_LINE new_node . next = None NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . next = new_node NEW_LINE DEDENT new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE DEDENT def push ( head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE new_node . next = None NEW_LINE while ( ptr != None ) : NEW_LINE INDENT next = ptr . next NEW_LINE if ( ptr . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next . next ) : NEW_LINE INDENT ptr . next . next . next . next . next = ptr . next NEW_LINE DEDENT DEDENT return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head . push ( head , 8 ) NEW_LINE head . push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head . push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head . push ( head , 8 ) NEW_LINE printList ( " Original ▁ List ▁ : ▁ " , end ) NEW_LINE printList ( head ) NEW
dp = [ [ 0 for _ in range ( 11 ) ] for _ in range ( 11 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT for j in range ( i * 2 , 11 ) : NEW_LINE INDENT if j * 2 + i * 2 >= dp [ j * 2 + i ] : NEW_LINE INDENT dp [ j * 2 + i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ 1 ] ) NEW_LINE
mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT return fact ( n ) // ( fact ( n ) * fact ( n // 2 ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = powmod ( a , n // 2 ) NEW_LINE temp = powmod ( a , n // 2 ) % mod NEW_LINE temp = ( temp * temp ) % mod NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return ( temp + n ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return temp NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT
MAX = 1000001 NEW_LINE prime = [ 0 ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime [ 0 ] = 1 NEW_LINE isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] = isPrime [ 1 ] + 1 NEW_LINE DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] NEW_LINE for i in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( 2 * i , i , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT return N - ans + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE ans = 0 NEW_LINE while ( low <= K ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - prime [ mid ] >= K ) : NEW_LINE INDENT ans = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid + 1 NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT
def countOperations ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( ( i * i ) < n and ( n % i > 0 ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( ( i * i ) > n ) : NEW_LINE INDENT i = n ; NEW_LINE DEDENT return ( 1 + ( n - i ) // 2 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countOperations ( n ) ) ; NEW_LINE
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE import sys NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr , n = LI ( ) NEW_LINE s = list ( S ( ) ) NEW_LINE l , r = LI ( ) NEW_LINE r = [ ] NEW_LINE for c in s : NEW_LINE INDENT l , r . append ( c ) NEW_LINE DEDENT for c in l : NEW_LINE INDENT l , r . append ( c ) NEW_LINE DEDENT for c in s : NEW_LINE INDENT l , r = LI ( ) NEW_LINE if c == ' A ' : NEW_LINE INDENT r [ l ] . append ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT r [ l ] . append ( c ) NEW_LINE DEDENT DEDENT return ' \n ' . join ( map ( str , r ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( l * 2 ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000 NEW_LINE MOD = 1000000007 NEW_LINE numSubsets = eulerlib . list_primality ( LIMIT * LIMIT // 2 ) NEW_LINE numSubsets [ 0 ] = 1 NEW_LINE for i in range ( LIMIT // 2 + 1 , - 1 , - 1 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT numSubsets [ i ] = numSubsets [ i - 1 ] + numSubsets [ i - 1 ] NEW_LINE DEDENT return str ( sum ( numSubsets [ 0 ] + numSubsets [ 1 ] ) % MODULULUS ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while row_num > 0 : NEW_LINE INDENT count += row_num & 1 NEW_LINE row >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row in row_num : NEW_LINE INDENT print ( countOddNumber ( row ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE n = len ( V ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= den [ i ] ) : NEW_LINE INDENT while ( V >= den [ i ] ) : NEW_LINE INDENT ans . append ( v ) NEW_LINE ans . append ( den [ i ] ) NEW_LINE DEDENT DEDENT ans . append ( ans [ i ] ) NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 93 NEW_LINE print ( " There ▁ of ▁ minimum ▁ to ▁ " , n , " : ▁ " , n , " : ▁ " , n , " : ▁ " , n , " : " , n , " : " , n , " : " , n , " : " , n , " : " , n , " : " , n , " : " , n , " : " , n , " : " , n , " : " , n , " : " , " ▁ " , n , " : " , n , " : " } NEW_LINE findMin ( n ) NEW_LINE
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = eulerlib . list_triples ( itertools . combinations_with_replacement ( itertools , 6 ) ) NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT for j in range ( 2 , 7 ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT return str ( i * j ) NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == sum - arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findEle ( arr , n ) ) NEW_LINE
def findExtraCharctccterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercterctercter
import math NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT a = i * ( i + 1 ) / 3 NEW_LINE b = i * ( i + 2 ) / 3 NEW_LINE c = a + b NEW_LINE if a > ans : NEW_LINE INDENT ans = max ( ans , c ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE to = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , t = input ( ) . split ( ) NEW_LINE to . append ( s ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT s , t = input ( ) . split ( ) NEW_LINE to . append ( s ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( to [ i ] ) ) : NEW_LINE INDENT if to [ j ] == to [ i ] : NEW_LINE INDENT to [ j ] = to [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT s , t = input ( ) . split ( ) NEW_LINE s , t = t [ : len ( to [ i ] ) ] , s + t [ i : len ( to [ i : len ( to [ i : len ( to [ i ] ) ) ] ) NEW_LINE if len ( s ) == len ( to [ len ( to [ i ] ) : ] ) NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT if ( n + 1 ) // 2 >= ( n + 1 ) // 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - float ( ' inf ' ) NEW_LINE max2 = - float ( ' inf ' ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( maxSumPair ( arr1 , arr2 , n1 , arr2 , n2 ) ) NEW_LINE
def operations ( op , n , k ) : NEW_LINE INDENT iVal = 0 NEW_LINE minVal = 10 ** 9 NEW_LINE minVal = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE minVal = min ( minVal , nVal ) NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT fre = ( k - ( minVal * abs ( minVal ) ) ) // abs ( minVal * abs ( minVal ) ) NEW_LINE k = ( k - ( minVal * abs ( minVal ) ) ) NEW_LINE count = ( fre * n ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT op = [ - 60 , 65 , - 1 , 14 , - 25 , - 25 ] NEW_LINE n = len ( op ) NEW_LINE k = 100000 NEW_LINE print ( operations ( op , n , k ) ) NEW_LINE DEDENT
from math import * NEW_LINE pref = [ 0 ] * 100005 NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( x ** ( 1 / 100 ) ) NEW_LINE if ( cr [ x - 1 ] * cr [ x - 1 ] == x ) : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100005 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i - 1 ) NEW_LINE DEDENT DEDENT Q = 4 NEW_LINE arr = [ [ [ 1 , 10 , 25 ] , [ 2 , 25 ] , [ 4 , 50 ] ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT
N , R , L = map ( int , input ( ) . split ( ) ) NEW_LINE R , L , R = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ 0 ] * ( L + 1 ) NEW_LINE for i in range ( R ) : NEW_LINE INDENT d , t [ i ] = t [ i ] , t [ i ] + L - 1 NEW_LINE t [ i ] += t NEW_LINE DEDENT print ( max ( t ) ) NEW_LINE
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( n , " th ▁ cube ▁ number ▁ : ▁ " , centered_cube ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s1 = s [ : : - 1 ] NEW_LINE a = s [ : : - 1 ] NEW_LINE b = s [ : : n ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 and s [ i ] == '0' : NEW_LINE INDENT b += s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a = s [ i ] NEW_LINE b += a NEW_LINE DEDENT DEDENT print ( ' ' . join ( a ) ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE i = N NEW_LINE while ( i > 0 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE i -= 1 NEW_LINE DEDENT return nth NEW_LINE DEDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT elif ( x == 1 ) : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT DEDENT def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT power = 1 NEW_LINE while ( power < y ) : NEW_LINE INDENT power = power * x NEW_LINE power = power * x NEW_LINE DEDENT return ( power ) NEW_LINE DEDENT x = 1 NEW_LINE y = 1 NEW_LINE while ( pow ( x , y ) ) : NEW_LINE INDENT pow = pow ( x , 30 ) NEW_LINE DEDENT print ( pow ( x , 30 ) ) NEW_LINE print ( pow ( 2 , 30 ) ) NEW_LINE
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT power = 1 NEW_LINE while ( power < y ) : NEW_LINE INDENT power = power * x NEW_LINE DEDENT power = 1 NEW_LINE while ( power < y ) : NEW_LINE INDENT power = power * x NEW_LINE power = power * x NEW_LINE DEDENT return power NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 1 , 30 NEW_LINE print ( isPower ( x , y ) ) NEW_LINE print ( isPower ( x , 30 ) ) NEW_LINE DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( minimumValue ( arr , n , k ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE n = int ( input ( ) ) NEW_LINE d = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , d , v = input ( ) . split ( ) NEW_LINE if s == " l " : NEW_LINE INDENT d . append ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT d . append ( s ) NEW_LINE DEDENT DEDENT l = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] == " l " : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if d [ i ] == " l " : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l . append ( s ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] == " l " : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) // 2 ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( 2 ** ( E - 1 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 ; NEW_LINE print ( countWays ( N ) ) ; NEW_LINE DEDENT
from math import gcd NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / gcd ( arr [ i ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = findLCM ( arr , n ) NEW_LINE count = ( r / lcm ) - ( ( l - 1 ) / lcm ) NEW_LINE return count NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = findLCM ( arr , n ) NEW_LINE count = ( r / lcm ) - ( ( l - 1 ) // lcm ) NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE l = 10 NEW_LINE r = 10 NEW_LINE print ( countNumbers ( arr , n , l , r ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += a [ j ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE u , v = a [ 0 ] , a [ 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] * 2 + u != a [ i + 1 ] * 2 : NEW_LINE INDENT u , v = i , a [ i + 1 ] NEW_LINE DEDENT DEDENT u , v = a [ : : - 1 ] , a [ : - 1 ] NEW_LINE u , v = sorted ( u , reverse = True ) NEW_LINE u , u , v = u , sorted ( u , v ) NEW_LINE u , u , v = u , u NEW_LINE if u != v or u != u : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in mp : NEW_LINE INDENT x = i NEW_LINE frequency = mp [ i ] NEW_LINE frequency = i NEW_LINE if frequency <= frequency : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency - x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinDeletion ( a , n ) ) NEW_LINE
def num_of_sequence ( inp ) : NEW_LINE INDENT return inp NEW_LINE DEDENT def nums ( inp ) : NEW_LINE INDENT return inp [ : - 1 ] + inp [ len ( inp ) - 1 : ] NEW_LINE DEDENT inp = lambda : inp [ : : - 1 ] NEW_LINE inp_sequence ( inp ) NEW_LINE print ( " Case ▁ in ▁ _ " , num_sequence ( inp ) ) NEW_LINE print ( " Case ▁ in ▁ _ " , num_sequence ( inp ) ) NEW_LINE
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for x in range ( n , - 1 , - 1 ) : NEW_LINE INDENT no = x ; NEW_LINE prev = x % 10 ; NEW_LINE while ( no != 0 ) : NEW_LINE INDENT no = no % 10 ; NEW_LINE prev = no % 10 ; NEW_LINE no = no % 10 ; NEW_LINE DEDENT prev_dig = no % 10 ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT n = 200 ; NEW_LINE print ( nondecdigits ( n ) ) ; NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE y1 , y2 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE y1 , y2 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE y1 , y2 , y2 = y1 , y2 , y2 NEW_LINE if x1 == y2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif y1 == y2 : NEW_LINE INDENT print ( y1 , y2 , y2 ) NEW_LINE DEDENT elif x1 == y2 : NEW_LINE INDENT print ( y1 , y2 ) NEW_LINE DEDENT elif x1 == y2 : NEW_LINE INDENT print ( y1 , y1 , y2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x1 , y1 , y2 ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE DEDENT if x < 0 : NEW_LINE INDENT print ( ' Sliv ' ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE y -= 2 NEW_LINE DEDENT ans = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT ans = ' Wik ' NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' Wik ' NEW_LINE DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] == ' . ' : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( ' B ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ' , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countDistinctSubarray ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE vis [ 0 ] = 1 NEW_LINE vis [ 0 ] = 1 NEW_LINE vis [ 1 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 3 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 4 ] = 1 NEW_LINE vis [ 4 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = 1 NEW_LINE vis [ 2 ] = vis [ 2 ] NEW_LINE vis [ 2 ] = vis [ 2 ] NEW_LINE vis [ 2 ] = vis [ 2 ] NEW_LINE vis [ 2 ] = vis [ 2 ] NEW_LINE if ( vis [ arr [ left ] ] == 0 ) : NEW_LINE INDENT vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] ] -= 1 NEW_LINE DEDENT vis [ arr [ left ] ] = vis [ arr [ left ] ] NEW_LINE if ( vis [ arr [ left ] ] == 0 ) : NEW_LINE INDENT vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE if ( vis [ arr [ left ] ] == 0 ) : NEW_LINE INDENT vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE DEDENT DEDENT return vis NEW_LINE DEDENT arr = [ 2 , 1 , 3 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinctSubarray ( arr , n ) ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c += a NEW_LINE DEDENT print ( c ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT tot_bit = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bit . count ( i ) NEW_LINE if ( isPrime ( tot_bit ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 6 NEW_LINE r = 10 NEW_LINE print ( primeBitsInRange ( l , r ) ) NEW_LINE
def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = countSet ( arr [ i ] , countSet ( arr [ j ] , arr [ j ] ) ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE
def reverseFirstKKK ( k ) : NEW_LINE INDENT if len ( k ) == 0 or k > len ( stack ) : NEW_LINE INDENT return NEW_LINE DEDENT if k <= len ( stack ) : NEW_LINE INDENT return NEW_LINE DEDENT if k <= len ( stack ) : NEW_LINE INDENT return NEW_LINE DEDENT if len ( stack ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT stack = [ ] NEW_LINE stack . append ( stack [ - 1 ] ) NEW_LINE stack . append ( stack [ - 1 ] ) NEW_LINE stack . append ( stack [ - 1 ] ) NEW_LINE DEDENT return [ ' ▁ ' . join ( stack ) for stack in stack ] NEW_LINE DEDENT def printFirstKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) % 2 == 0 : NEW_LINE INDENT print ( ' eavoogu ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' eavoogu ' ) NEW_LINE DEDENT DEDENT
def xorCalccalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( k + 1 ) & k ) : NEW_LINE INDENT return k // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT k = 31 NEW_LINE print ( xorCalc ( k ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid * mid == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid * mid == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid * mid == num : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE out = sObj . isPerfectSquare ( num ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Yes " if a + b == c and a + c == a + b or c == a + b or c == b + c or ( a + b + c ) == a + b == c and c == a + c : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ave = sum ( a ) / n NEW_LINE ave = [ ] NEW_LINE for i in a : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ave . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( len ( ave ) ) NEW_LINE print ( * ave ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE N , M = map ( int , readline ( ) . split ( ) ) NEW_LINE P = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , readline ( ) . split ( ) ) NEW_LINE P . append ( a ) NEW_LINE DEDENT P . sort ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT if P [ i ] [ 0 ] >= P [ i ] [ 1 ] : NEW_LINE INDENT P [ i ] [ 0 ] = P [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ 0 ] = P [ i ] [ 1 ] NEW_LINE DEDENT DEDENT write ( " % d ▁ % d \n " % P ▁ % P ▁ % P ) NEW_LINE write ( " % P ▁ % P ▁ % P ▁ % P ▁ % P ) NEW_LINE
def findElement ( arr , ranges , rot , indices , index ) : NEW_LINE INDENT for i in range ( rot - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left and right >= index ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = right NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] [ 2 ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE ranges = 2 NEW_LINE print ( findElement ( arr , ranges , indices , index ) ) NEW_LINE
MAXN = 1000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE spf [ 2 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAXN : NEW_LINE INDENT if spf [ i ] == i : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if spf [ j ] == j : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i != 1 : NEW_LINE INDENT temp = spf [ spf [ i ] ] NEW_LINE if i % temp == 0 : NEW_LINE INDENT spf [ spf [ spf [ spf [ spf [ spf [ sp ] ] ] ] = i NEW_LINE DEDENT while i != 1 : NEW_LINE INDENT temp = x // temp NEW_LINE DEDENT while i != 1 : NEW_LINE INDENT temp = temp // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkForNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE DEDENT def isValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = spf [ i ] NEW_LINE if ( x % temp == 0 and prime [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if isValidNum ( arr , n ) : NEW_LINE INDENT print ( " Yes " )
def isExists ( a , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE sum += a [ i ] NEW_LINE DEDENT if ( sum % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isExists ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( " Area ▁ of ▁ Kite ▁ = ▁ " , areaOfKite ( d1 , d2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( ' . ' ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT l . append ( ' . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( ' . ' ) NEW_LINE DEDENT DEDENT DEDENT for i in l : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT print ( ' . ' * ( l [ i ] - 2 ) + ' . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' . ' * ( l [ i ] - 3 ) + ' . ' * ( l [ i ] - 3 ) + ' . ' ) NEW_LINE DEDENT DEDENT print ( ' + ' . ' * ( l [ : : - 1 ] - 2 ) + ' . ' * ( l [ : - 1 ] + ' . ' * ( l [ : - 2 ] - 3 ) ) + ' . ' * ( l [ : : - 2 ] - 3 ) + ' . ' * ( l [ : - 3 ] - 4 ) + ' . ' * ( l [ : - 3 ] - 4 ) + ' . ' * ( l [ : : - 3 ] - 4 ) NEW_LINE DEDENT print ( ' + ' . join ( l ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % ( n - 1 ) == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def productEqual ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 NEW_LINE prodEven = 1 NEW_LINE prodEven = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE prodOdd *= digitEven NEW_LINE n //= digitEven NEW_LINE DEDENT if ( prodEven == prodOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 43242424 NEW_LINE if ( productEqual ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE d = list ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE str_a = input ( ) NEW_LINE for j in range ( len ( d ) ) : NEW_LINE INDENT if d [ j ] == ' A ' : NEW_LINE INDENT d [ j ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ j ] = d [ j ] NEW_LINE DEDENT DEDENT for j in range ( len ( d ) ) : NEW_LINE INDENT if d [ j ] == ' B ' : NEW_LINE INDENT d [ j ] = d [ j ] NEW_LINE DEDENT elif d [ j ] == ' C ' : NEW_LINE INDENT d [ j ] = d [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( d ) ) : NEW_LINE INDENT print ( d [ i ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def checkELEeven ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE checkEodd ( arr , n , 1 , 3 ) NEW_LINE
W , H , R = map ( int , input ( ) . split ( ) ) NEW_LINE x_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y_list . append ( x_list ) NEW_LINE if y_list [ 0 ] + x_list [ 1 ] <= y_list [ 2 ] and x_list [ 2 ] + y_list [ 3 ] <= x_list [ 3 ] and x_list [ 2 ] <= y_list [ 3 ] : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minNumber ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime ( num ) ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return num NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( isPrime ( sum ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE
def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime [ 0 ] = True NEW_LINE prime [ 1 ] = True NEW_LINE prime [ 1 ] = True NEW_LINE for p in range ( 2 , int ( max_val + 1 ) ** 0.5 + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( compositeProduct ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b = map ( int , line . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT y = a NEW_LINE x = b NEW_LINE y = a NEW_LINE while y > 0 : NEW_LINE INDENT if y > 0 : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y < 0 : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT y -= 1 NEW_LINE x = y NEW_LINE y -= 1 NEW_LINE DEDENT DEDENT print ( x , y ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] in ' o ' : NEW_LINE INDENT print ( ' WEDENT elif s [ 0 ] in ' o ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' WEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left ; NEW_LINE d = arr [ 1 ] - arr [ 0 ] ; NEW_LINE ans = arr [ 1 ] * ( k + 1 ) ; NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) ; NEW_LINE ans = ans + ( d * ( k + 1 ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 ] ; NEW_LINE queries = [ [ 2 , 4 , 6 , 8 , 12 , 14 ] , [ 5 , 6 , 6 , 12 , 14 ] , [ 5 , 6 , 12 , 16 ] ] ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in queries : NEW_LINE INDENT print ( findSum ( arr , n , q [ i ] , q [ i ] [ 0 ] ) ) ; NEW_LINE DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 ) : NEW_LINE INDENT z = ( n - ( i + j ) ) // c NEW_LINE if ( z == 0 ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE a , b , c = 3 , 3 , 3 , 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE DEDENT
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE h = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT h . append ( h [ i ] ) NEW_LINE DEDENT h . sort ( ) NEW_LINE print ( h [ - 1 ] ) NEW_LINE
def fact ( n ) : NEW_LINE INDENT ans = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i ; NEW_LINE DEDENT return ( ans ) ; NEW_LINE DEDENT def numberOfPossiblePalindrome ( string , n ) : NEW_LINE INDENT mp = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ ord ( string [ i ] ) ] += 1 ; NEW_LINE DEDENT k = 0 ; NEW_LINE den = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ ord ( string [ i ] ) ] % 2 == 0 ) : NEW_LINE INDENT fin = ( int ( num [ i ] / 2 ) ) // 2 ; NEW_LINE k += 1 ; NEW_LINE DEDENT num = num + fin * fact ; NEW_LINE den = den * fact ; NEW_LINE DEDENT if ( num != 0 ) : NEW_LINE INDENT ans = num + den * num ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abababab " ; NEW_LINE n = len ( string ) ; NEW_LINE print ( numberOfPossible ( string , n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def func ( a ) : NEW_LINE INDENT if a [ 0 ] < a [ 1 ] : NEW_LINE INDENT return a [ 0 ] + func ( a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return a [ 1 ] + func ( a [ 1 ] ) NEW_LINE DEDENT DEDENT def func ( a ) : NEW_LINE INDENT if a [ 0 ] < a [ 1 ] : NEW_LINE INDENT return a [ 0 ] + func ( a [ 1 ] , a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return func ( a [ 1 ] , a [ 2 ] ) NEW_LINE DEDENT DEDENT def func ( a ) : NEW_LINE INDENT if a [ 0 ] == a [ 1 ] : NEW_LINE INDENT return func ( a [ 1 ] , a [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return func ( a [ 0 ] , a [ 1 ] ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE func ( a ) NEW_LINE print ( func ( a ) ) NEW_LINE
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMBits ( n , m ) NEW_LINE print ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a , b = 0 , 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' A ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif c == ' B ' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif c == ' C ' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT if a == b and b == c : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def first_substring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cmp = { } NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' or s [ i ] == ' # ' ) : NEW_LINE INDENT s1 [ cmp ] = 1 NEW_LINE mp [ cmp ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' # ' or s [ i ] == ' # ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT s1 [ cmp [ i ] ] = 1 NEW_LINE cmp [ cmp [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' # ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' # ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT s1 [ j ] , s1 [ j ] = s [ j ] , s1 [ j - i + 1 ] NEW_LINE DEDENT DEDENT return ' - 1' NEW_LINE DEDENT s = " codef ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ " NEW_LINE s = first_substring ( s ) NEW_LINE print ( s ) NEW_LINE
def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 4452222578 NEW_LINE print ( countConsecutive ( n ) ) NEW_LINE
def findAngle ( n ) : NEW_LINE INDENT innerAngle = ( n - 2 ) * 180 / n NEW_LINE inscribedAngle = 360 / n NEW_LINE print ( " Exangle ▁ angle : " , inscribedAngle ) NEW_LINE print ( " Exangle ▁ angle ▁ : " , inscribedAngle ) NEW_LINE DEDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE
import math NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT smallest = math . ceil ( math . sqrt ( n - 1 ) ) ** 2 NEW_LINE print ( smallest , end = " ▁ " ) NEW_LINE largest = int ( math . ceil ( math . pow ( 10 , n ) ) - 1 , 2 ) NEW_LINE print ( largest , end = " ▁ " ) NEW_LINE DEDENT n = 4 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += s [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ) ' : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if c1 > c2 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT a . append ( i + 1 ) NEW_LINE b . append ( i + 2 ) NEW_LINE DEDENT DEDENT b . append ( a [ 0 ] ) NEW_LINE print ( len ( b ) ) NEW_LINE print ( ' ' . join ( a ) ) NEW_LINE print ( b ) NEW_LINE
def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = power ( a , n // 2 ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( 2 , n // 2 ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT return p NEW_LINE DEDENT rem = power ( 2 , n - 1 ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT return NEW_LINE DEDENT rem = power ( 2 , n - 1 ) NEW_LINE prefix [ n - 1 ] = p * p NEW_LINE prefix [ n - 1 ] = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if sum + rem > k : NEW_LINE INDENT return NEW_LINE DEDENT suffix [ 0 ] = prefix [ n - 1 ] NEW_LINE DEDENT def countSubsequences ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE prefix [ n - 1 ] NEW_LINE prefix [ n - 1 ] = arr [ n - 1 ] + a [ i ] NEW_LINE prefix [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE sum += a [ i - 1 ] NEW_LINE DEDENT return sum - prefix [ n ] NEW_LINE DEDENT def countSubsequences ( arr , n , k ) : NEW_LINE INDENT sum = power ( 2 , n ) NEW_LINE prefix [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i - 1 ] NEW_LINE sum += a [ i - 1 ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( countSubsequences ( arr , n
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isIdental ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT elif root == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root . left == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root . right == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root . left == None and root . right == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root . right == None and root . left == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root . right == None and root . right == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if root . data == root . left and isIdental ( root . left , root . right ) == 1 and isIdental ( root . right , root . left ) == 1 and isIdental ( root . right , root . right ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = Node ( 5 ) NEW_LINE root1 . left = Node ( 3 ) NEW_LINE root1 . left = Node ( 8 ) NEW_LINE root1 . right = Node ( 8 ) NEW_LINE root2 . left . right = Node ( 8 ) NEW_LINE root2 . left . right . right = Node ( 8 ) NEW_LINE root2 . left . right . right = Node ( 8 ) NEW_LINE root2 . right . left . right = Node ( 8 ) NEW_LINE root2 . right . left . right . right = Node ( 8 ) NEW_LINE root2 . right . right . left . right = Node ( 8 ) NEW_LINE root2 . right . left = Node ( 8 ) NEW_LINE root2 . right . right . right = Node ( 8
import sys NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def map ( int , input ( ) . split ( ) ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def list2d ( a , b , c , d ) : NEW_LINE INDENT if a == " I " : NEW_LINE INDENT return [ 0 , 0 , 0 ] NEW_LINE DEDENT elif b == " I " : NEW_LINE INDENT return [ 0 , 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ 0 , 0 , 0 ] NEW_LINE DEDENT DEDENT def f ( s , d ) : NEW_LINE INDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == " J " : NEW_LINE INDENT if s [ i - 1 ] == " O " : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if s [ j - 1 ] == " O " : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = max ( ans , f ( s [ 0 ] , f ( s [ 1 ] , f ( s [ 2 ] , f ( s [ 0 ] , f ( s [ 1 ] , f ) ) ) ) NEW_LINE ans = max ( ans , f ( s [ 2 ] , f ( s [ 2 ] , f ( s [ 2 ] , f ( s [ 0 ] , f ( s [ 1 ] , f ( s [ 0 ] , f ) , f ( s [ 1 ] , f ( s [ 1 ] , f ( s [ 1 ] , f ) , f ( s [ 1 ] , f ) , f ( s [ 0 ] , f ( s [ 1 ] , f ) , f ( s [ 1 ] , f ) , f ( s [ 1 ] , f ( s [ 0 ] , f ) , f ( s [ 1 ] , f ) , f ( s [ 1 ] , f ( s [ 0 ] , f ) , f (
s = input ( ) NEW_LINE c = s . count ( ' W ' ) NEW_LINE d = s . count ( ' W ' ) NEW_LINE e = s . count ( ' E ' ) NEW_LINE s = s . count ( ' W ' ) NEW_LINE d = s . count ( ' W ' ) NEW_LINE e = s . count ( ' E ' ) NEW_LINE d = s . count ( ' W ' ) NEW_LINE e = s . count ( ' W ' ) NEW_LINE d = s . count ( ' W ' ) NEW_LINE e = s . count ( ' E ' ) NEW_LINE d = s . count ( ' W ' ) NEW_LINE e = s . count ( ' E ' ) NEW_LINE s = s . count ( ' W ' ) NEW_LINE e = s . count ( ' W ' ) NEW_LINE print ( e ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printArr ( a ) : NEW_LINE INDENT newNode = Node ( ) NEW_LINE newNode . next = None NEW_LINE newNode . next = None NEW_LINE return newNode NEW_LINE DEDENT def findArr ( head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( a [ curr ] , end = " ▁ " ) NEW_LINE curr = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT def convertArr ( head ) : NEW_LINE INDENT curr = findArr ( head ) NEW_LINE curr = head NEW_LINE i = 0 NEW_LINE while ( curr != None ) : NEW_LINE INDENT arr [ i ] = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT return curr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = createArr ( 1 ) NEW_LINE head . append ( 2 ) NEW_LINE head . append ( 3 ) NEW_LINE head . append ( 3 ) NEW_LINE head . append ( 5 ) NEW_LINE head . append ( 5 ) NEW_LINE head . append ( 5 ) NEW_LINE head . append ( 5 ) NEW_LINE printArr ( head , len ( head ) ) NEW_LINE DEDENT
def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT a [ i ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j + 1 ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT n = 2 NEW_LINE print ( " Non - minus ▁ digits - minus ▁ = " , nonDecums ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . add ( a [ i ] ) NEW_LINE DEDENT b = set ( ) NEW_LINE for i in b : NEW_LINE INDENT if i not in b : NEW_LINE INDENT b . add ( i + a ) NEW_LINE DEDENT DEDENT print ( ' YES ' if b else ' NO ' ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT nums . sort ( ) NEW_LINE return nums [ 0 ] - min ( nums [ 0 ] - min ( nums [ 0 ] , nums [ 0 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT
def firstSetBitBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT n = 12 NEW_LINE print ( firstSetBitBit ( n ) ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE firstInd = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT firstInd = ord ( str [ i ] ) NEW_LINE if ( firstInd == - 1 ) : NEW_LINE INDENT firstInd = i NEW_LINE DEDENT else : NEW_LINE INDENT firstInd = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT firstInd = firstInd NEW_LINE if ( firstInd == - 1 ) : NEW_LINE INDENT firstInd = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - firstInd - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abba " NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a . sort ( key = lambda x : x [ 1 ] ) NEW_LINE count = 0 NEW_LINE ans = 0 NEW_LINE for i in a : NEW_LINE INDENT count += i [ 0 ] NEW_LINE ans = max ( ans , count ) NEW_LINE DEDENT print ( ans ) NEW_LINE
from math import sqrt NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = 5 * sqrt ( 3 ) * a * a * a * a NEW_LINE return area NEW_LINE DEDENT def findArea ( a ) : NEW_LINE INDENT volume = ( 5 / 12 ) * ( 3 + sqrt ( 5 ) ) NEW_LINE volume = ( 5 / 12 ) * a * a NEW_LINE return volume NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area ▁ : ▁ " , findArea ( a ) ) NEW_LINE print ( " Area ▁ : " , findArea ( a ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT P = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE for e in P : NEW_LINE INDENT yield e * e * f NEW_LINE DEDENT DEDENT def compute ( n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT def compute ( n ) : NEW_LINE INDENT return n * fact [ n ] * fact [ n ] * fact [ n ] * fact [ n ] NEW_LINE DEDENT def compute ( n ) : NEW_LINE INDENT return n * fact [ n ] * fact [ n ] * fact [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
N = 6 NEW_LINE Even = N // 2 NEW_LINE odd = N // 2 NEW_LINE print ( Even * Even ) NEW_LINE
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT for j in range ( len ( b ) ) : NEW_LINE INDENT if a [ i ] + b [ j ] == b [ i ] : NEW_LINE INDENT c [ j ] , c [ i ] , c [ j ] = c [ i ] , c [ j ] NEW_LINE DEDENT DEDENT DEDENT if c [ 0 ] + c [ 1 ] == b [ 2 ] + c [ 3 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def _cntcnt ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT number = number // 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _cntcntr ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res | ( 1 << ( 32 - i ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if a [ i ] <= k : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE while a != 0 and b != 0 : NEW_LINE INDENT c += 1 NEW_LINE a -= 2 NEW_LINE b -= 2 NEW_LINE c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def xorQueries ( self , queries , queries ) : NEW_LINE INDENT res = [ 0 ] * queries [ 0 ] NEW_LINE for i in range ( 1 , len ( queries ) ) : NEW_LINE INDENT res [ i ] = queries [ i - 1 ] ^ arr [ i ] NEW_LINE DEDENT for i in range ( len ( queries ) ) : NEW_LINE INDENT q = queries [ i ] ^ arr [ q ] NEW_LINE res [ i ] = arr [ q ] ^ arr [ q ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE queries = [ [ 1 , 3 , 4 ] , [ 0 , 2 , 8 ] , [ 1 , 3 , 3 ] ] NEW_LINE queries = [ [ 0 , 1 , 2 ] , [ 0 , 3 , 3 ] , [ 3 , 3 , 3 ] ] NEW_LINE out = sObj . xor ( queries [ 0 ] , [ 1 ] ) NEW_LINE print ( out ) NEW_LINE DEDENT
def encodedChar ( string , k ) : NEW_LINE INDENT modify = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE freq = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( string ) and ord ( string [ i ] ) >= ord ( ' a ' and ord ( string [ i ] ) <= ' z ' ) and ord ( string [ i ] ) <= '9' ) : NEW_LINE INDENT freq = freq * 10 + ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT compressed += temp NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT freq += freq NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT freq += freq NEW_LINE DEDENT return compressed [ k - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abccc12" NEW_LINE k = 21 NEW_LINE print ( encodedChar ( string , k ) ) NEW_LINE DEDENT
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 4 ; c = 2 ; NEW_LINE printPossible ( a , b , c ) ; NEW_LINE
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 NEW_LINE sign_sum = 1 NEW_LINE sign_sum = 1 NEW_LINE result_sum = sign * abs ( n + 1 ) NEW_LINE return result_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2 NEW_LINE print ( summation ( N ) ) NEW_LINE DEDENT
def sortSquares ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE print ( " After ▁ sort ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT i = a [ i : i + 1 ] NEW_LINE DEDENT if t == n : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE aa = LI ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if aa [ i ] != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE d = 1 NEW_LINE a = 1 NEW_LINE b = 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 and abs ( d ) == root ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + pow ( d - 2 * a ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and root1 == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT num = 55 NEW_LINE if ( isTriangular ( num ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ number ▁ number " ) NEW_LINE DEDENT
def printNumberWithR ( k , d ) : NEW_LINE INDENT if ( d == 0 and k != 1 ) : NEW_LINE INDENT print ( d ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT k = 4 NEW_LINE d = 4 NEW_LINE printNumberWithR ( k , d ) NEW_LINE
N = 3 NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] NEW_LINE rotateMatrix ( mat ) NEW_LINE
p = int ( input ( ) ) NEW_LINE print ( ( ( p + 500 * p ) // 500 ) * 500 ) NEW_LINE
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while n : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 451313 NEW_LINE print ( getProduct ( n ) ) NEW_LINE
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) [ : - 1 ] NEW_LINE def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT a , b , c , d , b , c , d , d , e , f , b , d , e = LI ( ) NEW_LINE return ( 100 * c + d + 5 * ( d + 5 ) ) NEW_LINE DEDENT while True : NEW_LINE INDENT inp = [ 0 ] * ( 5 + 1 ) NEW_LINE if len ( inp ) : NEW_LINE INDENT break NEW_LINE DEDENT a , b , c , d , e , f , b , c , d , d , e , f = LI ( ) NEW_LINE s = min ( a , b , c , d , d , e ) NEW_LINE print ( 100 * s - d + 5 * c + d + 5 * ( 5 - d ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE
k , a = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dp = [ [ 0 ] * ( a + 1 ) for a in map ( int , input ( ) . split ( ) ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT print ( ( dp [ k ] [ 0 ] ) % mod ) NEW_LINE
PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( 2 * pi * r ) + 6 * r NEW_LINE DEDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE
def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev_num = reverseDigits ( n ) NEW_LINE if ( rev_num == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4562 NEW_LINE print ( " Is ▁ palindrome ▁ number ▁ is ▁ " , n , " ▁ is ▁ - > ▁ number " ) NEW_LINE n = 2562 NEW_LINE print ( " Is ▁ is ▁ " , n , " ▁ is ▁ - > ▁ number " ) NEW_LINE n = 2 NEW_LINE print ( " Is ▁ is ▁ " , n , " ▁ - > ▁ number " ) NEW_LINE n = 2 NEW_LINE print ( " Is ▁ is ▁ " , n , " ▁ - > ▁ number ▁ " ) NEW_LINE n = 1200 NEW_LINE print ( " is ▁ " , n , " ▁ - > ▁ number ▁ " ) NEW_LINE n = 1200 NEW_LINE print ( " is ▁ a ▁ is ▁ - > ▁ number ▁ = " ) NEW_LINE n = 4000 NEW_LINE print ( " is ▁ " , n , " ▁ - > ▁ number ▁ " ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " is ▁ a ▁ is " , n , " ▁ is ▁ - ▁ number ▁ is " ) NEW_LINE n = " NEW_LINE print ( " is ▁ a ▁ is " , n , n , " ▁ - ▁ - ▁ ▁ - ▁ ▁ - ▁ ▁ - ▁ ▁ ▁ ▁ " ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , nums , num2 ) : NEW_LINE INDENT carry = 0 NEW_LINE carry = 0 NEW_LINE for i in range ( len ( nums ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i < 0 or carry == 1 : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT x = int ( nums [ i ] ) NEW_LINE carry += 1 NEW_LINE DEDENT return ( x + carry + carry ) % 10 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = "11" NEW_LINE nums2 = "123123" NEW_LINE out = sObj . addStrings ( nums , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i != n ) : NEW_LINE INDENT sum = sum + i + n / i ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT if ( sum == n and n != 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 ; NEW_LINE print ( " The ▁ all ▁ perfect ▁ numbers ▁ of ▁ 1000" ) ; NEW_LINE for n in range ( 2 , 10000 ) : NEW_LINE INDENT if ( isPerfect ( n ) ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ number " ) ; NEW_LINE DEDENT DEDENT DEDENT
from math import sqrt NEW_LINE def isPower ( n ) : NEW_LINE INDENT x = 2 NEW_LINE while ( x <= n ) : NEW_LINE INDENT p = x NEW_LINE while ( p <= n ) : NEW_LINE INDENT p = p * x NEW_LINE if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def isPower ( n ) : NEW_LINE INDENT x = 2 ; NEW_LINE y = 2 ; NEW_LINE p = 2 ; NEW_LINE while ( p <= n and p > 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT y = p * y ; NEW_LINE p += 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
from math import gcd NEW_LINE def findTwoNumbers ( sum , gcd , gcd ) : NEW_LINE INDENT if ( gcd ( gcd , sum ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( " a ▁ = ▁ b " , ▁ b " , " , ▁ b ▁ = ▁ " , sum - min ( gcd , sum - gcd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " a ▁ = ▁ " , sum - min ( gcd , sum - min ) , " , ▁ b ▁ = ▁ " , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c1 , c2 , c3 = ( l [ 0 ] - l [ 1 ] , l [ 2 ] ) , ( l [ 3 ] - l [ 3 ] ) NEW_LINE c1 , c2 , c3 = ( l [ 3 ] - l [ 4 ] ) , ( l [ 4 ] - l [ 5 ] ) , ( l [ 5 ] - l [ 5 ] ) NEW_LINE if c1 == c2 and c2 == c3 and c1 == c2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif c1 == c2 and c3 == c3 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif c1 == c2 and c3 == c3 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif c1 == c3 and c3 == c3 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
N , A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE def func ( n ) : NEW_LINE INDENT if A * n <= N : NEW_LINE INDENT return func ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT return func ( n ) NEW_LINE DEDENT DEDENT def func ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return func ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT return func ( n ) NEW_LINE DEDENT DEDENT N , A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( A * B , C , D ) ) NEW_LINE
def totalPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = count & ( i - 1 ) NEW_LINE DEDENT result = 0 NEW_LINE for i in m : NEW_LINE INDENT value = count & ( i - 1 ) NEW_LINE result += ( ( value * ( i - 1 ) ) // 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 7 , 5 , 3 , 9 , 1 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( totalPairs ( arr , n ) ) NEW_LINE
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n * n - 8 * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ number ▁ : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , " th ▁ hexadecagonal ▁ number : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE
Q , H , S , S , N = map ( int , input ( ) . split ( ) ) NEW_LINE if Q * 2 > S * 2 * Q : NEW_LINE INDENT print ( N * ( Q // 2 ) * ( N - Q // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N * ( Q // 2 ) * ( N - Q // 2 ) ) NEW_LINE DEDENT
def countNumbers ( L , R , K ) : NEW_LINE INDENT if K == 9 : NEW_LINE INDENT K = R - L + 1 NEW_LINE factor = ( K - L + 1 ) // 9 NEW_LINE rem = total NEW_LINE rem = total NEW_LINE DEDENT return factor NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L , R , K = 10 , 22 , 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE DEDENT
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE x = min ( a , b ) NEW_LINE y = min ( a , d ) NEW_LINE z = min ( a , b ) NEW_LINE if x + y + z <= f : NEW_LINE INDENT print ( x * y ) NEW_LINE DEDENT elif x + y <= f and y + z <= f and x + z <= f : NEW_LINE INDENT print ( y * z ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x * f ) NEW_LINE DEDENT
def Solution ( A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 2 NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT ans = max ( ans , A [ j ] + A [ k ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 9 , 4 , 7 , 2 , 10 ] NEW_LINE n = len ( A ) NEW_LINE print ( Solution ( A ) ) NEW_LINE DEDENT
def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 1 NEW_LINE freq = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i * d ) NEW_LINE if ( a0 in freq ) : NEW_LINE INDENT freq [ a0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT DEDENT return ( n - maxFreq ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE d = 1 NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] NEW_LINE print ( minimumChanges ( arr , n , d ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] < b [ i ] [ 1 ] and a [ i ] [ 2 ] < b [ i ] [ 2 ] : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( a . index ( min ( b ) ) + 1 ) NEW_LINE
def countPoints ( n , m , a , b , x , y , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < a [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if b [ j ] >= a [ i ] + y and b [ j ] <= a [ i ] + y : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 NEW_LINE y = 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPoints ( n , m , a , b , x , y , y , x , y ) ) NEW_LINE DEDENT
def multiplyWith3Point ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point ( x ) ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > s : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT if ans < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT cnti = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnti , maxi ) NEW_LINE return maxi NEW_LINE DEDENT s = " ccceceef " NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE
k = int ( input ( ) ) NEW_LINE n = 50 NEW_LINE for i in range ( k ) : NEW_LINE INDENT n += i + ( n - i ) NEW_LINE DEDENT print ( n ) NEW_LINE print ( * [ n ] ) NEW_LINE print ( * [ i for i in range ( n ) ] ) NEW_LINE
def zeroUpto ( num ) : NEW_LINE INDENT first = ( pow ( 10 , num ) - 1 ) // 9 NEW_LINE second = ( pow ( 10 , num ) - 1 ) // 9 NEW_LINE return ( first - second ) * ( first - 1 ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE totalUpto = zeroUpto ( k - 1 ) NEW_LINE totalUpto = zeroUpto ( k - 1 ) NEW_LINE return ( firstUpto - num [ k ] ) * ( pow ( 10 , k - 1 - 1 - 1 ) ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = numUpto ( k - 1 ) NEW_LINE totalUpto = 0 NEW_LINE negativeUpto = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if num [ i ] == '0' : NEW_LINE INDENT minimumUpto += ( ( int ) ( num [ i ] ) - 1 ) * ( pow ( 10 , k - 1 - i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT minimumUpto . remove ( ( int ) ) NEW_LINE DEDENT remainingUpto . remove ( minUpto ) ) NEW_LINE DEDENT remainingUpto . remove ( remainingUpto - 1 ) NEW_LINE ans = zeroUpto ( k - 1 ) + ( remainingUpto - 1 ) NEW_LINE return ans NEW_LINE DEDENT num = "11" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ 1" , num , " is " , countZero ( num - 1 ) ) NEW_LINE num = "1264" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ to ▁ 1" , countZero ( num - 1 ) ) NEW_LINE
import math NEW_LINE def triangle ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a * a NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = ( 2 * a ) / 3 NEW_LINE V = ( 2 * a ) / 3 NEW_LINE return V NEW_LINE DEDENT a = 5 NEW_LINE print ( triangle ( a ) ) NEW_LINE
def Prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkSumPrime ( string ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT summ += abs ( ord ( string [ i - 1 ] ) - ord ( string [ i ] ) ) NEW_LINE DEDENT if ( summ ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT num = 142 NEW_LINE str = "142" NEW_LINE if ( checkSum ( str ) ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not Prime " ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT print ( " % .3f " % sum ( 8 ) ) NEW_LINE
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT p = [ 2 , 5 , 1 , 3 , 4 ] NEW_LINE n = len ( p ) NEW_LINE print ( countElements ( p , n ) ) NEW_LINE
a , b = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE c = int ( a ) NEW_LINE if a > b : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE h = 9 NEW_LINE print ( " Volume ▁ of ▁ triangular : " , findVolume ( l , b , h ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ s [ i ] ] = 1 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT d [ s [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT d [ s [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in d : NEW_LINE INDENT ans += ( i - i ) * ( k - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT i , j = 284 , 292 NEW_LINE k = 22 NEW_LINE while i <= j : NEW_LINE INDENT mid = ( i * ( j + 1 ) // 2 - 1 ) // 2 NEW_LINE if mid == k : NEW_LINE INDENT return i NEW_LINE DEDENT elif mid == k : NEW_LINE INDENT return i NEW_LINE DEDENT elif mid == k : NEW_LINE INDENT return i NEW_LINE DEDENT else : NEW_LINE INDENT j = ( i * 3 - 1 ) // 2 NEW_LINE k = j * 3 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE prod = 1 NEW_LINE res = 1 NEW_LINE res = 0 NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( arr [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p * 2 , N , p ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT prod *= p NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT N = 500 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE
def checkDivis ( a , n ) : NEW_LINE INDENT m = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X / i != i ) : NEW_LINE INDENT b . append ( i / i ) NEW_LINE DEDENT DEDENT DEDENT return b NEW_LINE DEDENT def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b . sort ( ) NEW_LINE b . sort ( ) NEW_LINE b . sort ( ) NEW_LINE if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT b . sort ( ) NEW_LINE b . sort ( ) NEW_LINE DEDENT if ( checkDivisors ( a , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 6 , 6 , 16 , 16 , 16 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " All ▁ Subarray ▁ Subarray ▁ Subarray ▁ Subarray ▁ Subarray ▁ Subarray ▁ Subarray ▁ " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c1 , c2 , c3 , c3 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c8 , c8 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , 4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , c4 , 4 , 0 , 7 , c4 , c4 , c4 , c4 , 7 , c4 , 8 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( arr [ i ] * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getNodeLastNode ( root ) : NEW_LINE INDENT temp = Node ( root ) NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE result = None NEW_LINE while ( len ( temp ) != 0 ) : NEW_LINE INDENT temp . left = temp . right NEW_LINE if ( temp . left and not None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . left and not None ) : NEW_LINE INDENT temp . left = temp . right NEW_LINE DEDENT if ( temp . left and not None ) : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right . left = Node ( 3 ) NEW_LINE root . right . right . right = Node ( 3 ) NEW_LINE root . right . right . right . right = Node ( 5 ) NEW_LINE root . right . right . right . right . right . right = Node ( 5 ) NEW_LINE root . right . right . right . right . right . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right = Node ( 8 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right = Node ( 8 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getNodeLastNode ( root ) : NEW_LINE INDENT temp = Node ( root ) NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE temp . right = None NEW_LINE DEDENT def getNodeLastNode ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT temp = q . pop ( ) NEW_LINE if ( temp . left != None and not None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( temp . left . right . right . right . left . right . right . right . right ) NEW_LINE if ( temp . right . right . right and not None ) : NEW_LINE INDENT result = temp . right NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left . right = Node ( 2 ) NEW_LINE root . right . right . right = Node ( 3 ) NEW_LINE root . right . left . right . right . right . right . right . right . right . right = Node ( 5 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right = Node ( 8 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right = Node ( 8 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right = Node ( 8 ) NEW_LINE root . right . right . right . right . right . right .
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT
from math import gcd NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE d = temp // a NEW_LINE DEDENT lcm = int ( lcm / a ) NEW_LINE x = lcm // a NEW_LINE y = temp // gcd NEW_LINE d = temp // gcd NEW_LINE d = temp // d NEW_LINE d = temp // gcd NEW_LINE d = temp // d NEW_LINE d = temp // d NEW_LINE d = temp // d NEW_LINE d = temp // d NEW_LINE d = temp // d NEW_LINE d = temp // d NEW_LINE d = temp // d NEW_LINE d = temp // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d // d NEW_LINE d = d NEW_LINE print ( d , d ) NEW_LINE DEDENT a , b , c , d , d , d , d , d , d ) NEW_LINE
def maxSum ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE current_sum = arr [ i ] NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum : ▁ " , maxSum ( arr , n ) ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = findMaxSumUtil ( arr , n ) NEW_LINE return finalGCD NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT maxElement = findMaxSumUtil ( arr , n ) NEW_LINE return ( maxElement * n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b % a NEW_LINE b = t NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT a = 20 NEW_LINE b = 52 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT x , y , n = map ( int , input ( ) . split ( ) ) NEW_LINE x , y , n = map ( int , input ( ) . split ( ) ) NEW_LINE y -= n NEW_LINE if x <= y + h : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT
def divisibleby13 ( n1 ) : NEW_LINE INDENT l1 = len ( n1 ) NEW_LINE if ( l1 == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( l1 == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( l1 == '0' ) : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT elif ( l2 == '0' ) : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT elif ( l1 == 2 ) : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT elif ( l1 == 2 ) : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT elif ( l2 == 1 ) : NEW_LINE INDENT g1 = ( n1 - 48 ) * 100 + ( n1 - 48 ) * 100 NEW_LINE DEDENT elif ( l2 == 1 ) : NEW_LINE INDENT g2 = ( n1 - 48 ) * 100 + ( n1 - 48 ) * 100 NEW_LINE DEDENT elif ( l2 == 1 ) : NEW_LINE INDENT g2 = ( n1 - 48 ) * 100 + ( n2 - 48 ) * 100 NEW_LINE DEDENT else : NEW_LINE INDENT g2 = ( n2 - 48 ) * 100 + ( n1 - 48 ) * 100 NEW_LINE DEDENT if ( g2 % 100 == 0 ) : NEW_LINE INDENT return ( g1 % 39 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( div2 % 39 ) NEW_LINE DEDENT DEDENT s = "897575" NEW_LINE if ( divisibleBy13 ( s ) == 1 ) : NEW_LINE INDENT print ( divisibleby13 ( g2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( divisibleBy13 ( g ) ) NEW_LINE DEDENT
n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE p = ( n - 1 ) * p NEW_LINE ans = 1 NEW_LINE if p < 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = p * ( n - 1 ) + n - 1 NEW_LINE print ( ans ) NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( m + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " ef " NEW_LINE Y = " gfg " NEW_LINE cost = lcs ( X , Y , m , n ) NEW_LINE print ( " Minimum ▁ cost ▁ of ▁ two ▁ strings ▁ is " , findCost ( X , Y , m , n ) ) NEW_LINE DEDENT
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) / 2 NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE
def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE sum = 0 NEW_LINE root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT square += ( arr [ i ] ** 2 ) ** 2 NEW_LINE DEDENT sum = ( square / ( n ) ) NEW_LINE root = r / ( n ) NEW_LINE root = r * ( n ) NEW_LINE root = root NEW_LINE return root NEW_LINE DEDENT arr = [ 10 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( rsValue ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT M , N = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE P . sort ( ) NEW_LINE P . reverse ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( i + 1 , M ) : NEW_LINE INDENT if P [ i ] [ j ] > P [ i ] [ j - 1 ] : NEW_LINE INDENT ans = max ( ans , j - P [ i ] [ j ] + P [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE left = [ ] NEW_LINE right = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT left . append ( a [ i // 2 ] , a [ i // 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT right . append ( a [ i // 2 ] , a [ i // 2 ] ) NEW_LINE DEDENT left . append ( a [ - 1 ] , a [ - 1 ] ) NEW_LINE DEDENT right . append ( a [ - 1 ] , a [ - 2 * n ] ) NEW_LINE left . append ( a [ - 2 * n ] ) NEW_LINE right . append ( a [ - 2 * n ] ) NEW_LINE left . append ( a [ - 2 * n ] ) NEW_LINE right . append ( a [ - 2 * n ] ) NEW_LINE print ( ' left ' if left else ' right ' , ▁ left ' , ▁ = ' right ' , ▁ = ' right ' ) NEW_LINE print ( right [ n // 2 - 1 ] , left [ n // 2 - 1 ] , left [ n // 2 - 1 ] ) NEW_LINE
def maxSum ( arr ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 NEW_LINE m2 = 0 NEW_LINE m3 = 0 NEW_LINE for j in m : NEW_LINE INDENT if ( j // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ) NEW_LINE DEDENT elif ( j // ( m // ( m // ( m // ( m // ( m // 3 ) ) ) ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( j // ( m // ( m // ( m // 3 ) ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp [ n ] [ n ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 5 , 2 , 5 , 2 , 2 ] , [ 6 , 4 , 5 , 2 , 2 ] , [ 1 , 4 , 2 , 2 ] ] ] NEW_LINE n = len ( arr ) NEW_LINE maxSum ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] , dp [ n ] [ 1 ] , dp [ n ] [ 2 ] , dp [ n ] [ 2 ] , dp [ n ] [ 2 ] , dp [ n ] [ 2 ] ) NEW_LINE DEDENT
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 , x4 , y4 , y4 ) NEW_LINE print ( " No ▁ intersection ▁ intersection " , x1 , y2 , x3 , y3 ) NEW_LINE print ( " ( " , x1 , x2 , y3 ) " , end = " " ) NEW_LINE print ( " ( " , x1 , y2 , " , y3 , " ) " ) NEW_LINE print ( " ( " , x3 , " , y3 , " , ▁ " , end = " " ) NEW_LINE print ( " ( " , x4 , " , y4 , " , ▁ " ) " , end = " ) NEW_LINE print ( " ( " , x4 , " , y4 , " , end = " ) NEW_LINE print ( " ( " , x4 , y4 , " , ▁ " , end = " ) " ) NEW_LINE x7 = x5 NEW_LINE y8 = y5 NEW_LINE x8 = x5 NEW_LINE y8 = y5 NEW_LINE findPoints ( x1 , y1 , x2 , y2 , x3 , y3 , y4 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE cnt1 = 0 NEW_LINE cnt2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT elif s [ i ] == ' x ' : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT elif s [ i ] == ' x ' : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT elif s [ i ] == ' x ' : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT DEDENT print ( cnt2 ) NEW_LINE print ( cnt1 ) NEW_LINE
n , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n + e * 5 , n % d ) ) NEW_LINE
def kapSack ( W , wt , n ) : NEW_LINE INDENT maxa = - 10 ** 9 NEW_LINE maxindex = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( ( ( ( ( ( int ) / wt [ i ] ) ) ) > maxratio ) ) ) : NEW_LINE INDENT maxa = ( int ( ( ( int ) / wt [ i ] ) ) / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxa ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT val = [ 14 , 27 , 44 , 9 ] NEW_LINE wt = [ 6 , 7 , 9 , 9 ] NEW_LINE n = len ( val ) NEW_LINE W = 50 NEW_LINE print ( kapack ( W , wt , n ) ) NEW_LINE DEDENT
def AlternateRearRange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE j = 0 NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE j += 1 NEW_LINE flag = False NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 9 , 8 , 13 , 2 , 14 , 14 ] NEW_LINE n = len ( arr ) NEW_LINE AlternateRearRange ( arr , n ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a >= b and a >= c : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT binaryNum = len ( binaryNum ) ; NEW_LINE res = " " ; NEW_LINE for i in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( int ( binaryNum [ i + j ] ) != binaryNum [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return res ; NEW_LINE DEDENT def countOccur ( arr , n , pattern ) : NEW_LINE INDENT M = len ( pattern ) ; NEW_LINE N = len ( pattern ) ; NEW_LINE res = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT binaryNum = decToBinary ( arr [ i ] ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 72 , 7 , 8 ] ; NEW_LINE pattern = "10" ; NEW_LINE pattern = "10" ; NEW_LINE n = len ( arr ) ; NEW_LINE findOccur ( arr , n , pattern ) ; NEW_LINE DEDENT
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE DEDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE makearrayequalequal ( arr , n ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findKLargest ( self , nums , k ) : NEW_LINE INDENT self . sort ( nums ) NEW_LINE self . sort ( reverse = True ) NEW_LINE self . sort ( reverse = True ) NEW_LINE self . sort ( reverse = True ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 5 , 6 , 6 ] NEW_LINE k = 2 NEW_LINE out = sObj . findKLargest ( nums , k ) NEW_LINE while len ( nums ) < nums : NEW_LINE INDENT out . append ( nums [ k ] ) NEW_LINE nums . sort ( reverse = True ) NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT while len ( nums [ i ] ) > k and nums [ i + 1 ] > nums [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT while len ( nums ) > k and nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE out = sObj . findKLargest ( nums , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 98765439343934393439343934393439343934393439343934393 = ( 987435343934393439343934393939393 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT k = n % 10 NEW_LINE sum += k NEW_LINE n //= 10 NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 123 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE if s1 == s2 : NEW_LINE INDENT print ( ' WIN ' ) NEW_LINE DEDENT elif s1 == s2 : NEW_LINE INDENT print ( ' LEGMENT ' ) NEW_LINE DEDENT elif s2 == s2 : NEW_LINE INDENT print ( ' REGMENT ' ) NEW_LINE DEDENT elif s1 == s2 : NEW_LINE INDENT print ( ' LEGMENT ' ) NEW_LINE DEDENT elif s2 == s2 : NEW_LINE INDENT print ( ' REGMENT ' ) NEW_LINE DEDENT elif s1 < s2 : NEW_LINE INDENT print ( ' LEGMENT ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' LEGMENT ' ) NEW_LINE DEDENT
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = totalSquares * size NEW_LINE totalArea += area * size NEW_LINE DEDENT return totalArea NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , b = 4 , 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE DEDENT
def arrange ( N ) : NEW_LINE INDENT if ( N == 1 or N == 3 or N == 3 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT even = - 1 NEW_LINE odd = - 1 NEW_LINE even = - 1 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT even = N - 1 NEW_LINE odd = N - 1 NEW_LINE even = N - 1 NEW_LINE even = N - 1 NEW_LINE even = N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = N - 1 NEW_LINE even = N - 1 NEW_LINE even = odd - 2 NEW_LINE even = odd - 2 NEW_LINE even = even - 2 NEW_LINE DEDENT while ( even >= 2 ) : NEW_LINE INDENT print ( even , end = " ▁ " ) NEW_LINE even = odd - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_ NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_ NEW_LINE even = even - 2 NEW_LINE even = even - 2 NEW_ : NEW_LINE even = even - 2 NEW_ NEW_LINE even = even - 2 NEW_LINE even =
def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE min2 = 10 ** 9 NEW_LINE min2 = 10 ** 9 NEW_LINE min = 10 ** 9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if min1 == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 1 , 5 , 7 , 8 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMinEqualSums ( a , N ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( 1 , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 3 + ( n - 3 ) * 2 ) NEW_LINE DEDENT print ( ( n // 3 ) * ( n // 3 + 1 ) * ( n // 3 + 1 ) ) NEW_LINE DEDENT
def findMaximal ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMaximal ( a , N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] += 2 * a [ i ] NEW_LINE DEDENT a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] += 2 * a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT a [ i ] = a [ i ] + 2 * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i ] + 2 * a [ i ] NEW_LINE DEDENT DEDENT ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT ans [ i ] = a [ i ] + 2 * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = a [ i ] + 2 * a [ i ] NEW_LINE DEDENT ans [ i ] = a [ i ] + 2 * a [ i ] NEW_LINE DEDENT ans [ n ] = 2 * a [ n ] NEW_LINE print ( * ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if m <= a [ - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n and s [ i ] == '1' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( '0' * ( n - k ) ) NEW_LINE
def check ( t , b , c , d , p , b , d , p , p , t , d , p , t , p , t , p , t , d , p , t , d , p , t , t , p , t , t , p , t , d , t , p , t , d , t , t , d , t , p , t , d , t , w , t , t , d , t , p , t , d , t , p , t , d , t , t , w , t , d , t , p , t , d , t , t , d , t , w , t , t , t , w , t , t , d , t , w , t , t , t , d , t , t , w , t , t , w , t , t , w , t , t , d , t , t , w , t , t , w , t , t , w , t , t , w , t , t , w , t , t , t , w , t , t , w , t , w , t , t , w , t , w , t , t , t , w , t , t , w , t , t , w , t , w , t , w , t , t , w , t , w , t , t , w , t , w , t , w , t , w , t , w , t , t , w , t , t , w , t , w , t , w , t , w , t , w , t , w , t , w , t , t , w , t , w , t , w , t , w , t , w , t , w , t , t , w , t , w , t , w , t , w , t , w , t , w , t , w , t , w , t , w , w , t , w , t , w , t , w , t , w , t , w , w , t , w , w , t , w , t , w , t , w , w , t , w , w , t , w , w , t , w , w , t , w , w , t , w , w , w , w , w , t , w , w , t , w , w , w , w , w , w , w
N = 10000 NEW_LINE MOD = 1000000007 NEW_LINE F = [ 0 for i in range ( N ) ] NEW_LINE F [ 1 ] = 2 NEW_LINE F [ 2 ] = 3 NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD NEW_LINE DEDENT print ( F [ n ] ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT t += j NEW_LINE DEDENT ans += t NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def CeilLenSubsequence ( A , size , k ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if A [ m ] >= k : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def CeilEvenSubsequence ( A , size ) : NEW_LINE INDENT tail = [ 0 ] * size NEW_LINE len1 = 1 NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT if A [ i ] < A [ i ] : NEW_LINE INDENT tail [ i ] = A [ i ] NEW_LINE DEDENT elif A [ i ] > tail [ len1 - 1 ] : NEW_LINE INDENT tail [ i ] = A [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT tail [ len1 ] = A [ i ] NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 5 , 3 , 7 , 7 , 10 , 10 , 10 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Subsequence ▁ Subsequence ▁ is " , LeilEvenSubsequence ( A , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] - ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE count = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if ( not ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def get_chain_length ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while n != 60 : NEW_LINE INDENT if n not in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT n = factorial ( n ) NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def colorVisible ( height , color , K ) : NEW_LINE INDENT arr [ 0 ] , arr [ K - 1 ] , arr [ K - 1 ] = 1 , 1 NEW_LINE arr [ K - 1 ] , arr [ K - 1 ] = 1 , 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT return int ( minimum ) NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 ] NEW_LINE color = [ 1 , 2 , 3 , 3 ] NEW_LINE K = len ( color ) NEW_LINE print ( colorVisible ( height , color , K ) ) NEW_LINE
from math import log2 NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log2 ( n ) // log2 ( 8 ) ; NEW_LINE return ( i - floor ( i ) < 0.00001 ) ; NEW_LINE DEDENT n = 65 ; NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a , b ) // 4 , ( a + b ) // 4 ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : break NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * n ] NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ans += a [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 0 ] > s [ i ] [ 1 ] : s [ i ] += 1 NEW_LINE else : s [ i ] = s [ i ] [ 1 ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( i > m + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 ; NEW_LINE DEDENT DEDENT return count [ n ] ; NEW_LINE DEDENT n = 7 ; NEW_LINE m = 4 ; NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ " , countWays ( n , m ) ) ; NEW_LINE
def print ( n ) : NEW_LINE INDENT print ( n + n // 2 , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE print ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( n & ( 1 << i ) ) NEW_LINE DEDENT print ( ans % ( 10 ** 9 + 7 ) ) NEW_LINE
s = input ( ) NEW_LINE while True : NEW_LINE INDENT if s [ 0 ] == "0" : NEW_LINE INDENT break NEW_LINE DEDENT s = s [ 1 : ] NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT if i == "1" : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : break NEW_LINE ans = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( 1 , a + 1 ) : NEW_LINE INDENT if i != j and j != a + 1 : ans . append ( i ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT for j in range ( 1 , a + 1 ) : NEW_LINE INDENT if ans [ i ] != j and ans [ j ] != i : ans . append ( j ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def recur ( ind , c , last , last , last , last , last , last , n , a , n , dp ) : NEW_LINE INDENT if ( c == k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( dp [ ind ] [ c ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ c ] NEW_LINE DEDENT if ( dp [ ind ] [ c ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ c ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if ( c & 2 ) : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , c , last + 1 , i , i , n , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , last + 1 , i , 0 , 0 , 0 , 0 , 0 ) ) NEW_LINE DEDENT DEDENT dp [ ind ] [ c ] = ans NEW_LINE return dp [ ind ] [ c ] NEW_LINE DEDENT def __gcd ( a , b , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE print ( recur ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE s = sum ( a ) NEW_LINE s = sum ( a ) NEW_LINE s = s // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT s += a [ 2 * s ] NEW_LINE print ( s ) NEW_LINE
def allArray4 ( bin ) : NEW_LINE INDENT if ( len ( bin ) == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( len ( bin ) == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def isDivisibleBy5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE evensum = 0 NEW_LINE evensum = 0 NEW_LINE evensum = 0 NEW_LINE evensum = 0 NEW_LINE for i in range ( len ( bin ) ) : NEW_LINE INDENT if ( isOdd ) : NEW_LINE INDENT oddsum += evenSum NEW_LINE DEDENT else : NEW_LINE INDENT oddsum += i NEW_LINE DEDENT DEDENT if ( abs ( oddsum - evensum ) % 5 == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT bin = "0000101101001" NEW_LINE print ( isDivisibleBy5 ( bin ) ) NEW_LINE
from itertools import product NEW_LINE try : NEW_LINE INDENT s = list ( input ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT d [ s [ i ] ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] = '0' NEW_LINE DEDENT DEDENT for i in range ( len ( d ) ) : NEW_LINE INDENT if d [ s [ i ] ] == '1' : NEW_LINE INDENT d [ s [ i ] ] = '0' NEW_LINE DEDENT DEDENT for i in range ( len ( d ) ) : NEW_LINE INDENT if d [ s [ i ] ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT d [ s [ i ] ] = '0' NEW_LINE DEDENT d [ s [ i ] ] = '0' NEW_LINE for i in range ( len ( d ) ) : NEW_LINE INDENT if d [ s [ i ] ] == '0' : NEW_LINE INDENT d [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] = d [ s [ i ] ] NEW_LINE DEDENT DEDENT ans = d [ 0 ] NEW_LINE for i in range ( len ( d ) ) : NEW_LINE INDENT if d [ s [ i ] ] == '0' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
a = list ( input ( ) . split ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE c = list ( input ( ) . split ( ) ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] == ' + ' : NEW_LINE INDENT c [ i ] = int ( a [ i ] ) NEW_LINE DEDENT elif b [ i ] == ' + ' : NEW_LINE INDENT c [ i ] = int ( a [ i ] ) NEW_LINE DEDENT elif a [ i ] == ' - ' : NEW_LINE INDENT c [ i ] = int ( b [ i ] ) NEW_LINE DEDENT elif b [ i ] == ' - ' : NEW_LINE INDENT c [ i ] = int ( a [ i ] ) NEW_LINE DEDENT elif b [ i ] == ' - ' : NEW_LINE INDENT c [ i ] = int ( b [ i ] ) NEW_LINE DEDENT elif b [ i ] == ' - ' : NEW_LINE INDENT c [ i ] = int ( a [ i ] ) NEW_LINE DEDENT elif b [ i ] == ' - ' : NEW_LINE INDENT c [ i ] = int ( b [ i ] ) NEW_LINE DEDENT DEDENT print ( c [ 0 ] * a ) NEW_LINE
MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT primes . append ( len ( primes ) ) NEW_LINE DEDENT DEDENT DEDENT def minimumSquareFree ( N ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( " Minimum ▁ Number ▁ Of ▁ Blocks ▁ For ▁ Square ▁ Of ▁ Square ▁ Of ▁ Slips ▁ is ▁ P ▁ is " , minimum_count ) NEW_LINE N = 6 NEW_LINE print ( minimumSquareFree ( N ) ) NEW_LINE DEDENT
x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if x - a > b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x - b ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = a [ : : - 1 ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT c += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if c == k : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " The ▁ number ▁ after ▁ greater ▁ bit ▁ set ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit ▁ bit " , fun ( n ) ) NEW_LINE
def LongFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT S . add ( A [ i ] ) NEW_LINE DEDENT maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ i ] + A [ j ] NEW_LINE y = y NEW_LINE if ( y not in S ) : NEW_LINE INDENT z = x + y NEW_LINE maxLen = max ( maxLen , len ( S ) ) NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 5 , 8 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT
def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if sum in s . keys ( ) : NEW_LINE INDENT cnt += 1 NEW_LINE s . add ( sum ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 12 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 4 , 3 , 7 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPairs ( a , b , n , m ) ) NEW_LINE DEDENT
def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = int ( math . sqrt ( arr [ i ] ) ) NEW_LINE if ( y == math . ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from collections import deque NEW_LINE import sys NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == '0' : NEW_LINE INDENT S . append ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == '1' : NEW_LINE INDENT print ( S [ query [ 1 ] ] ) NEW_LINE DEDENT elif query [ 0 ] == '2' : NEW_LINE INDENT print ( S [ query [ 1 ] ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT print ( S [ query [ 1 ] ] ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT print ( S [ query [ 1 ] ] ) NEW_LINE DEDENT DEDENT
def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The ▁ minimum ▁ sum ▁ is " , calculate_sum ( a , n ) ) NEW_LINE print ( " The ▁ sum ▁ is " , calculate_sum ( a , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = int ( b [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if c == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] % 2 == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif a [ 1 ] % 2 == 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT s2 = s2 [ len ( s2 ) - 1 ] NEW_LINE s2 = s2 [ len ( s2 ) - 1 ] NEW_LINE s2 = s2 [ len ( s2 ) - 1 ] NEW_LINE if ( s == s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if ( len ( s ) <= 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( cnt [ ord ( s ) - 1 ] == ord ( s2 [ len ( s ) - 1 ] ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " nolon " NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = k - 1 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( k , n ) ) NEW_LINE
def minCost ( n , arr , cost ) : NEW_LINE INDENT sumCost = 0 NEW_LINE totalCost = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * sum NEW_LINE arr [ n - 1 ] += cost * sum NEW_LINE totalCost += ( 2 * cost ) NEW_LINE return totalCost NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += a [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT c += a [ i ] [ 1 ] NEW_LINE DEDENT print ( c ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( int ( s [ 0 ] ) + 1 ) : NEW_LINE INDENT if s [ j ] == ' I ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT elif s [ 0 ] == ' I ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = [ ] NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( ( s [ j ] + a ) == 0 ) : NEW_LINE INDENT a . append ( ( s [ j ] + a ) ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insertOrder ( root , data ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if ( root == None ) : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT if ( root . data < root . data ) : NEW_LINE INDENT root . insert ( root . left , data ) NEW_LINE DEDENT if ( root . right > root . data ) : NEW_LINE INDENT root . insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE root = None NEW_LINE root . insert ( root , arr ) NEW_LINE print ( root . insertOrder ( root ) ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LC = [ [ 0 for i in range ( m + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LC [ i ] [ j ] = LC [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LC [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LC [ i ] [ j ] = LC [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LC [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT X = " GEEGeeksforgeeks " NEW_LINE Y = " GEEGeeks " NEW_LINE n = len ( X ) NEW_LINE print ( " Length ▁ of ▁ Substring ▁ Substring ▁ is " , LC ) NEW_LINE
def countOccur ( x , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def maxOccur ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x // 10 NEW_LINE DEDENT result = 0 NEW_LINE max_count = 1 NEW_LINE for d in range ( 0 , 9 ) : NEW_LINE INDENT count = countOccur ( x , d ) NEW_LINE if ( count >= max_count ) : NEW_LINE INDENT max_count = count NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT x = 122345 NEW_LINE print ( " Max ▁ Occur ▁ is " , maxOccur ( x ) ) NEW_LINE
def printLogIncSubArr ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE len1 = 1 NEW_LINE maxIndex = 1 NEW_LINE maxIndex = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( max < len1 ) : NEW_LINE INDENT maxIndex = len1 NEW_LINE maxIndex = i - maxIndex NEW_LINE DEDENT DEDENT if ( max < len1 + maxIndex ) : NEW_LINE INDENT maxIndex = len1 NEW_LINE DEDENT for i in range ( maxIndex + maxIndex ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 3 , 5 , 7 , 9 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printLogIncSubArr ( arr , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT i = i NEW_LINE while n % i == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // i , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE a [ l - 1 ] -= 1 NEW_LINE if r - l + 1 < r : NEW_LINE INDENT print ( " Yes " ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( l , r ) : NEW_LINE INDENT for j in range ( i , r + 1 ) : NEW_LINE INDENT if a [ i ] == j : NEW_LINE INDENT continue NEW_LINE DEDENT a [ i ] = a [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Yes " if a [ l ] == 0 else " No " ) NEW_LINE
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 ] * n ; NEW_LINE S = [ 0 ] * n ; NEW_LINE res = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res ; NEW_LINE res += a [ i ] ; NEW_LINE S [ i ] = res ; NEW_LINE S [ i ] = res ; NEW_LINE DEDENT ans = S ; NEW_LINE ans = S ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] ; NEW_LINE ans = max ( ans , g + b [ i ] ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( " Maximum ▁ sum ▁ is : " , Max_Sum ( a , n ) ) ; NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( a * 2 - 1 ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( a * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * b - 1 ) NEW_LINE DEDENT DEDENT
def reverse ( s , x ) : NEW_LINE INDENT n = ( len ( s ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , n ) : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , n ) : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE reverse ( s , x ) NEW_LINE DEDENT
def lps ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE L = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for j in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( st [ i ] == st [ j ] and j == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( st [ i ] == st [ j ] and j == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i + 1 ] [ j - 1 ] , L [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT st = " geeksforgeeks " NEW_LINE print ( " Minimum ▁ number ▁ of ▁ deletions ▁ = " , minimumNumber ( st ) ) NEW_LINE
def bit_check ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 14 NEW_LINE if bit_check ( n ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if l [ i ] > l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE ans = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE for i in itertools . count ( LIMIT // 2 ) : NEW_LINE INDENT ans += i - i NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
M = 20 NEW_LINE dp = [ [ 0 for i in range ( 2 ) ] for j in range ( 21 ) ] NEW_LINE def count ( pos , c , d , n ) : NEW_LINE INDENT if ( pos == len ( d ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ c ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ c ] [ c ] NEW_LINE DEDENT ans = 0 NEW_LINE for dig in range ( 9 ) : NEW_LINE INDENT currCnt = cnt NEW_LINE if ( dig == d ) : NEW_LINE INDENT return dp [ pos ] [ cnt ] [ cntCnt ] [ cntCnt ] [ cntCnt ] [ cntCnt ] NEW_LINE DEDENT ans += count ( dp [ pos ] [ cnt ] [ cnt ] , currCnt ) NEW_LINE DEDENT dp [ pos ] [ cnt ] [ cnt ] = ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ [ ] for i in range ( len ( x ) ) ] NEW_LINE for bit in range ( len ( num ) ) : NEW_LINE INDENT currCnt = num % 10 NEW_LINE if ( dig == 0 ) : NEW_LINE INDENT currCnt [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT currCnt [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT ans += count ( 0 , 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 11 NEW_LINE R = 100 NEW_LINE d = 100 NEW_LINE k = 2 NEW_LINE print ( solve ( L - 1 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 10 == 0 : NEW_LINE INDENT ans += ( 10 ** i ) * ( 10 ** ( i - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( 10 ** ( i - 1 ) ) * ( 10 ** ( i - 1 ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def isPeak ( arr , n , num , i , j , j , j ) : NEW_LINE INDENT if i >= 0 and arr [ i ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ i ] < num [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] < num [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def printPeaks ( arr , n ) : NEW_LINE INDENT print ( " Points ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPeak ( arr , n , arr [ i ] , i + 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT printPeaks ( arr , n ) NEW_LINE DEDENT arr = [ 5 , 10 , 5 , 7 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPeaks ( arr , n ) NEW_LINE
def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( i >> 31 ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = [ " zero " , " zero " ] NEW_LINE val = index ( n ) NEW_LINE val = index ( n ) NEW_LINE print ( n , " is " , s [ val ] ) NEW_LINE DEDENT check ( 30 ) NEW_LINE check ( 30 ) NEW_LINE
def frequency ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( a ) NEW_LINE print ( frequency ( a , n , x ) ) NEW_LINE
def isNumBinary ( num ) : NEW_LINE INDENT num = abs ( num ) NEW_LINE s = num + 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s = s [ i ] NEW_LINE s = s [ i ] NEW_LINE DEDENT if ( num <= len ( s ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT s = s + 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 1234567890 NEW_LINE flag = isNumBinary ( N ) NEW_LINE if ( flag ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreeDiscerent ( num ) : NEW_LINE INDENT sq = sqrt ( n ) NEW_LINE if ( 1 * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT num = 15 NEW_LINE if isThreeDiscerent ( num ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDiscerent ( num ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = 1534 NEW_LINE if ( isThreeDiscerent ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 1534 NEW_LINE if isThreeDistinct ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 153975 NEW_LINE if isThreeDistinct ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 15397537419 NEW_LINE if isThreeDistinct ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 153975374 NEW_LINE if ( isThreeFactorial ( num ) ) : NEW_LINE
def compute ( ) : NEW_LINE INDENT n = 1 NEW_LINE d = 0 NEW_LINE while True : NEW_LINE INDENT if n % 3 == 0 : NEW_LINE INDENT return n // 3 + d NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT DEDENT n = 1 NEW_LINE d = 1 NEW_LINE while True : NEW_LINE INDENT if n % 3 == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT rem = n // 3 NEW_LINE DEDENT rem = n % 3 NEW_LINE rem = n // 3 NEW_LINE rem = n % 3 NEW_LINE return rem NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) // ( gcd ( x , y ) ) ) NEW_LINE return ( ( x * ans ) // ( gcd ( x , y ) ) ) NEW_LINE DEDENT def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) >> 1 ) NEW_LINE n = pow ( 10 , n - 1 ) NEW_LINE return int ( n ) NEW_LINE DEDENT def LCM ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y ) NEW_LINE ndigit = pow ( 10 , n ) NEW_LINE if ( ndigit < pow ( 10 , n ) ) : NEW_LINE INDENT return ndigit NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE z = 5 NEW_LINE res = findDivisible ( n , x , y , z ) NEW_LINE if res != 0 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT
MAXN = 100001 NEW_LINE prime = [ True for i in range ( MAXN ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( MAXN ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAXN , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT gcd = math . gcd ( a , b ) NEW_LINE for i in range ( 2 , ( gcd , a ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] and gcd % i == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE a = 6 NEW_LINE b = 12 NEW_LINE common_prime ( a , b ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT s , l , r = map ( int , input ( ) . split ( ) ) NEW_LINE s -= l NEW_LINE dp [ l ] [ r ] = s NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , l ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] + p [ k ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if dp [ i ] [ j ] < dp [ i ] [ j ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE a , b = LI ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = LI ( )
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE for i in a : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT a [ i ] [ j ] += a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if a == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE k = s . split ( ) NEW_LINE a = len ( s ) NEW_LINE b = min ( a , k ) NEW_LINE a = min ( a , k ) NEW_LINE b = min ( a , k ) NEW_LINE a = a + 1 NEW_LINE b = min ( b , k ) NEW_LINE print ( a , b ) NEW_LINE
a = input ( ) NEW_LINE b = input ( ) NEW_LINE d = { a . lower ( ) : b . lower ( ) for a in b } NEW_LINE d [ ' A ' , ' B ' , ' C ' , ' D ' , ' D ' , ' D ' , ' E ' , ' F ' , ' F ' , ' G ' , ' H ' , ' D ' , ' E ' , ' F ' , ' F ' , ' G ' , ' H ' , ' W ' , ' E ' , ' F ' , ' G ' , ' H ' , ' W ' , ' E ' , ' F ' , ' F ' , ' G ' , ' H ' , ' W ' , ' E ' , ' F ' , ' F ' , ' G ' , ' H ' , ' W ' , ' X ' , ' Z ' ] NEW_LINE d = int ( input ( ) ) NEW_LINE for i in range ( d ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( d ) : NEW_LINE INDENT if s [ j ] in s : NEW_LINE INDENT d [ j ] = s [ j ] . lower ( ) NEW_LINE DEDENT DEDENT if d [ s [ j ] ] == s [ j ] : NEW_LINE INDENT print ( ' WA ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' WA ' ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import heapq NEW_LINE import random NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from itertools import combinations NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heapify , heappop , heappush NEW_LINE from math import inf NEW_LINE from random import randint NEW_LINE from functools import reduce NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] NEW_LINE def solve ( n , l , l , r ) : NEW_LINE INDENT S = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT S . append ( list ( map ( str , S [ i ] . split ( ) ) ) ) NEW_LINE DEDENT return ' \n ' .
class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE ans = 0 NEW_LINE for row in grid : NEW_LINE INDENT for col in range ( len ( grid ) ) : NEW_LINE INDENT if grid [ row ] [ col ] == 1 : NEW_LINE INDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT elif grid [ row ] [ col ] == 1 : NEW_LINE INDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT elif grid [ row ] [ col ] == 1 : NEW_LINE INDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT elif grid [ row ] [ col ] == 1 and grid [ row ] [ col ] == 0 : NEW_LINE INDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT elif grid [ row ] [ col ] == 1 and grid [ col ] [ col ] == 1 : NEW_LINE INDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT DEDENT ans = max ( ans , shape [ row ] [ col ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE grid = Solution ( ) NEW_LINE grid = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE out = sObj . maxAreaOfIsland ( grid ) NEW_LINE print ( out ) NEW_LINE DEDENT
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( pow ( x , 2 * n ) * ( pow ( x , 2 * n ) - 1 ) ) // ( pow ( x , n ) - 1 ) NEW_LINE sum2 = ( x * y ) // ( pow ( x , n ) - 1 ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT x = 2 NEW_LINE y = 2 NEW_LINE n = 2 NEW_LINE print ( sum ( x , y , n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) // 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE return int ( n * ( n + 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT temp = temp . next NEW_LINE DEDENT i = i + 6 NEW_LINE if ( i == None or isPrime ( temp ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT def deleteNonPrimeNodes ( head ) : NEW_LINE INDENT ptr = next NEW_LINE while ( ptr != None and not isPrime ( ptr ) ) : NEW_LINE INDENT ptr = ptr NEW_LINE ptr = ptr NEW_LINE DEDENT ptr = ptr . next NEW_LINE while ( ptr != None and not isPrime ( ptr ) ) : NEW_LINE INDENT ptr . next = ptr . next NEW_LINE DEDENT ptr . next = ptr . next NEW_LINE DEDENT return head NEW_LINE DEDENT def deleteNonPrimeNodes ( head ) : NEW_LINE INDENT ptr = head NEW_LINE head = push NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 15 ) NEW_LINE printNonPrimeNodes ( head ) NEW
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI_number ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI_number ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI_number ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def LLI_number ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def solve ( l , r , l , r ) : NEW_LINE INDENT dp_number = [ LI ( ) for _ in range ( l + 1 ) ] NEW_LINE dp_number = [ [ 0 ] * l for _ in range ( l + 1 ) ] NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT dp_number [ i ] = dp_number [ i ] NEW_LINE DEDENT for l , r in dp_number : NEW_LINE INDENT for i in range ( l - 1 , l - 1 ) : NEW_LINE INDENT for j in range ( l - 1 , r ) : NEW_LINE INDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b = set ( ) NEW_LINE c = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT b . add ( a [ i ] ) NEW_LINE c += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . count ( ' . ' ) == 1 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT elif s . count ( ' . ' ) == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT elif s . count ( ' . ' ) == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT elif s . count ( ' . ' ) == 1 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( c ) NEW_LINE
def minReplacement ( str ) : NEW_LINE INDENT if ( len ( str ) > 26 ) : NEW_LINE INDENT print ( " IMPOSSIBLE " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE str [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT print ( str ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " xxxyyyy " ; NEW_LINE minReplacement ( str ) ; NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count = [ 0 ] * ( n + 2 ) NEW_LINE pre_count [ 0 ] = 0 NEW_LINE pre_count [ 0 ] = 0 NEW_LINE pre_count [ 0 ] = 0 NEW_LINE pre_count [ 0 ] = 0 NEW_LINE pre_count [ 0 ] = 0 NEW_LINE pre_count [ 0 ] = pre_count [ 0 ] = pre_count [ 1 ] NEW_LINE pre_count [ 0 ] = pre_count [ 1 ] = pre_count [ 2 ] NEW_LINE pre_count [ 0 ] = pre_count [ n - 1 ] + pre_count [ 2 ] NEW_LINE if ( s [ n - 1 ] == '0' ) : NEW_LINE INDENT pre_count [ n - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count [ n - 1 ] += pre_count [ n - 1 ] NEW_LINE pre_count [ n - 1 ] += pre_count [ n - 1 ] NEW_LINE pre_count [ n - 1 ] += pre_count [ n - 2 ] NEW_LINE DEDENT if ( pre_count [ n - 1 ] == '0' ) : NEW_LINE INDENT pre_count [ n - 1 ] += 1 NEW_LINE pre_count [ n - 1 ] += pre_count [ n - 1 ] NEW_LINE pre_count [ n - 1 ] += pre_count [ n - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = max ( pre_count [ i - 1 ] + pre_count [ i - 1 ] , pre_count [ i + 1 ] - pre_count [ i - 1 ] + pre_count [ i + 1 ] , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = "000011100000" NEW_LINE print ( longestSubseq ( s ) ) NEW_LINE
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while i <= N + 1 : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i ; NEW_LINE j += 2 ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT prime [ i * j ] = i ; NEW_LINE s [ i * j ] = i ; NEW_LINE DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT sieveOfEratosthenes ( N , s ) ; NEW_LINE curr = s [ N ] ; NEW_LINE cnt = 1 ; NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] ; NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE continue ; NEW_LINE DEDENT print ( curr , cnt ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 360 ; NEW_LINE generatePrimeFactors ( N ) ; NEW_LINE DEDENT
def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ i ] [ i ] = 1 NEW_LINE DEDENT longest = - 10 ** 9 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 and hash [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 56 , 56 , 56 , 53 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT
for s in [ * open ( 0 ) ] [ 1 : ] : a , b , c = map ( int , s . split ( ) ) ; print ( ( a + b + c ) // 2 ) NEW_LINE
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 2 NEW_LINE x = x // 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE v . append ( x ) NEW_LINE v . append ( x ) NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT vb = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( aa != vb ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations ( vb - vb ) NEW_LINE return minOperations ( vb - vb ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 14 NEW_LINE b = 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE DEDENT
N = 1000001 NEW_LINE C = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE def Calculate ( v ) : NEW_LINE INDENT vis [ a ] = 1 NEW_LINE c = 1 NEW_LINE c += 1 NEW_LINE for i in v : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , vis , vis , vis ) NEW_LINE DEDENT DEDENT vis [ b ] = 0 NEW_LINE vis [ a ] = 0 NEW_LINE c = 0 NEW_LINE vis [ b ] = 0 NEW_LINE c = 0 NEW_LINE vis [ b ] = 0 NEW_LINE c = 0 NEW_LINE vis [ b ] = 0 NEW_LINE vis [ b ] = 0 NEW_LINE c = 0 NEW_LINE vis [ b ] = 0 NEW_LINE vis [ b ] = 0 NEW_LINE vis [ b ] = 0 NEW_LINE vis [ b ] = 0 NEW_LINE vis [ b ] = 0 NEW_LINE vis [ b ] = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT v = vis [ i ] NEW_LINE vis [ v ] = v NEW_LINE vis [ i ] = 1 NEW_LINE DEDENT vis = N - c - c - 1 NEW_LINE print ( n - c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE m = 7 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE G = [ [ [ 1 , 2 ] , [ 3 , 5 ] ] NEW_LINE vis = [ [ [ 1 , 2 ] , [ 5 , 5 ] , [ 7 , 5 ] ] ] NEW_LINE Calculate ( v , a , b , b ) ] NEW_LINE print ( Calculate ( v ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = str ( n ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s [ i ] = 9 * ( len ( s [ i ] ) - 1 ) NEW_LINE DEDENT s1 = s [ : : - 1 ] NEW_LINE s2 = s [ : : - 1 ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '9' : NEW_LINE INDENT s1 *= 10 NEW_LINE DEDENT elif s [ i ] == '9' : NEW_LINE INDENT s2 *= 10 NEW_LINE DEDENT elif s [ i ] == '9' : NEW_LINE INDENT s2 *= 10 NEW_LINE DEDENT elif s [ i ] == '9' : NEW_LINE INDENT s2 *= 10 NEW_LINE DEDENT elif s [ i ] == '9' : NEW_LINE INDENT s2 *= 10 NEW_LINE DEDENT DEDENT print ( s1 ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while a >= b : NEW_LINE INDENT i += 1 NEW_LINE a = i NEW_LINE DEDENT print ( i ) NEW_LINE
from math import sqrt NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisor ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisor ( n ) ) NEW_LINE
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT return pow ( 10 , x - 1 ) NEW_LINE DEDENT def f ( x ) : NEW_LINE INDENT return pow ( 10 , x ) NEW_LINE DEDENT def f ( x ) : NEW_LINE INDENT return pow ( 10 , x ) NEW_LINE DEDENT def f ( x ) : NEW_LINE INDENT return pow ( x - 1 ) * f ( x // 2 ) NEW_LINE DEDENT def f ( x , y ) : NEW_LINE INDENT return pow ( x - 1 , y ) NEW_LINE DEDENT def f ( x , y ) : NEW_LINE INDENT return f ( x // 2 , y ) * f ( y // 2 ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT l , r = f ( x // 2 , y ) NEW_LINE ans = f ( l , r ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE
from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( sr - floor ( sr ) == 0 ) NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT sr = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num /= i NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT vec += 1 NEW_LINE DEDENT return len ( vec ) == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isPerfectSquare ( i ) and isPerfectSquare ( i ) ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT return len ( vec ) NEW_LINE DEDENT N = 30 NEW_LINE findNumbers ( N ) NEW_LINE
a , b , c , d , e , f , ' ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , '
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = input ( ) NEW_LINE if n == '0' : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = 0 NEW_LINE for i in n : NEW_LINE INDENT s += int ( i ) NEW_LINE DEDENT s += int ( i ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT sum = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = sum + i + n // i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT num1 = 55923 ; NEW_LINE num2 = 734 ; NEW_LINE if ( areEquivalent ( num1 , num2 ) ) : NEW_LINE INDENT print ( " Equivalent " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Equivalent " ) ; NEW_LINE DEDENT
def findY ( x ) : NEW_LINE INDENT if ( x > 2 ) : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE
MOD = 1000000007 ; NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT n = 3 ; m = 2 ; NEW_LINE print ( modFact ( n , m ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE res = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] < a [ i ] : NEW_LINE INDENT res . append ( a [ j ] ) NEW_LINE a [ j ] , a [ i ] = a [ j ] , a [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( len ( res ) ) NEW_LINE print ( * res ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10000000 ) NEW_LINE def dfs ( M , p , q , r , s ) : NEW_LINE INDENT if M [ p ] [ s ] == 1 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if s == 1 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if s == 0 : return 1 NEW_LINE if ( s == 0 ) + s == 0 : return 1 NEW_LINE if ( s == 0 ) + s == 0 : return 1 NEW_LINE if ( s == 0 ) + s == 0 : return 1 NEW_LINE if ( s == 0 ) + s == 0 : return 1 NEW_LINE if ( s == 0 ) + s == 0 : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE if ( s == 0 ) : return 1 NEW_LINE ans += dfs ( s == 1 ) NEW_LINE if ( s == 1 ) : return ans += 1 NEW_LINE ans += 1 NEW_LINE DEDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( a [ i ] ) NEW_LINE DEDENT l . reverse ( ) NEW_LINE l . reverse ( ) NEW_LINE l . reverse ( ) NEW_LINE l . reverse ( ) NEW_LINE l . reverse ( ) NEW_LINE l . reverse ( ) NEW_LINE print ( * l ) NEW_LINE
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * pow ( a , 2 ) + pow ( b , 2 ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE DEDENT
def find ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , ( 1 << length ) ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT DEDENT if ( sum == s ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ - 1 , 2 , 4 , 121 ] NEW_LINE find ( array , length , s ) NEW_LINE DEDENT
def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( fre [ i ] % k == 0 ) : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE x -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT s = " aabbabb " NEW_LINE k = 2 NEW_LINE print ( K_String ( s , k ) ) NEW_LINE
from itertools import accumulate NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE m = [ [ 0 ] * ( n + 1 ) for _ in [ 0 ] * n ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( accumulate ( 1 << i * a ) ) NEW_LINE m [ i ] [ 0 ] = 1 NEW_LINE for j in range ( m + 1 ) : NEW_LINE INDENT m [ i + j ] [ j + 1 ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in m : NEW_LINE INDENT ans += ( 1 - ( i * m [ i ] [ j ] / 2 ) ** ( 1 / 2 ) ) ** ( 1 / ( 2 ** m [ i ] [ j ] ) ) ** ( 1 / ( 2 ** m [ i ] [ j ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE result = 0 NEW_LINE for c in args : NEW_LINE INDENT if c / b > 0 : NEW_LINE INDENT result += c / b NEW_LINE DEDENT else : NEW_LINE INDENT result += c / b NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= i : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = solve ( a , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and k == 0 : break NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( k ) : b [ i ] -= a [ i ] NEW_LINE DEDENT print ( " Yes " if n == 0 else " No " ) NEW_LINE
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 ] * 10 NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = temp NEW_LINE b = temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE s = "46474" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE DEDENT
def maxZeros ( n ) : NEW_LINE INDENT if ( n == 0 or ( n == 0 or n % ( n - 1 ) ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE prevBit = 1 NEW_LINE prevBit = 1 NEW_LINE prevBit = 1 NEW_LINE prevBit = prevBit << 1 NEW_LINE for i in range ( 1 , b * 8 + 1 ) : NEW_LINE INDENT prevBit = prevBit << 1 NEW_LINE if ( n & bitBit ) : NEW_LINE INDENT if ( n & bitBit ) : NEW_LINE INDENT maxBit = prevBit NEW_LINE prevBit = prevBit NEW_LINE DEDENT prevBit = prevBit NEW_LINE DEDENT prevBit = prevBit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT n = 549 NEW_LINE print ( maxZeros ( n ) ) NEW_LINE
def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 NEW_LINE while num <= n : NEW_LINE INDENT sum += num NEW_LINE num *= k NEW_LINE num *= k NEW_LINE DEDENT return sum NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwr = sumPowersK ( n , k ) NEW_LINE sumAllPowers = ( n * ( n + 1 ) ) // 2 NEW_LINE return ( sum - pwrK ) NEW_LINE DEDENT n , k = 10 , 3 NEW_LINE print ( getSum ( n , k ) ) NEW_LINE
def XandYZintercept ( A , B , C , D ) : NEW_LINE INDENT rslt = - D // A NEW_LINE y = - D // A NEW_LINE zlt = - D // C NEW_LINE return rlt NEW_LINE DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE D = 7 NEW_LINE print ( XandYZintercept ( A , B , C , D ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i + 1 ) NEW_LINE l . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE maxSum ( a , n ) NEW_LINE
MAX = 1000 NEW_LINE def replaceString ( s ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s [ i - 1 ] == ' ▁ ' : NEW_LINE INDENT space_count += 1 NEW_LINE i -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT new_length = i + space_count * 2 NEW_LINE if ( new_length > MAX ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT index_length = new_length - 1 NEW_LINE new_length = new_length - 1 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( new_string [ j ] == ' ▁ ' ) : NEW_LINE INDENT string [ index_length - 1 ] = '0' NEW_LINE new_length -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index_length - 1 ] = '2' NEW_LINE index_length -= 1 NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " Mod ▁ John ▁ John " NEW_LINE string = replaceString ( string ) NEW_LINE string = replaceString ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT print ( string [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s [ : n ] NEW_LINE b = s [ n : n ] NEW_LINE if m == 0 : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT b = 0 NEW_LINE DEDENT else : NEW_LINE INDENT b = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT a = 0 NEW_LINE DEDENT else : NEW_LINE INDENT b = 0 NEW_LINE DEDENT DEDENT print ( '01' * b + '1' * b ) NEW_LINE
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( 10 , 20 ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE h = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if h [ j ] - h [ i - 1 ] > h [ j ] : NEW_LINE INDENT ans = min ( ans , abs ( h [ j ] - h [ j - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n = input ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT s . append ( int ( s [ i ] ) ) NEW_LINE DEDENT s = '9' * ( len ( s ) - 1 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s += s [ i ] NEW_LINE DEDENT print ( min ( k , s [ : k ] ) ) NEW_LINE
n , k , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE while n > 1 : NEW_LINE INDENT if n % k == 0 : NEW_LINE INDENT res += a * b NEW_LINE n //= k NEW_LINE DEDENT else : NEW_LINE INDENT res += ( n // k ) * a NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 or sum > 9 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT b . append ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( j ) NEW_LINE DEDENT DEDENT DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp [ - 1 ] [ - 1 ] ) ) NEW_LINE
def centered_hagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( " % d ▁ Centered ▁ number ▁ : ▁ " % n , centered_hagonal_num ( n ) ) NEW_LINE
def missingNum ( arr , n ) : NEW_LINE INDENT minvalue = min ( arr ) NEW_LINE xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor ^= ( minvalue ^ arr [ i ] ) NEW_LINE minvalue = xor ^ ( minvalue ) NEW_LINE DEDENT return xor ^ minvalue NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 13 , 12 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( missingNum ( arr , n ) ) NEW_LINE DEDENT
def smallestPermute ( n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( ord ( ' a ' ) + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( ord ( ' a ' ) + i + 2 ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( ord ( ' a ' ) + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( ord ( ' a ' ) + i + 2 ) ; NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) ; NEW_LINE res [ n - 2 ] = chr ( 48 + n - 1 ) ; NEW_LINE DEDENT res [ n ] = chr ( 48 + n - 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE smallestPermute ( n ) ; NEW_LINE
def minOperations ( a , n , K ) : NEW_LINE INDENT map = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if map [ a [ i ] ] in map : NEW_LINE INDENT return 1 NEW_LINE DEDENT map [ a [ i ] ] . append ( a [ i ] ) NEW_LINE DEDENT b = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] & K NEW_LINE DEDENT map . clear ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if map [ a [ i ] ] != b [ i ] : NEW_LINE INDENT map [ b [ i ] ] = 1 NEW_LINE DEDENT DEDENT map . clear ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if map [ a [ i ] ] != b [ i ] : NEW_LINE INDENT map [ b [ i ] ] = 2 NEW_LINE DEDENT DEDENT map . clear ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if map [ b [ i ] ] != b [ i ] : NEW_LINE INDENT map [ b [ i ] ] = 2 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT K = 3 NEW_LINE a = [ 1 , 2 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( a , n , K ) ) NEW_LINE DEDENT
def search ( x , y , x , y ) : NEW_LINE INDENT if x == 0 and y == 0 : NEW_LINE INDENT return x , y NEW_LINE DEDENT elif x == 0 : NEW_LINE INDENT return y , x , y NEW_LINE DEDENT else : NEW_LINE INDENT return x , y NEW_LINE DEDENT DEDENT def search ( x , y ) : NEW_LINE INDENT global y , x , y NEW_LINE if x == 0 and y == 0 : NEW_LINE INDENT return x , y NEW_LINE DEDENT elif x == 0 and y == 0 : NEW_LINE INDENT return y , x , y NEW_LINE DEDENT elif x == 0 : NEW_LINE INDENT return x , y NEW_LINE DEDENT else : NEW_LINE INDENT return x , y NEW_LINE DEDENT DEDENT DEDENT def search ( x , y ) : NEW_LINE INDENT global y NEW_LINE global x , y NEW_LINE global y NEW_LINE global y , x , y NEW_LINE if x == 0 : NEW_LINE INDENT search ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT search ( x , y ) NEW_LINE DEDENT DEDENT def search ( x , y ) : NEW_LINE INDENT global y NEW_LINE INDENT global y NEW_LINE x , y = y , x NEW_LINE if x == 0 : NEW_LINE INDENT search ( x , y ) NEW_LINE DEDENT elif x == 0 : NEW_LINE INDENT search ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT search ( x , y ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT search ( x , y ) NEW_LINE DEDENT DEDENT w = int ( input ( ) ) NEW_LINE while w != 0 : NEW_LINE INDENT w = int ( input ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT search ( x , y ) NEW_LINE DEDENT w , h = [ ] , [ ] NEW_LINE search ( x , y ) NEW_LINE search ( x , y ) NEW_LINE w , w = [ [ 0 , 0
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 360 == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 7 , eulerlib . bit_length ( ) , - 1 , - 1 ) : NEW_LINE INDENT ans += eulerlib . binomial ( i , 0 , - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def fractions ( n , ans ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT ans += fractions . factorial ( n - i , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def fractions ( n , ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans += fractions . factorial ( n - i , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) . split ( ) NEW_LINE t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t += t NEW_LINE s += t NEW_LINE DEDENT t += 60 * 60 + s NEW_LINE print ( t , 0 ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a * b , a * b ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT s1 = input ( ) NEW_LINE if s1 == "0" : NEW_LINE INDENT break NEW_LINE DEDENT s2 = input ( ) NEW_LINE s1 = s2 . count ( "0" ) NEW_LINE s2 = s1 . count ( "1" ) NEW_LINE s3 = s2 . count ( "0" ) NEW_LINE s3 = s2 . count ( "0" ) NEW_LINE if s1 == s2 : NEW_LINE INDENT s1 += 1 NEW_LINE DEDENT if s1 == "0" : NEW_LINE INDENT s1 += 1 NEW_LINE DEDENT if s2 == "0" : NEW_LINE INDENT s1 += 1 NEW_LINE DEDENT if s1 == s2 : NEW_LINE INDENT s2 += 1 NEW_LINE DEDENT if s1 == s2 : NEW_LINE INDENT s2 += 1 NEW_LINE DEDENT print ( s1 , s2 ) NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ is ▁ array ▁ is ▁ " ) NEW_LINE DEDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ array ▁ is ▁ " , end = " " ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 2 ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , i ) : NEW_LINE INDENT arr [ i ] = max ( arr [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT arr1 [ i ] = max ( arr1 [ i + 1 ] , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT arr2 [ i ] = max ( arr2 [ i + 1 ] , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT arr2 [ i ] = max ( arr2 [ i + 1 ] , arr2 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return arr2 [ 0 ] NEW_LINE DEDENT arr = [ 4 , 8 , 9 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE
def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE centeredHexagonalSeries ( n ) NEW_LINE
S = input ( ) NEW_LINE print ( ' Yes ' if S [ 0 ] == ' A ' or S [ 1 ] == ' B ' or S [ 2 ] == ' C ' or S [ 2 ] == ' B ' or S [ 3 ] == ' C ' or S [ 1 ] == ' B ' or S [ 2 ] == ' C ' or S [ 3 ] == ' B ' or S [ 3 ] == ' C ' or S [ 1 ] == ' B ' or S [ 2 ] == ' C ' or S [ 1 ] == ' D ' or S [ 2 ] == ' C ' or S [ 1 ] == ' D ' or S [ 2 ] == ' B ' or S [ 1 ] == ' C ' or S [ 2 ] == ' D ' or S [ 1 ] == ' C ' or S [ 2 ] == ' D ' or S [ 1 ] == ' C ' or S [ 2 ] == ' D ' or S [ 1 ] == ' D ' or S [ 1 ] == ' C ' or S [ 2 ] == ' D ' or S [ 2 ] == ' D ' or S [ 1 ] == ' ABC ' or S [ 2 ] == ' ABC ' or S [ 2 ] == ' ABC ' or S [ 3 ] == ' ABC ' or S [ 3 ] == ' ABC ' or S [ 2 ] == ' ABC ' or S [ 3 ] == ' ABC ' or S [ 3 ] == ' ABC ' or S [ 3 ] == ' ABC ' or S [ 3 ] == ' ABC ' or S [ 4 ] == ' ABC ' or S [ 4 ] == ' ABC ' or S [ 4 ] == ' ABC ' or S [ 4 ] == ' ABC ' or S [ 4 ] == ' ABC ' : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT s1 = 0 NEW_LINE s2 = 0 NEW_LINE for i in s : NEW_LINE INDENT if i . count ( ' R ' ) < k : NEW_LINE INDENT s1 += i . count ( ' R ' ) NEW_LINE DEDENT elif i . count ( ' R ' ) < k : NEW_LINE INDENT s2 += i . count ( ' R ' ) NEW_LINE DEDENT DEDENT print ( s1 // ( k + 1 ) ) NEW_LINE
def diagonMinMinMinMaxMinMinMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMin
def diagonMinMinMinMinMinMinMinMaxMinMaxMinMaxMinMaxMinMaxMinMinMinMaxMinMaxMinMaxMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMinMin
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count += 1 NEW_LINE sum += n NEW_LINE n = n - 2 NEW_LINE DEDENT return sum // count NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) // 2 NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT res = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT res . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in res : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT return ( count == len ( res ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def getLeftMostOne ( one ) : NEW_LINE INDENT if ( one == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one . pop ( 0 ) NEW_LINE return 0 NEW_LINE DEDENT def getLeftMostOne ( one , one ) : NEW_LINE INDENT if ( one == one ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one . pop ( 0 ) NEW_LINE return 1 NEW_LINE DEDENT def getLeftMostOne ( one , one ) : NEW_LINE INDENT if ( one == one ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( one == one and one [ - 1 ] ) : NEW_LINE INDENT one . pop ( 0 ) NEW_LINE return 1 NEW_LINE DEDENT elif ( one [ - 1 ] < one [ - 1 ] ) : NEW_LINE INDENT one . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT one . pop ( 0 ) NEW_LINE DEDENT DEDENT def performQueries ( arr , n , q ) : NEW_LINE INDENT zero = [ ] NEW_LINE one . pop ( 0 ) NEW_LINE one . append ( i ) NEW_LINE one . append ( i ) NEW_LINE one . append ( i ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT one . append ( i ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT if ( one [ i ] == 0 ) : NEW_LINE INDENT zero . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT one . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT one = one [ i ] NEW_LINE one . append ( i ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT if ( one [ i ] == 1 ) : NEW_LINE INDENT printLeftMostOne ( one [ i ] , one [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT printLeftMostMostOne ( one [ i ] , one [ i ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( - 1 ) + "0" , end = " ▁ " ) NEW_LINE print ( val * ( - 1 ) , end = " ▁ " ) NEW_LINE DEDENT x = 3 NEW_LINE y = 3 NEW_LINE Vertices ( x , y ) NEW_LINE
def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n ; NEW_LINE P [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i - 1 ] + P [ i - 1 ] ; NEW_LINE DEDENT S = P [ n - 1 ] ; NEW_LINE S = P [ n - 1 ] ; NEW_LINE for i in range ( 1 , S ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pre [ i ] = 1 ; NEW_LINE DEDENT S . append ( i ) ; NEW_LINE DEDENT S . sort ( ) ; NEW_LINE S = P [ n - 1 ] ; NEW_LINE for i in range ( S ) : NEW_LINE INDENT if ( S % i == 0 or S [ i ] != 1 ) : NEW_LINE INDENT pre [ i ] = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT res = set ( ) ; NEW_LINE for i in range ( S // i , S ) : NEW_LINE INDENT if ( S [ i ] == S ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT res . append ( div [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT res . append ( div [ i ] ) ; NEW_LINE DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( res ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE getSum ( a , n ) ; NEW_LINE DEDENT
def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = n - divide [ i ] NEW_LINE arr [ k ] = temp [ k ] NEW_LINE temp [ k ] = temp [ k ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Arr = [ 6 , 3 , 2 , 1 , 1 , 0 , 0 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE originalArray ( Arr , n ) NEW_LINE DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT k = input ( ) NEW_LINE if s [ 0 ] == s [ 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , H ) : NEW_LINE INDENT self . H = H [ 1 ] NEW_LINE result = - 10 ** 9 NEW_LINE for x in range ( self . H ) : NEW_LINE INDENT index = x - ( x - 1 ) NEW_LINE if index < 0 : NEW_LINE INDENT index = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = - 1 NEW_LINE DEDENT DEDENT result = max ( result , self . H [ - 1 ] - H [ 0 ] ) NEW_LINE return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE h = [ 1 , 2 , 3 ] NEW_LINE out = sObj . findRadius ( h , h ) NEW_LINE print ( out ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( i % 2 for i in range ( 7 , 25 , 2 ) if i % 5 == 0 and i % 5 == 0 and i % 5 == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def findLeestdivisible_smallestmod ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 7 , 25 , 2 ) : NEW_LINE INDENT k = pow ( 10 , i ) NEW_LINE pow = pow ( 10 , pow ) NEW_LINE pow += pow ( pow + pow ) % n NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( computeLeestdivisible_smallest_smallestmod ( n ) ) NEW_LINE DEDENT
def checkRecursive ( num , x , k , n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( x == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT r = pow ( num , 1.0 / n ) NEW_LINE for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - pow ( i , n ) NEW_LINE if ( a >= 0 ) : NEW_LINE INDENT checkRecursive ( i , x - pow ( i , n ) , i ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , 0.0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( checkRecursive ( 10 , 2 ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT print ( ' + s [ i ] , end = ' ' ) NEW_LINE DEDENT elif s [ i ] == '7' : NEW_LINE INDENT print ( ' ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ' , end = ' ' ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * n ] NEW_LINE b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * n ] NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in [ 0 ] * n ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if j - a [ i ] [ j ] < 0 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - a [ j ] [ j ] + b [ i ] // 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - a [ i ] [ j ] + b [ i ] / 2 NEW_LINE DEDENT DEDENT DEDENT ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans [ i ] = max ( ans [ i ] [ n - i ] , dp [ i ] [ n - a [ i ] ] [ n - a [ i ] ] / 2 ) NEW_LINE DEDENT print ( * ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT elif i == 1 : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def prime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = a + b NEW_LINE temp = 1 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( ( sum + temp ) == 0 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) NEW_LINE DEDENT n , m , a = 6 , 6 , 4 NEW_LINE print (Squares ( n , m , a ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n % m == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , a + 1 ) : NEW_LINE INDENT if ( j * j <= i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT a = 7 NEW_LINE b = 30 NEW_LINE print ( " Count ▁ of ▁ Circubes ▁ is " , countCubes ( a , b ) ) NEW_LINE
import sys NEW_LINE from collections import Counter NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT B [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if B [ i ] != B [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def SubString ( str , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT print ( str [ i : i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abcd " NEW_LINE Substring ( str , len ( str ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE n = len ( arr ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and isPrime ( i ) ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 and isPrime ( i ) ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ 1 ▁ = ▁ " , c1 ) NEW_LINE print ( " Number ▁ of ▁ 1 ▁ = ▁ " , c1 ) NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE countPrimePosition ( arr ) NEW_LINE
def angleExtonicccirccircccircccirccirc ( z ) : NEW_LINE INDENT print ( " The ▁ the ▁ triangle ▁ triangle ▁ triangular ▁circcirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirccirc ( ) ) NEW_LINE DEDENT z = 48 NEW_LINE angleExtcirccirccirccirccirccirccirc ( z ) NEW_LINE
def printMinIndexChar ( str , p ) : NEW_LINE INDENT minIndex = len ( str ) NEW_LINE m = len ( p ) NEW_LINE n = len ( p ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( p [ i ] == str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( " Minimum ▁ Character ▁ Character ▁ = ▁ " , str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Character ▁ Character ▁ = " , str [ minIndex ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE p = " set ▁ " NEW_LINE p = " set ▁ " NEW_LINE printMinIndexCharChar ( str , p ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE rl = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( rl ( ) ) NEW_LINE A , B = rl ( ) NEW_LINE if A < B : NEW_LINE INDENT print ( ' T ▁ Won ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Won ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def maxnumber ( n , k ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while ( n // i ) : NEW_LINE INDENT temp = ( n // ( i * 10 ) ) * i + ( n % ( i * 10 ) ) NEW_LINE ans = max ( ans , temp ) NEW_LINE i *= 10 NEW_LINE DEDENT n = ans NEW_LINE DEDENT return n NEW_LINE DEDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE N , M = map ( int , readline ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b = map ( int , readline ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE DEDENT B = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT B . append ( ( i + 1 , 0 ) ) NEW_LINE DEDENT B = [ 0 ] * ( N + 1 ) NEW_LINE B = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT B [ i ] = B [ i ] % N NEW_LINE DEDENT B = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT B [ i ] = B [ i + 1 ] NEW_LINE DEDENT B = [ 0 ] * ( N + 1 ) NEW_LINE B [ 0 ] = B [ 0 ] NEW_LINE B [ 0 ] = B [ 0 ] NEW_LINE B [ 0 ] = B [ 0 ] NEW_LINE B [ 0 ] = B [ 1 ] NEW_LINE B [ 0 ] = B [ 1 ] NEW_LINE B [ 0 ] = B [ 1 ] NEW_LINE B [ 0 ] = B [ 1 ] NEW_LINE B [ 1 ] = B [ 0 ] NEW_LINE B [ 1 ] = B [ 2 ] NEW_LINE B [ 1 ] = B [ 2 ] NEW_LINE B [ 0 ] = B [ 2 ] NEW_LINE B [ 0 ] = B [ 1 ] NEW_LINE B [ 1 ] = B [ 2 ] NEW_LINE B [ 1 ] = B [ 2 ] NEW_LINE B [ 0 ] = B [ 2 ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if B [ i ] == B [ i ] : NEW_LINE INDENT print ( i , i ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] NEW_LINE def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] NEW_LINE def Yes ( ) : print ( ' Yes ' ) NEW_LINE def No ( ) : print ( ' No ' ) NEW_LINE def YES ( ) : print ( ' YES ' ) NEW_LINE def NO ( ) : print ( ' NO ' ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = INT ( ) NEW_LINE A = LIST ( ) NEW_LINE a = A [ 0 ] NEW_LINE b = LIST ( ) NEW_LINE a = LIST ( ) NEW_LINE b = LIST ( ) NEW_LINE ans = min ( ans , a ) NEW_LINE print ( ans ) NEW_LINE
def get_last_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return int ( ans % 100 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 9 ) NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 1 , 10 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , get_last_digit ( N ) ) NEW_LINE DEDENT
def binaryNumber ( binaryNumber ) : NEW_LINE INDENT binaryNumber = "1" NEW_LINE while ( binaryNumber % 2 == 0 ) : NEW_LINE INDENT binaryNumber += 1 NEW_LINE DEDENT return binaryNumber NEW_LINE DEDENT binaryNumber = "1" NEW_LINE print ( binaryNumber ( binaryNumber , 2 ) ) NEW_LINE
def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y NEW_LINE if ( a == 1 and floor ( a * x + y * y ) == 1 and floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT l = 0.006 NEW_LINE m = 0.006 NEW_LINE n = 0.5 NEW_LINE if ( isPossible ( l , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE MOD = 1000000007 NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] % i ) % MOD NEW_LINE result [ i ] = ( ( fact [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] % MOD ) % MOD NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += ( a [ i + 1 ] - a [ i ] ) * ( - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE i = 0 NEW_LINE while ( i < size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ j ] = temp NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size - shift ) NEW_LINE arr [ i ] = - arr [ i ] NEW_LINE j = 0 NEW_LINE for i in range ( shift ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = - arr [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( shift ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT return len ( arr ) NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size - shift ) NEW_LINE arr2 = findMissingPositive ( arr , size - shift ) NEW_LINE j = 0 NEW_LINE for i in range ( shift , size , 1 ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return j + 1 NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 20 ] NEW_LINE arr = [ 0 , 2 , - 10 , - 20 ] NEW_LINE arr = [ 0 , 2 , - 20 , - 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ smallest ▁ positive ▁ number ▁ is " , findMissingPositive ( arr , n ) ) NEW_LINE
mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExplement ( n , d ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] + a [ - 1 ] > a [ n - 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 2 , n ) NEW_LINE DEDENT DEDENT
def convert12 ( s ) : NEW_LINE INDENT h1 = ord ( s [ 0 ] ) - ord ( '0' ) NEW_LINE h2 = ord ( s [ 1 ] ) - ord ( '0' ) NEW_LINE h3 = int ( s [ 1 ] ) NEW_LINE if h1 < 12 : NEW_LINE INDENT SLen = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT SLen = h1 * 10 + h2 NEW_LINE DEDENT if h1 == 0 : NEW_LINE INDENT SLen = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT SLen = " " NEW_LINE DEDENT for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( Str [ i ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT str = " 17 NEW_LINE convert12 ( str ) NEW_LINE convert12 ( str ) NEW_LINE
def check ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == b [ 0 ] and b [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " xxa " NEW_LINE b = " xxaxa " NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE DEDENT
def printkapack ( W , wt , n ) : NEW_LINE INDENT i = 0 NEW_LINE W = [ 0 for i in range ( W + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or wt == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif wt == 0 : NEW_LINE INDENT K [ i ] [ wt ] = 0 NEW_LINE DEDENT elif wt <= wt : NEW_LINE INDENT K [ i ] [ wt ] = max ( k [ i - 1 ] [ wt ] + K [ i - wt ] [ wt ] , K [ i - 1 ] [ wt ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ wt ] = K [ i - 1 ] [ wt ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] NEW_LINE W = W [ : ] NEW_LINE W . append ( W [ W ] ) NEW_LINE W . append ( W [ W ] ) NEW_LINE W . append ( W [ W [ W ] ] ) NEW_LINE W . append ( W [ W [ W [ W ] ] ) NEW_LINE W . append ( W [ W [ W [ W [ W [ W [ W [ W [ W ] ] ] ] ) NEW_LINE DEDENT res = K [ W [ W [ W [ W [ W [ W [ W [ W ] ] ] ] ] NEW_LINE printkapack ( W , W , val , wt ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == a [ i ] [ 1 ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
def indexedSequence ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 ] * 20 NEW_LINE index = 0 NEW_LINE ind = 0 NEW_LINE end = 0 NEW_LINE ind = 0 NEW_LINE end = 0 NEW_LINE end = 0 NEW_LINE while ( ind < end ) : NEW_LINE INDENT elements [ ind ] = arr [ ind ] NEW_LINE ind += 1 NEW_LINE DEDENT if ( k < elements [ 0 ] ) : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( k < elements [ 0 ] ) : NEW_LINE INDENT print ( " Found ▁ found " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( k == arr [ i ] ) : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 1 ) : NEW_LINE INDENT print ( " Found " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Found " ) NEW_LINE DEDENT DEDENT DEDENT n = len ( arr ) NEW_LINE n = len ( n ) NEW_LINE k = 8 NEW_LINE index = 8 NEW_LINE k = 8 NEW_LINE indexedSequence ( arr , n , k ) NEW_LINE
def larrangPalindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit = i * 10 NEW_LINE upper_limit + 9 NEW_LINE upper_limit += 9 NEW_LINE DEDENT low_limit = 1 + upper_limit // 10 NEW_LINE max_val = 0 NEW_LINE for i in range ( upper_limit , low , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , low , low , - 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if ( product < max_val and product < max_val ) : NEW_LINE INDENT break NEW_LINE DEDENT number = i NEW_LINE DEDENT number = base NEW_LINE DEDENT return max_val NEW_LINE DEDENT n = 2 NEW_LINE print ( larrangPalindrome ( n ) ) NEW_LINE
import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE i = bisect . bisect_left ( a , a [ 0 ] ) NEW_LINE print ( i ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b == c : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a == c and b > 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif a == c and b > 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif a == c and b > 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans = max ( ans , sum ( a [ i : i + 1 ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def maximumXor ( arr , n ) : NEW_LINE INDENT sForward = [ ] NEW_LINE sForward = [ ] NEW_LINE sForward = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while len ( sForward [ i ] < arr [ - 1 ] [ 0 ] ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] [ 1 ] ^ arr [ sForward [ - 1 ] [ 1 ] ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE sForward . pop ( - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 8 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumXor ( arr , n ) ) NEW_LINE
def decToHex ( n ) : NEW_LINE INDENT hexaDecimalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexa [ i ] = temp + 48 ; NEW_LINE i += 1 ; NEW_LINE DEDENT n = n // 16 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexa [ i ] , end = " " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexa [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 2545 ; NEW_LINE decToHex ( n ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , b [ i ] + b [ i + 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : break NEW_LINE s = input ( ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " _ " : NEW_LINE INDENT w = s . split ( ) NEW_LINE DEDENT else : NEW_LINE INDENT w = s . split ( ) NEW_LINE s = s . split ( ) NEW_LINE w = s . pop ( 0 ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( c ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == " _ " : NEW_LINE INDENT w = s [ i ] . pop ( 0 ) NEW_LINE ans += abs ( w - i ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( " Hello ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " door ▁ " ) NEW_LINE DEDENT
def extractMaximum ( s ) : NEW_LINE INDENT num = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE num = 0 NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "1005klklabc " NEW_LINE print ( extractMaximum ( string ) ) NEW_LINE DEDENT
max = 500099 NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * max ; NEW_LINE index_1 = - 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT ans = - ( 1e15 ) ; NEW_LINE index_2 = - 1 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT index_1 = 0 ; NEW_LINE v = 0 ; NEW_LINE v = ( 1e15 ) ; NEW_LINE for r in range ( l , n + 1 ) : NEW_LINE INDENT if ( sum [ r ] < v ) : NEW_LINE INDENT v = sum [ r ] ; NEW_LINE index_2 = r ; NEW_LINE index_1 = r ; NEW_LINE DEDENT if ( sum [ l ] + v ) : NEW_LINE INDENT ans = sum [ r ] + sum [ r ] ; NEW_LINE index_2 = i ; NEW_LINE index_2 = i ; NEW_LINE DEDENT DEDENT DEDENT print ( index_1 , index_2 , " ▁ " , index_3 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE find_Indices ( arr , n ) ; NEW_LINE DEDENT
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 3 , 1 , 5 , 4 , 4 , 5 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printElements ( arr , n ) NEW_LINE
def valueofX ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return sum / n NEW_LINE DEDENT else : NEW_LINE INDENT A = sum / n + 1 NEW_LINE B = sum / n + 1 NEW_LINE DEDENT if ( value < B ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT A = sum / n + 1 NEW_LINE B = sum / n + 1 NEW_LINE DEDENT DEDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 1 , 1 , 3 , 7 , 7 ] NEW_LINE print ( valueofX ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT b . append ( bin ( i ) [ 2 : ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( i & ( 1 << i ) ) : NEW_LINE INDENT ans += ( n - i ) // ( 1 << i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE l = len ( s ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if s [ i ] != s [ i ] : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in range ( 20 , - 1 , 9 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , - 9 , - 9 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( findNth ( 5 ) ) NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in range ( 1 , 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 0 , - 1 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( findNth ( 5 ) ) NEW_LINE DEDENT
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 NEW_LINE currSum = 0 NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N NEW_LINE N -= 1 NEW_LINE countElements += 1 NEW_LINE N -= 1 NEW_LINE DEDENT return countElements NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE S = 11 NEW_LINE count = countNumber ( N , S ) NEW_LINE print ( count ) NEW_LINE DEDENT
def stringmatch ( str , pattern , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ i - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j - 1 ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE lookup [ i ] [ j - 1 ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT elif ( pattern [ i - 1 ] == pattern [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT str = " bbaab " NEW_LINE pattern = " * * * * * abab " NEW_LINE if ( str [ pattern [ pattern [ pattern [ pattern [ i ] ] ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE from itertools import combinations NEW_LINE from math import log NEW_LINE def sieve_of_erast ( n ) : NEW_LINE INDENT sieve = [ True ] * ( n + 1 ) NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT sieve [ 0 ] = False NEW_LINE sieve [ 1 ] = False NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT sieve [ 2 ] = False NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT sieve [ 2 * i ] = False NEW_LINE DEDENT sieve [ 2 * i ] = False NEW_LINE DEDENT def solve ( a , b ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT b //= i NEW_LINE break NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT b -= 1 NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE b -= 1 NEW_LINE while b % 2 == 0 : NEW_LINE INDENT a //= 2 NEW_LINE DEDENT b //= 2 NEW_LINE DEDENT print ( solve ( a , b ) ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT fac = [ 0 ] * ( 100 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT fac [ i ] = 1 NEW_LINE DEDENT ans = fac [ n ] // ( fac [ n - r ] * fac [ r ] ) NEW_LINE ans = ( fac [ n ] * fac [ r ] ) + nCr ( k - 1 , n - 1 ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ - 1 ] , a [ - 1 ] ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 5 NEW_LINE n = 2 NEW_LINE print ( powGCD ( a , n , b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] == a [ i ] : NEW_LINE INDENT b [ i ] , b [ i ] = a [ i ] , a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] , b [ i ] = b [ i ] , a [ i ] NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == '8' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sumDigit += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 50 NEW_LINE b = 2 NEW_LINE print ( sumOfDigit ( n , b ) ) NEW_LINE
def printLargestDivisible ( n , a ) : NEW_LINE INDENT c0 , c0 , c5 = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT DEDENT c5 = math . floor ( c5 / 9 ) * 9 NEW_LINE if ( c0 == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif ( c0 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 5 , end = " " ) NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE printLargestDivisible ( n , a ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 NEW_LINE Min = ( ( S - S1 ) // floor ) * 60 NEW_LINE return Min NEW_LINE DEDENT S = 30 NEW_LINE s1 = 10 NEW_LINE print ( numberOfMinutes ( S , S1 ) , " min " ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n < k : NEW_LINE INDENT print ( a [ - 1 ] - a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
import math NEW_LINE def onesComplement ( n ) : NEW_LINE INDENT number_of_bits ( n ) NEW_LINE return ( ( 1 << math . log_bits ( n ) ) + 1 ) NEW_LINE DEDENT n = 22 NEW_LINE print ( onesComplement ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE while h % 2 == 0 : NEW_LINE INDENT w //= 2 NEW_LINE DEDENT if w % 2 == 0 : NEW_LINE INDENT h //= 2 NEW_LINE DEDENT if h >= w : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( ( ( 2 * x2 - x1 ) , ( 2 * y2 - y1 ) , " ) " ) NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE y2 = 1 NEW_LINE findPoint ( x1 , y1 , x2 , y2 ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a % 2 == 0 ) : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT print ( m - ( m % 3 == 0 ) + 1 ) NEW_LINE DEDENT
def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = " , x , " , ▁ Y ▁ = " , y ) NEW_LINE DEDENT x = 12 NEW_LINE y = 5 NEW_LINE alter ( x , y ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if b [ j ] - b [ i ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( i , n ) : NEW_LINE INDENT if b [ k ] - b [ k ] > b [ i ] : NEW_LINE INDENT ans = max ( ans , ans ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = s [ : n ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT print ( i + 1 , i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 , - 1 ) NEW_LINE DEDENT DEDENT
mod2 = 1000000007 NEW_LINE mod2 = 50000007 NEW_LINE def modulo ( num ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + ord ( num [ i ] ) - ord ( '0' ) ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a , b , r = modulo ( L ) NEW_LINE l , r = modulo ( R ) NEW_LINE l = modulo ( R * ( a - 1 ) ) % mod NEW_LINE r = ( ( b * ( a - 1 ) ) % mod NEW_LINE if ( r < 0 ) : NEW_LINE INDENT return r NEW_LINE DEDENT else : NEW_LINE INDENT return r % mod NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = "89472142" NEW_LINE R = 998244353 NEW_LINE print ( findSum ( L , R ) ) NEW_LINE DEDENT
def unsorted ( l , r , a , k ) : NEW_LINE INDENT if ( k < 1 or l + 1 == r ) : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE a [ mid - 1 ] = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid - 1 ] NEW_LINE return NEW_LINE DEDENT def arrayWithCircitions ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a [ 0 ] = 1 NEW_LINE a [ 0 ] = 1 NEW_LINE a [ 0 ] = 1 NEW_LINE dissorted ( 0 , n , a , k ) NEW_LINE DEDENT def arrayWithCircitions ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a [ 0 ] = 1 NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 17 NEW_LINE array = [ 0 ] * n NEW_LINE k = 17 NEW_LINE generateTransitions ( n , k ) NEW_LINE
def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 ; freqSum = 0 ; NEW_LINE freqSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + mid * freq [ i ] * freq [ i ] ; NEW_LINE freqSum = freqSum + freq [ i ] ; NEW_LINE DEDENT return sum / freqSum ; NEW_LINE DEDENT def partition ( low , high , freq , freq , n ) : NEW_LINE INDENT mid = [ 10 , 0 , 0 , 0 ] ; NEW_LINE freqSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mid [ i ] = ( low [ i ] + freq [ i ] * freq [ i ] * mid [ i ] ) ; NEW_LINE sum = sum + freqSum ; NEW_LINE freqSum = freqSum + freq [ i ] * mid [ i ] ; NEW_LINE freqSum = freqSum + freqSum ; NEW_LINE DEDENT DEDENT low , high = [ 70 , 71 , 72 , 84 , 84 , 91 , 98 ] ; NEW_LINE n = len ( low ) ; NEW_LINE print ( grouped ( low - high ) ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE
def rectanglearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n < a * b : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def getJumps ( x ) : NEW_LINE INDENT return ( x * ( x + 1 ) ) // 2 NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( ans < n or ( splits ( ans ) - n ) & 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE
MAX = 10 ** 9 NEW_LINE def lcs ( dp , arr1 , arr2 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( n < 0 or m < 0 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = dp [ n ] [ m ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , arr2 , k ) , lcs ( dp , arr2 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 5 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr1 ) NEW_LINE dp = [ [ 5 , 3 , 1 , 4 , 4 , 5 ] , 2 NEW_LINE dp [ 0 ] [ 0 ] ] = - 1 NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE dp [ n ] [ 0 ] = - 1 NEW_LINE dp ( dp1 , arr2 , n , arr2 , n , arr2 , n , m , arr2 , n , arr2 , m , k ) NEW_LINE k = len ( dp , arr1 , n , arr2 , m , k ) NEW_LINE print ( lcs ( dp , arr1 , n , arr2 , n ,
N , D , x = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while N > 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while N > 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( i ) NEW_LINE
def reverse ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT i = i ; NEW_LINE while ( i >= 2 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT i -= 1 ; NEW_LINE DEDENT DEDENT N = 25 ; NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ reversed ▁ range ▁ reversed ( N ) ) ; NEW_LINE
def pattern ( min_oper , p_w ) : NEW_LINE INDENT p_space = p_space - 1 NEW_LINE x = 1 NEW_LINE for i in range ( p_space - 1 , i ) : NEW_LINE INDENT for j in range ( p_space , i - 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( min_space + p_space - 2 , x ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for k in range ( min_space + p_space - 2 , x ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT min_oper = min_oper + 2 NEW_LINE x = x + 2 NEW_LINE x = x + 2 NEW_LINE print ( " " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT min_oper = 1 NEW_LINE p_ch = 5 NEW_LINE p_ch = 5 NEW_LINE pattern ( min_oper , p_ch ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , a , b = map ( str , input ( ) . split ( ) ) NEW_LINE if a == " M " : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif b == " M " : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c * 2 ) NEW_LINE
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( ( ( 1 + sqrt ( 5 ) ) ) / 2 ) NEW_LINE DEDENT def calculateFibonacci ( k ) : NEW_LINE INDENT sum = fib ( k * ( k - 1 ) ) / 2 NEW_LINE return int ( sum ) NEW_LINE DEDENT def calculateFibonacci ( k ) : NEW_LINE INDENT l = ( k * ( k - 1 ) ) / 2 NEW_LINE r = l + k NEW_LINE sum = calculateFibonacci ( l , r ) NEW_LINE return sum NEW_LINE DEDENT k = 3 NEW_LINE print ( sumFibonacci ( k ) ) NEW_LINE
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 4 , 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 + sqrt ( 5 ) ) ) / 2 NEW_LINE return int ( round ( ( r + 2 ) , n ) / math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) / sqrt ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 4 , 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE s [ l - 1 ] , s [ r - 1 ] , s [ l - 1 ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE s [ l - 1 ] , s [ r - 1 ] = s [ r - 1 ] , s [ l - 1 ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT b , c = map ( str , input ( ) . split ( ) ) NEW_LINE if b == s [ i ] : NEW_LINE INDENT s [ i ] , s [ i - 1 ] = s [ i - 1 ] , s [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT s [ i - 1 ] , s [ i - 1 ] = s [ i - 1 ] , s [ i - 1 ] NEW_LINE DEDENT DEDENT print ( s [ : q - 1 ] ) NEW_LINE
def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def searchStrings ( arr , str1 , str2 , start , last ) : NEW_LINE INDENT if ( str1 [ start ] > str2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + 1 ) // 2 NEW_LINE if ( arr [ mid ] == ' ' ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT mid = mid + 1 NEW_LINE DEDENT DEDENT if ( arr [ start ] == ' ' ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( compareStrings ( str1 , str1 , str2 , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' , ' ,
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = str ( a ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( a + str ( b ) ) NEW_LINE break NEW_LINE DEDENT DEDENT
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE y3 , x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE y3 , x3 , y3 = x1 + y2 , y3 + y3 NEW_LINE print ( 3 , 3 , 1 , 2 ) NEW_LINE print ( 3 , 3 ) NEW_LINE print ( 3 , 3 ) NEW_LINE print ( 3 ) NEW_LINE for i in range ( x3 ) : NEW_LINE INDENT print ( x1 + x3 , x3 + y3 ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != s [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n //= d NEW_LINE return ( n * ( 1 + n ) * ( 1 + n ) * d / 2 ) NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 5 ) NEW_LINE DEDENT n = 20 NEW_LINE print ( sumMultiples ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l1 = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l1 . append ( a ) NEW_LINE DEDENT l1 . sort ( ) NEW_LINE l2 = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if l1 [ j ] - l1 [ j ] > l2 [ j ] : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT DEDENT
def fact ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while num > 1 : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return ( 2 * n ) // ( fact ( n ) * fact ( n - s ) ) NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE catalan ( n ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < arr [ k ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT catalan ( s ) NEW_LINE DEDENT print ( totalBalan ( s ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - b == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a - b == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT DEDENT
def countWays ( n , arr , len ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( len ( arr [ j ] ) ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 ] NEW_LINE len = len ( arr ) NEW_LINE print ( countWays ( n , arr , len ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT a [ j ] += a [ j ] NEW_LINE DEDENT b . sort ( ) NEW_LINE if a [ 0 ] >= n : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE s = abs ( a - b ) NEW_LINE s = abs ( c - a ) NEW_LINE if s == s : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif s == s : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT elif s == s : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
n , d , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] <= d : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = 0 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( k > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , low + 1 , ( mid - 1 ) , high , key ) NEW_LINE DEDENT if ( k > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , ( mid - 1 ) , high , key ) NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE key = 10 NEW_LINE print ( " Index : ▁ " , binarySearch ( arr , 0 , n , key ) ) NEW_LINE
def equal_xor ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor ^= arr [ i ] NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE equal_xor ( arr , n ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT k = a . copy ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( a [ i ] in k ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 NEW_LINE cntEven = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT DEDENT evenPairs = 0 NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) // 2 NEW_LINE oddPairs += ( cntEven * ( cntEven - 1 ) ) // 2 NEW_LINE oddPairs += ( cntEven * ( cntEven - 1 ) ) // 2 NEW_LINE oddPairs += ( cntEven * cntEven - 1 ) // 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findPairs ( arr , n ) NEW_LINE
def minBinaryRangeRange ( H , K ) : NEW_LINE INDENT n = len ( H ) NEW_LINE lefttowers = [ ] NEW_LINE righttowers = [ ] NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while j < n : NEW_LINE INDENT if H [ j ] < righttowers [ j ] : NEW_LINE INDENT left = H [ j ] - lefttowers [ j ] NEW_LINE right = righttowers [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lefttowers [ k ] = righttowers [ k ] - lefttowers [ j ] NEW_LINE right = MAX NEW_LINE DEDENT if left < right : NEW_LINE INDENT min_range = left NEW_LINE DEDENT else : NEW_LINE INDENT righttowers [ k ] = righttowers [ k ] NEW_LINE DEDENT DEDENT return min_range NEW_LINE DEDENT a = [ 12 , 13 , 11 , 15 ] NEW_LINE b = [ 4 , 6 , 15 , 60 ] NEW_LINE max_range = 10 NEW_LINE min_range = 10 NEW_LINE print ( minBinaryRangeRange ( a , b ) ) NEW_LINE
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor ( num // divisor ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( getRemainder ( 100 , 7 ) ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE z = 0 NEW_LINE for i in range ( a , b + 1 , 0 , - 1 ) : NEW_LINE INDENT for j in range ( i * b + 1 , 0 , - 1 ) : NEW_LINE INDENT if i * j == a : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT DEDENT print ( z ) NEW_LINE
while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE a = [ int ( input ( ) ) for _ in range ( m ) ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += int ( input ( ) ) NEW_LINE if s > a [ i ] : s += 1 NEW_LINE DEDENT print ( max ( s , ( a [ i ] + s ) ) ) NEW_LINE DEDENT
N , W = map ( int , input ( ) . split ( ) ) NEW_LINE vw = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT v , w = map ( int , input ( ) . split ( ) ) NEW_LINE vw . append ( v , w ) NEW_LINE DEDENT v = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE vw . append ( v ) NEW_LINE DEDENT v = w NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += vw [ i ] * vw [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twbit = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twbit = ones & ( onesbit ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE twobit = ~ ( ones & arr [ i ] ) NEW_LINE DEDENT return twbit NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ is ▁ " , getSingle ( arr , n ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ j ] and arr [ i ] > arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ j ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ j ] and arr [ i ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ j ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ j ] and arr [ i ] ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 1 , 3 , 3 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxDiff ( arr , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT print ( a [ 0 ] - a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - a [ 0 ] ) NEW_LINE DEDENT DEDENT
def makeAP ( arr , n ) : NEW_LINE INDENT first_term = arr [ 2 ] - arr [ 1 ] NEW_LINE common_term = arr [ 2 ] - arr [ 1 ] NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_term = arr [ 2 ] - arr [ 1 ] NEW_LINE common_term = arr [ 2 ] - common_term NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 2 ] ) == ( arr [ 2 ] - arr [ 0 ] ) ) : NEW_LINE INDENT common_term = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 2 ] - arr [ 0 ] ) ) : NEW_LINE INDENT common_term = ( arr [ 3 ] - arr [ 0 ] ) // 3 NEW_LINE DEDENT else : NEW_LINE INDENT common_term = ( arr [ 3 ] - arr [ 0 ] ) // 3 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( first_term + ( i * common_term ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE x = 1 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( y + x ) % ( y ^ x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE x = 1 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( y * x + x ) % ( y + x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 15 NEW_LINE print ( countPairs ( n ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT count = 0 NEW_LINE for c in s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v // 2 * 2 NEW_LINE if ( ans % 2 == 1 and v % 2 == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " abccdddddd " NEW_LINE out = sObj . longestPalindrome ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res // ( n + 1 ) NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n ) NEW_LINE return catalan ( n // 2 ) NEW_LINE DEDENT n = 6 NEW_LINE print ( " Total ▁ possible ▁ of ▁ length ▁ of ▁ length ▁ is " , findWays ( 6 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT p = [ ] NEW_LINE for j in range ( 12 ) : NEW_LINE INDENT for k in range ( 12 ) : NEW_LINE INDENT if s [ k ] == ' X ' : NEW_LINE INDENT p . append ( 1 ) NEW_LINE DEDENT DEDENT p = [ ] NEW_LINE for j in range ( 12 ) : NEW_LINE INDENT for k in range ( 12 ) : NEW_LINE INDENT p [ j ] = '1' NEW_LINE DEDENT for j in range ( 12 ) : NEW_LINE INDENT p [ j ] = '1' NEW_LINE DEDENT DEDENT for j in range ( 12 ) : NEW_LINE INDENT for k in range ( 12 ) : NEW_LINE INDENT for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 ) : NEW_LINE INDENT if p [ j ] [ i ] == ' X ' : NEW_LINE INDENT p [ j ] [ i ] = '1' NEW_LINE DEDENT p [ j ] [ i ] = '1' NEW_LINE DEDENT p [ j ] [ i ] = '1' NEW_LINE DEDENT DEDENT DEDENT p = [ ] NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 ) : NEW_LINE INDENT for k in range ( 12 ) : NEW_LINE INDENT for l in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 ) : NEW_LINE INDENT for k in range ( 12 ) : NEW_LINE INDENT p [ j ] [ i ] = '1' NEW_LINE DEDENT p [ j ] [ i ] = '1' NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT p = p [ 12 ] NEW_LINE p = [ 12 , 12 , 12 ] NEW_LINE p . append ( '0' ) NEW_LINE p . append ( '1' ) NEW_LINE p . append ( '1' ) NEW_LINE p . append ( '0' ) NEW_LINE
n , t , a , b , t = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i * a + j * b == a * b : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' NO ' ) NEW_LINE
def isSumOfPowers ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if ( isSumOfPowers ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT s = [ i ] NEW_LINE result += 1 NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT tp = [ ] NEW_LINE for j in range ( tp % 10 + 1 , 10 ) : NEW_LINE INDENT tp . append ( tp * 10 + j ) NEW_LINE DEDENT if ( x <= n ) : NEW_LINE INDENT s . append ( tp ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ i ] = dp [ i - 1 ] [ i - 1 ] + cost [ i ] [ i ] NEW_LINE DEDENT return dp [ N - 1 ] [ N - 1 ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 9 ] , [ 7 , 3 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE
MAX_Prime = 1000000 NEW_LINE sieve_Prime = [ 0 ] * MAX_LINE sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX_Prime + 4 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX_Prime [ j ] , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_Prime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sieve_prime [ n ] = 2 NEW_LINE n = 2 NEW_LINE print ( " Count ▁ = " , sieve_prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_prime [ n ] + 1 ) NEW_LINE DEDENT
n , k , v , u , v , v = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] = min ( d [ i ] , u + v * v ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] == i : NEW_LINE INDENT ans += ( d [ i ] - u ) // v NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( d [ i ] - u ) / v NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = [ 0 ] * ( ord ( i - 1 ) ) NEW_LINE if ( i - 1 >= 0 ) : NEW_LINE INDENT prefix [ i ] = ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev + ( ord ( s [ i - 1 ] ) ) NEW_LINE DEDENT suffix [ i ] = prev + ( ord ( s [ i ] ) - ord ( ' a ' ) ) NEW_LINE DEDENT suffix = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT suffix [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT suffix [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT suffix [ ord ( s [ i ] ) - ord ( ' a ' ) ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT s = " ababa " NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT TARGET = 15 NEW_LINE ways = [ [ 0 for i in range ( TENGTH + 1 ) ] for i in range ( TENGTH + 1 ) ] NEW_LINE ways [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , TENGTH + 1 ) : NEW_LINE INDENT ways [ i ] [ i ] = ways [ i - 1 ] [ i ] + ways [ i - 1 ] [ i - 1 ] NEW_LINE DEDENT ans = factorial ( ways [ - 1 ] [ i ] ) // ( TARGET + 1 ) NEW_LINE return factorial ( ans ) // factorial ( TARGET + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if B [ i ] == 1 : NEW_LINE INDENT ans [ i ] = i NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if B [ i ] == 1 : NEW_LINE INDENT ans [ i ] = i NEW_LINE DEDENT DEDENT print ( i , bisect . bisect_left ( A , i ) ) NEW_LINE return NEW_LINE DEDENT main ( ) NEW_LINE
def merge ( m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = arr [ m - 1 ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT last = arr [ j ] NEW_LINE j = m - 2 NEW_LINE while j >= 0 and j >= 0 : NEW_LINE INDENT arr [ j ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if j != m - 2 or last > arr [ i ] : NEW_LINE INDENT arr [ j + 1 ] , arr [ i ] = arr [ i ] , arr [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if j != m - 2 or last > arr [ i ] : NEW_LINE INDENT arr [ j + 1 ] , arr [ i ] = last NEW_LINE DEDENT DEDENT DEDENT if len ( arr ) > 0 or len ( arr ) > 0 : NEW_LINE INDENT print ( " First ▁ First ▁ : ▁ " , end = " " ) NEW_LINE DEDENT print ( " Second ▁ : ▁ " , end = " " ) NEW_LINE print ( " \n First ▁ : ▁ " , end = " " ) NEW_LINE print ( " \n First ▁ : ▁ " , end = " " ) NEW_LINE print ( " \n First ▁ : ▁ " , end = " " ) NEW_LINE print ( " \n First ▁ : ▁ " , end = " " ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 15 , 15 , 20 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " First ▁ : ▁ " , end = " ) NEW_LINE print ( " First ▁ : ▁ " , end = " ) NEW_LINE print ( " \n First ▁ : ▁ " ) NEW_LINE print ( " ) NEW_LINE print ( " Second ▁ : ▁ " , end = " ) NEW_LINE print ( " ) NEW_LINE print ( " \n First ▁ : ▁ " ) NEW_LINE print ( " \n Second : NEW
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return gcd ( a1 , c1 ) NEW_LINE DEDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 243 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if a + b + c <= d : NEW_LINE INDENT ans += d NEW_LINE DEDENT else : NEW_LINE INDENT ans += d NEW_LINE DEDENT print ( ans ) NEW_LINE
dp = [ [ 0 for i in range ( 51 ) ] for j in range ( 51 ) ] NEW_LINE def countWays ( n , splits , start , gap ) : NEW_LINE INDENT if ( splits == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ start ] [ start ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ splits ] NEW_LINE DEDENT if ( dp [ start ] [ start ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ splits ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( start , n + 1 ) : NEW_LINE INDENT ans += countWays ( n - i , splits - 1 , i , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 5001 , n + 1 ) : NEW_LINE INDENT for j in range ( 5001 , 5 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT return ( dp [ n ] [ splits ] [ j ] ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n , 4 , 1 ) ) NEW_LINE
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( a + b ) // 2 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = 2 NEW_LINE b = 16 NEW_LINE print ( find_k ( a , b ) ) NEW_LINE
N = 101 NEW_LINE mod = 1000000007 + 7 NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE exactnum = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( X + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( y + 1 ) : NEW_LINE INDENT for k in range ( y + 1 ) : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT for k in range ( y ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT finalnum [ i - 1 ] [ k ] += ( exactnum [ i - 1 ] [ k - 1 ] * 10 + 4 * exactnum [ i - 1 ] [ k - 1 ] ) NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactnum [ i ] [ k ] += ( exactnum [ i - 1 ] [ k - 1 ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT if ( j > 0 ) : NEW_LINE INDENT exactnum [ i ] [ j ] += ( exactnum [ i - 1 ] [ k - 1 ] * 10 + exactnum [ i - 1 ] [ k - 1 ] ) NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactnum [ i ] [ j ] += exactnum [ i - 1 ] [ k - 1 ] NEW_LINE exactnum [ i ] [ j - 1 ] %= mod NEW_LINE DEDENT DEDENT DEDENT DEDENT ans += exactnum [ i ] [ j ] NEW_LINE DEDENT return ans NEW_LINE DEDENT x , y , z = 1 , 1 NEW_LINE print ( getSum ( x , y , z ) % mod ) NEW_LINE
CHARS = 26 NEW_LINE CHARS = 26 NEW_LINE def isValidString ( string ) : NEW_LINE INDENT freq = [ 0 for i in range ( CHARS ) ] NEW_LINE freq1 = 0 NEW_LINE freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT freq1 [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE freq1 [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE for i in range ( j + 1 , CHARS ) : NEW_LINE INDENT if freq1 [ j ] != 0 : NEW_LINE INDENT if freq1 [ j ] == freq1 [ i ] : NEW_LINE INDENT freq2 += 1 NEW_LINE freq2 [ j ] = freq2 [ j ] NEW_LINE freq2 [ j ] = freq2 [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT freq2 [ j ] = freq2 [ j ] NEW_LINE freq2 [ j ] = freq2 [ j ] NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CH1 ) : NEW_LINE INDENT if freq1 [ k ] == freq2 [ k ] : NEW_LINE INDENT count_freq2 [ k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abcbc " NEW_LINE if isValidString ( string ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if ( s [ 0 ] == ' a ' ) : NEW_LINE INDENT print ( s [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT DEDENT
def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfBits = 1 NEW_LINE sizeOfBits = len ( A ) NEW_LINE inf = float ( ' inf ' ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( size ) : NEW_LINE INDENT next = ord ( A [ i ] ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT next = ord ( A [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( size - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( next == 0 and j == i ) : NEW_LINE INDENT next = - 1 NEW_LINE DEDENT elif ( next == 0 and j + 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE DEDENT elif ( next == 0 and next + 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE DEDENT elif ( next == 0 and next + 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE DEDENT elif ( next < len ( A ) and next + 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = " aaab " NEW_LINE B = " abcab " NEW_LINE print ( findMinimumSubsequences ( A , B ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if a [ 0 ] [ j ] - a [ 0 ] [ j ] > a [ 0 ] [ j - 1 ] : NEW_LINE INDENT a [ 0 ] [ j ] = a [ 0 ] [ j - 1 ] + a [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] - a [ i ] [ k ] > a [ j ] [ k ] + a [ i ] [ j ] : NEW_LINE INDENT a [ i ] [ j ] = a [ i ] [ k ] + a [ j ] [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( * a ) NEW_LINE DEDENT
def FindRank ( arr , length ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 88 , 14 , 71 , 30 , 29 , 29 , 89 ] NEW_LINE length = len ( arr ) NEW_LINE FindRank ( arr , length ) NEW_LINE DEDENT
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( b ) NEW_LINE b . append ( a ) NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] [ 0 ] >= h : NEW_LINE INDENT ans = min ( ans , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product / pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product / 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT m , n = map ( int , line . split ( ) ) NEW_LINE if n < m : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT m = n NEW_LINE while m : NEW_LINE INDENT m , n = m , m NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE DEDENT
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' a ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def complement ( num ) : NEW_LINE INDENT i = 0 NEW_LINE len = 0 NEW_LINE temp = num NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 NEW_LINE num = int ( num / 10 ) NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT num = temp NEW_LINE return num NEW_LINE DEDENT print ( complement ( 25 ) ) NEW_LINE print ( complement ( 456 ) ) NEW_LINE
def countUnsetBits ( n ) : NEW_LINE INDENT x = n | ( n >> 1 ) NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 16 NEW_LINE n |= n >> 16 NEW_LINE n |= n >> 16 NEW_LINE return int ( int ( x ^ n ) ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE
def minOperations ( arr , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE freq = [ 0 for i in range ( 100001 ) ] NEW_LINE freq [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE dp [ 1 ] [ 0 ] = ( M - 2 ) + dp [ 0 ] [ 1 ] NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( b // c ) * c NEW_LINE return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 4 NEW_LINE print ( getMinNum ( a , b , c ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT DEDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT max = max NEW_LINE DEDENT DEDENT print ( max ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : break NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( ( a , b ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if m - i [ 1 ] <= l [ i [ 0 ] ] : NEW_LINE INDENT ans += m * i [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += m * i [ 0 ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from collections import deque NEW_LINE from heapq import heappop , heappush NEW_LINE import math NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return list ( map ( list , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def LS ( ) : return list ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) . split ( ) ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE inf = float ( ' inf ' ) NEW_LINE mod = 1000000007 NEW_LINE n = I ( ) NEW_LINE a = LI ( ) NEW_LINE b = LI ( ) NEW_LINE a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE a . reverse ( ) NEW_LINE b . reverse ( ) NEW_LINE a . reverse ( ) NEW_LINE a . reverse ( ) NEW_LINE a . reverse ( ) NEW_LINE b . reverse ( ) NEW_LINE a . reverse ( ) NEW_LINE a . reverse ( ) NEW_LINE b . reverse ( ) NEW_LINE ans = max ( ans , a [ : n ] ) NEW_LINE print ( ans ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE count [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , len ( arr [ j ] ) ) : NEW_LINE INDENT if i >= arr [ j ] : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] ; NEW_LINE DEDENT DEDENT DEDENT return count [ N ] ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 ; NEW_LINE print ( " Total ▁ number ▁ = ▁ " , countWays ( N ) ) ; NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 1 ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def countFreq ( a , n ) : NEW_LINE INDENT hm = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] != 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE DEDENT
def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False NEW_LINE possibleInRange = ( R - L + 1 ) NEW_LINE possibleInRange = ( R - L + 1 ) NEW_LINE numberInRange = ( R - L + 1 ) NEW_LINE if ( numberInRange < 3 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT elif ( numberInRange < 3 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( L % 2 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( " No ▁ Triple ▁ triplet ▁ is ▁ triplet ▁ and ▁ triplet ▁ triplet ▁ and ▁ triplet ▁ is " , L , R ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Triple ▁ is ▁ Triplet ▁ triplet ▁ is ▁ triplet ▁ is ▁ triplet ▁ " , L , R , " and ▁ triplet ▁ triplet ▁ is " , R ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Triplet ▁ Triplet ▁ Triplet ▁ is ▁ Triplet ▁ is ▁ Triplet ▁ and ▁ Triplet ▁ and ▁ Triplet ▁ " , L , R ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 10 NEW_LINE possibleTripletInRange ( L , R ) NEW_LINE L = 23 NEW_LINE R = 46 NEW_LINE possibleTripletInRange ( L , R ) NEW_LINE DEDENT
def convert ( char , s ) : NEW_LINE INDENT s2 = " abcdefghijklmnopqrstuvwxyz " NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 += a [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT return s2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT charSet = " ewertyuiopqr " NEW_LINE str1 = " ewertyuiopqr " NEW_LINE print ( convert ( charSet ( charSet , s1 ) ) ) NEW_LINE DEDENT
def generateNumber ( k , a , n , k ) : NEW_LINE INDENT global set , NEW_LINE if ( k == k ) : NEW_LINE INDENT set . add ( num ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT generateNumber ( i + 1 , a , n , a , n , k ) ; NEW_LINE addNumber ( i + 1 , a , n , k ) ; NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) ; NEW_LINE print ( " The ▁ number ▁ of ▁ integer ▁ : ▁ " , end = " " ) ; NEW_LINE print ( " The ▁ distinct ▁ : ▁ " , end = " " ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 8 , 17 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE printDistinctIntegers ( k , arr , n ) ; NEW_LINE DEDENT
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT prod *= int ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT b = r NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = ord ( b [ i ] ) - 1 NEW_LINE curr = ord ( '0' ) + ord ( '0' ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr = ord ( '9' ) NEW_LINE curr = ord ( curr ) - 1 NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr = ord ( '9' ) NEW_LINE DEDENT curr = ord ( curr ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr = ord ( '0' ) NEW_LINE DEDENT if ( num >= l and product ( curr ) < product ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE l = 51 NEW_LINE r = 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE
MAX = 100005 NEW_LINE def sieveOfEratosthenes ( n ) : NEW_LINE INDENT isPrime [ 1 ] = True NEW_LINE for i in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def findNumber ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime [ num ] ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return num NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sieveOfEratosthenes ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( not isPrime [ sum ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT
MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 for i in range ( MAX ) ] NEW_LINE max_bit = [ 0 for i in range ( MAX ) ] NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT DEDENT for d in bits_count : NEW_LINE INDENT temp = pow ( 2 , d ) NEW_LINE if ( bits_count [ d ] > n // 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == " ? " : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if i == n : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT if s [ i ] == " ? " : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT DEDENT if i == n : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT b . append ( n + 1 ) NEW_LINE b . append ( n + 1 ) NEW_LINE b . append ( n + 2 ) NEW_LINE b . append ( n + 2 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if b [ i ] != b [ i - 1 ] : NEW_LINE INDENT b [ i ] = b [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT b . append ( n + 1 ) NEW_LINE b . append ( n + 2 ) NEW_LINE ans = [ ] NEW_LINE for i in b : NEW_LINE INDENT if i != n : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( * ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT c += b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c += a [ i ] NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t , * a = input ( ) . split ( ) NEW_LINE if t == " r " : NEW_LINE INDENT s . append ( t ) NEW_LINE DEDENT elif t == " r " : NEW_LINE INDENT s . append ( t ) NEW_LINE DEDENT elif t == " p " : NEW_LINE INDENT s . append ( t ) NEW_LINE DEDENT elif t == " r " : NEW_LINE INDENT s . append ( t ) NEW_LINE DEDENT elif t == " p " : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT elif t == " r " : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT elif t == " r " : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT elif t == " r " : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
def solve ( A , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2000 ) ] for i in range ( n ) ] NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( sum ) : NEW_LINE INDENT sum += A [ i ] [ i ] NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( sum + 1 ) : NEW_LINE INDENT for j in range ( sum + A [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE if j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= 0 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - A [ i - 1 ] ] NEW_LINE DEDENT if j + A [ i ] <= sum and j + A [ i ] ] <= - sum and dp [ i ] [ j + A [ i - 1 ] ] != - sum and dp [ i ] [ j + A [ i ] ] != - sum and dp [ i ] [ j + A [ i ] ] != - sum and dp [ i ] [ j ] != - sum : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j + A [ i ] ] , dp [ i ] [ j + A [ i ] ] + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return n - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 9 , 41 , 41 , 41 , 60 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( solve ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 = map ( int , line . split ( ) ) NEW_LINE a = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE b = ( y1 - y2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE c = ( a + b * c ) ** 2 NEW_LINE d = ( b + c * d ) ** 2 NEW_LINE e = ( a + b * d ) ** 2 NEW_LINE if abs ( e - e ) ** 2 < e : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT b = { } NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT b [ i ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT b . append ( b [ i ] ) NEW_LINE i += 1 NEW_LINE while i < n : NEW_LINE INDENT if b [ i ] == b [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( b [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT b . append ( b [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT b . append ( b [ i ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] == b [ i ] : NEW_LINE INDENT print ( " Fizz " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " " ) NEW_LINE DEDENT DEDENT
def initialize ( l ) : NEW_LINE INDENT l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return l [ n ] [ r ] NEW_LINE DEDENT n = 8 NEW_LINE r = 3 NEW_LINE print ( n ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a - b ) * ( c - a ) + ( d - c ) // 2 ) NEW_LINE
def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = mul * b [ i ] NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE i = n NEW_LINE while i <= n : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = s . find ( ' < ' ) NEW_LINE while i < n and s [ i ] == ' > ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n >>= 1 NEW_LINE ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def get_ints ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return input ( ) . split ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) NEW_LINE def get_string ( ) : return input ( ) NEW_LINE def get_string ( ) : return input ( ) NEW_LINE def stringput ( ) : return input ( ) NEW_LINE def stringput ( ) : return input ( ) NEW_LINE def stringput ( ) : return input ( ) . split ( ) NEW_LINE def stringput ( ) : return input ( ) NEW_LINE def stringput ( ) : return stringput ( ) NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return input ( ) NEW_LINE def stringput ( ) : return stringput ( ) NEW_LINE def stringput ( ) : return stringput ( ) NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE def stringput ( ) : return [ str ( i ) for i in stringput ( ) ] NEW_LINE mod = 10 ** 9 + 7 NEW_LINE a , b , c , f = map ( int , stringput ( ) . split ( ) ) NEW_LINE print ( c ) NEW_LINE
h , m = map ( int , input ( ) . split ( ' : ' ) ) NEW_LINE a = h * 60 + m NEW_LINE b = h % 60 NEW_LINE print ( b ) NEW_LINE
def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] * a [ i - 1 ] < 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT a = [ - 5 , - 1 , - 1 , 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestAlternatingSubarray ( a , n ) ) NEW_LINE
def checkSubTriOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , b ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE if ( sqa == sqb or sqb + sqb ) or ( sqa + sqb ) or sqb + sqb in sqb or sqb > sqb or sqb + sqb ) : NEW_LINE INDENT print ( " Un - - angleb ) NEW_LINE DEDENT elif ( sqa + sqb ) in sqb : NEW_LINE INDENT print ( " Occ - - triangle - angleb ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Occ - angle - triangle - sqb ) NEW_LINE DEDENT DEDENT a = 2 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE checkSubTriangle ( a , b , c ) NEW_LINE
max = 100 NEW_LINE def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cnt = 0 NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE result += cntG NEW_LINE DEDENT elif ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += cntG NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT s = " GFGGG " NEW_LINE n = len ( s ) NEW_LINE countSubsequence ( s , n ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE a = [ LI ( ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( [ a [ i ] , a [ i ] ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] > a [ j ] [ 1 ] and a [ i ] [ 1 ] > a [ j ] [ 2 ] : NEW_LINE INDENT print ( i , j ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while n > 0 : NEW_LINE INDENT largest = pow ( n , n ) NEW_LINE n -= ( largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 150 NEW_LINE print ( countSteps ( n ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import decimal NEW_LINE import re NEW_LINE import string NEW_LINE import itertools NEW_LINE import decimal NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import array NEW_LINE import bisect NEW_LINE import re NEW_LINE import re NEW_LINE import string NEW_LINE from fractions import Fraction NEW_LINE from fractions import Fraction NEW_LINE from heapq import heappush , heappop NEW_LINE from functools import reduce NEW_LINE import math NEW_LINE import itertools NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import string NEW_LINE from collections import deque NEW_LINE from operator import mul NEW_LINE from heapq import heapify NEW_LINE from heapq import heappush , heappop NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from operator import itemgetter NEW_LINE from functools import reduce NEW_LINE import heapq NEW_LINE import heapq NEW_LINE from itertools import permutations NEW_LINE from operator import mul NEW_LINE from itertools import permutations NEW_LINE from fractions import gcd NEW_LINE from functools import reduce NEW_LINE import reduce NEW_LINE import fractions NEW_LINE import operator NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT DEDENT def read_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_int_n ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_int_n ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_str_n ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( )
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = min ( a ) NEW_LINE b = min ( a ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE c = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == m : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif i == m : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT m = min ( b ) NEW_LINE a . append ( c ) NEW_LINE b . append ( c ) NEW_LINE c1 = a [ 0 ] NEW_LINE c2 = b [ 0 ] NEW_LINE c2 = b [ 0 ] NEW_LINE c1 = b [ 0 ] NEW_LINE c2 = b [ 0 ] NEW_LINE c2 = b [ 0 ] NEW_LINE c1 = c2 - a [ 1 ] NEW_LINE c2 = c1 NEW_LINE c2 = c2 - a [ 0 ] NEW_LINE c2 = c2 NEW_LINE c1 = c2 - c2 NEW_LINE c2 = c2 - c1 NEW_LINE print ( c1 , c2 ) NEW_LINE
def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sum ( w ) NEW_LINE b = w [ : a ] NEW_LINE if a % b != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT a -= b NEW_LINE b = a % b NEW_LINE a -= b NEW_LINE b -= a NEW_LINE if a % b != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 - 1 ) * 9 , maxProd ( N // 10 - 1 ) * 9 * 9 * 9 * 9 ) NEW_LINE DEDENT N = 380 NEW_LINE print ( maxProd ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in s : NEW_LINE INDENT l . append ( len ( i ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in l : NEW_LINE INDENT ans += i NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = [ ] , [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( x ) NEW_LINE y . append ( y ) NEW_LINE DEDENT x . sort ( ) NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif x [ i ] == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x += ( y ** 2 ) ** ( 1 / 2 ) NEW_LINE DEDENT DEDENT print ( math . sqrt ( x ** 2 ) ) NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE
def reduceString ( s , l ) : NEW_LINE INDENT count = 1 NEW_LINE steps = 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( count // 2 ) NEW_LINE count = 1 NEW_LINE DEDENT steps += count // 2 NEW_LINE DEDENT steps += steps // 2 NEW_LINE return steps NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE l = len ( s ) NEW_LINE print ( reduceString ( s , l ) ) NEW_LINE
def is_same ( n , m ) : NEW_LINE INDENT a , b = m , n NEW_LINE if a == 0 : NEW_LINE INDENT return " ? " NEW_LINE DEDENT elif b == 0 : NEW_LINE INDENT return " ? " NEW_LINE DEDENT else : NEW_LINE INDENT return " ? " NEW_LINE DEDENT DEDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE if a + b == 0 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT s = " " NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT s += " ? " NEW_LINE DEDENT else : NEW_LINE INDENT s += " ? " NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a , b = l [ 0 ] , l [ 1 ] NEW_LINE if a <= b : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE DEDENT elif a <= b : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE print ( 3 ) NEW_LINE print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT for j in range ( b + 1 ) : NEW_LINE INDENT print ( i , j ) NEW_LINE DEDENT DEDENT DEDENT
mod = 1000000007 NEW_LINE mod = 1000000007 NEW_LINE def mul_factors ( n ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE cnt = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mul ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mul ( ans , ( 2 ) ) NEW_LINE DEDENT DEDENT return ans % mod NEW_LINE DEDENT n = 35868 NEW_LINE mod = 170000007 NEW_LINE print ( calculate_factors ( n ) ) NEW_LINE
s = input ( ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i - 1 ] == ' . ' : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT elif s [ i ] == ' - ' : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE minEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbs ( arr , n ) ) NEW_LINE DEDENT
def check ( a , b , c , n ) : NEW_LINE INDENT if a == 0 or b == 0 or c == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if b == 0 or c == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if a == 0 or b == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if a == 1 or b == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if b == 0 or c == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if a == 0 or b == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if a == 1 or b == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if a == 1 or b == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def check ( a , b , c , d ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if c == 0 or a == 0 or b == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if a == 0 or b == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def check ( a , b , c , d ) : NEW_LINE INDENT if a == 0 or b == c == d : NEW_LINE INDENT return True NEW_LINE DEDENT if b == 0 or a == d == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a , b , c , d , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b == c == d == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if a == b == d == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if b == c == d : NEW_LINE INDENT return True NEW_LINE DEDENT else :
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in countB . keys ( ) : NEW_LINE INDENT countB [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countB [ b [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE s = countA . keys ( ) NEW_LINE s = countA . keys ( ) NEW_LINE for x in s : NEW_LINE INDENT if countB in countB : NEW_LINE INDENT res += min ( countB , countA ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 , 4 ] NEW_LINE b = [ 2 , 3 , 4 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( minRemove ( a , b , n , m ) ) NEW_LINE DEDENT
M = 20 NEW_LINE dp = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def count ( pos , last , tight , num , num ) : NEW_LINE INDENT if ( pos == len ( dp ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE for dig in range ( tight ) : NEW_LINE INDENT curr1 = dig NEW_LINE if ( curr == 0 and dig != 0 ) : NEW_LINE INDENT curr1 = dig NEW_LINE DEDENT if ( curr1 == 0 and dig != 0 ) : NEW_LINE INDENT curr1 = dig NEW_LINE DEDENT ans += count ( pos + 1 , curr1 , num , curr1 , num ) NEW_LINE DEDENT dp [ pos ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT curr = dig % 10 NEW_LINE if ( curr == 0 and dig != 0 ) : NEW_LINE INDENT curr1 = dig NEW_LINE DEDENT ans += count ( i + 1 , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 60 NEW_LINE print ( solve ( L ) - solve ( L - 1 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( min ( a ) ) NEW_LINE
def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT x >>= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( check ( l , n ) ) : NEW_LINE INDENT return l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return l + 1 NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - b NEW_LINE DEDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE
def minimumSteps ( s , n ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ' ' ; NEW_LINE DEDENT s1 = " " ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] ; NEW_LINE dp [ i + 1 ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; NEW_LINE DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT s = " aaaaaa " ; NEW_LINE n = len ( s ) ; NEW_LINE print ( minimumSteps ( s , n ) // 2 ) ; NEW_LINE
def checkUtil ( num , dig , base , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num < base ) : NEW_LINE INDENT return checkUtil ( num / base , base , mod ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig , base ) : NEW_LINE INDENT for base in range ( 2 , 32 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig , base ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def generateArr ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = maxVal NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def generateArr ( arr , i , j ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT arr [ 0 ] = getMin ( arr , 1 , n - 2 ) NEW_LINE generateArr ( arr , 0 , n - 2 ) NEW_LINE printArray ( arr , 0 , n - 2 ) NEW_LINE printArray ( arr , 0 , n - 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE generateArr ( arr , 0 , n - 2 ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE import sys , random , itertools , math NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE input = sys . stdin . readline NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE S = LI ( ) NEW_LINE a = S ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == ' A ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT ans = max ( r , l ) NEW_LINE if l == r : NEW_LINE INDENT ans = max ( ans , r ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = r NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT a , b , c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE b = a - b NEW_LINE c = b - c NEW_LINE d = b - d NEW_LINE e = d / e NEW_LINE if a < b + e : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def nthXFib ( n , a , b ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return b ^ b NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( a ^ b ) NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE n = 10 NEW_LINE print ( nthXFibFib ( n , a , b ) ) NEW_LINE
import sys NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE l1 = [ ] NEW_LINE l2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE l1 . append ( a ) NEW_LINE l2 . append ( b ) NEW_LINE DEDENT for i in l1 : NEW_LINE INDENT if i [ 0 ] > l1 [ 1 ] : NEW_LINE INDENT print ( i , i [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , i [ 1 ] ) NEW_LINE DEDENT DEDENT
def Area ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.70477 * a NEW_LINE A = 0.70477 * a NEW_LINE A = 0.70477 * a NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT n = left + right NEW_LINE d = left + right NEW_LINE if d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + d NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** ( n - 2 ) ) NEW_LINE DEDENT
def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = 10 ** ( max + 1 ) - 1 NEW_LINE prime [ 0 ] = True NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT d = 3 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE
def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( pow ( 2 , d ) - 1 ) NEW_LINE prime [ 0 ] = True NEW_LINE sieve ( prime , maxVal + 1 ) NEW_LINE sieve ( prime , maxVal + 1 ) NEW_LINE DEDENT d = 8 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE i = 0 NEW_LINE while ( ( ( l [ 0 ] + l [ 1 ] ) / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / ( 1 / 1 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT
import sys NEW_LINE a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE def s ( i ) : NEW_LINE INDENT return ( a + b + c ) * d NEW_LINE DEDENT def s ( i ) : NEW_LINE INDENT return ( i + 1 ) * d NEW_LINE DEDENT def s ( i ) : NEW_LINE INDENT return ( i + 1 ) * d NEW_LINE DEDENT def s ( i ) : NEW_LINE INDENT return ( i + 1 ) * d NEW_LINE DEDENT def s ( i ) : NEW_LINE INDENT return ( i + 1 ) * d NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( i + 1 ) * d NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return a * b // ( a ) + 1 NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * a ) + ( * b ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * a ) + ( * b ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * a ) + ( * b ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * b ) + ( * a ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * a ) + ( * b ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * a ) + ( * b ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * a ) + ( * b ) NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT return ( * a ) NEW_LINE DEDENT
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE DEDENT
def countMaxDeciguous ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 4 , 3 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countMaxDeciguous ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( h * r * r ) / ( math . sqrt ( 2 ) * math . sqrt ( 2 ) ) NEW_LINE return a NEW_LINE DEDENT h = 5 NEW_LINE r = 6 NEW_LINE print ( cube ( h , r ) ) NEW_LINE
def pattern ( rows_no , rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT for i in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows_no = 7 NEW_LINE pattern_no = 7 NEW_LINE pattern_no = 7 NEW_LINE pattern_no = pattern ( rows_no ) NEW_LINE
n = input ( ) NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if n [ i ] == '0' : NEW_LINE INDENT print ( 10 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if n [ 0 ] == '0' : NEW_LINE INDENT print ( 10 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 1 , len ( n ) ) : NEW_LINE INDENT if n [ i ] == '1' : NEW_LINE INDENT print ( 10 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( 10 ) NEW_LINE
def check_digits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = n // 10 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( check_digits ( i ) > 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT N = 239793 ; NEW_LINE print ( smallest_number ( N ) ) ; NEW_LINE
def check_digits ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT if ( ( n % 10 != 0 ) % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( check_digits ( i ) != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE
def triangular_series ( n ) : NEW_LINE INDENT j = 1 NEW_LINE k = 1 NEW_LINE j = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE j = j + 1 NEW_LINE k = k + j NEW_LINE DEDENT DEDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE summ = 0 NEW_LINE for i in a : NEW_LINE INDENT summ += i * ( n - i ) NEW_LINE DEDENT print ( summ ) NEW_LINE
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 ; f2 = 1 ; i = 2 ; f3 = 1 ; NEW_LINE while ( i != 0 ) : f3 = f1 + f2 ; NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT i += 2 ; NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( " Position ▁ of ▁ n ▁ of ▁ k ▁ is " , findPosition ( k , n ) ) ; NEW_LINE DEDENT
s = input ( ) NEW_LINE res = " Second " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ len ( s ) - 1 ] : NEW_LINE INDENT res = " First " NEW_LINE DEDENT DEDENT if res % 2 == 1 : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT
def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 4 ] NEW_LINE K = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( countMinimumMoves ( arr , n , K ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , e ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b , n ) ) NEW_LINE DEDENT
T , S , Q = map ( int , input ( ) . split ( ) ) NEW_LINE x = 0 NEW_LINE while True : NEW_LINE INDENT if S < T : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT x = S * Q NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( n * ( n - 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n * ( n - 2 ) ) NEW_LINE DEDENT
def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT mat = [ [ 1 , 1 ] , [ 1 , 2 ] ] NEW_LINE for j in range ( len ( mat ) ) : NEW_LINE INDENT mat [ mat [ i ] [ j ] ] = mat [ i ] [ j ] NEW_LINE DEDENT if len ( len ( mat ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] NEW_LINE print ( countIdenticalRows ( mat ) ) NEW_LINE
def createSorted ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( len ( b ) == 0 ) : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start = 0 NEW_LINE end = len ( b ) - 1 NEW_LINE DEDENT DEDENT for i in range ( start , end ) : NEW_LINE INDENT start = 0 NEW_LINE end = 0 NEW_LINE end = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if ( b [ mid ] == a [ j ] ) : NEW_LINE INDENT b . append ( ( max , i ) ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT i = start + 1 NEW_LINE DEDENT DEDENT elif ( b [ mid ] > a [ i ] ) : NEW_LINE INDENT pos = start NEW_LINE DEDENT else : NEW_LINE INDENT pos = start NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 4 , 4 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE DEDENT
def countTotalDistinct ( str ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE ans = set ( ) NEW_LINE for j in range ( i , len ( temp ) ) : NEW_LINE INDENT temp = temp + str [ j ] NEW_LINE ans . add ( temp ) NEW_LINE if ( temp in temp ) : NEW_LINE INDENT temp . add ( temp ) NEW_LINE cnt += len ( temp ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ABCA " NEW_LINE print ( countTotalDistinct ( str ) ) NEW_LINE DEDENT
from math import log10 , gcd NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = log10 ( n ) NEW_LINE n = int ( n / ( 10 ** digits ) ) NEW_LINE return n NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 NEW_LINE print ( lastDigit ( n ) , lastDigit ( n ) ) NEW_LINE
def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( " Array ▁ of ▁ zeros ▁ zeros " ) NEW_LINE return NEW_LINE DEDENT b = [ 0 for i in range ( n - ind ) ] NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 1 , 0 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE
def find_maxm ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for x in mp : NEW_LINE INDENT value = mp . get ( x , 0 ) + 1 NEW_LINE if ( value == freq ) : NEW_LINE INDENT ans = max ( ans , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 2 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maxm ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = n * ( n + 1 ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= a [ i ] : NEW_LINE INDENT ans = a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def sumOfDigits ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigits ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigits ( N ) : NEW_LINE INDENT A = longest ( N ) NEW_LINE return sumOfDigits ( A ) + sumOfDigits ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( sumOfDigits ( N ) ) NEW_LINE DEDENT
import sys NEW_LINE d = [ " A " , " B " , " C " , " D " , " E " , " F " , " F " , " F " , " G " , " H " , " F " , " J " , " K " , " L " , " M " , " N " , " O " , " P " , " Q " , " P " , " Q " , " V " , " W " , " V " , " V " , " W " , " V " , " V " , " W " , " V " , " V " , " W " , " V " , " V " , " W " , " V " , " V " , " W " , " V " , " W " , " V " , " V " , " W " , " V " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " V " , " W " , " Z " , " W " , " V " , " W " , " W " , " Z " , " W " , " Z " , " W " , " Z " , " W " , " Z " , " Z " , " W " , " Z " , " W " , " Z " , " W " , " Z " , " Z " , " Z " , " Z " , " W " , " Z " , " W " , " Z " , " Z " , " Z " , " W " , " F " , " W " , " Z " , " W " , " Z " , " W " , " Z " , " W " , " Z " , " W " , " Z " , " W " , " W " , " W " , " Z " , " W " , " Z " , " W " , " E " , " W " ,
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = a + b - c + d NEW_LINE print ( ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] - a [ i - 1 ] <= 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def cal_cos ( n ) : NEW_LINE INDENT optimal = 0.0001 NEW_LINE n = n * ( 3.0 / 180.0 ) NEW_LINE cosx = n * ( 3.0 / 180.0 ) NEW_LINE cosx = sin ( n ) NEW_LINE i = 1 NEW_LINE j = 1 NEW_LINE while ( conver <= sinx ) : NEW_LINE INDENT cosx = 2 * i * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n / denominator NEW_LINE x1 = - x1 * n / denominator NEW_LINE x1 = - x1 * n / denominator NEW_LINE i = i + 1 NEW_LINE DEDENT print ( int ( sinx - sinx ) ) NEW_LINE DEDENT n = 90 NEW_LINE cal_cos ( n ) NEW_LINE
def multiply ( arr , 2 , 3 , 4 , 5 ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT pro = pro * arr [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( multiply ( arr ) ) NEW_LINE
from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif a [ 0 ] == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a [ 1 ] == 3 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT count += 1 NEW_LINE n >>= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT inc = arr [ 0 ] NEW_LINE exc = 0 NEW_LINE exc = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT exc = bit ( arr [ i ] ) NEW_LINE exc = exc + arr [ i ] NEW_LINE exc = exc + arr [ i ] NEW_LINE DEDENT return exc NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 4 , 5 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in s : NEW_LINE INDENT if i . count ( ' C ' ) == 1 : NEW_LINE INDENT ans += ( i . count ( ' D ' ) - 1 ) * ( i . count ( ' C ' ) - 1 ) // 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def findMinIndex ( arr , low , high ) : NEW_LINE INDENT if ( high < low and arr [ low ] < arr [ mid ] ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( mid == low and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > low and arr [ mid + 1 ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return findMinIndex ( arr , low , mid - 1 , x ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return findMinIndex ( arr , low , mid - 1 , high ) + 1 - minIndex ( arr , mid - 1 , x ) + 1 - minIndex ( arr , mid - 1 , low , x ) + 1 - minIndex ( arr , mid - 1 , x ) + 1 ) NEW_LINE DEDENT DEDENT def countEleLessThan ( arr , n , x ) : NEW_LINE INDENT min_index = findMinIndex ( arr , 0 , n - 1 , x ) NEW_LINE if ( x <= arr [ n - 1 ] ) : NEW_LINE INDENT return ( n - min_index ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT arr = findMinLessThan ( arr , 0 , n - 1 , x ) NEW_LINE n = len ( arr ) NEW_LINE x = 14 NEW_LINE print ( " Count ▁ = " , countEleThanLessThan ( arr , n , x ) ) NEW_LINE
def f ( x , y ) : NEW_LINE INDENT v = y - 2 * x NEW_LINE return v NEW_LINE DEDENT def calculate ( x , y , h ) : NEW_LINE INDENT y = y + h * x NEW_LINE return y NEW_LINE DEDENT def calculate ( x , y , h ) : NEW_LINE INDENT e1 = 0.00001 NEW_LINE y1 = y NEW_LINE y1 = y NEW_LINE y1 = y1 NEW_LINE while ( abs ( y1 - y1 ) > e ) : NEW_LINE INDENT y1 = y1 NEW_LINE y1 = y1 NEW_LINE y1 = y1 NEW_LINE y1 = y1 NEW_LINE y1 = calculate ( x , y , h ) NEW_LINE y1 = calculate ( x , y , h ) NEW_LINE y1 = calculate ( x , y , h ) NEW_LINE x2 = calculate ( x , y , h ) NEW_LINE y1 = calculate ( x , y , h ) NEW_LINE x2 = calculate ( x , y , x , y ) NEW_LINE y2 = calculate ( x , y , h ) NEW_LINE x = y1 NEW_LINE y = calculate ( x , y , h ) NEW_LINE print ( " The ▁ value ▁ of ▁ x ▁ = ▁ " , " % d " % x , " % y2 ) NEW_LINE DEDENT x = 0.5 NEW_LINE y = 1.5 NEW_LINE print ( " The ▁ value ▁ of ▁ x ▁ = " % d " % y , " % x , " % y ) NEW_LINE
def D_Pattern ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == 1 or i == 0 or i == n - 1 and j > 1 and i > n - 2 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 NEW_LINE DEDENT
def kthString ( n , k ) : NEW_LINE INDENT total_y = 0 NEW_LINE i = 1 NEW_LINE while ( total_y < k ) : NEW_LINE INDENT total_y = total_y + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y = i - 1 NEW_LINE second_x = k - ( total_y - n + 1 ) NEW_LINE while ( 2 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_y -= 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while ( 2 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT j = n NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT j = n NEW_LINE DEDENT n = 5 NEW_LINE kthString ( n , k ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def count_of_subarr ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N - 1 , N ) NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( count_of_subarr ( N ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def productAddedWithNonZero ( self , nums ) : NEW_LINE INDENT res = [ 1 ] * nums [ 0 ] NEW_LINE res [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( nums ) - 1 , - 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * nums [ i ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT res [ i ] *= res [ i ] NEW_LINE right *= nums [ i ] NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 ] NEW_LINE out = sObj . productAddedWithNonZero ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getSmallestAndL ( s , k ) : NEW_LINE INDENT curr = s [ 0 : k ] NEW_LINE lexMax = curr NEW_LINE lexMax = curr NEW_LINE lexMax = curr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT curr = ord ( s [ i : k ] ) + ord ( s [ i : k ] ) NEW_LINE if ( curr == curr ) : NEW_LINE INDENT lexMax = curr NEW_LINE DEDENT if ( lexMax ) : NEW_LINE INDENT lexMax = curr NEW_LINE DEDENT DEDENT print ( lexMax ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE getSmallAndL ( s , k ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
MAX_BITS = 32 NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT maxEle = i NEW_LINE maxEle = INT_MAX NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( set [ j ] & ( 1 << i ) ) and set [ j ] > maxEle ) : NEW_LINE INDENT maxEle = set [ j ] NEW_LINE maxEle = j NEW_LINE DEDENT DEDENT if ( maxEle == - 2147483648 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = set [ i ] NEW_LINE set [ maxInd ] NEW_LINE set [ maxInd ] = set [ maxInd ] NEW_LINE set [ maxInd ] = set [ maxInd ] NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= set [ i ] NEW_LINE set [ maxInd ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= set [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 9 , 8 , 5 ] NEW_LINE n = len ( set ) NEW_LINE print ( " MaxSubarray ▁ XOR ▁ is " , maxSubarrayXOR ( set , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c . append ( b [ i ] ) NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT c . append ( c [ i + 1 ] - i ) NEW_LINE DEDENT print ( len ( c ) , len ( c ) ) NEW_LINE
def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE min_sum = n - 1 NEW_LINE min_sum = 0 NEW_LINE min_sum = n - 1 NEW_LINE min_sum = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ Input ▁ is " ) NEW_LINE return NEW_LINE DEDENT arr . sort ( ) NEW_LINE min_sum = sum - 1 NEW_LINE min_sum = n - 1 NEW_LINE min_sum = min ( arr [ min_sum ] + arr [ min_sum ] ) NEW_LINE for i in range ( min_sum , min_sum ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE min_sum = sum NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l = sum NEW_LINE r = l NEW_LINE DEDENT else : NEW_LINE INDENT r = r NEW_LINE DEDENT DEDENT arr = [ 1 , 60 , - 10 , 70 , 70 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSum = ( arr [ min_sum ] + arr [ min_sum ] ) NEW_LINE print ( " The ▁ two ▁ elements ▁ is " , arr [ min_sum ] , arr [ min_sum ] , " and ▁ are " , arr [ min_sum ] ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " lechcode " NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkStackPermutation ( a , op , op , n ) : NEW_LINE INDENT stack = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT op . append ( op [ i ] ) NEW_LINE DEDENT result = [ ] NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT op = op [ - 1 ] NEW_LINE if ( op [ - 1 ] == op [ - 1 ] ) : NEW_LINE INDENT op . pop ( ) NEW_LINE while ( len ( op ) != 0 ) : NEW_LINE INDENT op . pop ( ) NEW_LINE DEDENT if ( op [ - 1 ] == op [ - 1 ] ) : NEW_LINE INDENT temp . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp . pop ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp . append ( ele ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp . append ( ele [ - 1 ] ) NEW_LINE DEDENT DEDENT if ( len ( op ) == 0 and op [ - 1 ] == op [ - 3 ] ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT
S = input ( ) NEW_LINE T = input ( ) NEW_LINE s_list = [ ] NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] != T [ i ] : NEW_LINE INDENT s_list . append ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT s_list . append ( " No " ) NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for i in range ( len ( s_list ) ) : NEW_LINE INDENT if s_list [ i ] != s_list [ i ] : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s , d , n = map ( int , input ( ) . split ( ) ) NEW_LINE m = max ( s , n - s ) NEW_LINE if d == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n + m <= n : NEW_LINE INDENT print ( s - d ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s - d ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a - s , t ) + 1 ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i % K NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 10 NEW_LINE K = 2 NEW_LINE print ( findSum ( N , K ) ) NEW_LINE
import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( 1 + ( 4 * n + 1 ) // math . gcd ( 4 * n + 1 , n + 1 ) ) NEW_LINE DEDENT
PI = 3.14 ; NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI ; NEW_LINE R += pow ( r , 2 ) ; NEW_LINE R = PI * pow ( R , 2 ) ; NEW_LINE area = PI * pow ( R , 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT r = 4 ; d = 5 ; NEW_LINE print ( find_area ( r , d ) ) ; NEW_LINE
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( ( s % n ) > 0 ) : NEW_LINE INDENT return s // n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s // n + 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE s = 11 NEW_LINE print ( minimumNumbers ( n , s ) ) NEW_LINE DEDENT
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE end = n - 1 NEW_LINE end = end - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT start = 0 NEW_LINE end = end - 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( prod > m ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( prod > m ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a , b , c = 0 , 1 , 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ch == ch [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isSolved ( str , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) and isVowel ( str [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) and isVowel ( str [ i - 1 ] ) and isVowel ( str [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str = " acaba " NEW_LINE n = len ( str ) NEW_LINE if isSolved ( str , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT n = 6 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def evaluate ( m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT ans += ( ( i / m ) ** n ) - pow ( ( i - 1 ) / m , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 6 NEW_LINE n = 3 NEW_LINE print ( evaluate ( m , n ) ) NEW_LINE DEDENT
def ProdOfPrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT n = 10 NEW_LINE print ( ProdOfPrimes ( n ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE year = 12 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 ) : NEW_LINE INDENT for m in range ( 12 ) : NEW_LINE INDENT for m in range ( 12 ) : NEW_LINE INDENT if i * 12 + j * 12 + 1 ) % 12 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if j * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 12 * 12 + 7 * 12 + 7 * 12 ) % 7 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def getDifference ( d , m , y ) : NEW_LINE INDENT year = d * y NEW_LINE y = y NEW_LINE if ( d <= 2 ) : NEW_LINE INDENT year -= 1 NEW_LINE DEDENT return year // 4 - year + 1 NEW_LINE DEDENT def getDifference ( d , d ) : NEW_LINE INDENT n1 = d * 365 + d * 365 + d * 365 + d * 365 NEW_LINE n2 = d * 365 + d * 365 NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT d1 = [ 1 , 2 , 4 , 4 ] NEW_LINE d2 = getDifference ( d1 , d2 ) NEW_LINE n2 = getDifference ( d1 , d2 ) NEW_LINE n2 = getDifference ( d1 , d2 ) NEW_LINE print ( " Difference ▁ of ▁ two ▁ numbers ▁ is " , getDifference ( d1 , d2 ) ) NEW_LINE
def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT generateNumbers ( n * 10 + a , b , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE print ( " The ▁ numbers ▁ is : " , end = " " ) NEW_LINE print ( " The ▁ numbers ▁ is : " , end = " " ) NEW_LINE print ( " The ▁ numbers ▁ : ▁ " , end = " " ) NEW_LINE print ( " The ▁ numbers ▁ : ▁ " , end = " " ) NEW_LINE print ( " The ▁ numbers ▁ is : " , end = " " ) NEW_LINE printNumbers ( n ) NEW_LINE DEDENT n = 12 NEW_LINE printNumbers ( n ) NEW_LINE
n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE t = 0 NEW_LINE while ( t * k ) : NEW_LINE INDENT l . append ( k * n ) NEW_LINE t += k * k NEW_LINE DEDENT l . append ( k ) NEW_LINE t += 1 NEW_LINE ans = [ ] NEW_LINE while ( t > 0 ) : NEW_LINE INDENT ans += [ k ] NEW_LINE t -= 1 NEW_LINE DEDENT print ( * ans ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT a [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] >= a [ i ] [ j ] : NEW_LINE INDENT ans = a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def getOddOccurrence ( ar , n_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 5 , 2 , 4 , 2 , 4 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getOddOccurrence ( ar , n ) ) NEW_LINE
def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = 1 << ( k - 1 ) NEW_LINE r = ( MAX >> ( k - 1 ) ) * 8 NEW_LINE return rlt NEW_LINE DEDENT def isPalindrome ( x , k ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( MAX // ( k - 1 ) ) * 8 NEW_LINE while l < r : NEW_LINE INDENT if isKthBitSet ( x , l ) != isKthBitSet ( x , l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT x = 1 << 15 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for p in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT isPrime [ p ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime [ i ] ) NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT x = n // i NEW_LINE if ( isPrime [ i ] and x != i and x != i and x != i ) : NEW_LINE INDENT print ( i , x ) NEW_LINE return NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair " ) NEW_LINE return NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " No ▁ pair " ) NEW_LINE DEDENT DEDENT n = 39 NEW_LINE findPrimePair ( n ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE g = gcd ( a , b ) NEW_LINE a = g NEW_LINE b = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 30 NEW_LINE b = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , b , " , ▁ = " , g ) ) NEW_LINE a = 30 NEW_LINE b = gcd ( a , b ) NEW_LINE g = g NEW_LINE print ( " GCD ( " , a , b , " ) ▁ = ▁ " , g ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE g = gcd ( a , b ) NEW_LINE a = g NEW_LINE b = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 30 NEW_LINE b = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , b , " , ▁ = " , g ) ) NEW_LINE a = 30 NEW_LINE b = gcd ( a , b ) NEW_LINE g = g NEW_LINE print ( " GCD ( " , a , b , " ) ▁ = ▁ " , g ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT SIZE = 10 ** 6 NEW_LINE ans = len ( SIZE ) NEW_LINE for n in range ( 3 , SIZE + 1 , 1 ) : NEW_LINE INDENT for m in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for m in range ( n - 2 , - 1 , - m * m ) : NEW_LINE INDENT tiles = n * n - m * m NEW_LINE if tiles > SIZE : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == '0' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT N = 14 NEW_LINE print ( maxZeros ( N ) ) NEW_LINE
def getLongestSeq ( a , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currLen = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( a [ k ] > 0 ) : NEW_LINE INDENT currLen += 1 NEW_LINE if ( currLen == 1 ) : NEW_LINE INDENT currLen = k NEW_LINE DEDENT else : NEW_LINE INDENT currLen = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( currLen > maxLen ) : NEW_LINE INDENT maxLen = currLen NEW_LINE maxLen = currLen NEW_LINE DEDENT DEDENT DEDENT if ( maxLen > 0 ) : NEW_LINE INDENT print ( " Index ▁ : ▁ " , maxLen ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Invalid ▁ : ▁ " , maxLen ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , - 3 , 2 , 3 , 4 , 4 , 1 , 5 , 5 , 6 , 5 , 5 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE getLongestSeq ( arr , n ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def construct ( arr ) : NEW_LINE INDENT if ( i > 0 or i > n - 1 or i > m - 1 ) : NEW_LINE INDENT return None NEW_LINE DEDENT temp = arr [ i ] NEW_LINE temp . right = construct ( arr [ i ] , i + 1 , j , m ) NEW_LINE temp . right = construct ( arr , i + 1 , j , m ) NEW_LINE return temp NEW_LINE DEDENT DEDENT def display ( arr ) : NEW_LINE INDENT Dp = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 , 9 ] , [ 7 , 8 , 6 , 9 ] ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE m = 3 NEW_LINE n = 3 NEW_LINE head = construct ( arr ) NEW_LINE print ( head ) NEW_LINE display ( head ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def findNthTerm ( N ) : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and a == c and b == d and b == d and b == d and b == d and b == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == b and c == d and b == d and b == d and b == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == b and c == d and d == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def naturalLogger ( a , b , m ) : NEW_LINE INDENT n = ( sqrt ( m ) + 1 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a * a ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT value = ( i * a ) % m NEW_LINE DEDENT value = 1 NEW_LINE cur = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT cur = ( cur * a ) % m NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE m = 7 NEW_LINE print ( naturalLogger ( a , b , m ) ) NEW_LINE a = 7 NEW_LINE b = 7 NEW_LINE m = 11 NEW_LINE print ( naturalLogger ( a , b , m ) ) NEW_LINE DEDENT
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return min ( abs ( a [ ind + i ] - a [ ind ] ) , abs ( a [ ind + i ] ) + findMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return min ( ans , abs ( a + i , a , n , k , dp ) + findMinimumCost ( ind + i , a , n , a , n , k , dp ) ) NEW_LINE DEDENT dp [ ind ] = ans NEW_LINE DEDENT dp = [ 10 , 30 , 40 , 50 , 20 , 20 ] NEW_LINE n = len ( dp ) NEW_LINE k = 3 NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE
from math import gcd NEW_LINE def Probability ( sum , times ) : NEW_LINE INDENT fuel = 0 NEW_LINE total = 36 NEW_LINE probability = 0 NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( i + j == sum ) : NEW_LINE INDENT probability += 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = probability / gcd1 NEW_LINE probability = probability / gcd1 NEW_LINE probability = probability / pow ( total , times ) NEW_LINE return probability NEW_LINE DEDENT sum = 7 NEW_LINE times = 7 NEW_LINE print ( " % . / " % d " % ( int ( times / gcd1 ) ) ) NEW_LINE
K = int ( input ( ) ) NEW_LINE N = K + 1 NEW_LINE N = len ( input ( ) ) NEW_LINE MOD = 998244353 NEW_LINE dp = [ [ 0 ] * ( K + 1 ) for _ in range ( K + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( K + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] ) % MOD NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] ) % MOD NEW_LINE DEDENT DEDENT DEDENT print ( dp [ K ] [ K ] ) NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , t = input ( ) . split ( ) NEW_LINE if s == " Y " : NEW_LINE INDENT d [ s ] += d [ t ] NEW_LINE DEDENT elif s == " Y " : NEW_LINE INDENT d [ s ] += d [ t ] NEW_LINE DEDENT DEDENT print ( d . get ( " Y " , 0 ) ) NEW_LINE
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = n - 1 NEW_LINE while ( j >= i + 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 7 , 9 , 12 , 12 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE num1 = 4 NEW_LINE print ( getCount ( arr , n , num1 , num2 ) ) NEW_LINE
import sys NEW_LINE import os NEW_LINE import math NEW_LINE def distance ( x , y ) : NEW_LINE INDENT return x - y NEW_LINE DEDENT def distance ( x , y ) : NEW_LINE INDENT return x - y NEW_LINE DEDENT def min_val ( x , y ) : NEW_LINE INDENT return min ( x - x , y ) NEW_LINE DEDENT def min_val ( x , y ) : NEW_LINE INDENT return min ( x - y , y ) NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT y = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y . append ( abs ( y [ i - 1 ] - y [ i - 1 ] ) ) NEW_LINE DEDENT print ( min ( y ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 ] * ( n + 1 ) NEW_LINE setBits [ 0 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i - 1 ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def largestGCDSubSet ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if ( currentGCD == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestGCDSubSet ( A , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE LIMIT = eulerlib . list_divisors ( LIMIT + 1 ) NEW_LINE ans = len ( LIMIT ) NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT for j in range ( 2 , LIMIT + 1 , LIMIT + 1 , LIMIT + 1 ) : NEW_LINE INDENT if LIMIT [ j ] == LIMIT : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE
def findEncinaryArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE findEncinaryArray ( arr , N ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE
def findMinDifference ( arr , n ) : NEW_LINE INDENT minMin = 2 ; secondMin = 2 ; NEW_LINE maxMin = 2 ; NEW_LINE maxMin = secondMin ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > maxMin ) : NEW_LINE INDENT secondMax = max ( arr [ i ] , maxMin ) ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] ; NEW_LINE DEDENT DEDENT diff = min ( max - 2 , secondMin - minMin ) ; NEW_LINE return diff ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDifference ( arr , n ) ) ; NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % i == 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if n == 1 or n == 0 else n * factorial ( n - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 5 NEW_LINE num = 5 NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( num ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , X , X = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE dp = [ [ 0 ] * ( X + 1 ) for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( X - 1 ) : NEW_LINE INDENT if A [ i ] [ j ] < dp [ i + 1 ] [ j ] : NEW_LINE INDENT dp [ i + 1 ] [ j ] = dp [ i ] [ j ] + A [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ X ] ) NEW_LINE
n , l , r = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for _ in range ( r ) : NEW_LINE INDENT b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( b ) NEW_LINE DEDENT s = sum ( a ) - s NEW_LINE print ( s ) NEW_LINE
def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT return ( min ( st [ 1 ] - st [ 0 ] ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE
from math import sqrt NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r , m = n , 0 NEW_LINE m = int ( sqrt ( k ) + 1 ) + 1 NEW_LINE for i in range ( 2 , m + 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT for v in range ( v , m + 1 ) : NEW_LINE INDENT k = v NEW_LINE while ( k > 0 ) : NEW_LINE INDENT k //= i NEW_LINE v //= i NEW_LINE DEDENT DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT
def LiesInLocangles ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - b <= 0 and x + b <= 0 and x + b <= 0 and x + b <= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if LiesInLocangles ( a , b , x , y ) : NEW_LINE INDENT print ( " Lies ▁ does ▁ at ▁ the ▁ at ▁ the ▁ at ▁ at ▁ at ▁ degrees " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Truth " ) NEW_LINE DEDENT DEDENT
N = 1000 NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 for i in range ( 2 * N ) ] NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT x = arr [ i ] + n NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( freq [ i ] > 0 and freq [ i ] > 0 ) : NEW_LINE INDENT ans += ( freq [ i ] * ( freq [ ( i + j ) // 2 ) ) // 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def getAvg ( x ) : NEW_LINE INDENT sum = sum + x NEW_LINE return ( sum ) / n NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = avgVal ( arr [ i ] ) NEW_LINE DEDENT return avg NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( arr [ i ] ) NEW_LINE DEDENT return avg NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ of ▁ numbers ▁ is " , int ( arr [ n ] ) , " numbers ▁ is " , int ( arr [ n ] ) , " numbers ▁ is " ) NEW_LINE
MAX = 10000 NEW_LINE s = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( p * p < MAX ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT product = product * p NEW_LINE s . append ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEqual ( n ) : NEW_LINE INDENT if ( s [ n ] in s ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT SieveOfEratosthenes ( n ) NEW_LINE if ( s [ n ] in s ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT SieveOfEratosthen ( ) NEW_LINE n = 31 NEW_LINE if ( isEqual ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , b = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
def maxOperations ( str ) : NEW_LINE INDENT i , g , g , k = g , g , g NEW_LINE g , g = g , g NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' g ' ) : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif ( str [ i ] == ' k ' ) : NEW_LINE INDENT g -= 1 NEW_LINE g -= 1 NEW_LINE g -= 1 NEW_LINE DEDENT elif ( str [ i ] == ' k ' ) : NEW_LINE INDENT g -= 1 NEW_LINE g -= 1 NEW_LINE g -= 1 NEW_LINE DEDENT elif ( str [ i ] == ' s ' ) : NEW_LINE INDENT if ( g > 0 ) : NEW_LINE INDENT g -= 1 NEW_LINE g -= 1 NEW_LINE g -= 1 NEW_LINE DEDENT DEDENT return g NEW_LINE DEDENT a = " ggkskksk " NEW_LINE print ( maxOperations ( a ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE adj = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . append ( b ) NEW_LINE adj [ b ] . append ( a ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . append ( b ) NEW_LINE adj [ b ] . append ( a ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in adj [ i ] : NEW_LINE INDENT if j in adj [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE adj [ i ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( " Kth ▁ element ▁ is " , kthSmallest ( arr , k ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a [ - 1 ] , a [ - 2 ] = a [ - 1 ] , a [ - 2 ] NEW_LINE DEDENT if a [ 0 ] == a [ - 1 ] : NEW_LINE INDENT print ( * a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * a ) NEW_LINE DEDENT
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT S = 1 NEW_LINE ANS = 1 NEW_LINE ANS = 0 NEW_LINE ANS = 0 NEW_LINE ANS = 0 NEW_LINE ANS = 0 NEW_LINE ANS = 0 NEW_LINE ANS = 0 NEW_LINE ANS = 0 NEW_LINE for i in range ( ANS + 1 ) : NEW_LINE INDENT for j in range ( ANS + 1 ) : NEW_LINE INDENT if ( j & ANS + 1 ) % 2 == 0 : NEW_LINE INDENT ANS += 1 NEW_LINE DEDENT elif ( j & ANS + 1 ) % 2 == 0 : NEW_LINE INDENT ANS += 1 NEW_LINE DEDENT DEDENT DEDENT ANS += ANS * pow ( ANS , ANS , ANS ) NEW_LINE ANS += ANS * pow ( ANS , ANS , ANS ) NEW_LINE DEDENT return ANS NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import radians , sin , cos , pi NEW_LINE def distance ( lat1 , lat2 , l1 , l2 ) : NEW_LINE INDENT l1 = radians ( l1 ) NEW_LINE l2 = radians ( l2 ) NEW_LINE d1 = l2 - l1 NEW_LINE d2 = radians ( d1 / 2 ) NEW_LINE a = math . sin ( rad2 / 2 ) * math . sin ( rad2 / 2 ) NEW_LINE d1 = math . sin ( rad2 / 2 ) * math . sin ( rad1 / 2 ) NEW_LINE r = 2 * math . sin ( rad2 / 2 ) * math . sin ( rad2 / 2 ) NEW_LINE return ( c * r ) NEW_LINE DEDENT lat1 = 54.0000007 NEW_LINE lat2 = 54.0000007 NEW_LINE l1 = - 1.006 NEW_LINE l2 = - 1.006 NEW_LINE l1 = - 1.006 NEW_LINE l2 = - 1.006 NEW_LINE r1 = - 1.006 NEW_LINE print ( " % . KLM " , l1 ) NEW_LINE
def centeredOctalhedral ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 2 * n + 3 * n + 3 * n + 3 ) // 3 NEW_LINE DEDENT n = 3 NEW_LINE print ( centeredOctalhedral ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOctalhedral ( n ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def solve ( ) : NEW_LINE INDENT N , M , P = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE P = [ int ( input ( ) ) for _ in range ( M ) ] NEW_LINE P . sort ( ) NEW_LINE ans = 0 NEW_LINE cur = P [ 0 ] * N NEW_LINE cur += P [ 0 ] NEW_LINE cur += P [ 0 ] NEW_LINE cur += P [ 1 ] NEW_LINE cur += P [ 0 ] NEW_LINE ans = min ( ans , cur ) NEW_LINE while cur < N : NEW_LINE INDENT cur += P [ cur ] NEW_LINE cur += P [ cur ] NEW_LINE cur += P [ cur ] NEW_LINE cur += P [ cur ] NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT solve ( ) NEW_LINE
def SumDiv ( A , n ) : NEW_LINE INDENT max_val = max_val + 1 NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( max_val + 1 , 2 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( 2 * p , max_val , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if prime [ A [ i ] ] and sum % A [ i ] == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE SumDiv ( A , n ) NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE print ( ) NEW_LINE
def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT n = 56742474 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE s = s . strip ( '0' ) NEW_LINE a = s . count ( '1' ) NEW_LINE b = s . count ( '0' ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( ' red ' ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( ' red ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' red ' ) NEW_LINE DEDENT DEDENT
d = [ [ 0 for i in range ( 91 ) ] for j in range ( 901001 ) ] NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or b == 0 or b == 0 or b == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == 0 or b == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( d [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return d [ a ] [ b ] NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 or k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT d [ a ] [ b ] = ans NEW_LINE DEDENT dp [ 0 ] [ 0 ] = minimumNumberOfDigits ( a , b ) NEW_LINE if ( k == - 1 or k > 100 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( a > 0 and b > 0 or b > 0 or b > 100 ) : NEW_LINE INDENT for i in range ( 1 , 9 ) : NEW_LINE INDENT if ( a >= i * i * i ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE a -= i * i NEW_LINE b -= i * i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 18 NEW_LINE b = 162 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE DEDENT
N = 5005 NEW_LINE def Add_edge ( v , y ) : NEW_LINE INDENT gr = [ [ ] for i in range ( N ) ] NEW_LINE gr [ y ] . append ( y ) NEW_LINE gr [ y ] . append ( y ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT gr [ y ] . append ( y ) NEW_LINE DEDENT d = [ [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if i != gr [ i ] [ i ] : NEW_LINE INDENT d [ i ] [ j ] += d [ i - 1 ] [ j - 1 ] * d [ i - j ] [ k - 1 ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ i ] [ j ] += d [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 5 NEW_LINE k = 2 NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 1 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 1 , 0 ) NEW_LINE Add_edge ( 1 , 0 ) NEW_LINE Add_edge ( 2 , 0 ) NEW_LINE Add_edge ( 1 , 0 ) NEW_LINE Add_edge ( 2 ) NEW_LINE Add_edge ( 2 ) NEW_LINE Add_edge ( 1 , 0 ) NEW_LINE Add_edge ( 1 , 0 ) NEW_LINE Add_edge ( 2 ) NEW_LINE print ( ans ) NEW_LINE
def findSubsequence ( arr , n ) : NEW_LINE INDENT Len = 1 NEW_LINE temp = [ 0 ] * 10 NEW_LINE cntMax = arr [ 0 ] NEW_LINE locMax = arr [ 0 ] NEW_LINE locMax = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT temp [ i ] = 1 NEW_LINE temp [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] // 10 NEW_LINE locMax = 1 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT temp [ temp [ temp [ temp [ temp ] ] ] = 1 NEW_LINE temp [ temp [ temp [ d ] ] ] = locMax NEW_LINE DEDENT DEDENT for d in range ( 0 , 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dpMax = locMax NEW_LINE locMax = locMax NEW_LINE DEDENT DEDENT Len = max ( Len , locMax ) NEW_LINE return Len NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 64 , 94 , 94 , 94 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def totalPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT return count NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT if ( L % G != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L // G NEW_LINE return ( 1 << total ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total ▁ P ▁ LC ▁ G ▁ LCM ▁ M ▁ LCM ▁ M ▁ LCM ▁ G ▁ M ▁ LCM " , countPairs ( G , L ) ) NEW_LINE DEDENT
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * ( m + 1 ) / 2 NEW_LINE return ans NEW_LINE DEDENT a = 7 NEW_LINE N = 49 NEW_LINE print ( " Sum ▁ of ▁ multi ▁ of ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % ▁ % " % ( a , N , " ▁ " , calculate_sum ( a , N ) ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) . split ( ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE for i in s : NEW_LINE INDENT if ( k * m ) // 100 > 0 : NEW_LINE INDENT print ( i , s [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , s [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE
def next ( arr , target ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( arr ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( next ( arr , 8 ) ) NEW_LINE
word = [ " zero " , " one " , " one " , " one " , " one " , " two " , " one " , " two " , " three " , " four " , " eight " , " nine " , " n " , " one " , " twives " ] NEW_LINE def printWordsWithIfChanges ( n ) : NEW_LINE INDENT digits = [ 0 for i in range ( 10 ) ] NEW_LINE while n != 0 : NEW_LINE INDENT digits [ digits [ i ] ] = n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT for i in range ( digits - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( digits [ digits [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 350 NEW_LINE printWordsWithChanges ( n ) NEW_LINE
n , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE total = 0 NEW_LINE for i in a : NEW_LINE INDENT total += i NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT total += n * k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min = 0 NEW_LINE min = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] != ' + ' or a [ i ] != ' + ' ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max ) NEW_LINE DEDENT s1 = " a " NEW_LINE s2 = " + " NEW_LINE solve ( s1 , s2 ) NEW_LINE
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE s = 2 NEW_LINE s = 2 NEW_LINE print ( TotalWays ( n , s , k ) ) NEW_LINE
def countEvenOdd ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE if rem % 2 == 0 : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Even ▁ count ▁ : ▁ " , even_count ) NEW_LINE print ( " Even ▁ count ▁ : ▁ " , odd_count ) NEW_LINE DEDENT n = 2453607 NEW_LINE t = countEvenOdd ( n ) NEW_LINE if t == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE dp [ a ] . append ( b ) NEW_LINE DEDENT dp [ k ] = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] += a NEW_LINE DEDENT DEDENT dp = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] + dp [ i ] [ j ] ) NEW_LINE DEDENT print ( dp [ k ] [ k ] ) NEW_LINE
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] <= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif ( p [ i ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif ( p [ i ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return min ( min ( a , b ) , min ( c , d ) ) NEW_LINE DEDENT p = [ [ 1 , 1 , 2 ] , [ - 2 , 2 ] , [ - 2 , 2 ] ] ] NEW_LINE n = len ( p ) NEW_LINE print ( findmin ( p , n ) ) NEW_LINE
def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE primefactors = dict ( ) NEW_LINE primefactors [ 2 ] = 1 NEW_LINE for i in range ( 2 , int ( P ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( P % i == 0 ) : NEW_LINE INDENT primefactors . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT primefactors . append ( prime ) NEW_LINE DEDENT DEDENT if ( P != 1 ) : NEW_LINE INDENT if ( primefactors [ P ] == 1 ) : NEW_LINE INDENT if ( primefactors [ P ] == 0 ) : NEW_LINE INDENT primefactors [ P ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primeFactors [ P ] = ( prime , primefactors [ P ] // N ) NEW_LINE DEDENT DEDENT DEDENT lst = primeFactors [ P ] NEW_LINE for it in lst : NEW_LINE INDENT ans *= pow ( prime , prime ) NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 3 NEW_LINE P = 24 NEW_LINE print ( maxGCD ( N , P ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE mask = k >> 1 NEW_LINE mask = 0 NEW_LINE mask = 1 << mask NEW_LINE mask = 1 << mask NEW_LINE mask = 1 << mask NEW_LINE mask = mask << mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE print ( " % d : " % mask , mask ) NEW_LINE mask = mask & mask NEW_LINE for i in mask : NEW_LINE INDENT mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE DEDENT mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask NEW_LINE mask <<= mask
def primeFactorization ( curOfPf , primeFact , primeFact ) : NEW_LINE INDENT if ( curOfPf , primeFact ) : NEW_LINE INDENT print ( cur , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , arr [ cur ] , 1 , arrFact [ cur ] ) : NEW_LINE INDENT if ( cur == len ( primeFact [ cur ] ) ) : NEW_LINE INDENT print ( cur , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT def findDivisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE curr = primeFactors ( curr , arr ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( n // i ) NEW_LINE arr . append ( n ) NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT arr . append ( primeFactors ( 1 , n ) ) NEW_LINE DEDENT arr . append ( n ) NEW_LINE DEDENT if ( n > 1 ) : NEW_LINE INDENT arr . append ( n ) NEW_LINE DEDENT arr = 0 NEW_LINE curr = 1 NEW_LINE generateDivisors ( 1 , n ) NEW_LINE print ( arr [ curr ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] , a [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT s = max ( s , n - s ) NEW_LINE print ( n - s ) NEW_LINE
def largestPalin ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE print ( largestPalin ( s ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += s [ i ] NEW_LINE DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT a = [ ] NEW_LINE for i in a : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT a = prime ( ) NEW_LINE a = [ ] NEW_LINE for i in a : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT print ( a . count ( 1 ) ) NEW_LINE
def initializeDiffArray ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ 0 ] = 0 NEW_LINE D [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT def updateDiff ( D , D , x ) : NEW_LINE INDENT for i in range ( len ( D ) ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT for i in range ( len ( D ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT DEDENT print ( A [ 0 ] , A [ 1 ] , A [ 2 ] ) NEW_LINE updateDiff ( D , D , D ) NEW_LINE print ( A , D ) NEW_LINE
def findMaxGumps ( arr , start , end , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE gaps . sort ( ) NEW_LINE gap_ins = 1 NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arr [ i ] <= gap_ins ) : NEW_LINE INDENT gaps_ins = gaps_ins NEW_LINE if ( gaps_ins > gap_ins ) : NEW_LINE INDENT gaps_ins = gaps_ins NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT gaps_ins = gaps_ins NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ = ▁ " , max ( gaps_ins , time_ins ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 10 , 5 , 5 , 5 , 12 ] NEW_LINE removeMaxGumps ( arr , addMaxGumps ( arr , addMaxGumps ( arr , addMaxGumps , start , end , end ) ) NEW_LINE DEDENT
def solve ( s , t ) : NEW_LINE INDENT dp = [ [ 0 ] * len ( s ) for _ in range ( len ( t ) ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( len ( t ) ) : NEW_LINE INDENT if t [ i ] == t [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ : : - 1 ] NEW_LINE DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == ' END ' : break NEW_LINE t = s . find ( ' END ' ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if t [ i ] == s [ i ] : NEW_LINE INDENT t = s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT t = s [ i ] NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT
def calcConstruct ( n , r ) : NEW_LINE INDENT finalNegator = 1 ; NEW_LINE mx = max ( r , n - r ) ; NEW_LINE for i in range ( m + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) ; NEW_LINE numerator = pow ( i - mx , i - mx ) ; NEW_LINE DEDENT return finalNegator ; NEW_LINE DEDENT n = 6 ; r = 2 ; NEW_LINE print ( "1 / " , calcConstruct ( n , r ) ) ; NEW_LINE
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE k = 2 NEW_LINE isPerfectSquare ( n + k ) NEW_LINE
import sys NEW_LINE from collections import Counter NEW_LINE def solve ( N : int , A : " List [ int ] " ) : NEW_LINE INDENT A . sort ( ) NEW_LINE cnt = Counter ( A ) NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE A = [ int ( next ( tokens ) ) for _ in range ( N ) ] NEW_LINE solve ( N , A ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE flag = True NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if a [ i + 1 ] - a [ i ] == 1 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE SIZE = 105 NEW_LINE POW = [ 1 ] * SIZE NEW_LINE while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT POW [ N ] = POW [ N - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT POW [ i ] = int ( input ( ) ) NEW_LINE DEDENT POW [ N ] = POW [ N ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT POW [ i ] = POW [ i ] - 1 NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( " % d " % ( SIZE [ N - 1 ] ) ) NEW_LINE DEDENT
def isDivisible ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( S [ n - 1 ] != '5' and S [ n - 1 ] != '0' and S [ n - 1 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( S [ i ] ) NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT S = "156346" NEW_LINE if ( isDivisible ( S ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 10 NEW_LINE while True : NEW_LINE INDENT isSquare = eulerlib . list_square ( itertools . count ( itertools . count ( itertools . count ( itertools . count ( 1 ) ) ) ) ) NEW_LINE if sum != - 1 : NEW_LINE INDENT ans = sum ( ans ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT DEDENT def compute ( ) : NEW_LINE INDENT limit = 10 NEW_LINE while True : NEW_LINE INDENT limit = 10 NEW_LINE for a in itertools . count ( a ) : NEW_LINE INDENT for b in itertools . count ( 2 ) : NEW_LINE INDENT if ( a + b * b - a ) % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a - b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if x + y + y + y - y + z < limit : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * x - y ) // 2 NEW_LINE y = min ( y , limit - y ) NEW_LINE DEDENT DEDENT ans = str ( ans ) NEW_LINE return str ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' u ' or c == ' u ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countVowels = 0 NEW_LINE ans = " " NEW_LINE for l in range ( n - k + 1 ) : NEW_LINE INDENT countVowels += countVowels NEW_LINE DEDENT ans += str [ 0 ] * countVowels NEW_LINE ans += str ( countVowels * countVowels ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT
import math NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( int ( s [ i ] ) * m ) NEW_LINE DEDENT l . sort ( ) NEW_LINE if l [ 0 ] == l [ 0 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT print ( l [ i ] - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT ans = n // l [ 0 ] NEW_LINE if ans == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( l [ 0 ] ) : NEW_LINE INDENT ans = n // l [ 0 ] NEW_LINE if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( [ x , y ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] [ j ] == 9 : NEW_LINE INDENT for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT if 998244353 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE s = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : s . append ( s [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] [ j ] == '1' : ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n * n * n * n * n * n * n ) + ( 10 * n * n * n * n ) // 30 ) NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def maxLengthSub ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE start = 0 NEW_LINE map = dict . fromkeys ( arr , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = 0 NEW_LINE if arr [ i ] - 1 in map : NEW_LINE INDENT temp = temp NEW_LINE DEDENT if arr [ i ] in map : NEW_LINE INDENT temp = temp NEW_LINE DEDENT if arr [ i ] + 1 in map : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] + 1 ] ) NEW_LINE DEDENT temp += 1 NEW_LINE if temp > max_val : NEW_LINE INDENT max_val = temp NEW_LINE DEDENT map [ arr [ i ] ] = temp NEW_LINE DEDENT return max_val NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 5 , 6 , 3 , 7 , 5 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ length ▁ = ▁ " , maxLengthSubsequence ( arr , n ) ) NEW_LINE DEDENT
def rearrange ( arr ) : NEW_LINE INDENT if ( arr == None or len ( arr ) % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIndex = ( len ( arr ) - 1 ) // 2 NEW_LINE while ( currIndex > 0 ) : NEW_LINE INDENT countrIndex += 1 NEW_LINE arr [ currIndex + 1 ] = arr [ currIndex + 1 ] NEW_LINE arr [ currIndex + 1 ] = arr [ currIndex + 1 ] NEW_LINE arr [ currIndex + 1 ] = arr [ currIndex + 1 ] NEW_LINE arr [ currIndex + 1 ] = arr [ currIndex ] NEW_LINE DEDENT currIndex -= 1 NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE rearrange ( arr ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE arr [ i ] = arr [ i ] NEW_LINE rearrange ( arr ) NEW_LINE
INF = 1000000 NEW_LINE def main ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE if N == K == 0 : NEW_LINE INDENT return NEW_LINE DEDENT S = [ [ None ] * N for _ in range ( N ) ] NEW_LINE for _ in [ 0 ] * N : NEW_LINE INDENT s , d , c = map ( int , input ( ) . split ( ) ) NEW_LINE S [ s ] [ d ] = c NEW_LINE DEDENT q = [ [ ] for _ in range ( N ) ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT c , d , c = map ( int , input ( ) . split ( ) ) NEW_LINE Q [ i ] . append ( ( c , d ) ) NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if D [ i ] [ j ] + D [ i ] [ j ] > D [ i ] [ j ] + D [ i ] [ j ] : NEW_LINE INDENT q [ i ] [ j ] = i NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
def countCharacter ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE consonant = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = ord ( str [ i ] ) NEW_LINE if ( ch >= ' a ' or ch <= ' z ' or ch <= ' z ' or ch <= ' z ' ) : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT elif ( ch >= ' a ' or ch <= ' z ' or ch <= ' a ' or ch <= ' z ' ) : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT elif ( ch == ' a ' or ch <= ' z ' or ch <= ' u ' ) : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT print ( " Consual : " , consonant ) NEW_LINE print ( " Consual : " , consonant ) NEW_LINE print ( " Consual : " , consonant ) NEW_LINE print ( " Consual : " , consonant ) NEW_LINE print ( " Consual : " , consonant ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geeks ▁ for ▁ geeks " NEW_LINE countCharacter ( str ) NEW_LINE DEDENT
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( 1 + ( l // 100 ) * ( b // 100 ) ) * ( 1 + ( h // 100 ) ) NEW_LINE percent += ( 1 + ( h // 100 ) ) * 100 NEW_LINE return percentInc NEW_LINE DEDENT l , b , h = 50 , 20 , 10 , 10 NEW_LINE print ( " % % % % % % % % % % % % % % % % % % % % % % % % % % % % " ) NEW_LINE
def MaxTotalRectangles ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] == 1 ) and not ( a [ i + 1 ] == 1 ) ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i ] NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i + 1 ] == 1 ) and ( flag == 1 ) ) : NEW_LINE INDENT sum = sum + a [ i ] * len NEW_LINE DEDENT elif ( ( ( a [ i ] == a [ i + 1 ] or flag == 1 ) and ( flag == 1 ) and flag == False ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE i = i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 9 , 10 , 9 , 8 , 8 , 8 , 8 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangles ( a , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT new_node = Node ( new_node . data ) NEW_LINE new_node . prev = new_node . prev NEW_LINE new_node . prev = new_node NEW_LINE return head NEW_LINE DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT new_node . prev = new_node . next NEW_LINE new_node . prev = new_node NEW_LINE return head NEW_LINE DEDENT def reverseEnd ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT last_node . prev = None NEW_LINE last_node . prev = None NEW_LINE last_node . prev = None NEW_LINE last_node . prev = None NEW_LINE last_node . prev = None NEW_LINE last_node . prev = None NEW_LINE last_node NEW_LINE return head_node NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT last_node . prev = None NEW_LINE last_node . prev = None NEW_LINE last_node . prev = lastnode NEW_LINE last_node . prev = last_node NEW_LINE last_node . prev = last_node NEW_LINE last_node . prev = last_node NEW_LINE return last_node NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT last_node . prev = head NEW_LINE last_node . prev = head NEW_LINE last_node . prev = last_node NEW_LINE last_node . prev = last_node NEW_LINE last_node . prev = last_node NEW_LINE return last_node NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = head NEW_LINE head = head NEW_
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( n // 10000 + ( n // 10000 ) * 1000 + ( n % 100 ) * 1000 + ( n % 10 ) * 100 + ( n % 10 ) * 100 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( itertools . count ( 1 ) for it in itertools . count ( 2 ** itertools . count ( 1 ) ) for i in itertools . count ( 2 ** itertools . combinations ( itertools . count ( 2 ** itertools . count ( 2 ** itertools . count ( 2 ** itertools . combinations ( n , 2 ) , 2 ) ) ) ) for _ in range ( 10 ** itertools . count ( 2 ** itertools . count ( 2 ** itertools . count ( 2 ** itertools . count ( 2 ** itertools . count ( 2 ** itertools . count ( 2 ** itertools . count ( 2 ** itertools ) ) ) ) ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def compute ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Mathedt ▁ Exptime ▁ tt " ) NEW_LINE return NEW_LINE DEDENT elif ( n % 2 == 0 or n % 4 == 0 ) : NEW_LINE INDENT print ( " No ▁ Messhedt ▁ Exptime " ) NEW_LINE print ( n * n + 1 , " ▁ " , end = " ▁ " ) NEW_LINE print ( n * n + 1 , end = " ▁ " ) NEW_LINE print ( n , end = " ▁ " ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT print ( " Harmhedron " , end = " ▁ " ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT print ( " Harmhedron " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 22 NEW_LINE evaluate ( n ) NEW_LINE
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( b // x + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b // x + 1 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if rem != 0 : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE DEDENT
s = input ( ) . split ( ' , ' ) NEW_LINE a = s . split ( ' , ' ) NEW_LINE b = s . split ( ' , ' ) NEW_LINE c = s . split ( ' , ' ) NEW_LINE print ( a , b , c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT DEDENT b . append ( n - 1 ) NEW_LINE c . append ( n - 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if b [ i ] != a [ i + 1 ] : NEW_LINE INDENT ans = max ( ans , len ( b ) - i - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_zero = [ 0 ] * ( n + 1 ) NEW_LINE hash_zero [ 0 ] = 1 NEW_LINE hash_zero [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_zero [ - difference ] NEW_LINE hash_zero [ - difference ] += 1 NEW_LINE hash_zero [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_zero [ - difference ] NEW_LINE hash_zero [ - difference ] += 1 NEW_LINE hash_zero [ - difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total ▁ Number ▁ of ▁ Odd ▁ Subarrays ▁ are " , countSubarrays ( arr , n ) ) NEW_LINE
SIZE = 26 NEW_LINE def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT
def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 ; r = n - 1 ; leftGreater = n ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 ; NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT return ( n - leftGreater ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 13 , 13 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 7 ; NEW_LINE print ( countGreater ( arr , n , k ) ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE M = [ [ 0 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] ] NEW_LINE M [ 0 ] [ 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 , 0 ] , [ 0 , 1 , 1 ] ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 ] ] NEW_LINE M [ 1 ] [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] NEW_LINE M [ 1 ] [ 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 ] ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] NEW_LINE M [ 1 , 0 ] [ 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] NEW_LINE M [ 1 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE M [ 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 , 0 ] ] NEW_LINE M [ 1 , 0 , 0 , 0 ] = M [ 1 , 0 , 0 , 0 , 0 ] NEW_LINE M [ 1 , 1 ] [ 1 , 0 , 0 ] NEW_LINE for i in M : NEW_LINE INDENT for j in M : NEW_LINE INDENT M [ i ] [ j ] += M [
import math NEW_LINE def findAandBBinary ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if val < 0 : NEW_LINE INDENT return " NO " NEW_LINE DEDENT a = ( N + math . sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - math . sqrt ( val ) ) / 2.0 NEW_LINE print ( a , b ) NEW_LINE print ( b , a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 69.0 NEW_LINE findAandBinary ( N ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( a ) NEW_LINE DEDENT l . sort ( ) NEW_LINE if a > l [ 0 ] : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE f = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . count ( " X " ) > 1 : NEW_LINE INDENT f = 1 NEW_LINE DEDENT f = 1 NEW_LINE DEDENT if f == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def solve ( s , c ) : NEW_LINE INDENT dp = [ [ 0 ] * ( 10 + 1 ) for _ in range ( 10 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if s [ i ] == c [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j ] ) % 10 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if s [ i ] == c [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) % 10 NEW_LINE DEDENT DEDENT DEDENT DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == '0' : break NEW_LINE c = s . count ( '0' ) NEW_LINE a = s . count ( '0' ) NEW_LINE b = s . count ( '0' ) NEW_LINE c = s . count ( '0' ) NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if s [ i ] == ' ? ' : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ 10 ] ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c1 , c2 = 0 , 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE c2 += 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( c1 + c2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c2 + c1 ) NEW_LINE DEDENT DEDENT
def minIncrementForUnique ( A ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE ans = 0 NEW_LINE for x in A : NEW_LINE INDENT mpp . append ( x ) NEW_LINE DEDENT Modified = [ ] NEW_LINE ans += 0 NEW_LINE ans += 1 NEW_LINE ans += 1 NEW_LINE for x in mpp : NEW_LINE INDENT if ( mpp [ x ] >= 2 ) : NEW_LINE INDENT ans += x - 1 NEW_LINE DEDENT elif ( len ( unique ) > 0 ) : NEW_LINE INDENT ans += x - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 3 , 2 , 1 , 2 , 1 ] NEW_LINE print ( minIncrementForUnique ( A ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE mod = 1000000007 NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( pow ( 3 , n - 1 , mod ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pow ( 3 , n - 1 , mod ) ) NEW_LINE DEDENT
MOD = 10 ** 9 + 7 NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 13 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = i NEW_LINE dp [ i + 1 ] [ 0 ] % 13 NEW_LINE dp [ i + 1 ] [ 0 ] %= 13 NEW_LINE dp [ i + 1 ] [ 0 ] %= MOD NEW_LINE dp [ i + 1 ] [ 0 ] %= MOD NEW_LINE dp [ i + 1 ] [ 0 ] %= MOD NEW_LINE dp [ i + 1 ] [ 0 ] %= MOD NEW_LINE dp [ i + 1 ] [ 0 ] %= MOD NEW_LINE DEDENT DEDENT return dp [ n ] [ 1 ] NEW_LINE DEDENT s = "123" NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE
def countNums ( a , b , c , d , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // d NEW_LINE y = b // d NEW_LINE z = ( c * d - ( a - 1 ) // d ) NEW_LINE z = ( c * d - ( a - 1 ) // d ) NEW_LINE return a - x + 1 NEW_LINE DEDENT def countNums ( a , b , c , d , d ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return b - a + 1 - x + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 10 , 50 , 4 , 4 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE DEDENT
def printSubstrings ( n ) : NEW_LINE INDENT s = pow ( n , 10 ) ; NEW_LINE d = ( pow ( 10 , s ) + 0.5 ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( n // d ) ; NEW_LINE n = d // 10 ; NEW_LINE DEDENT n = n % 10 ; NEW_LINE d = k // 10 ; NEW_LINE DEDENT n = n % k ; NEW_LINE d = k // 10 ; NEW_LINE d = k // 10 ; NEW_LINE DEDENT DEDENT n = 123 ; NEW_LINE printSubstrings ( n ) ; NEW_LINE
def NthCharacter ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE for i in range ( 1 , 1 ) : NEW_LINE INDENT if ( c < 10 ) : NEW_LINE INDENT s += str ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT s += str ( c % 10 ) NEW_LINE dup = c NEW_LINE DEDENT DEDENT c += 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += str ( dup % 10 ) NEW_LINE dup //= 10 NEW_LINE DEDENT c += 1 NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT c += 1 NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT s += str ( s [ n - 1 ] ) NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT n = 11 NEW_LINE print ( NthCharacter ( n ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( ( a , b , c ) ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 3 == 0 : NEW_LINE INDENT A [ i ] , A [ i ] , A [ i ] , A [ i ] , A [ i ] , A [ i ] , A [ i ] , A [ i ] ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 3 == 0 : NEW_LINE INDENT A [ i ] , A [ i ] = A [ i ] , A [ i ] NEW_LINE DEDENT DEDENT print ( sum ( A ) - A [ i ] ) NEW_LINE DEDENT
def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimeFrequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] or check_prime ( s [ i ] ) == False ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( check_prime ( s [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE print ( countPrimeFrequent ( s ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c + 1 ) NEW_LINE
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 ] * ( n + 2 ) NEW_LINE catalan [ 0 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j - j - 1 ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 1 NEW_LINE for p in fractions . Fraction ( p - 1 , 1 ) : NEW_LINE INDENT tot = TARGET * ( p - 1 ) ** ( p - 1 ) NEW_LINE for i in range ( 2 , p , - 1 , - 1 ) : NEW_LINE INDENT tot += i NEW_LINE DEDENT DEDENT return str ( tot ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE x , y = s . count ( ' U ' ) , s . count ( ' D ' ) NEW_LINE c1 = s . count ( ' R ' ) NEW_LINE c2 = s . count ( ' D ' ) NEW_LINE c3 = s . count ( ' D ' ) NEW_LINE if ( c1 == 0 and c2 == 0 ) : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( N ) : NEW_LINE INDENT if ( isPrime ( N ) and isPrime ( N - 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 13 NEW_LINE if ( isPossible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countDck ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res // ( n + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Polyck ▁ Sack ▁ Sack ▁ is " , countDck ( n ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 30 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif n == 30 or n == 30 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif n == 30 or n == 30 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT print ( math . gcd ( a [ i ] , a [ i + 1 ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans += ( a [ i ] + a [ i ] ) // 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1.14 * a NEW_LINE DEDENT d = 1.12 * a NEW_LINE return d NEW_LINE DEDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1.73 * a NEW_LINE DEDENT d = 1.73 * a NEW_LINE return d NEW_LINE DEDENT a = 9 NEW_LINE print ( hexDiagonal ( a ) ) NEW_LINE
def translate ( string ) : NEW_LINE INDENT len = len ( string ) ; NEW_LINE if ( len < 2 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT i = 0 ; NEW_LINE j = 0 ; NEW_LINE while ( j < len - 1 ) : NEW_LINE INDENT if ( string [ j ] == ' A ' and string [ j + 1 ] == ' B ' and string [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j += 1 ; NEW_LINE string [ j + 1 ] = ' C ' ; NEW_LINE i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT if ( j == len - 1 ) : NEW_LINE INDENT string [ i ] = string [ j ] ; NEW_LINE i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT if ( j == len - 1 ) : NEW_LINE INDENT string [ i ] = string [ j ] ; NEW_LINE DEDENT string [ len ( string ) - 1 ] = ' C ' ; NEW_LINE DEDENT string = " " ; NEW_LINE print ( string ) ; NEW_LINE print ( " The ▁ modify ▁ string ▁ is : " , end = " " ) ; NEW_LINE print ( string ) ; NEW_LINE DEDENT string = " the ▁ BEGGGGGGGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGGGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGF
def translate ( string ) : NEW_LINE INDENT for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( string [ i - 1 ] == ' A ' and string [ i ] == ' B ' ) : NEW_LINE INDENT string [ i - 1 ] = ' C ' NEW_LINE j = i NEW_LINE while j < len ( string ) - 1 : NEW_LINE INDENT string [ j ] = string [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT string [ j ] = ' ▁ ' NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return " " . join ( string ) NEW_LINE DEDENT string = " ohabbaGabbaGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGFGGGGFGGFGGFGGGFGGFGGFGGFGGFGGFGGFGGFGGFGGGFGGGGGFGGGGGGGGGGGGFGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
def compute ( ) : NEW_LINE INDENT TARGET = 2 NEW_LINE TARGET = [ ] NEW_LINE for ring in range ( 2 , TARGET ) : NEW_LINE INDENT if ( ring * 6 - 1 ) > TARGET : NEW_LINE INDENT break NEW_LINE DEDENT if ( ring * 6 - 1 ) > TARGET : NEW_LINE INDENT TARGET . append ( ring * 3 + 1 ) NEW_LINE DEDENT DEDENT return str ( TARGET ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( b ) : NEW_LINE INDENT if ( i * j ) == a and ( i * j ) == b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE
def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , largest ) NEW_LINE DEDENT n = 2346 NEW_LINEDigits ( n ) NEW_LINE
def solve ( d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , d2 ) NEW_LINE sumx = ( d1 + d2 ) // 2 NEW_LINE if ( 2 * maxx > sumx or sum % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT x1 , y2 = d1 , d2 NEW_LINE x3 , y3 = d1 , d2 NEW_LINE y3 = d1 + d2 NEW_LINE y3 = ( d1 + d2 - d3 ) // 2 NEW_LINE print ( " ( " , x1 , " , ▁ " , y3 , " ) " ) NEW_LINE DEDENT d1 = 3 NEW_LINE d2 = 5 NEW_LINE d3 = 5 NEW_LINE solve ( d1 , d2 , d3 ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def distributeBases ( k , n , str ) : NEW_LINE INDENT a = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE str = " aaaab " NEW_LINE if ( distributeBases ( k , n , str ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = s . split ( ' M ' ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' M ' and s [ i ] == ' M ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( len ( s ) % 2 != 0 ) : NEW_LINE INDENT if ( s [ i ] == ' M ' ) : NEW_LINE INDENT b = 1 NEW_LINE DEDENT if ( s [ i ] == ' M ' ) : NEW_LINE INDENT b = 1 NEW_LINE DEDENT DEDENT if ( b == 0 and a == b ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT if a [ i ] == b [ i + 1 ] and a [ i + 1 ] == c [ i + 2 ] : NEW_LINE INDENT print ( " yes " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( " no " ) NEW_LINE
R = 4 NEW_LINE C = 4 NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( arr [ mid - 1 ] == 0 and arr [ mid - 1 ] == 1 ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] == 0 and arr [ mid - 1 ] == 1 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] == 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr [ mid ] , ( mid - 1 ) , ( mid - 1 ) , ( mid - 1 ) , ( mid - 1 ) , ( mid - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT def rowWith0 ( mat ) : NEW_LINE INDENT max_row = 0 NEW_LINE min_row = 0 NEW_LINE min_row = - 1 NEW_LINE min_row = - 1 NEW_LINE for i in range ( R ) : NEW_LINE INDENT index = first ( mat [ i ] , 0 ) NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT min_row = i NEW_LINE DEDENT else : NEW_LINE INDENT min_row = i NEW_LINE min_row = i NEW_LINE DEDENT if ( min_row > c ) : NEW_LINE INDENT min_row = c NEW_LINE min_row = i NEW_LINE DEDENT DEDENT print ( " Row ▁ of ▁ max : ▁ " , max_row ) NEW_LINE print ( " Row ▁ : " , max_row ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( " Row ▁ min : ▁ " , max_row ) NEW_LINE DEDENT
def bitAtGivenSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE for i in range ( 0 , n // 4 ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif s [ i ] == ' C ' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if a < b : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT
from __future__ import division , print_function NEW_LINE from sys import stdin , exit NEW_LINE def main ( readline = stdin . readline ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT lst = [ 0 ] * 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lst [ i ] = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE DEDENT for s in range ( n ) : NEW_LINE INDENT lst [ s ] = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT lst [ i ] [ j ] = ( lst [ i ] [ j ] , lst [ i ] [ j ] + lst [ i ] [ j ] ) / 4 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( lst [ i ] [ j ] * 3 ) NEW_LINE DEDENT print ( f ' { ans : .8f } ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT if l * i <= r : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( 2 , r + 1 ) : NEW_LINE INDENT if l * j <= r : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i + k <= n : NEW_LINE INDENT ans = i + k NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , 2 * k + k ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mul1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul2 *= a [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if arePermutations ( a , b , n , m ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def findAndPrintChar ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT l1 = len ( str2 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l2 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - 1 ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - 1 ] = 2 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " characters " NEW_LINE str2 = " alphab " NEW_LINE findAndPrintChar ( str1 , str2 ) NEW_LINE DEDENT
def isIn ( circle_x , circle , radius , rad , rad , rad , rad ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_x ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT circle_x = 1 NEW_LINE radius_x = 1 NEW_LINE radius_y = 1 NEW_LINE if isIn ( circle_x , radius_y , radius_x , radius_y ) : NEW_LINE INDENT print ( " In " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " In " ) NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible = - 1 NEW_LINE minimumDivisible = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minimumDivisible ) : NEW_LINE INDENT return sum NEW_LINE DEDENT DEDENT sum = sum - maximumDivisible + ( x * minimumDivisible // x ) NEW_LINE return minDivisible NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE
from collections import deque NEW_LINE q = int ( input ( ) ) NEW_LINE deq = deque ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = input ( ) NEW_LINE if query [ 0 ] == '0' : NEW_LINE INDENT deq . appendleft ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == '1' : NEW_LINE INDENT deq . appendleft ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == '2' : NEW_LINE INDENT deq . pop ( ) NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT deq . pop ( ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printInOrder ( node ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = temp NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def printInOrder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp . left = Node ( 0 ) NEW_LINE temp . right = Node ( temp [ 0 ] ) NEW_LINE if ( temp . left >= len ( temp ) or l > len ( temp ) ) : NEW_LINE INDENT return None NEW_LINE DEDENT root . left = Node ( temp [ 0 ] ) NEW_LINE if ( l == len ( temp ) ) : NEW_LINE INDENT return None NEW_LINE DEDENT root . right = Node ( temp [ 1 ] ) NEW_LINE if ( l == len ( temp ) ) : NEW_LINE INDENT return root . left NEW_LINE DEDENT root . left . right = Node ( temp [ 0 ] ) NEW_LINE if ( l == len ( temp ) ) : NEW_LINE INDENT return root . left NEW_LINE DEDENT root . right = Node ( temp [ 0 ] ) NEW_LINE root . left . right = Node ( temp [ 1 ] ) NEW_LINE root . right . left . right = Node ( temp [ 1 ] ) NEW_LINE root . right . left . right = Node ( l - 1 ) NEW_LINE root . right . right . right = Node ( l - 1 ) NEW_LINE root . right . right . right . right . right = Node ( l - 1 ) NEW_LINE root . right . right . right . right . size = Node ( r ) NEW_LINE root . right . right . right . right . size = Node ( r ) NEW_LINE root . right . right . right . right . right . size = Node ( root , 0 , len ( root ) ) NEW_LINE printInOrder ( root ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW
def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( " No ▁ such ▁ longest ▁ pair " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 for i in range ( len2 ) ] NEW_LINE hash_pat = [ 0 for i in range ( len2 ) ] NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ j ] ) ] += 1 NEW_LINE DEDENT start = 0 NEW_LINE min_len = 0 NEW_LINE min_len = - 1 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( pat [ j ] ) ] > hash_pat [ ord ( pat [ j ] ) ] or hash_pat [ ord ( pat [ j ] ) ] == 0 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ j ] ) ] -= 1 NEW_LINE DEDENT if ( min_len == len2 ) : NEW_LINE INDENT min_len = j NEW_LINE DEDENT DEDENT if ( min_len == len2 ) : NEW_LINE INDENT min_len = j - start NEW_LINE DEDENT if ( min_len > len_MAX ) : NEW_LINE INDENT min_len = len ( hash_pat ) NEW_LINE start = start - start + 1 NEW_LINE DEDENT if ( min_len > len_MAX ) : NEW_LINE INDENT min_len = len ( hash_pat [ start ] ) NEW_LINE DEDENT return " No ▁ thread ▁ = " NEW_LINE DEDENT str = " tgt ▁ is ▁ thread ▁ : " NEW_LINE print ( " No ▁ thread ▁ = " ) NEW_LINE print ( findSubstring ( str , len_len ) ) NEW_LINE
def cross ( a , b , c , d ) : NEW_LINE INDENT return a . real * b . imag - a . imag NEW_LINE DEDENT def cross ( a , b , c , d ) : NEW_LINE INDENT return ( a . real * b . imag - c * d ) NEW_LINE DEDENT def cross ( a , b , c , d ) : NEW_LINE INDENT return ( ( a . real * c ) - ( a . imag * c ) NEW_LINE DEDENT def cross ( a , b , c , d ) : NEW_LINE INDENT return ( ( a . real * b . imag ) * ( c - d ) ) * ( ( d - c ) ) NEW_LINE DEDENT def cross ( a , b , c , d ) : NEW_LINE INDENT return ( ( a . real * c ) * ( d - c ) ) * ( a . imag - c ) NEW_LINE DEDENT def cross ( a , b , c , d ) : NEW_LINE INDENT return ( ( a . real * c ) * ( d - d ) ) NEW_LINE DEDENT def cross ( a , b , c , d ) : NEW_LINE INDENT return ( ( a . real * b ) * ( c - d ) ) NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b , c , d = map ( float , input ( ) . split ( ) ) NEW_LINE p = cross ( p , b , c , d ) NEW_LINE p = cross ( p , p ) NEW_LINE p = cross ( p , p ) NEW_LINE p = cross ( p , p ) NEW_LINE p = cross ( p , p ) NEW_LINE p = cross ( p , p ) NEW_LINE p = cross ( p , p ) NEW_LINE if cross ( p . imag ( p ) < 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = set ( ) NEW_LINE for i in s : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT if m > n : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE def addPrimes ( n ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( n ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = v . get ( i ) NEW_LINE a = v . get ( i ) NEW_LINE while ( a != 0 and not flag ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a < c : NEW_LINE INDENT a += b NEW_LINE DEDENT if b < c : NEW_LINE INDENT b += c NEW_LINE DEDENT if a < c : NEW_LINE INDENT b += a NEW_LINE DEDENT print ( b + c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = min ( l ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = min ( ans , l [ i ] + 15 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def memo ( i , evenSum , oddSum , oddSum , oddSum , evenSum , oddSum , oddSum , oddSum , evenSum , oddSum , evenSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , evenSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum , oddSum ] NEW_LINE DEDENT def CountNum ( n ) : NEW_LINE INDENT v = [ [ ] for i in range ( 20 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE DEDENT d = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT for j in range ( len ( v ) ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT d = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE DEDENT d = v NEW_LINE ans = memo ( 0 , 0 , 0 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 2 NEW_LINE R = 10 NEW_LINE print ( CountNum ( L ) ) NEW_LINE DEDENT
def check_a3 ( a , b , c , d ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if a [ i ] [ j ] == b [ i ] [ j ] - b [ i ] [ j ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def check_a3 ( a , b , c , d ) : NEW_LINE INDENT if b == d : NEW_LINE INDENT return True NEW_LINE DEDENT if c == d : NEW_LINE INDENT return False NEW_LINE DEDENT if b == d : NEW_LINE INDENT return True NEW_LINE DEDENT if c == d : NEW_LINE INDENT return True NEW_LINE DEDENT if c == d : NEW_LINE INDENT return True NEW_LINE DEDENT if b == d NEW_LINE DEDENT if check_a3 ( a , b , c , d ) : NEW_LINE INDENT return True NEW_LINE DEDENT if check_a3 ( a , b , c , d ) : NEW_LINE INDENT return False NEW_LINE DEDENT if check_a3 ( a , b , c , d ) : NEW_LINE INDENT return True NEW_LINE DEDENT if check_a3 ( a , c , d , d , e ) : NEW_LINE INDENT return False NEW_LINE DEDENT if check_a3 ( a , b , d , e ) : NEW_LINE INDENT return True NEW_LINE DEDENT if check_a3 ( a , b , c , d , e ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b , c , d , e , e , f , e , f , e , f , e , f , e , f , e , f , e , f , e , f , f , e , f , f , e , f , e , f , f , e , f , e , f , f , e , f , f , e , f , e , f , f , e , f , f , e , f , e , f ,
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] += a [ i ] NEW_LINE DEDENT if s [ 0 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( str ( i ) ) ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def search ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = search ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ in ▁ array ▁ is ▁ : " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ in ▁ array " ) NEW_LINE DEDENT
n , c = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( a - b , b ) NEW_LINE DEDENT l . reverse ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , l [ i ] [ 0 ] - ( c - a ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , l [ i ] [ 0 ] - ( l [ i ] [ 1 ] - ( c - a ) ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def toggleBitsFromLFromR ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def unsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 * 8 - 1 ) ) - 1 NEW_LINE num = toggleBitsFromLFromR ( num , l , r ) NEW_LINE return ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( unsetBitsInGivenRange ( n , l , r ) ) NEW_LINE
def MinStep ( a , n ) : NEW_LINE INDENT positive = 0 ; neg = 0 ; zero = 0 ; NEW_LINE step = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 ; NEW_LINE step += 1 ; NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 ; NEW_LINE step += ( a [ i ] - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT negative += 1 ; NEW_LINE step += ( a [ i ] - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT step += ( a [ i ] - 1 ) ; NEW_LINE DEDENT DEDENT DEDENT if ( negative ) : NEW_LINE INDENT step = step + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 ; NEW_LINE DEDENT DEDENT return step ; NEW_LINE DEDENT a = [ 0 , - 2 , - 1 , - 3 , 4 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinStep ( a , n ) ) ; NEW_LINE
n , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s = s [ : : - 1 ] NEW_LINE print ( min ( s [ 0 ] , abs ( s [ - 1 ] ) ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE print ( l [ n - 2 ] + l [ n - 2 ] ) NEW_LINE DEDENT
from math import gcd NEW_LINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) NEW_LINE dy = abs ( y2 - y1 ) NEW_LINE ans = dx + dy - gcd ( dx , dy ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 , y1 , x2 , y2 = 1 , 4 , 3 NEW_LINE noOfSquares ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT
def get_maximum ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] [ 0 ] < a [ i ] [ 0 ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( s [ j ] [ 0 ] - ord ( '0' ) ) <= a [ j ] [ 0 ] ) : NEW_LINE INDENT s [ j ] = ( '0' + a [ j ] [ 0 ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT DEDENT s = "133713" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 6 , 1 , 3 , 1 ] NEW_LINE print ( get_maximum ( s , a ) ) NEW_LINE
MAX_MAX = 20 NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 NEW_LINE octal = [ 0 ] * MAX_MAX NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal [ i ] = n % divis NEW_LINE n = n // divis [ i ] NEW_LINE DEDENT for i in range ( i - 1 , j + 1 ) : NEW_LINE INDENT octal [ i ] = n % divis [ j ] NEW_LINE DEDENT for j in range ( i - 1 , j + 1 ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT n = 97 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE INDENT if s [ i ] == '4' or s [ i ] == '7' : NEW_LINE INDENT l . append ( int ( i ) ) NEW_LINE DEDENT DEDENT if l . count ( '4' ) == int ( n / 2 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( low + high ) / 2 NEW_LINE midValue = int ( mid + high ) / 2 NEW_LINE if ( midValue >= 0 ) : NEW_LINE INDENT return midValue NEW_LINE DEDENT midIndex = min ( midValue - 1 , lowIndex ) NEW_LINE if ( midIndex >= 0 ) : NEW_LINE INDENT return midIndex NEW_LINE DEDENT leftindex = min ( midValue + 1 , midIndex ) NEW_LINE rightindex = binarySearch ( arr , leftindex , midIndex ) NEW_LINE if ( left >= 0 ) : NEW_LINE INDENT return leftIndex NEW_LINE DEDENT rightindex = min ( mid + 1 , rightindex ) NEW_LINE leftindex = binarySearch ( arr , leftindex , midIndex ) NEW_LINE rightindex = binarySearch ( arr , leftindex , rightindex ) NEW_LINE return rightindex NEW_LINE DEDENT arr = [ - 10 , - 1 , - 1 , 2 , 2 , 2 , 3 , 10 , 30 , 50 , 50 , 50 , 50 , 50 , 50 , 50 , 50 , 50 , 50 ] NEW_LINE arr1 = [ - 10 , - 1 , 2 , 3 , 10 , 30 , 50 , 50 , 50 , 50 , 50 , 50 , 50 , 50 ] NEW_LINE arr1 = [ - 10 , - 1 , 10 , 30 , 50 , 50 , 50 , 50 , 50 , 50 , 50 , 50 , 50 , 50 ] NEW_LINE print ( " Finite ▁ Point ▁ is " , binarySearch ( arr1 , arr1 , len ( arr1 ) ) ) NEW_LINE
MAX = 10000 NEW_LINE def getDigitProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT prod = ( x % 10 ) * getDigitProduct ( x // 10 ) NEW_LINE return prod NEW_LINE DEDENT def findSeed ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if ( i * primeProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT res . append ( x % 10 ) NEW_LINE return ( res [ : : - 1 ] ) NEW_LINE DEDENT n = 13 NEW_LINE findSeed ( n ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT ans = min ( ans , abs ( x [ i + k - 1 ] - x [ i ] ) + abs ( x [ i + k - 1 ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( mid * mid * mid ) - n NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = n NEW_LINE while ( 1 ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE if ( mid <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE print ( " cubic ▁ root ▁ of " , n , " is " , spiralRoot ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = max ( a ) NEW_LINE a . sort ( ) NEW_LINE b = a . copy ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = max ( b , a [ i ] ) NEW_LINE b . sort ( ) NEW_LINE DEDENT print ( a [ - 1 ] , b [ - 1 ] ) NEW_LINE
def inv ( a , m ) : NEW_LINE INDENT m0 , t0 , q1 = 0 , 0 , 1 NEW_LINE x0 , t1 = 0 , 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t0 = t0 NEW_LINE t1 = t0 NEW_LINE t1 = t1 NEW_LINE t1 = t1 NEW_LINE t1 = t1 NEW_LINE DEDENT if ( x0 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT prod *= num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT prod *= num [ i ] NEW_LINE result += div ( prod [ i ] , num [ i ] ) * inv ( prod [ i ] , num [ i ] ) NEW_LINE DEDENT return result % prod NEW_LINE DEDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( " x ▁ is " , findMinX ( num , rem , k ) ) NEW_LINE
def findMaxOR ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT temp [ i ] , arr [ j ] = arr [ i ] , arr [ j ] NEW_LINE arr [ i ] , arr [ i ] = temp [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT maxOR = arr [ 0 ] NEW_LINE countOR = 1 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( maxOR | arr [ i ] ) > maxOR ) : NEW_LINE INDENT maxOR = maxOR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxOR ( arr , n ) ) NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def alqSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 12 NEW_LINE print ( alqSum ( n ) ) NEW_LINE
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) // 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( pentagon_pyramidal ( n ) ) NEW_LINE
def fifthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i * i ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT n = 6 NEW_LINE print ( fifthPowerSum ( n ) ) NEW_LINE
def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * ( i + 1 ) * ( 2 * i + 1 ) ) // 6 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT remainder = n % base NEW_LINE sum += remainder NEW_LINE n = n // base NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for base in range ( 2 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT sum += solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT n = 8 NEW_LINE SumOfDigits ( n ) NEW_LINE
import math NEW_LINE def solve ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans += n NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans += solve ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def bitCount ( 4 ) : NEW_LINE INDENT return bitCount ( 15 ) NEW_LINE DEDENT print ( bitCount ( 15 ) ) NEW_LINE print ( bitCount ( 15 ) ) NEW_LINE
import math NEW_LINE def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE cost [ i ] [ j ] = cost [ i ] [ j - 1 ] + ( freq [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def sum ( freq , freq , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , j + 1 ) : NEW_LINE INDENT c = i + L - 1 NEW_LINE if ( j < i ) : NEW_LINE INDENT cost [ i ] [ j ] = cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT def sum ( freq , freq , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( i + 1 , j + 1 ) : NEW_LINE INDENT if ( k < freq [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ i ] [ j ] NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT keys = [ 10 , 12 , 20 ] NEW_LINE freq = [ [ 34 , 8 , 20 ] , [ 34 , 50 , 50 ] ] NEW_LINE n = len ( keys ) NEW_LINE print ( " Cost ▁ OF ▁ BST ▁ BST ▁ BST ▁ BST ▁ BST ▁ is " , optimalSearchTree ( keys , freq , n ) ) NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * div + x NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 1 NEW_LINE y = 5 NEW_LINE z = 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT c += abs ( b [ i ] - b [ i + 1 ] ) NEW_LINE DEDENT print ( c ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def maxcocompitive ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , ( n + 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n + 1 ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE print ( maxcocompefficient ( n ) ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ch [ i ] == ' a ' or ch [ i + 1 ] == ' u ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abaef " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPowel ( s , n ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE s , t = map ( int , input ( ) . split ( ) ) NEW_LINE e = [ [ 0 ] * ( w + 1 ) for i in range ( h + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( w - i + 1 , 0 , - 1 ) : NEW_LINE INDENT if j + i < w : s [ i ] [ j + i ] += 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j + j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == M ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s1 = " for " in range ( " , s2 ) NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT
def angleOnccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
def countSubarray ( a , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE number1 = count1 NEW_LINE count1 = count0 NEW_LINE count1 = count0 NEW_LINE count1 = count0 NEW_LINE DEDENT else : NEW_LINE INDENT number1 += ( count0 + 1 ) // 2 NEW_LINE count0 = count0 NEW_LINE count0 = count0 NEW_LINE DEDENT DEDENT if ( count1 > 0 ) : NEW_LINE INDENT number1 += ( count0 + 1 ) // 2 NEW_LINE DEDENT if ( count0 > 0 ) : NEW_LINE INDENT number1 += ( count0 + 1 ) * ( count0 + 1 ) // 2 NEW_LINE count0 = count0 NEW_LINE DEDENT print ( " Count ▁ of ▁ subarr ▁ of ▁ 1 ▁ : " , number1 ) NEW_LINE print ( " Count ▁ of ▁ 1 ▁ of ▁ 1 ▁ : " , number1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countSubarray ( a , n ) NEW_LINE DEDENT
def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE
def printPermutation ( n , k ) : NEW_LINE INDENT mx = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = " ▁ " ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 3 NEW_LINE if K >= N - 1 : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in a : NEW_LINE INDENT if i [ 0 ] == a [ 1 ] [ 0 ] : NEW_LINE INDENT a . append ( i [ 1 ] + a [ 2 ] ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE
def check ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( mp [ s2 [ i ] ] > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = " geeksforgeeks " NEW_LINE s2 = " geeksforgeeks " NEW_LINE if ( check ( s1 , s2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' YES ' if n * ( n - a ) + b + c - d ) <= c else ' NO ' ) NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT
N = 3 NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j + 1 ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j + 1 ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j + 1 ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT tri = [ [ 1 , 0 , 0 ] , [ 1 , 2 , 3 ] ] NEW_LINE print ( maxPathSum ( tri , 2 , 2 ) ) NEW_LINE
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , ( n - 2 ) // 2 + 1 ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isHeap ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if ( i > ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ 2 * i + 2 ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 2 , n ) and isHeap ( arr , 2 * i + 2 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 90 , 15 , 10 , 10 , 7 , 12 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isHeap ( arr , 0 , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE def dot ( a , b ) : NEW_LINE INDENT return a * b + c * d NEW_LINE DEDENT a1 , b1 , c2 , c1 = map ( int , input ( ) . split ( ) ) NEW_LINE a1 , b2 , c1 , c2 = map ( int , input ( ) . split ( ) ) NEW_LINE b1 = a - b1 NEW_LINE b1 = b - a1 NEW_LINE if dot ( b1 , b1 ) == d or ( b1 , b2 ) == d : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
import sys NEW_LINE def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDel ( arr , n ) ) ; NEW_LINE DEDENT
def count ( x , y ) : NEW_LINE INDENT ans = 0 ; NEW_LINE m = dict ( ) ; NEW_LINE while ( x % y != 0 ) : NEW_LINE INDENT x = x % y ; NEW_LINE ans += 1 ; NEW_LINE if ( x in m ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT m [ x ] += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT res = count ( 1 , 2 ) ; NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res = count ( 5 , 3 ) ; NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT res = count ( 3 , 3 ) ; NEW_LINE res = count ( 3 , 5 ) ; NEW_LINE DEDENT
def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT arr = [ 40 , 50 , 90 ] NEW_LINE n = 3 NEW_LINE if ( isPossibleToMakeDivisible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] . append ( i ) NEW_LINE DEDENT B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT B . append ( int ( input ( ) ) ) NEW_LINE DEDENT B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT B . append ( B [ i ] ) NEW_LINE DEDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if B [ i ] [ j ] == B [ i ] : NEW_LINE INDENT dp [ i + 1 ] = B [ j ] NEW_LINE dp [ i + 1 ] = B [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if B [ i ] == B [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE dp [ i + 1 ] = max ( dp [ i ] , dp [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i * j + 1 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT print ( j * j * j , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT a = 1 NEW_LINE b = 100 NEW_LINE printCubes ( a , b ) NEW_LINE
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( n , d , " ▁ " , getModulo ( n , d ) , " is " , getModulo ( n , d ) ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n and arr [ j ] - arr [ i ] < d : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 4 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif i % 4 == 0 : NEW_LINE INDENT ans += 7 NEW_LINE DEDENT elif i % 4 == 1 : NEW_LINE INDENT ans += 7 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
from math import gcd NEW_LINE def isPerfectCubeCube ( x ) : NEW_LINE INDENT r = gcd ( x , 3 ) NEW_LINE return ( r * r == x ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE K = 1 NEW_LINE canPerfectCubeCube ( N + K ) NEW_LINE print ( " Yes " if canPerfectCubeCube ( N , K ) ) else " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s , t = input ( ) , input ( ) NEW_LINE res = n * 2 * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT res = n * 2 * n - i NEW_LINE break NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
class Graph : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . v = v NEW_LINE self . u = v NEW_LINE self . u = None NEW_LINE DEDENT def DFS ( u , v ) : NEW_LINE INDENT u = v NEW_LINE self . u = u NEW_LINE self . u = v NEW_LINE DEDENT def DFS ( u , v ) : NEW_LINE INDENT global u NEW_LINE u = [ ] NEW_LINE for i in u : NEW_LINE INDENT if not self . u : NEW_LINE INDENT u . append ( i ) NEW_LINE DEDENT DEDENT u . append ( u ) NEW_LINE DEDENT def DFS ( u , v ) : NEW_LINE INDENT global u NEW_LINE u . append ( v ) NEW_LINE DFS ( u , v ) NEW_LINE DFS ( u , u ) NEW_LINE DFS ( u , v ) NEW_LINE return u NEW_LINE DEDENT def DFS ( u , visited , visited , visited , visited , visited ) : NEW_LINE INDENT visited [ u ] = 1 NEW_LINE visited [ v ] = 1 NEW_LINE for u in u : NEW_LINE INDENT if not visited [ u ] : NEW_LINE INDENT visited . append ( u , visited , visited , visited ) NEW_LINE DEDENT DEDENT visited . append ( u , visited , visited , visited ) NEW_LINE DEDENT visited . append ( u , visited , visited , visited ) NEW_LINE print ( " First ▁ Di ▁ St ▁ Di ▁ Ststra : " , end = " ▁ " ) NEW_LINE print ( " \n Graph ▁ Di ▁ Ststra : " ) NEW_LINE DFS ( u , visited , visited , visited , visited , visited , edges ) NEW_LINE
def countDigits ( val , arr , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ digit ] = val % 10 NEW_LINE val = int ( val / 10 ) NEW_LINE DEDENT return NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = pow ( x , i ) NEW_LINE countDigits ( val , freq ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT val = pow ( x , i ) NEW_LINE countDigits ( val , freq ) NEW_LINE DEDENT for i in range ( 9 ) : NEW_LINE INDENT print ( freq [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = " NO " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans = " YES " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n - 2 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a += list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( " I ▁ hate ▁ it ▁ : ▁ " , b ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( " I ▁ love ▁ that ▁ " , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " I ▁ love ▁ that ▁ love ▁ that ▁ " , b ) NEW_LINE DEDENT
def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( 0 , n ) ] for j in range ( 0 , n ) ] NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ar [ i ] [ j ] != arr [ j ] [ j ] : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 0 , 0 , 0 ] , [ 10 , 1 , 0 , 22 , 23 ] , [ 40 , 44 , 22 , 55 , 68 ] , [ 80 , 75 , 75 , 140 , 140 ] ] NEW_LINE row = [ 10 , 9 , 22 , 23 , 55 , 140 ] , [ 100 , 75 , 140 , 140 , 140 , 140 ] , [ 100 , 75 , 140 , 140 , 140 , 140 ] ] NEW_LINE row = [ 10 , 9 , 22 , 140 , 140 , 140 ] NEW_LINE print ( linearCheck ( mat , row ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE c = 0 NEW_LINE s = s // n NEW_LINE if s % n == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE rl = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( rl ( ) ) NEW_LINE T = [ int ( rl ( ) ) for ri in rl ( ) . split ( ) ] NEW_LINE V = [ int ( rl ( ) - 1 for ri in rl ( ) ] NEW_LINE V . sort ( ) NEW_LINE V . reverse ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT v = V [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT v = V [ j ] NEW_LINE if v > ans : NEW_LINE INDENT ans = max ( ans , v ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 3 ) NEW_LINE DEDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) - 2 * n + 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x = abs ( a ) NEW_LINE y = abs ( b ) NEW_LINE if x >= y : NEW_LINE INDENT print ( ' - ' , 0 , 0 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , 0 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , 0 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , 0 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , 0 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , 0 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , 0 , - y ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , - y , 0 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , - 1 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , - 1 ) NEW_LINE DEDENT elif x >= y : NEW_LINE INDENT print ( ' - ' , 0 , - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - ' , 0 , - 1 , 0 ) NEW_LINE DEDENT DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE s = s [ : k ] NEW_LINE a = s [ k : ] NEW_LINE b = s [ k : ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT b += s [ i ] NEW_LINE DEDENT print ( a ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def fib ( self , N ) : NEW_LINE INDENT memo = [ 0 ] * ( N + 1 ) NEW_LINE memo [ N ] = 1 NEW_LINE for i in range ( len ( memo ) ) : NEW_LINE INDENT memo [ i ] = ( memo [ i - 1 ] + memo [ i - 2 ] + memo [ i - 2 ] ) NEW_LINE DEDENT for i in range ( len ( memo ) - 1 , N + 1 ) : NEW_LINE INDENT memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] NEW_LINE DEDENT return memo [ N ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE out = sObj . fib ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = input ( ) NEW_LINE a = s . replace ( ' a ' , ' b ' ) NEW_LINE b = s . replace ( ' c ' , ' a ' ) NEW_LINE c = s . replace ( ' c ' , ' a ' ) NEW_LINE b = s . replace ( ' c ' , ' b ' ) NEW_LINE c = s . replace ( ' c ' , ' a ' ) NEW_LINE print ( c ) NEW_LINE DEDENT
PI = 3.14159.0 NEW_LINE def cosXSessSumSumSumSumSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE fact = 1 NEW_LINE fact = 1 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT fact = fact * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE fact = fact * x * i NEW_LINE fact = fact * fact * x NEW_LINE DEDENT return res NEW_LINE DEDENT x = 50 NEW_LINE n = 5 NEW_LINE print ( round ( cosXSessSumSum ( x , 5 ) * 1000000 ) , end = " " ) NEW_LINE
def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( N * ( N + 1 ) / 4 ) ) - ( S + 1 ) - ( S + 1 ) / 2 ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = i ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( " No ▁ : " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT
def multipleOfThree ( K , digits , digits ) : NEW_LINE INDENT sum = 0 ; NEW_LINE temp = ( dig + digits ) % 10 ; NEW_LINE if ( K == 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT sum += dig ; NEW_LINE remofDigits = ( K - 3 ) % 10 ; NEW_LINE remofDigits = ( K - 3 ) % 10 ; NEW_LINE remofDigits = ( K - 3 ) % 10 ; NEW_LINE sum += ( numberofDigits * 10 ) ; NEW_LINE for i in remofDigits : NEW_LINE INDENT temp = ( 2 * temp ) % 10 ; NEW_LINE sum += temp ; NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT K = 5 ; dig = 4 ; NEW_LINE div = 4 ; NEW_LINE if ( multipleOfThree ( K , dig ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT K = 5 ; dig = 4 ; NEW_LINE dig = 4 ; NEW_LINE if ( multipleOfThree ( K , dig , dig ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE if a [ n - 1 ] + b [ n - 2 ] <= a [ n - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def countOcc ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT c = 0 NEW_LINE l = 0 NEW_LINE a = 0 NEW_LINE for j in range ( i + 1 , i + 4 ) : NEW_LINE INDENT c = c = 0 NEW_LINE l = 0 NEW_LINE for j in range ( i + 1 , i + 4 ) : NEW_LINE INDENT if ( s [ j ] == ' a ' ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( s [ j ] == ' a ' ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( c == ' a ' and l == 1 and p == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT if ( c == 1 and l == 1 and a == 1 and p == 1 and p == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT s = " clcpccc " NEW_LINE print ( countOcc ( s ) ) NEW_LINE
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return x // y NEW_LINE DEDENT return x // y + countSteps ( y , x % y ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 100 NEW_LINE y = 19 NEW_LINE print ( countSteps ( x , y ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPerfectSquareNum ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSurnyNum ( n ) : NEW_LINE INDENT sr = sqrt ( n + 1 ) NEW_LINE return ( ( sr - floor ) == 0 ) NEW_LINE DEDENT n = 3 NEW_LINE if isPerfectSquareNum ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( PI - H ) ) * ( PI / 4 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = 3 NEW_LINE B = 4 NEW_LINE H = 5 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE m = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ a ] NEW_LINE print ( b [ 0 ] , sep = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT b , c = map ( str , input ( ) . split ( ) ) NEW_LINE b [ 0 ] = c NEW_LINE DEDENT print ( b [ 0 ] ) NEW_LINE DEDENT DEDENT
def getCount ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - 1 NEW_LINE if ( tmp == v [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def getBound ( array , length , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( value >= array [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE v = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( getCount ( v , n ) ) NEW_LINE DEDENT
def trailing_zeros ( N ) : NEW_LINE INDENT count_two = 0 NEW_LINE count_two = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val //= 2 NEW_LINE count_two += i NEW_LINE count_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val //= 5 NEW_LINE count_two += i NEW_LINE count_five += i NEW_LINE DEDENT DEDENT ans = min ( count_two , count_five ) NEW_LINE return ans NEW_LINE DEDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 107 NEW_LINE if ( isEqual ( a , b ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
class One : NEW_LINE INDENT def __init__ ( self , n , e ) : NEW_LINE INDENT self . n = e NEW_LINE self . i = n NEW_LINE self . j = n NEW_LINE self . i = n NEW_LINE self . i = n NEW_LINE DEDENT def add ( self , i , x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT self . i -= 1 NEW_LINE self . j = i NEW_LINE DEDENT else : NEW_LINE INDENT self . j = x NEW_LINE DEDENT DEDENT def add ( self , i , x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT self . i = i NEW_LINE DEDENT else : NEW_LINE INDENT self . j = i NEW_LINE DEDENT DEDENT def add ( self , i , j ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT self . i = j NEW_LINE DEDENT else : NEW_LINE INDENT self . j = j NEW_LINE DEDENT DEDENT return self . i NEW_LINE DEDENT def add ( self , i , j ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT return self . i NEW_LINE DEDENT else : NEW_LINE INDENT self . i += self . n NEW_LINE DEDENT DEDENT DEDENT N = int ( input ( ) ) NEW_LINE E = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE if a == " A " : NEW_LINE INDENT E . append ( a ) NEW_LINE DEDENT elif a == " E " : NEW_LINE INDENT if b == " E " : NEW_LINE INDENT E . append ( b ) NEW_LINE DEDENT elif a == " E " : NEW_LINE INDENT if b == " E " : NEW_LINE INDENT E . append ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT E . append ( a ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b == " E " : NEW_LINE INDENT E . append ( b )
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE print ( l [ n // 2 ] ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = a - 1 NEW_LINE while a > 0 and b > 0 : NEW_LINE INDENT c += 1 NEW_LINE a -= 1 NEW_LINE DEDENT print ( c , a // 2 + b // 2 ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE print ( n % m , end = ' ▁ ' ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( n % m , end = ' ▁ ' ) NEW_LINE DEDENT
def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 for i in range ( 7 ) ] NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( ord ( s1 [ i ] ) ) : NEW_LINE INDENT if ( ord ( s2 [ i ] ) & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT arr2 [ j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( s2 ) ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT s1 = " geeks " NEW_LINE s2 = " geekeks " NEW_LINE print ( totalPairs ( s1 , s2 ) ) NEW_LINE
def countSubSeq ( i , sum , cnt , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 and cnt > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , sum , cnt , n ) NEW_LINE ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt , n ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 1 , 2 , - 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubSeq ( 0 , 0 , 0 , 0 , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT s [ j ] = s [ j ] NEW_LINE j += 1 NEW_LINE DEDENT print ( s [ : n ] ) NEW_LINE
a , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , 100000 ) : NEW_LINE INDENT x = i ** 0.5 NEW_LINE y = x % 10 NEW_LINE if y == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
def pivBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = 0 NEW_LINE if pivot == - 1 : NEW_LINE INDENT return pivot NEW_LINE DEDENT if pivot == - 1 : NEW_LINE INDENT return pivot NEW_LINE DEDENT if pivot == - 1 : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] >= arr [ pivot - 1 ] : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] >= arr [ pivot - 1 ] : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] >= arr [ pivot - 1 ] : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ pivot ] >= arr [ pivot - 1 ] : NEW_LINE INDENT return pivot - 1 NEW_LINE DEDENT if arr [ pivot ] >= arr [ pivot - 1 ] : NEW_LINE INDENT return pivot NEW_LINE DEDENT return binarySearch ( arr , n - 1 , ( n - 1 ) , arr [ pivot - 1 ] , arr [ pivot - 1 ] , arr [ pivot - 1 ] , arr [ pivot - 1 ] ) NEW_LINE DEDENT def binarySearch ( arr , n , key ) : NEW_LINE INDENT if arr [ 0 ] >= arr [ n - 1 ] : NEW_LINE INDENT return binarySearch ( arr , n - 1 , ( mid - 1 ) , arr [ mid ] , arr [ mid - 1 ] , arr [ mid - 1 ] , arr [ mid - 1 ] ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid - 1 ] : NEW_LINE INDENT return binarySearch ( arr , n - 1 , ( mid - 1 ) , arr [ mid ] , arr [ mid - 1 ] , arr [ mid - 1 ] , arr [ mid - 1 ] ) NEW_LINE DEDENT return binarySearch ( arr , n , key ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT if j - 1 >= i : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] * dp [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT DEDENT print ( dp [ n ] [ 0 ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE p . sort ( ) NEW_LINE ans = [ ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT ans . append ( str ( i ) + ' ▁ ' ) NEW_LINE i += 1 NEW_LINE DEDENT print ( len ( ans ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( ans [ i ] , ans [ i ] ) NEW_LINE DEDENT
def print_row ( n , d ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( " # " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( " # " , end = " " ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( " " ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT print ( " # " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE d = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE print_row ( d ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 << 10 ) : NEW_LINE INDENT for j in range ( i << 10 ) : NEW_LINE INDENT if i & ( 1 << j ) == 6 and j & 1 == 6 and j & 1 == 6 : NEW_LINE INDENT a = a | 1 NEW_LINE DEDENT DEDENT if a & 1 << i == 6 or a & 1 << 9 == 7 : NEW_LINE INDENT b = b & 1 NEW_LINE DEDENT if b & 1 << i == 6 or a & 1 << 9 == 7 : NEW_LINE INDENT a = a | 1 NEW_LINE DEDENT if b & 1 << 9 == 7 : NEW_LINE INDENT a = b | 1 NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE graph = defaultdict ( list ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a - 1 ] . append ( b - 1 ) NEW_LINE graph [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT def dfs ( v ) : NEW_LINE INDENT global graph NEW_LINE graph [ v ] [ v ] = 1 NEW_LINE return graph NEW_LINE DEDENT def dfs ( v ) : NEW_LINE INDENT global graph NEW_LINE graph [ v ] [ v ] = 1 NEW_LINE graph [ v ] [ v ] = 1 NEW_LINE return graph NEW_LINE DEDENT def dfs ( graph , visited , v ) : NEW_LINE INDENT if visited [ v ] : NEW_LINE INDENT graph [ v ] . append ( v ) NEW_LINE graph [ v ] . append ( v ) NEW_LINE return NEW_LINE DEDENT visited [ v ] = 1 NEW_LINE graph [ v ] . append ( v ) NEW_LINE return dfs ( graph , visited , v ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE graph = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT graph [ graph [ i ] [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT graph [ graph [ i ] [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT graph [ i ] . append ( graph [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " . join ( graph [ graph [ i ] ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT if s [ j ] == ' a ' or s [ j ] == ' c ' : NEW_LINE INDENT a . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT b = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] == ' a ' : NEW_LINE INDENT b . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] == ' a ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE
s = input ( ) NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if stack [ i ] == s [ i ] : NEW_LINE INDENT stack . append ( stack [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stack . append ( stack [ i ] ) NEW_LINE DEDENT DEDENT if stack : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE INF = float ( ' inf ' ) NEW_LINE def inp ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inpl_str ( ) : return list ( sys . stdin . readline ( ) . split ( ) ) NEW_LINE H , W , E = inpl ( ) NEW_LINE AB = [ [ ] for _ in range ( H ) ] NEW_LINE for i in range ( W ) : NEW_LINE INDENT x , y = inpl ( ) NEW_LINE AB [ x ] . append ( y ) NEW_LINE AB [ y ] . append ( x ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if AB [ i ] [ j ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if AB [ i ] [ j ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
MAX = 100 NEW_LINE def countChanges ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( i == 0 or j == n + 1 or j == n + 1 ) : NEW_LINE INDENT A [ i ] [ j ] = A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] and A [ i ] [ j + 1 ] > A [ i ] [ j + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] , [ 7 , 8 , 9 ] , [ 7 , 8 , 9 ] ] NEW_LINE n = 3 NEW_LINE print ( countChanges ( a , n ) ) NEW_LINE
N = 100005 NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT pre = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE pre [ i ] = ans NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT pre [ n ] = ans NEW_LINE DEDENT print ( pre [ n ] ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " a " : NEW_LINE INDENT a . append ( s [ 1 : ] ) NEW_LINE DEDENT elif s [ 0 ] == " e " : NEW_LINE INDENT b . append ( s [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( s [ 2 : ] ) NEW_LINE DEDENT DEDENT if len ( a ) == 1 : NEW_LINE INDENT print ( " HL " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " HL " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def area_of_triangle ( n , l ) : NEW_LINE INDENT P = ( l * n ) / ( 2 * pi * ( 2 * n ) * 3.14 / 180.14 / 180.14 ) NEW_LINE area = ( P * A ) / 2.14 NEW_LINE ans_triangle = area_triangle ( ( n , l ) ) NEW_LINE return ans_triangle NEW_LINE DEDENT n = 6 NEW_LINE le = area_of_triangle ( n , le ) NEW_LINE print ( area_of_triangle ( n , le ) ) NEW_LINE
MAX = 256 ; NEW_LINE def lastNonRepeating ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = ord ( str [ i ] ) ; NEW_LINE if ( freq [ ch ] == 1 ) : NEW_LINE INDENT return " + ch ; NEW_LINE DEDENT DEDENT return " - 1" ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " ; NEW_LINE n = len ( str ) ; NEW_LINE print ( lastNonRepeating ( str , n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( a ) NEW_LINE DEDENT l . sort ( ) NEW_LINE r = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == l [ i ] and l [ i ] == r [ i ] : NEW_LINE INDENT r = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT def CheleRule ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = ( b - a ) // n NEW_LINE h = ( 7 * y ( a - b ) + 12 * y ( a + b ) + 12 * y ( a + b ) + 12 * y ( a + b ) ) NEW_LINE Sum = Sum + h NEW_LINE return Sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " f " , CheleRule ( 0 , 4 ) ) NEW_LINE DEDENT
maxN = 300 NEW_LINE maxM = 300 NEW_LINE def findLen ( arr , i , curr , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT v = findLen ( arr , i + 1 , curr , curr , n , m ) NEW_LINE dp [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = l NEW_LINE dp [ i ] [ curr ] = l NEW_LINE dp [ i ] [ curr ] = l NEW_LINE dp [ i ] [ curr ] = l NEW_LINE dp [ i ] [ curr ] = l NEW_LINE dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE return dp [ i ] [ curr ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = findLen ( arr , 0 , ( 1 << 8 ) - 1 ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
maxN = 20 NEW_LINE maxM = 64 NEW_LINE def findLen ( arr , i , curr , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT v = findLen ( arr , i + 1 , curr , curr , n , m ) NEW_LINE l = findLen ( arr , i + 1 , curr , arr [ i ] , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , curr , arr [ i ] , curr ) NEW_LINE dp = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE return dp [ i ] [ curr ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = findLen ( arr , 0 , 0 , n , 1 ) NEW_LINE print ( 0 if ans == - 1 else print ( 0 ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE to = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE to [ a ] [ b ] = c NEW_LINE to [ b ] [ a ] = c NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT to [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if to [ i ] [ j ] > 0 : s += to [ i ] [ j ] NEW_LINE DEDENT DEDENT s += s - max ( to [ i ] [ j ] , s ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if s [ i ] == '3' or s [ i - 1 ] == '3' or s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT elif s [ i - 1 ] == '3' or s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT elif s [ i - 1 ] == '3' or s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT elif s [ i - 1 ] == '3' or s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT elif s [ i - 1 ] == '3' or s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT elif s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT elif s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 5 NEW_LINE DEDENT elif s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 5 NEW_LINE DEDENT elif s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 5 NEW_LINE DEDENT elif s [ i - 1 ] == '3' : NEW_LINE INDENT ans += 5 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = float ( ' inf ' ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 10 , 100 , 300 , 1000 , 1000 , 30 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minDiff ( arr , n , k ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE if n == 10 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c1 , n2 = 0 , 0 NEW_LINE while n - 1 >= i : NEW_LINE INDENT c2 += 1 NEW_LINE n += 1 NEW_LINE DEDENT if n - c1 > n : NEW_LINE INDENT c1 += 1 NEW_LINE n += c2 NEW_LINE DEDENT print ( c1 ) NEW_LINE DEDENT
def Mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum / n NEW_LINE DEDENT def meanAbsononic ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT absSum = abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 15 , 18 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsononic ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE primes = eulerlib . list_primality ( 100 , 10 ** 9 ) NEW_LINE ans = sum ( i for i in primes if i == LIMIT ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import log2 NEW_LINE def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( ( 2 ** ( 1 / ( 1 << i ) ) ) , 1 , l , 1 ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) ) : NEW_LINE INDENT if ( ( ( x > r ) or ( x + ( 1 << i ) ) ) ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT else : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT n = 7 NEW_LINE l = 23 NEW_LINE r = 23 NEW_LINE print ( " The ▁ output ▁ is " , maximumXOR ( n , l , r ) ) NEW_LINE
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ False ] * ( N + 5 ) ; NEW_LINE i = 3 ; NEW_LINE while i * i <= N : NEW_LINE INDENT if arr [ i ] : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT arr [ j ] = True ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE prime . append ( len ( prime ) ) ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE
def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ : : - 1 ] NEW_LINE bit1 = bin ( n ) [ : : - 1 ] NEW_LINE bit1 = bit [ : : - 1 ] NEW_LINE zero = bit1 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if bit1 [ i ] == '0' : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a + b , 2 * c , 2 * b , 3 * c ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def distinctSubstring ( P , Q , K , N , K ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE s += ord ( ' a ' ) NEW_LINE S . add ( s [ j ] ) NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT P = " abcde " NEW_LINE Q = 5 NEW_LINE K = 5 NEW_LINE N = len ( P ) NEW_LINE print ( distinctSubstring ( P , Q , K , N ) ) NEW_LINE DEDENT
def makeEven ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE even = sys . maxsize NEW_LINE even = [ ] NEW_LINE index = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( ord ( string [ i ] ) - ord ( '0' ) % 2 == 0 ) : NEW_LINE INDENT even . append ( ord ( string [ i ] ) - ord ( '0' ) ) NEW_LINE index = i NEW_LINE DEDENT if ( even <= ( n - 1 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( even <= ( ord ( string [ n - 1 ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( even <= ( ord ( string [ n - 1 ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( even == 10 ** 9 ) : NEW_LINE INDENT return string NEW_LINE DEDENT return " " . join ( string ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "1356425" NEW_LINE print ( makeEven ( string ) ) NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT divisors = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT divisors [ i * j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( divisors [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE findDivisors ( n ) NEW_LINE
s , t = input ( ) , input ( ) NEW_LINE s , t = input ( ) , input ( ) , 0 , 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT s += t [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s += t [ i ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def printDistinct ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE count [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = ord ( str [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 2 and x != i ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 and x != n ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE for i in range ( MAX_CHAR , MAX_CHAR + 1 ) : NEW_LINE INDENT print ( str [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE printDistinct ( str ) NEW_LINE DEDENT
def calculate ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE while k > 0 : NEW_LINE INDENT result = pow ( result , x ) NEW_LINE if ( result > m ) : NEW_LINE INDENT result %= m NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT x = 5 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE
def converthenonnum ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE res = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '5' or s [ i ] == '5' or s [ i ] == '9' or s [ i ] == '9' or s [ i ] == '9' ) : NEW_LINE INDENT res = s [ i ] NEW_LINE DEDENT DEDENT if len ( res ) == 2 or len ( res ) == 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif len ( res ) == 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT n = 18674 NEW_LINE converthenonnum ( n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE d = { } NEW_LINE for i in s : NEW_LINE INDENT d [ i ] = s . replace ( i , d [ i ] ) NEW_LINE DEDENT for i in d : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = * map ( int , s . split ( ) ) ; i = a = [ * map ( int , s . split ( ) ) ] ; i = 0 NEW_LINE while a [ i ] : i += 1 ; a [ i ] = a . pop ( i ) ; i += 1 NEW_LINE print ( * a ) NEW_LINE DEDENT
def sag ( n , m ) : NEW_LINE INDENT return ( n * ( 1 + m ) * ( n - 1 ) ) // 2 NEW_LINE DEDENT def transition ( n , m ) : NEW_LINE INDENT anserSum = 1 + ( n - 1 ) * ( m + 1 ) * ( n - 1 ) NEW_LINE anserSum = sser ( n , an ) NEW_LINE anserSum = sser ( n , anserSum ) NEW_LINE return anserSum + anserSum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE print ( transition ( N , M ) ) NEW_LINE DEDENT
import sys NEW_LINE import re NEW_LINE import array NEW_LINE import bisect NEW_LINE from collections import defaultdict NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import copy NEW_LINE import heapq NEW_LINE from functools import lru_cache NEW_LINE from itertools import accumulate NEW_LINE from operator import mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase NEW_LINE from fractions import gcd NEW_LINE from functools import reduce NEW_LINE from heapq import heappush , heappop NEW_LINE from functools import reduce NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE H , W = MAP ( ) NEW_LINE C = [ LIST ( ) for _ in range ( H ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT c = C [ i ] [ i ] NEW_LINE for j in range ( W ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT ans += c * ( H - 1 ) * ( W - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
from math import sqrt NEW_LINE def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( n // i == k ) ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( i * i == n ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + ( X + 48 ) % p NEW_LINE DEDENT res = findModuloByM ( X , N // 2 , M ) NEW_LINE res = ( temp * power ( 10 , N // 2 , M ) + p ) % M NEW_LINE return res NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) NEW_LINE res = ( half * power ( 10 , N // 2 , M ) + half * 10 + x ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) NEW_LINE res = ( half * power ( 10 , N // 2 , M ) + half * 10 + x ) % M NEW_LINE return res NEW_LINE DEDENT DEDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] %= 2 NEW_LINE DEDENT ans = ( d [ 0 ] * c [ 1 ] ) NEW_LINE ans = ( d [ 0 ] * d [ 1 ] ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT min_val = 10 ** 9 NEW_LINE max_val = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - i ) > max_val ) : NEW_LINE INDENT max_val = arr [ i ] - i NEW_LINE DEDENT if ( ( arr [ i ] - i ) < min_val ) : NEW_LINE INDENT min_val = arr [ i ] - i NEW_LINE DEDENT DEDENT return ( max_val - min_val ) NEW_LINE DEDENT arr = [ 9 , 15 , 4 , 4 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE l . append ( s ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == 0 or j == 0 or j == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 or j == 0 or j == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 or j == 0 or i == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if j == 0 or i == n - 1 or j == 0 or j == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if j == 0 or i == n - 1 or j == 0 or j == n - 1 or j == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 or j == n - 1 or j == 0 or j == 0 or j == 0 or j == 0 or j == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 or j == n - 1 or j == 0 or j == 0 or j == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 or j == 0 or j == n - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 or j == n - 1 or j == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 or j == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j - 1 ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if s % n == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def isKthBitSetBit ( n , k ) : NEW_LINE INDENT if ( ( n >> 1 ) & 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def allBitsSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSet ( n , k ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return False NEW_LINE DEDENT def bitsInAltSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSet ( n , len ( n ) ) NEW_LINE bit = num & ( ( 1 << bit ) - 1 ) NEW_LINE return bit & ( ( ( 1 << bit ) - 1 ) ) NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if bitsInAltSetBitSetSetSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetSetBitSetBitSetBitSetSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetBitSetSetBitSetSetSetBitSetBitSetBitSetBitSetBitSetLenSetBitSetBitSetSetLenSetBitSetBitSetLenSetLenSetLenSetLenSetLenSetLenInSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenInSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLenSetLen
def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return nCr ( 2 * n - x ) * factorial ( n - x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE x = 4 NEW_LINE y = 2 NEW_LINE print ( NumberOfWays ( n , x , y ) ) NEW_LINE DEDENT
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE print ( commonPrefix ( arr , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geeks " ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE DEDENT elif a [ i ] == 2 : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ans == n : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE a = 1 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT a = a + b NEW_LINE b = b NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if arr [ low ] == arr [ high ] : NEW_LINE INDENT freq [ low ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE findFrequencyUtil ( arr , low , high , freq ) NEW_LINE findFrequencyUtil ( arr , low , high , freq ) NEW_LINE findFrequencyUtil ( arr , low + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( arr [ n - 1 ] + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( arr [ n - 1 ] + 1 , arr [ n - 1 ] ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT print ( i , i , " ▁ times " , freq , " times " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 9 , 10 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 10 NEW_LINE totients = eulerlib . list_totients ( LIMIT - 1 ) NEW_LINE totients = 1 NEW_LINE for n in itertools . count ( len ( totients ) ) : NEW_LINE INDENT totients += totients [ n ] NEW_LINE totients += eulerlib . list ( totients [ n ] , totients ) NEW_LINE DEDENT if totients == 0 : NEW_LINE INDENT return str ( totients ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def intersection ( a , b , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 2 , 3 , 3 , 5 , 5 ] NEW_LINE b = [ 3 , 3 , 3 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE n = len ( b ) NEW_LINE m = len ( b ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 3 , 5 , 5 ] NEW_LINE m = len ( a ) NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE
def findMin ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT x = int ( sum / n ) ; NEW_LINE return x + 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( findMin ( a , n ) ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT minPerfectSquare = arr [ 0 ] NEW_LINE minPerfectSquare = lcmOfArray ( arr , n ) NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT return minPerfectSquare NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectSquare ( arr , n ) ) NEW_LINE DEDENT
def subarrayCount ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE high = 0 NEW_LINE high = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT high += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = high - low + 1 NEW_LINE DEDENT DEDENT if ( high != low ) : NEW_LINE INDENT length = high - low + 1 NEW_LINE result += len ( length - 1 ) // 2 NEW_LINE high = i NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subarrayCount ( arr , n ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 2 + 1 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE s = sum ( a ) NEW_LINE print ( s , a [ 0 ] , s , a [ 1 ] ) NEW_LINE
MAX_CHARS = 256 NEW_LINE def findSubstring ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = [ 0 ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ str [ i ] ] == False ) : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE DEDENT DEDENT start = 0 NEW_LINE min_count = 0 NEW_LINE min_count = 999999999 NEW_LINE min_count = 0 NEW_LINE min_count = 0 NEW_LINE min_count = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ i ] ) ] += 1 NEW_LINE if ( curr_count [ ord ( str [ i ] ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( curr_count [ ord ( str [ i ] ) ] == 1 ) : NEW_LINE INDENT min_count = curr_count [ ord ( str [ i ] ) ] NEW_LINE min_count = curr_count NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( min_count == MAX_count ) : NEW_LINE INDENT min_count = j - start + 1 NEW_LINE start = start - start + 1 NEW_LINE DEDENT return str [ start ] NEW_LINE DEDENT str = " aaabbcbbc " NEW_LINE print ( " Smallest ▁ each ▁ distinct ▁ strings ▁ is : ▁ " , findSubstring ( str ) , findSubstring ( str ) ) NEW_LINE
import math NEW_LINE a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( f - a // 100 , - c // 100 ) : NEW_LINE INDENT for j in range ( f - a // 100 , - c // 100 ) : NEW_LINE INDENT for k in range ( f - b // 100 , - c // 100 , - 1 ) : NEW_LINE INDENT for l in range ( f - a // 100 , - b // 100 , - c // 100 ) : NEW_LINE INDENT if l * 100 + l * 100 + l * 100 + l * 100 == c * 100 : NEW_LINE INDENT t = max ( t , a // 100 + l ) NEW_LINE DEDENT DEDENT DEDENT DEDENT t = t NEW_LINE DEDENT print ( int ( t ) , int ( t ) ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE from collections import deque NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT temp = [ ] NEW_LINE for s in input ( ) . strip ( ' , ' ) : NEW_LINE INDENT temp . append ( s ) NEW_LINE DEDENT temp . append ( s ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for s in stdin : NEW_LINE INDENT if s == ' , ' : NEW_LINE INDENT ans = s + s NEW_LINE DEDENT elif s == ' , ' : NEW_LINE INDENT ans = s NEW_LINE DEDENT elif s == ' , ' : NEW_LINE INDENT ans = s NEW_LINE DEDENT elif s == ' , ' : NEW_LINE INDENT ans = s + s NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT print ( even * ( n - 1 ) ) NEW_LINE print ( odd ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE countPairs ( arr , n ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT p , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE p = x % 10 NEW_LINE q = y // 10 NEW_LINE z = y * ( 10 ** p ) NEW_LINE z = x % 10 NEW_LINE if p > q : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT elif p > q : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT elif p > q : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] [ j ] == ' S ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif s [ i ] [ j ] == ' G ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if count == 0 : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 NEW_LINE back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ front ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 50 , 90 , 120 , 120 , 120 , 120 ] NEW_LINE x = 120 NEW_LINE n = len ( arr ) NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 10 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE
def MinCostTree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ ] NEW_LINE st . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( st [ len ( st ) - 1 ] <= arr [ i ] ) : NEW_LINE INDENT x = st [ len ( st ) - 1 ] NEW_LINE st . pop ( ) NEW_LINE ans += x * min ( st [ len ( st ) - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCostTree ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in d : NEW_LINE INDENT d [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in d : NEW_LINE INDENT if i not in d : NEW_LINE INDENT print ( i ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( len ( d ) ) NEW_LINE print ( * d [ s [ 0 ] ] , * d [ s [ 1 ] ] , sep = ' ▁ ' ) NEW_LINE
def findEquation ( a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ▁ = ▁ " , int ( " + str ( sum ) + " ) " , " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE findEquation ( a , b ) NEW_LINE DEDENT
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r * r ) - ( y1 * x1 ) NEW_LINE print ( " x ▁ = ▁ " + str ( a ) + " ▁ " + str ( b ) + " ▁ " + str ( c ) ) NEW_LINE print ( c + " . " + str ( b ) + " ▁ " + str ( c ) ) NEW_LINE DEDENT x1 = 2 NEW_LINE y1 = - 3 NEW_LINE r = 8 NEW_LINE circle_equation ( x1 , y1 , r ) NEW_LINE
def unique_combination ( l , sum , K , A ) : NEW_LINE INDENT if ( sum == K ) : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE for i in range ( l , len ( A ) ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT elif ( i != len ( A ) - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( A [ l ] , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) ) : NEW_LINE INDENT if ( sum + A [ i ] > K ) : NEW_LINE INDENT continue NEW_LINE DEDENT A . append ( A [ i ] ) NEW_LINE A . append ( A [ i ] ) NEW_LINE DEDENT DEDENT A = [ 10 , 1 , 2 , 7 , 6 , 1 ] NEW_LINE K = 8 NEW_LINE A . sort ( ) NEW_LINE unique_combination ( A , 0 , K , A ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE a . append ( k ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i NEW_LINE while j < n and a [ j ] <= a [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT print ( j ) NEW_LINE
import re NEW_LINE alphabets = re . compile ( r ' a \ , ' b ' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' g ' , ' g ' , ' r ' , ' g ' , ' r ' , ' s ' , ' t ' , ' u ' , ' v ' , ' w ' , ' x ' , ' y ' , ' z ' ] ) NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT s = alphabets [ s ] NEW_LINE for j in s : NEW_LINE INDENT if i not in s : NEW_LINE INDENT break NEW_LINE DEDENT s += chr ( ord ( s ) - 97 ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( a & 1 ) : NEW_LINE INDENT return ( b & 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return ( n % 3 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT return ( n - 1 ) % 3 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 1 ) % 3 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT a = 2 ; b = 4 ; n = 3 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = b - a NEW_LINE y = abs ( a - b ) NEW_LINE print ( min ( x , y ) ) NEW_LINE DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( 0 , a [ 1 ] ) NEW_LINE dp [ 2 ] = max ( 0 , a [ 1 ] ) NEW_LINE dp [ 2 ] = max ( 0 , a [ 1 ] ) NEW_LINE dp [ 2 ] = max ( a [ 2 ] , max ( 0 , a [ 1 ] ) ) NEW_LINE i = 3 NEW_LINE while i < n : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , a [ i - 3 ] + dp [ i - 3 ] ) NEW_LINE i += 1 NEW_LINE DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , - 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_sum ( arr , n ) ) NEW_LINE DEDENT
word = input ( ) NEW_LINE vowels = [ ' A ' , ' E ' , ' E ' , ' I ' , ' Y ' ] NEW_LINE s = word . lower ( ) NEW_LINE if s in vowels : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = float ( ' inf ' ) NEW_LINE for i in range ( 1 , int ( 1 / ( 1 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT mini = i NEW_LINE sec = n // i NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT mini = i NEW_LINE DEDENT num1 = int ( mini / k ) NEW_LINE res2 = int ( mini / k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = int ( mini / k ) NEW_LINE DEDENT num2 = int ( mini / k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = int ( mini / k ) NEW_LINE DEDENT num2 = int ( mini / k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = int ( mini / k ) NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT n = 4 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE for case in range ( 1 , n + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE b = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] == i : NEW_LINE INDENT ans += n NEW_LINE DEDENT else : NEW_LINE INDENT ans += n NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE b = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE b . sort ( ) NEW_LINE ans = solve ( n , b ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] == i : NEW_LINE INDENT ans += solve ( i , n ) NEW_LINE DEDENT DEDENT print ( " Case ▁ # % d : ▁ % d " % ( i , ans ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def SellingPrice ( C , P ) : NEW_LINE INDENT P_cost = 1 + ( P / 100 ) NEW_LINE res = P_cost * P NEW_LINE return res NEW_LINE DEDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lis = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lis . sort ( ) NEW_LINE a , b = lis [ - 1 ] , lis [ - 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] - a [ i - 1 ] == i - 1 : NEW_LINE INDENT b = lis [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT b = lis [ i - 1 ] NEW_LINE DEDENT DEDENT print ( ' ' . join ( b ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( N : int , S : int ) : NEW_LINE INDENT if N < S : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if N < S : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if N < S : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT if N < S : NEW_LINE INDENT return solve ( N - S ) NEW_LINE DEDENT else : NEW_LINE INDENT return solve ( N - S ) * solve ( N - S ) NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE S = int ( input ( ) ) NEW_LINE if N < S : NEW_LINE INDENT print ( solve ( N , S ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
def solve ( m , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , ( x // m ) * ( x // m ) + b ) NEW_LINE DEDENT return ans NEW_LINE DEDENT m , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( m , b ) ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE m = 10 ; NEW_LINE check ( n , m ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = " YES " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT ans = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a >= b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( str , input ( ) . split ( ) ) NEW_LINE s . append ( a ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] [ 0 ] == s [ j ] [ 0 ] : NEW_LINE INDENT s [ i ] , s [ j ] = s [ j ] , s [ i ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] [ 0 ] == s [ j ] [ 0 ] : NEW_LINE INDENT s [ i ] , s [ j ] = s [ j ] , s [ i ] [ 0 ] NEW_LINE DEDENT DEDENT DEDENT print ( s [ 0 ] , end = " " ) NEW_LINE DEDENT
def findNthOccur ( str , ch , N ) : NEW_LINE INDENT occurrence = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occurrence += 1 NEW_LINE DEDENT if ( occurrence == N ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT str = " geeks " NEW_LINE ch = " e " NEW_LINE N = 2 NEW_LINE print ( findNthOccur ( str , ch , N ) ) NEW_LINE
a , b , c , d , e , f , f , h , i , j , k = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b and c == 1 and f == 1 and i > 4 : NEW_LINE INDENT print ( ' Brown ' ) NEW_LINE DEDENT elif a == b and c == 1 and i > 4 : NEW_LINE INDENT print ( ' bear ' ) NEW_LINE DEDENT elif a == c and i > 1 and i > 1 and j < 4 : NEW_LINE INDENT print ( ' bear ' ) NEW_LINE DEDENT elif a == b and i < 3 : NEW_LINE INDENT print ( ' bear ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' bear ' ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE LIMIT = eulerlib . list_length ( LIMIT ) NEW_LINE partitions = eulerlib . list_length ( LIMIT ) NEW_LINE partitions . sort ( reverse = True ) NEW_LINE def sum_sqrt ( n ) : NEW_LINE INDENT partition = int ( LIMIT / ( n + 1 ) ) NEW_LINE for i in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT count = LIMIT // ( i + 1 ) NEW_LINE suffix = i * i % ( i + 1 ) NEW_LINE suffix = i * i % ( i + 1 ) NEW_LINE suffix = i * ( i + 1 ) NEW_LINE suffix = i * ( i + 1 ) NEW_LINE suffix = ( suffix + suffix ) % MOD NEW_LINE DEDENT return str ( suffix + i ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT for i in range ( 0 , z ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT for i in range ( 0 , z ) : NEW_LINE INDENT s += a [ i - 1 ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != i + 1 : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE c = 0 NEW_LINE i = 0 NEW_LINE while i < n and a [ i ] != i + 1 : NEW_LINE INDENT if i == n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT if a [ i ] - a [ i + 1 ] > a [ i + 2 ] : NEW_LINE INDENT c , i = i , i + 2 NEW_LINE DEDENT else : NEW_LINE INDENT c , i = 0 NEW_LINE DEDENT DEDENT if c == n - 1 : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , n - 1 ) NEW_LINE DEDENT
def f ( s ) : NEW_LINE INDENT return s [ 0 ] * 60 + s [ 1 ] NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if b [ i ] [ j ] <= 60 and b [ i ] [ j ] <= 60 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , c ) NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and p == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT p . append ( i + 1 ) NEW_LINE DEDENT for i in range ( len ( p ) ) : NEW_LINE INDENT if p [ i ] == p [ i ] : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE import numpy as np NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE n , q = map ( int , readline ( ) . split ( ) ) NEW_LINE A = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE for a in A : NEW_LINE INDENT cnt += a NEW_LINE A [ i ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for a in A : NEW_LINE INDENT ans += cnt NEW_LINE DEDENT print ( ans ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( int ( ( a - b ) / 10 ) ) NEW_LINE DEDENT
maxSize = 1005 NEW_LINE isFib = [ False ] * maxSize NEW_LINE prefix = [ 0 ] * maxSize NEW_LINE prefix [ 0 ] = 0 NEW_LINE prefix [ 1 ] = 1 NEW_LINE prefix [ prev ] = 1 NEW_LINE def generateFibonacci ( num ) : NEW_LINE INDENT s = 0 NEW_LINE prev = 0 NEW_LINE while num != 0 : NEW_LINE INDENT s = s + num % 10 NEW_LINE num = num % 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def generateFibonacci ( k ) : NEW_LINE INDENT generateFibonacci ( ) NEW_LINE prev = 0 NEW_LINE prev = 1 NEW_LINE prev = 1 NEW_LINE isFibonacci ( ) NEW_LINE prev = isFibonacci ( ) NEW_LINE while cur < maxSize : NEW_LINE INDENT temp = cur NEW_LINE if temp < maxSize : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = cur NEW_LINE DEDENT for i in range ( 1 , maxSize ) : NEW_LINE INDENT temp = digit + prev NEW_LINE if ( isFib [ i ] and sum % k == 0 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + prefix [ i - 1 ] NEW_LINE DEDENT prev = prefix [ i ] NEW_LINE DEDENT for i in range ( maxSize ) : NEW_LINE INDENT print ( prefix [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT query = [ [ 1 , 11 ] , [ 5 , 15 ] ] NEW_LINE q = 2 NEW_LINE query = [ [ 1 , 11 ] , [ 2 , 15 ] ] NEW_LINE query = [ [ 2 , 15 ] , [ 2 , 24 ] ] NEW_LINE query = [ 2 , 24 ] , [ 2 , 24 ] ] NEW_LINE query = [ 2 , 24 ] NEW_LINE query = [ 2 , 24 ] NEW_LINE query [ query [ i ] ] = [ 2 , 24 ] , [ 24 , 24 ] NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if ( a [ i ] != b [ i + 1 ] and a [ i ] != b [ i + 1 ] ) : NEW_LINE INDENT ans += abs ( a [ i ] - b [ i + 1 ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def isPalindrome ( string ) : NEW_LINE INDENT len = len ( string ) ; NEW_LINE for i in range ( len // 2 ) : NEW_LINE INDENT if ( string [ i ] != string [ len ( string ) - 1 - i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = " " ; NEW_LINE res_str = " " ; NEW_LINE res_str = " " ; NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 ; NEW_LINE sum = sub_str + sub ; NEW_LINE N = N // 10 ; NEW_LINE DEDENT while ( N > 0 ) : NEW_LINE INDENT res_str += sub ; NEW_LINE N = N // 10 ; NEW_LINE DEDENT return res_str ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10101 ; NEW_LINE if ( createStringAndPalindrome ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , d = input ( ) . split ( ) NEW_LINE a = int ( s [ 0 ] ) NEW_LINE b = int ( d ) NEW_LINE c = int ( d ) NEW_LINE if a == ' H ' : NEW_LINE INDENT if b == ' D ' : NEW_LINE INDENT if c == ' D ' : NEW_LINE INDENT if a == ' H ' : NEW_LINE INDENT if b == ' D ' : NEW_LINE INDENT a = ' D ' NEW_LINE DEDENT elif b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT DEDENT elif b == ' D ' : NEW_LINE INDENT if c == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT elif c == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT DEDENT if b == ' D ' : NEW_LINE INDENT if c == ' D ' : NEW_LINE INDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT DEDENT if b == ' D ' : NEW_LINE INDENT if c == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT b = ' D ' NEW_LINE DEDENT if b == ' D ' : NEW_LINE
def sum_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even : NEW_LINE INDENT return ' Sum ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ' , sum_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even : NEW_LINE INDENT print ( " Sum ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even ▁ even " , sum_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even_even : NEW_even_even_even_even_even_even_even_even_even_even_even_even : NEW_even_even_even_even_even_even : NEW_even_even
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT a = s [ : len ( s ) - 1 ] NEW_LINE b = s [ len ( s ) - 1 : ] NEW_LINE if a == b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 ; NEW_LINE fl = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % n ) >= n : NEW_LINE INDENT if ( arr [ i ] % n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE fl = 1 ; NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n ; NEW_LINE DEDENT if ( fl ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] % n ; NEW_LINE arr [ i ] % n = n ; NEW_LINE DEDENT if ( fl ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 6 , 3 , 1 , 1 , 3 , 6 , 6 ] ; NEW_LINE arr_size = len ( arr ) ; NEW_LINE printDuplicates ( arr , arr_size ) ; NEW_LINE
import math NEW_LINE n = int ( input ( ) ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += math . pi / ( n - i ) NEW_LINE DEDENT print ( result ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 1 ) // 3 NEW_LINE DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
def maxHandSide ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT n = 10 NEW_LINE print ( maxHandSide ( n ) ) NEW_LINE
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 2 == 1 ) : NEW_LINE INDENT return n / 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n / 4 - 1 ; NEW_LINE DEDENT DEDENT n = 20 ; NEW_LINE print ( possibleways ( n ) ) ; NEW_LINE
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT n = 21 NEW_LINE print ( CountSetBits ( n ) ) NEW_LINE
def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT
def Sum ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) ; NEW_LINE DEDENT sum = Sum ( n , m - 1 ) / 2 ; NEW_LINE return ( sum * ( sum + 1 ) / 2 ) ; NEW_LINE DEDENT n = 5 ; m = 3 ; NEW_LINE print ( " Sum ▁ : " , int ( " , n , " , ▁ " , int ( " , int ( n , m ) ) , " , Sum ( n , m ) ) ; NEW_LINE
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( maxLCM ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 1 ) ) // 12 NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def cntWays ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 ; NEW_LINE DEDENT DEDENT n = 18 ; NEW_LINE print ( cntWays ( n ) ) ; NEW_LINE
def find_composite ( n ) : NEW_LINE INDENT print ( 9 * n ) ; NEW_LINE DEDENT n = 4 ; NEW_LINE find_composite ( n ) ; NEW_LINE
def findThreeDigit ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 7 NEW_LINE print ( findThreeDigit ( n ) ) NEW_LINE
def countMaxIntersection ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) // 2 ) // 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( countMaxIntersection ( n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT n = 48 NEW_LINE print ( highestPowerOf2 ( n ) ) NEW_LINE
def countIntersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntersection ( n ) ) NEW_LINE
s = input ( ) NEW_LINE if s . isalpha ( ) : NEW_LINE INDENT print ( " a " ) NEW_LINE DEDENT elif s . isupper ( ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " a " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT
import sys NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE import bisect NEW_LINE import heapq NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE import itertools NEW_LINE import string NEW_LINE from fractions import gcd NEW_LINE import itertools NEW_LINE import copy NEW_LINE import heapq NEW_LINE import bisect NEW_LINE import random NEW_LINE import decimal NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 20 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE INF = 10 ** 18 NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LF ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def L ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def L ( ) : return list ( map ( str , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def L ( ) : return list ( map ( str , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def L ( ) : return list ( map ( str , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT N = I ( ) NEW_LINE print ( ' ABC ' if N < 1200 else ' ARC ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = min ( b [ i ] , a [ i + 1 ] ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = min ( b [ i + 1 ] , b [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = min ( b [ i ] , b [ i + 1 ] ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = min ( b [ i ] , b [ i + 1 ] ) NEW_LINE DEDENT for i in b [ n - 1 ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x != 0 and y != 0 and z != 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE DEDENT return c NEW_LINE DEDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE print ( " Minimum ▁ of ▁ 3 ▁ numbers ▁ is " , smallest ( x , y , z ) ) NEW_LINE
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE if a + b + c * 5 + d * 5 == a : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT
m , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( m - 1 ) * ( m - 1 ) / m ) NEW_LINE
def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( b ** ( a ** ( b ) ) - 1 ) + 1 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 28 NEW_LINE print ( " Count ▁ of ▁ cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE
d = [ [ 0 for j in range ( 1001 ) ] for i in range ( 1001 ) ] NEW_LINE d [ 0 ] [ 0 ] = 0 NEW_LINE d [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( 1001 ) : NEW_LINE INDENT if d [ j ] [ 2 ] : NEW_LINE INDENT d [ j ] [ 2 ] = min ( d [ j ] [ 2 ] , d [ j ] [ 2 ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( d ) : NEW_LINE INDENT for j in range ( 1001 ) : NEW_LINE INDENT if d [ i ] [ j ] > d [ i ] [ j ] : NEW_LINE INDENT d [ i ] [ j ] = d [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = d [ 0 ] [ 1001 ] NEW_LINE for i in range ( 1001 ) : NEW_LINE INDENT for j in range ( 1001 ) : NEW_LINE INDENT if d [ i ] [ j ] > d [ i ] [ j ] : NEW_LINE INDENT ans = d [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT triangle = eulerlib . sqrt ( 1 + eulerlib . sqrt ( 1 + eulerlib . sqrt ( 1 + eulerlib . sqrt ( 1 + eulerlib . sqrt ( 1 - euler_ ) ) ) ) NEW_LINE return triangle NEW_LINE DEDENT def count_divisors ( n ) : NEW_LINE INDENT triangle = 0 NEW_LINE end = 0 NEW_LINE while end < end : NEW_LINE INDENT end += 1 NEW_LINE DEDENT return str ( triangle ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findDuration ( a , b , c , d ) : NEW_LINE INDENT return ( b * c - a * d ) / ( d - c ) NEW_LINE DEDENT a = 3 NEW_LINE b = 9 NEW_LINE c = 3 NEW_LINE d = 5 NEW_LINE print ( " \n " , end = " " ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = True NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ p ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT n = 74 NEW_LINE findPrimePair ( n ) NEW_LINE
def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 ; NEW_LINE reciprocal = 1 ; NEW_LINE while ( x % 10 ) : NEW_LINE INDENT remainder = x % 10 ; NEW_LINE if ( remainder == d1 ) : NEW_LINE INDENT result = result + d2 * reciprocal ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * reciprocal ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT x = 645 ; d1 = 6 ; NEW_LINE d2 = 5 ; NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) ; NEW_LINE
def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i - 1 - i ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT N = 9 NEW_LINE printPattern ( 0 , 0 , 0 , n ) NEW_LINE
def getPairsCount ( n , sum ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT unique_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in hm [ arr [ i ] ] ) : NEW_LINE INDENT unique_count += hm [ arr [ i ] ] NEW_LINE DEDENT if ( sum - arr [ sum ] == arr [ i ] ) : NEW_LINE INDENT unique_count -= 1 NEW_LINE DEDENT DEDENT return unique_count // 2 NEW_LINE DEDENT sum = 6 NEW_LINE sum = 0 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is " , getPairsCount ( n , sum ) ) NEW_LINE
def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum += arr [ i ] NEW_LINE DEDENT for i in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ i ] NEW_LINE DEDENT if ( subarray_sum > remaining ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 10 , 9 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Count_subarray ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE m = min ( a , b ) NEW_LINE if m > a : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT print ( n - m if a > b else n - b - m ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE A . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 10 == 0 : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT DEDENT if ans % 10 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 10 == 0 : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in a : NEW_LINE INDENT ans = min ( ans , i + k ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , i + k ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def findRepeatingNumberNumber ( arr , n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) + 1 NEW_LINE range_LINE range_R = range ( n ) + 1 NEW_LINE range_R - 1 NEW_LINE range_R - 1 NEW_LINE range_R - 1 , - 1 , - 1 , - 1 , - 1 NEW_LINE for i in range ( range_R - 1 ) : NEW_LINE INDENT count = i NEW_LINE if ( count > sq ) : NEW_LINE INDENT rep_B = i NEW_LINE break NEW_LINE DEDENT DEDENT mp [ arr [ i ] ] = i NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( ( ( not ( i * sqrt ) ) and ( arr [ i ] <= arr [ i ] ) ) ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT mp [ arr [ i ] ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( ( ( i * sqrt + 1 ) ) and ( arr [ i ] in mp ) ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 , 5 , 4 ] NEW_LINE n = 5 NEW_LINE print ( " One ▁ of ▁ repeating ▁ in ▁ array ▁ array ▁ is ▁ : " , findRepeatingNumber ( arr , n ) ) NEW_LINE
from math import sqrt NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT n = 15 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE n = 259426 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE o = 0 NEW_LINE for i in a : NEW_LINE INDENT o += 1 NEW_LINE DEDENT print ( min ( o , o ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE c = s . count ( '1' ) NEW_LINE a = c . count ( '0' ) NEW_LINE b = c . count ( '1' ) NEW_LINE print ( min ( a , b ) ) NEW_LINE
def pythalanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , " , ▁ " , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ Triplet " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE pythalanTriplet ( n ) NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( math . floor ( abs ( a ) + math . log10 ( abs ( b ) ) + math . log10 ( abs ( a ) ) + 1 ) ) + 1 NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
def indexOfFirstOne ( arr , low , high ) : NEW_LINE INDENT mid = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == 1 and arr [ mid - 1 ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( arr [ mid ] == 1 and arr [ mid - 1 ] == 0 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid - 1 NEW_LINE DEDENT DEDENT return mid NEW_LINE DEDENT def posOfFirstOne ( arr , low , high ) : NEW_LINE INDENT l = 0 NEW_LINE h = 1 NEW_LINE while ( arr [ h ] == 0 ) : NEW_LINE INDENT l = h NEW_LINE h = 2 * h NEW_LINE DEDENT return indOfFirst ( arr , l , h ) NEW_LINE DEDENT arr = [ 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE print ( " Index ▁ = " , posOfFirstOne ( arr , l , h ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 2 + 1 ) NEW_LINE DEDENT
from itertools import chain NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans = " " NEW_LINE while n : NEW_LINE INDENT ans += " . join ( [ str ( n ) for n in chain ( 0 , 2 ** n ) ] ) NEW_LINE n -= n NEW_LINE if n == 0 : NEW_LINE INDENT print ( ans ) NEW_LINE continue NEW_LINE DEDENT ans = " " NEW_LINE while n : NEW_LINE INDENT ans += "0" * ( n - n ) NEW_LINE DEDENT print ( ans ) NEW_LINE n -= n NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE rem = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE sum += rem NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT n = 43 NEW_LINE print ( " x ▁ = " , findX ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += max ( ans , a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
h , n = map ( int , input ( ) . split ( ) ) NEW_LINE print ( h - n ) NEW_LINE
def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT L = i NEW_LINE R = R [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT L = i NEW_LINE R = R NEW_LINE if L != R and pref_xor [ R ] == pref_xor [ L - 1 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ 1 , 2 , 2 , 4 ] NEW_LINE performQueries ( A , q ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while i < n and a [ i ] <= a [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( j ) NEW_LINE
n = int ( input ( ) ) NEW_LINE r1 , r1 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( b ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = max ( b ) NEW_LINE d = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT d . append ( ( b * a + ( d [ i ] / b ) ) ) NEW_LINE DEDENT d . sort ( ) NEW_LINE print ( ' { : . 10f } ' . format ( d [ 0 ] ) ) NEW_LINE
def trapezetricPattern ( num ) : NEW_LINE INDENT firstHalf = 1 NEW_LINE secondHalf = 1 NEW_LINE numOfTwaces = 0 NEW_LINE for num in numOfTwaces : NEW_LINE INDENT for num in numOfTwaces : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT for num in range ( numOfTwaces + 1 , numOfTwaces + 1 ) : NEW_LINE INDENT print ( firstHalf + 1 ) NEW_LINE DEDENT for num in range ( 1 , numOfTwaces + 1 ) : NEW_LINE INDENT print ( firstHalf + " * " , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE numOfTwaces += 1 NEW_LINE DEDENT print ( ) NEW_LINE numOfTwaces ( num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT trapezinate ( 3 ) NEW_LINE trapezaces = ( 2 ) - ( ( n * 2 ) * 2 ) NEW_LINE twoHalf = ( 2 ) - ( ( n * 2 ) * 2 ) NEW_LINE twoHalf = ( 2 ) - ( ( n * 2 ) * 2 ) NEW_LINE twoHalf = ( twoHalf - 1 ) * 2 NEW_LINE print ( " " . join ( twoHalf ) ) NEW_LINE DEDENT
def findPerm ( n , difference ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( 0 ) NEW_LINE ans . append ( 0 ) NEW_LINE ans . append ( 0 ) NEW_LINE x = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT diff = diff + diff NEW_LINE ans . append ( x + diff ) NEW_LINE DEDENT ans . append ( 0 ) NEW_LINE ans . append ( 0 ) NEW_LINE for i in range ( 1 , n - 2 ) : NEW_LINE INDENT ans . append ( i + diff ) NEW_LINE DEDENT ans . append ( ans [ - 1 ] ) NEW_LINE ans . append ( i ) NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT ans . append ( m [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT ans . append ( m [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT ans . append ( m [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE differencePerm ( n , difference ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def printKInPrimes ( k , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE printKPrimes ( n ) NEW_LINE printKPrimes ( k , n ) NEW_LINE printKPrimes ( k , n ) NEW_LINE DEDENT
def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * 50 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( n ) : NEW_LINE INDENT x = int ( n ) NEW_LINE while x != 0 : NEW_LINE INDENT x = n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return str ( x ) NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT c = str ( n ) NEW_LINE while n != 0 : NEW_LINE INDENT c += str ( n ) NEW_LINE n //= 10 NEW_LINE DEDENT return c NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def norm ( m , n ) : NEW_LINE INDENT N = ( abs ( m ) * abs ( m ) ) / math . sqrt ( ( abs ( m ) * abs ( n ) ) + ( abs ( m ) * abs ( n ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = - 5 ; NEW_LINE n = 3 ; NEW_LINE print ( centered ( m , n ) ) ; NEW_LINE DEDENT
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = i / n NEW_LINE if i == 0 : NEW_LINE INDENT print ( h , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( h ) NEW_LINE DEDENT DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 65 NEW_LINE print ( countBits ( i ) ) NEW_LINE
H , W , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( H * W ) - ( ( H * a ) // a ) * ( W // b ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE T = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT if T [ j ] == i : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT arr2 = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] % k NEW_LINE DEDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE j = 0 NEW_LINE j = 0 NEW_LINE j = j NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr2 [ j ] == arr2 [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE j = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif m - n <= 1 : NEW_LINE INDENT print ( m + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + m - 1 ) NEW_LINE DEDENT
def isHucket ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " the ▁ the ▁ arrays ▁ and ▁ leap " NEW_LINE n = len ( s ) NEW_LINE if ( isHucket ( s , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ans [ i ] not in ans : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT return str ( ans [ : - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x2 , y2 , y ) : NEW_LINE INDENT if ( x > x and x < y and y < y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE y2 = 10 NEW_LINE x2 = 8 NEW_LINE y2 = 5 NEW_LINE if ( FindPoint ( x1 , y1 , x2 , y2 , y2 , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE MX = 3000 NEW_LINE def countPoints ( n , points ) : NEW_LINE INDENT minX = INT_MIN NEW_LINE minY = INT_MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT minX = INT_MAX NEW_LINE minY = INT_MAX NEW_LINE minY = INT_MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT minX [ i ] = INT_MIN NEW_LINE minY = INT_MAX NEW_LINE DEDENT minX = INT_MAX NEW_LINE minY = INT_MAX NEW_LINE x = INT_MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x [ i ] [ 0 ] == INT_MAX ) : NEW_LINE INDENT minX = INT_MAX NEW_LINE minY = INT_MAX NEW_LINE x = INT_MAX NEW_LINE DEDENT elif ( x [ i ] [ 1 ] < minX [ i ] [ 0 ] and x [ i ] [ 1 ] < minY ) : NEW_LINE INDENT if ( x [ i ] > minY [ x [ i ] and x [ i ] < minY ) : NEW_LINE INDENT minY = INT_MAX NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE if ( x > minY [ x ] and x [ y ] < minY [ x [ y ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT points = [ [ 0 , 0 , 1 ] , [ 0 , 1 ] ] NEW_LINE points = [ [ 0 , 1 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE n = len ( points ) NEW_LINE print ( countPoints ( n , points ) ) NEW_LINE DEDENT
from math import log2 NEW_LINE from fractions import gcd NEW_LINE from math import log2 NEW_LINE from itertools import accumulate NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE import bisect NEW_LINE import heapq NEW_LINE import itertools NEW_LINE import bisect NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE INF = float ( ' inf ' ) NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return list ( sys . stdin . readline ( ) . split ( ) ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ list ( S ( ) for i in range ( n ) ] NEW_LINE def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] NEW_LINE mod = 10 ** 9 + 7 NEW_LINE inf = float ( " inf " ) NEW_LINE x , y = LI ( ) NEW_LINE y = y * x // y NEW_LINE ans = 0 NEW_LINE while y > 1 : NEW_LINE INDENT x = y &
def countSticks ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "56" NEW_LINE n = len ( s ) NEW_LINE print ( countSticks ( s , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE a [ i + 1 ] = a [ i + 1 ] NEW_LINE DEDENT DEDENT print ( len ( b ) ) NEW_LINE print ( * a ) NEW_LINE DEDENT
def group ( arr , a , b ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= 1 NEW_LINE arr [ k + 1 ] ^= 1 NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= 1 NEW_LINE DEDENT for i in range ( 1 , n + 2 ) : NEW_LINE INDENT if ( arr [ k ] == 1 ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE group ( arr , 1 , 5 ) NEW_LINE group ( arr , 2 , 5 ) NEW_LINE result ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT max_count = 1 NEW_LINE max_count = 1 NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE
MAX = 26 NEW_LINE def maxLength ( st , length ) : NEW_LINE INDENT res = 0 NEW_LINE lastPos = [ 0 for i in range ( MAX ) ] NEW_LINE lastPos = - 1 NEW_LINE for i in range ( length ) : NEW_LINE INDENT lastPos [ ord ( st [ i ] ) - ord ( ' a ' ) ] = ord ( ' a ' ) NEW_LINE if lastPos [ ordPos [ ordPos [ ordPos [ ordPos [ ordPos [ C ] ] ] ) ] != - 1 : NEW_LINE INDENT res = max ( len - ( i - lastPos [ C ] ) , res ) NEW_LINE DEDENT lastPos [ ord ( lastPos [ ordPos [ ord ( lastPos [ C ] ) - 1 ] ) ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT st = " geeksforgeeks " NEW_LINE length = len ( st ) NEW_LINE print ( maxLength ( st , length ) ) NEW_LINE
MAX = 1000000 NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 for i in range ( MAX ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT b [ arr [ j ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k != 1 ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return sys . maxsize NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( ksmallest ( arr , n , k ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = int ( n / 100 ) NEW_LINE while ( ( ( n // 100 ) ) > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return ( n % 30 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2795 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( ( n // 100 ) ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT N = 59346 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = int ( n / 100 ) NEW_LINE while ( ( ( n // 100 ) ) > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 1922 ( N ) NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = int ( n / 100 ) NEW_LINE while ( ( ( n // 100 ) ) <= 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5041 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Even_Sum ( n ) : NEW_LINE INDENT total = int ( n + 1 ) / 2 NEW_LINE odd = int ( n / 2 ) NEW_LINE even = total * total NEW_LINE return odd NEW_LINE DEDENT def EvenToSum ( n ) : NEW_LINE INDENT total_sum = int ( n / 2 ) NEW_LINE even_sum = even * ( total + 1 ) NEW_LINE even_sum = even_Sum ( total_sum + 1 ) - even_sum NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 5 NEW_LINE print ( int ( sumLToSum ( L , R ) ) ) NEW_LINE DEDENT
def isRatioP ( lowCost , highCost , lowCost , high , r ) : NEW_LINE INDENT for i in range ( lowCost , high + 1 , 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= high ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 NEW_LINE lowCost = 15 NEW_LINE lowCost = 5 NEW_LINE lowCost = 5 NEW_LINE lowCost = 12 NEW_LINE r = 12 NEW_LINE if ( isRatioP ( lowCost , lowCost , highCost , high , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import log2 NEW_LINE def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( int ( log2 ( n ) / log2 ( 2 ) ) == ( log2 ( n ) ) == ( int ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT print ( " Yes " ) if isPowerOfTwo ( 31 ) else print ( " No " ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000 NEW_LINE LIMIT = 50000 NEW_LINE prime = [ 0 ] * LIMIT NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT for j in range ( i , LIMIT + 1 ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT ans = len ( prime ) NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT ans += prime [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT lenz = 0 NEW_LINE if arr [ i ] - 1 in um : NEW_LINE INDENT lenz = um [ i ] - 1 NEW_LINE DEDENT if lenz < um [ i ] : NEW_LINE INDENT lenz = um [ i ] + 1 NEW_LINE DEDENT if um [ arr [ i ] + 1 ] in um : NEW_LINE INDENT lenz = um [ arr [ i ] + 1 ] NEW_LINE DEDENT if lenz < um [ arr [ i ] ] : NEW_LINE INDENT lenz = um [ arr [ i ] + 1 ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Longest ▁ length ▁ = " , longLenSub ( arr , n ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all : " , calculateSum ( n ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] NEW_LINE curr_sum = diff NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT DEDENT return max ( curr_sum , max ( curr_sum ) ) NEW_LINE DEDENT arr = [ 80 , 2 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE
from collections import Counter NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : NEW_LINE INDENT break NEW_LINE DEDENT dp = [ 0 for i in range ( len ( s ) ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] += dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( len ( dp ) ) : NEW_LINE INDENT if dp [ i ] == 1 : NEW_LINE INDENT ans += dp [ i ] NEW_LINE DEDENT DEDENT print ( ans % MOD ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( n // 2 ) + 1 NEW_LINE max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import deque NEW_LINE def get_int ( ) : return int ( input ( ) ) NEW_LINE def get_int ( ) : return int ( input ( ) ) NEW_LINE def get_string ( ) : return input ( ) . strip ( ) NEW_LINE def get_string ( ) : return input ( ) . strip ( ) NEW_LINE def get_string ( ) : return input ( ) . strip ( ) NEW_LINE def get_string ( ) : return input ( ) . split ( ) NEW_LINE def string_string ( ) : return input ( ) NEW_LINE def string_string ( ) : return input ( ) NEW_LINE def string_string ( ) : return input ( ) NEW_LINE def string_string ( ) : return input ( ) . split ( ) NEW_LINE def string_string ( ) : return input ( ) NEW_LINE def string_string ( ) : return input ( ) NEW_LINE def string_string ( ) : return input ( ) NEW_LINE def string_string_string_string_string ( ) : return input ( ) NEW_LINE def string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_string_
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : a [ i ] = i NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : a [ i ] = i + b [ i + 1 ] NEW_LINE DEDENT p = [ 0 ] * ( n + 1 ) NEW_LINE q = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT q [ i ] = i + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if p [ i ] == q [ i + 1 ] : NEW_LINE INDENT q [ i ] = i + 1 NEW_LINE DEDENT DEDENT q . append ( q [ n ] - q [ i ] ) NEW_LINE ans = p [ n ] - q [ i ] NEW_LINE if q [ n ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
MAX = 100000 NEW_LINE def print ( g1 , a , b , b , b , b , n ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT print ( g1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def checksum ( g1 , a , b , b , b , b , n ) : NEW_LINE INDENT for i in range ( 0 , a ) : NEW_LINE INDENT x += g1 [ i ] NEW_LINE DEDENT for i in range ( 0 , b ) : NEW_LINE INDENT x -= g1 [ i ] NEW_LINE DEDENT for i in range ( 0 , b ) : NEW_LINE INDENT x -= g2 [ i ] NEW_LINE DEDENT for i in range ( 0 , b ) : NEW_LINE INDENT x -= g2 [ i ] NEW_LINE DEDENT return x NEW_LINE DEDENT def coproups ( arr , x , g1 , g2 , b , n ) : NEW_LINE INDENT if ( x == n ) : NEW_LINE INDENT print ( g1 , a , b , b , b , n ) NEW_LINE return NEW_LINE DEDENT g1 = [ x for x in x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE n = len ( g1 + 1 NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE g2 = arr [ x ] NEW_LINE n = len ( g2 ) NEW_LINE g2 . append ( g2 ) NEW_LINE g2 . append ( g2 ) NEW_LINE g2 . append ( g2 ) NEW_LINE g2 . append ( g2 ) NEW_LINE g2 . append ( g2 ) NEW_
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if a [ i ] + a [ j ] <= a [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] ) NEW_LINE
def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( vec [ i ] == 1 ) : NEW_LINE INDENT suffix += 1 NEW_LINE DEDENT if ( vec [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ 0 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( input ) NEW_LINE print ( maxSubseq ( input , n ) ) NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ i - 1 ] [ j ] == - 1 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i - 1 ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j - 1 ] + maze [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 ] ] NEW_LINE print ( countPaths ( maze ) ) NEW_LINE
from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True NEW_LINE arr = [ 7 , 11 , 13 , 19 , 23 , 23 , 29 , 29 , 29 , 31 , 30 , 31 , 30 ] NEW_LINE if N % 2 == 0 or N % 2 == 0 or N % 5 == 0 or N % 5 == 0 : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( 0 , int ) : NEW_LINE INDENT for c in range ( int ( sqrt ( N ) ) , int ( sqrt ( N ) ) , int ( sqrt ( N ) ) ) : NEW_LINE INDENT if c > 0 : NEW_LINE INDENT break NEW_LINE DEDENT if not isPrime : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if isPrime : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if isPrime : NEW_LINE INDENT print ( " Prime ▁ Number ▁ Number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime ▁ Number " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 121 NEW_LINE isPrime ( N ) NEW_LINE DEDENT
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE a = x2 - y1 NEW_LINE b = y1 - y2 NEW_LINE c = y2 - y1 NEW_LINE d = y1 - a NEW_LINE e = y1 - b NEW_LINE f = d - b NEW_LINE print ( f ' { e } ▁ { e } ▁ { e } ' ) NEW_LINE
def lps ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq ( i , j ) == suffix [ j ] ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq ( i , i + 1 , j - 1 ) ) : NEW_LINE INDENT return lps ( lps ( i , i + 1 , j - 1 ) + 2 ) NEW_LINE DEDENT return lps ( lps ( lps ( i , i + 1 , j - 1 ) , lps ( lps ( i + 1 , j - 1 , j ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GEEKSFORGEEKS " NEW_LINE n = len ( string ) NEW_LINE print ( " The ▁ length ▁ of ▁ LENGTH " , lps ( n - 1 , 0 , n - 1 ) ) NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT l = i NEW_LINE rsum = i NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while r < n and l >= 0 : NEW_LINE INDENT lsum += ord ( string [ l ] ) NEW_LINE rsum += ord ( '0' ) NEW_LINE DEDENT lsum += ord ( '0' ) NEW_LINE rsum += ord ( '0' ) NEW_LINE if lsum == rsum : NEW_LINE INDENT ans = max ( ans , rsum - lsum + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE rsum -= 1 NEW_LINE rsum += ord ( rsum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "123123123" NEW_LINE print ( " Length ▁ of ▁ substring ▁ is " , findLength ( string , len ( string ) ) ) NEW_LINE DEDENT
def print ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ " A " , " E " , " F " , " E " ] NEW_LINE n = 6 NEW_LINE print ( a , n , 3 ) NEW_LINE
def print ( a , n , ind ) : NEW_LINE INDENT b = [ 0 ] * ( ( 2 * n ) ) ; NEW_LINE for i in range ( ind ) : NEW_LINE INDENT b [ i ] = b [ i ] ; NEW_LINE DEDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT a = [ " A " , " E " , " F " , " E " , " F " ] ; NEW_LINE n = 6 ; NEW_LINE print ( a [ n ] , n , 3 ) ; NEW_LINE
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . split ( ) NEW_LINE b = int ( a ) NEW_LINE c = int ( b ) NEW_LINE d = int ( c ) NEW_LINE e = int ( d ) NEW_LINE f = int ( d ) NEW_LINE i = 0 NEW_LINE while i < n and s [ i ] == ' * ' : NEW_LINE INDENT if a == b : NEW_LINE INDENT f = 1 NEW_LINE DEDENT elif a == b : NEW_LINE INDENT if b : NEW_LINE INDENT c = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT elif b == c : NEW_LINE INDENT f = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if f : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if f : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( c ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a . append ( 0 ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] [ 0 ] == a [ i + 1 ] [ 1 ] : NEW_LINE INDENT a [ i ] [ 0 ] = a [ i + 1 ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT a [ i + 1 ] [ 0 ] = a [ i ] [ 1 ] NEW_LINE DEDENT DEDENT for i in a : NEW_LINE INDENT print ( ' . join ( i ) ) NEW_LINE DEDENT
import math NEW_LINE v1 , v2 , t1 , t2 = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ float ( " inf " ) ] * 10002 NEW_LINE dp [ 0 ] = v1 + v2 NEW_LINE for i in range ( 1 , t2 + 1 ) : NEW_LINE INDENT for j in range ( i , t1 + 1 ) : NEW_LINE INDENT if dp [ i - j ] [ i - 1 ] <= v2 : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - i ] , dp [ i - j ] [ i ] + v2 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ t ] [ t ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE a , b = sorted ( a ) , sorted ( b ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT DEDENT print ( n - a ) NEW_LINE
def resolve ( ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if a % 2 == 0 and b % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT resolve ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( "1 ▁ " * ( i - 1 ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE bin ( 131 ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000 ) if i % 3 == 0 or i % 5 == 0 or i % 5 == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' n ' : NEW_LINE INDENT print ( '1' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT r , g = LI ( ) NEW_LINE print ( r * 2 - g ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def CircCircular ( n ) : NEW_LINE INDENT result = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT result = result * n NEW_LINE n -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE
def productDiagonals ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] NEW_LINE product = product * arr [ n // 2 - i - 1 ] [ n // 2 - i - 1 ] NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT product = product // arr [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT return product NEW_LINE DEDENT arr1 = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 1 , 2 ] , [ 2 , 2 , 1 , 2 ] , [ 2 , 2 , 1 , 2 ] , [ 2 , 2 , 1 , 2 ] ] NEW_LINE print ( productDiagonals ( arr1 , 4 ) ) NEW_LINE arr2 = [ [ 2 , 1 , 2 , 1 , 2 , 1 ] , [ 2 , 2 , 2 , 1 , 2 ] , [ 2 , 2 , 1 , 2 ] , [ 2 , 2 , 1 , 2 ] ] ] NEW_LINE print ( productDiagonals ( arr2 , 5 ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT print ( ' - ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' + ' , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ' * ' , sep = ' ' ) NEW_LINE DEDENT DEDENT
NO_OF_CHARS = 256 NEW_LINE def getFirstMostFreq ( str ) : NEW_LINE INDENT count = [ 0 for i in range ( len ( str ) ) ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE second = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ first ] and count [ i ] != count [ 1 ] ) : NEW_LINE INDENT second = i NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ first ] and count [ i ] != count [ 1 ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE res = getFirstFreq ( str ) NEW_LINE if ( res != " ) : NEW_LINE INDENT print ( " Second ▁ most ▁ " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ most ▁ " , res ) NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = 100 NEW_LINE for i in range ( N // 500 ) : NEW_LINE INDENT for j in range ( i * 1000 + 1 ) : NEW_LINE INDENT if j * 1000 + i * 1000 + j * 1000 : NEW_LINE INDENT write ( " % d " % ( j , i * 1000 + j * 1000 + j * 1000 ) ) NEW_LINE DEDENT DEDENT DEDENT write ( " % d \n " % solve ( ) ) NEW_LINE DEDENT solve ( ) NEW_LINE
def mySort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE DEDENT arr = arr [ 5 , 4 , 6 , 2 , 1 , 1 , 8 , 7 ] NEW_LINE arr . sort ( ) NEW_LINE print ( " Modified ▁ : ▁ " , arr [ n ] ) NEW_LINE
def minflip ( arr1 , arr2 , arr3 , arr1 , arr2 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] > arr2 [ i ] and arr2 [ i ] > arr2 [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT if ( flip <= p + q ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p = 2 NEW_LINE q = 2 NEW_LINE n = len ( arr2 ) NEW_LINE print ( minflip ( arr1 , arr2 , arr2 , p , q , n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , sum ( n ) ) NEW_LINE
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE oddArr . append ( arr [ i ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE oddArr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE while ( len ( oddArr ) < len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( len ( oddArr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 2 , 7 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitArr = [ ] NEW_LINE bitArr ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE visited [ arr [ i ] ] = True NEW_LINE DEDENT while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] == False ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE i += 1 NEW_LINE DEDENT while ( left < right and visited [ arr [ left ] ] == False ) : NEW_LINE INDENT visited [ arr [ left ] ] = True NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
class Solution : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . leftData = rootData NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def preorder ( self , s ) : NEW_LINE INDENT tree1 = self . rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . left = None NEW_LINE DEDENT def preorder ( self , s ) : NEW_LINE INDENT if s == None : NEW_LINE INDENT return self . left NEW_LINE DEDENT else : NEW_LINE INDENT if s == None : NEW_LINE INDENT return self . left NEW_LINE DEDENT else : NEW_LINE INDENT return self . right NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return self . left NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = Solution ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right . left = TreeNode ( 4 ) NEW_LINE root . right . left . right = TreeNode ( 1 ) NEW_LINE root . right . right . right . right = TreeNode ( 2 ) NEW_LINE root . right . right . right . right . right . right = TreeNode ( 1 ) NEW_LINE out = sObj . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right NEW_LINE out = sObj . is None NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
M = 1001 NEW_LINE mod = 998244353 NEW_LINE dp = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT ans = solve ( ) NEW_LINE ans += ( M - 1 ) * solve ( dp [ idx ] [ diff ] + 1 , ans ) NEW_LINE dp [ idx ] [ diff ] = ans % mod NEW_LINE return ans % mod NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 0 NEW_LINE print ( solve ( 2 , 0 , N , M , K ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT n = len ( eulerlib . sqrt ( 1 << 30 ) ) NEW_LINE ans = float ( " inf " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 << ( i ) ) : NEW_LINE INDENT ans = min ( ans , abs ( 1 << ( 1 << i ) + eulerlib . sqrt ( 1 << i ) - 5 ) ** ( 1 / j ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] * a [ 2 ] ) % 3 == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE
def getTotalXOROfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
def getTotalXOROfSubarrayXOR ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXOROfSubarrayXOR ( arr , N ) ) NEW_LINE
l , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( l * p / ( p + q ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ n - 1 ] - a [ n - 1 ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE c = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] NEW_LINE b = chr ( 97 + 97 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = chr ( 97 + a [ i ] ) NEW_LINE DEDENT b [ 0 ] = chr ( 97 + 97 ) NEW_LINE for i in b [ : : - 1 ] : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT b [ 0 ] = chr ( 97 + a [ i ] ) NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT b [ 0 ] = chr ( 97 + b [ i ] ) NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT b [ 0 ] = chr ( 97 + a [ i ] ) NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT b [ 0 ] = chr ( 97 + b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT b [ 0 ] = chr ( 97 + a [ i ] ) NEW_LINE DEDENT DEDENT for i in b [ : : - 1 ] : NEW_LINE INDENT if i == len ( b ) : NEW_LINE INDENT print ( 0 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( b [ 0 ] ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE c = input ( ) NEW_LINE w = c . count ( " W " ) NEW_LINE w = c . count ( " W " ) NEW_LINE w . append ( w ) NEW_LINE c . append ( c ) NEW_LINE ans = min ( w ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = min ( ans , c [ i ] + w [ i + 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = 0 NEW_LINE odd = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if odd > odd : NEW_LINE INDENT print ( odd ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ 1 , 2 , 3 , 5 , 6 , 7 , 8 , 9 , 8 , 9 , 9 , 10 , 9 , 10 , 9 , 10 , 9 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] : NEW_LINE INDENT for j in range ( i * i , n , i ) : NEW_LINE INDENT l [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT l . sort ( ) NEW_LINE l . reverse ( ) NEW_LINE for i in l : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] - 1 ) % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT
def powerOfTwo ( n ) : NEW_LINE INDENT return ( ( n & n - 1 ) == 0 ) NEW_LINE DEDENT def allFirstAndLastSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE if ( allFirstAndLastSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimumCostOfLine ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE y = 1 NEW_LINE v . sort ( ) NEW_LINE h . sort ( ) NEW_LINE i , j , j , i , j = 0 , 0 , 0 , 0 , 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * y NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * h [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT total += Y [ i ] * h [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * y NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 6 NEW_LINE n = 4 NEW_LINE n = 4 NEW_LINE Y = [ 4 , 1 , 1 , 2 ] NEW_LINE print ( minimumCostOfLine ( X , Y , m - 1 , n - 1 ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( ( p % a == 0 ) and gcd ( a , p // a ) == G ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total ▁ possible ▁ pairs ▁ = " , countPairs ( G , L ) ) NEW_LINE print ( " ▁ " , countPairs ( G , L ) ) NEW_LINE
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ j ] * b [ j ] [ k ] NEW_LINE DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] + a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ [ 1 , 1 ] , [ 1 , 0 ] , [ 1 , 0 ] ] ] NEW_LINE power ( F , n // 2 ) NEW_LINE multiply ( F , M ) NEW_LINE multiply ( F , M ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT if n % 2 != 0 : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT return multiply ( F , N - 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( " F " , find ( 5 ) ) NEW_LINE
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def checkPossible ( self , nums ) : NEW_LINE INDENT gapPoint = 0 NEW_LINE for i in range ( 0 , len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT gapPoint += 1 NEW_LINE if gapPoint >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if i - 1 < 0 or nums [ i + 1 ] <= nums [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossible ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if array [ i ] > mid : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if sum > mid : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE end = 0 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if check ( mid , array , n , K ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( array ) NEW_LINE K = 3 NEW_LINE print ( solve ( array , n , K ) ) NEW_LINE DEDENT
def solve ( m , n , mask ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return mask NEW_LINE DEDENT if mask & mask == 0 : NEW_LINE INDENT return mask NEW_LINE DEDENT m ^= mask NEW_LINE mask = m & mask NEW_LINE mask = m & mask NEW_LINE mask = m & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask << mask = mask NEW_LINE mask = mask & mask NEW_LINE mask = mask & mask NEW_LINE mask << mask = mask & mask NEW_LINE mask << mask << mask NEW_LINE mask << mask = mask & mask NEW_LINE mask << mask << mask NEW_LINE mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask << mask << mask << mask << mask << mask NEW_LINE mask << mask << mask << mask <<
for s in [ * open ( 0 ) ] [ 1 : ] : a , b = map ( int , s . split ( ) ) ; print ( min ( a + b , b + a , b ) * ( a + b , b ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] - b [ i ] ) < a [ i ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '4' ) : NEW_LINE INDENT return " Even " NEW_LINE DEDENT else : NEW_LINE INDENT return " Even " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 735 NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE S = deque ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT S . append ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == 1 : NEW_LINE INDENT print ( * S , sep = ' ▁ ' ) NEW_LINE DEDENT elif query [ 0 ] == 2 : NEW_LINE INDENT print ( * S , sep = ' ▁ ' ) NEW_LINE DEDENT elif query [ 0 ] == 2 : NEW_LINE INDENT print ( sep = ' \n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sep = ' \n ' ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE DEDENT DEDENT for i in b : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( len ( b ) ) NEW_LINE
def solve ( X , Y , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( count [ i ] - count [ j ] ) > K : NEW_LINE INDENT j += 1 NEW_LINE DEDENT while ( count [ i ] - count [ j ] > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , i - j ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE Y = " abcd " NEW_LINE K = 3 NEW_LINE print ( solve ( X , Y , N , K ) ) NEW_LINE DEDENT
import fractions NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT ans = " Yes " if n % 2 == 0 else " No " NEW_LINE print ( ans ) NEW_LINE
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n , 2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
def isPrime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 6 NEW_LINE print ( minimumCost ( n ) ) NEW_LINE
def snuke ( x ) : NEW_LINE INDENT rightOne = x & - x NEW_LINE nextOne = x & - x NEW_LINE if ( x > 0 ) : NEW_LINE INDENT rightOne += rightOne NEW_LINE rightOne += rightOne NEW_LINE rightOne += rightOne NEW_LINE DEDENT return nextOne NEW_LINE DEDENT x = 156 NEW_LINE print ( " Next ▁ number ▁ of ▁ set ▁ with ▁ set ▁ set ▁ " , snuke ( x ) , snuke ( x ) ) NEW_LINE
def properDivisSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i / j == j ) : NEW_LINE INDENT sum += j ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += j ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT sum += j ; NEW_LINE DEDENT DEDENT sum = sum - i ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( properDivisSum ( n ) ) ; NEW_LINE n = 5 ; NEW_LINE print ( properDivisSum ( n ) ) ; NEW_LINE n = 5 ; NEW_LINE print ( properDivisSum ( n ) ) ; NEW_LINE n = 5 ; NEW_LINE print ( properDivisSum ( n ) ) ; NEW_LINE n = 5 ; NEW_LINE print ( properDivisSum ( n ) ) ; NEW_LINE n = 5 ; NEW_LINE
import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = sys . maxsize ; result = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinLength ( arr , n ) ) ; NEW_LINE
def getLevenKat ( input ) : NEW_LINE INDENT rev = [ ' ' for i in range ( len ( input ) ) ] NEW_LINE n = len ( reverse ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ord ( input [ i - 1 ] ) == ' ? ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT res = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = " showLevenKateks " NEW_LINE print ( getLevenKatank ( input ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 12000 NEW_LINE factors = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT factors [ min ] = min ( factors [ i ] , i ) NEW_LINE DEDENT factors [ LIMIT ] = 0 NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT factors [ i ] = factors [ i - 1 ] NEW_LINE DEDENT factors [ LIMIT ] = 0 NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT factors [ LIMIT ] = i NEW_LINE DEDENT for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT factors [ LIMIT ] = i NEW_LINE if LIMIT > LIMIT and factors [ LIMIT ] > LIMIT : NEW_LINE INDENT factors [ LIMIT ] = i NEW_LINE DEDENT DEDENT for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT if factors [ LIMIT ] > LIMIT and factors [ LIMIT ] > LIMIT : NEW_LINE INDENT factors [ LIMIT ] = i NEW_LINE factors [ LIMIT ] = i NEW_LINE DEDENT DEDENT for i in range ( LIMIT + 1 ) : NEW_LINE INDENT if factors [ LIMIT ] > LIMIT and factors [ LIMIT ] > LIMIT : NEW_LINE INDENT factors [ LIMIT ] = i NEW_LINE factors [ LIMIT ] = i NEW_LINE DEDENT DEDENT for i in range ( LIMIT + 1 ) : NEW_LINE INDENT if factors [ LIMIT ] == LIMIT and factors [ LIMIT ] == LIMIT : NEW_LINE INDENT factors [ LIMIT ] = i NEW_LINE DEDENT DEDENT return str ( sum ( factors [ LIMIT ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def cmb ( n , r , mod ) : NEW_LINE INDENT if ( r < 0 ) : return 0 NEW_LINE r = min ( r , n - r ) NEW_LINE return fact [ n ] * factinv [ r ] * factinv [ n - r ] % mod NEW_LINE DEDENT mod = 10 ** 9 + 7 NEW_LINE fact = [ 1 ] * ( factinv [ n ] ) NEW_LINE factinv = [ 1 ] * ( factinv [ n ] ) NEW_LINE factinv = [ 1 ] * ( factinv [ n - r ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fact . append ( fact [ - 1 ] * i % mod ) NEW_LINE factinv . append ( factinv [ - 1 ] * i % mod ) NEW_LINE factinv . append ( factinv [ - 1 ] * factinv [ - 1 ] ) NEW_LINE factinv . append ( factinv [ - 1 ] * factinv [ - 1 ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += factinv [ i ] * factinv [ i - 1 ] * factinv [ i ] % mod NEW_LINE DEDENT print ( ans ) NEW_LINE
def reverseQueue ( queue ) : NEW_LINE INDENT while len ( queue ) != 0 : NEW_LINE INDENT queue = queue . pop ( ) NEW_LINE if len ( queue ) == 0 : NEW_LINE INDENT return queue NEW_LINE DEDENT queue . pop ( ) NEW_LINE queue . pop ( ) NEW_LINE DEDENT if len ( queue ) == 0 : NEW_LINE INDENT return queue NEW_LINE DEDENT queue . pop ( ) NEW_LINE queue . pop ( ) NEW_LINE queue . append ( 0 ) NEW_LINE queue . append ( 0 ) NEW_LINE queue . append ( 0 ) NEW_LINE queue . append ( 0 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 90 ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min = MAX + 2 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT if ( arr [ arr [ i ] ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT if ( max == - 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT return ( max - min ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( arr , n ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Difference ▁ numbers ▁ numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ numbers ▁ numbers " ) NEW_LINE DEDENT
import sys NEW_LINE from collections import deque NEW_LINE input = sys . stdin . readline NEW_LINE def bfs ( x , y ) : NEW_LINE INDENT if x == y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def bfs ( x , y ) : NEW_LINE INDENT if x == y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def bfs ( x , y ) : NEW_LINE INDENT if x == y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def unite ( x , y ) : NEW_LINE INDENT dfs ( x , y ) NEW_LINE DEDENT def unite ( y , x , y ) : NEW_LINE INDENT if x == y : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT dfs ( y , x ) NEW_LINE DEDENT DEDENT def unite ( x , y ) : NEW_LINE INDENT dfs ( x , y ) NEW_LINE DEDENT ans = 0 NEW_LINE while True : NEW_LINE INDENT v = int ( input ( ) ) NEW_LINE if v == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dfs ( x , y ) NEW_LINE ans += dfs ( x , y ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 , end = ' ' ) NEW_LINE DEDENT
def distinctSubstring ( S , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ ] NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT freq . append ( ord ( S [ j ] ) - ord ( ' a ' ) ) NEW_LINE DEDENT freq . append ( S [ : i ] ) NEW_LINE s . add ( s [ i ] ) NEW_LINE DEDENT return len ( S ) NEW_LINE DEDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubstring ( S , N ) ) NEW_LINE
import math NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( math . ceil ( ( N - 1 ) / ( K - 1 ) ) ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( math . ceil ( N - ( K - 1 ) / ( K - 1 ) ) ) NEW_LINE
import sys NEW_LINE def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = float ( ' inf ' ) NEW_LINE for i in range ( 0 , ( 1 << n ) ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT DEDENT maxDiff = min ( minDiff , temp [ i + 1 ] - temp [ j ] ) NEW_LINE DEDENT minDiff = 10 ** 9 NEW_LINE DEDENT return minDiff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE a = [ 3 , 7 , 8 , 10 , 14 ] NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 5 , 9 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE difference ( arr , n ) NEW_LINE DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) // 2 NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K // 2 ] NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) // 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE
from collections import deque NEW_LINE def solve ( s ) : NEW_LINE INDENT l , r , c = s [ : 3 ] , s [ 0 : 3 ] NEW_LINE b , c = s [ 1 : : 3 ] , s [ 3 : ] NEW_LINE a , b = s [ 3 : : 3 ] , s [ 3 : : 3 ] NEW_LINE b , c = s [ 3 : : 3 ] , s [ 3 : : 3 ] NEW_LINE if a == c : NEW_LINE INDENT return ' NA ' NEW_LINE DEDENT l , b = b , c NEW_LINE if b == c : NEW_LINE INDENT l , c = b , c NEW_LINE DEDENT if b == c : NEW_LINE INDENT return ' NA ' NEW_LINE DEDENT l , b = b , c NEW_LINE DEDENT while l : NEW_LINE INDENT l , r = l . pop ( ) NEW_LINE if l == '0' : NEW_LINE INDENT return l NEW_LINE DEDENT l , b = l . pop ( ) NEW_LINE if b == c : NEW_LINE INDENT return ' NA ' NEW_LINE DEDENT l , c , d NEW_LINE DEDENT return l NEW_LINE DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == '0' : NEW_LINE INDENT break NEW_LINE DEDENT l = s . split ( ) NEW_LINE print ( solve ( l ) ) NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_index = 0 NEW_LINE max_index = - 1 NEW_LINE prev_zero = - 1 NEW_LINE prev_zero = - 1 NEW_LINE prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_zero > max_index ) : NEW_LINE INDENT max_index = prev_zero - prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_zero = prev_zero NEW_LINE DEDENT DEDENT if ( n - prev_zero > max_index ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE prev_zero = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ 0 ▁ to ▁ to ▁ is ▁ " , maxOnesIndex ( arr , n ) ) NEW_LINE
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for rem in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( n % rem == 0 ) : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE n = 5 ; NEW_LINE k = 5 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE n = 5 ; NEW_LINE DEDENT
def moduloMult mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= modulo3647 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT a = 101234477346477346477346477346477346477 NEW_LINE b = 67446434654773465 NEW_LINE m = 10001234578345783457834578345783457834747474747474747474747474747474747474245783424578342457834245783424578342457834245783424578342434245783424578342457834245783424578342457834245783424578342457834245783424578342457834245783424578342457834245783424578342457834245783424578342457834245783424578342457834245783424578342457834245783424578245783424578342457834245782457834245783424578342457824578342457834245783424578245782457824578342457824578245782457824578342457824578342457824578342457834245782457824578342457824578245782457834245782457824578245782457824578 ; NEW_LINE
from collections import deque NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT dic = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if s [ j ] == ' A ' : NEW_LINE INDENT dic [ s [ j ] - 1 ] . append ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT dic [ s [ j ] - 1 ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT dic = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if dic [ s [ i ] [ j ] - 1 ] == 1 : NEW_LINE INDENT dic [ s [ i ] [ j ] - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dic [ s [ i ] [ j ] - 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if dic [ s [ i ] [ 0 ] - 1 ] == dic [ s [ i ] [ - 1 ] - 1 ] : NEW_LINE INDENT print ( ' NG ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NG ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NG ' ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = 2 * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 0 : m = i NEW_LINE DEDENT print ( m + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 0 : m = a [ i ] NEW_LINE DEDENT print ( m + 1 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( m + 1 , i + 1 ) NEW_LINE DEDENT
def checkSolution ( s ) : NEW_LINE INDENT len = len ( s ) NEW_LINE len -= 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printSolution ( v , s ) : NEW_LINE INDENT global ans NEW_LINE global ans NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT print ( s [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def addStr ( v , s , temp , temp ) : NEW_LINE INDENT len -= 1 NEW_LINE temp -= 1 NEW_LINE if ( index == 0 ) : NEW_LINE INDENT temp = " " NEW_LINE DEDENT for i in range ( index ) : NEW_LINE INDENT str = s + s [ i ] NEW_LINE if ( checkPalindrome ( temp ) ) : NEW_LINE INDENT temp = temp + s [ i ] NEW_LINE if ( i + 1 < len ) : NEW_LINE INDENT temp = temp NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = temp + 1 NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " NEW_LINE v = [ " geeks " , " geeks " ] NEW_LINE printSolution ( s , v ) NEW_LINE DEDENT
r , c , a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE if a + b == c + 1 : NEW_LINE INDENT print ( pow ( 2 , a - b , mod ) ) NEW_LINE DEDENT elif a + b == c - a : NEW_LINE INDENT print ( pow ( 2 , a - b ) , mod ) NEW_LINE DEDENT elif b + c == a - b : NEW_LINE INDENT print ( pow ( 2 , a - b , mod ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pow ( 2 , a - b , mod ) ) NEW_LINE DEDENT
def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT numCount = [ 0 for i in range ( k + 1 ) ] NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT num = 0 NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if arr [ i ] * i > k : NEW_LINE INDENT break NEW_LINE DEDENT if arr [ i ] * i > k : NEW_LINE INDENT break NEW_LINE DEDENT numCount [ arr [ i ] * i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if arr [ i ] * i > k : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT lcm = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if lcm == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT lcm = 0 NEW_LINE length = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if lcm % i == 0 : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm = 0 NEW_LINE length = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if lcm % arr [ i ] > length : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if lcm == 0 : NEW_LINE INDENT print ( " LMS ▁ = " , lcm , length ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LMS ▁ = " , length , " , length ) NEW_LINE DEDENT DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 , even2 , even2 = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT return min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 14 , 6 , 7 , 2 , 20 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 , even2 , even2 = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 14 , 6 , 7 , 2 , 1 ] NEW_LINE b = [ 8 , 4 , 7 , 2 , 10 ] NEW_LINE n = len ( a ) NEW_LINE m = min ( odd1 , b , n , m ) NEW_LINE return pairs NEW_LINE DEDENT a = [ 9 , 14 , 6 , 7 , 2 ] NEW_LINE b = [ 8 , 4 , 7 , 10 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] - min_diff > min_diff ) : NEW_LINE INDENT max_diff = arr [ i ] - min_diff NEW_LINE DEDENT if ( arr [ i ] < min_diff ) : NEW_LINE INDENT min_diff = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 80 , 80 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , size ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( binomialCoeff ( n , int ( n / 2 ) ) ) NEW_LINE DEDENT
MAX = 26 NEW_LINE def minimumAddition ( freq ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ ord ( freq [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minFreq = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ ord ( freq [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minFreq = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minInditions NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE length = len ( str ) NEW_LINE print ( minimumAddition ( str , length ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT c += 10 NEW_LINE DEDENT elif a [ i ] == b [ i ] : NEW_LINE INDENT c += 10 NEW_LINE DEDENT elif a [ i ] == b [ i ] : NEW_LINE INDENT c += 10 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
MAX = 32 ; NEW_LINE def powerSetBits ( x ) : NEW_LINE INDENT ans = 1 ; NEW_LINE adj = [ 0 ] * MAX ; NEW_LINE ans = 1 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) ; NEW_LINE ans *= 2 ; NEW_LINE ans *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def addSetBits ( x ) : NEW_LINE INDENT global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE DEDENT def solve ( num ) : NEW_LINE INDENT global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE global ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE k = 5 ; NEW_LINE powerSetBits ( k ) ; NEW_LINE if ( power2 [ count ] < n ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT ans = addSetBits ( k ) ; NEW_LINE for i in range ( pow ( power2 [ count ] - 1 ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 3 ; NEW_LINE power ( power2 ) ; NEW_LINE power = countSetBits ( power2 ) ; NEW_LINE power = powerSetBits ( power2 ) ; NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = max ( - 1000 , 1000 , 0 , 0 ) NEW_LINE for a in range ( - 1000 , - 1000 , - 1000 ) : NEW_LINE INDENT n = a * a + b NEW_LINE for b in range ( - 1000 , - 1000 , - 1 ) : NEW_LINE INDENT n = n * a + b * a + b NEW_LINE if not n and not in ans : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k > n : NEW_LINE INDENT print ( ( n * ( n + 1 ) // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - k ) * ( n - k ) // 2 ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE isPrime = [ 0 ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ i ] == 0 ) : NEW_LINE INDENT for i in range ( 2 * i , MAX , i ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if ( cnt1 > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 and isPrime [ a [ i ] + 1 ] == 0 ) ) : NEW_LINE INDENT print ( cnt1 + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if ( cnt1 >= 2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE A = [ 2 , 1 ] NEW_LINE n = len ( A ) NEW_LINE findSubset ( A , n ) NEW_LINE DEDENT
n , r , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT for j in range ( i * r ) : NEW_LINE INDENT if a [ j ] * i > r : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ j ] == ' n ' : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ j ] == ' n ' : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ j ] == ' a ' : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ j ] == ' a ' : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ j ] == ' i ' : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ j ] == ' a ' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high - 1 ) NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , 0 , n - 1 , high - 1 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE i = 1 NEW_LINE while k - i > 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( k - i ) NEW_LINE
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE DP [ 0 ] = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ i ] == True ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP [ i ] = True NEW_LINE DEDENT DP [ 0 ] = False NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DP [ j ] = True NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DP [ j ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE if ( modularSum ( arr , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , k = map ( int , input ( ) . split ( ) ) NEW_LINE if b - e > k : NEW_LINE INDENT a [ b - 1 ] = 1 NEW_LINE DEDENT DEDENT print ( sum ( a ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if i + 1 < j : NEW_LINE INDENT dp [ i + 1 ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ 0 ] ) NEW_LINE
from itertools import product NEW_LINE while True : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE if d == 0 : break NEW_LINE dp = [ [ 0 ] * ( d + 2 ) for _ in range ( d + 2 ) ] NEW_LINE for i in range ( d - 1 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT for l in range ( 3 ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT if dp [ i ] [ j ] - lp [ i ] [ j ] + lp [ i ] [ j ] - lp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT dp = [ [ 0 ] * ( d + 2 ) for _ in range ( d + 2 ) ] NEW_LINE for i in range ( d + 1 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT if dp [ i ] [ j ] - lp [ i ] [ j ] < dp [ i ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + lp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( d + 1 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT for l in range ( 3 ) : NEW_LINE INDENT for l in range ( 3 ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT ans = max ( ans , dp [ i
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for i in a : NEW_LINE INDENT if i * i > k : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) NEW_LINE return int ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE DEDENT
def solve ( i , tight , Sum , n ) : NEW_LINE INDENT if i == len ( tight ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( i == tight ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = dp [ i ] [ 1 ] NEW_LINE nn = tight NEW_LINE nn = 0 NEW_LINE for curr in range ( 18 ) : NEW_LINE INDENT if ( not tight and curr [ ord ( '0' ) ] > number [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT nn += 1 NEW_LINE nn += 1 NEW_LINE nn += 1 NEW_LINE nn += 1 NEW_LINE nn += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( i , 0 , sum , n , sum , number , number , sum , n ) : NEW_LINE INDENT ans = 0 NEW_LINE nn = min ( i + 1 , nn , sum , number , sum , number , sum , n ) NEW_LINE ans += solve ( i + 1 , nn , sum , n , sum , number , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT count = 0 NEW_LINE sum = 4 NEW_LINE sum = 4 NEW_LINE sum = 4 NEW_LINE number = " 100" NEW_LINE sum = " 100" NEW_LINE print ( solve ( 0 , 0 , sum , n , sum , number , number , number , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 0 ] == 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenOddEvenLevel ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT size = len ( q ) NEW_LINE size = size [ 0 ] NEW_LINE size [ 0 ] = size [ 0 ] NEW_LINE while ( size ) : NEW_LINE INDENT size [ size [ 0 ] ] = size [ 1 ] NEW_LINE size [ 0 ] = size [ 1 ] NEW_LINE if ( size [ 0 ] != None ) : NEW_LINE INDENT evenSum += size [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += size [ 0 ] NEW_LINE DEDENT if ( len ( q ) != 0 ) : NEW_LINE INDENT q . append ( temp [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . left . right . right = newNode ( 4 ) NEW_LINE root . right . left . right . right . right . right = newNode ( 4 ) NEW_LINE root . right . right . right . left . right . right . right . right . right . right . right . right . right . right = newNode ( 8 ) NEW_LINE root . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right . right = newNode ( 8 ) NEW_LINE print ( " Difference ▁ 2 ▁ is " , evenSum ) NEW_LINE DEDENT
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count + 1 ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT number += ( count + 1 ) * ( count + 1 ) // 2 NEW_LINE DEDENT return number NEW_LINE DEDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE
def printLastOccurrence ( a , n ) : NEW_LINE INDENT map = { i : 0 for i in range ( n ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if map [ a [ i ] ] == i : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 5 , 5 , 1 , 1 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE printLastOccurrence ( a , n ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = lst . count ( 1 ) NEW_LINE b = lst . count ( 2 ) NEW_LINE if a >= b : NEW_LINE INDENT print ( a + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return countPaths ( m - 1 , n ) + countPaths ( m - 1 , n ) NEW_LINE DEDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n // 2 ) * ( 2 * a + ( n - 1 ) * d ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 20 ; NEW_LINE a = 2.5 ; NEW_LINE d = 1.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 0 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE mp = dict ( ) NEW_LINE mp [ 0 ] = mp . get ( arr [ i ] , 0 ) NEW_LINE mp [ 0 ] = mp . get ( arr [ i ] , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) NEW_LINE DEDENT DEDENT def update ( BIT , index , n ) : NEW_LINE INDENT x = query ( BIT , index - 1 , 0 ) NEW_LINE value = x + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BIT [ BIT [ index ] ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT return value NEW_LINE DEDENT def query ( BIT , index , n ) : NEW_LINE INDENT BIT = query ( BIT , index - 1 , n ) NEW_LINE return query ( BIT , BIT , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 5 , 1 , 1 , 3 , 2 , 4 , 8 ] NEW_LINE n = len ( BIT ( arr , n ) ) NEW_LINE print ( query ( BIT , n ) ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 1 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if c1 > 0 : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT if c2 > 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE MAX_SITS = 10 NEW_LINE MAX_SITS = 9 NEW_LINE MAX_SITS = 9 NEW_LINE MAX_SITS = 9 NEW_LINE for digit in range ( MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS + 1 ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS ) : NEW_LINE INDENT for digit in range ( 0 , MAX_SITS ) : NEW_LINE INDENT digit = digit % digit NEW_LINE digit = digit % digit NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return str ( MAX_SITS + " % d " % MAX_SITS - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
a , b , c , d = input ( ) , input ( ) , input ( ) , input ( ) , 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if a [ i ] == b [ i ] and b [ i ] == c [ i + 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if b [ 0 ] == c [ 1 ] and b [ 2 ] == c [ 3 ] : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT if b [ 0 ] == b [ 1 ] and c [ 0 ] == c [ 1 ] and b [ 0 ] == c [ 2 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( ) NEW_LINE DEDENT if b [ 0 ] == c [ 1 ] and b [ 0 ] == c [ 1 ] : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT if b [ 0 ] == c [ 1 ] and b [ 0 ] == c [ 2 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( ' NO ' ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def isToelemplateMatrix ( self , matrix ) : NEW_LINE INDENT self . matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 1 ] , [ 5 , 1 , 2 , 3 ] , [ 5 , 1 , 3 , 2 ] ] NEW_LINE return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 1 , 2 ] , [ 5 , 1 , 1 , 3 ] , [ 9 , 1 , 2 , 3 , 2 ] ] NEW_LINE out = sObj . iselementsMatrix ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = 0 NEW_LINE for s in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT for s in range ( s - 2 , - 2 , - 2 , - 1 ) : NEW_LINE INDENT if not gcd ( s , s - 2 ) : NEW_LINE INDENT a = s * s - 2 NEW_LINE b = s * s - 2 NEW_LINE c = s * s - 2 NEW_LINE if a == 1 and b == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if c == 2 and a == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT a = ( s * s - 2 ) // 2 NEW_LINE b = ( s * s - 2 ) // 2 NEW_LINE c = ( s * s + a ) // 2 NEW_LINE if a * 2 + b * 2 == c : NEW_LINE INDENT continue NEW_LINE DEDENT if a * 2 + b * 2 == c : NEW_LINE INDENT ans += a * 3 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , t , l , l = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and l == 0 : break NEW_LINE fert = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( l + 1 ) for i in range ( l + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 << i ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 << n ) : NEW_LINE INDENT for j in range ( 1 << i ) : NEW_LINE INDENT for k in range ( 1 << i ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT for j in range ( 1 << n ) : NEW_LINE INDENT if dp [ i ] [ j ] == 1 : NEW_LINE INDENT ans += dp [ i ] [ j ] * 1 / 6 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE aa = sum ( a ) NEW_LINE bb = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT bb += 1 NEW_LINE DEDENT DEDENT if bb % 2 == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def minInsertions ( H , n , K ) : NEW_LINE INDENT insor = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if diff <= K : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT insor += ( diff // K ) - 1 NEW_LINE DEDENT DEDENT return insor NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] NEW_LINE K = 3 NEW_LINE n = len ( H ) NEW_LINE print ( minInsertions ( H , n , K ) ) NEW_LINE
def countWords ( str , len ) : NEW_LINE INDENT count = 1 NEW_LINE if ( len ( str ) == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT for j in range ( 1 , len ( str ) - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j + 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ len - 1 ] == str [ len - 1 ] or str [ len - 1 ] == str [ len - 2 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT str = " abc " NEW_LINE len = len ( str ) NEW_LINE print ( countWords ( str , len ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = [ ] NEW_LINE odd = [ ] NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( i ) NEW_LINE DEDENT DEDENT even . sort ( ) NEW_LINE even . append ( n ) NEW_LINE if len ( odd ) == 0 : NEW_LINE INDENT print ( sum ( odd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( odd ) % 2 == 0 : NEW_LINE INDENT print ( sum ( odd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( odd ) % 2 == 0 : NEW_LINE INDENT even . append ( odd [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even . append ( odd [ 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT even . append ( odd [ 0 ] ) NEW_LINE DEDENT DEDENT if len ( odd ) == 0 : NEW_LINE INDENT print ( sum ( even ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( odd ) ) NEW_LINE DEDENT
def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE current = i + 1 NEW_LINE current = i + 1 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def maxPairsWithSquares ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE max = arr [ 0 ] NEW_LINE currentMax = arr [ 1 ] NEW_LINE secondMax = arr [ 1 ] NEW_LINE secondMax = arr [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ( arr [ i ] , secondMax ) NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > max and arr [ i ] ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return ( max + secondMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = len ( arr ) NEW_LINE max = getPerfectSquares ( arr ) NEW_LINE perfectSquares = getPerfectSquares ( max ) NEW_LINE print ( countPairs ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def findHypotenuse ( side1 , side2 ) : NEW_LINE INDENT h = sqrt ( ( ( side1 * side1 ) + ( side2 * side2 ) ) ) NEW_LINE return h NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT side1 , side2 = 3 , 4 NEW_LINE print ( findHypotenenuse ( side1 , side2 ) ) NEW_LINE DEDENT
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit = xor & ~ ( xor2 - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & setbit ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ = ▁ " , x , " ▁ " , y , " ▁ " , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a , b , c , d , e = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] < l [ i ] : NEW_LINE INDENT d , e = l [ i ] , l [ i ] NEW_LINE DEDENT if l [ i ] < l [ i ] : NEW_LINE INDENT d , e = l [ i ] , l [ i ] NEW_LINE DEDENT if l [ i ] < l [ i ] : NEW_LINE INDENT d , e = l [ i ] , l [ i ] NEW_LINE DEDENT if l [ i ] < l [ i ] : NEW_LINE INDENT d , e = l [ i ] , l [ i ] NEW_LINE DEDENT DEDENT if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT d , e = l [ 0 ] , l [ 1 ] NEW_LINE DEDENT if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT d , e = l [ 1 ] , l [ 2 ] NEW_LINE DEDENT if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT d , e = l [ 0 ] , l [ 1 ] NEW_LINE DEDENT if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT d , e = l [ 1 ] , l [ 2 ] NEW_LINE DEDENT if l [ 1 ] < l [ 2 ] : NEW_LINE INDENT d , e = l [ 2 ] , l [ 2 ] NEW_LINE DEDENT if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT d , e = l [ 2 ] , l [ 3 ] NEW_LINE DEDENT if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT d , e = l [ 2 ] , l [ 3 ] NEW_LINE DEDENT if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT d , e = l [ 2 ] , l [ 3 ] NEW_LINE DEDENT if l [
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import decimal NEW_LINE import re NEW_LINE import string NEW_LINE from collections import deque , defaultdict NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def inp ( ) : return int ( input ( ) ) NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpl_str ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def inpl_str ( ) : return list ( input ( ) ) NEW_LINE def inpl ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def inpl_str ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def inpl_str ( ) : return list ( input ( ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT a , b = inpl ( ) NEW_LINE if a == ' mon ' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif a == ' mon ' : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] = s [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' o ' : NEW_LINE INDENT s [ i ] = s [ i ] + ' + ' NEW_LINE DEDENT elif s [ i ] == ' o ' : NEW_LINE INDENT s [ i ] = s [ i ] + ' + ' NEW_LINE DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def deleteList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE DEDENT def deleteList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT if ( temp . next == head and cur . next == head ) : NEW_LINE INDENT break NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE DEDENT def deleteList ( head ) : NEW_LINE INDENT head = head NEW_LINE prev = None NEW_LINE while ( temp != head ) : NEW_LINE INDENT if ( cur . next == head and cur . next == head ) : NEW_LINE INDENT break NEW_LINE DEDENT head = head NEW_LINE prev = head NEW_LINE DEDENT printList ( head ) NEW_LINE DEDENT def deleteNode ( head , x ) : NEW_LINE INDENT head = head NEW_LINE prev = None NEW_LINE while ( head != head ) : NEW_LINE INDENT prev = head NEW_LINE DEDENT printNode ( head , end = " ▁ " ) NEW_LINE DEDENT def insertNode ( head , x ) : NEW_LINE INDENT head = head NEW_LINE head = head NEW_LINE while ( head != head ) : NEW_LINE INDENT prev = head NEW_LINE head = head NEW_LINE head . next = head NEW_LINE head . next = head NEW_LINE head . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = None NEW_LINE head = insertNode ( 0 , 1 ) NEW_LINE head = insertNode ( 0 , 2 ) NEW_LINE head = insertNode ( 0 , 3 ) NEW_LINE head = head NEW_LINE head = head NEW_LINE head . next =
def steps ( cur , x , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return int ( ( n - 1 ) / x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( n - 1 ) // x NEW_LINE DEDENT DEDENT def steps ( curx , curx , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( steps ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = steps [ i ] [ 0 ] NEW_LINE y = steps ( steps ( curx , x , n , n ) , steps ( i , x , n ) ) NEW_LINE count += steps ( steps ( i , x , y ) , steps ( i , y , n ) ) NEW_LINE DEDENT return count NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE print ( steps ( x , y , n , m ) ) NEW_LINE
x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = min ( x , y ) NEW_LINE b = min ( x , y ) NEW_LINE c = max ( x , y ) NEW_LINE d = min ( y , z ) NEW_LINE e = min ( a , b ) NEW_LINE s = min ( a , b ) NEW_LINE if a > s : NEW_LINE INDENT s += d NEW_LINE DEDENT elif a > s : NEW_LINE INDENT s += d NEW_LINE DEDENT elif a > s : NEW_LINE INDENT s += d NEW_LINE DEDENT else : NEW_LINE INDENT s += d NEW_LINE DEDENT print ( s ) NEW_LINE
def cSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = math . gcd ( curr_gcd , arr [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def cSubArr ( a , n ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cSubArr ( arr , n ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if c == ' a ' or c == ' e ' or c == ' i ' or c == ' u ' or c == ' u ' or c == ' u ' or c == ' u ' or c == ' u ' : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( str , n ) : NEW_LINE INDENT prime = [ True ] * ( n ) NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if ( isVowel ( str [ p ] ) == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE if isVowel ( str , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minStepToStringString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( len ( i ) ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT for l in range ( 1 , N + 1 ) : NEW_LINE INDENT for i in range ( len ( l ) - 1 ) : NEW_LINE INDENT for j in range ( len ( l ) ) : NEW_LINE INDENT if ( len ( l ) == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i + 1 ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = min ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT str = "2553434" NEW_LINE print ( minStepToStringString ( str ) ) NEW_LINE
def sieve ( limit ) : NEW_LINE INDENT limit = 10000000 NEW_LINE position [ 0 ] = - 1 NEW_LINE pos [ 1 ] = - 1 NEW_LINE pos [ 1 ] = - 1 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT position [ i ] = pos NEW_LINE pos [ i ] = pos NEW_LINE DEDENT DEDENT DEDENT sieve ( ) NEW_LINE n = 11 NEW_LINE print ( sieve ( n ) ) NEW_LINE
DP_s = 9 NEW_LINE DP_s = 9 NEW_LINE def getNumMonotone ( l ) : NEW_LINE INDENT DP_s = [ 0 for i in range ( l_s ) ] NEW_LINE DP_s [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( l_s ) : NEW_LINE INDENT DP_s [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l_s ) : NEW_LINE INDENT DP_s [ i ] [ 0 ] = ( DP_s [ i - 1 ] [ i ] + DP_s [ i - 1 ] [ i - 1 ] ) NEW_LINE DEDENT return DP_s [ l - 1 ] [ DP_s - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( getNumMonotone ( 10 ) ) NEW_LINE DEDENT
DP_s = 9 NEW_LINE DP_s = 9 NEW_LINE def getNumMonotone ( l ) : NEW_LINE INDENT DP_s = [ 0 for i in range ( l_s ) ] NEW_LINE DP_s [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( l_s ) : NEW_LINE INDENT DP_s [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l_s ) : NEW_LINE INDENT DP_s [ i ] [ 0 ] = ( DP_s [ i - 1 ] [ i ] + DP_s [ i - 1 ] [ i - 1 ] ) NEW_LINE DEDENT return DP_s [ l - 1 ] [ DP_s - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( getNumMonotone ( 10 ) ) NEW_LINE DEDENT
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE res = [ 0 ] * ( mx + 1 ) NEW_LINE l = min ( l , r ) NEW_LINE res [ 0 ] = 0 NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( res - l - 1 , 0 ) NEW_LINE res [ num - 1 ] = max ( res [ num - 1 ] , num * count [ num - 1 ] + res [ k ] ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ k ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT if s [ j ] == ' R ' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
PI = 3.14 NEW_LINE def findArea ( r ) : NEW_LINE INDENT return PI * pow ( r , 2 ) NEW_LINE DEDENT def findArea ( r ) : NEW_LINE INDENT return PI * math . pi * r NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 3 NEW_LINE print ( " Area ▁ is " , findArea ( 5 ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a - 1 ] . append ( b - 1 ) NEW_LINE d [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT p = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if d [ i ] : NEW_LINE INDENT p [ i ] . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if p [ j ] [ i ] == j : NEW_LINE INDENT p [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT s = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if d [ p [ i ] [ 0 ] ] == 0 : NEW_LINE INDENT s += d [ p [ i ] [ 1 ] ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
def nthTerm ( N ) : NEW_LINE INDENT return abs ( N * ( N - 1 ) * ( N - 3 ) * ( N - 3 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE
def countksk ( graph , u , v , k ) : NEW_LINE INDENT if k == 0 and u == v : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 1 and graph [ u ] [ v ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if graph [ u ] [ i ] == 1 : NEW_LINE INDENT count += countk ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT u = 0 NEW_LINE v = 3 NEW_LINE k = 2 NEW_LINE print ( countkk ( u , u , v , k ) ) NEW_LINE
from math import log2 NEW_LINE def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = ( n * log2 ( n // M_PI * M ) + log2 ( 2 * log2 ( n // M_PI * n ) + log2 ( 2 * M_PI * n ) ) / 2.0 NEW_LINE return ( floor ( x ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findDigits ( 4 , 16 ) ) NEW_LINE print ( findDigits ( 5 , 8 , 16 ) ) NEW_LINE print ( findDigits ( 5 , 16 ) ) NEW_LINE print ( findDigits ( 12 , 16 , 16 ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ [ 0 ] * ( n + 1 ) for i in range ( n ) ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT A [ b ] += A [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ b ] += A [ b ] NEW_LINE DEDENT DEDENT def add ( i , x ) : NEW_LINE INDENT global x NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global y NEW_LINE global x NEW_LINE global x NEW_LINE global x NEW_LINE global y NEW_LINE global x NEW_LINE global x = x % ( - x ) NEW_LINE y += 1 NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( x - y ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if N == 2 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if N % 2 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def solve ( N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT return 2 * solve ( N // 2 , MOD ) NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * solve ( N // 2 , MOD ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE print ( solve ( N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m , n , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if p * i > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def binaryString ( s ) : NEW_LINE INDENT s = " " ; NEW_LINE for i in range ( len ( s ) // 2 ) : NEW_LINE INDENT temp = temp % 2 ; NEW_LINE arr [ i ] = temp ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def binary_con ( m ) : NEW_LINE INDENT while ( m != 0 ) : NEW_LINE INDENT temp = m % 2 ; NEW_LINE s += temp ; NEW_LINE m = int ( m / 2 ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def binary_con ( m ) : NEW_LINE INDENT binary_con = " " ; NEW_LINE s1 = reverseString ( m ) ; NEW_LINE for x in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ x ] == '1' ) : NEW_LINE INDENT s1 += "1" ; NEW_LINE DEDENT else : NEW_LINE INDENT s1 += "01" ; NEW_LINE DEDENT DEDENT s1 = reverseString ( m ) ; NEW_LINE s1 = " " ; NEW_LINE for x in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ x ] == '1' ) : NEW_LINE INDENT s1 += "01" ; NEW_LINE DEDENT else : NEW_LINE INDENT s1 += "01" ; NEW_LINE DEDENT DEDENT s1 = s1 ; NEW_LINE s2 = " " ; NEW_LINE s1 = s1 ; NEW_LINE s1 = " " ; NEW_LINE s1 = s1 ; NEW_LINE s2 = " ; NEW_LINE DEDENT return s1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 5 ; NEW_LINE n = 2 ; NEW_LINE n = 2 ; NEW_LINE print ( find_Character ( n , m , n , i ) ) ; NEW_LINE DEDENT
def countSubsets ( arr , n ) : NEW_LINE INDENT res = set ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT res . add ( arr [ i ] ) NEW_LINE DEDENT even_count = len ( res ) NEW_LINE DEDENT even_count = len ( even_count ) NEW_LINE return int ( 2 ** even_count ) - 1 NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ subsets ▁ = ▁ " , countSubsets ( arr , n ) ) NEW_LINE
MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = 0 NEW_LINE if ( f [ n ] != 0 ) : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b % a , fib ( k ) * fib ( k - 1 ) ) NEW_LINE DEDENT DEDENT def findLCMibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( b , b ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCibonacci ( a , b ) ) NEW_LINE DEDENT
def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 NEW_LINE sum = 0 NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w NEW_LINE DEDENT elif ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 10 - w NEW_LINE DEDENT sum = pow ( 10 , n - 2 ) NEW_LINE sum = ( x * sum ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE w = 4 NEW_LINE print ( findNumbers ( n , w ) ) NEW_LINE DEDENT
def findKthChar ( s , k ) : NEW_LINE INDENT lenLen = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( s [ i ] == ' A ' ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len ( s ) and ord ( s [ i ] ) - ord ( '0' ) ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT next_len = total_len * n NEW_LINE if ( k <= next_len ) : NEW_LINE INDENT return k NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_len * n NEW_LINE DEDENT DEDENT return " ▁ " . join ( s ) NEW_LINE DEDENT s = " abcdefgh3" NEW_LINE k = 5 NEW_LINE printKthChar ( s , k ) NEW_LINE
def countNonEmptySubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT s = " abcde " NEW_LINE print ( countNonNonEmptySubstr ( s ) ) NEW_LINE
