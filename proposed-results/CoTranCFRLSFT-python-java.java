import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean [ ] isprime ; static int [ ] primes = new int [ 1000000 ] ; static { Arrays . fill ( isprime , true ) ; isprime [ 0 ] = isprime [ 1 ] = false ; for ( int i = 2 ; i * i <= isprime . length ; i ++ ) { if ( isprime [ i ] ) { for ( int j = i * 2 ; j <= isprime . length ; j += i ) { isprime [ j ] = false ; } } } int [ ] prime = new int [ 1000000 ] ; for ( int i = 0 ; i < isprime . length ; i ++ ) { prime [ i ] = i ; } } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { while ( in . hasNext ( ) ) { int n = in . nextInt ( ) ; if ( n == 0 ) break ; int cnt = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( isprime [ i ] && primes [ n - i ] != i ) { cnt ++ ; } } out . println ( cnt ) ; } out . flush ( ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static void countFreq ( String str , int freq [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } } static boolean canMakePalindrome ( int freq [ ] , int len ) { int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) count_odd ++ ; } if ( len % 2 == 0 ) { if ( count_odd > 0 ) return false ; else return true ; } if ( count_odd != 1 ) return false ; return true ; } static String findOddAndRemoveItsFreq ( int freq [ ] ) { String odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str += ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; } static String findPalindromicString ( String str ) { int len = str . length ( ) ; int freq [ ] = new int [ MAX_CHAR ] ; countFreq ( str , freq , len ) ; if ( canMakePalindrome ( freq , len ) == false ) return " No ▁ Palindromic ▁ String " ; String odd_str = findOddAndRemoveItsFreq ( freq ) ; String front_str = " " ; String rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) temp += ch ; } front_str += temp ; rear_str = temp + rear_str ; } return ( front_str + odd_str + rear_str ) ; } public static void main ( String [ ] args ) { String str = " malayalam " ; int len = str . length ( ) ; int freq [ ] = new
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int q ; double x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 , s1 , s2 , s3 ; q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { x0 = sc . nextDouble ( ) ; y0 = sc . nextDouble ( ) ; x1 = sc . nextDouble ( ) ; y1 = sc . nextDouble ( ) ; x2 = sc . nextDouble ( ) ; y2 = sc . nextDouble ( ) ; x3 = sc . nextDouble ( ) ; y3 = sc . nextDouble ( ) ; s1 = ( ( x3 - x2 ) * ( y2 - y1 ) - ( y3 - y2 ) * ( x3 - x2 ) ) / 2 ; s2 = ( ( x3 - x2 ) * ( y3 - y2 ) - ( y3 - y2 ) * ( x3 - x2 ) ) / 2 ; if ( s1 * s2 < 0 && s2 * s3 < 0 ) { System . out . println ( 0 ) ; } else { System . out . println ( Math . min ( Math . min ( s1 , Math . min ( s2 , Math . min ( s3 , Math . min ( s1 , Math . max ( x2 , x3 ) ) ) ) ) ; } } } }
import java . io . * ; public class GFG { static int count9s ( String number ) { int n = number . length ( ) ; int d [ ] = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 ; int continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( number . charAt ( i ) - '0' == 0 ) continuous_zero ++ ; else continuous_zero = 0 ; mod_sum += number . charAt ( i ) - '0' ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( count9s ( "01809" ) ) ; System . out . println ( count9s ( "1809" ) ) ; System . out . println ( count9s ( "4189" ) ) ; } }
import java . io . * ; public class GFG { static int fastPow ( int N , int K ) { if ( K == 0 ) return 1 ; int temp = fastPow ( N , K / 2 ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } static int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 , K = 3 ; System . out . println ( countWays ( N , K ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] map = new int [ 8 ] [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { map [ i ] [ j ] = ( i + 1 ) % 8 ; } } while ( true ) { int n = sc . nextInt ( ) ; if ( n == - 1 ) break ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = ( sum ^ map [ i ] [ j ] ) % 8 ; } System . out . println ( sum ) ; } } }
import java . util . * ; public class GFG { static int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int p = 0 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) arr . add ( p ) ; } } static boolean isEuclid ( int n ) { int product = 1 ; for ( int i = 0 ; product < n ; i ++ ) { product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class GFG { static int MAX = 100000 ; static boolean prime [ ] = new boolean [ MAX ] ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isPrimorialPrime ( int n ) { if ( ! prime [ n ] ) return false ; int product = 1 , i = 0 ; while ( product < n ) { product *= arr . get ( i ) ; if ( product + 1 == n || product - 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isPrimorialPrime ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; public class GFG { static void mul_table ( int N , int i ) { if ( i > 10 ) return ; System . out . println ( N + " * " + i + " = ▁ " + N * i ) ; return mul_table ( N , i + 1 ) ; } public static void main ( String [ ] args ) { int N = 8 ; mul_table ( N , 1 ) ; } }
import java . io . * ; public class GFG { static int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 ; if ( ( n * m ) > 0 ) n2 = ( m * ( q + 1 ) ) ; else n2 = ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; } public static void main ( String [ ] args ) { int n = 13 , m = 4 ; System . out . println ( closestNumber ( n , m ) ) ; n = - 15 ; m = 6 ; System . out . println ( closestNumber ( n , m ) ) ; n = 0 ; m = 8 ; System . out . println ( closestNumber ( n , m ) ) ; n = 18 ; m = - 7 ; System . out . println ( closestNumber ( n , m ) ) ; } }
import java . io . * ; public class GFG { static int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) return 0 ; else if ( ( ang * n ) % 180 != 0 ) return 0 ; int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; } public static void main ( String [ ] args ) { int ang = 90 ; int n = 4 ; System . out . println ( solve ( ang , n ) ) ; } }
import java . util . * ; public class GFG { static int [ ] compute_lps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else lps [ i ] = 0 ; i ++ ; } } return lps ; } static void Longestsubstring ( String s ) { int [ ] lps = compute_lps ( s ) ; int n = s . length ( ) ; if ( lps [ n - 1 ] == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps . length - 1 ] - 1 == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < lps . length - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps . length - 1 ] - 1 == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( s . substring ( 0 , lps [ lps . length - 1 ] - 1 ) ) ; } } public static void main ( String [ ] args ) { String s = " fixprefixsuffix " ; Longestsubstring ( s ) ; } }
import java . io . * ; public class GFG { static void checkIfSortRotated ( int arr [ ] , int n ) { int minEle = Integer . MAX_VALUE ; int maxEle = Integer . MIN_VALUE ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } int flag1 = 1 ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = 0 ; break ; } } int flag2 = 2 ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = 0 ; break ; } } if ( flag1 && flag2 && arr [ n - 1 ] < arr [ minIndex - 1 ] ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . length ; checkIfSortRotated ( arr , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String [ ] inputA = scanner . nextLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( inputA [ 0 ] ) ; int d = Integer . parseInt ( inputA [ 1 ] ) ; String [ ] inputArray = scanner . nextLine ( ) . split ( " ▁ " ) ; int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = Integer . parseInt ( inputArray [ i ] ) ; } int a = 0 ; int i = 0 ; while ( i < n - 1 ) { if ( array [ i ] >= array [ i + 1 ] ) { a += ( array [ i ] - array [ i + 1 ] ) / d + 1 ; array [ i + 1 ] += ( ( array [ i ] - array [ i + 1 ] ) / d + 1 ) * d ; } i ++ ; } System . out . println ( a ) ; } }
import java . io . * ; public class GFG { static void checkIfPowerIsolated ( int n ) { int input = n ; int count = 0 ; for ( int i = 2 ; i * i <= n ; i ++ ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count > 0 ) { factor = count ; } } if ( n > 1 ) { factor = 1 ; } int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { product = product * i ; } } if ( product == input ) { System . out . println ( " Power - isolated ▁ Integer " ) ; } else { System . out . println ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) ; } } public static void main ( String [ ] args ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int a = 0 , z = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' A ' ) a ++ ; else z ++ ; } if ( a == z ) System . out . println ( " - 1" ) ; else { for ( int i = 0 ; i < z ; i ++ ) System . out . print ( " A " ) ; } } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int [ ] arr1 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr1 [ arr [ i ] - 1 ] = i ; } int [ ] arr2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ arr [ i ] - 1 ] = i ; } int len = n - arr1 [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( arr1 [ j ] == arr2 [ j ] ) { len = n - arr2 [ j + 1 ] ; break ; } } } int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) { max = n - arr1 [ i ] + arr2 [ j + 1 ] ; } } } if ( max < len ) { System . out . println ( - 1 ) ; } else { System . out . println ( len ) ; } } } }
import java . util . * ; public class GFG { static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) { return "0" ; } String result [ ] = new String [ len1 + len2 ] ; int i_n1 = 0 , i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 && result [ i ] . length ( ) <= len2 - 1 ; i -- ) { int carry = 0 ; int n1 = num1 . charAt ( i ) - '0' ; int i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; int carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) { result [ i_n1 + i_n2 ] += carry ; } } i = result . length ( ) - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += ( char ) ( result [ i ] + '0' ) ; return s ; } public static void main ( String [ ] args ) { String str1 = "1235421415454545454544" ; String str2 = "17145465465465454545448544544545" ; if ( ( str1 . charAt ( 0 ) == ' - ' || str2 . charAt ( 0 ) == ' - ' ) && ( str1 . charAt ( 0 ) == ' - ' || str2 . charAt ( 0 ) == ' - ' ) ) { System . out . print ( " - " ) ; } else if ( ( str1 . charAt ( 0 ) == ' - ' || str2 . charAt ( 0 ) == ' - ' ) || ( str1 . charAt ( 0 ) == ' - ' && str2 . charAt ( 0 ) == ' - ' ) ) { System . out . print (
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = x + sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { y = y + sc . nextInt ( ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + x ; } if ( sum <= y ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; String s = sc . next ( ) ; int left = 0 ; int right = n - k ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == left ) { sb . append ( " PRINT ▁ " ) ; } else { sb . append ( s . charAt ( i ) ) ; } } while ( left < right ) { sb . append ( " LEFT " ) ; } while ( right > 0 ) { sb . append ( " RIGHT " ) ; } System . out . println ( sb ) ; } }
import java . util . * ; public class GFG { static void printDistSum ( int arr [ ] , int n ) { int sum = Arrays . stream ( arr ) . sum ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) { if ( dp [ n ] [ j ] ) System . out . print ( j + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; printDistSum ( arr , n ) ; } }
import java . io . * ; public class GFG { static int Subtract ( int a , int b ) { int c = a + ( ~ b + 1 ) ; return c ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 ; System . out . println ( Subtract ( a , b ) ) ; a = 9 ; b = 7 ; System . out . println ( Subtract ( a , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { ans = Math . min ( ans , n - i ) ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } boolean found = false ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] && arr [ i ] == arr [ i - 1 ] ) { found = true ; break ; } } if ( found ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static int nextZero ( int i , int occurrences [ ] ) { while ( i < 26 ) { if ( occurrences [ i ] == 0 ) return i ; i ++ ; } return - 1 ; } static void getModifiedString ( String str ) { int n = str . length ( ) ; if ( n > 26 ) return " - 1" ; char [ ] str = str . toCharArray ( ) ; int occurrences [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) occurrences [ ch [ i ] - ' a ' ] ++ ; int index = nextZero ( 0 , occurrences ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( occurrences [ ch [ i ] - ' a ' ] > 1 ) { occurrences [ ch [ i ] - ' a ' ] -- ; ch [ i ] = ( char ) ( ' a ' + index ) ; occurrences [ index ] = 1 ; index = nextZero ( index + 1 , occurrences ) ; } } } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; getModifiedString ( str ) ; } }
import java . util . Scanner ; public class cf108A { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t = scan . nextInt ( ) ; while ( t -- > 0 ) { int hh = scan . nextInt ( ) ; int mm = scan . nextInt ( ) ; int time = scan . nextInt ( ) ; int s [ ] = new int [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { s [ 0 ] = Integer . parseInt ( s [ 0 ] ) * 3600 + scan . nextInt ( ) * 60 ; s [ 1 ] = Integer . parseInt ( s [ 1 ] ) * 60 + scan . nextInt ( ) ; } int n = time / 60 ; int min = ( h * 60 ) + ( m * 60 ) ; boolean flag = false ; for ( int i = 1 ; i < n ; i ++ ) { int s1 = s [ i ] ; int s2 = s [ i + 1 ] ; if ( s1 == s2 ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( i == j ) { s [ j ] = 0 ; } else { s [ j ] = s [ j - 1 ] + 1 ; } } flag = true ; if ( s1 == s2 ) { flag = false ; } } } if ( flag ) { System . out . println ( s [ n - 1 ] ) ; } else { int t = time / 60 ; int h = time % 60 ; if ( h < 10 ) { t = 0 ; } else { t = time - h * 60 ; } System . out . println ( t + " : " + t ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = i ; for ( int j = 0 ; j < n ; j ++ ) { if ( x % ( a [ j ] + 1 ) == 0 ) { x = j ; break ; } } if ( x > max ) { max = x ; } } System . out . println ( max ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long n = sc . nextLong ( ) ; if ( n == 1 ) { System . out . println ( 3 ) ; } else { if ( ( n & 1 ) == 0 ) { System . out . println ( 1 ) ; } else { int c = 1 ; while ( n != 0 ) { c *= 2 ; c ++ ; } int res = c ; while ( res <= n ) { res = res << 1 ; } System . out . println ( res ) ; } } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( i * j > n ) { if ( j == 1 ) count ++ ; } } } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int m = sc . nextInt ( ) ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { System . out . println ( a [ b [ i ] - 1 ] ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; int [ ] sumL = new int [ n + 2 ] ; int L = 1 ; sumL [ n ] = 1 ; for ( int i = n - 1 ; i > 0 ; i -- ) { L = sumL [ i + 1 ] ; int j = 2 ; while ( i * j <= n ) { L += ( sumL [ i * j ] - sumL [ Math . min ( n , ( i + 1 ) * j - 1 ) + 1 ] ) ; L %= m ; j ++ ; } L %= m ; sumL [ i ] = ( sumL [ i + 1 ] + L ) ; sumL [ i ] %= m ; } System . out . println ( L ) ; } }
import java . util . * ; public class GFG { static void printMax ( int arr [ ] , int n , int k ) { Queue < Integer > Qi = new LinkedList < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { while ( Qi . peek ( ) != - 1 && arr [ i ] >= arr [ Qi . peek ( ) ] ) Qi . poll ( ) ; Qi . add ( i ) ; } for ( int i = k ; i < n ; i ++ ) { System . out . print ( arr [ Qi . peek ( ) ] + " ▁ " ) ; while ( Qi . peek ( ) <= i - k ) Qi . pollFirst ( ) ; while ( Qi . peek ( ) != - 1 && arr [ i ] >= arr [ Qi . peek ( ) ] ) Qi . pollFirst ( ) ; Qi . add ( i ) ; } System . out . print ( arr [ Qi . peek ( ) ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 1 , 78 , 90 , 57 , 89 , 56 } ; int k = 3 ; printMax ( arr , arr . length , k ) ; } }
import java . io . * ; public class GFG { static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( ( b & 1 ) == 1 ) res += a ; a = a << 1 ; b = b >> 1 ; } return res ; } public static void main ( String [ ] args ) { System . out . println ( russianPeasant ( 18 , 1 ) ) ; System . out . println ( russianPeasant ( 20 , 12 ) ) ; } }
public class GFG { static boolean isValid ( String str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) return false ; } return true ; } public static void main ( String [ ] args ) { String str = "0110" ; int len = str . length ( ) ; if ( isValid ( str , len ) ) System . out . println ( " Valid " ) ; else System . out . println ( " Invalid " ) ; } }
import java . io . * ; public class GFG { static int lehmann ( int n , int t ) { int a = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) a = a * a ; for ( int i = 0 ; i < t ; i ++ ) { int result = ( int ) Math . pow ( a , i ) % n ; if ( ( result % n ) == 1 || ( result % n ) == ( n - 1 ) ) { a = random . next ( ) ; } else return - 1 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 13 , t = 10 ; if ( n == 2 ) System . out . println ( "2 ▁ is ▁ Prime . " ) ; if ( n % 2 == 0 ) System . out . println ( n + " ▁ is ▁ Composite . " ) ; else { int flag = lehmann ( n , t ) ; if ( flag == 1 ) System . out . println ( n + " ▁ may ▁ be ▁ Prime . " ) ; else System . out . println ( n + " ▁ is ▁ Composite . " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long ans = 0 ; while ( true ) { if ( a == 0 || b == 0 ) break ; ans += a / b ; a = a % b ; long c = b / a ; a = c % a ; b = c % a ; } System . out . println ( ans ) ; } } }
import java . util . * ; public class Codeforces { public static void main ( String [ ] args ) { Scanner kali = new Scanner ( System . in ) ; String s = kali . next ( ) ; int kali . nextInt ( ) ; if ( s . length ( ) < kali . nextInt ( ) ) System . out . println ( " impossible " ) ; else { int length = kali . nextInt ( ) ; String temp = s . substring ( 0 , length / 2 ) ; int counter = 1 ; for ( int i = 0 ; i < temp . length ( ) ; i ++ ) { if ( temp . charAt ( i ) != temp . charAt ( i + 1 ) ) counter ++ ; } if ( counter > kali . length ( ) ) System . out . println ( " impossible " ) ; else System . out . println ( counter - kali . length ( ) > 0 ? " impossible " : 0 ) ; } } }
import java . io . * ; public class GFG { static int N = 3 ; static int MaxTraceSub ( int mat [ ] [ ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j ; int trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 2 , 5 } , { 6 , 10 , 4 } , { 2 , 7 , -10 } } ; System . out . println ( MaxTraceSub ( mat ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { double [ ] [ ] f = new double [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { f [ i ] [ j ] = in . nextDouble ( ) ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( f [ i ] [ j ] < f [ i ] [ j ] || f [ i ] [ j ] > f [ i ] [ j + 1 ] ) { out . println ( " NO " ) ; return false ; } } } return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int [ ] res = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = 0 ; for ( int j = 0 ; j < n ; j ++ ) { x += arr [ j ] ; } int temp = 0 ; for ( int j = 0 ; j < n ; j ++ ) { temp += arr [ j ] ; if ( temp % 2 != 0 ) { res [ j ] = res [ j ] + 1 ; } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " ▁ " ) ; } System . out . println ( res [ n - 1 ] ) ; } } }
import java . io . * ; public class GFG { static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; i ++ ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( i % j == 0 ) divCount ++ ; } if ( divCount % 2 == 1 ) res ++ ; } return res ; } public static void main ( String [ ] args ) { int a = 1 , b = 10 ; System . out . println ( OddDivCount ( a , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int max = Integer . MIN_VALUE ; int idx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int val = ( arr [ i ] + m - 1 ) / m ; if ( val > max ) { max = val ; idx = i ; } } System . out . println ( idx + 1 ) ; } }
import java . io . * ; public class GFG { static void printArray ( int N , int arr [ ] ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static void replacedArray ( int N , int arr [ ] ) { int pos_sum = 0 , neg_sum = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int diff = abs ( pos_sum ) - abs ( neg_sum ) ; if ( arr [ i ] > 0 ) pos_sum = pos_sum + arr [ i ] ; else neg_sum = neg_sum + arr [ i ] ; arr [ i ] = Math . abs ( diff ) ; } } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , - 1 , 2 , 3 , - 2 } ; replacedArray ( N , arr ) ; printArray ( N , arr ) ; N = 6 ; int arr1 [ ] = { - 3 , - 4 , - 2 , 5 , 1 , - 2 } ; replacedArray ( N , arr1 ) ; printArray ( N , arr1 ) ; } }
import java . io . * ; public class GFG { static void printArray ( int N , int arr [ ] ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static void replacedArray ( int N , int arr [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { int pos_sum = 0 , neg_sum = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } int diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; arr [ i ] = Math . abs ( diff ) ; } } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , - 1 , 2 , 3 , - 2 } ; replacedArray ( N , arr ) ; printArray ( N , arr ) ; N = 6 ; int arr1 [ ] = { - 3 , - 4 , - 2 , 5 , 1 , - 2 } ; replacedArray ( N , arr1 ) ; printArray ( N , arr1 ) ; } }
public class GFG { static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; } public static void main ( String [ ] args ) { String s [ ] = { "1" , "2" , "4" } ; System . out . println ( countDivisbleby4 ( s ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int [ ] arr = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int sum1 = arr [ 0 ] + arr [ 1 ] ; int sum2 = arr [ 2 ] + arr [ 3 ] ; if ( arr [ 0 ] == sum1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < 10000 ; i ++ ) { if ( n > i * 4 ) { ans = n ; break ; } } for ( int i = 0 ; i < 10000 ; i ++ ) { if ( n % i == 0 && ( n / i ) % 4 == 1 && ( n / i ) % 7 == 1 ) { ans = n / i ; break ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } boolean flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= k && arr [ i + 1 ] >= k ) { flag = true ; } } if ( flag ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } } }
import java . util . * ; import java . io . * ; import java . math . * ; public class C { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int D = in . nextInt ( ) ; int I = in . nextInt ( ) ; int M = in . nextInt ( ) ; int N = in . nextInt ( ) ; int [ ] x = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) x [ i ] = in . nextInt ( ) ; int [ ] [ ] dp = new int [ 2 ] [ 256 ] ; Arrays . fill ( dp [ 0 ] , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 256 ; j ++ ) for ( int k = 0 ; k < D ; k ++ ) { int [ ] next = new int [ 2 ] ; for ( int l = 0 ; l < 2 ; l ++ ) { if ( l + D < 2 * M ) next [ k ] = Math . min ( next [ k ] , dp [ l + D ] ) ; else next [ k ] = Math . min ( next [ k ] , dp [ l + D ] ) ; } dp [ 0 ] [ 0 ] = Math . min ( next [ 0 ] , dp [ 1 ] [ 0 ] ) ; for ( int k = 1 ; k < 256 ; k ++ ) { int l = 0 ; int r = 2 * Math . min ( 2 * ( k - M ) , 0 ) ; while ( l < 256 ) { int m = ( l + r ) / 2 ; if ( Math . abs ( next [ k ] - next [ l ] ) <= m ) next [ k ] = Math . min ( next [ k ] , dp [ l ] [ k ] + ( Math . abs ( next [ k ] - next [ l ] ) / M ) * I ; else next [ k ] = Math . min ( next [ k ] , r + ( Math . abs ( next [ k ] - next [ l ] ) / M ) * I ) ; } dp [ l ] [ r ] = Math . min ( next [ l ] , dp [ l ] [ r ] ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] field = new int [ 12 ] [ 12 ] ; boolean [ ] [ ] check = new boolean [ 12 ] [ 12 ] ; for ( int i = 0 ; i < 12 ; i ++ ) { for ( int j = 0 ; j < 12 ; j ++ ) { field [ i ] [ j ] = sc . nextInt ( ) ; check [ i ] [ j ] = false ; } } int count = 0 ; for ( int i = 0 ; i < 12 ; i ++ ) { for ( int j = 0 ; j < 12 ; j ++ ) { if ( check [ i ] [ j ] ) { count ++ ; } } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . length ; if ( arraySortedOrNot ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int min = arr [ 0 ] ; int sum = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; sum = sum + 1 ; } } if ( arr . length == 1 ) { System . out . println ( 0 ) ; } else { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > min ) { sum = sum + 1 ; } } System . out . println ( sum ) ; } } } }
import java . util . * ; public class GFG { static int printKDistinct ( int arr [ ] , int size , int KthIndex ) { HashMap < Integer , Integer > dict = new HashMap < Integer , Integer > ( ) ;vect = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( dict . containsKey ( arr [ i ] ) ) { dict . put ( arr [ i ] , dict . get ( arr [ i ] ) + 1 ) ; } else { dict . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < size ; i ++ ) { if ( dict . get ( arr [ i ] ) > 1 ) continue ; else KthIndex -- ; if ( KthIndex == 0 ) return arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int size = arr . length ; System . out . println ( printKDistinct ( arr , size , 2 ) ) ; } }
import java . io . * ; public class GFG { static int fib ( int f [ ] , int n ) { f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; return f ; } static int findLastDigit ( int n ) { int f [ ] = new int [ 61 ] ; f = fib ( f , 60 ) ; return f [ n % 60 ] ; } public static void main ( String [ ] args ) { int n = 1 ; System . out . println ( findLastDigit ( n ) ) ; n = 61 ; System . out . println ( findLastDigit ( n ) ) ; n = 7 ; System . out . println ( findLastDigit ( n ) ) ; n = 67 ; System . out . println ( findLastDigit ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a == 5 || a == 17 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int z = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] [ ] b = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] [ 0 ] = Math . abs ( a [ i ] - a [ n ] ) ; b [ i ] [ 1 ] = Math . abs ( a [ i ] - a [ n ] ) ; } int [ ] [ ] c = new int [ n + 1 ] [ n + 1 ] ; c [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { c [ i ] [ j ] = Math . abs ( a [ i ] - a [ j - 1 ] ) + c [ i - 1 ] [ j ] ; } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = Math . min ( ans , Math . max ( c [ i ] [ 1 ] , c [ i ] [ 0 ] + b [ i ] [ 1 ] - c [ i - 1 ] [ 0 ] ) ) ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static void countEleLessThanOrEqual ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr2 [ j ] <= arr1 [ i ] ) count ++ ; System . out . print ( count + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 2 , 3 , 4 , 7 , 9 } ; int arr2 [ ] = { 0 , 1 , 2 , 1 , 1 , 4 } ; int m = arr1 . length ; int n = arr2 . length ; countEleLessThanOrEqual ( arr1 , arr2 , m , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int ans = arr [ 0 ] ; if ( k == 1 ) { ans = Math . min ( arr [ 0 ] , arr [ n - 1 ] ) ; } else if ( k == 2 ) { ans = Math . max ( arr [ 0 ] , arr [ n - 1 ] ) ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 5 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; a [ b ] = c ; } for ( int i = 0 ; i < 5 ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } System . out . println ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; Arrays . sort ( a ) ; int x = a [ n / 2 ] ; System . out . println ( x ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int p = sc . nextInt ( ) ; int sum = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { sum += i * ( int ) Math . pow ( 10 , 9 ) ; } System . out . println ( sum % p ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = sc . nextInt ( ) - 1 ; } long count = 0 ; int [ ] L = new int [ N + 1 ] ; int [ ] R = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { L [ i ] = i ; R [ i ] = N + 1 - A [ i ] ; } L [ N ] = N + 1 - A [ N ] ; R [ N ] = N - A [ N ] ; long a = 0 ; for ( int i = N - 1 ; i >= 1 ; i -- ) { long b = R [ i ] ; long c = a + ( R [ i ] - L [ i ] ) * b ; a = L [ i ] ; R [ i ] = c ; a = R [ i ] ; c = L [ i ] ; L [ i ] = b ; R [ i ] = c ; } for ( int i = 1 ; i <= N ; i ++ ) { count += ( long ) A [ i ] * ( ( long ) L [ i ] ) * ( ( long ) R [ i ] ) ; } System . out . println ( count ) ; } }
public class GFG { static int lps ( String str ) { int n = str . length ( ) ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + lps ( seq ) ) ; } }
import java . io . * ; public class GFG { static void printConsecutive ( int last , int first ) { System . out . print ( first ) ; first ++ ; for ( int x = first ; x <= last ; x ++ ) System . out . print ( " ▁ + ▁ " + x ) ; } static void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { System . out . print ( N + " = ▁ " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 12 ; findConsecutive ( n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( a - b > 1 && a + b == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int NumberOfSquares ( int x , int y ) { int s = __gcd ( x , y ) ; int ans = ( x * y ) / ( s * s ) ; return ans ; } public static void main ( String [ ] args ) { int m = 385 , n = 60 ; System . out . println ( NumberOfSquares ( m , n ) ) ; } }
import java . util . * ; public class GFG { static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char [ ] c = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) c [ i ] = s . charAt ( i ) ; Arrays . sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s . charAt ( i ) ) return false ; return true ; } public static void main ( String [ ] args ) { String s = " aabbbcc " ; if ( isAlphabaticOrder ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static void printMax ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { max = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] > max ) max = arr [ i + j ] ; } System . out . print ( max + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = arr . length ; int k = 3 ; printMax ( arr , n , k ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; ArrayList < ArrayList < Integer > > graph = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { graph . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { graph . get ( sc . nextInt ( ) - 1 ) . add ( sc . nextInt ( ) - 1 ) ; graph . get ( sc . nextInt ( ) - 1 ) . add ( sc . nextInt ( ) - 1 ) ; } int [ ] visited = new int [ n ] ; int [ ] notSeen = new int [ n ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == 0 ) continue ; int j = i ; visited [ j ] = 1 ; count ++ ; while ( ! graph . get ( j ) . contains ( j ) ) { graph . get ( j ) . add ( j ) ; } for ( int v : graph . get ( j ) ) { if ( visited [ v ] == 0 ) { notSeen [ v ] ++ ; count ++ ; break ; } } } double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) continue ; sum += ( double ) ( i + 1 ) * ( i + 1 ) ; } System . out . println ( sum ) ; } }
import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int p = sc . nextInt ( ) ; int count = 0 ; for ( int i = 1 ; i <= p ; i ++ ) { if ( i == p ) { count = ( a + b ) / 2 ; if ( count > a * b ) { count = a * b - 1 ; } else { count = ( a + b ) / 2 ; } } else { count = ( b - a ) / 2 ; if ( count > a * a + b * p ) { count = a * a + b * p ; } else { count = ( b - a + 1 ) / 2 ; } } } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] x = new int [ n ] ; int [ ] y = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = sc . nextInt ( ) ; y [ i ] = sc . nextInt ( ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int u = x [ i ] - x [ j ] ; int d = y [ i ] - y [ j ] ; int l = x [ i ] - x [ j ] ; int r = y [ i ] - y [ j ] ; int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( u < x [ j ] && u [ j ] < x [ i ] && y [ j ] < y [ i ] ) { count ++ ; } } if ( count >= k ) { ans = Math . min ( ans , ( u - d ) * ( r - l ) ) ; } } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; String [ ] s = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = sc . next ( ) ; } Arrays . sort ( s ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i % 2 == 0 ) { System . out . print ( s [ i ] + " ▁ " ) ; } else { System . out . print ( s [ i ] + " ▁ " ) ; } } } }
import java . util . ArrayList ; import java . util . Arrays ; class Main { public static ArrayList < String > preProcess ( ArrayList < String > substrings , String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String dup = " " ; for ( int j = i ; j < n ; j ++ ) { dup += s . charAt ( j ) ; substrings . add ( dup ) ; } } substrings . sort ( null ) ; return substrings ; } public static void main ( String [ ] args ) { String s = " geek " ; ArrayList < String > substrings = new ArrayList < > ( ) ; substrings = preProcess ( substrings , s ) ; int [ ] queries = { 1 , 5 , 10 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( substrings . get ( queries [ i ] - 1 ) ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] right = new int [ 4 ] [ 4 ] ; int [ ] left = new int [ 4 ] [ 2 ] ; int [ ] center = new int [ 4 ] [ 2 ] ; while ( true ) { int w = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; if ( w == 0 && h == 0 ) { break ; } int x = 1 ; int y = 1 ; int min = 0 ; int min_w = 0 ; int min_h = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { String s = sc . next ( ) ; if ( s . equals ( " STOP " ) ) { break ; } else if ( s . equals ( " RIGHT " ) ) { y = sc . nextInt ( ) ; x = sc . nextInt ( ) ; if ( x < min ) { min = x ; min_w = x ; } else if ( x > max ) { min = x ; min_w = x ; } } else if ( s . equals ( " LEFT " ) ) { x = sc . nextInt ( ) ; if ( x < min ) { min = x ; min_h = y ; } } else if ( s . equals ( " RIGHT " ) ) { y = sc . nextInt ( ) ; if ( y < min ) { min = y ; min_h = y ; } } else if ( s . equals ( " BACKWARD " ) ) { int right_x = sc . nextInt ( ) ; int left_x = sc . nextInt ( ) ; int right_y = sc . nextInt ( ) ; if ( y < min ) { if ( y < min ) { if ( y > max ) { max = y ; min_y = y ; } else { if ( y > max ) { max = y ; min_y = y ; } } } else if ( s . equals ( " LEFT " ) ) { x = x + 1 ; } else if ( s . equals ( " RIGHT " ) ) { y = y + 1 ; } else if ( s . equals ( " LEFT " ) ) { if ( y > max ) { if ( y > max ) { max = y ; min_y = y ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; String s = input . next ( ) ; int i = 0 ; int x = 0 ; int ans = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( s . charAt ( j ) == s . charAt ( i ) && s . charAt ( j ) == ' x ' ) { x += 1 ; } else { if ( x > 1 ) { ans += x - 1 ; } x = 0 ; } i = j ; } if ( x > 1 ) { ans += x - 1 ; } System . out . println ( ans ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc ; static final int INF = 1 << 28 ; static final double EPS = 1e-9 ; void run ( ) { sc = new Scanner ( System . in ) ; for ( ; ; ) { String s = sc . next ( ) ; if ( s . equals ( "0" ) ) break ; int a = 0 , b = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' A ' ) a ++ ; else b ++ ; } if ( a > b ) { println ( a + " ▁ " + b ) ; } else { println ( a + " ▁ " + b ) ; } } sc . close ( ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . io . * ; public class GFG { static int fact ( int N ) { int product = 1 ; for ( int i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; } static int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 0 , 1 , 2 , 0 } ; int n = arr . length ; System . out . println ( longestSubArray ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; System . out . println ( ( n - 1 ) * 9 + x ) ; } } }
import java . io . * ; public class GFG { static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . println ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; } public static void main ( String [ ] args ) { int l = 8 , b = 8 ; int x = 0 , y = 0 ; maximumArea ( l , b , x , y ) ; } }
public class Main { public static final int NO_OF_CHARS = 256 ; public static int max_distinct_char ( String str , int n ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } public static int smallesteSubstr_maxDistictChar ( String str ) { int n = str . length ( ) ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { String subs = str . substring ( i , j ) ; int subs_length = subs . length ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_length ) ; if ( subs_length < minl && max_distinct == sub_distinct_char ) { minl = subs_length ; } } } return minl ; } public static void main ( String [ ] args ) { String str = " AABBBCBB " ; int l = smallesteSubstr_maxDistictChar ( str ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters : ▁ " + l ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; String s1 = sc . next ( ) ; String s2 = sc . next ( ) ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { flag = false ; break ; } } if ( flag ) { System . out . println ( " NO " ) ; continue ; } int rc = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) == ' R ' && s2 . charAt ( i ) == ' R ' ) { rc ++ ; } } if ( rc != 0 ) { System . out . println ( " NO " ) ; continue ; } if ( rc == 0 ) { System . out . println ( " YES " ) ; } } } }
public class GFG { static int findNumberOfEvenCells ( int n , int [ ] [ ] q , int size ) { int [ ] row = new int [ n ] ; int [ ] col = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) r1 ++ ; if ( row [ i ] % 2 == 1 ) r2 ++ ; if ( col [ i ] % 2 == 0 ) c1 ++ ; if ( col [ i ] % 2 == 1 ) c2 ++ ; } int count = r1 * c1 + r2 * c2 ; return count ; } public static void main ( String [ ] args ) { int n = 2 ; int [ ] [ ] q = { { 1 , 1 } , { 1 , 2 } , { 2 , 1 } } ; int size = q . length ; System . out . println ( findNumberOfEvenCells ( n , q , size ) ) ; } }
import java . io . * ; public class GFG { static void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( " Increasing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Decreasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Increasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; else System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; checkType ( arr , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int count = 0 ; for ( char ch : s . toCharArray ( ) ) { if ( ch == '0' ) count ++ ; } if ( n == 1 || n == 2 ) System . out . println ( count ) ; else { if ( count == 2 ) System . out . println ( ( n / 2 ) - 1 ) ; else { if ( count == 3 ) System . out . println ( ( count - 1 ) / 2 ) ; else System . out . println ( ( count - 1 ) / 2 ) ; } } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; double p1 = ( double ) a / ( double ) b ; double p2 = ( double ) c / ( double ) d ; if ( p1 * p2 < 0 ) { p1 = p1 * ( double ) a / ( double ) b ; } else { p1 = p2 * ( double ) a / ( double ) c ; } int div = gcd ( p1 , p2 ) ; if ( ( int ) div == 0 ) { System . out . println ( 0 ) ; } else { int div2 = ( int ) div ; int div1 = ( int ) div1 ; if ( ( int ) div2 == 0 ) { System . out . println ( ( int ) div2 ) ; } else { System . out . println ( ( int ) div2 / ( int ) div1 ) ; } } } public static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } }
import java . io . * ; public class GFG { static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
import java . io . * ; public class GFG { static void rearrange ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j ++ ; } } System . out . println ( Arrays . toString ( arr ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 } ; int n = arr . length ; rearrange ( arr , n ) ; } }
import java . io . * ; public class GFG { static int centered_square_num ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( n + " th ▁ Centered ▁ square ▁ number : ▁ " ) ; System . out . println ( centered_square_num ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int test = 0 ; test < t ; test ++ ) { int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; if ( k == 1 ) { if ( n % 2 == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { if ( n <= k ) { System . out . println ( " NO " ) ; } else { if ( n % 2 == 0 && k % 2 == 1 ) { System . out . println ( " NO " ) ; } else if ( n % 2 == 1 && k % 2 == 0 ) { System . out . println ( " NO " ) ; } else { int x = 2 * k - 1 ; int min_sum = ( int ) Math . pow ( ( 1 + x ) , 2 ) / 4 ; if ( min_sum > n ) { System . out . println ( " NO " ) ; } else if ( min_sum == n ) { System . out . println ( " YES " ) ; } else { if ( ( n - min_sum ) % 2 == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } } } } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int [ ] b = new int [ n / 2 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { b [ i ] = a [ i ] ; } System . out . println ( b [ 0 ] * b [ n / 2 - 1 ] + b [ n / 2 ] * b [ n / 2 ] ) ; } }
import java . util . * ; public class GFG { static int maxSubArraySum ( int arr [ ] , int size ) { int max_so_far = arr [ 0 ] ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( arr [ i ] , curr_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } static int lenOfLongSubarrWithGivenSum ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == k ) maxLen = i + 1 ; if ( um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - k ) && maxLen < ( i - um . get ( sum - k ) ) && maxLen < ( i - um . get ( sum - k ) ) ) maxLen = i - um . get ( sum - k ) ; } return maxLen ; } static int lenLongSubarrWithMaxSum ( int arr [ ] , int n ) { int maxSum = maxSubArraySum ( arr , n ) ; return lenLongSubarrWithGivenSum ( arr , n , maxSum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 2 , - 1 , 3 , - 4 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ longest ▁ subarray ▁ having ▁ maximum ▁ sum ▁ = ▁ " + lenLongSubarrWithMaxSum ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int ans = arr [ 0 ] * arr [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > ans ) { ans = arr [ i ] * arr [ j ] ; } } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair find ( int dividend , int divisor , int start , int end ) { if ( start > end ) { return new pair ( 0 , dividend ) ; } int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( n > divisor ) start = mid + 1 ; else if ( n < 0 ) end = mid - 1 ; else { if ( n == divisor ) { mid ++ ; n = 0 ; } return new pair ( mid , n ) ; } return find ( dividend , divisor , start , end ) ; } static int divide ( int dividend , int divisor ) { return find ( dividend , divisor , 1 , dividend ) ; } public static void main ( String [ ] args ) { int dividend = 10 , divisor = 3 ; pair [ ] ans = divide ( dividend , divisor ) ; System . out . print ( ans [ 0 ] + " , ▁ " ) ; System . out . print ( ans [ 1 ] ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] [ ] solution = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { solution [ i ] [ 0 ] = Math . abs ( a [ i ] - a [ i - 1 ] ) ; solution [ i ] [ 1 ] = Math . abs ( a [ i ] - a [ i + 1 ] ) ; } int min = Math . abs ( solution [ 0 ] [ 1 ] ) ; int max = Math . abs ( solution [ n - 1 ] [ 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 0 ) { min = Math . abs ( solution [ i - 1 ] [ 0 ] - solution [ i ] [ 1 ] ) ; } else if ( i == n - 1 ) { min = Math . abs ( solution [ i ] [ 0 ] - solution [ i - 1 ] [ 1 ] ) ; } else { min = Math . abs ( solution [ i ] [ 1 ] - solution [ i - 1 ] [ 1 ] ) ; } if ( i == n - 1 ) { max = Math . abs ( solution [ i ] [ 0 ] - solution [ i - 1 ] [ 1 ] ) ; } } System . out . println ( min + " ▁ " + max ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int i = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] != arr [ j + 1 ] ) { count ++ ; } } int max = count ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ j + 1 ] ) { count ++ ; } } if ( count > max ) { max = count ; } System . out . println ( max ) ; } }
import java . io . * ; public class GFG { static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod1 , char aux_rod2 ) { if ( n == 0 ) return ; if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + aux_rod2 ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + ( aux_rod1 + 1 ) + " ▁ to ▁ rod ▁ " + to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + (
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char [ ] s = sc . next ( ) . toCharArray ( ) ; int mod = ( int ) 1e9 + 3 ; int a = 1000 ; int b = 1001 ; int c = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' > ' ) { a = ( a + b ) % mod ; } else if ( s [ i ] == ' < ' ) { b = ( b + c ) % mod ; } else if ( s [ i ] == ' + ' ) { c = ( c + a ) % mod ; } else if ( s [ i ] == ' - ' ) { c = ( c - b ) % mod ; } else { a = ( a + b ) % mod ; } } System . out . println ( ( a * mod ) % mod ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; TreeMap < String , Integer > map = new TreeMap < > ( ) ; int q = Integer . parseInt ( in . next ( ) ) ; for ( int i = 0 ; i < q ; i ++ ) { int odr = Integer . parseInt ( in . next ( ) ) ; switch ( odr ) { case 0 : String key0 = in . next ( ) ; int x0 = Integer . parseInt ( in . next ( ) ) ; map . put ( key0 , x0 ) ; break ; case 1 : String key1 = in . next ( ) ; out . println ( map . get ( key1 ) ) ; break ; case 2 : String key2 = in . next ( ) ; map . remove ( key2 ) ; break ; } } out . flush ( ) ; } }
import java . io . * ; public class GFG { static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( minSum ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int findN ( int k ) { if ( k == 0 ) { int ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; } public static void main ( String [ ] args ) { int k = 7 ; int res = findN ( k ) ; if ( res == - 1 ) System . out . println ( " Not ▁ possible " ) ; else System . out . println ( res ) ; } }
import java . util . Arrays ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { List < Integer > arr = Arrays . asList ( 1 , 2 , 3 ) ; int k = 1 ; int n = arr . size ( ) ; System . out . println ( subsetXOR ( arr , n , k ) ) ; } public static int subsetXOR ( List < Integer > arr , int n , int K ) { int max_ele = arr . get ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr . get ( i ) > max_ele ) { max_ele = arr . get ( i ) ; } } int m = ( 1 << ( int ) ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 ) ) - 1 ; int [ ] [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int [ ] [ ] dp1 : dp ) { for ( int [ ] dp2 : dp1 ) { Arrays . fill ( dp2 , 0 ) ; } } for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k_val = 0 ; k_val <= n ; k_val ++ ) { dp [ i ] [ j ] [ k_val ] = dp [ i - 1 ] [ j ] [ k_val ] ; if ( k_val != 0 ) { dp [ i ] [ j ] [ k_val ] += k_val * dp [ i - 1 ] [ j ^ arr . get ( i - 1 ) ] [ k_val - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int d = sc . nextInt ( ) ; int g = sc . nextInt ( ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < ( 1 << d ) ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int total = 0 ; int sum = 0 ; for ( int j = 0 ; j < d ; j ++ ) { if ( j == 0 ) { total += 100 * ( i + 1 ) * 100 ; } else if ( j == 0 ) { total += 100 * ( i + 1 ) * 100 ; } else { if ( total <= g ) { ans = Math . min ( ans , x + y ) ; } else { sum += y ; } } } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += sc . nextInt ( ) ; } if ( sum == m ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int max = arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; min = arr [ i ] ; } } int ans = n - max - min ; System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int minAbsDiff ( int n ) { int left = ( int ) Math . pow ( 2 , Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( minAbsDiff ( n ) ) ; } }
import java . io . * ; public class GFG { static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; } if ( arr1 [ i ] > arr2 [ j ] ) { if ( table [ j ] > current ) current = table [ j ] ; } } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( table [ i ] > result ) result = table [ i ] ; } return result ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = arr1 . length ; int m = arr2 . length ; System . out . println ( " Length ▁ of ▁ LCIS ▁ is ▁ " + LCIS ( arr1 , n , arr2 , m ) ) ; } }
import java . io . * ; public class GFG { static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; } static int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ) ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " + countSetBits ( n ) ) ; } }
import java . util . * ; public class GFG { static int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 , j = high + 1 ; while ( true ) { i ++ ; while ( arr [ i ] < pivot ) i ++ ; while ( arr [ j ] > pivot ) j -- ; if ( i >= j ) return j ; arr [ i ] = arr [ j ] ; } return i ; } static void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi ) ; quickSort ( arr , pi + 1 , high ) ; } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 7 , 8 , 9 , 1 , 5 } ; quickSort ( arr , 0 , arr . length - 1 ) ; System . out . println ( " Sorted ▁ array : " ) ; printArray ( arr , n ) ; } }
import java . util . * ; public class GFG { static int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j < high ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ high ] ; arr [ high ] = arr [ i + 1 ] ; return ( i + 1 ) ; } static void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } } static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 7 , 8 , 9 , 1 , 5 } ; quickSort ( arr , 0 , arr . length - 1 ) ; System . out . println ( " Sorted ▁ array : " ) ; printArray ( arr , arr . length ) ; } }
import java . io . * ; public class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static void minPossibleSum ( int a [ ] , int n , int x ) { int mxSum = maxSubArraySum ( a , n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum = sum - mxSum + mxSum / x ; System . out . print ( sum + " \n " ) ; } public static void main ( String [ ] args ) { int N = 3 , X = 2 ; int A [ ] = { 1 , - 2 , 3 } ; minPossibleSum ( A , N , X ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int [ ] res = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int max = Math . max ( arr [ i ] , arr [ i + 1 ] ) ; res [ i ] = max ; } Arrays . sort ( res ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " ▁ " ) ; } System . out . println ( ) ; } } }
import java . io . * ; public class GFG { static void printArray ( int N , int sum , int K ) { int minSum = ( N * ( N + 1 ) ) / 2 ; int maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 ; if ( minSum > sum || maxSum < sum ) { System . out . println ( " Not ▁ Possible " ) ; return ; } int [ ] arr = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i ] = i ; int sum = minSum ; for ( int i = N ; i >= 1 ; i -- ) { int x = sum + ( K - i ) ; if ( x < sum ) { sum = sum + ( K - i ) ; arr [ i ] = K ; K -- ; } else { arr [ i ] += ( sum - sum ) ; sum = sum ; break ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 3 , sum = 15 , K = 8 ; printArray ( N , sum , K ) ; } }
public class GFG { static int COST = 3 ; static int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; } public static void main ( String [ ] args ) { int x = 4 , y = 5 , z = 6 ; System . out . println ( maxItems ( x , y , z ) ) ; } }
import java . util . * ; public class GFG { static int run_tasks ( Queue < Integer > A , Queue < Integer > B ) { int total_time = 0 ; while ( A . size ( ) > 0 ) { int x = A . peek ( ) ; int y = B . peek ( ) ; if ( x == y ) total_time += 1 ; else { B . poll ( ) ; A . add ( x ) ; total_time += 2 ; } } return total_time ; } public static void main ( String [ ] args ) { Queue < Integer > A = new LinkedList < > ( ) ; Queue < Integer > B = new LinkedList < > ( ) ; A . add ( 3 ) ; A . add ( 2 ) ; A . add ( 1 ) ; A . add ( 4 ) ; B . add ( 1 ) ; B . add ( 3 ) ; B . add ( 2 ) ; System . out . println ( run_tasks ( A , B ) ) ; } }
import java . io . * ; public class GFG { static void line ( int x0 , int y0 ) { int c = 2 * y0 * x0 ; System . out . println ( y0 + " x ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; } public static void main ( String [ ] args ) { int x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set . add ( sc . nextInt ( ) ) ; } System . out . println ( set . size ( ) ) ; } }
import java . util . * ; import java . io . * ; import java . lang . * ; public class Main { static int INF = 1000000000 ; static int MAXN = 31 ; public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; for ( int i = 0 ; i < n ; ++ i ) { double x0 = input . nextDouble ( ) ; double y0 = input . nextDouble ( ) ; double x1 = input . nextDouble ( ) ; double y1 = input . nextDouble ( ) ; double x2 = input . nextDouble ( ) ; double y2 = input . nextDouble ( ) ; double z3 = input . nextDouble ( ) ; double w = input . nextDouble ( ) ; double q = input . nextDouble ( ) ; double s = Double . PI * q * - 1.0 * Math . sqrt ( x0 * x1 + y0 * y1 ) ; double t = Double . PI * q / 2.0 ; if ( s * t < 0 ) { System . out . println ( 0 ) ; } else if ( s * t > 0 ) { System . out . println ( 1 ) ; } else { System . out . println ( 2 ) ; } } } }
import java . util . * ; public class GFG { static boolean isAnyNotPalindrome ( String s ) { Set < Character > unique = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . add ( s . charAt ( i ) ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; } public static void main ( String [ ] args ) { String s = " aaaaab " ; if ( isAnyNotPalindrome ( s ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; public class GFG { static int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; System . out . println ( findMajority ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int sum = 0 ; int south = 0 ; int south = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; char c = s . charAt ( 0 ) ; int a = sc . nextInt ( ) ; if ( c == ' N ' ) { south += a ; } else if ( c == ' S ' ) { south -= a ; } else { south += a ; } if ( south < 0 ) { System . out . println ( " NO " ) ; return ; } } if ( south < 0 ) { System . out . println ( " NO " ) ; return ; } if ( south > 20000 ) { System . out . println ( " NO " ) ; return ; } int south = 20000 ; int south = 20000 ; boolean result = true ; for ( int i = 0 ; i < n ; i ++ ) { result &= ( south - south >= 0 ) ; result &= ( south + south < 20000 ) ; } if ( result ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 } ; int n = arr . length ; int k = 6 ; System . out . println ( countSubArrays ( arr , n , k ) ) ; } }
import java . util . * ; public class GFG { static boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 || k % 3 != 0 ) return false ; return true ; } public static void main ( String [ ] args ) { int a1 = 6 , b1 = 3 , c1 = 2 , k1 = 7 ; if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static int N = 6 ; static Vector < Integer > [ ] adjacency = new Vector [ N ] ; static void insert ( int x , int y ) { adjacency [ x ] . add ( y ) ; } static void dfs ( int node , int [ ] leaf , boolean [ ] vis ) { leaf [ node ] = 0 ; vis [ node ] = true ; for ( int it : adjacency [ node ] ) { if ( ! vis [ it ] ) { dfs ( it , leaf , vis ) ; leaf [ node ] += leaf [ it ] ; } } if ( adjacency [ node ] . size ( ) == 0 ) leaf [ node ] = 1 ; } static void printLeaf ( int n , int [ ] leaf ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( " The ▁ node ▁ " + i + " ▁ has ▁ " + leaf [ i ] + " ▁ leaf ▁ nodes " ) ; } public static void main ( String [ ] args ) { insert ( 1 , 2 ) ; insert ( 1 , 3 ) ; insert ( 3 , 4 ) ; insert ( 3 , 5 ) ; insert ( 3 , 6 ) ; insert ( 1 , 2 ) ; dfs ( 1 , leaf , vis ) ; printLeaf ( n , leaf ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int k = sc . nextInt ( ) ; int len = s . length ( ) ; int i = 0 ; while ( i < len ) { if ( s . charAt ( i ) == '1' ) { i ++ ; continue ; } else if ( s . charAt ( i ) == '0' ) { i ++ ; continue ; } if ( i >= k ) { System . out . println ( s . charAt ( i ) ) ; return ; } else { break ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; HashMap < Character , Integer > map = new HashMap < > ( ) ; String s = sc . next ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { map . put ( s . charAt ( i ) , map . getOrDefault ( s . charAt ( i ) , 0 ) ) ; } String t = sc . next ( ) ; System . out . println ( solve ( map , t ) ) ; } static int solve ( HashMap < Character , Integer > map , String s ) { int result = 0 ; if ( s . length ( ) != map . size ( ) ) { if ( s . contains ( t . charAt ( 0 ) ) ) { result = - 1 ; } else if ( s . contains ( t . charAt ( 0 ) ) ) { result = map . get ( s . charAt ( 0 ) ) + 1 ; } else { result = Math . min ( map . get ( s . charAt ( 0 ) ) , map . get ( t . charAt ( 1 ) ) ) ; } } return result ; } }
public class GFG { static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int L [ ] [ ] [ ] = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; } public static void main ( String [ ] args ) { String X = " AGGT12" ; String Y = "12TXAYB " ; String Z = "12XBA " ; int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; System . out . println ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcsOf3 ( X , Y , Z , m , n , o ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += Math . abs ( a [ i ] - a [ i + 1 ] ) ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static boolean isSpiltPossible ( int n , int a [ ] ) { int sum = 0 ; int c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) c1 ++ ; } if ( sum % 2 == 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 3 ; int a [ ] = { 1 , 1 , 2 } ; if ( isSpiltPossible ( n , a ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( arr [ i ] == 1 ) { ans ++ ; } else if ( arr [ i ] == 2 ) { ans ++ ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static void count_even_odd ( int min , int max , int steps [ ] [ ] ) { boolean beven = true ; boolean aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { int a = steps [ i ] [ 0 ] ; int b = steps [ i ] [ 1 ] ; if ( ! ( aeven || a & 1 ) ) aeven = true ; if ( beven ) { if ( b & 1 ) beven = false ; } else if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) beven = true ; } else if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) beven = true ; } else if ( b & 1 ) b = true ; } if ( beven ) { int even = ( max / 2 - ( min - 1 ) / 2 ) ; int odd = 0 ; } else { int even = ( max / 2 - ( min - 1 ) / 2 ) ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) { even += ( max - min + 1 - ( max / 2 ) + ( min - 1 ) / 2 ) ; } else { odd += ( max - min + 1 - ( max / 2 ) + ( min - 1 ) / 2 ) ; } System . out . println ( " even ▁ = ▁ " + even + " , ▁ odd ▁ = ▁ " + odd ) ; } public static void main ( String [ ] args ) { int min = 1 , max = 4 ; int steps [ ] [ ] = { { 1 , 2 } , { 3 , 4 } } ; count_even_odd ( min , max , steps ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int ans = 0 ; if ( n % k == 0 ) { ans = n / k ; } else { ans = n / k + 1 ; } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static void printKPFNums ( int A , int B , int K ) { boolean [ ] prime = new boolean [ B + 1 ] ; Arrays . fill ( prime , true ) ; int [ ] p_factors = new int [ B + 1 ] ; for ( int p = 2 ; p <= B ; p ++ ) { if ( p_factors [ p ] == 0 ) { for ( int i = p ; i <= B ; i += p ) p_factors [ i ] = p_factors [ i ] + 1 ; } } for ( int i = A ; i <= B ; i ++ ) { if ( p_factors [ i ] == K ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int A = 14 , B = 18 , K = 2 ; printKPFNums ( A , B , K ) ; } }
import java . util . * ; public class GFG { static void reverserWords ( String str ) { Stack < Integer > st = new Stack < Integer > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != ' ▁ ' ) st . push ( str . charAt ( i ) ) ; else { while ( ! st . empty ( ) ) { System . out . print ( st . peek ( ) ) ; st . pop ( ) ; } System . out . print ( " ▁ " ) ; } } while ( ! st . empty ( ) ) { System . out . print ( st . peek ( ) ) ; st . pop ( ) ; } } public static void main ( String [ ] args ) { String str = " Geeks ▁ for ▁ Geeks " ; reverserWords ( str ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s1 = sc . next ( ) ; String s2 = sc . next ( ) ; int l1 = 0 ; int l2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) > s2 . charAt ( i ) ) { l1 ++ ; } else if ( s1 . charAt ( i ) < s2 . charAt ( i ) ) { l2 ++ ; } } if ( l1 == 0 ) { System . out . println ( " - 1" ) ; } else if ( l1 == l2 ) { System . out . println ( ( l2 / l1 + 1 ) ) ; } else { System . out . println ( ( l2 / l1 + 1 ) ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n + 1 ] ; int [ ] b = new int [ n + 1 ] ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == 1 ) { count ++ ; a [ i ] = 2 ; } else if ( a [ i ] == 2 ) { count ++ ; a [ i ] = 3 ; b [ i ] = 1 ; } } if ( count > 0 ) { System . out . println ( count ) ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } } else { System . out . println ( 2 ) ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( 2 + " ▁ " ) ; } } } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { String [ ] s = in . next ( ) . split ( " [ \\ + = ] " ) ; double a = Double . parseDouble ( s [ 0 ] ) ; if ( s [ 0 ] . length ( ) == 2 ) return false ; a *= a ; if ( s [ 0 ] . length ( ) == 3 ) return true ; return false ; } static void solve ( ) { double [ ] a = new double [ s . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) { char c = s [ i ] . charAt ( 0 ) ; if ( c == ' + ' ) a [ i ] = a [ i + 1 ] ; else if ( c == ' - ' ) a [ i ] = - a [ i + 1 ] ; else if ( c == ' * ' ) a [ i ] *= a [ i + 1 ] ; else a [ i ] /= a [ i + 1 ] ; } int n = a . length ; out . println ( a [ n ] ) ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; solve ( ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int ans = 0 ; if ( k % n == 0 ) { System . out . println ( k / n ) ; } else { while ( k > 0 ) { ans ++ ; k -- ; } System . out . println ( ans ) ; } } }
import java . io . * ; public class GFG { static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n /= 2 ; System . out . println ( ( int ) Math . pow ( 3 , n - 1 ) ) ; } else { n = ( n / 2 ) + 1 ; System . out . println ( ( int ) Math . pow ( 2 , n - 1 ) ) ; } } public static void main ( String [ ] args ) { int N = 4 ; findNthTerm ( N ) ; N = 11 ; findNthTerm ( N ) ; } }
import java . io . * ; public class GFG { static int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i + 1 ] >= arr [ i ] ) len ++ ; else { cnt += ( ( len + 1 ) * len ) / 2 ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 7 , 1 , 1 } ; int n = arr . length ; System . out . println ( countNonIncreasing ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int maximize ( int A1 [ ] , int A2 [ ] , int n , int x , int y ) { int c [ ] = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = A2 [ i ] - A1 [ i ] ; sum += A1 [ i ] ; } Arrays . sort ( c ) ; int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += c [ i ] ; if ( i + 1 >= ( n - x ) ) maxi = Math . max ( sum , maxi ) ; } return maxi ; } public static void main ( String [ ] args ) { int A1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int A2 [ ] = { 5 , 4 , 3 , 2 , 1 } ; int n = 5 ; int x = 3 , y = 3 ; System . out . println ( maximize ( A1 , A2 , n , x , y ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int n = sc . nextInt ( ) ; System . out . println ( solve ( n ) ) ; } sc . close ( ) ; } static int solve ( int n ) { int result = 0 ; for ( int digit = 1 ; digit <= 9 ; digit ++ ) { if ( digit % 1000 == 0 ) { result += 10 ; } else if ( digit % 100 == 0 ) { result += 6 ; } else if ( digit % 10 == 0 ) { result += 3 ; } else { result += 1 ; } } return result ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] cost = new int [ n ] [ n ] ; int m = sc . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; cost [ a ] [ b ] = c ; cost [ b ] [ a ] = d ; } int s = sc . nextInt ( ) - 1 ; int g = sc . nextInt ( ) - 1 ; int v = sc . nextInt ( ) - 1 ; int p = sc . nextInt ( ) - 1 ; int costSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cost [ i ] [ j ] = Math . min ( cost [ i ] [ j ] , cost [ i ] [ j ] + cost [ j ] [ i ] ) ; } } System . out . println ( v - p ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int r1 = sc . nextInt ( ) ; int r2 = sc . nextInt ( ) ; int c1 = sc . nextInt ( ) ; int c2 = sc . nextInt ( ) ; int d1 = sc . nextInt ( ) ; int d2 = sc . nextInt ( ) ; int x = ( d1 + c1 ) / 2 ; int y = ( r2 + c1 ) / 2 ; int z = ( d1 + d2 ) / 2 ; if ( r1 >= 1 && x < 9 && y >= 1 && z < 9 && z > 1 && x < 9 ) System . out . println ( " - 1" ) ; else System . out . println ( x + " ▁ " + y + " ▁ " + z + " ▁ " + ( z - x ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n == 0 && m == 0 ) break ; int [ ] a = new int [ n ] ; int [ ] w = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { w [ i ] = sc . nextInt ( ) ; } int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( j + w [ i ] > i && j - w [ i ] > 0 ) { dp [ j + w [ i ] ] = Math . min ( dp [ j + w [ i ] ] , Math . abs ( j - w [ i ] - i ) ) ; } } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ j ] == Integer . MAX_VALUE ) { ans = Math . min ( ans , Math . abs ( i - w [ j ] ) ) ; } } } System . out . println ( ans == Integer . MAX_VALUE ? - 1 : ans ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int min = Integer . MAX_VALUE ; String [ ] [ ] s = new String [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { String t = sc . next ( ) ; for ( int j = 0 ; j < 2 ; j ++ ) { s [ i ] [ j ] = t . substring ( j , j + 1 ) ; } } for ( int i = 0 ; i < 2 ; i ++ ) { if ( s [ i ] [ 0 ] . equals ( " A " ) ) { if ( s [ i ] [ 1 ] . equals ( " B " ) ) { if ( s [ i ] [ 2 ] . equals ( " A " ) ) { if ( s [ i ] [ 0 ] . equals ( " A " ) ) { min = Math . min ( min , s [ i ] [ 2 ] . equals ( " B " ) ) ; } } else { if ( s [ i ] [ 1 ] . equals ( " A " ) ) { if ( s [ i ] [ 0 ] . equals ( " B " ) ) { min = Math . min ( min , s [ i ] [ 0 ] ) ; } } } } else if ( s [ i ] [ 1 ] . equals ( " C " ) ) { if ( s [ i ] [ 1 ] . equals ( " A " ) ) { if ( s [ i ] [ 0 ] . equals ( " B " ) ) { min = Math . min ( min , s [ i ] [ 1 ] ) ; } } } } } if ( min == Integer . MAX_VALUE ) { System . out . println ( - 1 ) ; } else { System . out . println ( min ) ; } } }
public class GFG { static boolean startsWith ( String str , String pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 , j = 0 ; while ( i < strLen && j < preLen ) { if ( str . charAt ( i ) != pre . charAt ( j ) ) return false ; i ++ ; j ++ ; } return true ; } static boolean endsWith ( String str , String suff ) { int i = str . length ( ) - 1 ; int j = suff . length ( ) - 1 ; while ( i >= 0 && j >= 0 ) { if ( str . charAt ( i ) != suff . charAt ( j ) ) return false ; i -- ; j -- ; } return true ; } static boolean checkString ( String str , String a , String b ) { if ( str . length ( ) != a . length ( ) + b . length ( ) ) return false ; if ( startsWith ( str , a ) ) { if ( endsWith ( str , b ) ) return true ; } if ( startsWith ( str , b ) ) { if ( endsWith ( str , a ) ) return true ; } return false ; } public static void main ( String [ ] args ) { String str = " GeeksforGeeks " ; String a = " Geeksfo " ; String b = " rGeeks " ; if ( checkString ( str , a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . out . println ( i + " ▁ " + j + " ▁ " + k ) ; return ; } } } } } } } public static void main ( String [ ] args ) { int n = 233 ; printCombination ( n ) ; } }
import java . io . * ; public class GFG { static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { if ( i + j + k == n ) result ++ ; } } } return result ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntegralSolutions ( n ) ) ; } }
import java . util . * ; public class GFG { static int TEN = 10 ; static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % TEN ; n /= TEN ; } return sum ; } static int getNthTerm ( int n ) { int sum = digitSum ( n ) ; if ( sum % TEN == 0 ) return ( n * TEN ) ; int extra = TEN - ( sum % TEN ) ; return ( ( n * TEN ) + extra ) ; } static void firstNTerms ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( getNthTerm ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 10 ; firstNTerms ( n ) ; } }
import java . io . * ; public class GFG { static int power ( int x , int a ) { int res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) == 1 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; } static int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct = 0 ; if ( N % 3 == 0 ) { maxProduct = power ( 3 , ( N / 3 ) ) ; return maxProduct ; } else if ( N % 3 == 1 ) { maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; return maxProduct ; } else if ( N % 3 == 2 ) { maxProduct = 2 * power ( 3 , ( N / 3 ) ) ; return maxProduct ; } return maxProduct ; } public static void main ( String [ ] args ) { int maxProduct = breakInteger ( 10 ) ; System . out . println ( maxProduct ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; List < Integer > list = new ArrayList < > ( ) ; list . add ( 1 ) ; for ( int i = 2 ; i <= 100000 ; i ++ ) { if ( list . get ( i ) == 1 ) { list . add ( i ) ; } } int q = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < q ; i ++ ) { String [ ] str = br . readLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int ans = 0 ; for ( int j = n ; j > i ; j -- ) { if ( j < n ) ans += ( n - j ) / i ; } pw . println ( ans ) ; } pw . close ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; String [ ] strs = s . split ( " " ) ; String res = " " ; if ( strs [ 0 ] . equals ( "2019" ) ) { res = strs [ 1 ] + " " + strs [ 2 ] . substring ( 4 ) ; } System . out . println ( res ) ; } }
import java . util . * ; public class GFG { static void firstnonrepeating ( String str ) { Queue < Character > q = new LinkedList < > ( ) ; int [ ] charCount = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { q . add ( str . charAt ( i ) ) ; charCount [ str . charAt ( i ) - ' a ' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( charCount [ q . peek ( ) - ' a ' ] > 1 ) { q . poll ( ) ; } else { System . out . print ( q . peek ( ) + " ▁ " ) ; break ; } } if ( q . isEmpty ( ) ) System . out . print ( - 1 + " ▁ " ) ; } System . out . print ( ) ; } public static void main ( String [ ] args ) { String str = " aabc " ; firstnonrepeating ( str ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int [ ] count = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { a [ i ] = sc . nextInt ( ) - 1 ; b [ i ] = sc . nextInt ( ) - 1 ; count [ a [ i ] ] ++ ; count [ b [ i ] ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( count [ j ] == 0 ) ans ++ ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int solve ( int n , int m , int obstacles , double rangee [ ] ) { double val = Math . min ( n , m ) ; double [ ] rangee = new double [ 2 ] ; Arrays . sort ( rangee ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { rangee [ i ] = 2 * rangee [ i ] ; val -= rangee [ i ] ; if ( val <= 0 ) return c ; else c ++ ; } if ( val > 0 ) return - 1 ; return 1 ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 ; int obstacles = 3 ; double rangee [ ] = { 1.0 , 1.25 , 1.15 } ; System . out . println ( solve ( n , m , obstacles , rangee ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; long x = Long . parseLong ( s . substring ( 0 , 1 ) ) ; long y = Long . parseLong ( s . substring ( 1 , 2 ) ) ; String dir = Integer . toString ( x ) ; if ( dir . equals ( " + " ) ) y += Long . parseLong ( s . substring ( 2 ) ) ; else if ( dir . equals ( " M " ) && y == Long . parseLong ( s . substring ( 0 , 2 ) ) ) { y *= Long . parseLong ( s . substring ( 2 ) ) ; } else if ( dir . equals ( " I " ) && y == Long . parseLong ( s . substring ( 2 ) ) ) { y = " I " ; } else if ( dir . equals ( " + " ) && y == Long . parseLong ( s . substring ( 1 ) ) ) { y = " U " ; } else if ( dir . equals ( " - " ) && y == Long . parseLong ( s . substring ( 2 ) ) ) { y = " M " ; } else if ( dir . equals ( " - " ) && y == Long . parseLong ( s . substring ( 0 , 2 ) ) ) { y = " L " ; } else if ( dir . equals ( " - " ) && y == Long . parseLong ( s . substring ( 1 ) ) ) { y = " U " ; } else if ( dir . equals ( " M " ) && y == Long . parseLong ( s . substring ( 2 ) ) ) { y = " L " ; } else if ( dir . equals ( " I " ) && y == Long . parseLong ( s . substring ( 0 , 2 ) ) ) { y = " I " ; } System . out . println ( y ) ; } }
import java . util . * ; public class GFG { static class MinStack { int size = 0 ; int [ ] stack = new int [ size ] ; int [ ] min_stack = new int [ size ] ; } ; static class MinStack { int [ ] stack = new int [ size ] ; MinStack ( ) { } ; void push ( int x ) { stack [ size ++ ] = x ; if ( size == 0 ) { min_stack [ size ++ ] = x ; return ; } if ( x <= min_stack [ size - 1 ] ) min_stack [ size -- ] = x ; else min_stack [ size -- ] = min_stack [ size - 1 ] ; } int pop ( ) { if ( size > 0 ) { return stack [ size -- ] ; } return stack [ size -- ] ; } int top ( ) { return stack [ size -- ] ; } int getMin ( ) { if ( size > 0 ) return min_stack [ size -- ] ; return null ; } public static void main ( String [ ] args ) { MinStack m = new MinStack ( ) ; m . push ( - 2 ) ; m . push ( 0 ) ; m . push ( - 3 ) ; System . out . println ( m . getMin ( ) ) ; m . push ( m . top ( ) ) ; System . out . println ( m . getMin ( ) ) ; m . pop ( ) ; System . out . println ( m . getMin ( ) ) ; } }
import java . util . * ; public class GFG { static String [ ] one = { " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " } ; static String [ ] ten = { " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " } ; static String numToWords ( int n , String s ) { String str = " " ; if ( n > 19 ) str += ten [ n / 10 ] + one [ n % 10 ] ; else str += one [ n ] ; if ( n != 0 ) str += s ; return str ; } static void convertToWords ( int n ) { String out = " " ; out += numToWords ( ( n / 10000000 ) , " crore ▁ " ) ; out += numToWords ( ( n / 100000 ) % 100 , " lakh ▁ " ) ; out += numToWords ( ( n / 100 ) % 100 , " thousand ▁ " ) ; out += numToWords ( ( n % 100 ) % 10 , " hundred ▁ " ) ; if ( n > 100 && n % 100 != 0 ) out += " and ▁ " ; out += numToWords ( ( n % 100 ) , " hundred ▁ " ) ; if ( n > 100 && n % 100 != 0 ) out += " and ▁ " ; out +=
import java . io . * ; public class GFG { static int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; } static boolean areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; } static int sub ( int a , int b ) { return a + flipSign ( b ) ; } static int mul ( int a , int b ) { if ( a < b ) return mul ( b , a ) ; int sum = 0 ; for ( int i = Math . abs ( b ) ; i >= 1 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; } static int division ( int a , int b ) { int quotient = 0 ; int divisor = flipSign ( Math . abs ( b ) ) ; for ( int dividend = Math . abs ( a ) ; dividend + divisor <= Math . abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; } public static void main ( String [ ] args ) { System . out . println ( " Subtraction ▁ is ▁ " + sub ( 4 , - 2 ) ) ; System . out . println ( " Product ▁ is ▁ " + mul ( - 9 , 6 ) ) ; int a = 8 , b = 2 ; if ( b > 0 ) System . out . println ( " Exception ▁ : - ▁ Division ▁ is ▁ " + division ( a , b ) ) ; else System . out . println ( " Exception ▁ : - ▁ Divide ▁ by ▁ 0" ) ; } }
import java . io . * ; public class GFG { static int factorial ( int n ) { int i = n ; int fact = 1 ; while ( n / i != n ) { fact = fact * i ; i -- ; } return fact ; } public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( " Factorial ▁ of ▁ " + num + " ▁ is ▁ " + factorial ( 5 ) ) ; } }
import java . io . * ; public class GFG { static int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = arr . length ; int x = 2 ; System . out . println ( CntDivbyX ( arr , n , x ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long ans = 0 ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { int t = 0 ; for ( int j = 0 ; j < n ; j ++ ) { while ( a [ j ] % 2 == 0 ) { t ++ ; a [ j ] /= 2 ; } } ans += t ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int min_noOf_operation ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res += noOfSubtraction ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = arr . length ; int k = 5 ; System . out . println ( min_noOf_operation ( arr , N , k ) ) ; } }
import java . io . * ; public class GFG { static int CountSubSet ( int arr [ ] , int n , int X ) { int N = ( int ) Math . pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == X ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 , 7 } ; int X = 5 ; int n = arr . length ; System . out . println ( CountSubSet ( arr , n , X ) ) ; } }
public class GFG { static int n = 5 ; static int FindMaxProduct ( int arr [ ] [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int result ; if ( ( j - 3 ) >= 0 ) result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) ; if ( max < result ) max = result ; if ( ( i - 3 ) >= 0 ) result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) ; if ( max < result ) max = result ; if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) ; if ( max < result ) max = result ; if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ) ; if ( max < result ) max = result ; } } return max ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } } ; System . out . println ( FindMaxProduct ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 50002 ; static Vector < Integer > primes = new Vector < Integer > ( ) ; static void sieve ( ) { boolean [ ] isPrime = new boolean [ MAX ] ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { isPrime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( isPrime [ p ] ) primes . add ( p ) ; } } static int power ( int x , int y ) { int count = 0 ; int z = y ; while ( x >= z ) { count += ( x / z ) ; z *= y ; } return count ; } static int modMult ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } static int countWays ( int n , int m ) { int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { int powers = power ( n , primes . get ( i ) ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; } public static void main ( String [ ] args ) { sieve ( ) ; int n = 4 , m = 7 ; System . out . println ( countWays ( n , m ) ) ; } }
import java . io . * ; public class GFG { static int smallestIndexsum ( int arr [ ] , int n ) { int i = n - 1 ; while ( i >= 0 && arr [ i ] % 2 == 1 ) i -- ; int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) sum += arr [ j ] ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 6 , 3 , 3 } ; int n = arr . length ; System . out . println ( smallestIndexsum ( arr , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; import java . util . TreeSet ; import java . util . * ; import static java . lang . System . * ; import static java . lang . Math . * ; public class pre5 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; String s = obj . next ( ) ; int y1 = obj . nextInt ( ) , m1 = obj . nextInt ( ) , d = obj . nextInt ( ) ; int y2 = obj . nextInt ( ) , m2 = obj . nextInt ( ) ; int ans = 0 ; for ( int i = y1 ; i <= y2 ; i ++ ) { ans = Math . abs ( ( y2 - i ) - i ) ; } out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String S = scanner . nextLine ( ) ; int totalQ = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == ' Q ' ) { totalQ ++ ; } } int CQ = 0 ; int CQAQ = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == ' Q ' ) { CQ ++ ; } else if ( S . charAt ( i ) == ' A ' ) { CQAQ += CQ * ( totalQ - CQ ) ; } } System . out . println ( CQAQ ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; } int [ ] dp = new int [ k + 1 ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; dp [ 0 ] = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i + 1 ] != Integer . MAX_VALUE ) { if ( k - i <= 0 ) continue ; if ( dp [ i ] == Integer . MAX_VALUE ) { dp [ i ] = Math . min ( dp [ i + 1 ] , dp [ i ] + 1 ) ; ans ++ ; } else { dp [ i ] = Math . min ( dp [ i + 1 ] , dp [ i ] + 1 ) ; ans ++ ; } } } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class A_EhabAndAnotherConstructionProblem { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int s = scanner . nextInt ( ) ; int result = 0 ; if ( s % n == 0 ) { result = ( s / n ) ; } else { result = ( s / n + 1 ) ; } System . out . println ( result ) ; } }
import java . util . * ; public class GFG { static void multiply ( Vector < Integer > v , int x ) { int carry = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + v . get ( i ) * x ; v . set ( i , res % 10 ) ; carry = res / 10 ; } while ( carry != 0 ) { v . add ( carry % 10 ) ; carry /= 10 ; } } static int findSumOfDigits ( int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; v . add ( 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) multiply ( v , i ) ; int sum = 0 ; size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) sum += v . get ( i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 1000 ; System . out . println ( findSumOfDigits ( n ) ) ; } }
import java . util . * ; public class B935 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; String s = sc . next ( ) ; int [ ] [ ] a = new int [ n ] [ m ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String s1 = s . substring ( 0 , i ) ; String s2 = s . substring ( i , s1 . length ( ) ) ; for ( int j = 0 ; j < m ; j ++ ) { int u = 0 , l = 0 ; int r = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { char ch = s1 . charAt ( i ) ; if ( ch == ' U ' && i != s1 . length ( ) - 1 ) { u ++ ; } else if ( ch == ' L ' && i != s1 . length ( ) - 1 ) { l ++ ; } else if ( ch == ' R ' && i != s1 . length ( ) - 1 ) { r ++ ; } } if ( u == 0 && l == 0 && r == 0 ) ans ++ ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] ramp = new int [ n ] ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int li = sc . nextInt ( ) ; int ri = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int max = 0 ; for ( int j = ri ; j <= ri ; j ++ ) { max = Math . max ( max , x ) ; if ( max == 0 ) { x [ j ] = ri + 1 ; } ri = li ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( x [ i ] + " ▁ " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int max = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > max ) { max = arr [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . io . * ; public class GFG { static int pell ( int n ) { if ( n <= 2 ) return n ; return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pell ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = 1 , b = n * n ; for ( int i = 1 ; i < n ; i ++ ) { System . out . println ( ( a + b ) + " ▁ " + ( b + i ) ) ; } } }
import java . util . * ; public class GFG { static int binary_search ( int arr [ ] , int low , int high , int ele ) { while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == ele ) return mid ; else if ( arr [ mid ] > ele ) high = mid ; else low = mid + 1 ; } return - 1 ; } static void printSmall ( int arr [ ] , int asize , int n ) { int copy [ ] = new int [ asize ] ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < asize ; i ++ ) { if ( binary_search ( copy , low = 0 , high = n , ele = arr [ i ] ) > - 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . length ; int n = 5 ; printSmall ( arr , asize , n ) ; } }
import java . io . * ; public class GFG { static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += Math . pow ( 2 , k ) ; k ++ ; n >>= 1 ; } return count ; } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( countNumbers ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int r = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int x = e / a ; int y = e % b ; int z = 0 , y = 0 ; while ( z <= y ) { z ++ ; y ++ ; } System . out . println ( Math . max ( r , r + ( x * y ) ) ) ; } }
import java . util . * ; public class GFG { static int max = Integer . MIN_VALUE ; static int ans = Integer . MAX_VALUE ; static Vector < Vector < Integer > > graph = new Vector < Vector < Integer > > ( ) ; static Vector < Integer > weight = new Vector < Integer > ( ) ; static void dfs ( int node , int parent ) { int a = Integer . bitCount ( weight . get ( node ) + x ) ; if ( max < a ) { max = a ; ans = node ; } else if ( max == a ) { ans = Math . min ( ans , node ) ; } for ( int to : graph . get ( node ) ) { if ( to == parent ) continue ; dfs ( to , node ) ; } } public static void main ( String [ ] args ) { int x = 15 ; int w [ ] = { 5 , 10 , 11 , 8 , 6 } ; w [ 1 ] = 5 ; w [ 2 ] = 10 ; w [ 3 ] = 11 ; w [ 4 ] = 8 ; w [ 5 ] = 6 ; graph . add ( new Vector < Integer > ( ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) { graph . get ( i ) . add ( 0 ) ; } weight . add ( 0 ) ; graph . get ( 0 ) . add ( 1 ) ; System . out . println ( ans ) ; } }
public class GFG { static int MAX = 26 ; static void updateFreq ( String str , int freq [ ] ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } } static int maxCount ( String str , String patt ) { int [ ] strFreq = new int [ MAX ] ; int [ ] pattFreq = new int [ MAX ] ; updateFreq ( str , strFreq ) ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( pattFreq [ i ] == 0 ) continue ; ans = Math . min ( ans , strFreq [ i ] / pattFreq [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; String patt = " geeks " ; System . out . println ( maxCount ( str , patt ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int sum = a + b ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + sc . nextInt ( ) ; } System . out . println ( sum ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int L = input . nextInt ( ) ; int R = input . nextInt ( ) ; int QL = input . nextInt ( ) ; int QR = input . nextInt ( ) ; int [ ] W = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { W [ i ] = input . nextInt ( ) ; } int [ ] sum_el = new int [ n + 1 ] ; sum_el [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum_el [ i ] = W [ i - 1 ] + sum_el [ i - 1 ] ; } int answer = QR * ( n - 1 ) + sum_el [ n ] * R ; for ( int i = 1 ; i <= n ; i ++ ) { int energy = L * sum_el [ i ] + R * ( sum_el [ n ] - sum_el [ i ] ) ; if ( i > ( n - i ) ) { energy = energy + ( i - ( n - i ) - 1 ) * QL ; } else if ( ( n - i ) > i ) { energy = energy + ( ( n - i ) - i - 1 ) * QR ; } if ( energy < answer ) { answer = energy ; } } System . out . println ( answer ) ; } }
import java . io . * ; public class GFG { static int wastedWater ( int V , int M , int N ) { int amt_per_min = M - N ; int time_to_fill = V / amt_per_min ; int wasted_amt = N * time_to_fill ; return wasted_amt ; } public static void main ( String [ ] args ) { int V = 700 ; int M = 10 ; int N = 3 ; System . out . println ( wastedWater ( V , M , N ) ) ; V = 1000 ; M = 100 ; N = 50 ; System . out . println ( wastedWater ( V , M , N ) ) ; } }
import java . io . * ; public class GFG { static int maxSubStr ( String str , int n ) { int count0 = 0 , count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) count0 ++ ; else count1 ++ ; if ( count0 == count1 ) cnt ++ ; } if ( count0 != count1 ) return - 1 ; return cnt ; } public static void main ( String [ ] args ) { String str = "0100110101" ; int n = str . length ( ) ; System . out . println ( maxSubStr ( str , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int min = Math . min ( a , Math . min ( b , c ) ) ; int max = Math . max ( a , Math . max ( b , c ) ) ; System . out . println ( min + " ▁ " + max ) ; } }
import java . io . * ; public class GFG { static int findS ( int s ) { int sum = 0 ; int n = 1 ; while ( sum < s ) { sum += n ; n ++ ; } n -- ; if ( sum == s ) return n ; return - 1 ; } public static void main ( String [ ] args ) { int s = 15 ; int n = findS ( s ) ; if ( n == - 1 ) System . out . println ( " - 1" ) ; else System . out . println ( n ) ; } }
import java . io . * ; public class GFG { static int maximumAbsolute ( int arr [ ] , int n ) { int mn = Integer . MAX_VALUE , mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < n - 1 && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int common_integer = ( mn + mx ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == - 1 ) { arr [ i ] = common_integer ; } } int max_diff = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; if ( diff > max_diff ) { max_diff = diff ; } } return max_diff ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , - 1 , 11 , - 1 , 3 , - 1 } ; int n = arr . length ; System . out . println ( maximumAbsolute ( arr , n ) ) ; } }
public class GFG { static final int MOD = 1000000007 ; static int countStrings ( int N ) { int [ ] [ ] dp = new int [ N + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] % MOD ) ; dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( countStrings ( N ) ) ; } }
public class GFG { static int longest_subseq ( int n , int k , String s ) { int dp [ ] = new int [ n ] ; int max_length [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s . charAt ( i ) - ' a ' ; int lower = Math . max ( 0 , curr - k ) ; int upper = Math . min ( 25 , curr + k ) ; for ( int j = lower ; j <= upper ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = Math . max ( dp [ i ] , max_length [ curr ] ) ; } return Math . max ( dp [ 0 ] , max_length [ 1 ] ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int n = s . length ( ) ; int k = 3 ; System . out . println ( longest_subseq ( n , k , s ) ) ; } }
import java . io . * ; public class GFG { static int longestFibonacciSubarray ( int n , int a [ ] ) { if ( n <= 2 ) return n ; int len = 2 ; int mx = Integer . MIN_VALUE ; for ( int i = 2 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) len ++ ; else len = 2 ; mx = Math . max ( mx , len ) ; } return mx ; } public static void main ( String [ ] args ) { int n = 5 ; int a [ ] = { 2 , 4 , 6 , 10 , 2 } ; System . out . println ( longestFibonacciSubarray ( n , a ) ) ; } }
import java . util . * ; public class GFG { static int minimumSubarrays ( int ar [ ] , int n ) { Vector < Integer > se = new Vector < Integer > ( ) ; int cnt = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( se . size ( ) == 0 ) se . add ( ar [ i ] ) ; else { cnt ++ ; se . clear ( ) ; se . add ( ar [ i ] ) ; } } return cnt ; } public static void main ( String [ ] args ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 } ; int n = ar . length ; System . out . println ( minimumSubarrays ( ar , n ) ) ; } }
import java . io . * ; public class GFG { static boolean check ( int s ) { int freq [ ] = new int [ 10 ] ; while ( s != 0 ) { int r = s % 10 ; s /= 10 ; freq [ r ] ++ ; } int xor = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) xor = xor ^ freq [ i ] ; if ( xor == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class _1005A_TanyaandStairways { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int res = sum / k ; for ( int i = 0 ; i < n ; i ++ ) { res += ( res / k ) ; res = res / k ; } System . out . print ( res + " ▁ " ) ; } }
class Main { static final int MAXN = 1000005 ; static int [ ] even = new int [ MAXN ] ; static int [ ] odd = new int [ MAXN ] ; public static void precompute ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd [ i ] = 1 ; } if ( arr [ i ] % 2 == 0 ) { even [ i ] = 1 ; } } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } } public static boolean isOdd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) { cnt -= odd [ L - 1 ] ; } if ( cnt == R - L + 1 ) { return true ; } return false ; } public static void performQueries ( int [ ] a , int n , int [ ] [ ] q , int m ) { precompute ( a , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] [ 0 ] ; int R = q [ i ] [ 1 ] ; if ( isOdd ( L , R ) ) { System . out . println ( " Odd " ) ; } else { System . out . println ( " Even " ) ; } } } public static void main ( String [ ] args ) { int [ ] a = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int n = a . length ; int [ ] [ ] q = { { 0 , 2 } , { 1 , 2 } , { 2 , 3 } , { 3 , 6 } } ; int m = q . length ; performQueries ( a , n , q , m ) ; } }
import java . util . * ; public class Codeforces { public static void main ( String args [ ] ) { try ( Scanner in = new Scanner ( System . in ) ) { int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; int a [ ] [ ] = new int [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { a [ i ] [ j ] = ( n - i * 7 - j ) * 5 ; } } int k = 0 ; int w = n / 3 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] [ j ] == 0 ) { continue ; } if ( j == w ) { continue ; } for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] [ k ] == 0 ) { continue ; } a [ i ] [ j ] -- ; a [ i ] [ k ] ++ ; w ++ ; } } } if ( w == 0 ) System . out . println ( - 1 ) ; else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 0 ) { System . out . println ( ( i + 1 ) + " ▁ " + ( j + 1 ) + " ▁ " + ( k ) ) ; continue ; } } } System . out . println ( a [ n - 1 ] [ k ] ) ; } } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int o = sc . nextInt ( ) ; int p = sc . nextInt ( ) ; int time = sc . nextInt ( ) ; int count = 0 ; int min = time ; for ( int i = 0 ; i < 120 ; i ++ ) { if ( time + o * i >= 60 ) { time = time + o * i ; count ++ ; } else { if ( time - min >= 60 ) { break ; } } if ( i == 120 ) { count ++ ; } } if ( time - min >= 30 ) { count ++ ; } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } if ( solve ( a , n ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } public static boolean solve ( int [ ] a , int n ) { int xor = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( xor == a [ i ] ) { return true ; } xor ^= a [ i ] ; } return false ; } }
import java . io . * ; public class GFG { static int times ( int steps [ ] , int n ) { int current_level = 0 , previous_level = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int steps [ ] = { 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 } ; int n = steps . length ; System . out . println ( times ( steps , n ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { int n = in . nextInt ( ) ; int [ ] m = new int [ n ] ; int [ ] d = new int [ n ] ; int [ ] v = new int [ n ] ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = in . nextInt ( ) ; d [ i ] = in . nextInt ( ) ; v [ i ] = in . nextInt ( ) ; s [ i ] = in . nextInt ( ) ; } int ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { int time = 0 ; int min = 360 ; for ( int j = 0 ; j < m [ i ] ; j ++ ) { if ( j + v [ i ] - 1 < 0 ) { time += 360 ; } else { time += v [ i ] - 1 ; min = Math . min ( min , Math . abs ( time - m [ i ] - time - j ) ) ; } ans = Math . min ( ans , s [ i ] - s [ i ] ) ; if ( i + 1 < n && m [ i ] - 1 < 0 ) { m [ i ] = 0 ; time += 360 ; } else if ( m [ i ] - 1 < 0 ) { m [ i ] = 0 ; time += 360 ; } } ans = Math . min ( ans , Math . abs ( time - m [ i ] ) ) ; } out . println ( ans ) ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; solve ( ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int u = 0 , p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && arr [ i ] % 1000 == 0 ) { u ++ ; } else if ( arr [ i ] % 1000 == 1 ) { p ++ ; } } if ( u > p ) { System . out . println ( " Petr " ) ; } else if ( u < p ) { System . out . println ( " Um _ nik " ) ; } else { System . out . println ( " Petr " ) ; } } }
public class GFG { static String smallest ( String s ) { int l = s . length ( ) ; String ans = " " ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) ans += s . charAt ( j ) ; } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; } public static void main ( String [ ] args ) { String s = " abcda " ; System . out . println ( smallest ( s ) ) ; } }
import java . util . Scanner ; public class A_Point_on_Spiral { static Scanner in = new Scanner ( System . in ) ; static int x , y ; static int a , b ; static boolean solve ( int start ) { a = start ; b = start ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( a == start ) { return true ; } else if ( a == b ) { return true ; } } return false ; } public static void main ( String [ ] amit ) { x = in . nextInt ( ) ; y = in . nextInt ( ) ; a = solve ( start ) ; b = solve ( start ) ; if ( solve ( x , y ) && solve ( x , y ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . * ; public class GFG { static int FindMinNumber ( int arr [ ] , int n , int k ) { int i = 0 , j = 0 ; int min_num = Integer . MAX_VALUE ; boolean found = false ; int sum = 0 ; while ( i < n ) { sum = sum + arr [ i ] ; if ( sum == k ) { min_num = Math . min ( min_num , ( n - ( i + 1 ) ) + j ) ; found = true ; } else if ( sum > k ) { while ( sum > k ) { sum = sum - arr [ j ++ ] ; } if ( sum == k ) { min_num = Math . min ( min_num , ( ( n - ( i + 1 ) ) + j ) ; found = true ; } } i ++ ; } if ( found ) return min_num ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 5 , 6 } ; int n = arr . length ; int k = 5 ; System . out . println ( FindMinNumber ( arr , n , k ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int c = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( s . charAt ( i ) == '1' ) c ++ ; } System . out . println ( c ) ; } }
import java . io . * ; public class GFG { static void nthPalindrome ( int n , int k ) { int temp ; if ( k % 2 == 1 ) temp = k / 2 ; else temp = k / 2 - 1 ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome = palindrome + n - 1 ; System . out . print ( palindrome ) ; if ( k % 2 == 1 ) { palindrome = palindrome / 10 ; } while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome = palindrome / 10 ; } } public static void main ( String [ ] args ) { int n = 6 , k = 5 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; System . out . println ( ) ; n = 10 ; k = 6 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; System . out . println ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int [ ] y = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { y [ i ] = sc . nextInt ( ) ; } long ans = Long . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { sum += y [ j ] ; ans = Math . min ( ans , sum * i ) ; } sum = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { sum += y [ j ] ; ans = Math . min ( ans , sum * i + ( ( j - 1 ) * x ) + ( ( j - 1 ) * y ) + ( ( j - 1 ) * x ) + ( ( j - 1 ) * y ) ) ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int MAX = 10000 ; static int [ ] hashTable = new int [ MAX ] ; static int minOperations ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] > 0 ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; } res ++ ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int p1 , p2 , p3 , p4 , a , b ; p1 = scanner . nextInt ( ) ; p2 = scanner . nextInt ( ) ; p3 = scanner . nextInt ( ) ; p4 = scanner . nextInt ( ) ; a = scanner . nextInt ( ) ; b = scanner . nextInt ( ) ; if ( Math . min ( p1 , Math . min ( p2 , Math . min ( p3 , p4 ) ) ) > a && Math . min ( p1 , Math . min ( p2 , Math . min ( p3 , p4 ) ) ) <= b ) { System . out . println ( Math . min ( p1 , Math . min ( p2 , Math . min ( p3 , p4 ) ) ) - a ) ; } else if ( Math . min ( p1 , Math . min ( p2 , Math . min ( p3 , p4 ) ) ) > b && Math . min ( p1 , Math . min ( p2 , Math . min ( p3 , p4 ) ) ) > a && a != b ) { System . out . println ( b - a + 1 ) ; } else if ( a == b && Math . min ( p1 , Math . min ( p2 , Math . min ( p3 , p4 ) ) ) > a ) { System . out . println ( Math . min ( p1 , Math . min ( p2 , Math . min ( p3 , p4 ) ) ) - a ) ; } else { System . out . println ( 0 ) ; } } }
public final class p049 { public static void main ( String [ ] args ) { System . out . println ( new p049 ( ) . run ( ) ) ; } public String run ( ) { BigInteger numer = BigInteger . ONE , denom = BigInteger . ONE ; for ( int d = 10 ; d <= 100 ; d ++ ) { for ( int n = 10 ; n < d ; n ++ ) { int n0 = n % 10 ; int n1 = n / 10 ; int d0 = d % 10 ; int d1 = d / 10 ; if ( n1 == d0 && n0 * d == n * d1 ) || ( n0 == d1 && n1 * d == n * d0 ) ) { numer *= n ; denom *= d ; } } } return BigInteger . valueOf ( denom / Library . gcd ( numer , denom ) ) . toString ( ) ; } }
import java . io . * ; public class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static int countOfOddPascal ( int n ) { int c = countSetBits ( n ) ; return ( int ) Math . pow ( 2 , c ) ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( countOfOddPascal ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long x = sc . nextLong ( ) ; long y = sc . nextLong ( ) ; long ans = Math . max ( a * ( x - 1 ) * b , Math . max ( a * ( y - 1 ) * a , b * ( x - 1 ) * b ) ) ; System . out . println ( ans ) ; } } }
import java . util . * ; public class GFG { static int minSwaps ( int arr [ ] ) { int n = arr . length ; int [ ] arrpos = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arrpos [ i ] = arr [ i ] ; Arrays . sort ( arrpos ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos [ i ] == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos [ j ] ; cycle_size ++ ; } if ( cycle_size > 0 ) ans += ( cycle_size - 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 4 , 3 , 2 } ; System . out . println ( minSwaps ( arr ) ) ; } }
import java . util . * ; public class GFG { static int N = 1000005 ; static boolean prime [ ] = new boolean [ N ] ; static void sieve ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j < N ; j += i ) prime [ j ] = false ; } } } static int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; boolean flag = true ; while ( num != 0 ) { if ( prime [ num ] == false ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power != 0 ) { if ( prime [ num % power ] == false ) { flag = false ; break ; } power *= 10 ; } if ( flag == true ) sum += i ; } return sum ; } public static void main ( String [ ] args ) { int n = 25 ; sieve ( ) ; System . out . println ( sumTruncatablePrimes ( n ) ) ; } }
import java . io . * ; public class GFG { static void findWeights ( int X ) { int sum = 0 ; int power = 0 ; while ( sum < X ) { sum = ( int ) Math . pow ( 3 , power + 1 ) - 1 ; sum /= 2 ; power ++ ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { System . out . print ( ans + " ▁ " ) ; ans = ans * 3 ; } } public static void main ( String [ ] args ) { int X = 2 ; findWeights ( X ) ; } }
import java . util . * ; public class GFG { static Vector < Integer > addToArrayForm ( int [ ] A , int K ) { Vector < Integer > v = new Vector < Integer > ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; int rem = 0 , i ; for ( i = A . length - 1 ; i >= 0 ; i -- ) { int my = A [ i ] + ( K % 10 ) + rem ; if ( my > 9 ) { rem = 1 ; v . add ( my % 10 ) ; } else { v . add ( my ) ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { my = ( K % 10 ) + rem ; v . add ( my % 10 ) ; if ( my / 10 > 0 ) { rem = 1 ; } else { rem = 0 ; } K = K / 10 ; } if ( rem > 0 ) { v . add ( rem ) ; } for ( i = v . size ( ) - 1 ; i >= 0 ; i -- ) { ans . add ( v . get ( i ) ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 7 , 4 } ; int K = 181 ; Vector < Integer > ans = addToArrayForm ( A , K ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) ) ; } }
import java . io . * ; public class GFG { static void printPaths ( char [ ] [ ] inputchar , int R , int C ) { for ( int i = 0 ; i < C ; i ++ ) { dfs ( inputchar , " " , 0 , i , R , C ) ; System . out . print ( ) ; } } static void dfs ( char [ ] [ ] inputchar , int res , int i , int j , int R , int C ) { if ( i == R ) { System . out . print ( res + " ▁ " ) ; return ; } res = res + inputchar [ i ] [ j ] ; for ( int k = 0 ; k < C ; k ++ ) { dfs ( inputchar , res , i + 1 , k , R , C ) ; if ( i + 1 == R ) break ; } } public static void main ( String [ ] args ) { char [ ] [ ] inputchar = { { ' a ' , ' b ' } , { ' d ' , ' e ' } } ; int R = inputchar . length ; int C = inputchar [ 0 ] . length ; printPaths ( inputchar , R , C ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s . charAt ( i ) ; if ( ch == ' R ' ) { for ( int j = 0 ; j < 10 ; j ++ ) { a [ j ] = 1 ; } } else if ( ch == ' L ' ) { for ( int j = 0 ; j < 10 ; j ++ ) { a [ j ] = 0 ; } } else if ( ch == ' R ' ) { for ( int j = 0 ; j < 10 ; j ++ ) { a [ j ] = 1 ; } } } else { for ( int j = 0 ; j < 10 ; j ++ ) { a [ j ] = 0 ; } } } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( a [ i ] ) ; } } }
import java . util . Scanner ; public class test232 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; if ( x == a || y == b ) { if ( x == a || y == b ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { if ( x == a || y == b ) { if ( x == a || y == b ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { if ( x == a || y == b ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } in . close ( ) ; } }
import java . io . * ; public class GFG { static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { System . out . println ( " Infinite " ) ; return ; } if ( x == 0 ) { System . out . println ( 0 ) ; return ; } if ( n <= 0 ) { System . out . println ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { System . out . print ( " - " ) ; if ( x <= 0 ) x = - x ; if ( y <= 0 ) y = - y ; } int d = x / y ; for ( int i = 0 ; i <= n ; i ++ ) { System . out . print ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) System . out . print ( " . " ) ; } } public static void main ( String [ ] args ) { int x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ; System . out . println ( ) ; } }
import java . util . * ; public class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int lcmOfArray ( int [ ] arr , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } static int minPerfectCube ( int [ ] arr , int n ) { int lcm = lcmOfArray ( arr , n ) ; int minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; for ( int i = 3 ; lcm > 1 ; i = lcm ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; } return minPerfectCube ; } public static void main ( String [ ] args ) { int [ ] arr = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . length ; System . out . println ( minPerfectCube ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static class Node { int data ; Node left , right ; } ; static Node newNode ( int key ) { Node node = new Node ( ) ; node . data = key ; node . left = node . right = null ; } static void printSpecificLevelOrder ( Node root ) { Queue < Node > s = new LinkedList < > ( ) ; q . add ( root ) ; Node prnt = s . peek ( ) ; q . add ( prnt . data ) ; if ( prnt . right > 0 ) s . add ( root . right ) ; if ( prnt . left > 0 ) s . add ( root . left ) ; while ( ! s . isEmpty ( ) ) { Node first = s . peek ( ) ; q . add ( first . data ) ; Node second = s . peek ( ) ; q . add ( second . data ) ; if ( first . left && second . right && first . right && second . left > 0 ) { s . add ( first . left ) ; s . add ( second . right ) ; s . add ( first . right ) ; s . add ( second . left ) ; } } for ( int elements = q . size ( ) - 1 ; elements >= 0 ; -- elements ) System . out . print ( elements + " ▁ " ) ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; System . out . println ( " Specific ▁ Level ▁ Order ▁ Traversal ▁ of ▁ Binary ▁ Tree ▁ is " ) ; root . printSpecificLevelOrder ( root ) ; } }
import java . io . * ; public class GFG { static void hollowSquare ( int rows ) { for ( int i = 1 ; i <= rows ; i ++ ) { if ( i == 1 || i == rows ) { for ( int j = 1 ; j <= rows ; j ++ ) System . out . print ( " * " ) ; } else { for ( int j = 1 ; j <= rows ; j ++ ) { if ( j == 1 || j == rows ) System . out . print ( " * " ) ; else System . out . print ( " ▁ " ) ; } } System . out . println ( ) ; } } static void solidSquare ( int rows ) { for ( int i = 1 ; i <= rows ; i ++ ) { for ( int j = 1 ; j <= rows ; j ++ ) System . out . print ( " * " ) ; System . out . println ( ) ; } } static void printPattern ( int rows ) { System . out . println ( " Solid ▁ Square : " ) ; solidSquare ( rows ) ; System . out . println ( " \n Hollow ▁ Square : " ) ; hollowSquare ( rows ) ; } public static void main ( String [ ] args ) { int rows = 5 ; printPattern ( rows ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = " " ; for ( int i = 0 ; i < n / 4 ; i ++ ) { s += " abcd " ; } s += " c " ; for ( int i = 0 ; i < n / 4 ; i ++ ) { s += " c " ; } System . out . println ( s ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] t = new int [ n ] ; int [ ] w = new int [ n ] ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { t [ i ] = sc . nextInt ( ) ; w [ i ] = sc . nextInt ( ) ; } dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= t [ i ] ; j ++ ) { for ( int k = 0 ; k <= j ; k ++ ) { dp [ j + t [ i ] ] [ k + j ] = Math . max ( dp [ j + t [ i ] ] [ k + j ] , dp [ j ] [ k ] + w [ i ] ) ; } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] > 0 && dp [ i ] [ n ] - dp [ n ] [ i - 1 ] > 0 ) { ans = i ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; if ( a <= x && x <= b ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static int findLargest ( int arr [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 9 } ; int n = arr . length ; System . out . println ( findLargest ( arr , n ) ) ; } }
public class GFG { static void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; else System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } public static void main ( String [ ] args ) { int n = 7 ; findWinner ( n ) ; } }
import java . util . * ; public class GFG { static class Graph { ArrayList < Integer > [ ] graph ; public Graph ( ) { graph = new ArrayList [ graph . size ( ) ] ; } public void addEdge ( int u , int v ) { graph [ u ] . add ( v ) ; } public void BFS ( int s ) { boolean [ ] visited = new boolean [ graph . size ( ) ] ; Queue < Integer > queue = new LinkedList < > ( ) ; queue . add ( s ) ; visited [ s ] = true ; while ( queue . size ( ) > 0 ) { int s = queue . poll ( ) ; System . out . print ( s + " ▁ " ) ; for ( int i = 0 ; i < graph [ s ] . size ( ) ; i ++ ) { System . out . print ( graph [ s ] . get ( i ) + " ▁ " ) ; } } } public static void main ( String [ ] args ) { Graph g = new Graph ( ) ; g . addEdge ( 0 , 1 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 1 , 2 ) ; g . addEdge ( 2 , 0 ) ; g . addEdge ( 2 , 3 ) ; g . addEdge ( 3 , 3 ) ; System . out . println ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 " ) ; g . BFS ( 2 ) ; } }
import java . util . * ; public class GFG { static class Graph { ArrayList < Integer > [ ] graph ; public Graph ( ) { graph = new ArrayList [ graph . size ( ) ] ; } public void addEdge ( int u , int v ) { graph [ u ] . add ( v ) ; } public void BFS ( int s ) { boolean [ ] visited = new boolean [ graph . size ( ) ] ; Queue < Integer > queue = new LinkedList < > ( ) ; queue . add ( s ) ; visited [ s ] = true ; while ( queue . size ( ) > 0 ) { int s = queue . poll ( ) ; System . out . print ( s + " ▁ " ) ; for ( int i = 0 ; i < graph [ s ] . size ( ) ; i ++ ) { System . out . print ( graph [ s ] . get ( i ) + " ▁ " ) ; } } } public static void main ( String [ ] args ) { Graph g = new Graph ( ) ; g . addEdge ( 0 , 1 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 1 , 2 ) ; g . addEdge ( 2 , 0 ) ; g . addEdge ( 2 , 3 ) ; g . addEdge ( 3 , 3 ) ; System . out . println ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 " ) ; g . BFS ( 2 ) ; } }
import java . io . * ; public class GFG { static void getElements ( int a , int arr [ ] , int n ) { int elements [ ] = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; for ( int i = 0 ; i <= n ; i ++ ) System . out . print ( elements [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 2 , 6 , 1 } ; int n = arr . length ; int a = 5 ; getElements ( a , arr , n ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ; public class A { static BufferedReader br ; static PrintWriter out ; static StringTokenizer st ; static int T ; public static void main ( String [ ] args ) throws Exception { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; T = Integer . parseInt ( br . readLine ( ) ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { out . print ( " Case ▁ # " + cas + " : ▁ " ) ; solve ( ) ; } out . close ( ) ; } static void solve ( ) throws Exception { String [ ] temp = br . readLine ( ) . split ( " ▁ " ) ; int N = Integer . parseInt ( temp [ 0 ] ) ; int R = Integer . parseInt ( temp [ 1 ] ) ; int P = Integer . parseInt ( temp [ 2 ] ) ; int S = Integer . parseInt ( temp [ 3 ] ) ; if ( R < 0 ) { R = - R ; } else if ( S < 0 ) { S = - S ; } int min = Math . min ( P , S ) ; int max = Math . max ( R , P + S ) ; if ( max - min <= 1 ) { out . println ( " IMPOSSIBLE " ) ; } else { int add = max - min ; out . println ( add ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] r = new int [ m ] ; int [ ] c = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { r [ i ] = sc . nextInt ( ) ; c [ i ] = sc . nextInt ( ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( r [ i ] == n ) ans ++ ; } if ( n % 2 == 1 && c [ n / 2 ] == 1 ) ans ++ ; System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static void printRepeating ( int arr [ ] , int size ) { int S = 0 , P = 1 ; int n = size - 2 ; for ( int i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; int D = ( int ) Math . sqrt ( S * S - 4 * P ) ; int x = ( int ) ( D + S ) / 2 ; int y = ( int ) ( S - D ) / 2 ; System . out . println ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : ▁ " + ( ( D + S ) / 2 ) + " ▁ & ▁ " + ( ( S - D ) / 2 ) ) ; } static int fact ( int n ) { if ( n == 0 ) return 1 ; else return ( n * fact ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; printRepeating ( arr , arr_size ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { int n = in . nextInt ( ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! solve ( i ) ) cnt ++ ; } out . println ( cnt ) ; return true ; } static int solve ( int p ) { int q = 0 ; for ( int i = 2 ; i * i <= p ; i ++ ) { if ( p % i == 0 ) { q ++ ; } } return q ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] x = new int [ n ] ; int [ ] y = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = sc . nextInt ( ) ; y [ i ] = sc . nextInt ( ) ; } double ans = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { double theta = Math . atan2 ( x [ i ] - x [ i ] , y [ i ] - y [ i ] ) ; double ans = Math . PI * ( x [ i ] - x [ i ] ) + Math . PI * ( y [ i ] - y [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) { theta = Math . atan2 ( x [ j ] - x [ i ] , y [ j ] - y [ i ] ) ; ans = Math . min ( ans , theta ) ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { String s = sc . next ( ) ; if ( s . equals ( " # " ) ) { sc . close ( ) ; break ; } int n = s . length ( ) ; int [ ] a = { 0 , 5 , 6 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 , 512 , 512 , 512 , 512 , 8 , 16 , 64 , 512 , 512 , 512 } ; int x = 0 , y = 0 , z = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( a [ j ] == s . charAt ( j ) ) { while ( a [ j + 1 ] == s . charAt ( j ) ) { a [ j + 1 ] = a [ j ] + 1 ; a [ j ] = - 1 ; x ++ ; if ( a [ j + 1 ] == - 1 ) { a [ j ] = a [ j + 1 ] + 1 ; x ++ ; } cnt ++ ; } } } x = a [ 0 ] / 12 ; y = a [ 0 ] % 12 ; z = a [ 0 ] / 12 ; while ( x < n && y < n ) { while ( y < n && a [ y + 1 ] == a [ y + 1 ] ) { a [ y + 1 ] = a [ y ] + 1 ; y ++ ; } if ( a [ y + 1 ] == a [ y ] ) { a [ y + 1 ] = a [ y ] + 1 ; x ++ ; } if ( a [ y + 1 ] == a [ y ] ) { cnt ++ ; } } } System . out . println ( cnt ) ; } } }
import java . util . Scanner ; public class A_Letter { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; char [ ] arr = s . toCharArray ( ) ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == ' FS ' ) { x ++ ; } else { y ++ ; } } if ( x > y ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = sc . nextInt ( ) ; } int max = a [ 0 ] * a [ 1 ] ; for ( int j = 1 ; j < n ; j ++ ) { if ( a [ j ] * a [ j - 1 ] > max ) { max = a [ j ] * a [ j - 1 ] ; } } System . out . println ( max ) ; } } }
import java . io . * ; public class GFG { static int __gcd ( int x , int y ) { int small ; if ( x > y ) small = y ; else small = x ; for ( int i = 1 ; i <= small ; i ++ ) { if ( ( x % i == 0 ) && ( y % i == 0 ) ) gcd = i ; } return gcd ; } static int FindLCM ( int a , int b ) { return ( a * b ) / __gcd ( a , b ) ; } static int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ; int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; } public static void main ( String [ ] args ) { int m = 3 , n = 11 , a = 2 , b = 3 ; System . out . println ( rangeDivisor ( m , n , a , b ) ) ; m = 11 ; n = 1000000 ; a = 6 ; b = 35 ; System . out . println ( rangeDivisor ( m , n , a , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String str = sc . next ( ) ; String ans = " " ; int start = 0 , end = str . length ( ) - 1 ; while ( start <= end ) { for ( int i = start + 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' , ' || str . charAt ( i ) == ' ! ' ) continue ; if ( str . charAt ( i ) == ' , ' || str . charAt ( i ) == ' ? ' ) { start = i + 1 ; ans = str . substring ( start , i + 1 ) ; break ; } } } System . out . println ( ans ) ; } }
import java . util . HashMap ; import java . util . Map ; public class GFG { static int smallestKFreq ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int res = Integer . MAX_VALUE ; int res1 = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == k ) { res = Math . min ( res , entry . getKey ( ) ) ; } } return ( res != res1 ) ? res : - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . length ; System . out . print ( smallestKFreq ( arr , n , k ) ) ; } }
public class GFG { static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) ( ' a ' + ( s . charAt ( 0 ) - ' a ' ) * 2 ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) < c ) return false ; else c = s . charAt ( i ) ; } return true ; } public static void main ( String [ ] args ) { String s = " aabbbddeecc " ; if ( areVowelsInOrder ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; class Main { public static void main ( final String [ ] args ) { final Scanner stdin = new Scanner ( System . in ) ; while ( true ) { final int n = stdin . nextInt ( ) ; if ( n == 0 ) { break ; } final int [ ] sum = new int [ n + 1 ] ; final int [ ] sum2 = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { final int lim = i * ( i + 1 ) * ( i + 2 ) ; final int limk = lim / 6 ; sum [ i ] = sum [ limk ] + 1 ; } final int [ ] max = new int [ n + 1 ] ; max [ 1 ] = sum [ 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { final int limk = i * ( i + 1 ) * ( i + 2 ) / 6 ; final int sum1 = sum [ limk ] + 1 ; final int sum2 = sum [ limk ] + 1 ; if ( sum1 >= lim ) { continue ; } final int sum = sum1 + sum2 ; max [ sum ] = max [ sum ] ; sum1 = sum ; } final int [ ] min = new int [ n + 1 ] ; min [ 1 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { final int limk = i * ( i + 1 ) * ( i + 2 ) / 6 ; final int sum = sum [ limk ] + 1 ; if ( sum < min [ limk ] ) { min [ limk ] = sum ; } } final int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( max [ i ] < min [ count ] ) { max [ i ] = max [ count ] ; count ++ ; } } final int [ ] max = new int [ n + 1 ] ; max [ 1 ] = min [ count ] ; } for ( final int i = 1 ; i <= n ; i ++ ) { System . out . println ( max [ i ] + " ▁ " + min [ i ] ) ; } } } }
public class GFG { static int countOfLetters ( String str ) { int letter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) letter ++ ; } return letter ; } static int countOfNumbers ( String str ) { int number = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) number ++ ; } return number ; } static void check ( String str ) { if ( countOfLetters ( str ) == countOfNumbers ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { String str = " GeeKs01324" ; check ( str ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayDeque ; import java . util . Deque ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = " " ; Deque < Integer > stack = new ArrayDeque < Integer > ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { line = br . readLine ( ) ; if ( line . equals ( " end " ) ) { stack . push ( Integer . parseInt ( line ) ) ; } else if ( stack . size ( ) > 0 ) { System . out . println ( stack . pop ( ) ) ; } else { stack . pop ( ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; if ( x == 1 || x == n * 2 - 1 ) { System . out . println ( " No " ) ; return ; } System . out . println ( " Yes " ) ; for ( int i = 1 ; i < n ; i ++ ) { System . out . println ( i + " ▁ " + ( i + 1 ) ) ; } for ( int i = 1 ; i < n ; i ++ ) { System . out . println ( i + " ▁ " + ( i + 1 ) ) ; } for ( int i = n - 1 ; i > 0 ; i -- ) { System . out . println ( i + " ▁ " + ( i - 1 ) ) ; } System . out . println ( x - 1 ) ; System . out . println ( x ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { System . out . println ( i + " ▁ " + ( i + 1 ) ) ; } for ( int i = n - 1 ; i > 0 ; i -- ) { System . out . println ( i + " ▁ " + ( i - 1 ) ) ; } System . out . println ( x - 1 ) ; System . out . println ( x + 1 ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { System . out . println ( i + " ▁ " + ( i + 1 ) ) ; } for ( int i = n - 1 ; i > 0 ; i -- ) { System . out . println ( i + " ▁ " + ( i + 1 ) ) ; } } }
public class GFG { static final int MAX = 100001 ; static int perfectDiv [ ] = new int [ MAX ] ; static void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; i ++ ) { for ( int j = i * i ; j < MAX ; j += i * i ) perfectDiv [ j ] ++ ; } } static int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; } public static void main ( String [ ] args ) { precomputeCounts ( ) ; int n = 16 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; n = 12 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; int b [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } System . out . println ( a [ 0 ] * b [ 0 ] ) ; } }
import java . util . Scanner ; public class B_Planning_The_Expedition { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = sc . nextInt ( ) ; } int res = 0 , idx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int mid = ( t + e - 1 ) / x [ i ] ; int pos = i + 1 ; while ( pos < n && x [ pos ] <= mid ) { pos ++ ; } if ( pos == n ) { System . out . println ( " - 1" ) ; return ; } if ( pos == n ) { System . out . println ( idx ) ; return ; } } } }
import java . lang . Math ; class Main { public static void main ( String [ ] args ) { int h = 20 ; int r = 150 ; calIST ( h , r ) ; } public static void calIST ( int h , int r ) { double IST = Math . round ( ( h * r * 1.0 ) / 360 * 1000.0 ) / 1000.0 ; int intIST = ( int ) IST ; double floatIST = Math . ceil ( ( IST - intIST ) * 60 ) ; System . out . println ( intIST + " : " + floatIST ) ; } }
import java . io . * ; public class GFG { static void printRoots ( int n ) { double theta = Math . PI * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . print ( " " + Math . format ( real ) + " \n " ) ; if ( img >= 0 ) { System . out . print ( " ▁ + ▁ i ▁ " ) ; } else { System . out . print ( " ▁ - ▁ i ▁ " ) ; } System . out . print ( Math . format ( Math . abs ( img ) , 2 ) + " \n " ) ; } } public static void main ( String [ ] args ) { printRoots ( 1 ) ; printRoots ( 2 ) ; printRoots ( 3 ) ; } }
import java . io . * ; public class GFG { static void findCart ( int arr1 [ ] , int arr2 [ ] , int n , int n1 ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n1 ; j ++ ) { System . out . print ( " { " + arr1 [ i ] + " , ▁ " + arr2 [ j ] + " } , ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 4 , 5 , 6 } ; int n1 = arr1 . length ; int n2 = arr2 . length ; findCart ( arr1 , arr2 , n1 , n2 ) ; } }
public class GFG { static int no_of_ways ( String s ) { int n = s . length ( ) ; int count_left = 0 ; int count_right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( 0 ) ) count_left ++ ; else break ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == s . charAt ( n - 1 ) ) count_right ++ ; else break ; } if ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( no_of_ways ( s ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 100000 ; static boolean prime [ ] = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static void SumOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } System . out . print ( sum + " \n " ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; int n = arr . length ; int k = 2 ; SumOfKthPrimes ( arr , n , k ) ; } }
import java . util . * ; public class GFG { static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static void solve ( int arr [ ] , int n , int k ) { int c = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } System . out . print ( sum + " \n " ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 5 , k = 2 ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; solve ( arr , n , k ) ; } }
import java . util . * ; public class GFG { static int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static void productOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 , product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { product *= arr [ i ] ; c = 0 ; } } } System . out . print ( product + " \n " ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 5 , k = 2 ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; productOfKthPrimes ( arr , n , k ) ; } }
import java . io . * ; public class GFG { static void findAllSequences ( int diff , char out [ ] , int start , int end ) { if ( Math . abs ( diff ) > ( end - start + 1 ) / 2 ) return ; if ( start > end ) { if ( diff == 0 ) { System . out . print ( out ) ; return ; } return ; } out [ start ] = '0' ; out [ end ] = '1' ; findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '1' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; char [ ] out = new char [ 2 * n ] ; findAllSequences ( 0 , out , 0 , 2 * n - 1 ) ; System . out . print ( ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class B_Vanya_and_Food_Processor { static Scanner in = new Scanner ( System . in ) ; static int n ; static long h ; static long [ ] a ; static void solve ( ) { int high = 0 ; int low = 0 ; int mid = 0 ; int count = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) { low += a [ i ] ; if ( low > mid ) { high = mid - 1 ; } else { count ++ ; low = mid + 1 ; } } if ( high == n ) { System . out . println ( count ) ; return ; } int ans = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( high < a [ i ] ) { ans = i ; low = mid + 1 ; } else { high = mid - 1 ; } } System . out . println ( ans ) ; } public static void main ( String [ ] amit ) { n = in . nextInt ( ) ; h = in . nextLong ( ) ; a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextLong ( ) ; } solve ( ) ; } }
public class GFG { static class Node { int data ; Node next ; } ; static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " - > ▁ " ) ; node = node . next ; } System . out . println ( " NULL " ) ; } static int cntNodes ( Node node ) { if ( node == null ) return 0 ; return 1 + cntNodes ( node . next ) ; } static void updateList ( Node head , int m ) { int cnt = cntNodes ( head ) ; if ( cnt != m && m < cnt ) { int skip = cnt - m ; Node prev = null ; Node curr = head ; while ( skip > 0 ) { prev = curr ; curr = curr . next ; skip -- ; } prev . next = null ; Node tempHead = head ; head = curr ; while ( curr . next != null ) curr = curr . next ; curr . next = tempHead ; printList ( head ) ; } } public static void main ( String [ ] args ) { Node head = new Node ( 4 ) ; head . next = new Node ( 5 ) ; head . next . next = new Node ( 6 ) ; head . next . next . next = new Node ( 1 ) ; head . next . next . next . next = new Node ( 2 ) ; head . next . next . next . next . next = new Node ( 3 ) ; int m = 3 ; updateList ( head , m ) ; } }
public class GFG { static int maxSubStrings ( String s , int k ) { int maxSubStr = 0 ; int n = s . length ( ) ; for ( int c = 0 ; c < 27 ; c ++ ) { char ch = ( char ) ( ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; } public static void main ( String [ ] args ) { String s = " aaacaabbaa " ; int k = 2 ; System . out . println ( maxSubStrings ( s , k ) ) ; } }
public class GFG { static final int N = 100 ; static void ansQueries ( int prefeven [ ] , int prefodd [ ] , int l , int r ) { if ( ( r - l + 1 ) % 2 == 0 ) { System . out . println ( "0" ) ; } else { if ( ( r - l + 1 ) % 2 == 0 ) { System . out . println ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; } else { System . out . println ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } } } static void wrapper ( int arr [ ] , int n , int l , int r , int q ) { int [ ] prefodd = new int [ N ] ; int [ ] prefeven = new int [ N ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } for ( int i = 0 ; i != q ; i ++ ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int l [ ] = { 1 , 1 , 2 } ; int r [ ] = { 2 , 3 , 4 } ; int q = l . length ; wrapper ( arr , n , l , r , q ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int sum = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; sum += temp ; } else { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; sum -= temp ; } } System . out . println ( sum ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } long sum = 0 ; int mid = ( n / 2 ) * k ; if ( n % 2 == 0 ) { mid = ( n / 2 ) * 2 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } System . out . println ( sum ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; ArrayList < ArrayDeque < Integer > > ar = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ar . add ( new ArrayDeque < > ( ) ) ; } for ( int i = 0 ; i < r ; i ++ ) { int odr = sc . nextInt ( ) ; int xdr = sc . nextInt ( ) ; if ( odr == 0 ) { ar . get ( xdr ) . addLast ( sc . nextInt ( ) ) ; } else if ( odr == 1 ) { System . out . println ( ar . get ( ar . size ( ) - 1 ) . getFirst ( ) ) ; } else { System . out . println ( ar . get ( ar . size ( ) - 1 ) . removeFirst ( ) ) ; } } } }
public class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void removeMin ( int arr [ ] , int n ) { int minVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minVal = Math . min ( minVal , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; } static void removeFromMax ( int arr [ ] , int n ) { int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } static void modifyArray ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; int k = 2 ; modifyArray ( arr , n , k ) ; } }
import java . io . * ; public class GFG { static float find_Centroid ( float [ ] [ ] v ) { float ans [ ] = new float [ 2 ] ; int n = v . length ; float signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float x0 = v [ i ] [ 0 ] ; float y0 = v [ i ] [ 1 ] ; float x1 = v [ ( i + 1 ) % n ] [ 0 ] ; float y1 = v [ ( i + 1 ) % n ] [ 1 ] ; float A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( float ) ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( float ) ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; } public static void main ( String [ ] args ) { float [ ] [ ] vp = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; float ans [ ] [ ] = find_Centroid ( vp ) ; System . out . printf ( " % . 3 f ▁ % . 3 f \n " , ans [ 0 ] [ 0 ] , ans [ 1 ] [ 1 ] ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; String [ ] s = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = in . next ( ) ; } int x = 0 ; int y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] . equals ( " lock " ) ) { x ++ ; } else if ( s [ i ] . equals ( " unlock " ) ) { y ++ ; } else if ( s [ i ] . equals ( " blue " ) ) { x = 1 ; } } System . out . println ( x ) ; } }
import java . util . * ; public class GFG { static int minOperations ( int ar [ ] , int k ) { Arrays . sort ( ar ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) ans += ar [ k - 1 ] - ar [ i ] ; ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 9 , 100 } ; int n = arr . length ; int k = 3 ; System . out . println ( minOperations ( arr , k ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char [ ] input = sc . nextLine ( ) . toCharArray ( ) ; if ( input [ 0 ] >= ' A ' && input [ 0 ] <= ' Z ' ) { System . out . println ( " ▁ Alphabet ▁ " ) ; } else if ( input [ 0 ] >= 65 && input [ 0 ] <= 90 ) { System . out . println ( " ▁ Alphabet ▁ " ) ; } else if ( input [ 0 ] >= 97 && input [ 0 ] <= 122 ) { System . out . println ( " ▁ A Character ▁ " ) ; } else if ( input [ 0 ] >= 48 && input [ 0 ] <= 57 ) { System . out . println ( " ▁ Digit ▁ " ) ; } else { System . out . println ( " Special ▁ Character ▁ " ) ; } } }
import java . util . * ; public class BmailComputerNetwork { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; ArrayList < ArrayList < Integer > > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; list . get ( a ) . add ( a ) ; } int max = Integer . MIN_VALUE ; int index = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int count = list . get ( i ) . size ( ) ; int c = 0 ; int maxIdx = - 1 ; for ( int j = 0 ; j < list . get ( i ) . size ( ) ; j ++ ) { if ( list . get ( i ) . get ( j ) == max ) { c = j ; maxIdx = i ; } } if ( c > 0 ) { index = i ; } } System . out . print ( maxIdx + " ▁ " ) ; for ( int i = 0 ; i < index ; i ++ ) { System . out . print ( list . get ( i ) . get ( i ) + " ▁ " ) ; } } }
import java . util . * ; public class BallsOfSteals { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] w = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { w [ i ] = sc . nextInt ( ) ; } int [ ] [ ] graph = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; graph [ a ] [ b ] = graph [ b ] [ a ] = 1 ; graph [ b ] [ a ] = 1 ; } int cost = Integer . MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( graph [ i ] [ j ] == 1 && graph [ i ] [ j ] == 1 ) { cost = Math . min ( cost , w [ j ] + w [ i ] ) ; } } } System . out . println ( cost == Integer . MAX_VALUE ? - 1 : cost ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < k ; k ++ ) { if ( arr [ i ] == 0 ) { j = i + 1 ; break ; } } for ( int l = 0 ; l < n ; l ++ ) { if ( arr [ l ] == 0 ) { System . out . print ( j + " ▁ " ) ; break ; } } for ( int k = 0 ; k < n - k + 1 ; k ++ ) { arr [ l ] -- ; arr [ k ] -- ; } for ( int l = 0 ; l < n ; l ++ ) { System . out . print ( arr [ l ] + " ▁ " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ n ] ; int [ ] [ ] map = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = sc . nextInt ( ) ; map [ arr [ i ] [ j ] - 1 ] = i ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( map [ arr [ i ] [ j ] - 1 ] == i ) { int temp = map [ arr [ i ] [ j ] ] ; map [ arr [ i ] [ j ] ] = arr [ i ] [ j ] ; arr [ i ] [ j ] = temp ; count ++ ; } } } System . out . println ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { System . out . print ( map [ i ] [ i ] + " ▁ " ) ; } } }
import java . io . * ; public class GFG { static int sameOccurrence ( int arr [ ] , int n , int x , int y ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ctX = 0 , ctY = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] == x ) ctX ++ ; else if ( arr [ j ] == y ) ctY ++ ; if ( ctX == ctY ) result ++ ; } } return ( result ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = arr . length ; int x = 2 , y = 3 ; System . out . println ( sameOccurrence ( arr , n , x , y ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { String s = sc . next ( ) ; int count = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '1' ) count ++ ; } if ( count > 2 ) System . out . println ( count - 2 ) ; else System . out . println ( count ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int a = 0 ; int con = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { a ++ ; } else { con ++ ; } } if ( a % 2 == 0 ) { System . out . println ( " Agasa " ) ; } else { System . out . println ( " Conan " ) ; } } }
import java . util . * ; public class GFG { public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; for ( int i = 0 ; i < 5 ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
import java . io . * ; public class GFG { public static void main ( String [ ] args ) { int target = 93 ; int arr [ ] = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int len = arr . length ; int count = 0 ; for ( int i = 0 ; i < len - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < len - 1 ; j ++ ) { if ( target % arr [ i ] * arr [ j ] == 0 ) { int toFind = target / arr [ i ] * arr [ j ] ; for ( int k = j + 1 ; k < len ; k ++ ) if ( arr [ k ] == toFind ) count ++ ; } } } } System . out . println ( " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " + count ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] [ ] solution = new int [ n ] [ 2 ] ; solution [ 0 ] [ 0 ] = a [ 0 ] ; solution [ 0 ] [ 1 ] = - a [ 0 ] ; solution [ 0 ] [ 2 ] = a [ n - 1 ] * a [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { solution [ i ] [ 0 ] = - a [ i ] * ( n - 1 ) ; solution [ i ] [ 1 ] = ( n - 1 ) * a [ i ] ; } solution [ n - 1 ] [ 1 ] = a [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( solution [ i ] [ 0 ] + " ▁ " ) ; } for ( int i = 1 ; i < n ; i ++ ) { System . out . print ( solution [ i ] [ 1 ] + " ▁ " ) ; } System . out . println ( ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int finalNum ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = __gcd ( result , arr [ i ] ) ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 9 , 6 , 36 } ; int n = arr . length ; System . out . println ( finalNum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int N = 1000 ; static int lastElement ( int a [ ] , int n ) { int steps = 1 ; Vector < Integer > [ ] v = new Vector [ n ] ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . add ( a [ i ] | a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps ++ ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . add ( v [ steps - 1 ] . get ( i ) | v [ steps - 1 ] . get ( i + 1 ) ) ; else v [ steps ] . add ( v [ steps - 1 ] . get ( i ) ^ v [ steps - 1 ] . get ( i + 1 ) ) ; } } return v [ steps ] . get ( 0 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 5 , 6 } ; int n = a . length ; int index = 0 , value = 2 , a [ 0 ] = 2 ; System . out . println ( lastElement ( a , n ) ) ; index = 3 ; value = 5 ; a [ index ] = value ; System . out . println ( lastElement ( a , n ) ) ; } }
import java . io . * ; public class GFG { static int number_cake ( int n ) { return ( n * n * n + 5 * n + 6 ) / 6 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( number_cake ( n ) ) ; n = 8 ; System . out . println ( number_cake ( n ) ) ; n = 25 ; System . out . println ( number_cake ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int g = 0 , p = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' g ' ) g ++ ; else p ++ ; } System . out . println ( ( g - p ) / 2 ) ; } }
import java . io . * ; public class GFG { static void pattern ( int N ) { int k = 0 , space = 1 , rows = N ; for ( int i = rows ; i >= 1 ; i -- ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( " * " ) ; if ( i != rows ) { for ( k = 1 ; k <= space ; k ++ ) System . out . print ( " ▁ " ) ; space += 2 ; } for ( int j = i ; j >= 1 ; j -- ) System . out . print ( " * " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int N = 6 ; pattern ( N ) ; } }
import java . io . * ; public class GFG { static int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) ans = Math . max ( ans , arr [ i - 1 ] ) ; return ans ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr ) ) ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr1 ) ) ; } }
import java . util . * ; public class Solution { public int pathSum ( TreeNode root , int sum ) { int result = 0 ; return result + pathSumHelper ( root . left , sum , 0 , ( so_far + root . val ) ) ; } public int pathSum ( TreeNode root , int sum ) { return pathSumHelper ( root , sum , 0 , ( so_far + root . val ) ) ; } public int pathSum ( TreeNode root , int target , int so_far , int [ ] cache ) { if ( root != null ) { int complement = so_far + root . val - target ; if ( cache . containsKey ( complement ) ) result += cache . get ( complement ) ; cache . put ( complement , cache . get ( so_far + root . val ) + 1 ) ; pathSumHelper ( root . left , target , so_far + root . val , cache ) ; pathSumHelper ( root . right , target , so_far + root . val , cache ) ; cache . put ( so_far + root . val , cache . get ( so_far + root . val ) - 1 ) ; } return result ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; TreeNode tree = new TreeNode ( 10 ) ; tree . left = new TreeNode ( 5 ) ; tree . right = new TreeNode ( - 3 ) ; tree . left . left = new TreeNode ( 3 ) ; tree . left . right = new TreeNode ( 2 ) ; tree . right . right = new TreeNode ( 11 ) ; tree . left . left . left = new TreeNode ( 3 ) ; tree . left . left . right = new TreeNode ( - 2 ) ; tree . left . right . right = new TreeNode ( 1 ) ; int s = 8 ; int out = sObj . pathSum ( tree , s ) ; System . out . println ( out ) ; } }
public class GFG { static void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s = s + arr [ i ] ; System . out . println ( Math . min ( s , x ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = arr . length ; getmax ( arr , arr_size , x ) ; } }
import java . io . * ; import java . util . * ; public class Solution { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { String s = br . readLine ( ) ; int num = Integer . parseInt ( s ) ; for ( int i = 0 ; i < 9 ; i ++ ) { String s1 = String . valueOf ( num ) ; String s2 = String . valueOf ( num ) ; String s3 = String . valueOf ( s2 ) ; int len = s1 . length ( ) ; long num = 0 ; for ( int j = 0 ; j < len ; j ++ ) { num = num + s3 . substring ( 0 , j ) ; } num = num * num ; pw . print ( " Case ▁ " + ( tt + 1 ) + " : " ) ; for ( int j = 0 ; j < len - 8 ; j ++ ) { num = num + s3 . substring ( 0 , j ) ; } pw . print ( num ) ; } pw . println ( ) ; } pw . close ( ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean [ ] isPrime = new boolean [ 500 ] ; static void solve ( ) { Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= 500 ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * 2 ; j <= 5000 ; j += i ) { isPrime [ j ] = false ; } } } int [ ] prime = new int [ 500 ] ; for ( int i = 0 ; i <= 5000 ; i ++ ) { if ( isPrime [ i ] ) { prime [ i ] = i ; for ( int j = 2 * i ; j <= 5000 ; j += i ) { isPrime [ j ] = false ; } } } int [ ] ans = new int [ 500 ] ; for ( int i = 0 ; i <= 5000 ; i ++ ) { if ( isPrime [ i ] ) { ans [ i ] = 0 ; } } for ( int i = 0 ; i < 500 ; i ++ ) { if ( prime [ i ] ) { ans [ i ] ++ ; for ( int j = i + 1 ; j <= 5000 ; j += i ) { prime [ j ] = false ; } } } while ( in . hasNext ( ) ) { int n = in . nextInt ( ) ; out . println ( ans [ n ] ) ; } out . flush ( ) ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; solve ( ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
public class GFG { static int maxOR ( int arr [ ] , int n ) { int maxVal = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxVal = Math . max ( maxVal , arr [ i ] | arr [ j ] ) ; } } return maxVal ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; System . out . println ( maxOR ( arr , n ) ) ; } }
import java . util . * ; public class Solution { public int numJewelsInStones ( String J , String S ) { if ( J . length ( ) == 0 || S . length ( ) == 0 ) return 0 ; Set < Character > jSet = new HashSet < Character > ( ) ; int ans = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( jSet . contains ( S . charAt ( i ) ) ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String J = " aA " ; String S = " aAAbbbb " ; int out = sObj . numJewelsInStones ( J , S ) ; System . out . println ( out ) ; } }
public class GFG { static int MAX = 100 ; static int n = 0 ; static int [ ] store = new int [ MAX ] ; static int [ ] [ ] graph = new int [ MAX ] [ MAX ] ; static int [ ] d = new int [ MAX ] ; static boolean is_clique ( int b ) { for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) { if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) return false ; } } return true ; } static int maxCliques ( int i , int l ) { int max_ = 0 ; for ( int j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { max_ = Math . max ( max_ , l ) ; max_ = Math . max ( max_ , maxCliques ( j , l + 1 ) ) ; } } return max_ ; } public static void main ( String [ ] args ) { int edges [ ] [ ] = { { 1 , 2 } , { 2 , 3 } , { 3 , 1 } , { 4 , 3 } , { 4 , 1 } , { 4 , 2 } } ; int size = edges . length ; n = 4 ; for ( int i = 0 ; i < size ; i ++ ) { graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; d [ edges [ i ] [ 0 ] ] ++ ; d [ edges [ i ] [ 1 ] ] ++ ; } System . out . println ( maxCliques ( 0 , 1 ) ) ; } }
import java . io . * ; public class GFG { static int setBitNumber ( int n ) { int k = ( int ) Math . log ( n ) ; return ( int ) Math . pow ( 2 , k ) ; } public static void main ( String [ ] args ) { int n = 273 ; System . out . println ( setBitNumber ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int f = sc . nextInt ( ) ; int x = s ; int l = s ; int r = f ; while ( x > 0 ) { int t = x - 1 ; int l = s ; int r = f - 1 ; while ( t > 0 ) { int t1 = t % 2 ; if ( r < t1 ) { l = t1 - l ; r = t1 - l ; t = t1 - l ; } else { l = t1 + l ; r = t1 - r ; t = t1 - l ; } x -- ; } if ( x == 0 ) System . out . println ( " X " ) ; else if ( l == r ) System . out . println ( " R " ) ; else if ( - l < r ) System . out . println ( " L " ) ; else System . out . println ( " R " ) ; } } }
import java . io . * ; public class GFG { static int subsetPairNotDivisibleByK ( int arr [ ] , int N , int K ) { int f [ ] = new int [ K ] ; for ( int i = 0 ; i < N ; i ++ ) f [ arr [ i ] % K ] ++ ; if ( K % 2 == 0 ) f [ K / 2 ] = Math . min ( f [ K / 2 ] , 1 ) ; int res = Math . min ( f [ 0 ] , 1 ) ; for ( int i = 1 ; i <= K / 2 ; i ++ ) res += Math . max ( f [ i ] , f [ K - i ] ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 7 , 2 , 9 , 1 } ; int N = arr . length ; int K = 3 ; System . out . println ( subsetPairNotDivisibleByK ( arr , N , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String [ ] lines = scanner . nextLine ( ) . split ( " ▁ " ) ; int w = Integer . parseInt ( lines [ 0 ] ) ; int m = Integer . parseInt ( lines [ 1 ] ) ; int k = Integer . parseInt ( lines [ 2 ] ) ; int max_length = 0 ; int available_digits = w / k ; while ( available_digits > 0 ) { int current_cost_per_n = Integer . toString ( m ) . length ( ) ; int same_cost_until = ( int ) Math . pow ( 10 , current_cost_per_n ) ; int usable_numbers = same_cost_until - m ; int use_digits = usable_numbers * current_cost_per_n ; m = same_cost_until ; if ( available_digits >= use_digits ) { max_length += usable_numbers ; available_digits -= use_digits ; } else { max_length += available_digits / current_cost_per_n ; available_digits = 0 ; } } System . out . println ( max_length ) ; } }
import java . io . * ; public class GFG { static void printRoots ( int a , int b , int c ) { System . out . print ( 1 + " , ▁ " + c / ( a * 1.0 ) ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = - 5 ; printRoots ( a , b , c ) ; } }
import java . util . * ; public class GFG { static int [ ] [ ] [ ] memo = new int [ 32 ] [ 2 ] [ 2 ] ; static int dp ( int pos , int fl , int pr , String bin ) { if ( pos == bin . length ( ) ) return 1 ; if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) return memo [ pos ] [ fl ] [ pr ] ; int val = 0 ; if ( bin . charAt ( pos ) == '0' ) val = val + dp ( pos + 1 , fl , 0 , bin ) ; else if ( bin . charAt ( pos ) == '1' ) val = val + dp ( pos + 1 , 1 , 0 , bin ) ; if ( pr == 0 ) { if ( fl == 1 ) val += dp ( pos + 1 , 1 , 0 , bin ) ; else if ( bin . charAt ( pos ) == '1' ) val += dp ( pos + 1 , 1 , 0 , bin ) ; } if ( memo [ pos ] [ fl ] [ pr ] = val ; return val ; } static int findIntegers ( int num ) { String bin = " " ; while ( num > 0 ) { if ( num % 2 == 0 ) bin += "1" ; else bin += "0" ; num /= 2 ; } bin = reverse ( bin ) ; return dp ( 0 , 0 , 0 , bin ) ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( findIntegers ( N ) ) ; } }
public class GFG { static int N = 4 ; static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + ( int ) Math . pow ( 2 , i ) ; else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + ( int ) Math . pow ( 2 , i ) ; else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( int ) Math . pow ( 2 , i + j ) ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n - 1 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } } ; System . out . println ( MaximumDecimalValue ( mat , 4 ) ) ; } }
import java . util . * ; public class GFG { static void createHash ( HashSet < Integer > hash1 , int maxElement ) { int prev = 0 , curr = 1 ; hash1 . add ( prev ) ; hash1 . add ( curr ) ; while ( curr < maxElement ) { int temp = curr + prev ; hash1 . add ( temp ) ; prev = curr ; curr = temp ; } } static void findFibonacciPair ( int n ) { HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . contains ( i ) && hash . contains ( ( n - i ) ) ) { System . out . println ( i + " , ▁ " + ( n - i ) ) ; return ; } } System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int N = 90 ; findFibonacciPair ( N ) ; } }
import java . io . * ; public class GFG { static int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; System . out . println ( countgroup ( a , n ) ) ; } }
import java . util . * ; public class GFG { static int maxLength ( String s , int n ) { int ans = - ( Integer . MIN_VALUE + 1 ) ; Vector < Integer > A = new Vector < Integer > ( ) ; Vector < Integer > L = new Vector < Integer > ( ) ; Vector < Integer > R = new Vector < Integer > ( ) ; int [ ] freq = new int [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) - ' a ' == i ) count ++ ; freq [ j ] = count ; } } for ( int j = 0 ; j < n ; j ++ ) { L . add ( ( 2 * freq [ j - 1 ] ) - j ) ; R . add ( ( 2 * freq [ j ] ) - j ) ; } int max_len = - ( Integer . MIN_VALUE + 1 ) ; int min_val = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { min_val = Math . min ( min_val , L . get ( j ) ) ; A . add ( min_val ) ; int l = 0 , r = j ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( A . get ( mid ) <= R . get ( j ) ) { max_len = Math . max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . max ( ans , max_len ) ; A . clear ( ) ; R . clear ( ) ; L . clear ( ) ; } return ans ; } public static void main ( String [ ] args ) { String s = " ababbbacbcbcca " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
import java . util . * ; public class GFG { static int N = 100005 ; static Vector < Vector < Integer > > gr = new Vector < Vector < Integer > > ( ) ; static int [ ] colour = new int [ N ] ; static Vector < Vector < Integer > > edges = new Vector < Vector < Integer > > ( ) ; static boolean bip = true ; static void add_edge ( int x , int y ) { gr . get ( x ) . add ( y ) ; gr . get ( y ) . add ( x ) ; edges . add ( new Vector < Integer > ( x , y ) ) ; } static void dfs ( int x , int col ) { colour [ x ] = col ; for ( int i = 0 ; i < gr . get ( x ) . size ( ) ; i ++ ) { if ( colour [ i ] == - 1 ) dfs ( i , col ^ 1 ) ; else colour [ i ] = col ; } } static void Directed_Graph ( int n , int m ) { dfs ( 1 , 1 ) ; if ( ! bip ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < m ; i ++ ) { if ( colour [ edges . get ( i ) . get ( 0 ) ] == 0 ) { edges . set ( i , edges . get ( i ) . get ( 1 ) ) ; edges . set ( i , edges . get ( i ) . get ( 0 ) ) ; } System . out . println ( edges . get ( i ) . get ( 0 ) + " ▁ " + edges . get ( i ) . get ( 1 ) ) ; } } public static void main ( String [ ] args ) { int n = 4 , m = 3 ; add_edge ( 1 , 2 ) ; add_edge ( 1 , 3 ) ; add_edge ( 1 , 4 ) ; Directed_Graph ( n , m ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } else { System . out . print ( arr [ i ] + " ▁ " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int total = 0 ; for ( int i = 1 ; i <= w ; i ++ ) { total += k * i ; } if ( total <= n ) { System . out . println ( 0 ) ; } else { System . out . println ( total - n ) ; } } }
public class GFG { static boolean isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; } static int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) if ( num % i == 0 ) flag = 0 ; if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; } static int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { for ( int i = a ; i <= b ; i ++ ) { int ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; } public static void main ( String [ ] args ) { int a = 2020 , b = 6300 , k = 29 ; System . out . println ( findCount ( a , b , k ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; String s = " " ; if ( k > n || k == 1 && n != 1 ) System . out . println ( - 1 ) ; else { for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 || i == n - 1 || k > n - 1 ) { s = s . substring ( 0 , i ) + ( char ) ( ' a ' + ( i % 2 == 0 ? ' z ' : ' a ' ) ) ; } else s = s . substring ( i + 1 , n ) + ( char ) ( ' z ' + ( i % 2 == 1 ? ' a ' : ' z ' ) ) ; } } System . out . println ( s ) ; } } }
import java . util . Arrays ; public class GFG { static int maxn = 16 ; static int precompute ( int dp [ ] ) { Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; int v [ ] = { 4 , 6 , 9 } ; for ( int i = 1 ; i < maxn ; i ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { int j = v [ k ] ; if ( i >= j && dp [ i - j ] != - 1 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } return dp ; } static int Maximum_Summands ( int dp [ ] , int n ) { if ( n < maxn ) return dp [ n ] ; else { int t = ( n - maxn ) / 4 + 1 ; return t + dp [ n - 4 * t ] ; } } public static void main ( String [ ] args ) { int n = 12 ; int dp [ ] = precompute ( ) ; System . out . println ( Maximum_Summands ( dp , n ) ) ; } }
import java . io . * ; public class GFG { static int countSquares ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( " Count ▁ of ▁ squares ▁ is ▁ " + countSquares ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; sum += arr [ i ] ; } Arrays . sort ( arr ) ; int [ ] count = new int [ 100000 + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } long ans = 0 ; for ( int i = 0 ; i < 100000 + 1 ; i ++ ) { ans += count [ i ] * ( count [ i ] - 1 ) / 2 ; } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int FindSubarray ( int arr [ ] , int n , int k ) { int count_one [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) count_one [ i ] = Integer . bitCount ( arr [ i ] ) ; int sum = count_one [ 0 ] ; if ( n == 1 ) { if ( count_one [ 0 ] >= k ) return 1 ; else return - 1 ; } int ans = Integer . MAX_VALUE ; int i = 1 , j = 0 ; while ( i < n ) { if ( k == count_one [ j ] ) { ans = 1 ; break ; } else if ( k == count_one [ i ] ) { ans = 1 ; break ; } else if ( sum + count_one [ i ] < k ) { sum += count_one [ i ] ; i ++ ; } else if ( sum + count_one [ i ] > k ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum -= count_one [ j ] ; j ++ ; } else if ( sum + count_one [ i ] == k ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum += count_one [ i ] ; i ++ ; } } if ( ans != Integer . MAX_VALUE ) return ans ; else return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int n = arr . length ; int k = 2 ; System . out . println ( FindSubarray ( arr , n , k ) ) ; } }
import java . io . * ; public class GFG { static void Loss ( double SP , double P ) { double loss = 0 ; loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( " Loss ▁ = ▁ " + loss ) ; } public static void main ( String [ ] args ) { double SP = 2400.0 ; double P = 30.0 ; Loss ( SP , P ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int left = 0 ; int right = m ; int count = 0 ; while ( left < right ) { while ( left < n && arr [ left ] <= x ) { left ++ ; } while ( right >= 0 && arr [ right ] <= x ) { right -- ; } count ++ ; } System . out . println ( Math . min ( count , right - left ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int max = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count ++ ; } else { if ( count > max ) { max = count ; } count = 0 ; } } if ( count > max ) { max = count ; } System . out . println ( 2 * max ) ; } }
public final class p021 { public static void main ( String [ ] args ) { System . out . println ( new p021 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { if ( get ( i ) == 89 ) sum += 1 ; } return Integer . toString ( sum ) ; } private static int [ ] squareDigitSum ( int n ) { int result = 0 ; while ( n > 0 ) { result += squareDigitSum ( n % 1000 ) ; n /= 1000 ; } return result ; } }
import java . util . * ; public class GFG { static int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; } static int countStrings ( String str , int n ) { HashSet < Character > distinct_char = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) distinct_char . add ( str . charAt ( i ) ) ; return fact ( distinct_char . size ( ) ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; System . out . println ( countStrings ( str , n ) ) ; } }
import java . util . * ; public class GFG { static int M = 4 ; static int N = 5 ; static void printCommonElements ( int mat [ ] [ ] ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp . containsKey ( mat [ i ] [ j ] ) && mp . get ( mat [ i ] [ j ] ) == i ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } } } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 1 , 4 , 8 } , { 3 , 7 , 8 , 5 , 1 } , { 8 , 7 , 7 , 3 , 1 } , { 8 , 1 , 2 , 7 , 9 } } ; printCommonElements ( mat ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long x = sc . nextLong ( ) ; long y = sc . nextLong ( ) ; long max = 0 ; long min = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long k = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; max = Math . max ( max , k * x + b ) ; min = Math . min ( min , k * x + b ) ; } System . out . println ( ( max - min == 0 ) ? " Yes " : " No " ) ; } }
import java . util . * ; import java . io . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) , t = in . nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int a = in . nextInt ( ) , b = in . nextInt ( ) ; int pos = a - ( t - pos ) * b ; if ( pos < 0 ) { ans = pos + 1 ; } else { pos = a + b ; if ( pos >= t ) { ans = pos ; } } pw . println ( ans ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . io . * ; public class GFG { static double sumOfAP ( double a , double d , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a ; a = a + d ; } return sum ; } public static void main ( String [ ] args ) { int n = 20 ; double a = 2.5 ; double d = 1.5 ; System . out . println ( sumOfAP ( a , d , n ) ) ; } }
import java . io . * ; public class GFG { static void find3Numbers ( int arr [ ] , int n ) { int small = Integer . MAX_VALUE ; int large = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= small ) small = arr [ i ] ; else if ( arr [ i ] <= large ) large = arr [ i ] ; else break ; } if ( i == n ) { System . out . println ( " No ▁ such ▁ triplet ▁ found " ) ; return ; } for ( int j = 0 ; j <= i ; j ++ ) { if ( arr [ j ] < large ) { small = arr [ j ] ; break ; } } System . out . println ( small + " ▁ " + large + " ▁ " + arr [ i ] ) ; return ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 7 , 4 , 8 } ; int n = arr . length ; find3Numbers ( arr , n ) ; } }
import java . util . * ; public class GFG { static void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } System . out . print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) System . out . print ( i * i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 96 ; numbersWith3Divisors ( n ) ; } }
import java . util . * ; public class GFG { static int findPairCount ( int N , int K ) { int count = 0 ; int [ ] rem = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += ( rem [ i ] * ( rem [ K - i ] - 1 ) ) / 2 ; } return count ; } public static void main ( String [ ] args ) { int N = 10 , K = 4 ; System . out . println ( findPairCount ( N , K ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; if ( ( n | m ) == 0 ) break ; int [ ] a = new int [ n ] , b = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) b [ i ] = sc . nextInt ( ) ; int max = 0 , min = INF ; for ( int i = 0 ; i < n || i < m ; i ++ ) { int s = a [ i ] , t = b [ i ] ; max = min ( max , s - s ) ; min = ( min < t ) ? t : min ; } for ( int j = 0 ; j < m ; j ++ ) { int s = b [ j ] , t = a [ j ] ; a [ j ] = s ; if ( min < s ) max = s ; } System . out . println ( max ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; sum += arr [ i ] ; } Arrays . sort ( arr ) ; if ( arr [ n - 1 ] % 2 == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static float PHI = 1.6180339 ; static float f [ ] = { 0 , 1 , 1 , 2 , 3 , 5 } ; static float fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; float fn = 5 ; while ( t < n ) { fn = fn * PHI ; t ++ ; } return fn ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . print ( n + " th ▁ Fibonacci ▁ Number ▁ = ▁ " + fib ( n ) ) ; } }
import java . io . * ; public class GFG { static int kthSmallest ( int n , int k ) { return 2 * k ; } public static void main ( String [ ] args ) { int n = 8 , k = 4 ; System . out . println ( kthSmallest ( n , k ) ) ; } }
import java . util . * ; public class GFG { static void printSumTricky ( int n , int mat [ ] [ ] , int k ) { if ( k > n ) return ; int [ ] [ ] stripSum = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i <= n - k ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + " ▁ " ) ; for ( int j = 1 ; j <= n - k ; j ++ ) sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 5 ; int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 } } ; int k = 3 ; printSumTricky ( mat , k ) ; } }
import java . util . Scanner ; public class B374 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int A = in . nextInt ( ) ; int B = in . nextInt ( ) ; int N = in . nextInt ( ) ; int solution = 0 ; if ( A == 0 && B == 0 && N == 1 ) { solution = 0 ; } else if ( A % A == 0 && B == 0 ) { solution = 1 ; } else if ( A % A == 0 && B % A == 0 ) { solution = 2 ; } else { solution = 3 ; } if ( solution < 2 ) { System . out . println ( " No ▁ solution " ) ; } else { int solutionNo = ( int ) Math . ceil ( ( double ) B / A ) ; int possible = solution % N == 0 ? solutionNo : solution ; System . out . println ( possible ? solutionNo : solution ) ; } } }
import java . io . * ; public class GFG { static int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } static int totalWays ( int X , int Y , int M , int W ) { return ( ncr ( M , X ) * ncr ( W , Y ) ) ; } public static void main ( String [ ] args ) { int X = 4 , Y = 3 , M = 6 , W = 5 ; System . out . println ( totalWays ( X , Y , M , W ) ) ; } }
import java . util . BitSet ; public class Main { public static int nextPowerOf2 ( int n ) { int count = 0 ; if ( ( n & ( n - 1 ) ) == 0 ) { return n ; } while ( n != 0 ) { n >>= 1 ; count ++ ; } return 1 << count ; } public static int removeElement ( int n ) { if ( n == 1 || n == 2 ) { return 0 ; } int a = nextPowerOf2 ( n ) ; if ( n == a || n == a - 1 ) { return 1 ; } else if ( n == a - 2 ) { return 0 ; } else if ( n % 2 == 0 ) { return 1 ; } else { return 2 ; } } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( removeElement ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int p = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } long ans = 0 ; for ( int i = 0 ; i < p ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { ans += ( ( long ) Math . pow ( n , i ) * ( ( long ) Math . pow ( p , i ) ) ) ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; } public static void main ( String [ ] args ) { int a = 3 , m = 11 ; System . out . println ( modInverse ( a , m ) ) ; } }
import java . io . * ; public class GFG { static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } static int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int l = 1000 , r = 6000 ; System . out . println ( countNumbers ( l , r ) ) ; } }
import java . io . * ; public class GFG { static void findGreater ( int a , int b ) { double x = a * ( Math . log ( b ) ) ; double y = b * ( Math . log ( a ) ) ; if ( y > x ) System . out . println ( " a ^ b ▁ is ▁ greater " ) ; else if ( y < x ) System . out . println ( " b ^ a ▁ is ▁ greater " ) ; else System . out . println ( " Both ▁ are ▁ equal " ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 5 , c = 2 , d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ; } }
import java . io . * ; public class GFG { static int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) l = i ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) r = i ; break ; } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) ans -- ; break ; } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) ans -- ; break ; } } return ans ; } public static void main ( String [ ] args ) { String str1 = " toy " ; String str2 = " try " ; int n = str1 . length ( ) ; System . out . println ( findAnswer ( str1 , str2 , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int lo = x ; int hi = x ; int max = 0 ; while ( m -- > 0 ) { int lo = sc . nextInt ( ) ; int hi = sc . nextInt ( ) ; if ( lo < hi ) { max = hi ; } if ( lo > hi ) { lo = lo ; } if ( hi < lo ) { max = hi ; } } System . out . println ( max - lo + 1 ) ; } } }
public class GFG { static boolean bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num = n >> ( l - 1 ) ; int prev = num & 1 ; num = num >> 1 ; for ( int i = 1 ; i < ( r - l ) ; i ++ ) { int curr = num & 1 ; if ( curr == prev ) return false ; prev = curr ; num = num >> 1 ; } return true ; } public static void main ( String [ ] args ) { int n = 18 ; int l = 1 ; int r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ m ] ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; } int min = n - a [ 0 ] ; int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] < 0 ) { count ++ ; } else { if ( count < min ) min = count ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] == 0 ) { if ( b [ i ] % 2 == 0 ) System . out . println ( 0 ) ; else if ( b [ i ] > min ) System . out . println ( 1 ) ; else System . out . println ( 2 ) ; } else { if ( count < min ) System . out . println ( 2 ) ; else System . out . println ( 1 ) ; } } } }
import java . io . * ; public class GFG { static int nth_group ( int n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( nth_group ( N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ n ] ; int [ ] [ ] c = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] = sc . nextInt ( ) ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 0 ) { c [ i ] [ j ] = a [ i ] [ j ] ; sum += a [ i ] [ j ] ; } else { c [ i ] [ j ] = sum - a [ i ] [ j ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) { if ( a [ i ] [ j ] == 0 ) { continue ; } else { int temp = 0 ; for ( int k = i ; k < n ; k ++ ) { temp += a [ k ] [ j ] ; } if ( temp != 0 ) { System . out . println ( - 1 ) ; return ; } } } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( c [ i ] [ j ] == 0 ) { ans = - 1 ; break ; } else if ( c [ i ] [ j ] == 0 ) { ans ++ ; break ; } else if ( c [ i ] [ j ] == 0 ) { ans = - 1 ; break ; } } } if ( ans == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( ans ) ; } } }
import java . util . Scanner ; public class Wifi { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int days = in . nextInt ( ) ; int walkTime = in . nextInt ( ) ; int [ ] arr = new int [ days ] ; for ( int i = 0 ; i < days ; i ++ ) { arr [ i ] = in . nextInt ( ) ; } int walkTime = 0 ; int [ ] ans = new int [ days ] ; for ( int i = 0 ; i < days ; i ++ ) { int next = arr [ i ] + walkTime ; if ( arr [ i ] < next ) { if ( next - arr [ i ] > walkTime ) { ans [ i ] = next - arr [ i ] ; } else { if ( next - arr [ i ] < walkTime ) { ans [ i ] = walkTime - arr [ i ] ; } else { ans [ i ] = next + arr [ i ] ; } walkTime = next - arr [ i ] ; } } } System . out . println ( ans [ days - 1 ] ) ; for ( int i = 0 ; i < days ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } }
public class GFG { static int MAX = 1000000 ; static int maximumOccurredElement ( int L [ ] , int R [ ] , int n ) { int arr [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ L [ i ] ] ++ ; arr [ R [ i ] + 1 ] -- ; } int msum = arr [ 0 ] ; for ( int i = 1 ; i < MAX ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; if ( msum < arr [ i ] ) { msum = arr [ i ] ; ind = i ; } } return ind ; } public static void main ( String [ ] args ) { int L [ ] = { 1 , 4 , 9 , 13 , 21 } ; int R [ ] = { 15 , 8 , 12 , 20 , 30 } ; int n = L . length ; System . out . println ( maximumOccurredElement ( L , R , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { String t = sc . next ( ) ; if ( ( t + t ) . charAt ( 0 ) != s . charAt ( s . length ( ) - 1 ) ) { count ++ ; } } System . out . println ( count ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n > m ) { System . out . println ( " Impossible " ) ; return ; } System . out . println ( ( n + m ) - 1 + " ▁ " + ( n + m - 1 ) ) ; } }
import java . io . * ; public class GFG { static float func ( float x ) { return ( 1 ) / ( 1 + x * x ) ; } static float calculate ( float lower_limit , float upper_limit , float interval_limit ) { float interval_size = ( float ) ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ; for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( ( float ) ( 3 * interval_size ) / 8 ) * sum ; } public static void main ( String [ ] args ) { float interval_limit = 10 ; float lower_limit = 1 , upper_limit = 10 ; float integral_res = calculate ( lower_limit , upper_limit , interval_limit ) ; System . out . println ( integral_res ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int ans = 0 ; if ( k == 0 ) { ans = ( n * x ) ; } else { ans = ( ( n - k ) * x ) + ( ( n - k ) * y ) ; } System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { double x = in . nextDouble ( ) ; if ( x == 0 ) return false ; double h = in . nextDouble ( ) ; double dist = Math . sqrt ( h * h + x * x * x ) ; out . printf ( " % .6f \n " , dist + ( 2 * x * x ) ) ; return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { ans = ans + 9 ; if ( ans <= 9 ) { ans = ans - 9 ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int MAX = 100000 ; static boolean prime [ ] = new boolean [ MAX ] ; static void sieve ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } } static void printPrimeQuad ( int n ) { for ( int i = 0 ; i < n - 7 ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] && prime [ i + 6 ] && prime [ i + 8 ] ) System . out . println ( i + " ▁ " + ( i + 2 ) + " ▁ " + ( i + 6 ) + " ▁ " + ( i + 8 ) ) ; } } public static void main ( String [ ] args ) { sieve ( ) ; int n = 20 ; printPrimeQuad ( 20 ) ; } }
public class GFG { static int MAX = 1000 ; static int maxSubsequenceSubstring ( String x , String y , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x . charAt ( j - 1 ) == y . charAt ( i - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; } public static void main ( String [ ] args ) { String x = " ABCD " , y = " BACDBDCD " ; int n = x . length ( ) , m = y . length ( ) ; System . out . println ( maxSubsequenceSubstring ( x , y , n , m ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % a == 0 || i % b == 0 ) sum += i ; } return sum ; } public static void main ( String [ ] args ) { int n = 10 ; int a = 3 ; int b = 5 ; System . out . println ( findSum ( n , a , b ) ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { arr [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < t . length ( ) ; i ++ ) { arr [ t . charAt ( i ) - ' a ' ] ++ ; } int upper = 0 , lower = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 || i == 26 ) { break ; } int val = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { int val1 = Math . min ( arr [ s . charAt ( i ) - ' a ' ] , arr [ t . charAt ( i ) - ' a ' ] ) ; int val2 = Math . min ( arr [ s . charAt ( i ) - ' a ' ] , arr [ t . charAt ( i ) - ' a ' ] ) ; int val3 = Math . min ( val , val2 ) ; upper += val3 ; arr [ i ] -= val1 ; arr [ t . charAt ( i ) - ' a ' ] = val2 ; lower += val1 ; } } System . out . println ( upper + " ▁ " + lower ) ; } }
import java . io . * ; public class GFG { static int MAX = 1000 ; static int sequence [ ] = new int [ MAX + 1 ] ; static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) sequence [ i ] = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( sequence [ j ] == sequence [ i ] ) { sequence [ i + 1 ] = i - j ; break ; } } } } static int getNthTerm ( int n ) { return sequence [ n ] ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 6 ; System . out . println ( getNthTerm ( n ) ) ; n = 100 ; System . out . println ( getNthTerm ( n ) ) ; } }
import java . io . * ; public class GFG { static int MAX = 10000 ; static int sequence [ ] = new int [ MAX + 1 ] ; static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( sequence [ j ] == sequence [ i ] ) { sequence [ i + 1 ] = i - j ; break ; } } } } static int getCount ( int n ) { int count = 1 ; int i = n - 1 ; while ( sequence [ i + 1 ] != 0 ) { count ++ ; i = i - sequence [ i + 1 ] ; } return count ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 5 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } }
import java . io . * ; public class GFG { static int MAX = 10000 ; static int sequence [ ] = new int [ MAX + 1 ] ; static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( sequence [ j ] == sequence [ i ] ) { sequence [ i + 1 ] = i - j ; break ; } } } } static int getCount ( int n ) { int nthTerm = sequence [ n - 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sequence [ i ] == nthTerm ) count ++ ; } return count ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 5 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } }
import java . io . * ; public class GFG { static int nthElement ( int a , int b , int n ) { int lcm = ( a * b ) / ( int ) Math . gcd ( a , b ) ; int l = 1 , r = Math . min ( a , b ) * n ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; int val = ( int ) ( mid / a + mid / b - mid / lcm ) ; if ( val == n ) return Math . max ( ( int ) mid / a * a , ( int ) mid / b * b ) ; if ( val < n ) l = mid + 1 ; else r = mid - 1 ; } return Integer . MIN_VALUE ; } public static void main ( String [ ] args ) { int a = 5 , b = 3 , n = 5 ; System . out . println ( nthElement ( a , b , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { FastScanner fs = new FastScanner ( ) ; int y = fs . nextInt ( ) ; for ( int i = 1 ; ; i ++ ) { boolean b = true ; for ( int j = 1 ; j <= i ; j ++ ) { if ( ( i - j ) % 7 == 0 ) { b = false ; break ; } } if ( b ) { System . out . println ( y ) ; break ; } } } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] hit = new int [ 3 ] ; int [ ] homerun = new int [ 3 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String c = sc . next ( ) ; if ( c . equals ( " HIT " ) ) { if ( homerun [ count ] == 0 ) { hit [ 0 ] ++ ; homerun [ count ] = 1 ; } else if ( c . equals ( " HOMERUN " ) ) { if ( homerun [ count ] == 1 ) { homerun [ count ] = 0 ; count ++ ; } homerun [ count ] = 1 ; } else if ( c . equals ( " OUT " ) ) { if ( homerun [ count ] == 0 ) { count ++ ; } homerun [ count ] = 0 ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( hit [ i ] + homerun [ i ] ) ; } } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static double findValue ( int x , int y , int z ) { int g = __gcd ( y , z ) ; return ( x * g ) / __gcd ( x , g ) ; } public static void main ( String [ ] args ) { int x = 30 , y = 40 , z = 400 ; System . out . println ( findValue ( x , y , z ) ) ; } }
import java . io . * ; public class GFG { static void foot ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { double k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; double x2 = a * k + x1 ; double y2 = b * k + y1 ; double z2 = c * k + z1 ; System . out . print ( " x2 ▁ = ▁ " + x2 + " ▁ " ) ; System . out . print ( " y2 ▁ = ▁ " + y2 + " ▁ " ) ; System . out . print ( " z2 ▁ = ▁ " + z2 + " ▁ " ) ; } public static void main ( String [ ] args ) { int a = 1 , b = - 2 , c = 0 , d = 0 , x1 = - 1 , y1 = 3 , z1 = 4 ; foot ( a , b , c , d , x1 , y1 , z1 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String [ ] c = new String [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { c [ i ] = scanner . nextLine ( ) ; } if ( c [ 0 ] . charAt ( 0 ) == c [ 1 ] . charAt ( 2 ) && c [ 0 ] . charAt ( 1 ) == c [ 1 ] . charAt ( 1 ) && c [ 0 ] . charAt ( 2 ) == c [ 1 ] . charAt ( 0 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class MinimumOps { public static int getMinimumOps ( int [ ] ar ) { int n = ar . length ; int small = Integer . MAX_VALUE ; int large = Integer . MIN_VALUE ; for ( int val : ar ) { small = Math . min ( small , val ) ; large = Math . max ( large , val ) ; } int [ ] [ ] dp = new int [ n ] [ large + 1 ] ; for ( int j = small ; j <= large ; j ++ ) { dp [ 0 ] [ j ] = Math . abs ( ar [ 0 ] - j ) ; } for ( int i = 1 ; i < n ; i ++ ) { int minimum = Integer . MAX_VALUE ; for ( int j = small ; j <= large ; j ++ ) { minimum = Math . min ( minimum , dp [ i - 1 ] [ j ] ) ; dp [ i ] [ j ] = minimum + Math . abs ( ar [ i ] - j ) ; } } int ans = Integer . MAX_VALUE ; for ( int j = small ; j <= large ; j ++ ) { ans = Math . min ( ans , dp [ n - 1 ] [ j ] ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] ar = { 1 , 2 , 1 , 4 , 3 } ; System . out . println ( getMinimumOps ( ar ) ) ; } }
import java . io . * ; public class GFG { static double PI = 3.14159265 ; static double area_leaf ( double a ) { return ( a * a * ( PI / 2 - 1 ) ) ; } public static void main ( String [ ] args ) { double a = 7 ; System . out . println ( area_leaf ( a ) ) ; } }
import java . io . * ; public class GFG { static int removeAlternate ( int n ) { if ( n == 1 ) return 1 ; if ( n % 2 == 0 ) return 2 * removeAlternate ( n / 2 ) - 1 ; else return 2 * removeAlternate ( ( n - 1 ) / 2 ) + 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( removeAlternate ( n ) ) ; n = 10 ; System . out . println ( removeAlternate ( n ) ) ; } }
import java . io . * ; public class GFG { static void check ( int n , int m ) { if ( n == 2 || m == 2 || n % m == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int m = 3 ; int n = 9 ; check ( n , m ) ; } }
import java . util . * ; import java . io . * ; public class B { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( " \n " ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader read = new FastReader ( ) ; int t = read . nextInt ( ) ; while ( t -- > 0 ) { int n = read . nextInt ( ) ; int m = read . nextInt ( ) ; int k = read . nextInt ( ) ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = read . nextInt ( ) ; Arrays . sort ( arr ) ; if ( m % 2 == 1 && ( n / 2 ) <= m ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } }
import java . io . * ; public class GFG { static int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 4 , - 3 , 2 , - 5 } ; int n = arr . length ; System . out . println ( negProdSubArr ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } static int posProdSubArr ( int arr [ ] , int n ) { int total = ( n * ( n + 1 ) ) / 2 ; int cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 4 , - 3 , 2 , - 5 } ; int n = arr . length ; System . out . println ( posProdSubArr ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { long n = sc . nextLong ( ) ; long k = sc . nextLong ( ) ; long temp ; long count = 0 ; long div = n / k ; temp = n % k ; if ( temp != 0 ) count ++ ; if ( temp > 0 ) count ++ ; System . out . println ( count ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int x = Integer . parseInt ( st . nextToken ( ) ) ; int y = Integer . parseInt ( st . nextToken ( ) ) ; int a = Integer . parseInt ( st . nextToken ( ) ) ; int b = Integer . parseInt ( st . nextToken ( ) ) ; int result = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { result += i ; if ( result % 2 == 0 ) { result -- ; } } System . out . println ( result ) ; } }
import java . io . * ; public class GFG { static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return ( n - len ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 6 , 5 , 4 } ; int n = arr . length ; System . out . println ( minRemove ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static void print_max ( int a [ ] , int n , int k ) { int max_upto [ ] = new int [ n ] ; Vector < Integer > s = new Vector < > ( ) ; s . add ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . isEmpty ( ) && a [ s . peek ( ) ] < a [ i ] ) { max_upto [ s . peek ( ) ] = i - 1 ; s . remove ( ) ; } s . add ( i ) ; } while ( ! s . isEmpty ( ) ) { max_upto [ s . peek ( ) ] = n - 1 ; s . remove ( ) ; } int j = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { while ( j < i || max_upto [ j ] < i + k - 1 ) j ++ ; System . out . print ( a [ j ] + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 } ; int n = a . length ; int k = 3 ; print_max ( a , n , k ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int max = 0 ; for ( int a = 0 ; a < 100 ; a ++ ) { for ( int b = 0 ; b < 100 ; b ++ ) { int sum = 0 ; for ( int i = 0 ; i < a ; i ++ ) sum += ( int ) ( '0' + a * Math . pow ( 10 , b ) ) ; } max = Math . max ( max , sum ) ; } return Integer . toString ( max ) ; } }
import java . util . HashSet ; public class Main { public static int countWindowDistinct ( int [ ] win , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j = 0 ; while ( j < i ) { if ( win [ i ] == win [ j ] ) { break ; } else { j ++ ; } } if ( j == i ) { dist_count ++ ; } } return dist_count ; } public static void countDistinct ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int [ ] subArray = new int [ k ] ; System . arraycopy ( arr , i , subArray , 0 , k ) ; System . out . println ( countWindowDistinct ( subArray , k ) ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 1 , 3 , 4 , 2 , 3 } ; int k = 4 ; int n = arr . length ; countDistinct ( arr , n , k ) ; } }
import java . io . * ; public class GFG { static int evenNumSubstring ( String str [ ] ) { int len = str . length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } public static void main ( String [ ] args ) { String str [ ] = { "1" , "2" , "3" , "4" } ; System . out . println ( evenNumSubstring ( str ) ) ; } }
import java . util . * ; public class GFG { static int max = 4 ; static int countWays ( int index , int cnt , int dp [ ] [ ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } public static void main ( String [ ] args ) { int n = 3 , m = 3 , k = 2 ; int [ ] [ ] dp = new int [ max ] [ n ] ; for ( int i = 0 ; i < max ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . print ( m * countWays ( 1 , 0 , dp , n , m , k ) ) ; } }
import java . util . * ; public class GFG { static int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += i ; sum += n / i ; } } return sum - n ; } static void printAliquot ( int n ) { System . out . print ( n + " ▁ " ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( n ) ; int nextt = 0 ; while ( n > 0 ) { n = getSum ( n ) ; if ( s . contains ( n ) ) { System . out . println ( " Repeats ▁ with ▁ " + n ) ; break ; } System . out . print ( n + " ▁ " ) ; s . add ( n ) ; nextt ++ ; } } public static void main ( String [ ] args ) { printAliquot ( 12 ) ; } }
import java . util . Scanner ; public class Bulbs { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int [ ] x = new int [ n + 1 ] ; int [ ] y = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { x [ i ] = in . nextInt ( ) ; } for ( int i = 1 ; i <= n ; i ++ ) { y [ i ] = in . nextInt ( ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( x [ i ] == 1 ) { System . out . print ( 1 + " ▁ " ) ; } else { System . out . print ( 2 + " ▁ " ) ; } } } }
import java . io . * ; public class GFG { static void reverseArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { int temp = arr [ i ] ; arr [ i ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] ; arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = temp ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = arr . length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; public class GFG { static void printSeriesSum ( int N ) { int sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * ( 3 / 2 ) ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int N = 8 ; printSeriesSum ( N ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; while ( t > 0 ) { t -- ; int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; int c = gcd ( a , b ) ; a = a / c ; b = b / c ; int ans1 , ans2 ; if ( a == b ) { ans1 = 1 ; ans2 = 0 ; } else if ( a % 2 == 0 || b % 2 == 0 ) { ans1 = 1 ; ans2 = 1 ; } else { ans1 = a * b / 2 + 1 ; ans2 = a * b / 2 ; } System . out . println ( ans1 + " ▁ " + ans2 ) ; } } public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } else { return gcd ( b % a , a ) ; } } }
import java . util . * ; public class GFG { static int sz = ( int ) 1e5 ; static boolean [ ] isPrime = new boolean [ sz + 1 ] ; static void sieve ( ) { for ( int i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j <= sz ; j += i ) isPrime [ j ] = false ; } } } static int minDifference ( int L , int R ) { int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { snd = i ; break ; } } if ( snd == 0 ) return - 1 ; int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { if ( i - snd <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; } public static void main ( String [ ] args ) { sieve ( ) ; int L = 21 , R = 50 ; System . out . println ( minDifference ( L , R ) ) ; } }
public class GFG { static int getMaxLength ( int arr [ ] , int n ) { int start = 0 ; int preCnt = 0 ; while ( start < n && arr [ start ] == 1 ) { preCnt ++ ; start ++ ; } int end = n - 1 ; int suffCnt = 0 ; while ( end >= 0 && arr [ end ] == 1 ) { suffCnt ++ ; end -- ; } if ( start > end ) return n ; int midCnt = 0 ; int i = start ; int result = 0 ; while ( i <= end ) { if ( arr [ i ] == 1 ) { midCnt ++ ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } i = i + 1 ; } return Math . max ( result , preCnt + suffCnt ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( getMaxLength ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int d = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ d ] ; int [ ] b = new int [ d ] ; int [ ] c = new int [ d ] ; for ( int i = 0 ; i < d ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; c [ i ] = sc . nextInt ( ) ; } int [ ] [ ] dp = new int [ d + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] <= b [ i ] && c [ j ] <= c [ i ] ) { dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + Math . abs ( c [ j ] - c [ i ] ) ) ; } } } int ans = 0 ; for ( int i = 0 ; i <= d ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { System . out . println ( " YES " ) ; System . out . println ( i + " ▁ " + ( i + 1 ) ) ; return ; } } System . out . println ( " NO " ) ; } }
import java . io . * ; public class GFG { static double sqroot ( double s ) { double pSq = 0 , P = 0 , A = 0 ; for ( int i = s ; i >= 1 ; i -- ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } double d = s - pSq ; double P = d / ( 2.0 * N ) ; double A = N + P ; double sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; } public static void main ( String [ ] args ) { double num = 9.2345 ; double sqroot_of_num = sqroot ( num ) ; System . out . println ( " Square ▁ root ▁ of ▁ " + num + " ▁ = ▁ " + sqroot_of_num * 100000.0 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int [ ] temp = arr ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp [ i ] > arr [ i ] ) { temp [ i ] = arr [ i ] ; count ++ ; } else { if ( count % 2 == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int j = i - 1 ; j >= 0 && temp [ j ] <= arr [ j ] ; j -- ) { count ++ ; temp [ j ] = arr [ j ] ; } } } System . out . println ( count ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; class Main { public static void main ( final String [ ] args ) { final Scanner stdin = new Scanner ( System . in ) ; while ( true ) { final int r = stdin . nextInt ( ) ; final int n = stdin . nextInt ( ) ; if ( r == 0 && n == 0 ) { break ; } final int [ ] x = new int [ n ] ; final int [ ] y = new int [ n ] ; final int [ ] h = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { final int x = stdin . nextInt ( ) ; final int y = stdin . nextInt ( ) ; final int d = stdin . nextInt ( ) ; for ( int j = x + 1 ; j < x + 1 ; j ++ ) { h [ i ] = max ( h [ i ] , d ) ; } } final double left = 0 ; final double right = 0 ; final double mid = ( left + right ) / 2 ; for ( final int i = 0 ; i < n ; i ++ ) { final double mid = ( left + right ) / 2 ; final double value = Math . sqrt ( mid * mid + ( x - i ) * ( x - i ) * ( x - i ) + ( y - i ) * ( y - r ) ) ; final double dist = Math . min ( mid - value , dist ) ; if ( dist < left ) { left = mid ; } else { right = mid ; } } final double value = Math . sqrt ( right * right - ( left + right ) * ( right - left ) / 2 ) ; final double dist_value = dist + value ; double lo = 0 ; double hi = mid ; while ( lo < hi ) { final double value = ( right + low ) / 2 ; final double dist = Math . min ( mid - value , dist_value ) ; final double dist_value = dist + value ; if ( dist < left + mid ) { hi = mid ; } else { lo = mid ; } } System . out . println ( lo + hi ) ; } } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int i = 0 , j = i , ans = 0 ; while ( i < n ) { while ( j < n && arr [ j ] == i ) j ++ ; if ( j == i ) ans ++ ; i ++ ; } System . out . println ( ans ) ; } } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { int n = in . nextInt ( ) ; if ( n != 0 ) return true ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = ( n % 10 + 7 ) % 10 ; n /= 10 ; } int l = s [ 0 ] ; while ( l != 0 ) { int u = ( l + 1 ) / 2 , a = ( l + r ) % 10 ; out . printf ( " % c % d % n " , u , a > 0 ? ( a - 1 ) / 10 : a % 10 ) ; l /= 10 ; } return false ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . io . * ; public class GFG { static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n + 1 ] ; int inc [ ] = new int [ n + 1 ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) { inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 2 , 3 , 5 , 7 , 9 , 10 } ; int n = arr . length ; System . out . println ( " Maximum ▁ sum ▁ = ▁ " + maxAlternateSum ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static void generateArr ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( arr [ 0 ] ) ; return ; } int [ ] barr = new int [ n ] ; barr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; barr [ n - 1 ] = arr [ n - 1 ] & arr [ n - 2 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) barr [ i ] = arr [ i - 1 ] & arr [ i + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( barr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; generateArr ( arr , n ) ; } }
import java . util . * ; public class GFG { static void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . * ; public class GFG { static void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev + arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev + arr [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; public class GFG { static int countTriplets ( int A , int B , int C ) { int ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; } public static void main ( String [ ] args ) { int A = 3 , B = 2 , C = 2 ; System . out . println ( countTriplets ( A , B , C ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 100000 ; static boolean prime [ ] = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int smallestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) return i ; } return - 1 ; } static int largestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = r ; i > l ; i -- ) { if ( prime [ i ] ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int queries [ ] = { 2 , 5 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . print ( smallestPrime ( queries [ i ] ) + " ▁ " + largestPrime ( queries [ i ] ) + " \n " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] d = new int [ n ] ; int [ ] w = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { d [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { w [ i ] = sc . nextInt ( ) ; } int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; } } dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = Integer . min ( dp [ i ] [ j ] , dp [ i ] [ j - 1 ] + d [ j ] * w [ i ] ) ; } } System . out . println ( dp [ n ] [ m ] ) ; } }
import java . util . Scanner ; public class Test { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int sum = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { sum += x ; } System . out . println ( sum ) ; } }
import java . util . * ; public class B1095 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int [ ] t = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { t [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int x = t [ i ] - a * m ; if ( x < 0 ) x += d ; if ( x >= n ) break ; count += ( x / a ) * d + d ; if ( x % a == 0 ) count ++ ; } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; long ans = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { ans += ( ( long ) ( Math . pow ( 2 , j ) - 1 ) ) * ( ( long ) ( Math . pow ( 2 , j ) - 1 ) ) ; } System . out . println ( ans ) ; } } }
import java . util . Scanner ; public class problemB { public static int n ; public static int s ; public static int d ; public static int a [ ] ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; s = sc . next ( ) ; d = 0 ; a = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( d % 2 == 1 ) { a ++ ; d ++ ; } else { b ++ ; break ; } } if ( a % 2 == 1 ) { System . out . println ( " Second " ) ; } else { System . out . println ( " First " ) ; } } }
import java . io . * ; public class GFG { static int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; } static void getSum ( int n ) { n = reverse ( n ) ; int sumOdd = 0 , sumEven = 0 ; int c = 1 ; while ( n != 0 ) { if ( c % 2 == 0 ) { sumEven += n % 10 ; } else { sumOdd += n % 10 ; } n /= 10 ; c ++ ; } System . out . println ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; System . out . println ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; } public static void main ( String [ ] args ) { int n = 457892 ; getSum ( n ) ; } }
public class GFG { static void disp ( int row_no , int block ) { System . out . println ( row_no * block ) ; } static int row ( int ht , int h ) { return ht / h ; } static void calculate ( int l , int w , int h , int a , int ht ) { int no_block ; if ( h < w ) row_no = row ( ht , w ) ; else row_no = row ( ht , h ) ; disp ( row_no , no_block ) ; } public static void main ( String [ ] args ) { int l = 50 , w = 20 , h = 35 , a = 700 , ht = 140 ; calculate ( l , w , h , a , ht ) ; } }
public class GFG { static String bin [ ] = { "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" } ; static int maxFreq ( String s ) { String binary = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) binary += bin [ s . charAt ( i ) - '0' ] ; binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = - 1 , j = 0 ; for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { if ( binary . charAt ( i ) == '1' ) { count = Math . max ( count , j - prev ) ; prev = j ; } j ++ ; } return count ; } public static void main ( String [ ] args ) { String octal = "13" ; System . out . println ( maxFreq ( octal ) ) ; } }
public class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } static String encryptString ( String s , int n , int k ) { int cv [ ] = new int [ n ] ; int cc [ ] = new int [ n ] ; if ( isVowel ( s . charAt ( 0 ) ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + isVowel ( s . charAt ( i ) ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s . charAt ( i ) ) == false ? 1 : 0 ) ; } String ans = " " ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += prod ; for ( int i = k ; i < s . length ( ) ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += ( prod ) ; } return ans ; } public static void main ( String [ ] args ) { String s = " hello " ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encryptString ( s , n , k ) ) ; } }
import java . io . * ; public class GFG { static float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 ; float frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; } public static void main ( String args [ ] ) { int num [ ] = { 13 , 14 , 15 , 16 , 17 } ; int freq [ ] = { 2 , 5 , 13 , 7 , 3 } ; int n = num . length ; System . out . println ( harmonicMean ( num , freq , n ) ) ; } }
import java . text . DecimalFormat ; public class Main { public static void main ( String [ ] args ) { int a = 9 ; int n = 6 ; DecimalFormat df = new DecimalFormat ( " # . # # # " ) ; System . out . println ( df . format ( polyarea ( n , a ) ) ) ; } public static double polyarea ( int n , int a ) { if ( a < 0 && n < 0 ) { return - 1 ; } double A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * Math . PI / 180 ) ) ; return A ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int lcm ( int a , int b ) { return ( a / __gcd ( a , b ) * b ) ; } static int getMinValue ( int c ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= Math . sqrt ( c ) ; i ++ ) { if ( c % i == 0 && lcm ( i , c / i ) == c ) ans = Math . min ( ans , Math . max ( i , c / i ) ) ; } return ans ; } public static void main ( String [ ] args ) { int c = 6 ; System . out . println ( getMinValue ( c ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int m = sc . nextInt ( ) , n = sc . nextInt ( ) , m = sc . nextInt ( ) , max = sc . nextInt ( ) , min = sc . nextInt ( ) , ans = max ; if ( m == 0 ) break ; for ( int i = 0 ; i < m ; i ++ ) { int d = sc . nextInt ( ) - 1 ; min = min ( min , d ) ; max = max ( max , d ) ; } System . out . println ( ans ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; import java . io . * ; import java . awt . * ; import java . awt . geom . Point2D ; import static java . lang . Math . * ; public class B { public static void main ( String [ ] $ ) { int b = sc . nextInt ( ) , q = sc . nextInt ( ) , i = sc . nextInt ( ) , s = sc . nextInt ( ) , m = sc . nextInt ( ) ; long [ ] a = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = sc . nextLong ( ) ; long ans = 0 ; for ( long i = b ; i > 0 ; i -- ) { if ( i * q >= b ) { ans ++ ; b *= q ; } } System . out . println ( ans < 32 ? ans : 32 ) ; } static PrintWriter out = new PrintWriter ( System . out ) ; static class sc { static Scanner s = new Scanner ( System . in ) ; static String next ( ) { return s . next ( ) ; } static int nextInt ( ) { return Integer . parseInt ( s . next ( ) ) ; } static long nextLong ( ) { return Long . parseLong ( s . next ( ) ) ; } static double nextDouble ( ) { return Double . parseDouble ( s . next ( ) ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; map . put ( arr [ j ] , j + 1 ) ; } for ( int j = 0 ; j < n ; j ++ ) { if ( map . get ( arr [ j ] ) == null ) { map . put ( arr [ j ] , j + 1 ) ; } } int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) < min ) { min = entry . getValue ( ) ; max = entry . getKey ( ) ; } } System . out . println ( min + " ▁ " + max ) ; } } }
import java . io . * ; public class GFG { static double findIndex ( double n ) { double fibo = 2.078087 * Math . log ( n ) + 1.672276 ; return fibo ; } public static void main ( String [ ] args ) { double n = 21 ; System . out . println ( findIndex ( n ) ) ; } }
import java . util . * ; public class GFG { static boolean isSmaller ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 . charAt ( i ) < str2 . charAt ( i ) ) return true ; else if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) return false ; } return false ; } static String findDiff ( String str1 , String str2 ) { if ( isSmaller ( str1 , str2 ) ) { String temp = str1 ; str1 = str2 ; str2 = temp ; String str3 = " " ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; str1 = str1 . substring ( n - 1 , n2 ) ; str2 = str2 . substring ( n - 1 , n2 ) ; int carry = 0 ; for ( int i = 0 ; i < n2 ; i ++ ) { int sub = ( ( str1 . charAt ( i ) - '0' ) - ( str2 . charAt ( i ) - '0' ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str3 = str3 + sub ; } for ( int i = n2 ; i < n1 ; i ++ ) { int sub = ( ( str1 . charAt ( i ) - '0' ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str3 = str3 + str ; } str3 = str3 ; return str3 ; } public static void main ( String [ ] args ) { String str1 = "978" ; String str2 = "12977" ; System . out . println ( findDiff ( str1 , str2 ) ) ; String s1 = "100" ; String s2 = "1000000" ; System . out . println ( findDiff ( s1 , s2 ) ) ; } }
public class GFG { static int minSwaps ( String s1 , String s2 ) { int c0 = 0 , c1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) c0 ++ ; else if ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) c1 ++ ; } int ans = c0 / 2 + c1 / 2 ; if ( c0 % 2 == 0 && c1 % 2 == 0 ) return ans ; else if ( ( c0 + c1 ) % 2 == 0 ) return ans + 2 ; else return - 1 ; } public static void main ( String [ ] args ) { String s1 = "0011" ; String s2 = "1111" ; int ans = minSwaps ( s1 , s2 ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } long ans = ( long ) ( n * ( n + 1 ) / 2 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , update ( a , i ) ) ; } System . out . println ( ans ) ; } static long update ( int [ ] a , long x ) { int i = 0 ; long j = a . length - 1 ; while ( i <= j ) { i = ( i - j ) / 2 ; j = ( j + 1 ) / 2 ; } return ( a [ i ] + x ) / 2 ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String str = scan . next ( ) ; int left = 0 ; int right = 0 ; int balance = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ^ ' ) { left ++ ; } else { right ++ ; } } if ( left > right ) { System . out . println ( " left " ) ; } else if ( left < right ) { System . out . println ( " right " ) ; } else { System . out . println ( " balance " ) ; } } }
import java . util . * ; public class GFG { static void normalSieve ( int n ) { int prime [ ] = new int [ n / 2 ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < n ; j += i * 2 ) { prime [ j / 2 ] = 1 ; } } } System . out . print ( 2 + " ▁ " ) ; for ( int i = 3 ; i < n ; i += 2 ) { if ( prime [ i / 2 ] == 0 ) { System . out . print ( i + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int n = 100 ; normalSieve ( n ) ; } }
import java . util . Scanner ; public class Code_131A { public static String changeCase ( String str ) { char [ ] ch = str . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < ch . length ; i ++ ) { if ( ch [ i ] >= ' a ' && ch [ i ] <= ' z ' ) { count ++ ; } } if ( count <= 0 ) return " " ; for ( int i = 0 ; i < ch . length - 1 ; i ++ ) { if ( ch [ i ] >= ' a ' && ch [ i + 1 ] <= ' z ' ) { count ++ ; } } if ( count <= 0 ) return " " ; for ( int i = 0 ; i < ch . length ; i ++ ) { if ( ch [ i ] >= ' a ' && ch [ i + 1 ] <= ' z ' ) return changeCase ( ch [ i ] ) ; } return changeCase ( ch ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String str = sc . next ( ) ; System . out . println ( changeCase ( str ) ) ; sc . close ( ) ; } }
import java . io . * ; public class GFG { static int frequencyOfSmallest ( int n , int arr [ ] ) { int mn = arr [ 0 ] ; int freq = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < mn ) { mn = arr [ i ] ; freq = 1 ; } else if ( arr [ i ] == mn ) freq ++ ; } return freq ; } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 3 , 2 , 3 , 4 , 4 } ; System . out . println ( frequencyOfSmallest ( N , arr ) ) ; } }
public class GFG { static boolean isSubArray ( int A [ ] , int B [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( A [ i ] == B [ j ] ) { i ++ ; j ++ ; if ( j == m ) return true ; } else { i = i - j + 1 ; j = 0 ; } } return false ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 3 , 0 , 5 , 1 , 1 , 2 } ; int n = A . length ; int B [ ] = { 3 , 0 , 5 , 1 } ; int m = B . length ; if ( isSubArray ( A , B , n , m ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int sum = n ; for ( int i = 0 ; i < n ; i ++ ) { sum += Math . abs ( arr [ i ] - arr [ i + 1 ] ) + 1 ; } System . out . println ( sum ) ; } }
import java . io . * ; public class GFG { static int calculateSum ( int n , int k ) { int res = 1 ; int MOD = 1000000007 ; for ( int i = 0 ; i < k ; i ++ ) res = ( res * n ) % MOD ; return res ; } public static void main ( String [ ] args ) { int n = 4 ; int k = 3 ; System . out . println ( calculateSum ( n , k ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] [ ] dp = new long [ n + 1 ] [ 4 ] ; dp [ 0 ] [ 0 ] = 1 ; int idx = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { char [ ] a = sc . next ( ) . toCharArray ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { if ( a [ j ] == ' T ' ) { dp [ idx ] [ j + 1 ] = ( dp [ idx ] [ j + 1 ] + dp [ idx ] [ j ] ) % 1000000007 ; } else if ( a [ j ] == ' A ' ) { dp [ idx ] [ j + 1 ] = ( dp [ idx ] [ j + 1 ] + dp [ idx ] [ j ] ) % 1000000007 ; } } idx ++ ; } System . out . println ( dp [ idx ] [ 0 ] ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < String > input = new ArrayList < > ( ) ; String line ; int sum_before_change = 0 ; int sum_after_change = 0 ; while ( ( line = br . readLine ( ) ) != null ) { input . add ( line ) ; if ( line . isEmpty ( ) ) break ; } for ( String str : input ) { if ( " , " . equals ( str ) ) break ; input . add ( str ) ; sum_before_change += Integer . parseInt ( str ) ; } System . out . println ( sum_before_change ) ; System . out . println ( sum_after_change ) ; } }
import java . io . * ; public class GFG { static int MAX = 100 ; static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( sumOfproduct ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String string1 , string2 ; System . out . print ( " Enter ▁ the ▁ first ▁ string : ▁ " ) ; string1 = sc . nextLine ( ) ; System . out . println ( string1 ) ; System . out . print ( " Enter ▁ the ▁ second ▁ string : ▁ " ) ; string2 = sc . nextLine ( ) ; System . out . println ( string2 ) ; System . out . print ( " Are ▁ both ▁ strings ▁ same : ▁ " ) ; if ( string1 . equals ( string2 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; public class GFG { static int pairCount ( int arr [ ] , int n ) { int max_val = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) count ++ ; } return ( count * ( count - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( pairCount ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int getPrime ( int arr [ ] , int n ) { int max_val = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) maximum = Math . max ( maximum , arr [ i ] ) ; } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 10 , 15 , 7 , 6 , 8 , 13 } ; int n = arr . length ; System . out . print ( getPrime ( arr , n ) ) ; } }
public final class p048 { public static void main ( String [ ] args ) { System . out . println ( new p048 ( ) . run ( ) ) ; } public String run ( ) { long sum = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) sum += ( long ) Math . pow ( 10 , i ) * i ; return sum ; } private static final long MAX_NUMBERS = 10 ; public String run ( ) { int [ ] NUMBERS = { 371072875339021027987979982208375902465101350250 , 46376937677490009712648124896970078050417018260538 , 74324986199524741059474233309513058123726617309629 , 91942213363574161572522430563301811072406154908250 , 23067588207539346171171980310421047513778063246676 , 89261670696623633820136378418383684178734361726757 , 28112879812849979408065481931592621691275889832738 , 44274228917432520321923589422876796487670272189318 , 47451445736001306439091167216856844588711603153276 , 703864861058430254399396198289175936656560607 , 582035653253593008402633568948830189458628227828 , 801811993848262827112653829987240784473053190104293586 , 8651550600629586486153207527337195919142056499115593487603870771546649911559348760353253593008402633568948830189458628227828 , 80181199384826282711265382998724
import java . util . Arrays ; public class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }
import java . util . * ; public class GFG { static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; } else System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; int n = arr . length ; printDistinct ( arr , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int result = a * b ; System . out . println ( result ) ; } }
import java . io . * ; public class GFG { static int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; } public static void main ( String [ ] args ) { int a = 10 , b = 17 , n = 3 ; System . out . println ( nth_term ( a , b , n ) ) ; } }
public class GFG { static int findSubSequence ( String s , int num ) { int res = 0 ; for ( int i = 0 ; i < num ; i ++ ) { if ( num % 2 == 1 ) res += s . charAt ( i ) - '0' ; } return res ; } static int combinedSum ( String s ) { int n = s . length ( ) ; int c_sum = 0 ; int ran = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= ran ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } public static void main ( String [ ] args ) { String s = "123" ; System . out . println ( combinedSum ( s ) ) ; } }
import java . io . * ; public class GFG { static int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 5 , 3 , 1 , 7 , 3 , 4 } ; int n = a . length ; System . out . println ( minimumCost ( a , n ) ) ; } }
import java . io . * ; public class GFG { static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; } public static void main ( String [ ] args ) { int n = countMultiples ( 25 ) ; System . out . println ( " Count ▁ = ▁ " + n ) ; } }
import java . util . * ; public class GFG { static int longSub ( String str , int k ) { int [ ] freq = new int [ 26 ] ; int start = 0 , maxLen = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; freq [ ch - ' a ' ] ++ ; if ( freq [ ch - ' a ' ] > k ) { if ( maxLen < ( i - start ) ) maxLen = i - start ; while ( freq [ ch - ' a ' ] > k ) { freq [ ch - ' a ' ] -- ; start = start + 1 ; } } } if ( maxLen < ( n - start ) ) maxLen = n - start ; return maxLen ; } public static void main ( String [ ] args ) { String str = " babcaag " ; int k = 1 ; System . out . println ( " Length ▁ = ▁ " + longSub ( str , k ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = 0 ; int g = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; if ( x >= y ) { g += x ; a += x ; } else if ( x >= y ) { a += y ; g += y ; } else { break ; } } System . out . println ( ( a > g ? " A " : " G " ) + ( sum > 0 ? " G " : " A " ) ) ; } }
public class Solution { public String toHex ( int num ) { if ( num == 0 ) { return "0" ; } String mp = "0123456789abcdef " ; String ans = " " ; for ( int i = 0 ; i < 8 ; i ++ ) { int n = num & 15 ; char c = mp . charAt ( n ) ; ans = c + ans ; num = num >> 4 ; } return ans . trim ( ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int num = 26 ; String out = sObj . toHex ( num ) ; System . out . println ( out ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; boolean left = true ; boolean right = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j && i % 2 == 0 ) { left = false ; } else if ( i % 2 == 1 && j == ( n - 1 ) / 2 ) { right = false ; } else if ( i % 2 == 0 && j % 2 == 1 ) { left = false ; } else { right = false ; } } } if ( left && right ) { System . out . println ( " YES " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " S " ) ; } } else { System . out . println ( " NO " ) ; } } }
public class GFG { static void longestString ( String str1 , String str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) result = result + ( char ) ( ' a ' + i ) ; } System . out . println ( result ) ; } public static void main ( String [ ] args ) { String str1 = " geeks " ; String str2 = " cake " ; longestString ( str1 , str2 ) ; } }
public class GFG { static int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; } static int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ) ans += mul ; mul = mul * 2 ; continue ; } int odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c != 0 ) ans += mul ; mul = mul * 2 ; int zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( ( l % 2 == 1 ) && ( r % 2 == 1 ) ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans = ans + 1 ; } return ans ; } public static void main ( String [ ] args ) { int l = 1 , r = 4 ; System . out . println ( xorRange ( l , r ) ) ; } }
public class GFG { static void q1 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " Yes " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q2 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q3 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " Yes " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } static void q4 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } static void q0 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } public static void main ( String [ ] args ) { String s = " abbaabb " ; q0 ( s , 0 ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; int n , m ; int [ ] a , b ; int [ ] [ ] memo ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { n = sc . nextInt ( ) ; if ( n == 0 ) break ; a = new int [ n ] ; b = new int [ n ] ; memo = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) a [ i ] [ j ] = sc . nextInt ( ) + 1 ; for ( int i = 0 ; i < n ; i ++ ) { int k = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; if ( memo [ i ] [ k ] != 0 ) continue ; dfs ( i , k ) ; } } int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( solve ( 0 , sc . nextInt ( ) ) ) ; } } void dfs ( int now , int rest ) { if ( rest == 0 ) return ; memo [ now ] [ rest ] = rest ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( b [ j ] <= now ) continue ; res += solve ( i , j ) ; } } return memo [ now ] [ rest ] = res ; } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
public class GFG { static void findTime ( String T , int K ) { int minutes = ( ( T . charAt ( 0 ) - '0' ) * 10 + T . charAt ( 1 ) - '0' ) * 60 + ( ( T . charAt ( 3 ) - '0' ) * 10 + T . charAt ( 4 ) - '0' ) ) ; minutes += K ; int hour = ( minutes / 60 ) % 24 ; int min = minutes % 60 ; if ( hour < 10 ) System . out . print ( "0" + hour + " : " ) ; else System . out . print ( " " + hour + " : " ) ; if ( min < 10 ) System . out . print ( "0" + min ) ; else System . out . print ( min ) ; } public static void main ( String [ ] args ) { String T = "21:39" ; int K = 43 ; findTime ( T , K ) ; } }
import java . io . * ; public class GFG { static void maxProductSum ( String str , int m ) { int n = str . length ( ) ; int maxProd = Integer . MIN_VALUE , maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str . charAt ( j ) - '0' ) ; sum = sum + ( str . charAt ( j ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( " Maximum ▁ Product ▁ = ▁ " + maxProd ) ; System . out . println ( " Maximum ▁ Sum ▁ = ▁ " + maxSum ) ; } public static void main ( String [ ] args ) { String str = "3675356291" ; int m = 5 ; maxProductSum ( str , m ) ; } }
import java . io . * ; public class GFG { static int minCost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 || m < 0 ) return Integer . MAX_VALUE ; if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + Math . min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } static int min ( int x , int y , int z ) { if ( x < y ) return x if ( x < z ) return x ; else return y if ( y < z ) return y ; } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . println ( minCost ( cost , 2 , 2 ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] p = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = sc . nextInt ( ) ; } Arrays . sort ( p ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int d = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( ( j - i ) * ( k - 1 ) + ( k - j ) <= 1 ) { d = d + Math . abs ( p [ k ] - p [ j ] ) ; } } ans = Math . min ( ans , d ) ; } } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static int [ ] par , rank ; public static int [ ] weight ; public static boolean [ ] used ; public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int q = scan . nextInt ( ) ; rank = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rank [ i ] = 0 ; } for ( int i = 0 ; i < q ; i ++ ) { int t = scan . nextInt ( ) ; if ( t == 1 ) { rank [ i ] = 0 ; } else { int p = scan . nextInt ( ) - 1 ; int q = scan . nextInt ( ) - 1 ; rank [ i ] = rank [ p ] + q ; if ( rank [ i ] == 0 ) { par [ i ] = p ; } else { int q = scan . nextInt ( ) - 1 ; rank [ i ] = rank [ p ] + q ; if ( rank [ i ] == rank [ q ] ) { used [ q ] = true ; rank [ p ] = q ; } } } } } public static int find ( int p , int q ) { if ( used [ p ] == 0 ) { return p ; } else { used [ p ] = 0 ; return par [ p ] = find ( par [ p ] , q ) ; } } public static int rank [ ] ; public static int find ( int p , int q ) { if ( par [ q ] == p ) { return 0 ; } if ( weight [ p ] == 0 ) { return p ; } else { return rank [ q ] = rank [ p ] + rank [ q ] ; } } }
import java . io . * ; public class GFG { static int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( i % M == 0 ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int A = 6 , B = 15 , M = 3 ; System . out . println ( sumDivisibles ( A , B , M ) ) ; } }
import java . io . * ; public class GFG { static int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; if ( a . length > 1 ) a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; } public static void main ( String [ ] args ) { int n = 328 ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + n + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ " + countNumbersWith4 ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int ans = 0 ; if ( n == 1 ) { ans = y ; } else if ( n == 2 ) { ans = x ; } else if ( n == 3 ) { ans = y - x ; } else if ( n == 4 ) { ans = ( y - x ) ; } else if ( n == 5 ) { ans = ( y - x ) ; } else if ( n == 6 ) { ans = ( y - x ) ; } else if ( n == 7 ) { ans = ( y - x ) ; } else if ( n == 8 ) { ans = ( y - x ) ; } else if ( n == 9 ) { ans = ( y - x ) ; } else if ( n == 5 ) { ans = ( y - x ) ; } else if ( n == 6 ) { ans = ( y - x ) ; } else if ( n == 7 ) { ans = ( y - x ) ; } else if ( n == 8 ) { ans = ( y - x ) ; } else if ( n == 9 ) { ans = ( y - x ) ; } else if ( n == 10 ) { ans = ( y - x ) ; } else if ( n == 11 ) { ans = ( y - x ) ; } else if ( n == 12 ) { ans = ( y - x ) ; } else if ( n == 13 ) { ans = ( y - x ) ; } else if ( n == 12 ) { ans = ( y - x ) ; } else if ( n == 2 ) { ans = ( x - y ) ; } else if ( n == 3 ) { ans = ( x - y ) ; } else if ( n == 4 ) { ans = ( x - y ) ; } System . out . println ( ans ) ; } }
public class Main { public static int INT_MIN = - ( int ) Math . pow ( 2 , 31 ) ; public static int INT_MAX = ( int ) Math . pow ( 2 , 31 ) ; public static void findPostOrderUtil ( int [ ] pre , int n , int minval , int maxval , int [ ] preIndex ) { if ( preIndex [ 0 ] == n ) { return ; } if ( pre [ preIndex [ 0 ] ] < minval || pre [ preIndex [ 0 ] ] > maxval ) { return ; } int val = pre [ preIndex [ 0 ] ] ; preIndex [ 0 ] += 1 ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; System . out . print ( val + " ▁ " ) ; } public static void findPostOrder ( int [ ] pre , int n ) { int [ ] preIndex = { 0 } ; findPostOrderUtil ( pre , n , INT_MIN , INT_MAX , preIndex ) ; } public static void main ( String [ ] args ) { int [ ] pre = { 40 , 30 , 35 , 80 , 100 } ; int n = pre . length ; findPostOrder ( pre , n ) ; } }
import java . util . * ; public class GFG { static int countWays ( int n , int arr [ ] , int k ) { if ( k <= 0 || k >= n ) return 0 ; Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; if ( s . size ( ) <= k ) return 0 ; return s . size ( ) - k ; } public static void main ( String [ ] args ) { int arr [ ] = { 100 , 200 , 400 , 50 } ; int k = 3 ; int n = arr . length ; System . out . println ( countWays ( n , arr , k ) ) ; } }
import java . util . Scanner ; public class B_Time_stamp { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int tc = 0 ; tc < n ; ++ tc ) { String str = sc . next ( ) ; System . out . println ( solve ( str ) ) ; } sc . close ( ) ; } static String solve ( String str ) { StringBuilder sb = new StringBuilder ( ) ; int len = str . length ( ) ; if ( len == 1 ) { return " " ; } String [ ] strSplit = str . split ( " : " ) ; int start = 0 , end = str . length ( ) - 1 ; while ( start <= end ) { if ( str . charAt ( start ) == '0' ) { start = 0 ; } else { start = str . indexOf ( '0' ) + 1 ; } sb . append ( start ) ; if ( start == end ) { return str . substring ( 0 , start . length ( ) - 1 ) ; } } return sb . toString ( ) ; } }
public class GFG { static boolean isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ) ? true : false ; } static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i < n ; i ++ ) { if ( isPrime ( i ) != null ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( countInterestingPrimes ( N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String [ ] w = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { w [ i ] = sc . next ( ) ; } Arrays . sort ( w ) ; String s = " " ; int c = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( w [ i ] . equals ( w [ i + 1 ] ) ) { c ++ ; } else { break ; } } if ( c > 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . * ; public class GFG { static int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; } public static void main ( String [ ] args ) { int div [ ] = { 8 , 3 } ; int rem [ ] = { 2 , 2 } ; int N = div . length ; System . out . println ( findNum ( div , rem , N ) ) ; } }
import java . util . * ; public class GFG { static void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 , type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { int temp = arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] ; arr [ type1 ] = temp ; type1 -- ; } else type0 ++ ; } } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int arr_size = arr . length ; segregate0and1 ( arr , arr_size ) ; System . out . print ( " Array ▁ after ▁ segregation ▁ is ▁ " ) ; for ( int i = 0 ; i < arr_size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; set . add ( x ) ; } System . out . println ( set . size ( ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String s = scanner . next ( ) ; String t = scanner . next ( ) ; int a = ( int ) t . charAt ( 0 ) - ( int ) s . charAt ( 0 ) ; int b = Integer . parseInt ( t . substring ( 1 ) ) - Integer . parseInt ( s . substring ( 1 ) ) ; int x = Math . abs ( a ) ; int y = Math . abs ( b ) ; char [ ] c = { ' R ' , ' U ' , ' L ' , ' D ' } ; int i = 0 ; int j = 1 ; if ( a < 0 ) { i = 2 ; } if ( b < 0 ) { j = 3 ; } int k = j ; if ( x > y ) { k = i ; int temp = x ; x = y ; y = temp ; } String m = " " + c [ i ] + c [ j ] ; String n = " " + c [ k ] ; System . out . println ( y ) ; for ( int l = 0 ; l < x ; l ++ ) { System . out . println ( m ) ; } for ( int l = 0 ; l < y - x ; l ++ ) { System . out . println ( n ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } long sum = 0 ; for ( int i = 0 ; i < w ; i ++ ) { for ( int j = 0 ; j < h ; j ++ ) { sum += ( arr [ i ] [ j ] - 1 ) * ( arr [ i ] [ j ] - 1 ) * ( arr [ i ] [ j ] + 1 ) ; } } System . out . println ( sum ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] = sc . nextInt ( ) ; } } boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 ) { continue ; } boolean check = false ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] [ k ] + a [ k ] [ j ] < a [ i ] [ j ] - 1 || a [ i ] [ k ] == a [ j ] [ k ] - 1 ) { check = false ; break ; } } if ( ! check ) { break ; } } if ( flag ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int x = a ^ b ; int y = a ^ b ; System . out . println ( x + y ) ; System . out . println ( y ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; if ( x == 0 ) System . out . println ( "0" ) ; else if ( x == 1 ) System . out . println ( "1" ) ; else if ( x == 2 ) System . out . println ( "2" ) ; else if ( x == 3 ) System . out . println ( "3" ) ; else if ( x == 4 ) System . out . println ( "4" ) ; else if ( x == 5 ) System . out . println ( "6" ) ; else if ( x == 7 ) System . out . println ( "7" ) ; else if ( x == 8 ) System . out . println ( "8" ) ; else if ( x == 9 ) System . out . println ( "1" ) ; else if ( x == 10 ) System . out . println ( "2" ) ; else System . out . println ( "1" ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] [ ] cnt = new long [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; char [ ] c = s . toCharArray ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { cnt [ c [ j ] - ' A ' ] ++ ; } } long ans = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( cnt [ i ] [ j ] > 0 ) ans += cnt [ i ] [ j ] ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } int left = 0 ; int right = 0 ; int count = 0 ; while ( left < n && right < m ) { if ( a [ left ] == b [ right ] ) { count ++ ; left ++ ; } else if ( a [ left ] > b [ right ] ) { right ++ ; } else { left ++ ; } } System . out . println ( count ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int A = sc . nextInt ( ) ; String op = sc . next ( ) ; int B = sc . nextInt ( ) ; if ( op . equals ( " ? " ) ) break ; int ans = 0 ; switch ( op ) { case " + " : ans += A ; break ; case " - " : ans -= A ; break ; case " * " : ans *= B ; break ; case " / " : ans /= B ; break ; } System . out . println ( ans ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int ans = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int start = a [ i ] - a [ i + 1 ] ; int end = a [ i ] + a [ i + 1 ] ; if ( start > end ) { ans ++ ; } else if ( start == end ) { ans ++ ; } } System . out . println ( ans ) ; } }
public class GFG { static int MAX = 256 ; static int countPairs ( String s ) { int cnt [ ] = new int [ MAX ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s . charAt ( i ) - 97 ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( countPairs ( s ) ) ; } }
import java . util . * ; public class GFG { static int [ ] prime = new int [ 100005 ] ; static void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = 1 ; prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = 0 ; } } } static void sortedArray ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) v . add ( arr [ i ] ) ; } Collections . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else System . out . print ( v . get ( j ) + " ▁ " ) ; j ++ ; } } public static void main ( String [ ] args ) { int n = 6 ; int arr [ ] = { 100 , 11 , 500 , 2 , 17 , 1 } ; sortedArray ( arr , n ) ; } }
import java . util . * ; public class Main { public static void createHash ( Set < Integer > hash1 , int maxElement ) { int prev = 0 ; int curr = 1 ; hash1 . add ( prev ) ; hash1 . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; if ( temp <= maxElement ) { hash1 . add ( temp ) ; } prev = curr ; curr = temp ; } } public static int gcdFibonacciFreq ( int [ ] arr , int n ) { Set < Integer > hash1 = new HashSet < > ( ) ; createHash ( hash1 , Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ) ; Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m . put ( arr [ i ] , m . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } int gcd = 0 ; for ( int it : m . keySet ( ) ) { if ( hash1 . contains ( m . get ( it ) ) ) { gcd = gcd ( gcd , it ) ; } } return gcd ; } public static int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 } ; int n = arr . length ; System . out . println ( gcdFibonacciFreq ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . sqrt ( 2 ) ) ; float area = 3.14 * R * R / 2.0 ; return area ; } public static void main ( String [ ] args ) { float a = 4 ; System . out . println ( " Area ▁ of ▁ semicircle ▁ = ▁ " + find_Area ( a ) ) ; } }
import java . io . * ; public class GFG { static int findQuadruples ( int a [ ] , int b [ ] , int c [ ] , int d [ ] , int x , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int l = 0 ; l < n ; l ++ ) { if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) count ++ ; } } } } return count ; } public static void main ( String [ ] args ) { int x = 3 ; int a [ ] = { 0 , 1 } ; int b [ ] = { 2 , 0 } ; int c [ ] = { 0 , 1 } ; int d [ ] = { 0 , 1 } ; int n = a . length ; System . out . println ( findQuadruples ( a , b , c , d , x , n ) ) ; } }
public class GFG { static void findSmallest ( String s , int q [ ] [ ] , int m ) { int N = s . length ( ) ; int H [ ] [ ] = new int [ N + 1 ] [ 26 ] ; for ( int i = 1 ; i <= N ; i ++ ) { H [ i ] [ s . charAt ( i - 1 ) - ' a ' ] ++ ; for ( int j = 0 ; j < 26 ; j ++ ) H [ i ] [ j ] += H [ i - 1 ] [ j ] ; } for ( int j = 0 ; j < m ; j ++ ) { int l = q [ j ] [ 0 ] ; int r = q [ j ] [ 1 ] ; int n = q [ j ] [ 2 ] ; int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] ; if ( sum >= n ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; break ; } } } } public static void main ( String [ ] args ) { String s = " afbccdeb " ; int q [ ] [ ] = { { 2 , 4 , 1 } , { 1 , 6 , 4 } , { 1 , 8 , 7 } } ; int x = q . length ; findSmallest ( s , q , x ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; String s = sc . next ( ) ; long zero = 0 ; long one = 0 ; long zero = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { one ++ ; } else { zero ++ ; } } long x = Math . min ( one , zero ) ; long y = Math . min ( one , zero ) ; System . out . println ( Math . min ( x * y , y * z ) ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) ; int start_point = 0 ; int numb_moves = 0 ; if ( n == 1 ) { System . out . println ( 2 ) ; } else if ( n % 3 == 0 ) { System . out . println ( n / 3 ) ; continue ; } else if ( n == 2 || n == 3 ) { System . out . println ( 1 ) ; } else { int x = n % 3 ; System . out . println ( ( n - x ) / 3 + 1 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( n % i == 0 ) { int k = n / i ; String str = s . substring ( 0 , k ) + s . substring ( k + 1 ) ; System . out . println ( str ) ; return ; } } } }
import java . util . * ; public class GFG { static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; } } if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 } ; int n = arr . length ; printPairs ( arr , n ) ; } }
import java . io . * ; public class GFG { static int doublefactorial ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; } public static void main ( String [ ] args ) { System . out . println ( " Double ▁ factorial ▁ is ▁ " + doublefactorial ( 5 ) ) ; } }
public class Main { public static void main ( String [ ] args ) { System . out . println ( minRemovals ( "010010" ) ) ; System . out . println ( minRemovals ( "0100101" ) ) ; } public static int minRemovals ( String str ) { if ( str . equals ( " " ) ) { return 0 ; } if ( isPalindrome ( str ) ) { return 1 ; } return 2 ; } public static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) { if ( str . charAt ( l ) != str . charAt ( h ) ) { return false ; } l = l + 1 ; h = h - 1 ; } return true ; } }
import java . util . * ; public class GFG { static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; sumofdigit [ 0 ] = num . charAt ( 0 ) ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; } public static void main ( String [ ] args ) { String num = "1234" ; System . out . println ( sumOfSubstrings ( num ) ) ; } }
import java . io . * ; public class GFG { static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b % n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; } public static void main ( String [ ] args ) { int a = 5 , b = 13 , n = 3 ; System . out . println ( findCountOfPairs ( a , b , n ) ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int LIMIT = 1000000 ; int maxnumer = 0 ; int maxdenom = 1 ; for ( int d = 1 ; d <= LIMIT ; d ++ ) { int n = d * 3 / 7 ; if ( d % 7 == 0 ) n -- ; if ( n * maxdenom > d * maxnumer ) { maxnumer = n ; maxdenom = d ; } } return Integer . toString ( maxnumer ) ; } }
import java . io . * ; public class GFG { static int c [ ] = new int [ 100 ] ; static void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) { c [ j ] = c [ j - 1 ] - c [ j ] ; } c [ 0 ] = - c [ 0 ] ; } } static boolean isPrime ( int n ) { coef ( n ) ; c [ 0 ] = c [ 0 ] + 1 ; c [ n ] = c [ n ] - 1 ; int i = n ; while ( i > - 1 && c [ i ] % n == 0 ) i -- ; return ( i < 0 ) ? true : false ; } public static void main ( String [ ] args ) { int n = 37 ; if ( isPrime ( n ) ) System . out . println ( " Prime " ) ; else System . out . println ( " Not ▁ Prime " ) ; } }
import java . io . * ; public class GFG { static int count_greater ( int arr [ ] , int n ) { int min = Integer . MAX_VALUE ; int counter = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > min ) counter ++ ; if ( arr [ i ] <= min ) min = arr [ i ] ; } return counter ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( count_greater ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x - arr [ i ] <= 0 ) { count ++ ; } else { break ; } } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int left = 0 ; int right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( a == - 1 && b == - 1 ) { left ++ ; } else if ( a == 0 && b == 0 ) { right ++ ; } else if ( a > 0 && b > 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; int INF = 1 << 28 ; double EPS = 1e-12 ; int t , d , l ; int [ ] x ; void run ( ) { for ( ; ; ) { t = sc . nextInt ( ) ; d = sc . nextInt ( ) ; l = sc . nextInt ( ) ; if ( ( t | d | l ) == 0 ) { break ; } x = new int [ t + 1 ] ; for ( int i = 0 ; i < t ; i ++ ) { int c = sc . nextInt ( ) ; x [ i + 1 ] = c ; } int max = 0 , idx = 0 ; for ( int i = t ; i <= t ; i ++ ) { int min = i , max = t ; for ( int j = 0 ; j < t ; j ++ ) { if ( x [ j ] - x [ idx ] < d ) { min = x [ j ] - x [ idx ] ; max = max ( max , x [ j ] - x [ idx ] ) ; idx ++ ; } } max = min + max ; } for ( int i = t ; i <= t ; i ++ ) { println ( x [ i ] + " ▁ " + max ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . io . * ; public class GFG { static int minimumSwaps ( int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ; System . out . println ( minimumSwaps ( arr ) ) ; } }
import java . math . BigInteger ; import java . util . PriorityQueue ; public final class p076 { public static void main ( String [ ] args ) { System . out . println ( new p076 ( ) . run ( ) ) ; } private static final int TARGET = 500500 ; private static final int MODULUS = 500500507 ; public String run ( ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; for ( int i = 2 ; i <= TARGET ; i ++ ) { int item = pq . poll ( ) ; ans *= item ; ans %= MODULUS ; pq . add ( item * item ) ; if ( item == nextPrime ) { nextPrime ++ ; while ( ! pq . isEmpty ( ) ) { nextPrime ++ ; } pq . add ( nextPrime ) ; } } } return Integer . toString ( ans ) ; } }
import java . io . * ; public class GFG { static void findUniquePair ( int arr [ ] , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR ^= arr [ i ] ; int set_bit_no = ( XOR & ~ ( XOR - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 } ; int n = a . length ; findUniquePair ( a , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] [ ] arr = new char [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . next ( ) . toCharArray ( ) ; } boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] [ j ] != arr [ i ] [ j ] ) { found = true ; break ; } } } if ( ! found ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = null ; int count = 0 ; while ( ( line = br . readLine ( ) ) != null ) { if ( line . isEmpty ( ) ) break ; char [ ] input = line . toCharArray ( ) ; int num = 0 ; for ( int i = 0 ; i < input . length ; i ++ ) { if ( input [ i ] == ' @ ' ) { num = 0 ; } else if ( input [ i ] == ' ( ' ) { if ( i + 2 < input . length && input [ i + 2 ] == ' ) ' ) { if ( i + 3 < input . length && input [ i + 3 ] == ' ( ' ) { num ++ ; } else { num = input [ i + 2 ] ; } } } } else { if ( input [ i ] == ' @ ' ) { if ( i + 1 < input . length && input [ i + 1 ] == ' ) ' ) { num ++ ; } else if ( i + 1 < input . length && input [ i + 1 ] == ' @ ' ) { if ( i + 2 < input . length && input [ i + 2 ] == ' ( ' ) { num ++ ; } else { num = 0 ; } } } } } System . out . println ( num * num ) ; } } }
import java . util . * ; public class GFG { static boolean isMajority ( int [ ] a ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { if ( x . getValue ( ) >= n / 2 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int [ ] a = { 2 , 3 , 9 , 2 , 2 } ; if ( isMajority ( a ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int [ ] v = new int [ n ] ; int [ ] w = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = sc . nextInt ( ) ; w [ i ] = sc . nextInt ( ) ; } int [ ] [ ] dp = new int [ n + 1 ] [ w + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= w [ i ] ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= w [ i ] ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j ] + v [ i ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= w [ i ] ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i + 1 ] [ j ] ) ; System . out . println ( dp [ n ] [ w [ i ] ] ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc ; static final int INF = 1 << 28 ; static final double EPS = 1e-9 ; class P { double x , y ; P ( double x , double y ) { this . x = x ; this . y = y ; } double length ( P p ) { return sqrt ( ( p . x - x ) * ( p . x - x ) + ( p . y - y ) * ( p . y - y ) ) ; } } void run ( ) { sc = new Scanner ( System . in ) ; LinkedList < P > list = new LinkedList < P > ( ) ; for ( int i = 0 ; i < 1001 ; i ++ ) list . add ( new P ( i , 0.0 ) ) ; int n = sc . nextInt ( ) ; if ( n == - 1 ) { break ; } System . out . println ( list . get ( n - 1 ) . x + " \n " + list . get ( n - 1 ) . y + " \n " + list . get ( n - 1 ) . length ( ) ) ; } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . Arrays ; public class GFG { static void printKMissing ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { System . out . print ( curr + " ▁ " ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { System . out . print ( curr + " ▁ " ) ; curr ++ ; count ++ ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 } ; int n = arr . length ; int k = 3 ; printKMissing ( arr , n , k ) ; } }
import java . util . * ; public class GFG { static void printNumbers ( int a [ ] , int n ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; for ( int j = 1 ; j * j <= num ; j ++ ) { if ( num % j == 0 ) { if ( j != 1 ) mpp . put ( j , mpp . get ( j ) == null ? 1 : mpp . get ( j ) + 1 ) ; if ( ( num / j ) != j ) mpp . put ( num / j , mpp . get ( num / j ) == null ? 1 : mpp . get ( num / j ) + 1 ) ; } } } int maxi = 0 ; for ( Map . Entry < Integer , Integer > it : mpp . entrySet ( ) ) { maxi = Math . max ( it . getValue ( ) , maxi ) ; } for ( Map . Entry < Integer , Integer > it : mpp . entrySet ( ) ) { if ( it . getValue ( ) == maxi ) System . out . print ( it . getKey ( ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 12 , 15 , 27 , 20 , 40 } ; int n = a . length ; printNumbers ( a , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String str = sc . next ( ) ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' a ' ) { count ++ ; } } if ( count % 2 == 0 ) { if ( str . length ( ) % 2 == 1 ) { System . out . println ( " : ( " ) ; } else { String str1 = str . substring ( 0 , str . length ( ) / 2 ) ; String str2 = str . substring ( str . length ( ) / 2 ) ; String str3 = str . substring ( str . length ( ) / 2 ) ; String str4 = str . substring ( 0 , str . length ( ) / 2 ) ; String str5 = str . substring ( str . length ( ) / 2 ) ; String str6 = str . substring ( str . length ( ) / 2 ) ; if ( str1 . equals ( str2 ) ) { System . out . println ( " : ( " ) ; } else { System . out . println ( str1 ) ; } } } else { System . out . println ( " : ( " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int min = arr [ 0 ] , count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; count ++ ; } else { count = 0 ; } } System . out . println ( count ) ; } }
public class GFG { static int checkIfStartsWithCapital ( String str ) { if ( str . charAt ( 0 ) >= ' A ' && str . charAt ( 0 ) <= ' Z ' ) return 1 ; else return 0 ; } static void check ( String str ) { if ( checkIfStartsWithCapital ( str ) == 1 ) System . out . println ( " Accepted " ) ; else System . out . println ( " Not ▁ Accepted " ) ; } public static void main ( String [ ] args ) { String str = " GeeksforGeeks " ; check ( str ) ; str = " geeksforgeeks " ; check ( str ) ; } }
import java . io . * ; public class GFG { static float getAvg ( float prev_avg , float x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; } static void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; System . out . println ( " Average ▁ of ▁ " + i + " ▁ numbers ▁ is ▁ " + avg ) ; } } public static void main ( String [ ] args ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int ans = 0 ; int isPrime [ ] = Library . listPrimality ( 999999 ) ; int primes [ ] = Library . listPrimes ( 999999 ) ; int consecutive = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { int sum = primes [ i ] ; int consec = 1 ; for ( int j = i + 1 ; j < primes . length ; j ++ ) { sum += primes [ j ] ; consec ++ ; if ( sum >= isPrime . length ) break ; if ( isPrime [ sum ] && consec > consecutive ) { ans = sum ; consecutive = consec ; } } } return Integer . toString ( ans ) ; } }
import java . io . * ; public class GFG { static int lis ( int arr [ ] , int n ) { int i , j , maxm = 0 ; int [ ] lst = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lst [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lst [ i ] < lst [ j ] + 1 ) lst [ i ] = lst [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( maxm < lst [ i ] ) maxm = lst [ i ] ; return maxm ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ lst ▁ is ▁ " + lis ( arr , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = a + b ; while ( c * c < 1 ) { c ++ ; } System . out . println ( ( int ) Math . sqrt ( c ) * ( int ) Math . sqrt ( c ) ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . util . * ; public class GFG { static int [ ] fix ( int [ ] A ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) s . add ( A [ i ] ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( s . contains ( i ) ) A [ i ] = i ; else A [ i ] = - 1 ; } return A ; } public static void main ( String [ ] args ) { int [ ] A = { - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 } ; System . out . println ( fix ( A ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int f = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int z = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int x1 = sc . nextInt ( ) ; int y1 = sc . nextInt ( ) ; int z1 = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) ; int y2 = sc . nextInt ( ) ; int z2 = sc . nextInt ( ) ; int x3 = sc . nextInt ( ) ; int y3 = sc . nextInt ( ) ; int z3 = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) ; int y2 = sc . nextInt ( ) ; int z2 = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int x3 = sc . nextInt ( ) ; int y3 = sc . nextInt ( ) ; int z3 = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int x4 = sc . nextInt ( ) ; int y4 = sc . nextInt ( ) ; int x5 = sc . nextInt ( ) ; int y5 = sc . nextInt ( ) ; int z4 = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int x6 = sc . nextInt ( ) ; int y6 = sc . nextInt ( ) ; int z = sc . nextInt ( ) ; int w = x3 + y3 + x4 ; int x8 = sc . nextInt ( ) ; int y8 = sc . nextInt ( ) ; int z = sc . nextInt ( ) ; int w = x2 + y2 + y3 ; int z = x4 + y4 ; int w = x3 + y4 ; int x6 = sc . nextInt ( ) ; int y7 = sc . nextInt ( ) ; int z = x6 + y7 ; int w = x3 + y6 ; if ( z <
public class GFG { static class Node { int data ; Node prev ; Node next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . prev = new_node ; new_node . next = head_ref ; if ( head_ref != null ) head_ref . prev = new_node ; head_ref = new_node ; return head_ref ; } static Node makeOddNode ( Node head_ref , int A [ ] , int n ) { Node ptr = head_ref ; int i = 0 ; while ( ptr != null ) { int next = ptr . next ; if ( ptr . data % 2 == 0 ) ptr . data = A [ i ++ ] ; ptr = next ; } } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = null ; int Arr [ ] = { 3 , 5 , 23 , 17 , 1 } ; head = push ( head , 4 ) ; head = push ( head , 7 ) ; head = push ( head , 8 ) ; head = push ( head , 9 ) ; head = push ( head , 6 ) ; int n = Arr . length ; System . out . print ( " Original ▁ List : " ) ; printList ( head ) ; System . out . println ( ) ; makeOddNode ( head , Arr , n ) ; System . out . print ( " New ▁ odd ▁ List : " ) ; printList ( head ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; sc . hasNext ( ) ; ) { int n = sc . nextInt ( ) , s = sc . nextInt ( ) ; int [ ] dp = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) dp [ i ] += dp [ i ] + i * j ; } int max = 0 , sum = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { sum += dp [ i ] ; max = max ( max , sum ) ; } if ( s > max ) { System . out . println ( 0 ) ; continue ; } int res = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( dp [ i ] != 0 ) continue ; for ( int j = 0 ; j < 10 ; j ++ ) { sum += dp [ i ] + ( j - 1 ) * ( s - i * j ) ; } res += dp [ i ] ; } System . out . println ( res ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class GFG { static int mod = 1000000007 ; static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static int powmod ( int a , int n ) { if ( n == 0 ) return 1 ; int pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) return ( pt * a ) % mod ; else return pt ; } static int CountSubset ( int arr [ ] , int n ) { int ans = powmod ( 2 , n - 1 ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( CountSubset ( arr , n ) ) ; } }
class Main { static final int MAX = 1000001 ; static final double MAX_sqrt = Math . pow ( MAX , 0.5 ) ; static int [ ] primeUpto = new int [ MAX ] ; public static void SieveOfEratosthenes ( ) { int [ ] isPrime = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { isPrime [ i ] = 1 ; } isPrime [ 0 ] = 0 ; isPrime [ 1 ] = 0 ; for ( int i = 2 ; i < MAX_sqrt ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) { isPrime [ j ] = 0 ; } } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) { primeUpto [ i ] += 1 ; } } } public static int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } return ( N - ans + 1 ) != 0 ? ( N - ans + 1 ) : 0 ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; System . out . println ( countOfNumbers ( N , K ) ) ; } }
import java . io . * ; public class GFG { static int countOperations ( int n ) { int i = 2 ; while ( ( i * i ) < n && ( n % i ) != 0 ) i ++ ; if ( ( i * i ) > n ) i = n ; return ( 1 + ( n - i ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countOperations ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; String s = sc . next ( ) ; int [ ] a = new int [ n ] ; int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == ' A ' && s . charAt ( i + 1 ) == ' C ' ) { a [ i ] = 1 ; } else { c [ i ] = 0 ; } } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == ' A ' && s . charAt ( i + 1 ) == ' C ' ) { ans [ i ] = 1 ; } else { ans [ i ] = 0 ; } } for ( int i = 0 ; i < q ; i ++ ) { int l = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; System . out . println ( ans [ r ] - ans [ l - 1 ] ) ; } } }
import java . util . Scanner ; public class A1334 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int l = in . nextInt ( ) ; int r = in . nextInt ( ) ; System . out . println ( l + " ▁ " + 2 * Math . min ( l , r ) ) ; } } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } private static final int LIMIT = 5000 ; private static final int MODULUS = Library . pow ( 10 , 16 ) ; public String run ( ) { int count [ ] = new int [ LIMIT * LIMIT ] ; count [ 0 ] = 1 ; int s = 0 ; for ( int p = Library . listPrimes ( LIMIT ) ; p >= 0 ; p -- ) { for ( int i = 0 ; i <= s ; i ++ ) count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS ; s += p ; } boolean [ ] isPrime = Library . listPrimality ( s + 1 ) ; int sum = 0 ; for ( int i = 0 ; i <= s ; i ++ ) sum += count [ i ] ; return Long . toString ( sum % MODULUS ) ; } }
import java . io . * ; public class GFG { static int countOddNumber ( int row_num ) { int count = 0 ; while ( row_num != 0 ) { count += row_num & 1 ; row_num >>= 1 ; } return ( 1 << count ) ; } static void gouldSequence ( int n ) { for ( int row_num = 0 ; row_num < n ; row_num ++ ) { System . out . print ( countOddNumber ( row_num ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 16 ; gouldSequence ( n ) ; } }
import java . util . * ; public class GFG { static void findMin ( int V ) { int [ ] deno = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; int n = deno . length ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 93 ; System . out . print ( " Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ for ▁ " + n + " ▁ : ▁ " ) ; findMin ( n ) ; } }
import java . math . BigInteger ; import java . util . Arrays ; public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 1 ; ; i ++ ) { if ( isNum ( i ) && isNum ( i * i ) ) return Integer . toString ( i ) ; } } private static boolean isNum ( int i ) { if ( isNum ( i ) ) return false ; if ( Library . isPalindrome ( Integer . parseInt ( Integer . toString ( i ) ) ) ) return true ; if ( Library . isPalindrome ( Integer . toString ( i ) ) ) return false ; return true ; } }
import java . io . * ; public class GFG { static int count ( int arr [ ] , int n , int x ) { if ( x == 1 ) { int ans = ( int ) Math . pow ( 2 , n ) - 1 ; return ans ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) count ++ ; } int ans = ( int ) Math . pow ( 2 , count ) - 1 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 3 , 5 } ; int n = arr . length ; int x = 1 ; System . out . println ( count ( arr , n , x ) ) ; } }
import java . io . * ; public class GFG { static int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 6 } ; int n = arr . length ; System . out . println ( findEle ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static String findExtraCharacter ( String strA , String strB ) { HashMap < Character , Integer > m1 = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) { if ( m1 . containsKey ( strB . charAt ( i ) ) ) m1 . put ( strB . charAt ( i ) , m1 . get ( strB . charAt ( i ) ) + 1 ) ; else m1 . put ( strB . charAt ( i ) , 1 ) ; } for ( int i = 0 ; i < strA . length ( ) ; i ++ ) m1 . put ( strA . charAt ( i ) , m1 . get ( strA . charAt ( i ) ) - 1 ) ; for ( Map . Entry < Character , Integer > entry : m1 . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) return entry . getKey ( ) ; } return null ; } public static void main ( String [ ] args ) { String strA = " abcd " ; String strB = " cbdad " ; System . out . println ( findExtraCharacter ( strA , strB ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int max = 0 ; for ( int i = 0 ; i <= 54 ; i ++ ) { for ( int j = 0 ; j <= 54 ; j ++ ) { for ( int k = 0 ; k <= 54 ; k ++ ) { int d = i * j + j * k ; if ( d > n || d < 0 ) continue ; max = max ( max , d ) ; } } max = max ( max , max ) ; } System . out . println ( max ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { int n = in . nextInt ( ) ; if ( n == 0 ) return false ; String s1 = in . next ( ) ; String s2 = in . next ( ) ; String s = s1 ; int l = 0 , r = 0 ; while ( l < s . length ( ) && r < s . length ( ) ) { int m = s . indexOf ( s1 , l ) ; if ( m == - 1 && s . substring ( 0 , m ) . equals ( s2 ) ) { out . println ( - 1 ) ; return true ; } if ( m == s . length ( ) ) { l = m ; } else if ( m > s . length ( ) ) { out . println ( - 1 ) ; return true ; } s += s . substring ( l , m ) ; r += m ; } return true ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . Scanner ; import java . util . HashMap ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] ls = new int [ n ] ; HashMap < Integer , Integer > cnt = new HashMap < > ( ) ; boolean ans = true ; for ( int i = 0 ; i < n ; i ++ ) { ls [ i ] = input . nextInt ( ) ; if ( ! cnt . containsKey ( ls [ i ] ) ) { cnt . put ( ls [ i ] , 1 ) ; } else { cnt . put ( ls [ i ] , cnt . get ( ls [ i ] ) + 1 ) ; } if ( cnt . get ( ls [ i ] ) > ( n + 1 ) / 2 ) { ans = false ; } } if ( ans ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static int maxSumPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 ) { int max1 = Integer . MIN_VALUE ; int max2 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n1 ; i ++ ) if ( arr1 [ i ] > max1 ) max1 = arr1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) if ( arr2 [ i ] > max2 ) max2 = arr2 [ i ] ; return max1 + max2 ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 10 , 2 , 3 } ; int arr2 [ ] = { 3 , 4 , 7 } ; int n1 = arr1 . length ; int n2 = arr2 . length ; System . out . println ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) ; } }
import java . io . * ; public class GFG { static int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int minimum = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; minimum = Math . min ( minimum , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . abs ( minimum ) ) / Math . abs ( nVal ) ; k = k - ( times * Math . abs ( nVal ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; } public static void main ( String [ ] args ) { int op [ ] = { - 60 , 65 , - 1 , 14 , - 25 } ; int n = op . length ; int k = 100000 ; System . out . println ( operations ( op , n , k ) ) ; } }
public class GFG { static int pref [ ] = new int [ 100010 ] ; static int isPerfectCube ( int x ) { int cr = ( int ) Math . round ( Math . cbrt ( x ) ) ; int rslt = ( cr * cr * cr == x ) ? x : 0 ; return rslt ; } static void compute ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) { pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; } } static void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; System . out . print ( sum + " ▁ " ) ; } public static void main ( String [ ] args ) { compute ( ) ; int Q = 4 ; int arr [ ] [ ] = { { 1 , 10 } , { 1 , 100 } , { 2 , 25 } , { 4 , 50 } } ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; class Main { public static void main ( final String [ ] args ) { final Scanner stdin = new Scanner ( System . in ) ; final int n = stdin . nextInt ( ) ; final int r = stdin . nextInt ( ) ; final int l = stdin . nextInt ( ) ; final int [ ] maxTimes = new int [ n + 1 ] ; maxTimes [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { final int d = stdin . nextInt ( ) ; final int t = stdin . nextInt ( ) ; final int x = stdin . nextInt ( ) ; maxTimes [ d ] += x ; if ( maxTimes [ d ] > 0 ) { maxTimes [ d ] = maxTimes [ d ] + x ; } } int pos = 1 ; int max = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( maxTimes [ i ] > 0 ) { if ( maxTimes [ i ] > maxTimes [ i - 1 ] ) { max = maxTimes [ i ] ; pos = i - 1 ; } } else { if ( maxTimes [ i ] == 0 ) { max = maxTimes [ i - 1 ] ; pos = i - 1 ; } } maxTimes [ pos ] += l ; } System . out . println ( pos + 1 ) ; } }
import java . io . * ; public class GFG { static int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( n + " th ▁ centered ▁ cube ▁ number : ▁ " ) ; System . out . println ( centered_cube ( n ) ) ; n = 10 ; System . out . print ( n + " th ▁ centered ▁ cube ▁ number : ▁ " ) ; System . out . println ( centered_cube ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int i = 0 ; int j = n - 1 ; while ( i < n && s . charAt ( i ) == '0' ) i ++ ; while ( i < n && s . charAt ( i ) == '1' ) j -- ; if ( i == n ) System . out . print ( s . charAt ( i ) ) ; else if ( i == n ) System . out . print ( "0" ) ; else if ( j == 0 || i == n - 1 ) System . out . print ( s . charAt ( i ) ) ; else { if ( i == 0 || j == 0 ) System . out . print ( "1" ) ; else System . out . print ( s . charAt ( i - 1 ) ) ; } } } }
import java . io . * ; public class GFG { static int nthTerm ( int N ) { int nth = 0 ; for ( int i = N ; i >= 1 ; i -- ) nth += Math . pow ( i , i ) ; return nth ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) { pow = pow * x ; } return ( pow == y ) ; } public static void main ( String [ ] args ) { if ( isPower ( 10 , 1 ) ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; if ( isPower ( 1 , 20 ) ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; if ( isPower ( 2 , 128 ) ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; if ( isPower ( 2 , 30 ) ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; } }
import java . io . * ; public class GFG { static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) { pow = pow * x ; } return ( pow == y ) ; } public static void main ( String [ ] args ) { if ( isPower ( 10 , 1 ) ) System . out . println ( 1 ) ; else System . out . println ( 0 ) ; if ( isPower ( 1 , 20 ) ) System . out . println ( 1 ) ; else System . out . println ( 0 ) ; if ( isPower ( 2 , 128 ) ) System . out . println ( 1 ) ; else System . out . println ( 0 ) ; if ( isPower ( 2 , 30 ) ) System . out . println ( 1 ) ; else System . out . println ( 0 ) ; } }
import java . util . * ; public class GFG { static int minimumValue ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 21 , 5 , 3 , 8 } ; int k = 3 ; int n = arr . length ; System . out . println ( minimumValue ( arr , n , k ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; ArrayList < ArrayList < Integer > > graph = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { graph . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) - 1 ; String s = sc . next ( ) ; int b = sc . nextInt ( ) - 1 ; if ( s . equals ( " back " ) ) { graph . get ( a ) . add ( b ) ; } else { graph . get ( b ) . add ( a ) ; } } boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( graph . get ( i ) . size ( ) == 0 ) { flag = true ; break ; } for ( int j = 0 ; j < graph . get ( i ) . size ( ) ; j ++ ) { int k = graph . get ( i ) . get ( j ) ; if ( k == 0 ) { graph . get ( i ) . add ( i ) ; continue ; } graph . get ( i ) . add ( k ) ; graph . get ( i ) . add ( k ) ; } } if ( flag == false ) { System . out . println ( 0 ) ; } else { System . out . println ( 1 ) ; } } }
import java . io . * ; public class GFG { static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }
import java . io . * ; public class GFG { static int findLCM ( int arr [ ] , int n ) { int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) lcm = ( lcm * arr [ i ] ) / __gcd ( arr [ i ] , lcm ) ; return lcm ; } static void countNumbers ( int arr [ ] , int n , int l , int r ) { int lcm = findLCM ( arr , n ) ; int count = ( r / lcm ) - ( ( l - 1 ) / lcm ) ; System . out . println ( count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 2 } ; int n = arr . length ; int l = 1 ; int r = 10 ; countNumbers ( arr , n , l , r ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int ans = 0 ; int max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] == i ) continue ; int x = 0 ; int y = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] == i ) { x = 1 ; break ; } else if ( a [ k ] > j ) { x = 1 ; break ; } if ( b [ k ] == i ) { y = 1 ; break ; } } if ( x > max ) { max = x ; ans = i ; } } } System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; public class Solution { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; while ( t -- > 0 ) { int n = Integer . parseInt ( br . readLine ( ) ) ; String [ ] str = br . readLine ( ) . split ( " ▁ " ) ; int [ ] arr = new int [ n * 4 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = Integer . parseInt ( str [ i ] ) ; Arrays . sort ( arr ) ; boolean ok = true ; for ( int i = 0 ; i < n * 4 ; i ++ ) { if ( arr [ i ] * arr [ i ] != ( arr [ n - i - 1 ] * arr [ i ] ) ) ok = false ; } if ( ok ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . util . * ; public class GFG { static int MinDeletion ( int a [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( a [ i ] , map . get ( a [ i ] ) == null ? 1 : map . get ( a [ i ] ) + 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { int x = entry . getKey ( ) ; int frequency = entry . getValue ( ) ; if ( x <= frequency ) ans += ( frequency - x ) ; else ans += frequency ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 4 , 5 } ; int n = a . length ; System . out . println ( MinDeletion ( a , n ) ) ; } }
import java . util . * ; public class GFG { static String fromStart ( String str , int del11 ) { String inp1 = str . substring ( 0 , del11 - 1 ) ; String inp2 = str . substring ( del1 , str . length ( ) ) ; return inp1 + inp2 ; } static String fromEnd ( String str , int del1 ) { String inp1 = str . substring ( 0 , del1 - 1 ) ; String inp2 = str . substring ( str . length ( ) - del1 + 1 , str . length ( ) ) ; return inp1 + inp2 ; } public static void main ( String [ ] args ) { int in = 1234 ; int del1 = 3 ; System . out . println ( " num _ after _ deleting _ from _ starting ▁ " + fromStart ( inp , del1 ) ) ; System . out . println ( " num _ after _ deleting _ from _ ending ▁ " + fromEnd ( inp , del1 ) ) ; } }
public class GFG { static int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; boolean flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; } public static void main ( String [ ] args ) { int n = 200 ; System . out . println ( nondecdigits ( n ) ) ; } }
import java . util . Scanner ; public class antiPalindrome { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int antiPalindrome = sc . nextInt ( ) ; int bones = sc . nextInt ( ) ; int thirds = sc . nextInt ( ) ; int thirds = sc . nextInt ( ) ; int thirds = sc . nextInt ( ) ; int a = Math . abs ( antiPalindrome - bones ) ; int b = Math . abs ( thirds - thirds ) ; if ( a == b ) { System . out . println ( antiPalindrome + thirds + " ▁ " + ( thirds + thirds ) + " ▁ " + ( thirds + thirds ) ) ; } else if ( a == c ) { System . out . println ( antiPalindrome + " ▁ " + ( thirds + thirds ) ) ; } else if ( a == d ) { System . out . println ( antiPalindrome + " ▁ " + ( thirds + thirds ) ) ; } else System . out . println ( - 1 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; sc . close ( ) ; int an = 0 ; int anako = 0 ; int an2 = 0 ; int an3 = 0 ; int an4 = 0 ; int an5 = 0 ; int an6 = 0 ; int an7 = 0 ; int cnt = 0 ; while ( true ) { an += 10 ; an += 10 ; an += 10 ; if ( y <= 22 ) { an += 10 ; } if ( an > 21 ) { an += 10 ; } if ( an < 21 ) { an += 10 ; } if ( an > 21 ) { an2 = 0 ; } cnt ++ ; if ( cnt == n ) { System . out . println ( " Hanako " ) ; return ; } an += an ; } if ( an == 0 && an2 >= 22 ) { System . out . println ( " Ciel " ) ; return ; } if ( an == 0 && an2 >= 22 ) { System . out . println ( " Hanako " ) ; return ; } if ( an == 0 && an3 >= 22 ) { System . out . println ( " Ciel " ) ; return ; } System . out . println ( " Hanako " ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; char arr [ ] [ ] = new char [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . next ( ) . toCharArray ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' W ' ) { arr [ i ] [ j ] = ' B ' ; } else { arr [ i ] [ j ] = ' W ' ; } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' . ' ) { arr [ i ] [ j ] = ' W ' ; } else { arr [ i ] [ j ] = ' B ' ; } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { System . out . print ( arr [ i ] [ j ] ) ; } System . out . println ( ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int res = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { i ++ ; if ( i < n - 1 ) res = 2 * ( Math . abs ( i - s . charAt ( i ) ) - 1 ) + 2 ; } else { res = 2 * ( Math . abs ( i - s . charAt ( i ) ) - 1 ) + 2 ; if ( res > i + 1 ) res = i + 1 ; } } System . out . println ( res ) ; } }
import java . util . * ; public class GFG { static int countDistictSubarray ( int arr [ ] , int n ) { HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; HashMap < Integer , Integer > v = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; int right = 0 ; int window = 0 ; for ( int left = 0 ; left < n ; left ++ ) { while ( right < n && window < k ) { if ( v . containsKey ( arr [ right ] ) ) v . put ( arr [ right ] , v . get ( arr [ right ] ) + 1 ) ; else v . put ( arr [ right ] , 1 ) ; if ( v . containsKey ( arr [ right ] ) ) { window ++ ; } right ++ ; } if ( window == k ) ans += ( n - right + 1 ) ; v . put ( arr [ left ] , v . get ( arr [ left ] ) - 1 ) ; if ( v . containsKey ( arr [ left ] ) ) { window -- ; } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 3 , 2 , 3 } ; int n = arr . length ; System . out . println ( countDistictSubarray ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int ans = s ; for ( int i = 0 ; i < n ; i ++ ) { int l = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; ans = Math . max ( ans , l + r ) ; } System . out . println ( ans ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int primeBitsInRange ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int tot_bit = Integer . bitCount ( i ) ; if ( isPrime ( tot_bit ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int l = 6 , r = 10 ; System . out . println ( primeBitsInRange ( l , r ) ) ; } }
import java . io . * ; public class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; if ( sum == k ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 4 ; System . out . println ( pairs ( arr , n , k ) ) ; } }
import java . util . * ; public class GFG { static class Queue { private int [ ] data ; public Queue ( ) { data = new int [ 10 ] ; data [ 0 ] = 10 ; data [ 1 ] = 20 ; } public void reverseQueueFirstKElements ( int k ) { if ( Queue . isEmpty ( ) || k > data . length ) return ; if ( k <= 0 ) return ; Stack < Integer > Stack = new Stack < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { Stack . push ( data . get ( 0 ) ) ; data . remove ( 0 ) ; } while ( ! Stack . isEmpty ( ) ) { Stack . push ( data . peek ( ) ) ; data . remove ( 0 ) ; } for ( int i = data . size ( ) - k ; i < data . length ( ) - k ; i ++ ) { Queue . push ( data . get ( 0 ) ) ; data . remove ( 0 ) ; } } public static void main ( String [ ] args ) { Queue q = new Queue ( ) ; q . add ( 10 ) ; q . add ( 20 ) ; q . add ( 30 ) ; q . add ( 40 ) ; q . add ( 50 ) ; q . add ( 60 ) ; q . add ( 70 ) ; q . add ( 80 ) ; q . add ( 90 ) ; q . add ( 100 ) ; int k = 5 ; reverseQueueFirstKElements ( k ) ; q . print ( q ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { count ++ ; } } if ( count % 2 == 0 ) { System . out . println ( " errorgorao90" ) ; } else { System . out . println ( " maomao90" ) ; } } } }
import java . io . * ; public class GFG { static int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; } public static void main ( String [ ] args ) { int k = 31 ; System . out . println ( xorCalc ( k ) ) ; } }
public class Solution { public boolean isPerfectSquare ( int num ) { int low = 1 , high = num ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int mid_square = mid * mid ; if ( mid_square == num ) return true ; else if ( mid_square < num ) low = mid + 1 ; else high = mid - 1 ; } return false ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int num = 16 ; boolean out = sObj . isPerfectSquare ( num ) ; System . out . println ( out ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int max = Math . max ( a , Math . max ( b , c ) ) ; int min = Math . min ( a , Math . min ( c , b ) ) ; if ( max - min == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; int [ ] l = new int [ n ] ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { l [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } int c = 0 ; List < Integer > r = new ArrayList < > ( ) ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += l [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( s - l [ i ] ) / ( n - 1 ) == l [ i ] ) { c ++ ; r . add ( i + 1 ) ; } } System . out . println ( c ) ; for ( int x : r ) { System . out . print ( x + " ▁ " ) ; } } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] ar = new int [ n ] [ 2 ] ; int [ ] time = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] [ 0 ] = sc . nextInt ( ) ; ar [ i ] [ 1 ] = sc . nextInt ( ) ; time [ i ] += ar [ i ] [ 0 ] ; } int now = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( time [ i ] - m > 0 ) { System . out . println ( ar [ i ] [ 0 ] + " ▁ " + ( time [ i ] - m ) ) ; } else { now += ar [ i ] [ 1 ] ; System . out . println ( ar [ i ] [ 0 ] + " ▁ " + ( now - m ) ) ; } } } }
import java . io . * ; public class GFG { static int findElement ( int arr [ ] , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index = index - 1 ; } } return arr [ index ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int rotations = 2 ; int [ ] [ ] ranges = { { 0 , 2 } , { 0 , 3 } } ; int index = 1 ; System . out . println ( findElement ( arr , ranges , rotations , index ) ) ; } }
import java . util . * ; public class GFG { static int MAXN = 1000001 ; static int spf [ ] = new int [ MAXN ] ; static int hash [ ] = new int [ MAXN ] ; static void sieve ( ) { for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i += 2 ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) { if ( spf [ j ] == j ) spf [ j ] = i ; } } } } static void getFactorization ( int x ) { while ( x != 1 ) { int temp = spf [ x ] ; if ( x % temp == 0 ) { hash [ spf [ x ] ] ++ ; x /= spf [ x ] ; } while ( x % temp == 0 ) x /= temp ; } } static boolean check ( int x ) { while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } static boolean hasValidNum ( int arr [ ] , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static boolean isExists ( int a [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( a [ i ] , freq . getOrDefault ( a [ i ] , 0 ) + 1 ) ; sum += a [ i ] ; } if ( sum % 2 == 0 ) { if ( freq . get ( sum / 2 ) != null ) return true ; } return false ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 1 , 2 , 2 } ; int n = a . length ; if ( isExists ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static float areaOfKite ( float d1 , float d2 ) { float area ; area = ( d1 * d2 ) / 2 ; return area ; } public static void main ( String [ ] args ) { float d1 = 4 , d2 = 6 ; System . out . println ( " Area ▁ of ▁ Kite ▁ = ▁ " + areaOfKite ( d1 , d2 ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int sum = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { String a = " . " ; for ( int j = 0 ; j < 4 ; j ++ ) { if ( i == 0 || i == 3 ) a += " ( " ; else if ( i == 2 ) a += " ) " ; else if ( j == 0 || j == 1 ) a += " . " ; sum += i ; } } System . out . println ( a ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; while ( n > 1 ) { if ( n % 2 == 0 ) { n /= 2 ; } else { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; } }
import java . io . * ; public class GFG { static boolean productEqual ( int n ) { if ( n < 10 ) return false ; int prodOdd = 1 , prodEven = 1 ; while ( n > 0 ) { int digit = n % 10 ; prodOdd *= digit ; n = n / 10 ; } if ( prodOdd == prodEven ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 4324 ; if ( productEqual ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n ; int [ ] k ; int [ ] l ; int i , j , a ; String s ; n = sc . nextInt ( ) ; while ( n != 0 ) { k = new int [ 26 ] ; l = new int [ 26 ] ; for ( i = 0 ; i < 26 ; i ++ ) { k [ i ] = sc . nextInt ( ) ; } s = sc . next ( ) ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { a = s . charAt ( i ) - ' a ' ; for ( j = 0 ; j < 26 ; j ++ ) { if ( a == k [ j ] ) { System . out . print ( ( char ) ( ' a ' + ( j % 26 ) ) ) ; break ; } else if ( a > k [ j ] ) { a -- ; j ++ ; } else break ; } } System . out . println ( ) ; n = sc . nextInt ( ) ; } } }
public class GFG { static void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) System . out . println ( " odd " ) ; else System . out . println ( " even " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 1 } ; int n = arr . length ; checkEVENodd ( arr , n , 1 , 3 ) ; } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; BAmrAndPins solver = new BAmrAndPins ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class BAmrAndPins { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int w = in . nextInt ( ) ; int h = in . nextInt ( ) ; int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; int r = in . nextInt ( ) ; int d = Math . abs ( x - r ) ; int e = Math . abs ( y - r ) ; if ( d < 0 || e < 0 || d > w || e > h ) { out . println ( " No " ) ; return ; } out . println ( " Yes " ) ; } } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int findPrime ( int n ) { for ( int num = n + 1 ; num <= n ; num ++ ) { if ( isPrime ( num ) ) return num ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s += arr [ i ] ; if ( isPrime ( s ) ) return 0 ; int num = findPrime ( s ) ; return num - s ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; System . out . println ( minNumber ( arr , arr ) ) ; } }
import java . util . * ; public class GFG { static int max_element ( int [ ] arr ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } static int compositeProduct ( int [ ] arr , int n ) { int max_val = max_element ( arr ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) product *= arr [ i ] ; } return product ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( compositeProduct ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc ; static final int INF = 1 << 28 ; static final double EPS = 1e-9 ; void run ( ) { sc = new Scanner ( System . in ) ; for ( ; ; ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; if ( ( x | y ) == 0 ) { break ; } if ( x < y ) { int tmp = x ; x = y ; y = tmp ; } println ( String . format ( " % d ▁ % d " , x , y ) ) ; } sc . close ( ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String s = sc . next ( ) ; char [ ] ch = s . toCharArray ( ) ; int n = ch . length ; if ( n == 1 ) { if ( ch [ 0 ] == ' j ' && ch [ 1 ] == ' l ' || ch [ 1 ] == ' a ' && ch [ 2 ] == ' d ' || ch [ 2 ] == ' e ' && ch [ 3 ] == ' i ' || ch [ 3 ] == ' o ' && ch [ 4 ] == ' o ' || ch [ 4 ] == ' u ' ) System . out . println ( " FILIPINO " ) ; else if ( n == 2 ) { if ( ch [ 0 ] == ' o ' && ch [ 1 ] == ' o ' || ch [ 2 ] == ' a ' && ch [ 3 ] == ' d ' ) System . out . println ( " KOREAN " ) ; else System . out . println ( " JAPANESE " ) ; } else if ( n == 3 ) { if ( ch [ 0 ] == ' o ' && ch [ 1 ] == ' o ' && ch [ 2 ] == ' o ' ) System . out . println ( " KOREAN " ) ; else System . out . println ( " FILIPINO " ) ; } else if ( n == 4 ) { if ( ch [ 0 ] == ' o ' && ch [ 1 ] == ' o ' ) System . out . println ( " KOREAN " ) ; else System . out . println ( " FILIPINO " ) ; } else if ( n == 5 ) { if ( ch [ 1 ] == ' o ' && ch [ 2 ] == ' d ' ) System . out . println ( " KOREAN " ) ; else System . out . println ( " FILIPINO " ) ; } } } } }
import java . io . * ; public class GFG { static int findSum ( int arr [ ] , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 } ; int queries = 3 ; int q [ ] [ ] = { { 2 , 4 } , { 2 , 6 } , { 5 , 6 } } ; int n = arr . length ; for ( int i = 0 ; i < queries ; i ++ ) System . out . println ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) ) ; } }
import java . io . * ; public class GFG { static int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) { for ( int j = 0 ; j <= n - i ; j += b ) { int z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } } return maxVal ; } public static void main ( String [ ] args ) { int n = 10 ; int a = 5 ; int b = 3 ; int c = 4 ; System . out . println ( maxResult ( n , a , b , c ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 1 ; i < 4 ; i ++ ) { for ( int j = 1 ; j < 10 ; j ++ ) { if ( a [ j ] > a [ j - 1 ] ) { int tmp = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = tmp ; } } } for ( int i = 1 ; i < 10 ; i ++ ) { System . out . println ( a [ i ] ) ; } } }
import java . util . * ; public class GFG { static int fact ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; } static int numberOfPossiblePallindrome ( String str , int n ) { Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( str . charAt ( i ) ) ) mp . put ( str . charAt ( i ) , mp . get ( str . charAt ( i ) ) + 1 ) ; else mp . put ( str . charAt ( i ) , 1 ) ; } int k = 0 ; int num = 0 ; int den = 1 ; int fi = 0 ; for ( Map . Entry < Character , Integer > it : mp . entrySet ( ) ) { if ( it . getValue ( ) % 2 == 0 ) fi = it . getValue ( ) / 2 ; else fi = ( it . getValue ( ) - 1 ) / 2 ; k ++ ; num = num + fi ; den = den * fact ( fi ) ; } if ( num != 0 ) num = fact ( num ) ; int ans = num / den ; if ( k != 0 ) ans = ans * k ; return ( ans ) ; } public static void main ( String [ ] args ) { String str = " ababab " ; int n = str . length ( ) ; System . out . println ( numberOfPossiblePallindrome ( str , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int count = 0 ; for ( int i = n / 2 ; i > 0 ; i -- ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; count ++ ; } } } int temp = arr [ 0 ] ; arr [ 0 ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; count ++ ; } } } int ans = count ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { ans = i + 1 ; break ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } public static void main ( String [ ] args ) { int n = 107 , m = 4 ; System . out . println ( toggleLastMBits ( n , m ) ) ; } }
import java . util . Scanner ; public class test288 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { char a [ ] = in . next ( ) . toCharArray ( ) ; char b [ ] = in . next ( ) . toCharArray ( ) ; int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] == ' B ' ) { sum ++ ; } } if ( sum < 0 ) { System . out . println ( " NO " ) ; } else { if ( a . length > 1 && a [ 0 ] == ' B ' ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } } in . close ( ) ; } }
import java . util . * ; public class GFG { static String first_substring ( String s ) { int n = s . length ( ) , c = 0 ; Map < String , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' || s . charAt ( i ) == ' # ' ) { String s1 = s . substring ( c , i ) ; mpp . put ( s1 , 1 ) ; c = i + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) == ' ▁ ' ) break ; String s1 = s . substring ( i , j + 1 ) ; String s2 = s1 ; s1 = reverse ( s1 ) ; if ( mpp . containsKey ( s1 ) ) { if ( mpp . get ( s1 ) != null ) { return s2 ; } } } } return " - 1" ; } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l = a . length - 1 ; for ( int i = l ; i >= 0 ; i -- ) { char temp = a [ i ] ; a [ i ] = a [ l - 1 ] ; a [ l - 1 ] = temp ; } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String s = " mango ▁ is ▁ sweet ▁ when ▁ nam ▁ en ▁ tastes ▁ it # " ; String s1 = first_substring ( s ) ; System . out . println ( s1 ) ; } }
public class GFG { static int countConsecutive ( int n ) { String s = Integer . toString ( n ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int n = 44522255 ; System . out . println ( countConsecutive ( n ) ) ; } }
import java . io . * ; public class GFG { static void findAngle ( int n ) { double interiorAngle = ( double ) ( ( n - 2 ) * 180 / n ) ; double exteriorAngle = 360 / n ; System . out . println ( " Interior ▁ angle : ▁ " + interiorAngle ) ; System . out . println ( " Exterior ▁ angle : ▁ " + exteriorAngle ) ; } public static void main ( String [ ] args ) { int n = 10 ; findAngle ( n ) ; } }
import java . io . * ; public class GFG { static void nDigitPerfectSquares ( int n ) { System . out . print ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) ; System . out . print ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; } public static void main ( String [ ] args ) { int n = 4 ; nDigitPerfectSquares ( n ) ; } }
import java . util . Scanner ; public class test267 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { in . nextInt ( ) ; in . next ( ) ; char [ ] s = in . next ( ) . toCharArray ( ) ; char [ ] p = new char [ s . length ] ; boolean x = true ; p [ 0 ] = s [ 0 ] ; for ( int i = 1 ; i < s . length ; i ++ ) { if ( p [ i ] != s [ i - 1 ] ) { x = false ; break ; } } if ( x ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } in . close ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { if ( s . charAt ( i ) == ' a ' || s . charAt ( i ) == ' b ' || s . charAt ( i + 1 ) == ' ab ' ) { count ++ ; } } System . out . println ( count ) ; System . out . println ( s ) ; } }
import java . util . * ; public class GFG { static int discard_count = 0 ; static int power ( int a , int n ) { if ( n == 0 ) return 1 ; int p = power ( a , n / 2 ) ; p = p * p ; if ( n & 1 == 1 ) p = p * a ; return p ; } static void solve ( int i , int n , double sum , int k , int a [ ] , int prefix [ ] ) { if ( sum > k ) { discard_count += power ( 2 , n - i ) ; return ; } if ( i == n ) return ; int rem = prefix [ n - 1 ] - prefix [ i ] ; if ( sum + a [ i ] + rem > k ) solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) ; if ( sum + rem > k ) solve ( i + 1 , n , sum , k , a , prefix ) ; } static int countSubsequences ( int arr [ ] , int n , int K ) { double sum = 0.0 ; k = ( int ) Math . log ( K ) ; int prefix [ ] = new int [ n ] ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = ( int ) Math . log ( arr [ i ] ) ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; int total = ( int ) Math . pow ( 2 , n ) - 1 ; if ( sum <= k ) return total ; solve ( 0 , n , 0.0 , k , a , prefix ) ; return total - discard_count ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 7 , 2 } ; int n = arr . length ; int k = 50 ; System . out . println ( countSubsequences ( arr , n , k ) ) ; } }
public class GFG { static class Node { int data ; Node left , right ; } ; static void inorder ( Node root ) { if ( root == null ) return ; inorder ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; inorder ( root . right ) ; } static boolean isIdentical ( Node root1 , Node root2 ) { if ( root1 == null && root2 == null ) return true ; else if ( root1 == null && root2 == null ) return false ; else if ( root1 . data == root2 . data && isIdentical ( root1 . left , root2 . left ) && isIdentical ( root1 . right , root2 . right ) ) return true ; else return false ; } public static void main ( String [ ] args ) { Node root1 = new Node ( 5 ) ; Node root2 = new Node ( 5 ) ; root1 . left = new Node ( 3 ) ; root1 . right = new Node ( 8 ) ; root1 . left . left = new Node ( 2 ) ; root1 . left . right = new Node ( 4 ) ; root2 . left = new Node ( 3 ) ; root2 . right = new Node ( 8 ) ; root2 . left . left = new Node ( 2 ) ; root2 . left . right = new Node ( 4 ) ; Node root2 . left = new Node ( 3 ) ; root2 . right = new Node ( 8 ) ; root2 . left . left = new Node ( 2 ) ; root2 . left . right = new Node ( 4 ) ; if ( isIdentical ( root1 , root2 ) ) System . out . print ( " Both ▁ BSTs ▁ are ▁ identical " ) ; else System . out . print ( " BSTs ▁ are ▁ not ▁ identical " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] s = sc . next ( ) . toCharArray ( ) ; int ans = 0 ; int jsum = 0 ; int isum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' O ' ) { jsum = 0 ; } else if ( s [ i ] == ' J ' ) { jsum ++ ; } else if ( s [ i ] == ' I ' ) { isum ++ ; } } int osum = 0 ; int osum = 0 ; int osum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' O ' ) { osum ++ ; } else if ( s [ i ] == ' J ' ) { osum ++ ; } else if ( s [ i ] == ' I ' ) { osum ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' O ' ) { osum ++ ; } else if ( s [ i ] == ' J ' ) { osum ++ ; } else if ( s [ i ] == ' I ' ) { osum ++ ; } } int osum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' O ' ) { osum ++ ; } else if ( s [ i ] == ' J ' ) { osum ++ ; } else if ( s [ i ] == ' I ' ) { osum ++ ; } } ans += Math . max ( osum , osum ) ; System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] dice = new int [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dice [ 0 ] [ i ] = sc . nextInt ( ) ; dice [ 1 ] [ i ] = sc . nextInt ( ) ; dice [ 2 ] [ i ] = sc . nextInt ( ) ; } char [ ] s = sc . next ( ) . toCharArray ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { switch ( s [ i ] ) { case ' N ' : dice [ 0 ] [ i ] = dice [ 1 ] [ i ] + dice [ 2 ] [ i + 1 ] ; break ; case ' E ' : dice [ 0 ] [ i ] = dice [ 1 ] [ i + 1 ] + dice [ 3 ] [ i + 1 ] ; break ; case ' S ' : dice [ 0 ] [ i ] = dice [ 1 ] [ i + 1 ] + dice [ 2 ] [ i + 1 ] ; break ; case ' W ' : dice [ 0 ] [ i ] = dice [ 1 ] [ i + 1 ] + dice [ 3 ] [ i + 1 ] ; break ; case ' W ' : dice [ 0 ] [ i ] = dice [ 1 ] [ i + 1 ] + dice [ 2 ] [ i + 1 ] ; break ; case ' E ' : dice [ 0 ] [ i ] = dice [ 1 ] [ i + 1 ] + dice [ 3 ] [ i + 1 ] ; break ; } } int ans = dice [ 0 ] [ 1 ] ; System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static class node { int data ; node next ; } ; static node add ( int data ) { node newnode = new node ( ) ; newnode . data = data ; newnode . next = null ; return newnode ; } static void printArr ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } static int findlength ( head ) { Node curr = head ; int cnt = 0 ; while ( curr != null ) { cnt ++ ; curr = curr . next ; } return cnt ; } static void convertArr ( head ) { int len = findlength ( head ) ; Vector < Integer > arr = new Vector < > ( ) ; int index = 0 ; int curr = head ; while ( curr != null ) { arr . add ( curr . data ) ; curr = curr . next ; } printArr ( arr , len ) ; } public static void main ( String args [ ] ) { add ( 1 ) ; head . next = add ( 2 ) ; head . next . next = add ( 3 ) ; head . next . next . next = add ( 4 ) ; head . next . next . next . next = add ( 5 ) ; convertArr ( head ) ; } }
import java . io . * ; public class GFG { static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( " Non - decreasing ▁ digits ▁ = ▁ " + nonDecNums ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( i + arr [ i ] ) % n ; set . add ( x ) ; } if ( set . size ( ) == n ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public class Solution { public int minMoves ( int [ ] nums ) { if ( nums . length == 0 || nums . length == 0 ) return 0 ; int min = Collections . min ( nums ) ; int sum = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) sum += nums [ i ] - min ; return sum ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 1 , 2 , 3 } ; int out = sObj . minMoves ( nums ) ; System . out . println ( out ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( a > 0 && b > 0 ) { if ( a % 2 == 0 && b % 2 == 0 ) { System . out . println ( " Positive " ) ; } else { System . out . println ( " Negative " ) ; } } else if ( a < 0 && b % 2 == 0 ) { System . out . println ( " Negative " ) ; } else { System . out . println ( " Positive " ) ; } } }
import java . io . * ; public class GFG { static int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( firstSetBit ( n ) ) ; } }
import java . util . * ; public class GFG { static int MAX_CHAR = 256 ; static int maximumChars ( String str ) { int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; } public static void main ( String [ ] args ) { String str = " abba " ; System . out . println ( maximumChars ( str ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; arr [ i ] += d ; max = Math . max ( max , arr [ i ] ) ; } long ans = 0 ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] > 0 && Math . abs ( arr [ i ] - arr [ i ] ) < d ) { sum += arr [ i ] ; ans = Math . max ( ans , sum ) ; sum -= arr [ i ] ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static float findArea ( float a ) { float area = 5 * ( float ) ( 3 * Math . sqrt ( 3 ) ) * a * a ; return area ; } static float findVolume ( float a ) { float volume = ( ( 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a * a ; return volume ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( " Area : ▁ " + findArea ( a ) ) ; System . out . println ( " Volume : ▁ " + findVolume ( a ) ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int nine_pyramid [ ] = { 1 , 1 , 1 , 1 , 1 } ; int six_cubes [ ] = { 1 , 1 , 1 , 1 , 1 } ; int six_pyramid [ ] = { 1 , 1 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 9 ; i ++ ) nine_pyramid [ i ] = convolve ( nine_pyramid , PYRAMIDAL_DIE_PDF ) ; int six_cubes [ ] = { 1 , 1 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 6 ; i ++ ) six_cubes [ i ] = convolve ( six_cubes , CUBIC_DIE_PDF ) ; double ans = 0 ; for ( int i = 0 ; i < nine_pyramid . length ; i ++ ) ans += nine_pyramid [ i ] * six_cubes [ i ] ; ans /= ( double ) ( nine_pyramid [ nine_pyramid . length - 1 ] * six_cubes [ six_cubes . length - 1 ] ) ; return String . format ( " % .7f " , ans ) ; } private static double convolve ( int a [ ] , int b [ ] ) { int c [ ] = new int [ a . length + b . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) for ( int j = 0 ; j < b . length ; j ++ ) c [ i + j ] += a [ i ] * b [ j ] ; return c ; } }
import java . io . * ; public class GFG { public static void main ( String [ ] args ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; } }
import java . io . * ; public class GFG { static int solve ( int M , int N , int s ) { if ( N % s == 0 ) N = N / s ; else N = ( N / s ) + 1 ; if ( M % s == 0 ) M = M / s ; else M = ( M / s ) + 1 ; return M * N ; } public static void main ( String [ ] args ) { int N = 12 , M = 13 , s = 4 ; System . out . println ( solve ( M , N , s ) ) ; } }
public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . util . * ; public class JavaApplication75 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > arr = new ArrayList < > ( ) ; int sum = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { arr . add ( sc . nextInt ( ) ) ; sum += arr . get ( i ) ; } if ( sum == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static int _popcnt32 ( int number ) { int counter = 0 ; while ( number > 0 ) { if ( number % 2 == 1 ) counter ++ ; number /= 2 ; } return counter ; } static int maximize ( int a ) { int n = _popcnt32 ( a ) ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res = res | ( 1 << ( 32 - i ) ) ; return Math . abs ( res ) ; } public static void main ( String [ ] args ) { int a = 1 ; System . out . println ( maximize ( a ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ i ] <= k ) { count ++ ; } } System . out . println ( count ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int count = 0 ; while ( a > 0 && b > 0 ) { if ( a > 1 && b > 1 ) { a -- ; b -- ; } else { if ( a == 1 && b == 1 ) { count ++ ; } else { count ++ ; b ++ ; } } } System . out . println ( count ) ; } }
import java . util . * ; public class Solution { public List < Integer > xorQueries ( int [ ] [ ] arr , int [ ] queries ) { int [ ] pref = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) pref [ i ] = ( arr [ i ] [ i ] ^ pref [ arr . length - 1 ] ) ; List < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < queries . length ; i ++ ) ans . add ( pref [ r + 1 ] ^ pref [ l ] ) ; return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] [ ] arr = { 1 , 3 , 4 , 8 } ; int [ ] [ ] queries = { { 0 , 1 } , { 1 , 2 } , { 0 , 3 } , { 3 , 3 } } ; List < Integer > out = sObj . xorQueries ( arr , queries ) ; System . out . println ( Arrays . toString ( out ) ) ; } }
import java . util . * ; public class GFG { static String encodedChar ( String str , int k ) { String expand = " " ; int freq = 0 ; int i = 0 ; while ( i < str . length ( ) ) { String temp = " " ; freq = 0 ; while ( i < str . length ( ) && str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + ( str . charAt ( i ) - '0' ) ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) { expand += temp ; } } if ( freq == 0 ) { expand += temp ; } return expand . substring ( k - 1 ) ; } public static void main ( String [ ] args ) { String str = " ab4c12ed3" ; int k = 21 ; System . out . println ( encodedChar ( str , k ) ) ; } }
public class GFG { static void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 || a + b < c ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ; } }
import java . io . * ; public class GFG { static int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = ( n + 1 ) % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . println ( summation ( N ) ) ; } }
import java . util . Arrays ; public class GFG { static void sortSquare ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; Arrays . sort ( arr ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 6 , - 3 , - 1 , 2 , 4 , 5 } ; int n = arr . length ; System . out . print ( " Before ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; sortSquare ( arr , n ) ; System . out . print ( " After ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . Scanner ; public class Bulbs { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int i = 0 ; while ( i < n - 1 ) { if ( arr [ i ] + arr [ i + 1 ] > t ) { System . out . println ( " NO " ) ; return ; } i ++ ; } if ( i == n - 1 ) { System . out . println ( " YES " ) ; } else { i ++ ; while ( i < n - 1 && arr [ i ] + arr [ i + 1 ] == t ) { i ++ ; } if ( i == n - 1 ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] dp = new int [ n ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] == 0 ) { continue ; } dp [ i ] = 1 ; count ++ ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == i ) { dp [ j ] = 2 ; continue ; } if ( j == i ) { dp [ j ] = 1 ; count ++ ; } else { if ( dp [ j ] == 1 ) { dp [ j ] = 2 ; count ++ ; } else { dp [ j ] = 1 ; count = 0 ; break ; } } } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; int root1 = ( int ) Math . floor ( Math . sqrt ( d ) ) / ( 2 * a ) ; int root2 = ( int ) Math . floor ( Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 55 ; if ( isTriangular ( n ) ) System . out . println ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) ; else System . out . println ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) ; } }
import java . io . * ; public class GFG { static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( - 1 ) ; else { System . out . print ( d ) ; k -- ; while ( k > 1 ) System . out . print ( 0 ) ; } } public static void main ( String [ ] args ) { int k = 4 , d = 4 ; printNumberWithDR ( k , d ) ; } }
import java . io . * ; public class GFG { static int N = 3 ; static void rotateMatrix ( int mat [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; rotateMatrix ( mat ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; if ( n % 500 == 0 ) { System . out . println ( n ) ; } else { System . out . println ( ( n / 500 ) * 500 ) ; } } }
import java . io . * ; public class GFG { static int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } public static void main ( String [ ] args ) { int n = 4513 ; System . out . println ( getProduct ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc ; static final int INF = 1 << 28 ; static final double EPS = 1e-9 ; void run ( ) { sc = new Scanner ( System . in ) ; for ( ; ; ) { int b = sc . nextInt ( ) , r = sc . nextInt ( ) , g = sc . nextInt ( ) , c = sc . nextInt ( ) , s = sc . nextInt ( ) , t = sc . nextInt ( ) ; if ( ( b | r | g | c | s | t ) == 0 ) break ; int sum = 0 ; for ( int i = t ; i > 0 ; i -- ) { sum += b * 5 + r * 3 * 5 ; } println ( " " + sum + " " ) ; } sc . close ( ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] c = new int [ n ] ; int [ ] d = new int [ n ] ; long MOD = 1000000007 ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = sc . nextInt ( ) ; d [ i ] = 0 ; } long ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = c [ i ] ; long count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) count = ( d [ i ] + c [ j ] ) % MOD ; else count = ( count + ( c [ j - 1 ] - x ) ) % MOD ; } ans = ( ans * count ) % MOD ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static double PI = 3.14159265 ; static double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } public static void main ( String [ ] args ) { double r = 7 ; System . out . println ( length_rope ( r ) ) ; } }
public class GFG { static int reverseDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int isPalindrome ( int n ) { int rev_n = reverseDigits ( n ) ; if ( rev_n == n ) return 1 ; else return 0 ; } public static void main ( String [ ] args ) { int n = 4562 ; if ( isPalindrome ( n ) == 1 ) System . out . println ( " Is ▁ " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + 1 ) ; else System . out . println ( " Is ▁ " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + 0 ) ; n = 2002 ; if ( isPalindrome ( n ) == 1 ) System . out . println ( " Is ▁ " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + 1 ) ; else System . out . println ( " Is ▁ " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + 1 ) ; } }
import java . util . * ; public class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder res = new StringBuilder ( ) ; int pos1 = num1 . length ( ) - 1 ; int pos2 = num2 . length ( ) - 1 ; int carry = 0 ; while ( pos1 >= 0 || pos2 >= 0 || carry == 1 ) { int digit1 = 0 ; int digit2 = 0 ; if ( pos1 >= 0 ) digit1 = num1 . charAt ( pos1 ) - '0' ; if ( pos2 >= 0 ) digit2 = num2 . charAt ( pos2 ) - '0' ; res . append ( ( digit1 + digit2 + carry ) % 10 ) ; carry = ( digit1 + digit2 + carry ) / 10 ; pos1 -- ; pos2 -- ; } return res . toString ( ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String num1 = "11" ; String num2 = "123" ; String out = sObj . addStrings ( num1 , num2 ) ; System . out . println ( out ) ; } }
import java . io . * ; public class GFG { static boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) sum = sum + i + n / i ; } return ( sum == n && n != 1 ) ; } public static void main ( String [ ] args ) { System . out . println ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) ; int n = 2 ; for ( n = 2 ; n < 10000 ; n ++ ) { if ( isPerfect ( n ) ) System . out . println ( n + " ▁ is ▁ a ▁ perfect ▁ number " ) ; } } }
import java . io . * ; public class GFG { static boolean isPower ( int n ) { if ( n <= 1 ) return true ; for ( int x = 2 ; x * x <= n ; x ++ ) { int p = x ; while ( p <= n ) { p = p * x ; if ( p == n ) return true ; } } return false ; } public static void main ( String [ ] args ) { for ( int i = 2 ; i <= 100 ; i ++ ) if ( isPower ( i ) ) System . out . print ( i + " ▁ " ) ; } }
import java . io . * ; public class GFG { static boolean isPower ( int n ) { if ( n == 1 ) return true ; for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int y = 2 ; int p = ( int ) ( Math . pow ( x , y ) ) ; while ( p <= n && p > 0 ) { if ( p == n ) return true ; y = y + 1 ; p = Math . pow ( x , y ) ; } } return false ; } public static void main ( String [ ] args ) { for ( int i = 2 ; i <= 100 ; i ++ ) { if ( isPower ( i ) ) System . out . print ( i + " ▁ " ) ; } } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void findTwoNumbers ( int sum , int gcd ) { if ( gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) { System . out . println ( " a ▁ = ▁ " + Math . min ( gcd , sum - gcd ) + " , ▁ b ▁ = ▁ " + ( sum - Math . min ( gcd , sum - gcd ) ) ) ; } else System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { int sum = 8 , gcd = 2 ; findTwoNumbers ( sum , gcd ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int rb = sc . nextInt ( ) ; int cb = sc . nextInt ( ) ; int rd = sc . nextInt ( ) ; int cd = sc . nextInt ( ) ; int count = 0 ; while ( true ) { int x = 1 ; int y = 1 ; while ( x <= n ) { x = x * - 1 ; } while ( y <= m ) { y = y * - 1 ; } count ++ ; x = x + y ; y = y + rd ; } System . out . println ( count ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long c = sc . nextLong ( ) ; long d = sc . nextLong ( ) ; long x = 0 ; if ( a < b ) x = a ; else if ( b < d ) x = d ; else if ( c < d ) y = c ; else y = d ; if ( x < y ) System . out . println ( x ) ; else System . out . println ( y ) ; } }
import java . util . * ; public class GFG { static int totalPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = Integer . bitCount ( arr [ i ] ) ; if ( m . containsKey ( x ) ) m . put ( x , m . get ( x ) + 1 ) ; else m . put ( x , 1 ) ; } int result = 0 ; for ( Map . Entry < Integer , Integer > it : m . entrySet ( ) ) { result += ( it . getValue ( ) * ( it . getValue ( ) - 1 ) ) / 2 ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 5 , 3 , 9 , 1 , 2 } ; int n = arr . length ; System . out . println ( totalPairs ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; n = 12 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int q = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int ans = 0 ; int m = 0 ; if ( n % 2 == 0 ) { m = ( n / 2 ) * 4 ; ans += ( m ) * Math . min ( s * 2 , h ) ; } else { m = ( n / 2 ) * 4 ; ans += Math . min ( s * 2 , h ) * Math . min ( 8 , s ) ; } if ( n % 2 == 1 ) { m = ( n / 2 ) * 2 ; ans += ( m ) * Math . min ( 8 , d ) ; ans += ( m * Math . min ( 2 , s ) ) * Math . min ( 2 , d ) ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int countNumbers ( int L , int R , int K ) { if ( K == 9 ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i - rem > 0 ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int L = 10 , R = 22 , K = 3 ; System . out . println ( countNumbers ( L , R , K ) ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int f = sc . nextInt ( ) ; int ans = 0 ; if ( a > f ) { ans = e ; a -- ; } else { if ( b > a ) { ans = b ; b -- ; a -- ; } else { ans = a ; a -- ; } } else { if ( c > b ) { ans = c * e ; c -- ; b -- ; } else { ans = d ; c ++ ; b -- ; } } if ( c > b ) { ans = e ; e = f ; f = b ; } else { ans = d ; e = f ; f = a ; } System . out . println ( ans ) ; } }
import java . util . Arrays ; public class Solution { public int solve ( int [ ] A ) { int ans = 2 ; int n = A . length ; if ( n <= 2 ) return n ; int [ ] llap = new int [ n ] ; Arrays . sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . max ( llap [ j ] , llap [ j ] + 1 ) ; ans = Math . max ( ans , llap [ j ] ) ; i -- ; k ++ ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k ++ ; else i -- ; } } return ans ; } public static void main ( String [ ] args ) { Solution obj = new Solution ( ) ; int [ ] a = { 9 , 4 , 7 , 2 , 10 } ; int [ ] n = new int [ ] { a , 2 , 7 , 2 , 10 } ; System . out . println ( obj . solve ( n ) ) ; } }
import java . util . * ; public class GFG { static int minimumChanges ( int arr [ ] , int n , int d ) { int maxFreq = Integer . MIN_VALUE ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a0 = arr [ i ] - i * d ; if ( freq . containsKey ( a0 ) ) { freq . put ( a0 , freq . get ( a0 ) + 1 ) ; } else { freq . put ( a0 , 1 ) ; } if ( freq . get ( a0 ) > maxFreq ) maxFreq = freq . get ( a0 ) ; } return ( n - maxFreq ) ; } public static void main ( String [ ] args ) { int n = 5 ; int d = 1 ; int arr [ ] = { 1 , 3 , 3 , 4 , 6 } ; int ans = minimumChanges ( arr , n , d ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; ArrayList < Pair > a = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( new Pair ( sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) ) ) ; } Collections . sort ( a ) ; int min = a . get ( 0 ) . b ; for ( int i = 1 ; i < n ; i ++ ) { if ( a . get ( i ) . a >= a . get ( i - 1 ) . a && a . get ( i ) . b >= a . get ( i - 1 ) . b ) { min = Math . min ( min , i ) ; } } System . out . println ( min + 1 ) ; } } class Pair implements Comparable < Pair > { int a , b , c ; public Pair ( int a , int b , int c ) { this . a = a ; this . b = b ; this . c = c ; } @ Override public int compareTo ( Pair p ) { if ( this . a != p . a ) return this . a - p . a ; return this . b - p . b ; } }
import java . util . * ; public class GFG { static int countPoints ( int n , int m , int a [ ] , int b [ ] , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m && a [ i ] + y < b [ j ] ) { if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; } public static void main ( String [ ] args ) { int x = 1 , y = 4 ; int a [ ] = { 1 , 5 } ; int n = a . length ; int b [ ] = { 1 , 1 , 2 } ; int m = b . length ; System . out . println ( countPoints ( n , m , a , b , x , y ) ) ; } }
import java . io . * ; public class GFG { static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; } public static void main ( String [ ] args ) { int x = 4 ; System . out . println ( multiplyWith3Point5 ( x ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int left = 0 ; int right = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { left += arr [ i ] - arr [ i ] ; if ( left < s ) { System . out . println ( - 1 ) ; return ; } else { right = Math . min ( right , left + 1 ) ; } } System . out . println ( right - min ) ; } }
public class GFG { static int longestSubstring ( String s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) { cnt ++ ; } else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; } public static void main ( String [ ] args ) { String s = " ccccdeededff " ; System . out . println ( longestSubstring ( s ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int n = k ; int [ ] a = new int [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) { a [ i ] = ( k / 50 ) + ( k % 50 ) ; } int b = k / 50 ; int c = ( k - b * 50 ) / 50 ; int d = k - b * 50 ; System . out . println ( d + c ) ; for ( int i = 0 ; i < d ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } } }
import java . io . * ; public class GFG { static int zeroUpto ( int digits ) { int first = ( ( int ) ( Math . pow ( 10 , digits ) - 1 ) / 9 ) ; int second = ( int ) ( Math . pow ( 9 , digits ) - 1 ) / 8 ; return 9 * ( first - second ) ; } static int countZero ( String num ) { int k = num . length ( ) ; int total = zeroUpto ( k - 1 ) ; int non_zero = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { if ( num . charAt ( i ) == '0' ) { non_zero -- ; break ; } non_zero += ( ( num . charAt ( i ) - '0' ) - 1 ) * ( Math . pow ( 9 , k - 1 - i ) ) ; } int no = 0 , remaining = 0 , calculatedUpto = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { no = no * 10 + ( num . charAt ( i ) - '0' ) ; if ( i != 0 ) calculatedUpto = calculatedUpto * 10 + 9 ; } remaining = no - calculatedUpto ; int ans = zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) ; return ans ; } public static void main ( String [ ] args ) { String num = "107" ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + num + " ▁ is ▁ " + countZero ( num ) ) ; num = "1264" ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + num + " ▁ is ▁ " + countZero ( num ) ) ; } }
import java . io . * ; public class GFG { static float cone ( float a ) { if ( a < 0 ) return - 1 ; float r = ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * Math . pow ( r , 2 ) * h ; return V ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( cone ( a ) ) ; } }
public class GFG { static boolean Prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n + 1 ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static boolean checkSumPrime ( String str ) { int sum = 0 ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) sum += Math . abs ( str . charAt ( i - 1 ) - str . charAt ( i ) ) ; if ( Prime ( sum ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int num = 142 ; String s = String . valueOf ( num ) ; if ( checkSumPrime ( s ) ) System . out . println ( " Prime " ) ; else System . out . println ( " Not ▁ Prime " ) ; } }
public class Main { public static double sum ( int n ) { if ( n < 2 ) { return 1 ; } else { return 1.0 / n + sum ( n - 1 ) ; } } public static void main ( String [ ] args ) { System . out . printf ( " % .3f \n " , sum ( 8 ) ) ; System . out . printf ( " % .3f \n " , sum ( 10 ) ) ; } }
public class GFG { static int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int p [ ] = { 2 , 5 , 1 , 3 , 4 } ; int n = p . length ; System . out . println ( countElements ( p , n ) ) ; } }
import java . util . * ; import java . io . * ; public class A_602 { public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; if ( s . charAt ( 0 ) == t . charAt ( 1 ) ) out . println ( " = " ) ; else if ( s . charAt ( 0 ) > t . charAt ( 1 ) ) out . println ( " > " ) ; else out . println ( " < " ) ; out . close ( ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . io . * ; public class GFG { static float findVolume ( float l , float b , float h ) { return ( ( l * b * h ) / 2 ) ; } public static void main ( String [ ] args ) { float l = 18 , b = 12 , h = 9 ; System . out . print ( " Volume ▁ of ▁ triangular ▁ prism : ▁ " + findVolume ( l , b , h ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; String s = sc . next ( ) ; char [ ] arr = s . toCharArray ( ) ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == ' A ' ) count ++ ; } int ans = 0 ; int count2 = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) { count2 ++ ; k -= arr [ i ] ; ans += count2 * count ; count = 0 ; } else if ( k < arr [ i ] ) count ++ ; } System . out . println ( ans ) ; } }
public final class p028 { public static void main ( String [ ] args ) { System . out . println ( new p028 ( ) . run ( ) ) ; } public String run ( ) { int i = 286 ; int j = 166 ; int k = 144 ; while ( true ) { int triangle = i * ( i + 1 ) / 2 ; int pentagon = j * ( j * 3 - 1 ) / 2 ; int hexagon = k * ( k * 2 - 1 ) ; if ( minimum == Math . max ( triangle , pentagon , hexagon ) ) return Integer . toString ( triangle ) ; if ( minimum == triangle ) i ++ ; if ( minimum == pentagon ) j ++ ; if ( minimum == hexagon ) k ++ ; } } }
import java . util . * ; public class GFG { static int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; boolean arr [ ] = new boolean [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == true ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = false ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; } public static void main ( String [ ] args ) { int N = 500 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . lang . Math ; public class Main { public static void main ( String [ ] args ) { List < Integer > arr = Arrays . asList ( 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ) ; int N = arr . size ( ) ; if ( checkDivisors ( arr , N ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static boolean checkDivisors ( List < Integer > a , int n ) { int X = Integer . MIN_VALUE ; for ( int num : a ) { X = Math . max ( X , num ) ; } List < Integer > b = new ArrayList < > ( ) ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { b . add ( i ) ; if ( X / i != i ) { b . add ( X / i ) ; } } } if ( b . size ( ) != n ) { return false ; } Integer [ ] arrA = a . toArray ( new Integer [ a . size ( ) ] ) ; Integer [ ] arrB = b . toArray ( new Integer [ b . size ( ) ] ) ; Arrays . sort ( arrA ) ; Arrays . sort ( arrB ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arrB [ i ] != arrA [ i ] ) { return false ; } } return true ; } }
import java . io . * ; public class GFG { static void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; System . out . println ( ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( " All ▁ Non - empty ▁ Subarrays " ) ; subArray ( arr , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; if ( n % 2 == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( n / 2 + " ▁ " + ( n / 4 ) ) ; } } } }
import java . util . Arrays ; public class GFG { static int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * i ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 6 , 1 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int maxSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) sum += a [ i ] ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 1 , 4 , 5 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int findAnswer ( int n , int arr [ ] ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 53 , 28 , 143 , 5 } ; int n = arr . length ; System . out . println ( findAnswer ( n , arr ) ) ; } }
import java . util . * ; public class GFG { static int findSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) sum += arr [ i + 1 ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( findSum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static class Node { int data ; Node left , right ; Node ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } static Node getDeepestLeftLeafNode ( Node root ) { if ( root == null ) return null ; Queue < Node > q = new LinkedList < Node > ( ) ; q . add ( root ) ; int result = null ; while ( q . size ( ) > 0 ) { Node temp = q . peek ( ) ; q . remove ( ) ; if ( temp != null ) { q . add ( temp ) ; if ( ! temp . left . left && ! temp . left . right ) result = temp . left ; } if ( temp . right != null ) { q . add ( temp . right ) ; } } return result ; } public static void main ( String [ ] args ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . left . Left = new Node ( 4 ) ; root . right . right = new Node ( 6 ) ; root . right . left . right = new Node ( 7 ) ; root . right . right . right = new Node ( 8 ) ; root . right . left . right . left = new Node ( 9 ) ; root . right . right . right . right = new Node ( 10 ) ; Node result = getDeepestLeftLeafNode ( root ) ; if ( result != null ) System . out . println ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : ▁ " + result . data ) ; else System . out . println ( " No ▁ result , ▁ Left ▁ leaf ▁ not ▁ found " ) ; } }
import java . util . * ; public class GFG { static class Node { int data ; Node left , right ; Node ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } static Node getDeepestRightLeafNode ( Node root ) { if ( root == null ) return null ; Queue < Node > q = new LinkedList < Node > ( ) ; q . add ( root ) ; int result = null ; while ( q . size ( ) > 0 ) { Node temp = q . peek ( ) ; q . remove ( ) ; if ( temp . left != null ) q . add ( temp . left ) ; if ( temp . right != null ) { q . add ( temp . right ) ; if ( temp . right . left == null && temp . right . right == null ) result = temp . right ; } } return result ; } public static void main ( String args [ ] ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . left . right = new Node ( 4 ) ; root . right . left = new Node ( 5 ) ; root . right . right = new Node ( 6 ) ; root . right . left . right = new Node ( 7 ) ; root . right . right . right = new Node ( 8 ) ; root . right . left . right . left = new Node ( 9 ) ; root . right . right . right . right = new Node ( 10 ) ; Node result = getDeepestRightLeafNode ( root ) ; if ( result != null ) System . out . println ( " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : ▁ " + result . data ) ; else System . out . println ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found " ) ; } }
import java . util . Scanner ; public class Fibonacci { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int a = 2 ; int b = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int old_a = a ; a = b ; b = old_a + b ; } System . out . println ( b ) ; } }
import java . io . * ; public class GFG { static void printRatio ( int a , int b , int c , int d ) { if ( b * c > a * d ) { swap ( c , d ) ; swap ( a , b ) ; } int lcm = ( a * c ) / __gcd ( a , c ) ; int x = lcm / a ; int y = lcm / c ; d = d * y ; int k = __gcd ( b , d ) ; b = b / k ; d = d / k ; System . out . print ( b + " : ▁ " + d ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 4 , b = 3 , c = 2 , d = 2 ; printRatio ( a , b , c , d ) ; } }
import java . io . * ; public class GFG { static int maxsum_SIS ( int arr [ ] , int n ) { int max_sum = 0 ; int current_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] ) current_sum += arr [ i ] ; else max_sum = Math . max ( max_sum , current_sum ) ; current_sum = arr [ i ] ; } return Math . max ( max_sum , current_sum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 4 } ; int n = arr . length ; System . out . println ( " Maximum ▁ sum ▁ : ▁ " + maxsum_SIS ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static int findMaxSumUtil ( int arr [ ] , int n ) { int finalGCD = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) finalGCD = GCD ( arr [ i ] , finalGCD ) ; return finalGCD ; } static int findMaxSum ( int arr [ ] , int n ) { int maxElement = findMaxSumUtil ( arr , n ) ; return ( maxElement * n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 20 , 12 , 36 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } static int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; } public static void main ( String [ ] args ) { int a = 20 , b = 52 , x = 5 , y = 7 ; System . out . println ( findMinDiff ( a , b , x , y ) ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dx = sc . nextInt ( ) ; int dy = sc . nextInt ( ) ; if ( dx > x - w && dy > y - h && dx < x - w && dy < y - h ) { count ++ ; } } System . out . println ( count ) ; } } }
import java . io . * ; public class GFG { static boolean divisibleby37 ( String n ) { int l = n . length ( ) ; if ( n == 0 ) return true ; if ( l % 3 == 1 ) n += "00" ; l += 2 ; else if ( l % 3 == 2 ) n += "0" + n ; int gSum = 0 ; while ( l != 0 ) { int group = n . charAt ( l - 3 ) - '0' ; gSum += group ; l -- ; } if ( gSum >= 1000 ) return ( divisibleby37 ( gSum ) ) ; else return ( gSum % 37 == 0 ) ; } public static void main ( String [ ] args ) { System . out . println ( divisibleby37 ( "8955795758" ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) , x = sc . nextInt ( ) , y = sc . nextInt ( ) ; if ( y <= n - 1 || ( y - n + 1 ) <= x ) { pw . println ( - 1 ) ; } else { pw . println ( 1 ) ; int res = 1 ; for ( int i = y - n + 1 ; i <= n ; i ++ ) { if ( res <= x ) { res ++ ; } else { pw . println ( 1 ) ; } } pw . close ( ) ; } pw . close ( ) ; } }
public class Main { public static void main ( String [ ] args ) { String X = " ef " ; String Y = " gh " ; System . out . print ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ identical ▁ is ▁ = ▁ " + findMinCost ( X , Y , 10 , 20 ) ) ; } public static int lcs ( String X , String Y , int m , int n ) { int [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } return L [ m ] [ n ] ; } public static int findMinCost ( String X , String Y , int costX , int costY ) { int m = X . length ( ) ; int n = Y . length ( ) ; int len_LCS = lcs ( X , Y , m , n ) ; return ( costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ) ; } }
import java . io . * ; public class GFG { static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; } public static void main ( String [ ] args ) { int base = 8 ; System . out . println ( numberOfSquares ( base ) ) ; } }
import java . io . * ; public class GFG { static double rmsValue ( int arr [ ] , int n ) { double square = 0 , mean = 0.0 ; double root = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) square += ( arr [ i ] * arr [ i ] ) ; mean = ( square / ( double ) n ) ; root = Math . sqrt ( mean ) ; return root ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 4 , 6 , 8 } ; int n = arr . length ; System . out . println ( rmsValue ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] p = new int [ m ] ; int [ ] c = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { p [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = sc . nextInt ( ) ; } int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) Arrays . fill ( dp [ i ] , Integer . MAX_VALUE ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) Arrays . sort ( p ) ; int ans = 0 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j + c [ i ] <= m ) sum += p [ j + c [ i ] ] ; else sum += p [ j + c [ i ] ] ; } dp [ i ] [ j ] = sum ; } for ( int i = m ; i > 0 ; i -- ) { dp [ i ] [ m ] = Math . min ( dp [ i ] [ m ] , sum - dp [ i - 1 ] [ m ] ) ; } for ( int i = m ; i > 0 ; i -- ) ans = Math . max ( ans , dp [ i ] [ m ] ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; Node [ ] nodes = new Node [ n ] ; for ( int i = 0 ; i < n ; i ++ ) nodes [ i ] = new Node ( i ) ; for ( int i = 0 ; i < n ; i ++ ) { int index = sc . nextInt ( ) - 1 ; nodes [ index ] = new Node ( i + 1 , nodes [ index ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " node ▁ " + nodes [ i ] . index + " : ▁ " ) ; System . out . print ( " parent ▁ key ▁ = ▁ " + nodes [ index ] . index + " , ▁ " ) ; if ( nodes [ index ] . left != null ) nodes [ index ] . left . print ( " , ▁ " ) ; nodes [ index ] . right = new Node ( nodes [ index ] . left , nodes [ index ] . right ) ; System . out . print ( " node ▁ " + nodes [ index ] . index + " : ▁ parent ▁ key ▁ = ▁ " + nodes [ index ] . left ) ; System . out . print ( " left ▁ key ▁ = ▁ " ) ; if ( nodes [ index ] . right != null ) nodes [ index ] . right . print ( " , ▁ " ) ; System . out . print ( nodes [ index ] . index + " : ▁ " ) ; System . out . print ( nodes [ index ] . index + " : ▁ " ) ; if ( nodes [ index ] . left != null ) nodes [ index ] . left . print ( " , ▁ " ) ; if ( nodes [ index ] . right != null ) nodes [ index ] . right . print ( " , ▁ " ) ; System . out . print ( nodes [ index ] . index + " : ▁ " ) ; } } static class Node { int index ; Node left ; Node right ; } }
public class GFG { static int n = 6 , m = 6 ; static void maxSum ( int arr [ ] [ ] ) { int dp [ ] [ ] = new int [ n + 1 ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( j / ( m / 3 ) ) == 0 ) m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; else if ( ( j / ( m / 3 ) ) == 1 ) m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; else if ( ( j / ( m / 3 ) ) == 2 ) m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } } System . out . println ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; int maxSum = maxSum ( arr ) ; } }
import java . util . * ; public class GFG { static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 || y5 > y6 ) { System . out . print ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 0 ; int x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 ; int x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } }
import java . util . * ; public class Hamster939B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int x = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' X ' ) x ++ ; else sum += 1 ; } if ( x == 0 ) { System . out . println ( 0 ) ; System . out . println ( s ) ; return ; } int i = n - x ; if ( sum % 2 == 0 ) { System . out . println ( sum / 2 ) ; for ( int j = 0 ; j < i ; j ++ ) { if ( s . charAt ( j ) == ' X ' ) { s . delete ( j ) ; x -- ; } else { System . out . print ( s . charAt ( j ) ) ; } } } else { System . out . println ( sum / 2 ) ; for ( int j = i + 1 ; j < n ; j ++ ) { System . out . print ( ' X ' ) ; } for ( int j = i + 1 ; j < n ; j ++ ) { System . out . print ( s . charAt ( j ) ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int p = d ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = p * 5 + d ; int y = ( p + d ) / 5 ; int z = ( x + y ) % min ; if ( z > min ) { min = z ; } p = p + y ; } System . out . println ( n - min ) ; } }
import java . io . * ; public class GFG { static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int maxratio = Integer . MIN_VALUE , maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; } public static void main ( String [ ] args ) { int val [ ] = { 14 , 27 , 44 , 19 } ; int wt [ ] = { 6 , 7 , 9 , 8 } ; int n = val . length ; int W = 50 ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
import java . util . * ; public class GFG { static void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { v1 . add ( arr [ i ] ) ; } else { v2 . add ( arr [ i ] ) ; } } int index = 0 , j = 0 , flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 . get ( i ) ; flag = ~ flag ; } else { arr [ index ++ ] = v2 . get ( j ) ; flag = ~ flag ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 8 , 13 , 2 , 19 , 14 } ; int n = arr . length ; AlternateRearrange ( arr , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a <= c && b >= c ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
public class Main { public static String decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } String binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binary += Integer . toString ( binaryNum [ j ] ) ; } return binary ; } public static int countFreq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j = 0 ; while ( j < M ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } j ++ ; } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } public static void findOccurrence ( int [ ] arr , int n , String pattern ) { for ( int i = 0 ; i < n ; i ++ ) { String binary = decToBinary ( arr [ i ] ) ; System . out . print ( countFreq ( pattern , binary ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 106 , 7 , 8 } ; String pattern = "10" ; int n = arr . length ; findOccurrence ( arr , n , pattern ) ; } }
import java . io . * ; public class GFG { static void makearrayequal ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) x += arr [ i ] & 1 ; System . out . println ( Math . min ( x , n - x ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 2 , 1 } ; int n = arr . length ; makearrayequal ( arr , n ) ; } }
import java . util . * ; public class Solution { public int [ ] findKthLargest ( int [ ] nums , int k ) { Arrays . shuffle ( nums ) ; return quickSelection ( nums , 0 , nums . length - 1 , nums . length - k ) ; } public int quickSelection ( int [ ] nums , int start , int end , int k ) { if ( start > end ) return Integer . MAX_VALUE ; int pivot = nums [ end ] ; int left = start ; for ( int i = start ; i < end ; i ++ ) { if ( nums [ i ] <= pivot ) { int temp = nums [ left ] ; nums [ left ] = nums [ i ] ; nums [ i ] = temp ; left ++ ; } } swap ( nums , left , nums . length - 1 ) ; swap ( nums , end , nums . length - 1 , nums . length - 1 ) ; if ( left == k ) return nums [ left ] ; else if ( left < k ) return quickSelection ( nums , left + 1 , end , k ) ; else return quickSelection ( nums , start , left - 1 , k ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 3 , 2 , 1 , 5 , 6 , 4 } ; int k = 2 ; int [ ] out = sObj . findKthLargest ( nums , k ) ; System . out . println ( out ) ; } private static void swap ( int [ ] nums , int i , int j ) { int temp = nums [ j ] ; nums [ j ] = nums [ i ] ; nums [ i ] = temp ; } }
import java . io . * ; public class GFG { static String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) return " YES " ; n /= 10 ; } return " NO " ; } public static void main ( String [ ] args ) { int n = 9876543 ; System . out . println ( isDivisible ( n ) ) ; } }
import java . io . * ; public class GFG { static String isDivisible ( int n ) { int temp = n , sum = 0 ; while ( n > 0 ) { int k = n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; } public static void main ( String [ ] args ) { int n = 123 ; System . out . println ( isDivisible ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( a > b ) System . out . println ( " GREATER " ) ; else if ( a < b ) System . out . println ( " LESS " ) ; else System . out . println ( " EQUAL " ) ; } }
import java . io . * ; public class GFG { static int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) ; int area = ( totalSquares * size * size ) ; totalArea += area ; size ++ ; } return totalArea ; } public static void main ( String [ ] args ) { int l = 4 , b = 3 ; System . out . println ( calculateAreaSum ( l , b ) ) ; } }
import java . io . * ; public class GFG { static void arrange ( int N ) { if ( N == 1 ) { System . out . print ( "1 ▁ " ) ; return ; } if ( N == 2 || N == 3 ) { System . out . print ( " - 1 ▁ " ) ; return ; } int even = - 1 , odd = - 1 ; if ( N % 2 == 0 ) { even = N ; odd = N - 1 ; } else { odd = N ; even = N - 1 ; } while ( odd >= 1 ) { System . out . print ( odd + " ▁ " ) ; odd = odd - 2 ; } while ( even >= 2 ) { System . out . print ( even + " ▁ " ) ; even = even - 2 ; } } } public static void main ( String [ ] args ) { int N = 5 ; arrange ( N ) ; } }
import java . io . * ; public class GFG { static int findMinEqualSums ( int a [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + a [ i ] ; int sum1 = 0 , sum2 = 0 , min = Integer . MAX_VALUE ; for ( int i = 0 ; i < N - 1 ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) min = Math . abs ( sum1 - sum2 ) ; } return min ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 5 , 7 , 8 } ; int N = a . length ; System . out . println ( findMinEqualSums ( a , N ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int n = sc . nextInt ( ) ; System . out . println ( solve ( n ) ) ; } sc . close ( ) ; } static String solve ( int n ) { StringBuilder sb = new StringBuilder ( n ) ; int firstIndex = 0 ; for ( int digit = 1 ; digit <= 3 ; ++ digit ) { if ( digit <= 1 ) { sb . append ( firstIndex ) ; } else { sb . append ( digit ) ; } firstIndex = digit - 1 ; } return sb . toString ( ) ; } }
import java . util . * ; public class GFG { static int findOptimalSolution ( int a [ ] , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) points += a [ i ] * i ; return points ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 2 , 3 , 9 } ; int N = a . length ; System . out . println ( findOptimalSolution ( a , N ) ) ; } }
import java . util . * ; public class JavaApplication75 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > arrNum = new ArrayList < > ( ) ; ArrayList < Integer > arrPrice = new ArrayList < > ( ) ; ArrayList < Integer > arrPricePrice = new ArrayList < > ( ) ; ArrayList < Integer > arrPricePrice2 = new ArrayList < > ( ) ; ArrayList < Integer > arrPrice2 = new ArrayList < > ( ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int sleeptimerest = 0 , sleeptime = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arrNum . add ( sc . nextInt ( ) ) ; arrPrice . add ( sc . nextInt ( ) ) ; } while ( arrPrice . size ( ) <= k ) { arrPrice . add ( arrPrice . get ( 0 ) ) ; sleeptimerest = arrPrice . get ( 0 ) ; arrPrice2 . add ( arrPrice . get ( 1 ) ) ; if ( arrPrice . size ( ) == k && arrPrice . get ( 0 ) > 0 && arrPrice . get ( 1 ) > 0 ) { System . out . print ( " - 1" ) ; return ; } arrPrice . add ( sleeptimerest + arrPrice . get ( 0 ) ) ; arrPricePrice . set ( 0 , arrPrice . get ( 0 ) ) ; sleeptimerest -- ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arrPrice . get ( i ) + " ▁ " ) ; } } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { sum = sum + arr [ i ] ; } } if ( sum > m ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . io . * ; public class GFG { static int getPairs ( int a [ ] ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 4 , 3 , 1 } ; System . out . println ( getPairs ( a ) ) ; } }
import java . util . Scanner ; public class B465 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; String S = in . next ( ) ; char [ ] A = S . toCharArray ( ) ; int length = A . length ; boolean ok = true ; for ( int i = 0 ; i < length ; i ++ ) { if ( A [ i ] == '1' ) { ok = false ; break ; } } if ( ok ) { char [ ] B = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { B [ i ] = '0' ; } if ( K == 0 ) { ok = false ; break ; } } for ( int i = 0 ; i < length ; i ++ ) { char c = A [ i ] ; if ( Character . isDigit ( c ) ) { char d = Character . toString ( c ) ; if ( Character . getNumericValue ( d ) == 0 ) { d = '0' ; } else { d ++ ; } } if ( ok ) { for ( int i = 0 ; i < length - K ; i ++ ) { System . out . print ( B [ i ] ) ; } } else { System . out . print ( 0 ) ; } } } }
import java . util . * ; public class JavaApplication75 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int arr [ ] [ ] = new int [ 4 ] [ 3 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { arr [ i ] [ j ] = sc . nextInt ( ) ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( arr [ i ] [ j ] == 1 && arr [ i ] [ i ] == 1 && arr [ i ] [ j ] == 1 ) { System . out . println ( " YES " ) ; return ; } } } System . out . println ( " NO " ) ; } }
public class GFG { static final int MOD = 1000000007 ; static int F [ ] = new int [ N ] ; static void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) { F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; } } public static void main ( String [ ] args ) { int n = 8 ; precompute ( ) ; System . out . println ( F [ n ] ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { int n = in . nextInt ( ) ; if ( n == 0 ) return false ; int cnt = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 2 ; j <= n ; j ++ ) { if ( i * j > n ) break ; while ( i * j > n ) { cnt ++ ; i += j ; } } } out . println ( cnt ) ; return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . io . * ; public class GFG { static int CeilIndex ( int A [ ] , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( A [ m ] >= key ) r = m ; else l = m ; } return r ; } static int LongestIncreasingSubsequenceLength ( int A [ ] , int size ) { int [ ] tailTable = new int [ size + 1 ] ; int len = 0 ; tailTable [ 0 ] = A [ 0 ] ; len = 1 ; for ( int i = 1 ; i < size ; i ++ ) { if ( A [ i ] < tailTable [ 0 ] ) tailTable [ 0 ] = A [ i ] ; else if ( A [ i ] > tailTable [ len - 1 ] ) tailTable [ len ] = A [ i ] ; else if ( A [ i ] > tailTable [ len - 1 ] ) tailTable [ len ] = A [ i ] ; else { tailTable [ CeilIndex ( tailTable , - 1 , len - 1 , A [ i ] ) ] = A [ i ] ; } } return len ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 } ; int n = A . length ; System . out . println ( " Length ▁ of ▁ Longest ▁ Increasing ▁ Subsequence ▁ is ▁ " + LongestIncreasingSubsequenceLength ( A , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = sc . nextInt ( ) ; } int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] <= min ) { min = Math . min ( min , Math . abs ( x [ i ] - min ) ) ; } if ( x [ i ] > max ) { max = x [ i ] ; } } System . out . println ( max - min ) ; } }
import java . math . BigInteger ; import java . util . HashSet ; import java . util . Set ; public final class p076 { public static void main ( String [ ] args ) { System . out . println ( new p076 ( ) . run ( ) ) ; } public String run ( ) { int LIMIT = Library . pow ( 10 , 6 ) ; int sum = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( getChainLength ( i ) == 60 ) sum += 1 ; } return Integer . toString ( sum ) ; } private static int getChainLength ( int n ) { Set < Integer > seen = new HashSet < Integer > ( ) ; while ( true ) { seen . add ( n ) ; n = factorialize ( n ) ; if ( seen . contains ( n ) ) return seen . size ( ) ; } } private static int [ ] factorial ( int n ) { int result = 0 ; while ( n != 0 ) { result += FACTORIAL [ n % 10 ] ; n /= 10 ; } return result ; } }
public class GFG { static int colourVisible ( int height [ ] , int colour [ ] , int K ) { int arr [ ] = new int [ K + 1 ] ; int visible = 0 ; int max = height [ K - 1 ] ; arr [ colour [ K - 1 ] ] = 1 ; for ( int i = K - 2 ; i >= 0 ; i -- ) { if ( height [ i ] > max ) { max = height [ i ] ; arr [ colour [ i ] ] = 1 ; } } for ( int i = 1 ; i <= K ; i ++ ) { if ( arr [ i ] == 1 ) { visible ++ ; } } return visible ; } public static void main ( String [ ] args ) { int height [ ] = { 3 , 5 , 1 , 2 , 3 } ; int colour [ ] = { 1 , 2 , 3 , 4 , 3 } ; int K = colour . length ; System . out . println ( colourVisible ( height , colour , K ) ) ; } }
import java . io . * ; public class GFG { static boolean checkPowerof8 ( int n ) { double i = Math . log ( n , 8 ) ; return ( i - trunc ( i ) < 0.000001 ) ; } public static void main ( String [ ] args ) { int n = 65 ; if ( checkPowerof8 ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int ans = 0 ; if ( a == b ) { ans = ( a + b ) / 4 ; } else { ans = Math . min ( a , b ) ; } if ( a > b ) { ans = ( a + b ) / 4 ; } else { ans = Math . min ( a , b ) ; } System . out . println ( ans ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { int n , m ; n = parseInt ( line . substring ( 0 , line . indexOf ( ' ▁ ' ) ) ) ; m = parseInt ( line . substring ( line . indexOf ( ' ▁ ' ) + 1 ) ) ; if ( ( n | m ) == 0 ) break ; int max = 0 ; for ( int i = 0 ; i < m ; i ++ ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; for ( int j = 1 ; j < n ; j ++ ) { int w = parseInt ( st . nextToken ( ) ) ; max = Math . max ( max , w ) ; } } System . out . println ( max ) ; } } }
import java . util . Scanner ; public class A1405 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; while ( t -- > 0 ) { int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; b [ i ] = scanner . nextInt ( ) ; } int left = - 1 ; int right = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( left == - 1 ) { left = i ; } else { if ( a [ left ] > b [ i ] ) { left = i ; } else { right = i ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > b [ i ] ) { System . out . print ( a [ i ] + " ▁ " ) ; } else { System . out . print ( "0 ▁ " ) ; } } System . out . println ( ) ; } scanner . close ( ) ; } }
import java . util . * ; public class GFG { static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) count [ i ] = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; } public static void main ( String [ ] args ) { int n = 7 , m = 4 ; System . out . println ( " Number ▁ of ▁ ways ▁ = ▁ " + countWays ( n , m ) ) ; } }
import java . io . * ; public class GFG { static void print ( int n ) { System . out . print ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { print ( 3 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; System . out . println ( ( n + 1 ) & - ( n + 1 ) ) ; } }
import java . util . Scanner ; public class B_Code_Parsing { static Scanner in = new Scanner ( System . in ) ; static int n ; static char a [ ] ; public static void main ( String [ ] amit ) { a = in . next ( ) . toCharArray ( ) ; n = a . length ; if ( a [ 0 ] == '0' ) System . out . print ( a [ 0 ] ) ; else { int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == ' B ' ) count ++ ; } if ( count == n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) a [ i ] = '1' ; else if ( a [ i ] == '1' ) a [ i ] = '0' ; } } System . out . print ( a [ n - 1 ] ) ; } } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { int n = in . nextInt ( ) ; int x = in . nextInt ( ) ; if ( n + x == 0 ) return false ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( i != j && i != j && i != n && j != ( i + 1 ) % 3 == 0 ) cnt ++ ; } } out . println ( cnt ) ; return true ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 100 ; static int recur ( int ind , int cnt , int last , int a [ ] , int n , int k , int dp [ ] [ ] ) { if ( cnt == k ) return 0 ; if ( ind == n ) return ( int ) ( - 1 * Math . pow ( 10 , 9 ) ) ; if ( dp [ ind ] [ cnt ] != - 1 ) return dp [ ind ] [ cnt ] ; int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( cnt % 2 == 0 ) ans = Math . max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = Math . max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } return dp [ ind ] [ cnt ] = ans ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 } ; int n = a . length ; int k = 4 ; int dp [ ] [ ] = new int [ n ] [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . println ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) ; } }
import java . util . * ; import java . io . * ; public class codeforces { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; double arr [ ] = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextDouble ( ) ; sum += arr [ i ] ; } Arrays . sort ( arr ) ; double min = Math . abs ( 2 * n - sum ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( Math . abs ( 2 * n - sum ) < min ) { min = Math . abs ( 2 * n - sum ) ; } } System . out . println ( min ) ; } }
public class GFG { static String equivalentBase4 ( String bin ) { if ( bin . equals ( "00" ) ) return 0 ; if ( bin . equals ( "01" ) ) return 1 ; if ( bin . equals ( "10" ) ) return 2 ; if ( bin . equals ( "11" ) ) return 3 ; return isDivisibleBy5 ( bin ) ; } static boolean isDivisibleBy5 ( String bin ) { int len = bin . length ( ) ; if ( ( len % 2 ) == 1 ) bin = "0" + bin ; int odd_sum = 0 , even_sum = 0 ; int isOddDigit = 1 ; for ( int i = 0 ; i < len ; i += 2 ) { if ( isOddDigit ) odd_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; else even_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; isOddDigit = isOddDigit ^ 1 ; } if ( Math . abs ( odd_sum - even_sum ) % 5 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { String bin = "10000101001" ; System . out . println ( isDivisibleBy5 ( bin ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] [ ] map = new int [ 8 ] [ 8 ] [ 2 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { map [ i ] [ j ] [ 0 ] = i ; for ( int k = 0 ; k < 8 ; k ++ ) { int x = i + j ; int y = j + k ; int z = i + k ; map [ i ] [ y ] [ z ] = x ; map [ i ] [ y ] [ z ] = x ; } } } while ( sc . hasNext ( ) ) { int [ ] a = new int [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int ans = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { for ( int k = 0 ; k < 8 ; k ++ ) { if ( map [ i ] [ j ] [ k ] == 0 ) continue ; map [ i ] [ j ] [ k ] = map [ i ] [ j ] [ k ] + 1 ; } } } for ( int i = 0 ; i < 8 ; i ++ ) { System . out . println ( map [ a [ i ] ] [ 0 ] [ i ] ) ; } System . out . println ( ans ) ; } } }
import java . util . * ; public class Main { static int a1 [ ] = new int [ 10 ] ; static int a2 [ ] = new int [ 10 ] ; static int b1 [ ] = new int [ 10 ] ; static int c1 [ ] = new int [ 10 ] ; static int c2 [ ] = new int [ 10 ] ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; a1 [ 0 ] = sc . nextInt ( ) ; a2 [ 0 ] = sc . nextInt ( ) ; a2 [ 0 ] = sc . nextInt ( ) ; a1 [ 1 ] = sc . nextInt ( ) ; a2 [ 1 ] = sc . nextInt ( ) ; c1 [ 0 ] = sc . nextInt ( ) ; c2 [ 0 ] = sc . nextInt ( ) ; c2 [ 1 ] = sc . nextInt ( ) ; c2 [ 1 ] = sc . nextInt ( ) ; int answer = Integer . MAX_VALUE ; for ( int i = 1 ; i < a1 . length ; i ++ ) { for ( int j = i + 1 ; j < a2 . length ; j ++ ) { if ( a1 [ i ] == a2 [ j ] ) { if ( a1 [ i ] > a2 [ j ] ) { answer = Math . min ( answer , a1 [ i ] + a2 [ j ] ) ; } } } } System . out . println ( answer ) ; } }
import java . util . ArrayList ; import java . util . List ; import static java . lang . Math . sqrt ; class Main { private static final int MAX = 1005 ; public static List < Integer > SieveOfEratosthenes ( List < Integer > primes ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p <= sqrt ( MAX ) ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { primes . add ( p ) ; } } return primes ; } public static int minimumSquareFreeDivisors ( int N ) { List < Integer > prime = new ArrayList < > ( ) ; List < Integer > primes = new ArrayList < > ( ) ; primes = SieveOfEratosthenes ( prime ) ; int max_count = 0 ; int i = 0 ; while ( primes . size ( ) > 0 && primes . get ( i ) * primes . get ( i ) <= N ) { if ( N % primes . get ( i ) == 0 ) { int tmp = 0 ; while ( N % primes . get ( i ) == 0 ) { tmp += 1 ; N /= primes . get ( i ) ; } max_count = Math . max ( max_count , tmp ) ; } i += 1 ; } if ( max_count == 0 ) { max_count = 1 ; } return max_count ; } public static void main ( String [ ] args ) { int N ; N = 24 ; System . out . println ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ " + minimumSquareFreeDivisors ( N ) ) ; N = 6 ; System . out . println ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ " + minimumSquareFreeDivisors ( N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int ans = 0 ; if ( a > b ) { a = b ; } else { b = a - 1 ; } while ( true ) { ans = ( x + a ) % b ; if ( ans == 0 ) break ; x = x - a ; if ( ans < 0 ) break ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int cnt = 0 ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cnt ++ ; } } if ( cnt == 0 ) { System . out . println ( 0 ) ; } else if ( cnt == 1 ) { System . out . println ( - 1 ) ; } else { if ( arr [ k - 1 ] == arr [ k ] ) { System . out . println ( - 1 ) ; } else { System . out . println ( n - cnt ) ; } } } }
import java . io . * ; public class GFG { static int fun ( int n ) { return n & ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( " The ▁ number ▁ after ▁ unsetting ▁ the ▁ rightmost ▁ set ▁ bit ▁ " + fun ( n ) ) ; } }
import java . util . * ; public class GFG { static int LongestFibSubseq ( int [ ] A , int n ) { Set < Integer > S = new HashSet < Integer > ( ) ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = A [ j ] ; int y = A [ i ] + A [ j ] ; int len = 2 ; while ( S . contains ( y ) ) { int z = x + y ; x = y ; y = z ; len ++ ; maxLen = Math . max ( maxLen , len ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . length ; System . out . println ( LongestFibSubseq ( A , n ) ) ; } }
import java . util . * ; public class GFG { static int countPairs ( int a [ ] , int b [ ] , int n , int m ) { int cnt = 0 ; HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int sum = a [ i ] + b [ j ] ; if ( ! s . containsKey ( sum ) ) { s . put ( sum , 1 ) ; } } } return cnt ; } public static void main ( String [ ] args ) { int a [ ] = { 12 , 2 , 7 } ; int n = a . length ; int b [ ] = { 4 , 3 , 8 } ; int m = b . length ; System . out . println ( countPairs ( a , b , n , m ) ) ; } }
import java . io . * ; public class GFG { static boolean check ( int a [ ] , int y ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { double x = Math . sqrt ( a [ i ] ) ; if ( Math . floor ( x ) == Math . ceil ( x ) ) sum += a [ i ] ; } if ( sum % y == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 4 , 9 , 10 } ; int x = 13 ; if ( check ( a , x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; PriorityQueue < Integer > pque = new PriorityQueue < > ( ) ; int limit = n ; for ( int i = 0 ; i < q ; i ++ ) { int query = sc . nextInt ( ) ; int key = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; if ( query == 0 ) { pque . add ( x ) ; } else if ( query == 1 ) { int p = sc . nextInt ( ) ; if ( pque . peek ( ) != null ) pque . poll ( ) ; } else if ( query == 2 ) { int p = sc . nextInt ( ) ; if ( pque . peek ( ) != null ) pque . poll ( ) ; } else { int d = sc . nextInt ( ) ; if ( pque . peek ( ) != null ) { System . out . println ( pque . peek ( ) ) ; } } } } }
import java . util . * ; public class GFG { static int calculate_min_sum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int min_sum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) min_sum += Math . abs ( a [ i ] - a [ i - 1 ] ) ; return min_sum ; } static int calculate_max_sum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int max_sum = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) max_sum += Math . abs ( a [ n - 1 - i ] - a [ i ] ) ; return max_sum ; } public static void main ( String [ ] args ) { int a [ ] = { 10 , - 10 , 20 , - 40 } ; int n = a . length ; System . out . println ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + calculate_min_sum ( a , n ) ) ; System . out . println ( " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + calculate_max_sum ( a , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int m = sc . nextInt ( ) ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < b [ i ] ) { count ++ ; } else if ( a [ i ] > b [ i ] ) { count ++ ; } } System . out . println ( count > 0 ? 1 : 0 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; if ( a [ i ] % 2 == 0 ) y ++ ; else x ++ ; } if ( x == 0 || y == 0 ) { System . out . println ( " Yes " ) ; } else if ( x == y ) { System . out . println ( " No " ) ; } else { int s = Math . max ( 0 , ( x / 4 ) - 1 ) ; int e = Math . max ( 0 , ( x - y / 4 ) - 1 ) ; int t = Math . max ( 0 , ( x - y / 4 ) - 1 ) ; int s1 = Math . max ( x - y / 4 , 0 ) ; if ( e >= s && e < s1 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } }
public class GFG { static boolean isPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) return false ; } return true ; } static boolean ans ( String s ) { String s2 = s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { s2 = s2 . substring ( s2 . length ( ) - 1 ) + s2 ; s2 = s2 . substring ( 0 , s2 . length - 1 ) ; if ( s != s2 && isPalindrome ( s2 ) ) return true ; } return false ; } static int solve ( String s ) { if ( s . length ( ) <= 3 ) return - 1 ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s . charAt ( i ) - ' a ' ] ++ ; int max = cnt [ 0 ] ; for ( int i = 0 ; i < cnt . length ; i ++ ) { if ( cnt [ i ] > max ) max = cnt [ i ] ; } if ( max >= s . length ( ) - 1 ) return - 1 ; else { if ( ans ( s ) == true ) return 1 ; else return 2 ; } } public static void main ( String [ ] args ) { String s = " nolon " ; System . out . println ( solve ( s ) ) ; } }
import java . io . * ; public class GFG { static int count_numbers ( int k , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; } public static void main ( String [ ] args ) { int k = 10 , n = 3 ; System . out . println ( count_numbers ( k , n ) ) ; } }
import java . io . * ; public class GFG { static int minCost ( int n , int arr [ ] , int cost ) { int sum = 0 , totalCost = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += arr [ i ] ; totalCost += cost * sum ; arr [ n - 1 ] += sum ; totalCost += ( 2 * cost * arr [ n - 1 ] ) ; return totalCost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = arr . length ; int cost = 1 ; System . out . println ( minCost ( n , arr , cost ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int q = sc . nextInt ( ) ; for ( int tc = 0 ; tc < q ; tc ++ ) { int c = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; System . out . println ( solve ( c , a , n ) ) ; } sc . close ( ) ; } static int solve ( int c , int a , int n ) { int canC = 0 ; int canS = 0 ; if ( c >= a ) { canC = ( c - a ) / 2 ; canS += ( c - a ) / 3 ; } else { canC = ( c - a ) / 2 ; canC += ( a - a ) / 2 ; canC += ( a - a ) / 3 ; } return canC + canS ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; import java . util . TreeSet ; import java . util . * ; import static java . lang . System . * ; import static java . lang . Math . * ; public class pre5 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; while ( true ) { int n = obj . nextInt ( ) ; if ( n == 0 ) break ; int m = obj . nextInt ( ) ; String str = obj . next ( ) ; int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( str . charAt ( i ) == ' IO ' ) { int IOI = 0 ; for ( int j = i + 1 ; j < m ; j ++ ) { if ( str . charAt ( j ) == ' IO ' ) IOI ++ ; } if ( IOI >= n ) ans ++ ; } out . println ( ans ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String s = sc . next ( ) ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( ( s . charAt ( i ) - '0' ) % 25 == 0 || s . charAt ( i ) - '0' % 25 == 0 ) { int sum = 0 ; for ( int k = i + 1 ; k < s . length ( ) ; k ++ ) { sum = ( s . charAt ( k ) - '0' ) + ( s . charAt ( k ) - '0' ) ; } if ( sum % 25 == 0 ) { min = Math . min ( min , sum ) ; } } } } System . out . println ( min ) ; } } }
public class GFG { static class Node { int data ; Node left , right ; } ; static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static Node insert ( Node root , int data ) { if ( root == null ) return newNode ( data ) ; else { if ( data < root . data ) root . left = insert ( root . left , data ) ; if ( data > root . data ) root . right = insert ( root . right , data ) ; return root ; } } static void inOrder ( Node root ) { if ( root == null ) return ; else { inOrder ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; inOrder ( root . right ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 2 , 5 , 4 , 4 } ; int n = arr . length ; Node root = null ; for ( int i = 0 ; i < n ; i ++ ) root = insert ( root , arr [ i ] ) ; inOrder ( root ) ; } }
public class GFG { static int MAX_CHAR = 26 ; static String removeChars ( String str , int k ) { int [ ] hash = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hash [ str . charAt ( i ) - ' a ' ] ++ ; } String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash [ str . charAt ( i ) - ' a ' ] >= k ) res += str . charAt ( i ) ; } return res ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int k = 2 ; System . out . println ( removeChars ( str , k ) ) ; } }
import java . io . * ; public class GFG { static int LCSubStr ( String X , String Y , int m , int n ) { int LCSuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCSuff [ i ] [ j ] ) ; } else { LCSuff [ i ] [ j ] = 0 ; } } } return result ; } public static void main ( String [ ] args ) { String X = " OldSite : GeeksforGeeks . org " ; String Y = " NewSite : GeeksQuiz . com " ; int m = X . length ( ) ; int n = Y . length ( ) ; System . out . println ( " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ▁ " + LCSubStr ( X , Y , m , n ) ) ; } }
import java . io . * ; public class GFG { static int countOccurrences ( int x , int d ) { int count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x /= 10 ; } return count ; } static int maxOccurring ( int x ) { if ( x < 0 ) x = - x ; int result = 0 ; int max_count = 1 ; for ( int d = 0 ; d < 10 ; d ++ ) { int count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; } public static void main ( String [ ] args ) { int x = 1223355 ; System . out . println ( " Max ▁ occurring ▁ digit ▁ is ▁ " + maxOccurring ( x ) ) ; } }
import java . io . * ; public class GFG { static void printLogestIncSubArr ( int arr [ ] , int n ) { int m = 1 , l = 1 , maxIndex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) l ++ ; else { if ( m < l ) { m = l ; maxIndex = i - m ; } l = 1 ; } } if ( m < l ) { m = l ; maxIndex = n - m ; } for ( int i = maxIndex ; i < ( m + maxIndex ) ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 } ; int n = arr . length ; printLogestIncSubArr ( arr , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] ans = new int [ 101 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { ans [ i ] = i ; if ( n / i != i ) { ans [ i ] = n / i + 1 ; } } } for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { ans [ i ] = i ; if ( n / i != i ) { ans [ i ] = n / i + 1 ; } } } System . out . println ( ans [ 1 ] ) ; } }
import java . util . * ; public class BallsOfSteals { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int arr [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } for ( int i = 1 ; i <= n ; i ++ ) { int j = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int c = 0 ; for ( int l = 0 ; l <= k ; l ++ ) { if ( arr [ l ] > arr [ j ] && arr [ l ] <= arr [ j ] ) c ++ ; } if ( c == n ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } }
import java . io . * ; public class GFG { static int Max_Sum ( int a [ ] , int n ) { int b [ ] = new int [ n ] ; int S = 0 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { g -= a [ i ] ; ans = Math . max ( ans , g + b [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { - 6 , 10 , - 3 , 10 , - 2 } ; int n = a . length ; System . out . println ( " Maximum ▁ sum ▁ is : ▁ " + Max_Sum ( a , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int count = 0 ; int max = 0 ; int min = 0 ; for ( int j = 1 ; j <= 100 ; j ++ ) { for ( int k = 1 ; k <= 100 ; k ++ ) { if ( j <= x ) { if ( count < min ) { max = count ; min = j ; } count = 0 ; } else if ( count < y ) { if ( count < min ) { min = count ; } count = 0 ; } else { max = count ; } } } if ( max == 0 && x != y ) { System . out . println ( count - 1 ) ; } else { System . out . println ( count ) ; } } } }
public class Main { public static void reverse ( String str1 , int x ) { int n = ( str1 . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( str1 . charAt ( i ) ) ; } for ( int i = n + x - 1 ; i >= n ; i -- ) { System . out . print ( str1 . charAt ( i ) ) ; } for ( int i = n + x ; i < str1 . length ( ) ; i ++ ) { System . out . print ( str1 . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String str1 = " geeksforgeeks " ; int x = 3 ; reverse ( str1 , x ) ; } }
public class GFG { static int lps ( String str ) { int n = str . length ( ) ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } static int minimumNumberOfDeletions ( String str ) { int n = str . length ( ) ; int l = lps ( str ) ; return ( n - l ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " + minimumNumberOfDeletions ( str ) ) ; } }
public class GFG { static boolean bit_check ( int n ) { if ( ( n & ( n - 1 ) ) == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( bit_check ( n ) ? 1 : 0 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } int count = 0 ; for ( int j = n - 1 ; j >= 1 ; j -- ) { if ( arr [ j ] <= arr [ j - 1 ] ) { count ++ ; } } System . out . println ( count ) ; } } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int LIMIT = Library . pow ( 10 , 8 ) - 1 ; int ans = 0 ; int [ ] primes = Library . listPrimes ( LIMIT / 2 ) ; int sqrt = Library . sqrt ( LIMIT ) ; for ( int i = 0 ; i < primes . length ; i ++ ) { if ( sqrt > primes [ i ] ) break ; int end = binarySearch ( primes , LIMIT / p ) ; ans += ( end >= 0 ? end + 1 : - end - 1 ) - i ; } return Integer . toString ( ans ) ; } private static int binarySearch ( int [ ] lst , int x ) { int start = 0 , end = lst . length ; while ( start < end ) { int mid = ( start + end ) / 2 ; if ( x < lst [ mid ] ) end = mid ; else if ( x > lst [ mid ] ) start = mid + 1 ; else if ( x == lst [ mid ] ) return mid ; else throw new AssertionError ( ) ; } return - start - 1 ; } }
import java . util . * ; public class GFG { static int M = 20 ; static int dp [ ] [ ] [ ] [ ] = new int [ M ] [ M ] [ 2 ] [ 2 ] ; static int d = 2 ; static int K = 1 ; static int count ( int pos , int cnt , int tight , int nonz , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 ) return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; int ans = 0 ; int limit = ( tight != 0 ) ? 9 : num . get ( pos ) ; for ( int dig = 0 ; dig <= limit ; dig ++ ) { int currCnt = cnt ; if ( dig == d ) { if ( d != 0 || d == 0 && nonz ) currCnt ++ ; int currTight = tight ; if ( dig < num . get ( pos ) ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , ( nonz || dig != 0 ) , num ) ; } return dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; } return dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; } static int solve ( int x ) { Vector < Integer > num = new Vector < Integer > ( ) ; while ( x > 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < M ; k ++ ) dp [ i ] [ j ] [ k ] [ 0 ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; } public static void main ( String [ ] args ) { int L = 11 , R = 100 ; int d = 2 ; int K = 1 ; System . out . println ( solve ( R ) - solve ( L - 1 ) ) ; } }
import java . util . * ; public class Test3 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; if ( s . length ( ) == 1 ) { System . out . print ( 9 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( Character . getNumericValue ( s . charAt ( i ) ) > 4 ) { System . out . print ( i ) ; break ; } } } else { System . out . print ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Character . getNumericValue ( s . charAt ( i ) ) > 4 ) { System . out . print ( i ) ; break ; } } } } }
import java . io . * ; public class GFG { static boolean isPeak ( int arr [ ] , int n , int num , int i , int j ) { if ( i >= 0 && arr [ i ] > num ) return false ; if ( j < n && arr [ j ] > num ) return false ; return true ; } static boolean isTrough ( int arr [ ] , int n , int num , int i , int j ) { if ( i >= 0 && arr [ i ] < num ) return false ; if ( j < n && arr [ j ] < num ) return false ; return true ; } static void printPeaksTroughs ( int arr [ ] , int n ) { System . out . print ( " Peaks ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) if ( isPeak ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; System . out . print ( " Troughs ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) if ( isTrough ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 10 , 5 , 7 , 4 , 3 , 5 } ; int n = arr . length ; printPeaksTroughs ( arr , n ) ; } }
public class Main { public static int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; } public static void check ( int n ) { String [ ] s = { " negative " , " zero " , " positive " } ; int val = index ( n ) ; System . out . println ( n + " ▁ is ▁ " + s [ val ] ) ; } public static void main ( String [ ] args ) { check ( 30 ) ; check ( - 20 ) ; check ( 0 ) ; } }
import java . util . * ; public class GFG { static int frequency ( int a [ ] , int x ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] == x ) count ++ ; return count ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , 5 , 5 , 5 , 4 } ; int x = 5 ; System . out . println ( frequency ( a , x ) ) ; } }
import java . util . * ; public class GFG { static boolean isNumBalanced ( int N ) { String str = Integer . toString ( N ) ; boolean isBalanced = true ; int freq [ ] = new int [ 10 ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - '0' ] ++ ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( freq [ i ] != freq [ i + 1 ] ) isBalanced = false ; } if ( isBalanced ) return true ; else return false ; } public static void main ( String [ ] args ) { int N = 1234567890 ; boolean flag = isNumBalanced ( N ) ; if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isThreeDisctFactors ( int n ) { int sq = ( int ) Math . sqrt ( n ) ; if ( 1 * sq * sq != n ) return false ; if ( isPrime ( sq ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int num = 9 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 15 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 12397923568441 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; num = 12397923568441 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 12397923568441 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int numer = 1 , denom = 0 ; for ( int i = 100 ; i >= 0 ; i -- ) { numer = eContfracTerm ( i ) * numer + denom ; } int sum = 0 ; for ( int i = 0 ; i < numer ; i ++ ) sum += Integer . parseInt ( Integer . toString ( numer ) ) ; return Integer . toString ( sum ) ; } private static int eContfracTerm ( int i ) { if ( i == 0 ) return 2 ; else if ( i % 3 == 2 ) return i / 3 * 2 + 2 ; else return 1 ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int LCM ( int x , int y , int z ) { int ans = ( x * y ) / ( __gcd ( x , y ) ) ; return ( z * ans ) / ( __gcd ( ans , z ) ) ; } static int findDivisible ( int n , int x , int y , int z ) { int lcm = LCM ( x , y , z ) ; int ndigitnumber = ( int ) Math . pow ( 10 , n - 1 ) ; int reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; } public static void main ( String [ ] args ) { int n = 4 , x = 2 , y = 3 , z = 5 ; int res = findDivisible ( n , x , y , z ) ; if ( res != 0 ) System . out . println ( res ) ; else System . out . println ( " Not ▁ possible " ) ; } }
import java . util . * ; public class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ 100001 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } } static void common_prime ( int a , int b ) { int gcd = gcd ( a , b ) ; for ( int i = 2 ; i <= gcd ; i ++ ) { if ( prime [ i ] && gcd % i == 0 ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int a = 6 , b = 12 ; common_prime ( a , b ) ; } }
import java . util . Scanner ; public class Main { static int [ ] [ ] cost ; static int [ ] [ ] memo ; static int n ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; cost = new int [ n ] [ 394 ] ; memo = new int [ n ] [ 394 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 394 ; j ++ ) { cost [ i ] [ j ] = sc . nextInt ( ) ; } } for ( int i = 0 ; i < n ; i ++ ) { int s = sc . nextInt ( ) ; int l = sc . nextInt ( ) ; int p = sc . nextInt ( ) ; for ( int j = s ; j <= l ; j ++ ) { for ( int k = s ; k < l + 1 ; k ++ ) { if ( cost [ j ] [ k ] > cost [ j + 1 ] [ k ] ) { cost [ j ] [ k ] = cost [ j ] [ k ] ; } } } int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int s = sc . nextInt ( ) ; int l = sc . nextInt ( ) ; int p = sc . nextInt ( ) ; for ( int j = s ; j < l + 1 ; j ++ ) { for ( int k = s ; k < l + 1 ; k ++ ) { if ( cost [ j ] [ k ] > cost [ j + 1 ] [ s ] ) { cost [ j ] [ k ] = cost [ j ] [ k ] ; } } } } boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( memo [ i ] [ 0 ] != Integer . MAX_VALUE && cost [ i ] [ 1 ] != Integer . MAX_VALUE ) { flag = true ; break ; } } if ( flag ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( cost [ i ] [ 0 ] ) ; } } if ( flag ) { System . out . println ( - 1 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; ArrayList < Integer > [ ] g = new ArrayList [ N ] ; for ( int i = 0 ; i < N ; i ++ ) g [ i ] = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; g [ a ] . add ( b ) ; g [ b ] . add ( a ) ; } ArrayDeque < Integer > q = new ArrayDeque < > ( ) ; int [ ] w = new int [ N ] ; Arrays . fill ( w , - 1 ) ; q . add ( 1 ) ; while ( ! q . isEmpty ( ) ) { int v = q . poll ( ) ; if ( w [ v ] == - 1 ) { continue ; } for ( int i : g [ v ] ) { if ( w [ i ] == - 1 ) { q . add ( i ) ; w [ i ] = w [ v ] + 1 ; } } } if ( w [ 0 ] == - 1 ) { System . out . println ( " First " ) ; return ; } for ( int i = 1 ; i < N ; i ++ ) { if ( w [ i ] == - 1 ) { continue ; } w [ i ] = w [ i ] + 1 ; q . add ( i ) ; } String ans = " Second " ; for ( int i = 0 ; i < N ; i ++ ) { if ( w [ i ] == - 1 ) { ans = " First " ; break ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int arr [ ] [ ] = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; for ( int j = 0 ; j < m ; j ++ ) { arr [ i ] [ j ] = s . charAt ( j ) ; } } boolean ans = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { int sum = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] [ j ] + arr [ i + 1 ] [ k ] + arr [ i + 1 ] [ k ] + arr [ i + 1 ] [ j ] == 3 ) { sum = 1 ; } } } } if ( sum == 3 ) { ans = false ; } } System . out . println ( ans ? " YES " : " NO " ) ; } } }
import java . util . * ; public class CodeForces { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; String s = sc . next ( ) ; int l = 0 ; int r = n - 1 ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( s . charAt ( m ) == ' . ' ) { r = m ; } else { l = m ; } } int max = 0 ; int idx = 0 ; while ( l < r ) { if ( s . charAt ( l ) == ' . ' ) { idx = l ; } else { r = m - 1 ; } } int lo = 0 ; int hi = n - 1 ; while ( lo < r ) { if ( s . charAt ( lo ) == ' . ' ) { lo = m + 1 ; } else { hi = m - 1 ; } } int middle = ( lo + r ) / 2 ; int count = 0 ; while ( lo < r ) { if ( s . charAt ( lo ) == ' . ' ) { count ++ ; } else { break ; } } System . out . println ( ( count + 1 ) + " ▁ " + ( hi - count ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String a = sc . nextLine ( ) . toLowerCase ( ) . replace ( " ; " , " " ) . replace ( " _ " , " " ) . replace ( " ; " , " " ) ; String b = sc . nextLine ( ) . toLowerCase ( ) . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) ; int q = Integer . parseInt ( sc . nextLine ( ) ) ; String [ ] c = new String [ q ] ; for ( int i = 0 ; i < q ; i ++ ) { c [ i ] = sc . nextLine ( ) . toLowerCase ( ) . replace ( " ; " , " " ) . replace ( " - " , " " ) ; } String [ ] r = new String [ q ] ; for ( int i = 0 ; i < q ; i ++ ) { r [ i ] = sc . nextLine ( ) . toLowerCase ( ) . replace ( " ; " , " " ) ; } for ( int i = 0 ; i < q ; i ++ ) { boolean ok = false ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { if ( r [ i ] . equals ( c [ j ] ) ) { ok = true ; break ; } } if ( ok ) { if ( r [ i ] . toLowerCase ( ) . equals ( r [ i ] ) ) { ok = true ; break ; } } } if ( ok ) { System . out . println ( " ACC " ) ; } else { System . out . println ( " WA " ) ; } } } }
import java . util . * ; import java . io . * ; import java . math . * ; public class A { static BufferedReader br ; static StringTokenizer st ; static PrintWriter out ; static int T ; public static void main ( String [ ] args ) throws Exception { br = new BufferedReader ( new FileReader ( " input . txt " ) ) ; out = new PrintWriter ( new FileWriter ( " output . txt " ) ) ; int T = nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { out . print ( " Case ▁ # " + cas + " : ▁ " ) ; solve ( ) ; } out . close ( ) ; } static void solve ( ) throws Exception { int N = nextInt ( ) ; int L = nextInt ( ) ; int [ ] a = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) a [ i ] = nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) b [ i ] = nextInt ( ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; int ans = L + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) xor ^= a [ j ] ; if ( xor == b [ 0 ] ) { int count = 0 ; for ( int k = 0 ; k < N ; k ++ ) if ( ( a [ j ] ^ xor ^ b [ k ] ) != 0 ) count ++ ; } if ( count < L ) ans = L + 1 ; } if ( ans == L + 1 ) out . println ( " NOT ▁ POSSIBLE " ) ; else out . println ( " NOT ▁ POSSIBLE " ) ; } }
import java . util . * ; public class Solution { public int maxAreaOfIsland ( int [ ] [ ] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { grid [ i ] [ j ] = 0 ; ans = Math . max ( dfs ( grid , i , j ) , ans ) ; } } } return ans ; } public int dfs ( int [ ] [ ] grid , int i , int j ) { Stack < Pair > stack = new Stack < Pair > ( ) ; stack . push ( new Pair ( i , j ) ) ; int area = 0 ; while ( ! stack . isEmpty ( ) ) { Pair < Integer , Integer > nr = stack . pop ( ) ; int nc = stack . pop ( ) . key ; area ++ ; for ( int nr = ( r - 1 ) , nc = ( r + 1 ) ; nr <= nc ; nr ++ , nc ++ ) { if ( 0 <= nr < grid . length && 0 <= nc < grid [ 0 ] . length && 0 <= nc < grid [ 0 ] . length && grid [ nr ] [ nc ] == 1 ) { stack . push ( new Pair ( nr , nc ) ) ; grid [ nr ] [ nc ] = 0 ; } } } return area ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] [ ] grid = { { 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 } } ; int [ ] [ ] [ ] grid = { { 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 } , { 0 , 0 , 0
import java . io . * ; public class GFG { static int sum ( int x , int y , int n ) { int sum1 = ( int ) ( Math . pow ( x , 2 * n ) - 1 ) ; double sum2 = ( int ) ( ( x * x * Math . pow ( x , 2 * n ) * Math . pow ( y , n ) - 1 ) ) / ( x * x - 1 ) ; return ( int ) ( sum1 + sum2 ) ; } public static void main ( String [ ] args ) { int x = 2 , y = 2 , n = 2 ; System . out . println ( sum ( x , y , n ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; } public static void main ( String [ ] args ) { int n = 687 ; System . out . println ( getSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; } public static void main ( String [ ] args ) { int n = 687 ; System . out . println ( getSum ( n ) ) ; } }
public class GFG { static class Node { int data ; Node next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; return head_ref ; } static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n + 2 ; i = i + 6 ) if ( i * i < n + 2 && ( n % i == 0 || n % ( i + 2 ) == 0 ) ) return false ; return true ; } static Node deleteNonPrimeNodes ( Node head_ref ) { Node ptr = head_ref ; while ( ptr != null && isPrime ( ptr . data ) != true ) { Node temp = ptr ; ptr = ptr . next ; } head_ref = ptr ; if ( ptr == null ) return null ; Node curr = ptr . next ; while ( curr != null ) { if ( isPrime ( curr . data ) != true ) { ptr . next = curr . next ; curr = ptr . next ; } else { ptr = curr ; curr = curr . next ; } } return head_ref ; } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , 17 ) ; head = push ( head , 7 ) ; head = push ( head , 6 ) ; head = push ( head , 16 ) ; head = push ( head , 15 ) ; System . out . println ( " Original ▁ List : ▁ " ) ; printList ( head ) ; head = deleteNonPrimeNodes ( head ) ; System . out . println ( " \n Modified ▁ List : ▁ " ) ; printList ( head ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int l = sc . nextInt ( ) ; int [ ] [ ] t = new int [ m ] [ 5 * n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { int d = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; t [ a ] [ k ] = t ; } int dp [ ] [ ] = new int [ n + 1 ] [ 5 * n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= 5 * n ; j ++ ) dp [ i ] [ j ] = t [ i ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= l ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] + t [ i ] [ j ] ) ; System . out . println ( dp [ n ] [ l ] ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] w = new int [ n ] ; int [ ] r = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int x = sc . nextInt ( ) - 1 ; int y = sc . nextInt ( ) - 1 ; if ( w [ x ] == 1 && r [ y ] == 1 ) { w [ y ] = 0 ; } else { r [ x ] ++ ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( w [ i ] == 0 ) ans ++ ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int [ ] left = new int [ h ] ; int [ ] right = new int [ h ] ; for ( int i = 0 ; i < h ; i ++ ) { String line = sc . next ( ) ; for ( int j = 0 ; j < w ; j ++ ) { if ( line . charAt ( j ) == ' B ' ) { left [ i ] = j ; right [ i ] = w ; } } } int ans = 0 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( left [ i ] == i && right [ j ] == i ) { ans = Math . abs ( left [ i ] - left [ j ] ) + Math . abs ( right [ i ] - right [ j ] ) ; } } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static void minReplacement ( String str ) { if ( str . length ( ) > 26 ) { System . out . println ( " IMPOSSIBLE " ) ; } else { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash [ str . charAt ( i ) - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( hash [ str . charAt ( i ) - ' a ' ] > 1 ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( hash [ j ] == 0 ) { hash [ str . charAt ( i ) - ' a ' ] -- ; str . setCharAt ( i , ( char ) ( j + ' a ' ) ) ; hash [ j ] ++ ; break ; } } } } System . out . println ( str ) ; } } public static void main ( String [ ] args ) { String str = " xxxxyyyy " ; minReplacement ( str ) ; } }
public class Main { public static int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s . charAt ( j - 1 ) == '0' ) { pre_count_0 [ j ] += 1 ; } else { pre_count_1 [ j ] += 1 ; } if ( s . charAt ( n - j ) == '0' ) { post_count_0 [ n - j + 1 ] += 1 ; } } if ( pre_count_0 [ n ] == n || pre_count_0 [ n ] == 0 ) { return n ; } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; } } return ans ; } public static void main ( String [ ] args ) { String s = "000011100000" ; System . out . println ( longestSubseq ( s ) ) ; } }
import java . io . * ; public class GFG { static void sieveOfEratosthenes ( int N , int s [ ] ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; i * j <= N / i ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } static void generatePrimeFactors ( int N ) { int [ ] s = new int [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; System . out . println ( " Factor ▁ Power " ) ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } System . out . println ( curr + " \ t " + cnt ) ; curr = s [ N ] ; cnt = 1 ; } } public static void main ( String [ ] args ) { int N = 360 ; generatePrimeFactors ( N ) ; } }
import java . util . * ; public class GFG { static int longestSubarray ( int a [ ] , int n ) { int hash [ ] [ ] = new int [ n ] [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { hash [ i ] [ num % 10 ] = 1 ; num /= 10 ; } } int longest = Integer . MIN_VALUE ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( hash [ i ] [ j ] && hash [ i + 1 ] [ j ] ) { count ++ ; break ; } } if ( j == 10 ) { longest = Math . max ( longest , count + 1 ) ; count = 0 ; } } longest = Math . max ( longest , count + 1 ) ; return longest ; } public static void main ( String [ ] args ) { int a [ ] = { 11 , 22 , 33 , 44 , 54 , 56 , 63 } ; int n = a . length ; System . out . println ( longestSubarray ( a , n ) ) ; } }
import java . util . * ; public class Exersise { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] [ ] array = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { for ( int j = 0 ; j < array [ i ] . length ; j ++ ) { array [ i ] [ j ] = input . nextInt ( ) ; } } for ( int i = 0 ; i < array . length ; i ++ ) { System . out . println ( array [ i ] [ 0 ] + array [ i ] [ 1 ] / 2 ) ; } } }
import java . util . * ; public class GFG { static Vector < Integer > Divisors ( int x ) { int c = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . add ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . add ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . add ( c ) ; v . add ( x ) ; return v ; } static int MinOperations ( int a , int b ) { Vector < Integer > va = Divisors ( a ) ; Vector < Integer > vb = Divisors ( b ) ; if ( va . get ( 3 ) != vb . get ( 3 ) ) return - 1 ; int minOperations = Math . abs ( va . get ( 0 ) - vb . get ( 0 ) ) + Math . abs ( va . get ( 1 ) - vb . get ( 1 ) ) + Math . abs ( va . get ( 2 ) - vb . get ( 2 ) ) ; return minOperations ; } public static void main ( String [ ] args ) { int a = 14 , b = 28 ; System . out . println ( MinOperations ( a , b ) ) ; } }
import java . util . * ; public class GFG { static int N = 1000001 ; static int c = 0 ; static int n = 0 ; static int m = 0 ; static int a = 0 , b = 0 ; static void dfs ( int a , int b , Vector < Vector < Integer > > v , boolean vis [ ] ) { vis [ a ] = true ; c ++ ; for ( int i = 0 ; i < v . get ( a ) . size ( ) ; i ++ ) if ( vis [ i ] == false && i != b ) dfs ( i , b , v , vis ) ; } static void Calculate ( Vector < Vector < Integer > > v ) { int vis [ ] = new int [ n + 1 ] ; vis [ 0 ] = 0 ; c = 0 ; dfs ( a , b , v , vis ) ; int ans1 = n - c - 1 ; vis = new int [ vis . length ] ; c = 0 ; dfs ( b , a , v , vis ) ; int ans2 = n - c - 1 ; System . out . println ( ans1 * ans2 ) ; } public static void main ( String [ ] args ) { int n = 7 , m = 7 ; int a = 3 , b = 5 ; Vector < Vector < Integer > > v = new Vector < Vector < Integer > > ( ) ; vis [ 0 ] = 0 ; vis [ 1 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) v . add ( new Vector < Integer > ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) { Vector < Integer > v = new Vector < Integer > ( ) ; v . get ( edges [ i ] . get ( 0 ) ) . add ( edges [ i ] . get ( 1 ) ) ; v . get ( edges [ i ] . get ( 1 ) ) . add ( edges [ i ] . get ( 0 ) ) ; } Calculate ( v ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long ans = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { long t = n ; n = t ; while ( n > 0 ) { ans = Math . max ( ans , t * ( n / i ) ) ; n = n % i ; } } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class A_194 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int res = 0 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int l = i ; if ( l > n ) { count = i ; break ; } } res = count + ( ( n - k ) / k ) ; System . out . println ( res ) ; } }
import java . io . * ; public class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static int largestDigitSumdivisior ( int n ) { int res = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { res = Math . max ( res , getSum ( i ) ) ; res = Math . max ( res , getSum ( n / i ) ) ; } } return res ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( largestDigitSumdivisior ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long l = sc . nextLong ( ) ; long r = sc . nextLong ( ) ; long temp ; if ( l == r ) { System . out . println ( - 1 ) ; } else { long count = 0 ; long temp ; long temp2 = l ; long temp3 = l ; long count2 = 0 ; boolean flag = true ; while ( temp != 0 ) { temp = temp * 10 + temp2 ; if ( temp != 0 && temp != 9 ) { count ++ ; temp2 = temp * 10 + temp3 ; } if ( temp != 0 && temp != 9 ) { flag = false ; } } if ( flag ) { System . out . println ( count ) ; } else { if ( temp2 >= l && temp2 <= r ) { System . out . println ( - 1 ) ; } else { long temp = temp * 9 ; long temp3 = temp * 9 ; long count = 0 ; while ( temp != 0 ) { temp = temp * 10 + temp3 ; count ++ ; temp3 = temp * 10 + temp4 ; } if ( count > temp ) { System . out . println ( - 1 ) ; } else { long temp4 = temp2 / 10 + temp4 ; long count2 = 0 ; while ( temp != 0 ) { temp4 = temp4 % 10 ; temp = temp2 / 10 ; count2 ++ ; } if ( count > temp ) { System . out . println ( - 1 ) ; } else { long temp = temp * 10 + temp2 ; long temp5 = temp3 / 10 ; temp = temp5 % 10 ; temp = temp5 / 10 ; temp = temp3 % 10 ; temp5 = temp5 / 10 ; temp = temp * 10 + temp4 ; } if ( count > temp ) { System . out . println ( - 1 ) ; } else { System . out . println ( count2 ) ; } } } } } } }
import java . util . Scanner ; public class cf318B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j + 1 ] ; arr [ j + 1 ] = arr [ j ] ; arr [ j ] = temp ; } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . util . * ; public class GFG { static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; i ++ ) { while ( num % i == 0 ) { num /= i ; cnt ++ ; } } if ( num > 1 ) cnt ++ ; return cnt == 2 ; } static void findNumbers ( int N ) { Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) vec . add ( i ) ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) System . out . print ( vec . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 30 ; findNumbers ( N ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; String t ; String [ ] a ; while ( s . hasNext ( ) ) { t = s . nextLine ( ) ; a = s . nextLine ( ) . split ( "11" ) ; if ( t . length == 2 ) { for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; } else if ( t . length == 3 ) { for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "1" ; } else if ( t . length == 4 ) { for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "1" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "1" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "1" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "1" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "1" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; for ( int i = 0 ; i < t . length ; i ++ ) a [ i ] = "0" ; System . out . println (
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int count = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) { for ( int k = 1 ; k <= 9 ; k ++ ) { if ( n - i * j > n ) { count ++ ; } } } System . out . println ( count ) ; } } }
import java . io . * ; public class GFG { static int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) sum = sum + i + ( int ) Math . floor ( n / i ) ; } return sum ; } static boolean areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } public static void main ( String [ ] args ) { int num1 = 559 , num2 = 703 ; if ( areEquivalent ( num1 , num2 ) == true ) System . out . println ( " Equivalent " ) ; else System . out . println ( " Not ▁ Equivalent " ) ; } }
import java . io . * ; public class GFG { static int findY ( int x ) { if ( x > 2 ) return x - 2 ; return x + 2 ; } public static void main ( String [ ] args ) { int x = 5 ; System . out . println ( findY ( x ) ) ; } }
import java . io . * ; public class GFG { static int MOD = 1000000007 ; static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( modFact ( n , m ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int w = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; int [ ] [ ] map = new int [ h ] [ w ] ; int [ ] px = new int [ w ] ; int [ ] py = new int [ h ] ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { map [ i ] [ j ] = sc . nextInt ( ) ; px [ i ] = px [ j ] + 1 ; py [ i ] = py [ j ] - 1 ; } } int ans = 0 ; for ( int i = 0 ; i < w ; i ++ ) { for ( int j = 0 ; j < h ; j ++ ) { if ( map [ i ] [ j ] == 1 ) ans ++ ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } }
import java . io . * ; public class GFG { static float circlearea ( float a , float b ) { if ( a < 0 || b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14f * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 8 , b = 10 ; System . out . println ( circlearea ( a , b ) ) ; } }
import java . util . * ; public class GFG { static void find ( int [ ] arr , int n ) { if ( check ( arr , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } static boolean check ( int [ ] arr , int n ) { for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ i ] == n ) return true ; } for ( int i = 1 ; i < arr . length ; i ++ ) { if ( check ( arr , i ) && check ( arr , i + 1 ) ) return true ; } return false ; } public static void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 4 , 121 } ; find ( arr , 5 ) ; } }
public class GFG { static String K_String ( String s , int k ) { int n = s . length ( ) ; int fre [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - ' a ' ] ++ ; String str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % k == 0 ) { int x = fre [ i ] / k ; while ( x > 0 ) { str += ( char ) ( i + ' a ' ) ; x -- ; } } else return " - 1" ; } return str ; } public static void main ( String [ ] args ) { String s = " aabb " ; int k = 2 ; System . out . println ( K_String ( s , k ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { int n = in . nextInt ( ) ; if ( n == 0 ) return false ; double [ ] [ ] dp = new double [ n + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= j ; k ++ ) { if ( i + j + k <= n ) { dp [ i + 1 ] [ j + k ] += dp [ i ] [ j ] ; if ( solve ( ) ) { out . printf ( " % .6f \n " , j ) ; return true ; } } } } } return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; List < String > ans = new ArrayList < String > ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] input = line . split ( " ▁ " ) ; long a = Long . parseLong ( input [ 0 ] ) ; long b = Long . parseLong ( input [ 1 ] ) ; long n = Long . parseLong ( input [ 2 ] ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long tmp = a % b ; long rem = a % b ; sum = sum + ( tmp * 10 ) ; if ( rem == 0 ) { ans . add ( ans . toString ( ) ) ; } } } for ( String string : ans ) System . out . println ( string ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int ans = 0 ; int l = 0 ; int r = 1 << 18 ; while ( r - l > 1 ) { int mid = l + r ; while ( l < r && a [ mid ] == a [ mid ] ) mid ++ ; if ( mid == 0 ) { r = mid ; } else { l = mid ; } } System . out . println ( r - l ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( n == 0 && k == 0 ) { break ; } int [ ] s = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { b [ i ] = sc . nextInt ( ) ; } } int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { min = Math . min ( min , s [ i ] - b [ i ] ) ; } System . out . println ( min == Integer . MAX_VALUE ? " Yes " : " No " ) ; } } }
import java . util . * ; public class GFG { static int maxFreq ( String s , int a , int b ) { int [ ] fre = new int [ 10 ] ; int n = s . length ( ) ; if ( a > b ) { s = s . substring ( a , b ) ; } for ( int i = 0 ; i < n ; i ++ ) { a = s . charAt ( i ) - '0' ; fre [ a ] ++ ; } if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } public static void main ( String [ ] args ) { int a = 4 , b = 7 ; String s = "47744" ; System . out . println ( maxFreq ( s , a , b ) ) ; } }
import java . io . * ; public class GFG { static int maxZeros ( int n ) { if ( n == 0 || ( n & ( n - 1 ) ) == 0 ) return - 1 ; int setBit = 1 ; int prev = 0 ; for ( int i = 1 ; i < 33 ; i ++ ) { prev ++ ; if ( ( n & setBit ) == setBit ) { setBit = setBit << 1 ; break ; } setBit = setBit << 1 ; } int max0 = Integer . MIN_VALUE ; int cur = prev ; for ( int j = i + 1 ; j < 33 ; j ++ ) { cur ++ ; if ( ( n & setBit ) == setBit ) { if ( max0 < ( cur - prev - 1 ) ) max0 = cur - prev - 1 ; prev = cur ; } setBit = setBit << 1 ; } return max0 ; } public static void main ( String [ ] args ) { int n = 549 ; System . out . println ( maxZeros ( n ) ) ; } }
import java . io . * ; public class GFG { static int sumPowersK ( int n , int k ) { int sum = 0 ; int num = 1 ; while ( num <= n ) { sum += num ; num *= k ; } return sum ; } static int getSum ( int n , int k ) { int pwrK = sumPowersK ( n , k ) ; int sumAll = ( n * ( n + 1 ) ) / 2 ; return ( sumAll - pwrK ) ; } public static void main ( String [ ] args ) { int n = 10 , k = 3 ; System . out . println ( getSum ( n , k ) ) ; } }
import java . io . * ; public class GFG { static void XandYandZintercept ( int A , int B , int C , int D ) { double x = - D / A ; double y = - D / B ; double z = - D / C ; System . out . println ( x + " ▁ " + y + " ▁ " + z ) ; } public static void main ( String [ ] args ) { int A = 2 , B = 5 , C = 7 , D = 8 ; System . out . println ( XandYandZintercept ( A , B , C , D ) ) ; } }
import java . util . * ; public class GFG { static void maxSum ( int arr [ ] , int n ) { int sum = 0 ; Vector < Integer > l = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += Math . abs ( arr [ i ] ) ; if ( arr [ i ] >= 0 ) continue ; if ( i == 0 ) l . add ( i + 1 ) ; else { l . add ( i + 1 ) ; l . add ( i ) ; } } System . out . println ( sum ) ; System . out . print ( l . toString ( ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 4 ; int arr [ ] = { 1 , - 2 , - 3 , 4 } ; maxSum ( arr , n ) ; } }
import java . util . * ; public class GFG { static int MAX = 1000 ; static String replaceSpaces ( String str ) { int i = str . length ( ) ; int space_count = str . indexOf ( ' ▁ ' ) ; if ( space_count > MAX ) return - 1 ; int index = str . length ( ) - 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( str . charAt ( j ) == ' ▁ ' ) { str . setCharAt ( index , '0' ) ; str . setCharAt ( index - 1 , '2' ) ; str . setCharAt ( index - 2 , ' % ' ) ; } else { str . setCharAt ( index , str . charAt ( j ) ) ; str . setCharAt ( j , ' % ' ) ; index -- ; } } return str ; } public static void main ( String [ ] args ) { String str = " Mr ▁ John ▁ Smith ▁ ▁ ▁ " ; str = replaceSpaces ( str ) ; System . out . println ( str ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int d = sc . nextInt ( ) ; int [ ] ans = new int [ n ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = d > 0 ? 1 : 0 ; d -- ; if ( d == 0 ) { count ++ ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ans [ i ] == 0 ) { ans [ i ] = 1 ; count ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 1 ) { System . out . print ( 0 ) ; } else { System . out . print ( 1 ) ; } } } }
import java . io . * ; public class GFG { static boolean check ( int n ) { int m = n ; while ( n != 0 ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n = n / 10 ; } return true ; } static int count ( int l , int r ) { int ans = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( check ( i ) ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int l = 10 , r = 20 ; System . out . println ( count ( l , r ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( a == b ) { System . out . println ( "1 ▁ 10" ) ; } else if ( a > b ) { System . out . println ( " - 1" ) ; } else { System . out . println ( a + " ▁ " + b ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int ans = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = Math . max ( ans , a [ i ] - a [ i - 1 ] + a [ i ] - a [ i - 2 ] ) ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; if ( n % 4 == 0 ) System . out . println ( "4" ) ; else System . out . println ( "0" ) ; } }
import java . util . * ; public class JavaApplication118 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > arrNum = new ArrayList < > ( ) ; ArrayList < Integer > arrPrice = new ArrayList < > ( ) ; int num = sc . nextInt ( ) ; String s = sc . next ( ) ; int counter = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) >= '0' && s . charAt ( i ) <= '9' ) { arrNum . add ( i ) ; } } for ( int i = 0 ; i < arrNum . size ( ) ; i ++ ) { int n = s . charAt ( i ) - '0' ; arrNum . add ( n ) ; counter ++ ; } if ( counter >= num ) { System . out . println ( counter ) ; } else { System . out . println ( 0 ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int ans = 0 ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % k == 0 ) { c = i + a ; if ( c >= n ) { ans = i ; break ; } } else { c = i ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int digSum ( int n ) { int sum = 0 ; while ( n > 0 || sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n = n / 10 ; } return sum ; } public static void main ( String [ ] args ) { int n = 1234 ; System . out . println ( digSum ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; sc . nextLine ( ) ; String s = sc . nextLine ( ) ; String t = sc . nextLine ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( s . charAt ( i ) == t . charAt ( j ) ) { dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] - 1 ) ; if ( i >= 0 && j < m ) dp [ i ] [ j + 1 ] = Math . max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) ; } else { dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] - 1 ) ; if ( j >= 0 && s . charAt ( i ) == t . charAt ( j ) ) dp [ i ] [ j + 1 ] = Math . max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) ; } } } int ans = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int centered_heptagonal_num ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( n + " th ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ " ) ; System . out . println ( centered_heptagonal_num ( n ) ) ; } }
import java . util . * ; public class GFG { static int missingNum ( int arr [ ] , int n ) { int minvalue = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = arr . length ; System . out . println ( missingNum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static String smallestPermute ( int n ) { String res = " " ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res += ( char ) ( ' a ' + i + 2 ) ; else res += ( char ) ( ' a ' + i ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res += ( char ) ( ' a ' + i + 2 ) ; else res += ( char ) ( ' a ' + i ) ; } res . replace ( n - 1 , ( char ) ( ' a ' + n - 2 ) , ( char ) ( ' a ' + n ) ) ; res . replace ( n - 2 , ( char ) ( ' a ' + n - 3 ) , ( char ) ( ' a ' + n - 1 ) ) ; } return res ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( smallestPermute ( n ) ) ; } }
import java . util . * ; public class GFG { static int minOperations ( int a [ ] , int n , int K ) { HashMap < Integer , Boolean > Map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Map . containsKey ( a [ i ] ) ) return 0 ; Map . put ( a [ i ] , true ) ; } Vector < Integer > b = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) b . add ( a [ i ] & K ) ; Map . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b . get ( i ) ) Map . put ( b . get ( i ) , true ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( Map . containsKey ( a [ i ] ) ) return 1 ; Map . put ( a [ i ] , true ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( Map . containsKey ( b [ i ] ) ) return 2 ; Map . put ( b [ i ] , true ) ; } return - 1 ; } public static void main ( String [ ] args ) { int K = 3 ; int a [ ] = { 1 , 2 , 3 , 7 } ; int n = a . length ; System . out . println ( minOperations ( a , n , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } char [ ] [ ] map ; int count ; int w , h ; public void run ( ) { Scanner scan = new Scanner ( System . in ) ; while ( scan . hasNext ( ) ) { w = scan . nextInt ( ) ; h = scan . nextInt ( ) ; if ( w == 0 && h == 0 ) { break ; } map = new char [ h ] [ w ] ; count = 0 ; for ( int i = 0 ; i < h ; i ++ ) { map [ i ] = scan . next ( ) . toCharArray ( ) ; } count = 0 ; for ( int i = 0 ; i < w ; i ++ ) { for ( int j = 0 ; j < h ; j ++ ) { if ( map [ i ] [ j ] == ' # ' ) { count ++ ; map [ i ] [ j ] = ' . ' ; } else if ( map [ i ] [ j ] == ' W ' ) { count ++ ; map [ i ] [ j ] = ' B ' ; } else if ( map [ i ] [ j ] == ' B ' ) { count ++ ; map [ i ] [ j ] = ' . ' ; } } } System . out . println ( count + " ▁ " + count ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; if ( n <= 60 ) { System . out . println ( " NO " ) ; } else { if ( n <= 270 ) { System . out . println ( " YES " ) ; } else { if ( n % 360 == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } } }
import java . util . * ; public final class p075 { public static void main ( String [ ] args ) { System . out . println ( new p075 ( ) . run ( ) ) ; } private static final int NUM_COLORS = 7 ; private static final int BALLS_PER_COLOR = 10 ; private static final int DECIMALS = 9 ; private List < Library > hist = new ArrayList < Library > ( ) ; private BigInteger numerator = BigInteger . ZERO ; private BigInteger denominator = BigInteger . ZERO ; private BigInteger numerator = BigInteger . ZERO ; private BigInteger divideExactly ( BigInteger x , BigInteger y ) { if ( remain == 0 ) { hist . add ( new Library ( ) ) ; while ( hist . size ( ) < NUM_COLORS ) hist . add ( 0 ) ; int histogram [ ] = new int [ BALLS_PER_COLOR + 1 ] ; for ( int x : hist ) histogram [ x ] ++ ; int count = factorial ( NUM_COLORS ) ; for ( int x : hist ) count = divideExactly ( count , Library . binomial ( BALLS_PER_COLOR , x ) ) ; for ( int x : hist ) count *= divideExactly ( count , Library . binomial ( BALLS_PER_COLOR , x ) ) ; distinctcolors = hist . size ( ) ; numerator = numerator . add ( count * distinctcolors ) ; } else if ( hist . size ( ) < NUM_COLORS ) { for ( int i = Math . min ( limit , remain ) ; i >= 0 ; i -- ) { history . add ( i ) ; explore ( remain - i , i , history ) ; } } return new BigInteger ( numerator . toString ( ) . substring ( 0 , digits + 1 ) ) ; } private BigInteger factorial ( int remain ) { BigInteger count = BigInteger . ZERO ; for ( int x : hist ) count = divideExactly ( count , Library . binomial ( BALLS_PER_COLOR , NUM_PICKED ) . multiply ( BigInteger . valueOf ( x ) ) ; return count ; } private BigInteger divideExactly ( BigInteger x , BigInteger y ) { if ( x . mod ( y ) . compareTo ( BigInteger . ZERO ) ) throw new IllegalArgumentException ( " Not ▁ divisible " ) ; return divideExactly ( x , y ) ; } private BigInteger divide ( BigInteger x , BigInteger y ) {
import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int s = scanner . nextInt ( ) ; int h = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; int i = 0 ; while ( i < n ) { i ++ ; m += i % 60 ; if ( m <= s ) { System . out . println ( ( h + m ) / 60 + " ▁ " + ( m + 1 ) % 60 ) ; break ; } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; if ( b == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; System . out . println ( a + " ▁ " + ( a * b ) + " ▁ " + ( a * b + a ) ) ; } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; while ( true ) { String [ ] input = scanner . nextLine ( ) . split ( " ▁ " ) ; String r = input [ 0 ] ; String a = input [ 1 ] ; if ( r . equals ( "0" ) ) { break ; } int h = 0 ; for ( int i = 0 ; i < Math . min ( r . length ( ) , a . length ( ) ) ; i ++ ) { if ( r . charAt ( i ) == a . charAt ( i ) ) { h ++ ; } } int b = - h ; for ( int i = 0 ; i < r . length ( ) ; i ++ ) { if ( a . contains ( Character . toString ( r . charAt ( i ) ) ) ) { b ++ ; } } System . out . println ( h + " ▁ " + b ) ; } scanner . close ( ) ; } }
public class Main { public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 9 , 2 , 20 } ; int n = arr . length ; int MIN = - 100000000 ; System . out . println ( findMaxValue ( arr , n , MIN ) ) ; } public static int findMaxValue ( int [ ] arr , int n , int MIN ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have ▁ at ▁ least ▁ 4 ▁ elements " ) ; return MIN ; } int [ ] table1 = new int [ n + 1 ] ; int [ ] table2 = new int [ n ] ; int [ ] table3 = new int [ n - 1 ] ; int [ ] table4 = new int [ n - 2 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; } for ( int i = n - 4 ; i >= 0 ; i -- ) { table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; } return table4 [ 0 ] ; } }
import java . io . * ; public class GFG { static void centeredHexagonalSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( 3 * i * ( i - 1 ) + 1 + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 10 ; centeredHexagonalSeries ( n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; String result = " No " ; for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) == ' A ' && s . charAt ( i + 1 ) == ' B ' && s . charAt ( i + 2 ) == ' C ' ) { result = " Yes " ; break ; } } System . out . println ( result ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int left = 0 ; int right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; if ( s . charAt ( 0 ) == ' B ' ) { left ++ ; } else { right ++ ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( left == 0 ) { ans ++ ; } left -- ; } for ( int i = 0 ; i < n ; i ++ ) { if ( right == 0 ) { ans ++ ; } right ++ ; } System . out . println ( ans + " ▁ " + right ) ; } }
import java . io . * ; public class GFG { static void diagonalsMinMax ( int mat [ ] [ ] ) { if ( mat . length == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( i == j ) { if ( mat [ i ] [ j ] < principalMin ) principalMin = mat [ i ] [ j ] ; if ( mat [ i ] [ j ] > principalMax ) principalMax = mat [ i ] [ j ] ; } if ( ( i + j ) == ( n - 1 ) ) { if ( mat [ i ] [ j ] < secondaryMin ) secondaryMin = mat [ i ] [ j ] ; if ( mat [ i ] [ j ] > secondaryMax ) secondaryMax = mat [ i ] [ j ] ; } } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMax ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( mat ) ; } }
import java . io . * ; public class GFG { static int n = 5 ; static void diagonalsMinMax ( int mat [ ] [ ] ) { if ( n == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] < principalMin ) principalMin = mat [ i ] [ i ] ; if ( mat [ i ] [ i ] > principalMax ) principalMax = mat [ i ] [ i ] ; if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) secondaryMin = mat [ n - 1 - i ] [ i ] ; if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) secondaryMax = mat [ n - 1 - i ] [ i ] ; } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMax ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( mat ) ; } }
import java . io . * ; public class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } int sum = 0 ; int count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n -= 2 ; } return sum / count ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }
import java . io . * ; public class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }
import java . util . * ; public class GFG { static boolean areElementsContiguous ( int arr [ ] ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { us . add ( arr [ i ] ) ; } int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( curr_ele != 0 && us . contains ( curr_ele ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( curr_ele != 0 && us . contains ( curr_ele ) ) { count ++ ; curr_ele ++ ; } return ( count == us . size ( ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; if ( areElementsContiguous ( arr ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static ArrayList < Integer > zero = new ArrayList < > ( ) ; static ArrayList < Integer > one = new ArrayList < > ( ) ; static void getLeftMostZero ( ) { if ( zero . size ( ) == 0 ) return - 1 ; zero . add ( 0 ) ; return ; } static void getLeftMostOne ( ) { if ( one . size ( ) == 0 ) return - 1 ; one . remove ( 0 ) ; return ; } static int getLeftMostElement ( ) { if ( zero . size ( ) == 0 && one . size ( ) == 0 ) return 1 ; else if ( zero . size ( ) > one . size ( ) ) zero . add ( one . remove ( 0 ) ) ; else one . add ( zero . removeFirst ( ) ) ; return res ; } static void performQueries ( int arr [ ] , int n , int queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int type = queries [ i ] ; if ( type == 1 ) System . out . println ( getLeftMostZero ( ) ) ; else if ( type == 2 ) System . out . println ( getLeftMostOne ( ) ) ; else if ( type == 3 ) System . out . println ( getLeftMostElement ( ) ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 1 , 1 } ; int n = arr . length ; int queries [ ] = { 1 , 3 , 1 } ; int q = queries . length ; performQueries ( arr , n , queries , q ) ; } }
public class GFG { static void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; if ( x < 0 ) x = - 1 ; else x = 1 ; System . out . print ( val * x + " ▁ " ) ; if ( y < 0 ) y = - 1 ; else y = 1 ; System . out . print ( "0" + val * y ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 3 ; Vertices ( x , y ) ; } }
import java . util . * ; public class GFG { static void getSum ( int a [ ] , int n ) { int P [ ] = new int [ n ] ; P [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) P [ i ] = a [ i ] + P [ i - 1 ] ; int S = P [ n - 1 ] ; HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . put ( P [ i ] , 1 ) ; for ( int i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { boolean pres = true ; int div1 = i ; int div2 = S / i ; for ( int j = div1 ; j <= S ; j += div1 ) { if ( hash . get ( j ) == null ) { pres = false ; break ; } } if ( pres && div1 != S ) { res . add ( div1 ) ; } pres = true ; for ( int j = S / i ; j <= S ; j += S / i ) { if ( hash . get ( j ) == null ) { pres = false ; break ; } } if ( pres && div2 != S ) { res . add ( div2 ) ; } } } if ( res . size ( ) == 0 ) { System . out . print ( " - 1" ) ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 1 , 1 , 1 , 2 , 1 , 3 } ; int n = a . length ; getSum ( a , n ) ; } }
import java . util . * ; public class GFG { static void originalArray ( int greater [ ] , int n ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) temp . add ( i ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = n - greater [ i ] - i ; arr [ i ] = temp . get ( k ) ; temp . remove ( k ) ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 3 , 2 , 1 , 0 , 1 , 0 } ; int n = arr . length ; originalArray ( arr , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int n = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String t = sc . next ( ) ; int l = 0 ; int r = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( t . charAt ( j ) == s . charAt ( l ) ) l ++ ; else if ( t . charAt ( j ) == s . charAt ( l ) ) r ++ ; else { if ( l > r ) { ans = r - l ; } l = 0 ; r = 0 ; } } } System . out . println ( ans ) ; } }
import java . util . * ; public class Solution { public int findRadius ( int [ ] houses , int [ ] heaters ) { Arrays . sort ( heaters ) ; int i = 0 , r = 0 ; for ( int x : heaters ) { while ( x <= sum / 2. ) i ++ ; r = Math . max ( r , Math . abs ( heaters [ i ] - x ) ) ; } return r ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] houses = { 1 , 2 , 3 } ; int [ ] heaters = { 2 } ; int out = sObj . findRadius ( houses , heaters ) ; System . out . println ( out ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; int pow = 1 ; for ( int i = 7 ; ; i = i + 25 ) { if ( sum % i != 0 || n % 5 == 0 ) return Integer . toString ( i ) ; } return Integer . toString ( sum ) ; } private static int sum ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; sum = ( sum + pow ) % n ; } return k ; } }
import java . io . * ; public class GFG { static int res = 0 ; static int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) Math . floor ( Math . pow ( num , ( 1 / n ) ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) Math . pow ( i , n ) , i , n ) ; } return res ; } static int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; } public static void main ( String [ ] args ) { System . out . println ( check ( 10 , 2 ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int [ ] a = new int [ 4 ] ; a [ 0 ] = 7 ; a [ 1 ] = 7 ; a [ 2 ] = 7 ; a [ 3 ] = 7 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( s . charAt ( i ) == '7' ) { a [ 0 ] += a [ 1 ] ; } else if ( s . charAt ( i ) == ' + ' ) { a [ 1 ] += a [ 0 ] ; } else if ( s . charAt ( i ) == ' - ' ) { a [ 2 ] -= a [ 1 ] ; } else if ( s . charAt ( i ) == ' + ' ) { a [ 0 ] += a [ 1 ] ; } else { a [ 1 ] += a [ 2 ] ; } } int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 7 ) { System . out . print ( a [ i ] ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; double [ ] [ ] dp = new double [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; } dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k <= j ; k ++ ) { if ( k + a [ j ] <= b [ k ] ) { dp [ j ] [ k ] = Math . max ( dp [ j ] [ k ] , dp [ j ] [ k ] + a [ j ] ) ; } else { dp [ j ] [ k ] = Math . max ( dp [ j ] [ k ] , dp [ j ] [ k ] ) ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( dp [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } }
import java . util . * ; public class Test3 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } System . out . println ( sum + n ) ; } }
public class GFG { static boolean prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void thirdNumber ( int a , int b ) { int summ = 0 , temp = 0 ; summ = a + b ; temp = 1 ; if ( ( summ & 1 ) == 1 ) temp = 2 ; while ( ! prime ( summ + temp ) ) temp += 2 ; System . out . println ( temp ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 5 ; thirdNumber ( a , b ) ; } }
import java . io . * ; public class GFG { static int Squares ( int n , int m , int a ) { return ( ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ) ; } public static void main ( String [ ] args ) { int n = 6 , m = 6 , a = 4 ; System . out . println ( Squares ( n , m , a ) ) ; } }
import java . util . Scanner ; public class D { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; System . out . println ( solve ( n , m ) ? " YES " : " NO " ) ; } sc . close ( ) ; } static boolean solve ( int n , int m ) { return ( n <= 6 && n % m == 0 ) ; } }
import java . io . * ; public class GFG { static int countCubes ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j * j * j > i ) break ; if ( j * j * j == i ) cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int a = 7 , b = 30 ; System . out . println ( " Count ▁ of ▁ Cubes ▁ is ▁ " + countCubes ( a , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] count = new int [ 100001 ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; count [ a [ i ] ] ++ ; } for ( int i = 0 ; i < 100001 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( count [ j ] == 0 ) { count [ j ] = 1 ; } } } int ans = n ; if ( count [ 0 ] > 0 && count [ 1 ] > 0 ) { ans = n - count [ 0 ] - count [ 1 ] ; } else if ( count [ 0 ] == 0 && count [ 1 ] > 0 ) { ans = n / 2 ; } System . out . println ( ans ) ; } }
public class GFG { static void subString ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int len = i + 1 ; len <= n ; len ++ ) System . out . println ( s . substring ( i , len ) ) ; } } public static void main ( String [ ] args ) { String s = " abcd " ; subString ( s , s . length ( ) ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void countPrimePosition ( int arr [ ] ) { int c0 = 0 , c1 = 0 ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 && isPrime ( i ) ) c0 ++ ; if ( arr [ i ] == 1 && isPrime ( i ) ) c1 ++ ; } System . out . println ( " Number ▁ of ▁ 0s ▁ = ▁ " + c0 ) ; System . out . println ( " Number ▁ of ▁ 1s ▁ = ▁ " + c1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; countPrimePosition ( arr ) ; } }
import java . io . * ; public class GFG { static void angleextcycquad ( int z ) { System . out . print ( " The ▁ exterior ▁ angle ▁ of ▁ the " + " ▁ " ) ; System . out . print ( " cyclic ▁ quadrilateral ▁ is ▁ " ) ; System . out . print ( z + " ▁ degrees " ) ; } public static void main ( String [ ] args ) { int z = 48 ; angleextcycquad ( z ) ; } }
import java . io . * ; public class GFG { static void printMinIndexChar ( String str , String patt ) { int minIndex = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != Integer . MAX_VALUE ) { System . out . println ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str . charAt ( minIndex ) ) ; } else System . out . println ( " No ▁ character ▁ present " ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; String patt = " set " ; printMinIndexChar ( str , patt ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = 0 , b = 0 ; while ( n -- > 0 ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; if ( a == b ) { System . out . println ( " Poor ▁ Alex " ) ; return ; } } System . out . println ( " Happy ▁ Alex " ) ; } }
public class Main { public static int maxnumber ( int n , int k ) { int ans = 0 ; for ( int j = 0 ; j < k ; j ++ ) { int i = 1 ; while ( n / i > 0 ) { int temp = ( n / ( i * 10 ) ) * i + ( n % i ) ; i *= 10 ; if ( temp > ans ) { ans = temp ; } } n = ans ; } return ans ; } public static void main ( String [ ] args ) { int n = 6358 ; int k = 1 ; System . out . println ( maxnumber ( n , k ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ m ] ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; } int [ ] c = new int [ n + 1 ] ; for ( int i = n ; i >= 1 ; i -- ) { c [ i ] = Math . max ( c [ i ] , a [ i - 1 ] + b [ i ] ) ; } int maxi = 0 , max = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( c [ i ] == 0 ) { maxi ++ ; } else { c [ i ] = c [ i - 1 ] + a [ i - 1 ] ; max = Math . max ( max , c [ i ] ) ; } } int [ ] ans = new int [ n + 1 ] ; int k = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( c [ i ] == 0 ) { ans [ k ] = i ; k ++ ; } else { ans [ k ] = maxi ; max = Math . max ( max , ans [ i ] ) ; k ++ ; } } int maxi = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( c [ i ] == 0 ) { ans [ i ] = maxi ; maxi = i ; } } int ans1 = 0 ; int ans2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ] == max ) { ans1 ++ ; } else if ( ans [ i ] == max ) { ans2 ++ ; } } System . out . println ( ans1 + " ▁ " + ans2 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { a [ i ] += a [ i ] ; ans += Math . abs ( a [ i ] ) + 1 ; } else { b [ i ] += a [ i ] ; ans += Math . abs ( b [ i ] ) + 1 ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int get_last_two_digit ( int N ) { if ( N <= 10 ) { int ans = 0 ; int fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = fac * i ; ans = ans % 100 ; return ans ; } else return 13 ; } public static void main ( String [ ] args ) { int N = 1 ; for ( N = 1 ; N <= 10 ; N ++ ) System . out . println ( " For ▁ N ▁ = ▁ " + N + " : ▁ " + get_last_two_digit ( N ) ) ; } }
import java . io . * ; public class GFG { public static void main ( String [ ] args ) { String binaryNumber = "1001" ; System . out . println ( binaryNumber ) ; } }
import java . io . * ; public class GFG { static boolean isPossible ( double x , double y , double z ) { double a = x * x + y * y + z * z ; a = Math . round ( a , 8 ) ; if ( ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { double l = 0.70710678 ; double m = 0.5 ; double n = 0.5 ; if ( isPossible ( l , m , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static int MAX = 1000000 ; static int MOD = 1000000007 ; static int result [ ] = new int [ MAX + 1 ] ; static int fact [ ] = new int [ MAX + 1 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } static void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; } public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; long arr [ ] = new long [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextLong ( ) ; } Arrays . sort ( arr ) ; long ans = arr [ n - 1 ] ; long sum1 = arr [ n - 1 ] ; for ( int j = 1 ; j < n ; j ++ ) { if ( j == 1 ) { sum1 += arr [ j ] ; } else { sum1 += arr [ j - 1 ] - arr [ j ] ; } } ans = Math . min ( ans , sum1 ) ; } System . out . println ( ans ) ; } } }
import java . io . * ; public class GFG { static int segregate ( int arr [ ] , int size ) { int j = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j ++ ; } } return j ; } static int findMissingPositive ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { if ( Math . abs ( arr [ i ] ) - 1 < size && arr [ Math . abs ( arr [ i ] ) - 1 ] > 0 ) { arr [ Math . abs ( arr [ i ] ) - 1 ] = - arr [ Math . abs ( arr [ i ] ) - 1 ] ; } } for ( int i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; } static int findMissing ( int arr [ ] , int size ) { int shift = segregate ( arr , size ) ; return findMissingPositive ( arr , size - shift ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 10 , 2 , - 10 , - 20 } ; int arr_size = arr . length ; int missing = findMissing ( arr , arr_size ) ; System . out . println ( " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " + missing ) ; } }
import java . io . * ; public class GFG { static int mod = 1000000007 ; static int digitNumber ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } public static void main ( String [ ] args ) { int d = 9 ; int n = 3 ; System . out . println ( countExcluding ( n , d ) ) ; } }
import java . util . Scanner ; public class A1334 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; int c [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = in . nextInt ( ) ; } int min = a [ 0 ] + b [ 1 ] ; if ( min > a [ n - 1 ] ) { System . out . println ( - 1 ) ; } else { System . out . println ( 1 + " ▁ " + 2 + " ▁ " + n ) ; } } } }
public class GFG { static void convert12 ( String str ) { int h1 = str . charAt ( 0 ) - '0' ; int h2 = str . charAt ( 1 ) - '0' ; int hh = h1 * 10 + h2 ; String Meridien ; if ( hh < 12 )Meridien = " AM " ; elseMeridien = " PM " ; hh %= 12 ; if ( hh == 0 ) { System . out . print ( "12" ) ; for ( int i = 2 ; i < 8 ; i ++ ) System . out . print ( str . charAt ( i ) ) ; } else { System . out . print ( hh ) ; for ( int i = 2 ; i < 8 ; i ++ ) System . out . print ( str . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String str = "17:35:20" ; convert12 ( str ) ; } }
import java . util . * ; public class GFG { static boolean check ( String s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i % k ) ) return false ; } return true ; } static int countCommonDivisors ( String a , String b ) { int ct = 0 ; int n = a . length ( ) ; int m = b . length ( ) ; for ( int i = 1 ; i <= Math . min ( n , m ) ; i ++ ) { if ( n % i == 0 && m % i == 0 ) { if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) { if ( check ( a , i ) && check ( b , i ) ) ct ++ ; } } } return ct ; } public static void main ( String [ ] args ) { String a = " xaxa " ; String b = " xaxaxaxa " ; System . out . println ( countCommonDivisors ( a , b ) ) ; } }
import java . util . * ; public class GFG { static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; int w = W ; for ( int i = n ; i >= 1 ; i -- ) { if ( res <= 0 ) break ; if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . println ( wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } public static void main ( String [ ] args ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; printknapSack ( W , wt , val , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { a [ i ] [ j ] = sc . nextInt ( ) ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( a [ i ] [ j ] == a [ i ] [ j + 1 ] ) { if ( a [ i ] [ 0 ] == a [ i ] [ 1 ] ) { count ++ ; } } } } System . out . println ( count ) ; } }
public class Main { public static void indexedSequentialSearch ( int [ ] arr , int n , int k ) { int [ ] elements = new int [ 20 ] ; int [ ] indices = new int [ 20 ] ; int j = 0 , ind = 0 ; for ( int i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { System . out . println ( " Not ▁ found " ) ; System . exit ( 0 ) ; } else { int start = 0 , end = 0 ; for ( int i = 1 ; i < ind + 1 ; i ++ ) { if ( k < elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; break ; } } int i = 0 ; for ( i = start ; i < end + 1 ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) { System . out . println ( " Found ▁ at ▁ index ▁ " + i ) ; } else { System . out . println ( " Not ▁ found " ) ; } } } public static void main ( String [ ] args ) { int [ ] arr = { 6 , 7 , 8 , 9 , 10 } ; int n = arr . length ; int k = 8 ; indexedSequentialSearch ( arr , n , k ) ; } }
import java . io . * ; public class GFG { static int larrgestPalindrome ( int n ) { int upper_limit = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { upper_limit = upper_limit * 10 ; upper_limit = upper_limit + 9 ; } int lower_limit = 1 + upper_limit / 10 ; int max_product = 0 ; for ( int i = upper_limit ; i >= 1 ; i -- ) { for ( int j = i ; j < lower_limit ; j ++ ) { int product = i * j ; if ( product < max_product ) break ; int number = product ; int reverse = 0 ; while ( number != 0 ) { reverse = reverse * 10 + number % 10 ; number = number / 10 ; } if ( product == reverse && product > max_product ) { max_product = product ; } } } return max_product ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( larrgestPalindrome ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > b [ 0 ] ) { b [ 0 ] = a [ i ] ; c [ 0 ] = b [ i ] ; } else { b [ 1 ] = c [ i ] ; c [ i ] = c [ i - 1 ] ; } } int count = 0 ; Arrays . sort ( b ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( c [ i ] == b [ i + 1 ] ) { count ++ ; } } System . out . println ( count ) ; } }
import java . util . Scanner ; public class Problem1481B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; int [ ] arr = new int [ 7 ] ; for ( int i = 0 ; i < t ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; arr [ 0 ] = a - 1 ; arr [ 1 ] = b - 1 ; arr [ 2 ] = c - 1 ; if ( arr [ 0 ] == 1 && arr [ 1 ] == 1 && arr [ 2 ] == 1 ) { System . out . println ( 0 ) ; } else if ( arr [ 0 ] == 1 && arr [ 1 ] == 1 && arr [ 2 ] == 1 ) { System . out . println ( 1 ) ; } else if ( arr [ 0 ] == 1 && arr [ 1 ] == 2 && arr [ 2 ] == 3 ) { System . out . println ( 2 ) ; } else if ( arr [ 0 ] == 1 && arr [ 1 ] == 1 && arr [ 2 ] == 2 ) { System . out . println ( 3 ) ; } else { int l = arr [ 0 ] - 1 ; int r = arr [ 1 ] - 1 ; int min = Math . min ( l , r ) ; int count = 0 ; if ( l <= r ) { count += 2 ; } else { count += 1 ; } if ( r <= l && r <= r ) { count += 1 ; } } if ( l <= r && r <= s ) { System . out . println ( count + 1 ) ; } else { System . out . println ( count + 2 ) ; } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = input . nextInt ( ) ; } int [ ] diff = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff [ i ] = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } int [ ] [ ] dp = new int [ n - 1 ] [ 3 ] ; dp [ 0 ] [ 1 ] = diff [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 2 ] + diff [ i ] , diff [ i ] ) ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - diff [ i ] ; } System . out . println ( Math . max ( dp [ n - 2 ] [ 0 ] , Math . max ( dp [ n - 2 ] [ 1 ] , dp [ n - 2 ] [ 2 ] ) ) ) ; } }
import java . util . * ; public class GFG { static int maximumXor ( int arr [ ] , int n ) { Stack < Integer > sForward = new Stack < Integer > ( ) , sBackward = new Stack < Integer > ( ) ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! sForward . empty ( ) && arr [ i ] < arr [ sForward . peek ( ) ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward . peek ( ) ] ) ; sForward . pop ( ) ; } sForward . push ( i ) ; while ( ! sBackward . empty ( ) && arr [ n - i - 1 ] < arr [ sBackward . peek ( ) ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward . peek ( ) ] ) ; sBackward . pop ( ) ; } sBackward . push ( n - i - 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 1 , 2 } ; int n = arr . length ; System . out . println ( maximumXor ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ++ ] = ( char ) ( temp + 48 ) ; } else { hexaDeciNum [ i ++ ] = ( char ) ( temp + 55 ) ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; } public static void main ( String [ ] args ) { int n = 2545 ; decToHexa ( n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ 100001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; a [ x ] ++ ; } int max = 0 ; for ( int i = 2 ; i < a . length ; i ++ ) { if ( a [ i - 1 ] > max ) { max = a [ i - 1 ] ; } } System . out . println ( max ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int h = sc . nextInt ( ) , w = sc . nextInt ( ) ; if ( ( h | w ) == 0 ) break ; HashMap < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < h ; i ++ ) { String s = sc . next ( ) ; for ( int j = 0 ; j < w ; j ++ ) { map . put ( s . charAt ( j ) , i ) ; } } String str = sc . next ( ) ; int sum = 0 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { int dist = map . get ( s . charAt ( j ) ) ; sum += dist + 1 ; } } System . out . println ( sum ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a + b ) ; } }
public class GFG { static int extractMaximum ( String str ) { int num = 0 , res = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) num = num * 10 + ( str . charAt ( i ) - 0 ) ; else { res = Math . max ( res , num ) ; num = 0 ; } } return Math . max ( res , num ) ; } public static void main ( String [ ] args ) { String str = "100klh564abc365bg " ; System . out . println ( extractMaximum ( str ) ) ; } }
import java . io . * ; public class GFG { static int max = 50009 ; static void find_Indices ( int arr [ ] , int n ) { int sum [ ] = new int [ max ] ; int k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ k ] ; k ++ ; } int ans = Integer . MIN_VALUE ; int index_1 = index_2 = index_3 = - 1 ; for ( int l = 0 ; l <= n ; l ++ ) { int index = 0 ; int vmin = Integer . MAX_VALUE ; for ( int r = l ; r <= n ; r ++ ) { if ( sum [ r ] < vmin ) vmin = sum [ r ] ; index = r ; if ( sum [ l ] + sum [ r ] - vmin > ans ) { ans = sum [ l ] + sum [ r ] - vmin ; index_1 = l ; index_2 = index ; index_3 = r ; } } } System . out . println ( index_1 + " ▁ " + index_2 + " ▁ " + index_3 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , 3 } ; int n = arr . length ; find_Indices ( arr , n ) ; } }
import java . io . * ; public class GFG { static void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; int n = arr . length ; printElements ( arr , n ) ; } }
import java . io . * ; public class GFG { static int valueofX ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; return sum / n ; } public static void main ( String [ ] args ) { int n = 7 ; int arr [ ] = { 6 , 9 , 1 , 6 , 1 , 3 , 7 } ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( ar [ i ] - a ) * ( ar [ i ] - a ) ; int A = sum / n ; int B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) return A ; else return B ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr [ i ] ; j ++ ) { if ( arr [ i ] == 1 ) { count ++ ; } } if ( count > n - m ) { count = 1 ; } } System . out . println ( count ) ; } } }
import java . util . Scanner ; public class B_Equivalent_Strings { static Scanner in = new Scanner ( System . in ) ; static int n , m ; static String s ; static boolean equ ( char x , char y ) { if ( y == ' * ' || x == ' * ' ) return true ; else if ( y == ' * ' || x == ' * ' ) return false ; else { if ( n % 2 == 0 ) return false ; else { if ( x == ' * ' ) return true ; else return false ; } } } public static void main ( String [ ] amit ) { s = in . next ( ) . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) != s . charAt ( j ) ) count ++ ; } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static int findNth ( int n ) { int count = 0 ; int curr = 19 ; while ( true ) { int sum = 0 ; int x = curr ; while ( x > 0 ) { sum = sum + x % 10 ; x = x / 10 ; } if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; curr += 9 ; } return - 1 ; } public static void main ( String args [ ] ) { System . out . println ( findNth ( 5 ) ) ; } }
import java . util . * ; public class GFG { static int findNth ( int n ) { int count = 0 ; for ( int curr = - 1 ; ; curr = ++ count ) { int sum = 0 ; int x = curr ; while ( x > 0 ) { sum = sum + x % 10 ; x = x / 10 ; } if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; } public static void main ( String [ ] args ) { System . out . println ( findNth ( 5 ) ) ; } }
import java . io . * ; public class GFG { static int countNumber ( int N , int S ) { int countElements = 0 ; int currentSum = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N = N - 1 ; countElements ++ ; } return countElements ; } public static void main ( String [ ] args ) { int N = 5 , S = 11 ; int count = countNumber ( N , S ) ; System . out . println ( count ) ; } }
import java . util . * ; public class GFG { static boolean strrmatch ( String str , String pattern , int n , int m ) { if ( m == 0 ) return ( n == 0 ) ; boolean [ ] [ ] lookup = new boolean [ n + 1 ] [ m + 1 ] ; lookup [ 0 ] [ 0 ] = true ; for ( int j = 1 ; j <= m ; j ++ ) { if ( pattern . charAt ( j - 1 ) == ' * ' ) lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( pattern . charAt ( j - 1 ) == ' * ' ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] || lookup [ i - 1 ] [ j ] ; else if ( pattern . charAt ( j - 1 ) == ' ? ' || str . charAt ( i - 1 ) == pattern . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] ; else lookup [ i ] [ j ] = false ; } } return lookup [ n ] [ m ] ; } public static void main ( String [ ] args ) { String str = " baaabab " ; String pattern = " * * * * * ba * * * * ab " ; if ( strrmatch ( str , pattern , str . length ( ) , pattern . length ( ) , str . length ( ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . PriorityQueue ; import java . util . Queue ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { StringTokenizer st = new StringTokenizer ( line ) ; long x , y ; x = parseInt ( st . nextToken ( ) ) ; y = parseInt ( st . nextToken ( ) ) ; if ( ( x | y ) == 0 ) break ; long a , b , z , x_max , y_max ; a = x_max = y_max = 0 ; b = y_max = 0 ; for ( long i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { z = i ; break ; } } for ( long i = 2 ; i * i <= y ; i ++ ) { if ( y % i == 0 ) { break ; } x_max = Math . max ( x_max , i ) ; } long y_max = Math . max ( y_max , y ) ; z_max = Math . max ( z_max , x ) ; if ( z_max > y ) { System . out . println ( " b " ) ; } else { System . out . println ( " a " ) ; } } } }
import java . util . * ; public class GFG { static double nCr ( int n , int r ) { double fac [ ] = new double [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; double ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) ; return ans ; } public static void main ( String [ ] args ) { int n = 3 , k = 3 ; double ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int max = 0 , min = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; if ( a [ i ] > max ) { max = a [ i ] ; } } if ( max == 0 ) { System . out . println ( min + " ▁ " + max ) ; } else { System . out . println ( max - min + " ▁ " + min ) ; } } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int powGCD ( int a , int n , int b ) { for ( int i = 0 ; i <= n ; i ++ ) a = a * a ; return gcd ( a , b ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 5 , n = 2 ; System . out . println ( powGCD ( a , n , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '8' ) count ++ ; } System . out . println ( Math . min ( n / 11 , Math . min ( count , ( n - count ) / 11 ) ) ) ; } }
import java . io . * ; public class GFG { static int sumOfDigit ( int n , int b ) { int unitDigit = 0 ; int sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; } public static void main ( String [ ] args ) { int n = 50 ; int b = 2 ; System . out . println ( sumOfDigit ( n , b ) ) ; } }
import java . io . * ; public class GFG { static void printLargestDivisible ( int n , int a [ ] ) { int c0 = 0 , c5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) c0 ++ ; else c5 ++ ; } c5 = ( int ) Math . floor ( c5 / 9 ) * 9 ; if ( c0 == 0 ) System . out . print ( - 1 ) ; else if ( c5 == 0 ) System . out . print ( 0 ) ; else { for ( int i = 0 ; i < c5 ; i ++ ) System . out . print ( 5 ) ; for ( int i = 0 ; i < c0 ; i ++ ) System . out . print ( 0 ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 } ; int n = a . length ; printLargestDivisible ( n , a ) ; } }
import java . io . * ; public class GFG { static int countWays ( int n ) { int counter = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { for ( int l = k ; l < n ; l ++ ) { if ( i + j + k + l == n ) counter ++ ; } } } } return counter ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countWays ( n ) ) ; } }
import java . io . * ; public class GFG { static int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( ( S - S1 ) / Math . floor ( S ) ) * 60 ; return ( int ) Min ; } public static void main ( String [ ] args ) { int S = 30 , S1 = 10 ; System . out . println ( numberOfMinutes ( S , S1 ) + " ▁ min " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int ans = n ; for ( int i = 0 ; i < n - k ; i ++ ) { ans += ( arr [ i + 1 ] - arr [ i ] ) ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int onesComplement ( int n ) { int number_of_bits = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << number_of_bits ) - 1 ) ^ n ; } public static void main ( String [ ] args ) { int n = 22 ; System . out . println ( onesComplement ( n ) ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { long w = sc . nextLong ( ) , h = sc . nextLong ( ) , n = sc . nextLong ( ) ; if ( n == 1 && w % 2 == 1 && h % 2 == 1 || n == 2 && w % 2 == 1 || h % 2 == 1 && w % 2 == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
public class GFG { static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . print ( " ( " + 2 * x2 - x1 + " , ▁ " + 2 * y2 - y1 + " ) " ) ; } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 0 ; int x2 = 1 , y2 = 1 ; findPoint ( x1 , y1 , x2 , y2 ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int 1 = sc . nextInt ( ) ; int 2 = sc . nextInt ( ) ; int x = 0 , y = 0 ; while ( x < 2 ) { int d = sc . nextInt ( ) ; x ++ ; y ++ ; if ( y == 1 || y == 2 ) { System . out . println ( ( x - y + 1 ) % 3 + 1 ) ; } else { if ( ( x - y + 1 ) % 3 == 0 ) { System . out . println ( ( x - y + 2 ) % 3 + 1 ) ; } else { System . out . println ( ( x - y + 2 ) % 3 + 1 ) ; } } } } } }
import java . io . * ; public class GFG { static void alter ( int x , int y ) { while ( true ) { if ( x == 0 || y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( " X ▁ = ▁ " + x + " , ▁ " + y + " ▁ = ▁ " + y ) ; } public static void main ( String [ ] args ) { int x = 12 , y = 5 ; alter ( x , y ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] V = new int [ N ] ; for ( int i = 0 ; i < V . length ; ++ i ) { V [ i ] = sc . nextInt ( ) ; } Arrays . sort ( V ) ; int [ ] v = new int [ N ] ; for ( int i = 0 ; i < V . length ; ++ i ) { v [ i ] = V [ i ] ; } int [ ] dist = new int [ N ] ; int max = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i ; j < N ; ++ j ) { if ( V [ j ] - V [ i ] > dist [ j ] ) { dist [ j ] = dist [ j ] + 1 ; } else { dist [ j ] = dist [ j ] + 2 ; } if ( V [ j ] == V [ i ] ) { dist [ i ] = i ; } } if ( V [ i ] == V [ i ] ) { ++ max ; } } System . out . println ( N - max ) ; } }
import java . util . Scanner ; public class B1618 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { in . nextInt ( ) ; in . nextInt ( ) ; String S = in . next ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == ' a ' ) { a ++ ; } else { b ++ ; } } if ( a == b ) { System . out . println ( ( i + 1 ) + " ▁ " + ( i + 2 ) ) ; continue ; } int v = 0 ; for ( int i = S . length ( ) - 2 ; i >= 0 ; i -- ) { for ( int j = i + 1 ; j < S . length ( ) ; j ++ ) { if ( S . charAt ( j ) == ' a ' ) { v ++ ; } } if ( v == a || v == b ) { System . out . println ( ( i + 1 ) + " ▁ " + ( j + 1 ) ) ; break ; } } if ( v == 0 ) { System . out . println ( - 1 ) ; } } } }
import java . io . * ; public class GFG { static int mod = 1000000007 ; static int inv2 = 500000004 ; static int modulo ( String num ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + Integer . parseInt ( num . charAt ( i ) ) - 0 ) % mod ; return res ; } static int findSum ( String L , String R ) { int a = modulo ( L ) ; int b = modulo ( R ) ; int l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; int r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; int ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ( ret + mod ) % mod ; else ret = ret % mod ; return ret ; } public static void main ( String [ ] args ) { String L = "88949273204" ; String R = "98429729474298592" ; System . out . println ( findSum ( L , R ) ) ; } }
import java . util . * ; public class GFG { static void unsort ( int l , int r , int a [ ] , int k ) { if ( k < 1 || l + 1 == r ) return ; k -= 2 ; int mid = ( l + r ) / 2 ; int temp = a [ mid - 1 ] ; a [ mid - 1 ] = a [ mid ] ; a [ mid ] = temp ; unsort ( l , mid , a , k ) ; unsort ( mid , r , a , k ) ; } static void arrayWithKCalls ( int n , int k ) { if ( k % 2 == 0 ) { System . out . print ( " NO ▁ SOLUTION " ) ; return ; } int a [ ] = new int [ n + 1 ] ; a [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) a [ i ] = i + 1 ; k -- ; unsort ( 0 , n , a , k ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 10 , k = 17 ; arrayWithKCalls ( n , k ) ; } }
import java . util . * ; public class GFG { static double mean ( int mid [ ] , int freq [ ] , int n ) { double sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; } static double groupedSD ( int lower_limit [ ] , int upper_limit [ ] , int freq [ ] , int n ) { int mid [ ] [ ] = new int [ n ] [ n ] ; double sum = 0 , freqSum = 0 ; double sd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] [ 0 ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = Math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; } public static void main ( String [ ] args ) { int lower_limit [ ] = { 50 , 61 , 71 , 86 , 96 } ; int upper_limit [ ] = { 60 , 70 , 85 , 95 , 100 } ; int freq [ ] = { 9 , 7 , 9 , 12 , 8 } ; int n = lower_limit . length ; System . out . println ( groupedSD ( lower_limit , upper_limit , freq , n ) ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 ; System . out . println ( gcd ( a , b ) ) ; } }
import java . io . * ; public class GFG { static float rectanglearea ( float a , float b ) { if ( a < 0 || b < 0 ) return - 1 ; return 2 * a * b ; } public static void main ( String [ ] args ) { float a = 10 , b = 8 ; System . out . println ( rectanglearea ( a , b ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; while ( t > 0 ) { t -- ; int n = input . nextInt ( ) ; int l = input . nextInt ( ) ; int r = input . nextInt ( ) ; int k = n / l ; if ( r * k >= n ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } } }
import java . io . * ; public class GFG { static int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; } static int countJumps ( int n ) { n = Math . abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n || ( getsum ( ans ) - n ) % 2 == 1 ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( countJumps ( n ) ) ; } }
import java . util . * ; public class GFG { static final int MAX = 10 ; static int lcs ( int dp [ ] [ ] [ ] , int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return ( - ( int ) Math . pow ( 10 , 7 ) ) ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; } public static void main ( String [ ] args ) { int k = 1 ; int arr1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int arr2 [ ] = { 5 , 3 , 1 , 4 , 2 } ; int n = arr1 . length ; int m = arr2 . length ; int [ ] [ ] [ ] dp = new int [ MAX ] [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int k = 0 ; k < MAX ; k ++ ) for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] [ k ] = - 1 ; System . out . println ( lcs ( dp , arr1 , n , arr2 , m , k ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; long n = Long . parseLong ( st . nextToken ( ) ) ; long d = Long . parseLong ( st . nextToken ( ) ) ; long x = Long . parseLong ( st . nextToken ( ) ) ; long s = 0 ; long h = 1 ; long d2 = 0 ; long x2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 10 == 0 ) { h ++ ; } else { d2 = d2 + d2 ; h = 1 ; } } long ans = 0 ; for ( long i = h ; i > 0 ; i -- ) { long s = i % 10 ; s = s + d2 * h ; ans += ( long ) s * x2 ; } out . println ( ans ) ; out . close ( ) ; } }
import java . util . * ; public class GFG { static void Reverseorder ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = n ; p >= 1 ; p -- ) { if ( prime [ p ] ) System . out . print ( p + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; if ( N == 1 ) System . out . println ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; else Reverseorder ( N ) ; } }
import java . io . * ; public class GFG { static void pattern ( int min_stars , int p_height ) { int p_space = p_height - 1 , x = 1 ; for ( int i = 0 ; i < p_height ; i ++ ) { for ( int j = p_space ; j > i ; j -- ) System . out . print ( " ▁ " ) ; for ( int k = 0 ; k < min_stars ; k ++ ) System . out . print ( " * " ) ; for ( int n = ( p_height + p_height - 2 ) ; n > x ; n -- ) System . out . print ( " ▁ " ) ; for ( int k = 0 ; k < min_stars ; k ++ ) System . out . print ( " ▁ " ) ; for ( int k = 0 ; k < min_stars ; k ++ ) System . out . print ( " * " ) ; min_stars = min_stars + 2 ; x = x + 2 ; System . out . print ( " \n " ) ; } } public static void main ( String [ ] args ) { int min_stars = 1 , p_height = 5 ; pattern ( min_stars , p_height ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int min = Integer . MAX_VALUE ; Map < Integer , Set < String > > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; int p = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; for ( int j = p ; j <= q ; j ++ ) { if ( s . charAt ( j - 1 ) == ' M ' ) map . put ( j , new HashSet < > ( ) ) ; map . get ( j ) . add ( s ) ; } } for ( int i = 0 ; i <= m ; i ++ ) { int count = 0 ; for ( String s : map . keySet ( ) ) { if ( s . charAt ( 0 ) == ' M ' ) count ++ ; } if ( count > min ) { min = count ; } } System . out . println ( min ) ; } }
import java . io . * ; public class GFG { static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; } } return sum ; } public static void main ( String [ ] args ) { int x [ ] = { - 1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = x . length ; System . out . println ( distancesum ( x , y , n ) ) ; } }
import java . io . * ; public class GFG { static float fib ( int n ) { float phi = ( 1 + ( float ) Math . sqrt ( 5 ) ) / 2 ; return ( float ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static float calculateSum ( float l , float r ) { float sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } static float sumFibonacci ( int k ) { float l = ( k * ( k - 1 ) ) / 2 ; float r = l + k ; float sum = calculateSum ( l , r - 1 ) ; return sum ; } public static void main ( String [ ] args ) { int k = 3 ; System . out . println ( sumFibonacci ( k ) ) ; } }
public class Main { public static void main ( String [ ] args ) { int l = 4 ; int r = 8 ; System . out . println ( calculateSum ( l , r ) ) ; } public static int calculateSum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += fib ( i ) ; } return sum ; } public static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } }
import java . io . * ; public class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } public static void main ( String [ ] args ) { int l = 4 , r = 8 ; System . out . println ( calculateSum ( l , r ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; for ( int j = a ; j < b ; j ++ ) { if ( arr [ j ] == c ) arr [ j ] = d ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . * ; public class GFG { static int compareStrings ( String str1 , String str2 ) { int i = 0 ; while ( i < str1 . length ( ) - 1 && str1 . charAt ( i ) == str2 . charAt ( i ) ) i ++ ; if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) return - 1 ; return ( str1 . charAt ( i ) < str2 . charAt ( i ) ) ; } static int searchStr ( String arr [ ] , String str , int first , int last ) { if ( first > last ) return - 1 ; int mid = ( last + first ) / 2 ; if ( arr [ mid ] . length ( ) == 0 ) { int left = mid - 1 , right = mid + 1 ; while ( true ) { if ( left < first && right > last ) return - 1 ; if ( right <= last && arr [ right ] . length ( ) != 0 ) { mid = right ; break ; } if ( left >= first && arr [ left ] . length ( ) != 0 ) { mid = left ; break ; } right ++ ; left -- ; } } if ( compareStrings ( str , arr [ mid ] ) == 0 ) return mid ; if ( compareStrings ( str , arr [ mid ] ) < 0 ) { mid = str ; return searchStr ( arr , str , mid + 1 , last ) ; } return searchStr ( arr , str , first , mid - 1 ) ; } public static void main ( String [ ] args ) { String arr [ ] = { " for " , " " , " " , " " , " geeks " , " ide " , " " , " practice " , " " , " " , " quiz " , " " , " " } ; String str = " quiz " ; int n = arr . length ; System . out . println ( searchStr ( arr , str , 0 , n - 1 ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int ans = A + B ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int ax = sc . nextInt ( ) ; int ay = sc . nextInt ( ) ; int bx = sc . nextInt ( ) ; int by = sc . nextInt ( ) ; int cx = sc . nextInt ( ) ; int cy = sc . nextInt ( ) ; int dx = sc . nextInt ( ) ; int dy = sc . nextInt ( ) ; int dx1 = dx ; int dy1 = dy ; int dx2 = dx ; int dy2 = dy ; System . out . println ( 3 ) ; System . out . println ( dx1 + " ▁ " + dy1 + " ▁ " + ( dx2 + dy2 ) ) ; System . out . println ( dx2 + " ▁ " + ( dy1 + dy2 ) ) ; System . out . println ( dy1 + " ▁ " + ( dy2 + dx1 ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class test267 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int n = in . nextInt ( ) ; char [ ] a = in . next ( ) . toCharArray ( ) ; char [ ] b = new char [ n ] ; boolean m = true ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = a [ i ] ; m = false ; } Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] != a [ i ] ) { m = false ; break ; } } System . out . println ( m ) ; } in . close ( ) ; } }
import java . io . * ; public class GFG { static int sumAP ( int n , int d ) { n /= d ; return ( n ) * ( 1 + n ) * ( d / 2 ) ; } static int sumMultiples ( int n ) { n -- ; return ( int ) ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( sumMultiples ( n ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int t = sc . nextInt ( ) ; if ( t == 0 ) break ; int n = sc . nextInt ( ) ; int s [ ] = new int [ n ] ; int f [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = sc . nextInt ( ) ; f [ i ] = sc . nextInt ( ) ; } s [ n - 1 ] = f [ n - 1 ] - s [ 0 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { t -= s [ i ] - s [ i + 1 ] ; } println ( t + " ▁ OK " ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class GFG { static int fact ( int num ) { int fact = 1 ; while ( num > 1 ) { fact = fact * num ; num -- ; } return fact ; } static int catalan ( int n ) { return fact ( 2 * n ) / ( fact ( n ) * fact ( n + 1 ) ) ; } static int catalan ( int n ) { return fact ( 2 * n ) / ( fact ( n ) * fact ( n + 1 ) ) ; } public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; for ( int k = 0 ; k < n ; k ++ ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ k ] ) s ++ ; } int catalan_leftBST = catalan ( s ) ; int catalan_rightBST = catalan ( n - s - 1 ) ; int totalBST = catalan_rightBST * catalan_leftBST ; System . out . print ( totalBST + " ▁ " ) ; } } }
import java . util . Scanner ; public class A_Cow_and_Haybales { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; System . out . println ( ( x - y ) == 1 ? " YES " : " NO " ) ; } } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = Integer . parseInt ( scanner . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] a = get ( scanner ) ; if ( a [ 1 ] >= a [ 0 ] ) { System . out . println ( a [ 1 ] - a [ 0 ] ) ; } else { if ( ( a [ 0 ] - a [ 1 ] ) % 2 == 0 || ( a [ 0 ] + a [ 1 ] ) % 2 == 0 ) { System . out . println ( 0 ) ; } else { System . out . println ( 1 ) ; } } } } public static int [ ] get ( Scanner scanner ) { String [ ] input = scanner . nextLine ( ) . split ( " ▁ " ) ; int [ ] arr = new int [ input . length ] ; for ( int i = 0 ; i < input . length ; i ++ ) { arr [ i ] = Integer . parseInt ( input [ i ] ) ; } return arr ; } }
import java . io . * ; public class GFG { static int countWays ( int n , int arr [ ] ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 1 ; if ( n == 0 ) return 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int no_ways = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { if ( i - arr [ j ] >= 0 ) no_ways += count [ i - arr [ j ] ] ; count [ i ] = no_ways ; } } return count [ n ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 } ; int n = 5 ; System . out . println ( countWays ( n , arr ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { int l = in . nextInt ( ) ; if ( l == 0 ) return false ; int i = 0 ; int sum = 0 ; int ans = 0 ; for ( i = 0 ; i < 12 ; i ++ ) { int m = in . nextInt ( ) ; int n = in . nextInt ( ) ; sum += m - n ; if ( sum >= l ) { ans = i + 1 ; } } out . println ( ans == 0 ? " NA " : ans ) ; } out . flush ( ) ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int max = Math . max ( a , b ) ; int min = Math . min ( c , a ) ; if ( max == min ) System . out . println ( 0 ) ; else { int res = 2 * ( c - max ) ; System . out . println ( res ) ; } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int count = 0 ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; if ( x <= b ) { total += x ; } else if ( x > d ) { total = total + d ; count ++ ; } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n = arr . length ; int key = 10 ; System . out . println ( " Index : ▁ " + binarySearch ( arr , 0 , n , key ) ) ; } }
public class GFG { static void equal_xor_sum ( int arr [ ] , int n ) { int sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( sum == Xor ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 3 , 7 , 10 } ; int n = arr . length ; equal_xor_sum ( arr , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } int ans = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int c = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == i && arr [ j ] == c ) c ++ ; } if ( c == n ) ans = Math . min ( ans , b [ c ] ) ; } System . out . println ( ans ) ; } }
public class GFG { static void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; findPairs ( arr , n ) ; } }
import java . util . * ; public class GFG { static int minBroadcastRange ( int houses [ ] , int towers [ ] , int n , int m ) { int leftTower = Integer . MIN_VALUE , rightTower = Integer . MAX_VALUE ; int j = 0 , k = 0 ; int min_range = 0 ; while ( j < n ) { if ( houses [ j ] < rightTower ) { int left = houses [ j ] - leftTower ; int right = rightTower - houses [ j ] ; if ( left < right ) local_max = left ; else local_max = right ; if ( local_max > min_range ) min_range = local_max ; j ++ ; } else { leftTower = towers [ k ] ; if ( k < m - 1 ) k ++ ; rightTower = towers [ k ] ; } else { rightTower = towers [ k ] ; } } j ++ ; } return min_range ; } public static void main ( String [ ] args ) { int a [ ] = { 12 , 13 , 11 , 80 } ; int b [ ] = { 4 , 6 , 15 , 60 } ; int n = a . length ; int m = b . length ; int max = minBroadcastRange ( a , b , n , m ) ; System . out . println ( max ) ; } }
import java . io . * ; public class GFG { static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; } public static void main ( String [ ] args ) { int num = 100 , divisor = 7 ; System . out . println ( getRemainder ( num , divisor ) ) ; } }
import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Scanner ; import java . util . Set ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String [ ] inputs = scanner . nextLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( inputs [ 0 ] ) ; int m = Integer . parseInt ( inputs [ 1 ] ) ; int z = Integer . parseInt ( inputs [ 2 ] ) ; int n1 = n ; int m1 = m ; int kill = 0 ; List < Integer > calls = new ArrayList < Integer > ( ) ; List < Integer > artists = new ArrayList < Integer > ( ) ; for ( int call = n ; call <= z ; call += n ) { calls . add ( call ) ; } for ( int artist = m ; artist <= z ; artist += m ) { artists . add ( artist ) ; } Set < Integer > intersection = new HashSet < Integer > ( calls ) ; intersection . retainAll ( artists ) ; System . out . println ( intersection . size ( ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int m = sc . nextInt ( ) , n = sc . nextInt ( ) ; if ( ( m | n ) == 0 ) break ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; int max = 0 , min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] + a [ i ] <= m ) sum += a [ j ] ; else sum += a [ j ] ; } max = max ( max , sum ) ; min = min ( min , sum ) ; } int res = min + 1 ; for ( int i = 0 ; i < n ; i ++ ) { res = min ( res , a [ i ] ) ; } System . out . println ( res ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; import java . io . * ; public class test { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] ss0 = br . readLine ( ) . trim ( ) . split ( " ▁ " , 0 ) ; int n = Integer . parseInt ( ss0 [ 0 ] ) ; int w = Integer . parseInt ( ss0 [ 1 ] ) ; double [ ] v = new double [ n ] ; double [ ] w = new double [ n ] ; double max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ss0 = br . readLine ( ) . trim ( ) . split ( " ▁ " ) ; v [ i ] = Double . parseDouble ( ss0 [ 0 ] ) ; w [ i ] = Double . parseDouble ( ss0 [ 1 ] ) ; max = Math . max ( max , v [ i ] ) ; } double [ ] v_ = new double [ n ] ; double [ ] w_ = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = Double . parseDouble ( ss0 [ i ] ) ; w [ i ] = Double . parseDouble ( ss1 [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { v_ [ i ] = Double . parseDouble ( v [ i ] ) ; w_ [ i ] = Double . parseDouble ( ss1 [ i ] ) ; } double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += max * v [ i ] / w [ i ] ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; int common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int maxdiff ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( arr [ i ] , freq . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 3 , 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( maxdiff ( arr , n ) ) ; } }
import java . util . Scanner ; import java . util . ArrayList ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int num = Integer . parseInt ( scanner . nextLine ( ) ) ; for ( int i = 0 ; i < num ; i ++ ) { String [ ] nm = scanner . nextLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( nm [ 0 ] ) ; int m = Integer . parseInt ( nm [ 1 ] ) ; List < List < Integer > > l = new ArrayList < > ( ) ; for ( int a = 0 ; a < n ; a ++ ) { List < Integer > l1 = new ArrayList < > ( ) ; String [ ] input = scanner . nextLine ( ) . split ( " ▁ " ) ; for ( int b = 0 ; b < m ; b ++ ) { l1 . add ( Integer . parseInt ( input [ b ] ) ) ; } l . add ( l1 ) ; } int ans = 0 ; List < Integer > m1 = new ArrayList < > ( ) ; int count = 0 ; int mini = Integer . MAX_VALUE ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < m ; y ++ ) { if ( l . get ( x ) . get ( y ) < 0 ) { count ++ ; mini = Math . min ( mini , - l . get ( x ) . get ( y ) ) ; ans += - l . get ( x ) . get ( y ) ; } else { mini = Math . min ( mini , Math . abs ( l . get ( x ) . get ( y ) ) ) ; ans += Math . abs ( l . get ( x ) . get ( y ) ) ; } } } if ( count % 2 == 0 ) { System . out . println ( ans ) ; } else { System . out . println ( ans - 2 * mini ) ; } } scanner . close ( ) ; } }
import java . util . * ; public class GFG { static void makeAP ( int arr [ ] , int n ) { int initial_term , common_difference ; if ( n == 3 ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else if ( ( arr [ 1 ] - arr [ 0 ] ) == ( arr [ 2 ] - arr [ 1 ] ) ) { initial_term = arr [ 0 ] ; common_difference = arr [ 1 ] - arr [ 0 ] ; } else if ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else { common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initial_term = arr [ 0 ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( initial_term + ( i * common_difference ) + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 7 } ; int n = arr . length ; makeAP ( arr , n ) ; } }
import java . io . * ; public class GFG { static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( countPairs ( n ) ) ; } }
import java . io . * ; public class GFG { static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( countPairs ( n ) ) ; } }
import java . util . * ; public class Solution { public int longestPalindrome ( String s ) { int ans = 0 ; HashMap < Character , Integer > charMap = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { charMap . put ( s . charAt ( i ) , charMap . getOrDefault ( s . charAt ( i ) , 0 ) + 1 ) ; } for ( Character c : charMap . keySet ( ) ) { if ( charMap . get ( c ) % 2 == 0 ) ans += charMap . get ( c ) ; else ans += charMap . get ( c ) / 2 * 2 ; } if ( charMap . size ( ) != 0 ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String s = " abccccdd " ; int out = sObj . longestPalindrome ( s ) ; System . out . println ( out ) ; } }
import java . io . * ; public class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; i ++ ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int catalan ( int n ) { int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } static int findWays ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; return catalan ( n / 2 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ " + n + " ▁ is ▁ " + findWays ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String s = sc . next ( ) ; List < Integer > ans = new ArrayList < > ( ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' O ' ) { int ans = 0 ; int j = i ; while ( j < s . length ( ) && s . charAt ( j ) == ' O ' ) { ans ++ ; j ++ ; } if ( ans == 0 ) { break ; } } } System . out . println ( ans . size ( ) ) ; for ( int x : ans ) System . out . print ( x + " ▁ " ) ; System . out . println ( ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int d = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int da = sc . nextInt ( ) ; int db = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; boolean flag = false ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) { if ( ( a - x * i ) == ( b - y * j ) || ( a - x * j ) == ( b - y * i ) ) { flag = true ; break ; } } } if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; public class GFG { static boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; } public static void main ( String [ ] args ) { int n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Stack ; public class GFG { static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < Integer > ( ) ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j < 10 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( countNumber ( n ) ) ; } }
import java . io . * ; public class GFG { static double maxAverageOfPath ( int cost [ ] [ ] , int N ) { double dp [ ] [ ] = new double [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i <= N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j <= N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 6 , 5 , 4 } , { 7 , 3 , 9 } } ; System . out . println ( maxAverageOfPath ( cost , 3 ) ) ; } }
import java . io . * ; public class GFG { static int MAX = 1000000 ; static int sieve_Prime [ ] = new int [ MAX + 4 ] ; static int sieve_count [ ] = new int [ MAX + 4 ] ; static void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } } public static void main ( String [ ] args ) { form_sieve ( ) ; int n = 2 ; System . out . println ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; n = 3 ; System . out . println ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; double t = sc . nextInt ( ) ; double u = sc . nextInt ( ) ; double v = sc . nextInt ( ) ; double l = sc . nextInt ( ) ; double [ ] d = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { d [ i ] = sc . nextInt ( ) ; } double res = 0 ; double left = d [ 0 ] ; double right = d [ 0 ] ; double ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { double cur = d [ i ] ; double p = 0.0 ; double q = 1.0 ; double r = 0.0 ; double mid = ( left + right ) / 2 ; while ( true ) { double mid = ( left + right ) / 2 ; if ( p + mid < d . length && d [ i ] - p >= d [ mid ] ) { r = mid ; } else { p = mid ; } } if ( r + mid < d . length ) { double temp = d [ r ] ; d [ r ] = d [ r ] ; d [ r ] = temp ; if ( r > mid ) { r = mid ; } else { double temp = d [ r ] ; d [ r ] = d [ r ] ; d [ r ] = temp ; if ( r > mid ) { r = mid ; } else { temp = d [ r ] ; d [ r ] = temp ; } } } if ( r > d . length ) { ans = r - d [ r ] ; } else { double temp = d [ r ] ; d [ r ] = d [ r ] ; d [ r ] = temp ; } } System . out . println ( ans ) ; } }
public class GFG { static int waysToSplit ( String s ) { int n = s . length ( ) ; int answer = 0 ; int [ ] prefix = new int [ n ] ; int [ ] suffix = new int [ n ] ; int [ ] seen = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int prev = prefix [ i - 1 ] >= 0 ? prefix [ i - 1 ] : 0 ; if ( seen [ s . charAt ( i ) - ' a ' ] == 0 ) prefix [ i ] += ( prev + 1 ) ; else prefix [ i ] = prev ; seen [ s . charAt ( i ) - ' a ' ] = 1 ; } seen = new int [ seen . length ] ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int prev = suffix [ i ] ; if ( seen [ s . charAt ( i ) - ' a ' ] == 0 ) suffix [ i - 1 ] += ( prev + 1 ) ; else suffix [ i - 1 ] = prev ; seen [ s . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { String s = " ababa " ; System . out . println ( waysToSplit ( s ) ) ; } }
import java . math . BigInteger ; public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } private static final int TURNS = 15 ; public String run ( ) { BigInteger [ ] [ ] ways = new BigInteger [ TURNS + 1 ] [ TURNS + 1 ] ; ways [ 0 ] [ 0 ] = BigInteger . valueOf ( 1 ) ; ways [ 1 ] [ 0 ] = BigInteger . ZERO ; for ( int i = 1 ; i <= TURNS ; i ++ ) { BigInteger row [ ] = BigInteger . ZERO ; for ( int j = 1 ; j <= i ; j ++ ) { BigInteger temp = BigInteger . ZERO ; if ( j < i ) temp = ways [ i - 1 ] [ j ] * i ; if ( j > 0 ) temp = temp + ways [ i - 1 ] [ j - 1 ] ; row [ i ] = temp ; ways [ i ] [ j ] = BigInteger . valueOf ( temp ) ; } } BigInteger numer = BigInteger . valueOf ( ways [ TURNS ] [ TURNS / 2 + 1 ] ) ; BigInteger denom = BigInteger . valueOf ( ways [ TURNS + 1 ] [ TURNS / 2 ] ) ; return denom . divide ( numer ) ; } }
import java . util . Scanner ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] t = new int [ n + 1 ] ; int [ ] a = new int [ n + 1 ] ; int [ ] cnt = new int [ n + 1 ] ; String [ ] tArray = input . nextLine ( ) . split ( " ▁ " ) ; String [ ] aArray = input . nextLine ( ) . split ( " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { t [ i ] = Integer . parseInt ( tArray [ i - 1 ] ) ; a [ i ] = Integer . parseInt ( aArray [ i - 1 ] ) ; } ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; Arrays . fill ( cnt , 0 ) ; for ( int i : a ) { cnt [ i ] += 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( t [ i ] == 1 ) { ArrayList < Integer > crt = new ArrayList < Integer > ( ) ; crt . add ( i ) ; int x = a [ i ] ; while ( cnt [ x ] == 1 ) { crt . add ( x ) ; x = a [ x ] ; } if ( crt . size ( ) > ans . size ( ) ) { ans = new ArrayList < Integer > ( crt ) ; } } } Collections . reverse ( ans ) ; System . out . println ( ans . size ( ) ) ; System . out . println ( String . join ( " ▁ " , ans . toString ( ) . replace ( " [ " , " " ) . replace ( " ] " , " " ) . split ( " , " ) ) ) ; } }
import java . io . * ; public class GFG { static void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int last = ar1 [ m - 1 ] ; int j = m - 2 ; while ( j >= 0 && ar1 [ j ] > ar2 [ i ] ) { ar1 [ j + 1 ] = ar1 [ j ] ; j -- ; } if ( j != m - 2 || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } } public static void main ( String [ ] args ) { int ar1 [ ] = { 1 , 5 , 9 , 10 , 15 , 20 } ; int ar2 [ ] = { 2 , 3 , 8 , 13 } ; int m = ar1 . length ; int n = ar2 . length ; merge ( ar1 , ar2 , m , n ) ; System . out . println ( " After ▁ Merging ▁ " ) ; System . out . println ( " First ▁ Array : ▁ " + ar1 [ 0 ] ) ; System . out . println ( ar1 [ m - 1 ] ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) ; int b1 = ( c - b ) ; int c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } public static void main ( String [ ] args ) { int a = 62 , b = 132 , c = 237 ; System . out . println ( sameRemainder ( a , b , c ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int ans = 0 ; int mx = 0 ; int mxs = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( i != 0 ) mxs += a ; if ( i != 0 && mx < i ) mxs += b ; if ( i != 0 && mx == i ) mxs += c ; } System . out . println ( Math . max ( mxs , ( d - mxs ) + ( d - mxs ) ) ) ; } }
import java . util . * ; public class GFG { static int [ ] [ ] [ ] dp = new int [ 501 ] [ 501 ] [ 501 ] ; static int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 || parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) return dp [ n ] [ nextPart ] [ parts ] ; int ans = 0 ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; } static int countWays ( int n ) { return countWaysUtil ( n , 4 , 1 ) ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countWaysUtil ( n , 4 , 1 ) ) ; } }
import java . io . * ; public class GFG { static int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 16 ; System . out . println ( find_k ( a , b ) ) ; } }
import java . util . * ; public class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int N = 101 ; static int [ ] [ ] [ ] exactsum = new int [ N ] [ N ] [ N ] ; static int [ ] [ ] exactnum = new int [ N ] [ N ] [ N ] ; static long getSum ( int x , int y , int z ) { long ans = 0 ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { for ( int k = 0 ; k <= z ; k ++ ) { if ( i > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] ; } if ( j > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] ; } if ( k > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; } } } return ans ; } public static void main ( String [ ] args ) { int x = 1 , y = 1 , z = 1 ; System . out . println ( ( getSum ( x , y , z ) % mod ) ) ; } }
public class GFG { static final int CHARS = 26 ; static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int freq1 = 0 , count_freq1 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int freq2 = 0 , count_freq2 = 0 ; for ( int j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; else return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; return true ; } public static void main ( String [ ] args ) { String str = " abcbc " ; if ( isValidString ( str ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Scanner ; public class test290 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { char a [ ] = in . next ( ) . toCharArray ( ) ; char b [ ] = new char [ 3 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( i % 2 == 0 ) { a [ i ] = ' b ' ; } else { a [ i ] = ' a ' ; } } b [ 0 ] = ' b ' ; b [ 1 ] = ' a ' ; boolean x = true ; for ( int i = 2 ; i < a . length ; i ++ ) { if ( a [ i ] == ' b ' ) { x = false ; break ; } else { if ( a [ i ] == ' a ' ) { x = false ; break ; } else { b [ i ] = ' b ' ; } } } for ( int i = 0 ; i < b . length ; i ++ ) { if ( b [ i ] == ' z ' ) { x = false ; break ; } else { if ( a [ i ] == ' y ' ) { x = false ; break ; } else { x = true ; } } } for ( int i = 0 ; i < c . length ; i ++ ) { System . out . print ( b [ i ] ) ; } System . out . println ( ) ; } in . close ( ) ; } }
import java . util . * ; public class GFG { static int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . length ( ) ; int sizeOfA = A . length ( ) ; int inf = 1000000 ; int next [ ] [ ] = new int [ sizeOfB ] [ sizeOfB ] ; for ( int i = 0 ; i < sizeOfB ; i ++ ) next [ B . charAt ( i ) - ' a ' ] [ i ] = i ; for ( int i = 0 ; i < sizeOfB ; i ++ ) for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) if ( next [ i ] [ j ] == inf ) next [ i ] [ j ] = next [ i ] [ j + 1 ] ; int pos = 0 ; for ( int i = 0 ; i < sizeOfA ; i ++ ) { if ( pos == 0 && next [ A . charAt ( i ) - ' a ' ] [ pos ] == inf ) { numberOfSubsequences = - 1 ; break ; } else if ( pos < sizeOfB && next [ A . charAt ( i ) - ' a ' ] [ pos ] < inf ) { int nextIndex = next [ A . charAt ( i ) - ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; } public static void main ( String [ ] args ) { String A = " aacbe " ; String B = " aceab " ; System . out . println ( findMinimumSubsequences ( A , B ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { arr [ i ] [ j ] = Math . max ( i + 1 , n - i - j ) + Math . max ( j + 1 , m - j - i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { arr [ i ] [ j ] = Math . max ( arr [ i ] [ j ] , arr [ i ] [ m - j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] [ 0 ] + " ▁ " ) ; } System . out . println ( arr [ n - 1 ] [ m - 1 ] ) ; } } }
import java . io . * ; public class GFG { static void FindRank ( int arr [ ] , int len ) { System . out . print ( 1 + " ▁ " ) ; for ( int i = 1 ; i < len ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ j ] > arr [ i ] ) rank ++ ; System . out . print ( rank + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 88 , 14 , 69 , 30 , 29 , 89 } ; int len = arr . length ; FindRank ( arr , len ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long H = sc . nextLong ( ) ; long ans = 0 ; long max = 0 ; long [ ] a = new long [ N ] ; long [ ] b = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = sc . nextLong ( ) ; b [ i ] = sc . nextLong ( ) ; if ( a [ i ] > max ) max = a [ i ] ; } Arrays . sort ( a ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] > max ) ans ++ ; if ( max - a [ i ] > H && H - a [ i ] < max ) ans ++ ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int firstkdigits ( int n , int k ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( product / Math . pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; } public static void main ( String [ ] args ) { int n = 15 , k = 4 ; System . out . println ( firstkdigits ( n , k ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; import java . util . TreeSet ; import static java . lang . System . out ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; List < Integer > gcdList = new ArrayList < Integer > ( ) ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { StringTokenizer st = new StringTokenizer ( line ) ; int a , b , temp ; a = Integer . parseInt ( st . nextToken ( ) ) ; b = Integer . parseInt ( st . nextToken ( ) ) ; temp = gcd ( a , b ) ; gcdList . add ( temp ) ; } for ( int i = 0 ; i < gcdList . size ( ) ; i ++ ) { out . println ( gcdList . get ( i ) ) ; } } static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; HashMap < Character , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( map . containsKey ( s . charAt ( i ) ) ) { map . put ( s . charAt ( i ) , map . get ( s . charAt ( i ) ) + 1 ) ; } else { map . put ( s . charAt ( i ) , 1 ) ; } } int ans = 0 ; for ( Character key : map . keySet ( ) ) { int val = map . get ( key ) ; if ( val % 2 == 1 ) { ans ++ ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int complement ( int num ) { int i = 0 ; int len = 0 ; int comp = 0 ; int temp = num ; while ( true ) { len ++ ; num /= 10 ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . pow ( 10 , len ) - num ; return comp ; } public static void main ( String [ ] args ) { System . out . println ( complement ( 25 ) ) ; System . out . println ( complement ( 456 ) ) ; } }
import java . io . * ; public class GFG { static int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; int t = ( int ) Math . log ( x ^ n , 2 ) ; return ( int ) Math . floor ( t ) ; } public static void main ( String [ ] args ) { int n = 17 ; System . out . println ( countUnsetBits ( n ) ) ; } }
import java . util . * ; public class GFG { static int minOperations ( int arr [ ] , int n ) { int result = 0 ; int freq [ ] = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j += i ) { freq [ j ] = 0 ; result ++ ; } } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int totalWays ( int N , int M , int X ) { int dp [ ] [ ] = new int [ N + 1 ] [ 2 ] ; if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } public static void main ( String [ ] args ) { int N = 4 , M = 3 , X = 2 ; System . out . println ( totalWays ( N , M , X ) ) ; } }
import java . io . * ; public class GFG { static int getMinNum ( int a , int b , int c ) { if ( c < a || c > b ) return c ; int x = ( ( b / c ) * c ) + c ; return x ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 , c = 4 ; System . out . println ( getMinNum ( a , b , c ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; String S = scanner . next ( ) ; int x = 0 ; int max_num = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == ' I ' ) { x += 1 ; } else { x -= 1 ; } if ( x > max_num ) { max_num = x ; } } System . out . println ( max_num ) ; } }
import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; while ( true ) { String [ ] NM = scanner . nextLine ( ) . split ( " ▁ " ) ; int N = Integer . parseInt ( NM [ 0 ] ) ; int M = Integer . parseInt ( NM [ 1 ] ) ; if ( N == 0 ) { break ; } protect ( N , M , scanner ) ; } } public static void protect ( int N , int M , Scanner scanner ) { int [ ] [ ] DP = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] input = scanner . nextLine ( ) . split ( " ▁ " ) ; for ( int j = 0 ; j < 2 ; j ++ ) { DP [ i ] [ j ] = Integer . parseInt ( input [ j ] ) ; } } Arrays . sort ( DP , Comparator . comparingInt ( o -> o [ 1 ] ) ) ; int nokori = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( M > DP [ N - i - 1 ] [ 0 ] ) { M -= DP [ N - i - 1 ] [ 0 ] ; DP = Arrays . copyOf ( DP , DP . length - 1 ) ; } else if ( M <= DP [ N - i - 1 ] [ 0 ] ) { nokori = ( DP [ N - i - 1 ] [ 0 ] - M ) * DP [ N - i - 1 ] [ 1 ] ; M = 0 ; DP = Arrays . copyOf ( DP , DP . length - 1 ) ; break ; } } for ( int i = 0 ; i < DP . length ; i ++ ) { nokori += DP [ i ] [ 0 ] * DP [ i ] [ 1 ] ; } System . out . println ( nokori ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; PriorityQueue < Long > left = new PriorityQueue < > ( Comparator . naturalOrder ( ) ) ; PriorityQueue < Long > right = new PriorityQueue < > ( Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { long a = sc . nextLong ( ) ; if ( a > left . peek ( ) ) { left . add ( a ) ; } else { right . add ( a ) ; } } long [ ] leftSum = new long [ n + 1 ] ; long [ ] rightSum = new long [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { leftSum [ i + 1 ] = leftSum [ i ] + a ; } for ( int i = n ; i < n ; i ++ ) { leftSum [ i + 1 ] = leftSum [ i ] - left . poll ( ) ; } for ( int i = n ; i < n ; i ++ ) { rightSum [ i + 1 ] = rightSum [ i ] - right . poll ( ) ; } PriorityQueue < Long > red = new PriorityQueue < > ( Comparator . reverseOrder ( ) ) ; for ( int i = n ; i >= 1 ; i -- ) { red . add ( rightSum [ i ] ) ; } long blue = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { blue += rightSum [ i ] ; blue += rightSum [ i ] ; } long ans = Long . MIN_VALUE ; for ( int i = 0 ; i <= n ; i ++ ) { long blue = red . poll ( ) + blue ; long red = right . poll ( ) - red ; long blue = blue + blue ; long sum = sum - red ; long blue = blue + blue ; long temp = red + blue ; long temp2 = blue + red ; long ans = Math . max ( temp , blue ) ; temp = blue + blue ; ans = Math . max ( temp , ans ) ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int countWays ( int arr [ ] , int m , int N ) { int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; } return count [ N ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 6 } ; int m = arr . length ; int N = 7 ; System . out . println ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " + countWays ( arr , m , N ) ) ; } }
import java . io . * ; public class GFG { static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
import java . util . * ; public class GFG { static void countFreq ( int a [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . containsKey ( a [ i ] ) ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; else hm . put ( a [ i ] , 1 ) ; } int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm . get ( a [ i ] ) ; if ( hm . get ( a [ i ] ) > 0 ) System . out . print ( a [ i ] + " - > ▁ " + cumul ) ; hm . put ( a [ i ] , 0 ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 , 4 , 2 , 1 } ; int n = a . length ; countFreq ( a , n ) ; } }
import java . io . * ; public class GFG { static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 ; int possibleB = 0 ; int possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) flag = false ; else if ( numbersInRange > 3 ) { flag = true ; if ( ( L % 2 ) > 0 ) L ++ ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ( L % 2 ) == 0 ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { System . out . println ( " ( " + possibleA + " , ▁ " + possibleB + " , ▁ " + possibleC + " ) ▁ is ▁ one ▁ such " + " possible ▁ triplet ▁ between ▁ " + L + " ▁ and ▁ " + R ) ; } else { System . out . println ( " No ▁ Such ▁ Triplet ▁ exists ▁ between ▁ " + L + " ▁ and ▁ " + R ) ; } } public static void main ( String [ ] args ) { int L = 2 , R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }
public class GFG { static String conversion ( char [ ] charSet , String str ) { String s2 = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { s2 += ( charSet . indexOf ( str . charAt ( i ) ) ) ; } return s2 ; } public static void main ( String [ ] args ) { char [ ] charSet = " abcdefghijklmnopqrstuvwxyz " . toCharArray ( ) ; String str = " qwertyuiopasdfghjklzxcvbnm " . toCharArray ( ) ; System . out . println ( conversion ( charSet , str ) ) ; } }
import java . util . * ; public class GFG { static Set < Integer > s = new TreeSet < > ( ) ; static void generateNumber ( int count , int a [ ] , int n , int num , int k ) { if ( k == count ) { s . add ( num ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) { generateNumber ( count + 1 , a , n , num + a [ i ] , k ) ; } } static void printDistinctIntegers ( int k , int a [ ] , int n ) { generateNumber ( 0 , a , n , 0 , k ) ; System . out . println ( " The ▁ " + s . size ( ) + " ▁ distinct ▁ integers ▁ are : " ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) System . out . print ( s . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 8 , 17 , 5 } ; int n = a . length ; int k = 2 ; printDistinctIntegers ( k , a , n ) ; } }
import java . util . * ; public class GFG { static int product ( int x ) { int prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; } static int findNumber ( int l , int r ) { String a = Integer . toString ( l ) ; String b = Integer . toString ( r ) ; int ans = r ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { if ( b . charAt ( i ) == '0' ) continue ; char curr [ ] = b . toCharArray ( ) ; curr [ i ] = ( ( curr [ i ] - '0' ) - 1 ) + '0' ; for ( int j = i + 1 ; j < curr . length ; j ++ ) curr [ j ] = ( char ) ( '9' ) ; int num = 0 ; for ( int c : curr ) num = num * 10 + ( int ) c - '0' ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } public static void main ( String [ ] args ) { int l = 1 , r = 10 ; System . out . println ( findNumber ( l , r ) ) ; l = 51 ; 62 System . out . println ( findNumber ( l , r ) ) ; } }
import java . util . * ; public class GFG { static boolean [ ] isPrime = new boolean [ 100005 ] ; static void sieveOfEratostheneses ( ) { for ( int i = 1 ; i < 100005 ; i ++ ) isPrime [ i ] = true ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i < 100005 ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j < 100005 ; j += i ) isPrime [ j ] = false ; } } } static int findPrime ( int n ) { for ( int num = n + 1 ; num <= n ; num ++ ) { if ( isPrime [ num ] ) return num ; num ++ ; } return 0 ; } static int minNumber ( int arr [ ] ) { sieveOfEratostheneses ( ) ; int s = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) s += arr [ i ] ; if ( isPrime [ s ] == true ) return 0 ; int num = findPrime ( s ) ; return num - s ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; System . out . println ( minNumber ( arr ) ) ; } }
public class GFG { static int MAX = 25 ; static int getMinSum ( int arr [ ] , int n ) { int bits_count [ ] = new int [ MAX ] ; int max_bit = 0 , sum = 0 , ans = 0 ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] , f = 0 ; while ( e > 0 ) { int rem = e % 2 ; e = e / 2 ; if ( rem == 1 ) bits_count [ f ] += rem ; f ++ ; } max_bit = Math . max ( max_bit , f ) ; } for ( int d = 0 ; d < max_bit ; d ++ ) { int temp = ( int ) Math . pow ( 2 , d ) ; if ( bits_count [ d ] > n / 2 ) ans = ans + temp ; } for ( int d = 0 ; d < max_bit ; d ++ ) { int temp = ( int ) Math . pow ( 2 , d ) ; if ( bits_count [ d ] > n / 2 ) ans = ans + temp ; } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 7 , 11 , 15 } ; int n = arr . length ; System . out . println ( getMinSum ( arr , n ) ) ; } }
import java . util . Scanner ; public class B877 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; String S = in . next ( ) ; int answer = 0 ; int last = S . length ( ) ; for ( int i = 0 ; i < last ; i ++ ) { char c = S . charAt ( i ) ; if ( c == ' ? ' || c == ' ! ' || c == ' . ' ) { answer ++ ; } else { last = i ; } } if ( last == 0 ) { answer = " Impossible " ; } else if ( last >= S . length ( ) ) { answer = " Impossible " ; } else { answer = Math . max ( answer , last - last ) + 1 ; } System . out . println ( answer ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = Integer . parseInt ( st . nextToken ( ) ) - 1 ; int [ ] res = new int [ n ] ; Arrays . fill ( res , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = arr [ i ] + 1 ; if ( res [ i ] < 0 ) res [ i ] = Math . abs ( res [ i ] - res [ i + 1 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) pw . print ( res [ i ] + " ▁ " ) ; pw . println ( ) ; pw . close ( ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] b = new int [ n ] ; int [ ] a = new int [ m ] ; int [ ] c = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { c [ i ] = sc . nextInt ( ) ; } Arrays . sort ( b ) ; int cost = 0 ; int i = 0 , j = 0 ; while ( i < n && j < m ) { while ( i < n && b [ j ] < c [ i ] ) i ++ ; cost += c [ j ] ; j ++ ; } System . out . println ( cost ) ; } } }
import java . io . * ; public class GFG { static int findMaximumNum ( int arr [ ] , int n ) { for ( int i = n ; i >= 1 ; i -- ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i <= arr [ j ] ) count ++ ; if ( count >= i ) return i ; } return 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 8 , 10 } ; int n = arr . length ; System . out . println ( findMaximumNum ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int m = sc . nextInt ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( m -- > 0 ) { String str = sc . next ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( str . startsWith ( " i " ) ) { sb . append ( s . substring ( a , a + b ) ) ; } else if ( str . startsWith ( " o " ) ) { sb . append ( s . substring ( a , b + 1 ) ) ; } else { sb . deleteCharAt ( a ) ; } } System . out . println ( sb ) ; } }
import java . util . * ; public class GFG { static int solve ( int [ ] A , int n ) { int [ ] [ ] dp = new int [ 2 ] [ 2 ] ; int flag = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += A [ i ] ; for ( int i = - sum ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = - sum ; j <= sum ; j ++ ) { dp [ flag ] [ j ] = Integer . MAX_VALUE ; if ( j - A [ i - 1 ] <= sum && j - A [ i - 1 ] >= - sum ) dp [ flag ] [ j ] = dp [ flag ] [ j - A [ i - 1 ] ] ; if ( j + A [ i - 1 ] <= sum && j + A [ i - 1 ] >= - sum && dp [ flag ] [ j + A [ i - 1 ] ] != Integer . MAX_VALUE && dp [ flag ] [ j ] != Integer . MAX_VALUE ) dp [ flag ] [ j ] = Math . min ( dp [ flag ] [ j ] , dp [ flag ] [ j + A [ i - 1 ] ] + 1 ) ; } flag = flag ^ 1 ; } for ( int i = 0 ; i <= sum ; i ++ ) if ( dp [ flag ^ 1 ] [ i ] != Integer . MAX_VALUE ) return dp [ flag ^ 1 ] [ i ] ; return n - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = arr . length ; System . out . println ( solve ( arr , n ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static void solve ( ) { double [ ] p = new double [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { p [ i ] = in . nextDouble ( ) ; } double x1 = p [ 0 ] - p [ 1 ] ; double y1 = p [ 1 ] - p [ 2 ] ; double x2 = p [ 3 ] - p [ 4 ] ; double y2 = p [ 5 ] - p [ 6 ] ; double z1 = p [ 7 ] - p [ 8 ] ; double z2 = p [ 9 ] - p [ 10 ] ; double s = x1 * x2 + y1 * y2 + z1 * z2 ; if ( ( s * ( x1 - x2 ) == 0 && ( y1 - y2 ) == 0 ) || ( s * ( y1 - y2 ) == 0 && ( z1 - z2 ) == 0 ) ) { out . println ( " YES " ) ; } else { out . println ( " NO " ) ; } } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; solve ( ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static String fizzBuzz ( String str ) { int m = str . length ( ) ; if ( m == 0 && n == 0 ) return "0" ; String fizz = " " ; String buzz = " " ; int p = 0 ; String ns = " " ; for ( int i = 0 ; i < m ; ++ i ) { if ( fizz . equals ( str ) ) { fizz = fizz + " Fizz " ; } else if ( fizz . equals ( " " ) && str . equals ( " " ) ) { fizz = fizz + " Buzz " ; } else if ( fizz . equals ( " " ) && str . equals ( " " ) ) { ns = fizz + " Fizz " ; } else if ( fizz . equals ( " " ) && str . equals ( " " ) ) { ns = fizz + " Buzz " ; } p = p + 1 ; } return ns ; } public static void main ( String [ ] args ) { while ( true ) { String str = sc . next ( ) ; if ( str . equals ( "0" ) && str . equals ( "0" ) ) break ; String [ ] s = str . split ( " ▁ " ) ; int m = Integer . parseInt ( s [ 0 ] ) ; int n = Integer . parseInt ( s [ 1 ] ) ; fizz = new String [ m ] ; for ( int i = 0 ; i < m ; ++ i ) fizz [ i ] = fizz [ i ] + s [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { s [ i ] = sc . next ( ) ; } int l = 0 ; int p = 0 ; for ( int i = 0 ; i < m ; ++ i ) { System . out . print ( fizz [ p ] + " ▁ " ) ; p ++ ; } System . out . println ( fizz [ m - 1 ] ) ; } } }
public class GFG { static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { l [ i ] [ j ] = l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ; } } } static int nCr ( int n , int r ) { return l [ n ] [ r ] ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 8 , r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; int c = scanner . nextInt ( ) ; int d = scanner . nextInt ( ) ; System . out . println ( Math . max ( 0 , Math . min ( b , d ) - Math . max ( a , c ) ) ) ; } }
import java . io . * ; public class GFG { static void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . floor ( a [ i ] / mul ) ; System . out . print ( x + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 5 , 100 , 8 } ; int b [ ] = { 2 , 3 } ; int n = a . length ; int m = b . length ; calculate ( a , b , n , m ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a += sc . nextInt ( ) ; } int b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b += sc . nextInt ( ) ; } int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c += sc . nextInt ( ) ; } System . out . println ( a - b ) ; System . out . println ( b - c ) ; } }
import java . util . * ; public class boredom { public static void main ( String [ ] args ) { Scanner css = new Scanner ( System . in ) ; int t = css . nextInt ( ) ; while ( t -- > 0 ) { int n = css . nextInt ( ) ; String str = css . next ( ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( str . charAt ( i ) == ' < ' ) { i ++ ; } else if ( str . charAt ( j ) == ' > ' ) { j -- ; } else break ; } System . out . println ( i + 1 ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; int count = 0 ; while ( n > 0 ) { n /= 2 ; count ++ ; } System . out . println ( count ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int p_speed = Integer . parseInt ( input . nextLine ( ) ) ; int d_speed = Integer . parseInt ( input . nextLine ( ) ) ; int time = Integer . parseInt ( input . nextLine ( ) ) ; int wait = Integer . parseInt ( input . nextLine ( ) ) ; int distance = Integer . parseInt ( input . nextLine ( ) ) ; int position_p = time * p_speed ; int position_d = 0 ; int counter = 0 ; int time_counter = 0 ; while ( position_p < distance && d_speed > p_speed ) { int time_d = position_p / ( d_speed - p_speed ) ; position_p += ( time_d * p_speed ) ; if ( position_p >= distance ) { break ; } int t_back = position_p / d_speed + wait ; position_p += ( t_back * p_speed ) ; counter ++ ; } System . out . println ( counter ) ; } }
import java . util . * ; public class Main { public static void solve ( String s1 , String s2 ) { String a1 = s1 . substring ( 0 , 2 ) ; String a2 = s2 . substring ( 0 , 2 ) ; String a3 = s1 . substring ( 3 , 5 ) ; String a4 = s2 . substring ( 3 , 5 ) ; int hrs = Integer . parseInt ( a1 ) ; int min = Integer . parseInt ( a2 ) ; int min2 = Integer . parseInt ( a3 ) ; int min = Math . abs ( hrs - min2 ) ; String hrs = ( hrs / 60 ) + " : " + ( min % 60 ) ; if ( hrs % 60 == 0 ) { hrs -- ; } int min2 = min * 60 + min2 ; String ans = " " ; if ( hrs % 60 == 0 ) { ans = "0" + ans ; } else { ans = ans + " : " + ans + " " ; } if ( min2 < min ) { ans = "0" + ans + " : " + min2 ; } else { ans = "0" + ans + " : " + min2 ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s1 = sc . next ( ) ; String s2 = sc . next ( ) ; solve ( s1 , s2 ) ; } }
import java . io . * ; public class GFG { static int longestAlternatingSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] * a [ i - 1 ] < 0 ) { cnt ++ ; longest = Math . max ( longest , cnt ) ; } else { cnt = 1 ; } } return longest ; } public static void main ( String [ ] args ) { int a [ ] = { - 5 , - 1 , - 1 , 2 , - 2 , - 3 } ; int n = a . length ; System . out . println ( longestAlternatingSubarray ( a , n ) ) ; } }
public class GFG { static void checkTypeOfTriangle ( int a , int b , int c ) { doubleqa = Math . pow ( a , 2 ) ; double sqb = Math . pow ( b , 2 ) ; double sqc = Math . pow ( c , 2 ) ; if ( sqa == sqa + sqb || sqb == sqa + sqc || sqc == sqa + sqb ) System . out . println ( " Right - angled ▁ Triangle " ) ; else if ( sqa > sqc + sqb || sqb > sqa + sqc || sqc > sqa + sqb ) System . out . println ( " Obtuse - angled ▁ Triangle " ) ; else System . out . println ( " Acute - angled ▁ Triangle " ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 2 , c = 2 ; checkTypeOfTriangle ( a , b , c ) ; } }
public class GFG { static int MAX = 100 ; static void countSubsequence ( String s , int n ) { int cntG = 0 ; int cntF = 0 ; int result = 0 ; int C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' G ' ) { cntG ++ ; result += C ; continue ; } if ( s . charAt ( i ) == ' F ' ) { cntF ++ ; C += cntG ; continue ; } else { continue ; } } System . out . print ( result + " \n " ) ; } public static void main ( String [ ] args ) { String s = " GFGFG " ; int n = s . length ( ) ; countSubsequence ( s , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] x = new int [ n ] [ 3 ] ; int [ ] [ ] y = new int [ n ] [ 3 ] ; int [ ] h = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { x [ i ] [ j ] = sc . nextInt ( ) ; y [ i ] [ j ] = sc . nextInt ( ) ; h [ i ] [ j ] = sc . nextInt ( ) ; } } for ( int cx = 0 ; cx <= 100 ; cx ++ ) { for ( int cy = 0 ; cy <= 100 ; cy ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( x [ i ] [ j ] < x [ i ] [ j ] || y [ i ] [ j ] < y [ i ] [ j ] ) { int nx = x [ i ] [ j ] - cx ; int ny = y [ i ] [ j ] - cy ; int nx1 = x [ i ] [ j ] - x [ i ] [ 0 ] ; int ny1 = y [ i ] [ j ] - y [ i ] [ 0 ] ; int nx2 = x [ i ] [ j ] + y [ j ] [ j ] ; int ny2 = y [ i ] [ j ] - y [ i ] [ j ] ; int nx = x [ i ] [ j ] - cx ; int ny2 = y [ i ] [ j ] - ny ; if ( nx1 + ny1 != ny2 + nx1 ) { System . out . println ( ( cx + ( x [ i ] [ j ] + y [ j ] [ 0 ] ) + " ▁ " + ( y [ i ] [ j ] + nx1 ) ) ; return ; } } } } } } } }
import java . io . * ; public class GFG { static int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . floor ( Math . cbrt ( n ) ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; } public static void main ( String [ ] args ) { int n = 150 ; System . out . println ( countSteps ( n ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static void solve ( ) { int [ ] [ ] a = new int [ 8 ] [ 3 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { a [ i ] [ j ] = in . nextInt ( ) ; } } Arrays . sort ( a , ( o1 , o2 ) -> Double . compare ( o2 . y , o1 . y ) ) ; for ( int i = 0 ; i < 8 ; i ++ ) { out . printf ( " % d ▁ % d \n " , a [ i ] [ 0 ] , a [ i ] [ 1 ] ) ; } } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; solve ( ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] arr = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextLong ( ) ; Arrays . sort ( arr ) ; long min = arr [ 0 ] , max = arr [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; if ( arr [ i ] > max ) max = arr [ i ] ; } long ans = ( max - min ) * ( max - 1 ) / 2 ; System . out . println ( ans + " ▁ " + max ) ; } }
import java . util . * ; public class GFG { static int count_bits ( int a ) { int c = 0 ; while ( a > 0 ) { c += a & 1 ; a >>= 1 ; } return c ; } static int count_bits ( int [ ] arr ) { int i = 0 ; int count = 0 ; while ( i < arr . length ) { int x = count_bits ( arr [ i ] ) ; if ( i % x == 0 ) count ++ ; i ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; System . out . println ( count_bits ( arr ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; total += arr [ i ] ; } int half = ( total / 2 ) + 1 ; int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > half ) { even ++ ; } else { odd ++ ; } } if ( ( even + odd ) % ( n + 1 ) != 0 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } }
import java . io . * ; public class GFG { static int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; } public static void main ( String [ ] args ) { int N = 390 ; System . out . println ( maxProd ( N ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { int count = 2 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 1 && arr [ j + 1 ] == 1 ) { count ++ ; } else { break ; } } if ( count > max ) { max = count ; } } } System . out . println ( max ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; List < Integer > x = new ArrayList < > ( ) ; List < Integer > y = new ArrayList < > ( ) ; for ( int i = 0 ; i < 2 * n ; i ++ ) { int x1 = sc . nextInt ( ) ; int y1 = sc . nextInt ( ) ; x . add ( x1 ) ; y . add ( y1 ) ; } Collections . sort ( x ) ; Collections . sort ( y ) ; double a = Math . abs ( x . get ( 0 ) ) ; double b = Math . abs ( y . get ( 0 ) ) ; double c = Math . abs ( x . get ( 1 ) ) ; double z = Math . abs ( y . get ( 1 ) ) ; double x2 = Math . abs ( x . get ( 2 ) ) ; double y2 = Math . abs ( y . get ( 2 ) ) ; x . add ( x2 ) ; y . add ( y2 ) ; double z2 = Math . abs ( y . get ( 2 ) ) ; double a = Math . abs ( x . get ( 0 ) ) ; double b = Math . abs ( y . get ( 1 ) ) ; double z2 = Math . abs ( x . get ( 2 ) ) ; double x3 = Math . abs ( y . get ( 0 ) ) ; double y3 = Math . abs ( x . get ( 2 ) ) ; double a = Math . sqrt ( x3 * x3 + y3 * y3 ) ; System . out . println ( a + b ) ; } } }
import java . io . * ; public class GFG { static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count = count * ( N + i - 1 ) ; count = count / i ; } return count ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countNonDecreasing ( n ) ) ; } }
import java . util . * ; public class GFG { static int reduceString ( String s , int l ) { int count = 1 ; int steps = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) count ++ ; else { steps += ( count / 2 ) ; count = 1 ; } } steps += ( count / 2 ) ; return steps ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int l = s . length ( ) ; System . out . println ( reduceString ( s , l ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; sc . close ( ) ; int n = a + b ; String ans = " ! " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 || i == n - 1 || i == n - 2 || i == n - 1 || i == n - 2 ) ans = "0" ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( i > b && i <= x ) { count ++ ; } } System . out . println ( count ) ; for ( int i = a ; i <= y ; i ++ ) { if ( i > b && i <= x ) { System . out . println ( i + " ▁ " + i ) ; } } } }
import java . util . * ; public class GFG { static int mod = 1000000007 ; static int mult ( int a , int b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; } static int calculate_factors ( int n ) { int cnt = 0 ; int ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt > 0 ) ans = mult ( ans , ( cnt + 1 ) ) ; for ( int i = 3 ; i * i <= n ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt > 0 ) ans = mult ( ans , ( cnt + 1 ) ) ; } if ( n > 2 ) ans = mult ( ans , 2 ) ; return ans % mod ; } public static void main ( String [ ] args ) { int n = 19374857 ; int mod = 17 ; System . out . println ( calculate_factors ( n ) ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' . ' ) { count ++ ; } else { if ( count == 0 ) { count = 1 ; } else { count = 2 ; } } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 3 } ; int n = arr . length ; System . out . println ( maxAbsDiff ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int [ ] [ ] s = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { s [ i ] [ j ] = sc . nextInt ( ) ; } } int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; if ( x == 1 ) { for ( int j = 0 ; j < 3 ; j ++ ) { s [ i ] [ j ] = 1 ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < s [ i ] . length ; j ++ ) { if ( s [ i ] [ j ] == 1 ) { s [ i ] [ j ] = 2 ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < s [ i ] . length ; j ++ ) { if ( s [ i ] [ j ] == 2 ) { System . out . println ( 1 ) ; } else if ( s [ i ] [ j ] == 1 ) { System . out . println ( 2 ) ; } } } } } }
import java . util . * ; public class GFG { static int minRemove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; int res = 0 ; for ( int x : countA . keySet ( ) ) { if ( countB . containsKey ( x ) ) res += Math . min ( countA . get ( x ) , countB . get ( x ) ) ; } return res ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 } ; int b [ ] = { 2 , 3 , 4 , 5 , 8 } ; int n = a . length ; int m = b . length ; System . out . println ( minRemove ( a , b , n , m ) ) ; } }
import java . io . * ; public class GFG { static int count ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i < r ; i ++ ) { if ( i < 10 ) cnt ++ ; else { int n = i % 10 ; int k = i ; while ( k >= 10 ) k /= 10 ; if ( n == k ) cnt ++ ; } } return ( cnt ) ; } public static void main ( String [ ] args ) { int L = 2 , R = 60 ; System . out . println ( count ( L , R ) ) ; L = 1 ; R = 1000 ; System . out . println ( count ( L , R ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int count = 0 ; int count_diff = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( arr [ i ] == 1 ) { if ( count_diff == 0 ) { count_diff = 1 ; } else { count_diff -- ; } } else { if ( count_diff == 0 ) { count_diff = 1 ; } count_diff = 0 ; } } if ( count_diff != 0 ) { System . out . println ( count_diff ) ; } else { System . out . println ( count_diff ) ; } } }
import java . io . * ; public class GFG { static int bit ( int x ) { int ans = 0 ; while ( x > 0 ) { x /= 2 ; ans ++ ; } return ans ; } static boolean check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; } static int bs ( int n ) { int l = 1 ; int r = ( int ) Math . sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( check ( l , n ) == false ) return ( int ) Math . floor ( l + 1 ) ; else return ( int ) Math . floor ( l ) ; } static int countDivisor ( int n ) { return n - bs ( n ) + 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countDivisor ( n ) ) ; } }
public class GFG { static int minimalSteps ( String s , int n ) { int dp [ ] = new int [ n ] ; String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 + i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) { dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; } public static void main ( String [ ] args ) { String s = " aaaaaaaa " ; int n = s . length ( ) ; System . out . println ( minimalSteps ( s , n ) ) ; } }
import java . io . * ; public class GFG { static boolean checkUtil ( int num , int dig , int base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( num / base , - - dig , base ) ; return false ; } static boolean check ( int num , int dig ) { for ( int base = 2 ; base < 33 ; base ++ ) { if ( checkUtil ( num , dig , base ) ) return true ; } return false ; } public static void main ( String [ ] args ) { int num = 8 , dig = 3 ; if ( check ( num , dig ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static int getMin ( int arr [ ] , int i , int j ) { int minVal = arr [ i ] ; i ++ ; while ( i <= j ) minVal = Math . min ( minVal , arr [ i ] ) ; return minVal ; } static int getMax ( int arr [ ] , int i , int j ) { int maxVal = arr [ i ] ; i ++ ; while ( i <= j ) maxVal = Math . max ( maxVal , arr [ i ] ) ; return maxVal ; } static void generateArr ( int arr [ ] , int n ) { if ( n == 0 ) return ; if ( n == 1 ) { System . out . print ( arr [ 0 ] ) ; return ; } int tmpArr [ ] = new int [ n ] ; tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) tmpArr [ i ] = Math . abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) ; tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) ; printArray ( tmpArr , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 2 , 4 , 3 } ; int n = arr . length ; generateArr ( arr , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] v = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; } char [ ] c = sc . next ( ) . toCharArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( c [ i ] == ' B ' ) { v [ i ] = Math . max ( a [ i ] , v [ i ] ) ; } else { v [ i ] = Math . max ( a [ i ] , v [ i + 1 ] ) ; } } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += a [ i ] ; if ( c [ i ] == ' B ' ) { ans += v [ i ] ; } else { ans += v [ i ] ; } } long b = 0 ; long min = a [ 0 ] , r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( c [ i ] == ' B ' ) { b = Math . max ( b , r ) ; } else { b = Math . max ( b , a [ i ] ) ; r = Math . max ( r , a [ i ] ) ; } min = Math . min ( min , b ) ; } System . out . println ( ans + min ) ; } }
import java . util . * ; import java . io . * ; import java . lang . Math ; public class CodeForces { static int n ; static int m ; static double x [ ] , y [ ] , z [ ] ; public static void main ( String args [ ] ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; int t = Integer . parseInt ( st . nextToken ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { st = new StringTokenizer ( f . readLine ( ) ) ; x [ i ] = Double . parseDouble ( st . nextToken ( ) ) ; y [ i ] = Double . parseDouble ( st . nextToken ( ) ) ; z [ i ] = Double . parseDouble ( st . nextToken ( ) ) ; } double s1 = Math . abs ( x [ 1 ] - x [ 2 ] ) , s2 = Math . abs ( y [ 1 ] - y [ 2 ] ) , s3 = Math . abs ( z [ 3 ] - y [ 4 ] ) , s4 = Math . abs ( x [ 0 ] - x [ 1 ] ) , s5 = Math . abs ( y [ 1 ] - y [ 0 ] ) ; if ( s1 * s2 - s3 * s4 < 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return a ^ b ; return nthXorFib ( n % 3 , a , b ) ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 ; int n = 10 ; System . out . print ( nthXorFib ( n , a , b ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int taro = 0 ; int hanako = 0 ; int a , b , x , y ; for ( int i = 0 ; i < n ; i ++ ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; x = sc . nextInt ( ) ; y = sc . nextInt ( ) ; if ( x == b ) { taro ++ ; } else if ( x > b ) { hanako ++ ; } else if ( x == b ) { taro ++ ; } else if ( x > b ) { a ++ ; } } System . out . println ( taro + " ▁ " + hanako ) ; } }
import java . io . * ; public class GFG { static float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = 1.268 * a ; float A = 0.70477 * Math . pow ( h , 2 ) ; return A ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( Area ( a ) ) ; } }
import java . util . * ; public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; Stack < P > stack = new Stack < > ( ) ; stack . push ( new P ( 1 , 3 , 1 , 2 ) ) ; while ( ! stack . isEmpty ( ) ) { P p = stack . pop ( ) ; int d = p . d + p . r ; if ( d <= 12000 && d <= 12000 ) { int n = p . d + p . r ; count ++ ; stack . push ( new P ( n , d , r , n , d ) ) ; stack . push ( new P ( n , d , n , d ) ) ; stack . push ( new P ( n , d , p . r , n , d ) ) ; } } return Integer . toString ( count ) ; } private static class P implements Comparable < P > { int l , r , d ; public P ( int l , int r , int d , int n ) { this . l = l ; this . r = r ; this . d = d ; } @ Override public int compareTo ( P p ) { if ( l == p . l ) return Integer . compare ( l , p . l ) ; if ( r == p . r ) return Integer . compare ( r , p . r ) ; return Integer . compare ( n , p . d ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = 1 ; while ( n > 0 ) { x *= 2 ; n >>= 1 ; } System . out . println ( ( int ) Math . pow ( 2 , x / 2 ) ) ; } }
import java . util . * ; public class GFG { static void sieve ( boolean prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } static int sumPrime ( int d ) { int maxVal = ( int ) ( Math . sqrt ( d ) - 1 ) ; boolean prime [ ] = new boolean [ maxVal + 1 ] ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int d = 3 ; System . out . println ( sumPrime ( d ) ) ; } }
import java . util . * ; public class GFG { static void sieve ( boolean prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } static int sumPrime ( int d ) { int maxVal = ( int ) ( Math . pow ( 2 , d ) - 1 ) ; boolean prime [ ] = new boolean [ maxVal + 1 ] ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int d = 8 ; System . out . println ( sumPrime ( d ) ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int sum = 0 ; int count = 0 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] * ( j + 1 ) >= x ) { count ++ ; } sum += arr [ j ] ; } System . out . println ( count ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int ans = 0 ; if ( A > B && B > C ) ans ++ ; if ( A == B && B == C ) ans ++ ; System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int maxPartitions ( int arr [ ] , int n ) { int ans = 0 ; int max_so_far = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( maxPartitions ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int countMaxContiguous ( int arr [ ] , int n ) { int current_max = 0 ; int max_so_far = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) current_max = 0 ; else { current_max ++ ; max_so_far = Math . max ( current_max , max_so_far ) ; } } return max_so_far ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 2 , 4 , 3 , 8 , 9 } ; int n = arr . length ; System . out . println ( countMaxContiguous ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static float cubeSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) ; return a ; } public static void main ( String [ ] args ) { float h = 5 , r = 6 ; System . out . println ( cubeSide ( h , r ) ) ; } }
import java . io . * ; public class GFG { static void pattern ( int rows_no ) { for ( int i = 1 ; i <= rows_no ; i ++ ) { for ( int k = 1 ; k <= i ; k ++ ) System . out . print ( " ▁ " ) ; for ( int j = i ; j <= rows_no ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } for ( int i = rows_no - 1 ; i >= 1 ; i -- ) { for ( int k = 1 ; k <= i ; k ++ ) System . out . print ( " ▁ " ) ; for ( int j = i ; j <= rows_no ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } for ( int i = rows_no - 1 ; i >= 1 ; i -- ) { for ( int k = 1 ; k <= i ; k ++ ) System . out . print ( " ▁ " ) ; for ( int j = i ; j <= rows_no ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int rows_no = 7 ; pattern ( rows_no ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i < n ; i ++ ) { int a = i ; int b = n - i ; ans = Math . min ( ans , a + b ) ; } System . out . println ( ans ) ; } }
public class GFG { static boolean check_digits ( int n ) { while ( n > 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; } static int smallest_number ( int n ) { int i = n ; while ( true ) { if ( check_digits ( i ) ) return i ; i ++ ; } } public static void main ( String [ ] args ) { int N = 2397 ; System . out . println ( smallest_number ( N ) ) ; } }
import java . io . * ; public class GFG { static boolean check_digits ( int n ) { while ( n > 0 ) { if ( ( n % 10 ) % 2 == 1 ) return false ; n /= 10 ; } return true ; } static int smallest_number ( int n ) { for ( int i = n ; i < 2401 ; i ++ ) if ( check_digits ( i ) == 1 ) return ( i ) ; return 0 ; } public static void main ( String [ ] args ) { int N = 2397 ; System . out . println ( smallest_number ( N ) ) ; } }
import java . io . * ; public class GFG { static void triangular_series ( int n ) { int j = 1 , k = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( k + " ▁ " ) ; j ++ ; k += j ; } } public static void main ( String [ ] args ) { int n = 5 ; triangular_series ( n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ m ] ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( map . containsKey ( arr [ i ] ) ) { map . put ( arr [ i ] , map . get ( arr [ i ] ) + 1 ) ; } else { map . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( int val : map . keySet ( ) ) { int val_ = map . get ( val ) ; if ( val == 1 ) { ans += ( n - val_ ) ; } else { ans += n - val_ ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int findPosition ( int k , int n ) { int f1 = 0 , f2 = 1 ; int i = 2 ; while ( i != 0 ) { int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) return n * i ; i ++ ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 5 , k = 4 ; System . out . println ( " Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in ▁ Fibonacci ▁ Series ▁ is ▁ " + findPosition ( k , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; if ( s . length ( ) % 2 == 1 ) { System . out . println ( " Second " ) ; } else { System . out . println ( " First " ) ; } } }
import java . io . * ; public class GFG { static int countMinimumMoves ( int arr [ ] , int n , int k ) { for ( int i = k - 1 ; i < n ; i ++ ) if ( arr [ i ] != arr [ k - 1 ] ) return - 1 ; for ( int i = k - 1 ; i >= 0 ; i -- ) if ( arr [ i ] != arr [ k - 1 ] ) return i + 1 ; return 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int K = 4 ; int n = arr . length ; System . out . println ( countMinimumMoves ( arr , n , K ) ) ; } }
public class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int powerGCD ( int a , int b , int n ) { int e = power ( a , n , b ) ; return gcd ( e , b ) ; } public static void main ( String [ ] args ) { int a = 5 , b = 4 , n = 2 ; System . out . println ( powerGCD ( a , b , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; double t = sc . nextInt ( ) ; double s = sc . nextInt ( ) ; double q = sc . nextInt ( ) ; double ans = 0 ; double x = ( double ) q ; for ( double i = s ; i > 0 ; i -- ) { double a = ( double ) i / ( double ) q ; ans ++ ; if ( a >= 1.0 * s ) { s = s - a ; } else { break ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; System . out . println ( ( n - 2 ) * ( n - 2 ) ) ; } }
import java . util . * ; public class GFG { static int countIdenticalRows ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { HashSet < Integer > hs = new HashSet < Integer > ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) hs . add ( mat [ i ] [ j ] ) ; if ( hs . size ( ) == 1 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 2 , 3 } , { 5 , 5 , 5 } } ; System . out . println ( countIdenticalRows ( mat ) ) ; } }
import java . util . * ; public class GFG { static void createSorted ( int a [ ] , int n ) { Vector < Integer > b = new Vector < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( b . size ( ) == 0 ) { b . add ( a [ j ] ) ; } else { int start = 0 , end = b . size ( ) - 1 , pos = 0 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( b . get ( mid ) == a [ j ] ) { b . add ( Math . max ( 0 , mid + 1 ) ) ; break ; } else if ( b . get ( mid ) > a [ j ] ) { pos = end = mid - 1 ; } else { pos = start = mid + 1 ; } if ( start > end ) { pos = start ; b . add ( Math . max ( 0 , pos ) ) ; break ; } } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( b . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 2 , 5 , 4 , 9 , 8 } ; int n = a . length ; createSorted ( a , n ) ; } }
import java . util . * ; public class GFG { static int countTotalDistinct ( String str ) { int cnt = 0 ; Set < String > items = new HashSet < String > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { String temp = " " ; Set < String > ans = new HashSet < String > ( ) ; for ( int j = i ; j < str . length ( ) ; j ++ ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; } public static void main ( String [ ] args ) { String str = " ABCA " ; System . out . println ( countTotalDistinct ( str ) ) ; } }
import java . io . * ; public class GFG { static int firstDigit ( int n ) { int digits = ( int ) ( Math . log10 ( n ) ) ; n = n / ( int ) Math . pow ( 10 , digits ) ; return n ; } static int lastDigit ( int n ) { return ( n % 10 ) ; } public static void main ( String [ ] args ) { int n = 98562 ; System . out . print ( firstDigit ( n ) + " ▁ " ) ; System . out . print ( lastDigit ( n ) ) ; } }
import java . io . * ; public class GFG { static void removeZeros ( int a [ ] , int n ) { int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != 0 ) { ind = i ; break ; } } if ( ind == - 1 ) { System . out . print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) ; return ; } int b [ ] = new int [ n - ind ] ; for ( int i = 0 ; i < n - ind ; i ++ ) b [ i ] = a [ ind + i ] ; for ( int i = 0 ; i < n - ind ; i ++ ) System . out . print ( b [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , 0 , 0 , 1 , 2 , 0 , 3 } ; int n = a . length ; removeZeros ( a , n ) ; } }
import java . util . * ; public class GFG { static int find_maxm ( int arr [ ] , int n ) { Map < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mpp . containsKey ( arr [ i ] ) ) { mpp . put ( arr [ i ] , mpp . get ( arr [ i ] ) + 1 ) ; } else { mpp . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > entry : mpp . entrySet ( ) ) { if ( entry . getValue ( ) == entry . getKey ( ) ) { ans = Math . max ( ans , entry . getKey ( ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . println ( find_maxm ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int [ ] arr_sorted = arr . clone ( ) ; Arrays . sort ( arr_sorted ) ; int i = 0 , j = n - 1 ; while ( i < n - 1 && arr [ i ] <= arr_sorted [ j ] ) { i ++ ; j -- ; } i -- ; j -- ; int k = n - 1 ; while ( i < j ) { if ( arr [ i ] <= arr_sorted [ k ] ) { arr_sorted [ k ] = arr_sorted [ k ] ; k -- ; } else if ( arr [ i ] <= arr_sorted [ j ] ) { arr_sorted [ k ] = arr_sorted [ k ] ; i ++ ; } else { j -- ; k ++ ; } } System . out . println ( arr_sorted [ i ] ) ; } }
import java . io . * ; public class GFG { static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x > 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; } static int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } static int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; } public static void main ( String [ ] args ) { int N = 35 ; System . out . println ( sumOfDigitsTwoParts ( N ) ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc ; static final int INF = 1 << 28 ; static final double EPS = 1e-9 ; class N { double x , y ; N ( double x , double y ) { this . x = x ; this . y = y ; } @ Override public boolean equals ( Object o ) { return ( ( N ) o ) . x == x ; } } void run ( ) { sc = new Scanner ( System . in ) ; for ( ; sc . hasNext ( ) ; ) { double x = sc . nextDouble ( ) ; double y = sc . nextDouble ( ) ; println ( " AAA " + ( x / 500.0 ) + " " + ( y / 500.0 ) * 60 + " ▁ " + ( ( x - 500.0 ) * 75.0 ) / 100.0 ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int ans = 0 ; if ( n == 1 ) { ans = c ; } else if ( n == 2 ) { if ( r == 1 ) { ans = r - 1 ; } else { ans = r - 2 ; } } else if ( m == 2 ) { if ( c == 1 ) { ans = c - 2 ; } else { ans = c - 2 ; } } else { if ( r == 1 ) { ans = r - 2 ; } else { ans = r - 2 ; } } System . out . println ( ans ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; boolean flag = true ; for ( int j = 1 ; j < n ; j ++ ) { if ( arr [ j ] - arr [ j - 1 ] > 1 ) { flag = false ; break ; } } if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . lang . Math ; public class Main { public static void main ( String [ ] args ) { int n = 90 ; cal_sin ( n ) ; } public static void cal_sin ( int n ) { double accuracy = 0.0001 ; n = ( int ) ( n * ( 3.142 / 180.0 ) ) ; double x1 = n ; double sinx = n ; double sinval = Math . sin ( n ) ; int i = 1 ; while ( true ) { double denominator = 2 * i * ( 2 * i + 1 ) ; x1 = - x1 * n * n / denominator ; sinx = sinx + x1 ; i = i + 1 ; if ( accuracy <= Math . abs ( sinval - sinx ) ) { break ; } } System . out . println ( Math . round ( sinx ) ) ; } }
import java . io . * ; public class GFG { static int multiply ( int array [ ] , int n ) { int pro = 1 ; for ( int i = 0 ; i < n ; i ++ ) pro = pro * array [ i ] ; return pro ; } public static void main ( String [ ] args ) { int array [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = array . length ; System . out . println ( multiply ( array , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] map = new long [ 64 ] ; for ( int i = 0 ; i < n ; i ++ ) { int odr = sc . nextInt ( ) ; switch ( odr ) { case 0 : map [ sc . nextInt ( ) ] ++ ; break ; case 1 : if ( map [ sc . nextInt ( ) ] == 1 ) { System . out . println ( 1 ) ; } else { System . out . println ( 0 ) ; } break ; case 2 : if ( map [ sc . nextInt ( ) ] == 2 ) { System . out . println ( 1 ) ; } else { System . out . println ( 0 ) ; } break ; case 3 : if ( map [ sc . nextInt ( ) ] == 1 ) { System . out . println ( 1 ) ; } else { int r1 = sc . nextInt ( ) ; int r2 = sc . nextInt ( ) ; map [ r1 ] = ( long ) Math . pow ( 2 , r1 ) * Math . pow ( 2 , r2 ) ; map [ r2 ] = ( long ) Math . pow ( 2 , r1 ) * Math . pow ( 2 , r2 ) ; } break ; case 4 : if ( map [ sc . nextInt ( ) ] == 1 ) { System . out . println ( 0 ) ; } else { System . out . println ( 1 ) ; } break ; case 5 : if ( map [ sc . nextInt ( ) ] == 0 ) { System . out . println ( 1 ) ; } else { long r = map [ sc . nextInt ( ) ] ; long x = map [ sc . nextInt ( ) ] ; for ( int i = 0 ; i < 64 ; i ++ ) { x += map [ i ] ; } System . out . println ( x ) ; } break ; } } } }
public class Main { public static int bit ( int n ) { int count = 0 ; while ( n != 0 ) { count += 1 ; n = n & ( n - 1 ) ; } return count ; } public static int maxSumOfBits ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int excl_new ; if ( incl > excl ) { excl_new = incl ; } else { excl_new = excl ; } incl = excl + arr [ i ] ; excl = excl_new ; } if ( incl > excl ) { return incl ; } else { return excl ; } } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 } ; int n = arr . length ; System . out . println ( maxSumOfBits ( arr , n ) ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; if ( s . charAt ( 0 ) == ' C ' ) count ++ ; } System . out . println ( count ) ; } }
public class GFG { static int findMinIndex ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return findMinIndex ( arr , low , mid - 1 ) ; return findMinIndex ( arr , mid + 1 , high ) ; } static int binary_search ( int arr [ ] , int l , int h , int x ) { while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= x ) l = mid + 1 ; else h = mid - 1 ; } return h ; } static int countEleLessThanOrEqual ( int arr [ ] , int n , int x ) { int min_index = findMinIndex ( arr , 0 , n - 1 ) ; if ( x <= arr [ n - 1 ] ) return ( binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ) ; if ( ( min_index - 1 ) >= 0 && x <= arr [ min_index - 1 ] ) return ( n - min_index + binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) ; return n ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 10 , 12 , 15 , 2 , 4 , 5 } ; int n = arr . length ; int x = 14 ; System . out . print ( " Count ▁ = ▁ " ) ; System . out . print ( countEleLessThanOrEqual ( arr , n , x ) ) ; } }
public class GFG { static double f ( double x , double y ) { double v = y - 2 * x * x + 1 ; return v ; } static double predict ( double x , double y , double h ) { double y1p = y + h * f ( x , y ) ; return y1p ; } static double correct ( double x , double y , double x1 , double y1 , double h ) { double e = 0.00001 ; double y1c = y1 ; while ( Math . abs ( y1c - y1 ) > e ) { y1 = y1c ; y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) ; } return y1c ; } static void printFinalValues ( double x , double xn , double y , double h ) { while ( x < xn ) { double x1 = x + h ; double y1p = predict ( x , y , h ) ; double y1c = correct ( x , y , x1 , y1p , h ) ; x = x1 ; y = y1c ; } System . out . println ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = ▁ " + x + " ▁ is ▁ : ▁ " + String . format ( " % . 4 f " , y ) ) ; } public static void main ( String [ ] args ) { double x = 0 , y = 0.5 , xn = 1 , y = 0.2 ; printFinalValues ( x , xn , y , h ) ; } }
import java . io . * ; public class GFG { static String D_Pattern ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == 1 || ( ( i == 0 || i == n - 1 ) && ( j > 1 && j < n - 2 ) ) || ( j == n - 2 && i != 0 && i != n - 1 ) ) { str = str + " * " ; } else { str = str + " ▁ " ; } } } return ( str ) ; } public static void main ( String [ ] args ) { String str = " " ; int n = 9 ; System . out . println ( D_Pattern ( str , n ) ) ; } }
import java . io . * ; public class GFG { static void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; for ( int j = 1 ; j <= first_y_position ; j ++ ) { System . out . print ( " x " ) ; } System . out . print ( " y " ) ; int j = first_y_position + 1 ; while ( second_y_position > 1 ) { System . out . print ( " x " ) ; second_y_position -- ; j ++ ; } System . out . print ( " y " ) ; while ( j < n ) { System . out . print ( " x " ) ; j ++ ; } } public static void main ( String [ ] args ) { int n = 5 , k = 7 ; kthString ( n , k ) ; } }
import java . io . * ; public class GFG { static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int count_of_subarrays ( int N ) { int count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( count_of_subarrays ( N ) ) ; } }
public class Solution { public int [ ] productExceptSelf ( int [ ] nums ) { int [ ] ans = new int [ nums . length ] ; for ( int i = 1 ; i < nums . length ; i ++ ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; int right = 1 ; for ( int i = nums . length - 1 ; i >= 0 ; i -- ) { ans [ i ] *= right ; right *= nums [ i ] ; } return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 1 , 2 , 3 , 4 } ; int [ ] out = sObj . productExceptSelf ( nums ) ; System . out . println ( Arrays . toString ( out ) ) ; } }
public class GFG { static void getSmallestAndLargest ( String s , int k ) { String currStr = s . substring ( 0 , k ) ; String lexMin = currStr ; String lexMax = currStr ; for ( int i = k ; i < s . length ( ) ; i ++ ) { currStr = currStr . substring ( 1 , k ) + s . charAt ( i ) ; if ( lexMax < currStr ) lexMax = currStr ; if ( lexMin > currStr ) lexMin = currStr ; } System . out . println ( lexMin ) ; System . out . println ( lexMax ) ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int k = 3 ; getSmallestAndLargest ( str , k ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ n - i - 1 ] + " ▁ " ) ; } } }
import java . io . * ; public class GFG { static int INT_BITS = 32 ; static int maxSubarrayXOR ( int set [ ] , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = Integer . MIN_VALUE ; for ( int j = index ; j < n ; j ++ ) { if ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) { maxEle = set [ j ] ; maxInd = j ; } } if ( maxEle == Integer . MIN_VALUE ) continue ; int temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; maxInd = index ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) { set [ j ] = set [ j ] ^ set [ maxInd ] ; } } index = index + 1 ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ set [ i ] ; return res ; } public static void main ( String [ ] args ) { int set [ ] = { 9 , 8 , 5 } ; int n = set . length ; System . out . println ( " Max ▁ subset ▁ XOR ▁ is ▁ " ) ; System . out . println ( maxSubarrayXOR ( set , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ 101 ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; a [ x ] ++ ; if ( a [ x ] > max ) { max = a [ x ] ; } } System . out . println ( max + " ▁ " + a [ max ] ) ; } }
import java . util . * ; public class GFG { static int partition ( int arr [ ] , int si , int ei ) { int x = arr [ ei ] ; int i = si - 1 ; for ( int j = si ; j < ei ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ ei ] ; arr [ ei ] = arr [ i + 1 ] ; return ( i + 1 ) ; } static void quickSort ( int arr [ ] , int si , int ei ) { int pi = 0 ; if ( si < ei ) { pi = partition ( arr , si , ei ) ; quickSort ( arr , si , pi - 1 ) ; quickSort ( arr , pi + 1 , ei ) ; } } static void minAbsSumPair ( int arr [ ] , int n ) { int sum = 0 , min_sum = Integer . MAX_VALUE ; int l = 0 , r = n - 1 ; int min_l = l , min_r = n - 1 ; if ( n < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } quickSort ( arr , l , r ) ; while ( l < r ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( sum ) < Math . abs ( min_sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } if ( sum < 0 ) l ++ ; else r -- ; } System . out . println ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_l ] + " ▁ and ▁ " + arr [ min_r ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 60 , - 10 , 70 , - 80 , 85 } ; int n = arr . length ; minAbsSumPair ( arr , n ) ; } }
import java . util . * ; public class Solution { public int firstUniqChar ( String s ) { HashMap < Character , Integer > countMap = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( countMap . containsKey ( s . charAt ( i ) ) ) { countMap . put ( s . charAt ( i ) , countMap . get ( s . charAt ( i ) ) + 1 ) ; } else countMap . put ( s . charAt ( i ) , 1 ) ; } return - 1 ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String s = " leetcode " ; int out = sObj . firstUniqChar ( s ) ; System . out . println ( out ) ; } }
import java . util . LinkedList ; import java . util . Queue ; public class StackPermutation { public static boolean checkStackPermutation ( int [ ] ip , int [ ] op , int n ) { Queue < Integer > input = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { input . add ( ip [ i ] ) ; } Queue < Integer > output = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { output . add ( op [ i ] ) ; } LinkedList < Integer > tempStack = new LinkedList < > ( ) ; while ( ! input . isEmpty ( ) ) { int ele = input . peek ( ) ; input . poll ( ) ; if ( ele == output . peek ( ) ) { output . poll ( ) ; while ( ! tempStack . isEmpty ( ) ) { if ( tempStack . peekLast ( ) == output . peek ( ) ) { tempStack . pollLast ( ) ; output . poll ( ) ; } else { break ; } } } else { tempStack . add ( ele ) ; } } return ( input . isEmpty ( ) && tempStack . isEmpty ( ) ) ; } public static void main ( String [ ] args ) { int [ ] input = { 1 , 2 , 3 } ; int [ ] output = { 2 , 1 , 3 } ; int n = 3 ; if ( checkStackPermutation ( input , output , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " Not ▁ Possible " ) ; } } }
import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; Map < Character , List < Character > > s = new HashMap < > ( ) ; Map < Character , List < Character > > t = new HashMap < > ( ) ; char [ ] S = scanner . nextLine ( ) . toCharArray ( ) ; char [ ] T = scanner . nextLine ( ) . toCharArray ( ) ; for ( int i = 0 ; i < S . length ; i ++ ) { if ( ! s . containsKey ( S [ i ] ) ) { s . put ( S [ i ] , new ArrayList < > ( ) ) ; } if ( ! t . containsKey ( T [ i ] ) ) { t . put ( T [ i ] , new ArrayList < > ( ) ) ; } if ( ! s . get ( S [ i ] ) . contains ( T [ i ] ) ) { s . get ( S [ i ] ) . add ( T [ i ] ) ; if ( s . get ( S [ i ] ) . size ( ) >= 2 ) { System . out . println ( " No " ) ; break ; } } if ( ! t . get ( T [ i ] ) . contains ( S [ i ] ) ) { t . get ( T [ i ] ) . add ( S [ i ] ) ; if ( t . get ( T [ i ] ) . size ( ) >= 2 ) { System . out . println ( " No " ) ; break ; } } if ( i == S . length - 1 ) { System . out . println ( " Yes " ) ; } } } }
import java . io . * ; public class GFG { static int getSum ( int n , int d ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i % 10 == d ) sum += i ; } return sum ; } public static void main ( String [ ] args ) { int n = 30 , d = 3 ; System . out . println ( getSum ( n , d ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; int cost = 0 ; if ( a < b ) { cost = Math . min ( a - r , b - c ) ; } else if ( b < a ) { cost = Math . min ( a - r , b - c ) ; } else { cost = Math . min ( a - r , b - c ) ; } if ( cost < cost ) System . out . println ( cost ) ; else System . out . println ( cost ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int ans = n ; if ( s < t ) { ans ++ ; } else { ans -- ; } if ( s == t ) { ans -- ; } System . out . println ( ans ) ; } } }
import java . io . * ; public class GFG { static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } public static void main ( String [ ] args ) { int N = 10 ; int K = 2 ; System . out . println ( findSum ( N , K ) ) ; } }
import java . util . Scanner ; public class B_Yet_Another_Dividing_into_Teams { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int ans = 0 ; for ( int j = 1 ; j <= a ; j ++ ) { int count = 0 ; while ( j <= a ) { if ( j % 4 == 0 ) { count ++ ; j /= 4 ; } else { ans += 1 ; count ++ ; } } ans += count ; } System . out . println ( ans ) ; } } }
import java . io . * ; public class GFG { static double PI = 3.14 ; static double find_area ( double r , double d ) { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; } public static void main ( String [ ] args ) { double r = 4 , d = 5 ; System . out . println ( find_area ( r , d ) ) ; } }
import java . io . * ; public class GFG { static int minimumNumbers ( int n , int s ) { if ( s % n == 0 ) return s / n + 1 ; else return s / n ; } public static void main ( String [ ] args ) { int n = 5 , s = 11 ; System . out . println ( minimumNumbers ( n , s ) ) ; } }
import java . util . * ; public class GFG { static int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int end = n - 1 ; end >= 1 ; end -- ) { int start = 0 ; int mid = end - 1 ; while ( start < mid ) { int prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; int n = arr . length ; int m = 1 ; System . out . println ( countTriplets ( arr , n , m ) ) ; } }
import java . io . * ; public class GFG { static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 , res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; } public static void main ( String [ ] args ) { int result = findIndex ( 21 ) ; System . out . println ( result ) ; } }
public class GFG { static boolean isVowel ( char ch ) { if ( ch == ' i ' || ch == ' a ' || ch == ' e ' || ch == ' o ' || ch == ' u ' ) return true ; else return false ; } static boolean isSatisfied ( String str , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str . charAt ( i ) ) && ! isVowel ( str . charAt ( i - 1 ) ) ) return false ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ! isVowel ( str . charAt ( i ) ) && ! isVowel ( str . charAt ( i - 1 ) ) && ! isVowel ( str . charAt ( i + 1 ) ) ) return false ; } return true ; } public static void main ( String [ ] args ) { String str = " acaba " ; int n = str . length ( ) ; if ( isSatisfied ( str , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int countWays ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; return dp [ n ] ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( countWays ( n ) ) ; } }
import java . io . * ; public class GFG { static double expect ( double m , int n ) { double ans = 0.0 ; for ( int i = m ; i > 0 ; i -- ) { ans += Math . pow ( i / m , n ) - Math . pow ( ( i - 1 ) / m , n ) ) * i ; } return ans ; } public static void main ( String [ ] args ) { double m = 6 , n = 3 ; System . out . println ( expect ( m , n ) ) ; } }
import java . io . * ; public class GFG { static int ProdOfPrimes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int prod = 1 ; for ( int i = 2 ; i <= n ; i ++ ) if ( prime [ i ] ) prod *= i ; return prod ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( ProdOfPrimes ( n ) ) ; } }
public final class p036 { public static void main ( String [ ] args ) { System . out . println ( new p036 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int y = 1901 ; y <= 2001 ; y ++ ) { for ( int m = 1 ; m <= 12 ; m ++ ) { if ( date ( y , m , 1 ) == 6 ) count ++ ; } } return Integer . toString ( count ) ; } private static int date ( int y , int m , int d ) { int sum = 0 ; for ( int y = 1 ; y <= 12 ; y ++ ) { if ( y == 1 && m == 1 ) sum ++ ; } return sum ; } }
import java . io . * ; public class GFG { static class Date { int d , m , y ; static int monthDays [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 31 , 30 , 31 , 31 } ; static int countLeapYears ( int d ) { int years = d . y ; if ( d . m <= 2 ) years -- ; return ( years / 4 - years / 100 + years / 400 ) ; } static int getDifference ( Date dt1 , Date dt2 ) { int n1 = dt1 . y * 365 + dt1 . d ; for ( int i = 0 ; i < dt1 . m ; i ++ ) n1 += monthDays [ i ] ; int n2 = dt2 . y * 365 + dt2 . d ; for ( int i = 0 ; i < dt2 . m ; i ++ ) n2 += monthDays [ i ] ; n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; } public static void main ( String [ ] args ) { Date dt1 = new Date ( 1 , 2 , 2000 ) ; Date dt2 = new Date ( 1 , 2 , 2004 ) ; System . out . println ( " Difference ▁ between ▁ two ▁ dates ▁ is ▁ " + getDifference ( dt1 , dt2 ) ) ; } }
import java . util . * ; public class Main { static Set < Integer > st = new HashSet < > ( ) ; public static void generateNumbers ( int n , int num , int a , int b ) { if ( num > 0 && num < n ) { st . add ( num ) ; } if ( num >= n ) { return ; } if ( num * 10 + a > num ) { generateNumbers ( n , num * 10 + a , a , b ) ; } generateNumbers ( n , num * 10 + b , a , b ) ; } public static void printNumbers ( int n ) { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j ++ ) { generateNumbers ( n , 0 , i , j ) ; } } System . out . print ( " The ▁ numbers ▁ are : ▁ " ) ; List < Integer > l = new ArrayList < > ( st ) ; System . out . println ( l ) ; } public static void main ( String [ ] args ) { int n = 12 ; printNumbers ( n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int min = arr [ 0 ] , max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; } if ( arr [ i ] < min ) min = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; if ( ( n | m ) == 0 ) break ; HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int v = sc . nextInt ( ) ; if ( v == 0 ) continue ; map . put ( v , map . getOrDefault ( v , 0 ) + 1 ) ; } } int max = 0 , min = INF ; for ( int i : map . keySet ( ) ) { if ( map . get ( i ) == max ) { max = i ; min = min ( min , map . get ( i ) ) ; } } System . out . println ( min ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . io . * ; public class GFG { static int getOddOccurrence ( int arr [ ] ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) res = res ^ arr [ i ] ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; System . out . println ( getOddOccurrence ( arr ) ) ; } }
import java . io . * ; public class GFG { static boolean isKthBitSet ( int x , int k ) { if ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) return true ; else return false ; } static boolean isPalindrome ( int x ) { int l = 1 , r = 2 * 8 ; while ( l < r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return false ; l ++ ; r -- ; } return true ; } public static void main ( String [ ] args ) { int x = 1 << 15 + 1 << 16 ; System . out . println ( isPalindrome ( x ) ) ; x = 1 << 31 + 1 ; System . out . println ( isPalindrome ( x ) ) ; } }
import java . util . * ; public class GFG { static void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static void findPrimePair ( int n ) { int flag = 0 ; boolean [ ] isPrime = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] & isPrime [ x ] && x != i && x * i == n ) { System . out . println ( i + " ▁ " + x ) ; flag = 1 ; break ; } } if ( flag == 0 ) System . out . println ( " No ▁ such ▁ pair ▁ found " ) ; } public static void main ( String [ ] args ) { int n = 39 ; findPrimePair ( n ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 15 ; System . out . println ( " GCD ( " + a + " , ▁ " + b + " ) ▁ = ▁ " + gcd ( a , b ) ) ; a = 35 ; b = 10 ; System . out . println ( " GCD ( " + a + " , ▁ " + b + " ) ▁ = ▁ " + gcd ( a , b ) ) ; a = 31 ; b = 2 ; System . out . println ( " GCD ( " + a + " , ▁ " + b + " ) ▁ = ▁ " + gcd ( a , b ) ) ; a = 10 ; System . out . println ( " GCD ( " + a + " , ▁ " + b + " ) ▁ = ▁ " + gcd ( a , b ) ) ; } }
public class Main { public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { int a = 10 ; int b = 15 ; System . out . println ( " GCD ( " + a + " , " + b + " ) ▁ = " + gcd ( a , b ) ) ; a = 35 ; b = 10 ; System . out . println ( " GCD ( " + a + " , " + b + " ) ▁ = " + gcd ( a , b ) ) ; a = 31 ; b = 2 ; System . out . println ( " GCD ( " + a + " , " + b + " ) ▁ = " + gcd ( a , b ) ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int SIZE_LIMIT = 1000000 ; int TYPE_LIMIT = 10 ; int [ ] type = new int [ SIZE_LIMIT + 1 ] ; for ( int n = 3 ; n <= SIZE_LIMIT / 4 + 1 ; n ++ ) { for ( int m = n - 2 ; m >= 1 ; m -- ) { int tiles = n * n - m * m ; if ( tiles > SIZE_LIMIT ) break ; type [ tiles ] ++ ; } } int count = 0 ; for ( int x : type ) { if ( 1 <= x && x <= TYPE_LIMIT ) count ++ ; } return Integer . toString ( count ) ; } }
import java . util . Scanner ; public class B_Yet_Another_Meme_Problem { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { String s = sc . next ( ) ; System . out . println ( solve ( s ) ? " YES " : " NO " ) ; } sc . close ( ) ; } static boolean solve ( String s ) { int i = 0 , j = s . length ( ) - 1 ; int cnt = 0 ; int min = Integer . MAX_VALUE ; for ( i = 0 ; i < s . length ( ) ; ++ i ) { if ( s . charAt ( i ) == '0' ) { ++ cnt ; min = Math . min ( min , cnt ) ; } else { ++ cnt ; } if ( cnt < min ) { min = cnt ; } } if ( cnt == min ) { return true ; } for ( i = s . length ( ) - 1 ; i >= 0 ; -- i ) { int j = i + 1 ; if ( s . charAt ( i ) == '0' && j > 0 ) { min = Math . min ( min , cnt ) ; } } for ( i = s . length ( ) - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == '0' && j > 0 ) { min = Math . min ( min , cnt ) ; } } return true ; } }
import java . io . * ; public class GFG { static int maxZeros ( int N ) { int maxm = - 1 ; int cnt = 0 ; while ( N > 0 ) { if ( ( N & 1 ) == 1 ) { cnt ++ ; N >>= 1 ; maxm = Math . max ( maxm , cnt ) ; } else { maxm = Math . max ( maxm , cnt ) ; cnt = 0 ; N >>= 1 ; } } return maxm ; } public static void main ( String [ ] args ) { int N = 14 ; System . out . println ( maxZeros ( N ) ) ; } }
public class Main { public static void getLongestSeq ( int [ ] a , int n ) { int maxIdx = 0 ; int maxLen = 0 ; int currLen = 0 ; int currIdx = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] > 0 ) { currLen += 1 ; if ( currLen == 1 ) { currIdx = k ; } } else { if ( currLen > maxLen ) { maxLen = currLen ; maxIdx = currIdx ; } currLen = 0 ; } } if ( maxLen > 0 ) { System . out . println ( " Index : ▁ " + maxIdx + " , ▁ Length : ▁ " + maxLen ) ; } else { System . out . println ( " No ▁ positive ▁ sequence ▁ detected . " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 } ; int n = arr . length ; getLongestSeq ( arr , n ) ; } }
public class GFG { static class Node { int data ; Node right , down ; } ; static Node construct ( int arr [ ] [ ] , int i , int j , int m , int n ) { if ( i > n - 1 || j > m - 1 ) return null ; Node temp = new Node ( ) ; temp . data = arr [ i ] [ j ] ; temp . right = construct ( arr , i , j + 1 , m , n ) ; temp . down = construct ( arr , i + 1 , j , m , n ) ; return temp ; } static void display ( Node head ) { Node Dp = head ; while ( Dp != null ) { Node Rp = Dp ; while ( Rp != null ) { System . out . print ( Rp . data + " ▁ " ) ; Rp = Rp . right ; } System . out . println ( ) ; Dp = Dp . down ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int m = 3 , n = 3 ; Node head = construct ( arr , 0 , 0 , m , n ) ; display ( head ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Arrays . binarySearch ( a , " " ) < 0 ) { count ++ ; } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static void findNthTerm ( int N ) { int ans ; if ( N % 2 == 0 ) ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 ; else ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int N = 3 ; findNthTerm ( N ) ; } }
import java . io . * ; public class GFG { static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) Math . sqrt ( m + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; i ++ ) an = ( an * a ) % m ; int value [ ] = new int [ m ] ; int cur = an ; for ( int i = 1 ; i <= n ; i ++ ) { if ( value [ cur ] == 0 ) { value [ cur ] = i ; } cur = ( cur * an ) % m ; } cur = b ; for ( int i = 0 ; i <= n ; i ++ ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , m = 5 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; } }
import java . util . * ; public class GFG { static int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) { ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; } else break ; } dp [ ind ] = ans ; return ans ; } } public static void main ( String [ ] args ) { int a [ ] = { 10 , 30 , 40 , 50 , 20 } ; int k = 3 ; int n = a . length ; int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = - 1 ; System . out . println ( FindMinimumCost ( 0 , a , n , k , dp ) ) ; } }
import java . io . * ; public class GFG { static int Probability ( int sum , int times ) { double favorable = 0.0 ; double total = 36.0 ; double probability = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 7 ; j ++ ) { if ( ( i + j ) == sum ) favorable ++ ; } } double gcd1 = gcd ( favorable , ( double ) total ) ; favorable = favorable / gcd1 ; total = total / gcd1 ; probability = Math . pow ( total , times ) ; return probability ; } static double gcd ( int favorable , int total ) { return favorable / gcd1 ; } public static void main ( String [ ] args ) { int sum = 7 , times = 7 ; System . out . print ( 1 + " / " + Probability ( sum , times ) ) ; } }
import java . util . Scanner ; public class Main { static int mod = 998244353 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int inv = 998244353 ; int [ ] frac = new int [ n + k + 1 ] ; frac [ 0 ] = 1 ; for ( int i = 1 ; i <= n + k ; i ++ ) { frac [ i ] = ( frac [ i - 1 ] * i ) % mod ; } long ans = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 0 ; j <= n + k ; j ++ ) { int tmp = j ; ans = ( ans + ( ( ( frac [ i ] * frac [ j ] ) % mod ) * frac [ j ] ) % mod ) % mod ; ans = ( ans - tmp ) % mod ; } } for ( int i = 1 ; i <= k ; i ++ ) { ans = ( ans + ( ( frac [ n + k - 1 ] * frac [ i ] ) % mod ) * frac [ n + k - 1 ] ) % mod ; ans = ( ans + tmp ) % mod ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; int a = sc . nextInt ( ) ; String b = s . substring ( 0 , 1 ) ; int c = s . charAt ( 0 ) ; if ( b . equals ( " BTC " ) ) { sum += ( a * 38 ) ; } else { sum += ( a * 60 ) ; } } System . out . println ( sum ) ; } }
import java . io . * ; public class GFG { static int getCount ( int arr [ ] , int n , int num1 , int num2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == num1 ) break ; } if ( i >= n - 1 ) return 0 ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( arr [ j ] == num2 ) break ; } if ( j == i ) return 0 ; return ( j - i - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 } ; int n = arr . length ; int num1 = 5 , num2 = 4 ; System . out . println ( getCount ( arr , n , num1 , num2 ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; Arrays . sort ( a ) ; int min = INF ; for ( int i = 0 ; i < n - 1 ; i ++ ) { min = min ( min , a [ i + 1 ] - a [ i ] ) ; } System . out . println ( min ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . io . * ; public class GFG { static int countSetBits ( int n ) { int cnt = 0 ; int setBits [ ] = new int [ n + 1 ] ; setBits [ 0 ] = 0 ; setBits [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) setBits [ i ] = setBits [ i / 2 ] ; else setBits [ i ] = setBits [ i - 1 ] + 1 ; } for ( int i = 0 ; i <= n ; i ++ ) cnt += setBits [ i ] ; return cnt ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( countSetBits ( n ) ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int largestGCD1Subset ( int [ ] A , int n ) { int currentGCD = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { currentGCD = gcd ( currentGCD , A [ i ] ) ; if ( currentGCD == 1 ) return n ; } return 0 ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 18 , 6 , 3 } ; int n = A . length ; System . out . println ( largestGCD1Subset ( A , n ) ) ; } }
public class Main { public static void main ( String [ ] args ) { System . out . println ( compute ( ) ) ; } public static String compute ( ) { int [ ] divisors = new int [ 10_000_001 ] ; for ( int i = 2 ; i <= divisors . length / 2 ; i ++ ) { for ( int j = i * 2 ; j < divisors . length ; j += i ) { divisors [ j ] ++ ; } } int ans = 0 ; for ( int i = 2 ; i < divisors . length - 1 ; i ++ ) { if ( divisors [ i ] == divisors [ i + 1 ] ) { ans ++ ; } } return Integer . toString ( ans ) ; } }
import java . io . * ; public class GFG { static void updateArray ( int arr [ ] , int n ) { int i ; for ( i = n - 1 ; i > 0 ; i -- ) { arr [ i ] = arr [ i - 1 ] ; } arr [ 0 ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; updateArray ( arr , N ) ; } }
import java . io . * ; public class GFG { static void findEncryptedArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( sum - arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; findEncryptedArray ( arr , N ) ; } }
import java . io . * ; public class GFG { static void updateArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; updateArray ( arr , N ) ; } }
import java . util . * ; public class GFG { static int findMinDifference ( int arr [ ] , int n ) { int min , secondMax , min , secondMin ; if ( arr [ 0 ] < arr [ 1 ] ) min = secondMax = arr [ 0 ] ; else min = secondMax = arr [ 1 ] ; if ( arr [ 0 ] < arr [ 1 ] ) max = secondMin = arr [ 1 ] ; else max = secondMin = arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) secondMax = arr [ i ] ; else if ( arr [ i ] > secondMin ) secondMin = arr [ i ] ; else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) secondMin = arr [ i ] ; } int diff = Math . min ( max - secondMin , secondMax - min ) ; return diff ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( findMinDifference ( arr , n ) ) ; } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . IOException ; import java . util . HashSet ; import java . util . Set ; import java . lang . Math ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String input = br . readLine ( ) ; int n = Integer . parseInt ( input ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] line = br . readLine ( ) . split ( " ▁ " ) ; a [ i ] = Integer . parseInt ( line [ 0 ] ) ; b [ i ] = Integer . parseInt ( line [ 1 ] ) ; } Set < Integer > f = factor ( a [ 0 ] , b [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { f = test ( a [ i ] , b [ i ] , f ) ; } if ( f . size ( ) == 0 ) { System . out . println ( " - 1" ) ; } else { for ( int i : f ) { System . out . println ( i ) ; break ; } } } public static Set < Integer > factor ( int a , int b ) { Set < Integer > ret = new HashSet < > ( ) ; int i = 2 ; while ( i <= Math . sqrt ( Math . max ( a , b ) ) ) { while ( a % i == 0 ) { ret . add ( i ) ; a /= i ; } while ( b % i == 0 ) { ret . add ( i ) ; b /= i ; } i ++ ; } if ( a >= 2 ) { ret . add ( a ) ; } if ( b >= 2 ) { ret . add ( b ) ; } return ret ; } public static Set < Integer > test ( int a , int b , Set < Integer > s ) { Set < Integer > ret = new HashSet < > ( ) ; for ( int i : s ) { if ( a % i == 0 || b % i == 0 ) { ret . add ( i ) ; } } return ret ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; while ( stdIn . hasNext ( ) ) { int n = stdIn . nextInt ( ) ; if ( n == 0 ) { break ; } int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = stdIn . nextInt ( ) ; } Arrays . sort ( a ) ; int min = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= min ) { min = a [ i ] ; } } System . out . println ( ( a [ n - 1 ] == n - min ) ? " NO ▁ COLOR " : a [ n - 1 ] ) ; } } }
import java . io . * ; public class GFG { static int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( " Factorial ▁ of ▁ " + num + " ▁ is ▁ " + factorial ( 5 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int [ ] [ ] w = new int [ d ] [ d ] ; for ( int i = 0 ; i < d ; i ++ ) { for ( int j = 0 ; j < d ; j ++ ) { w [ i ] [ j ] = sc . nextInt ( ) ; } } int [ ] [ ] dp = new int [ d ] [ d ] ; int ans = 0 ; for ( int i = 0 ; i < d ; i ++ ) { for ( int j = 0 ; j < d ; j ++ ) { int [ ] [ ] next = new int [ d ] [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( k < x ) { next [ k ] [ j ] = dp [ k ] [ j ] ; } else { next [ k ] [ j ] = dp [ k ] [ j ] ; } if ( next [ k ] [ j ] > 0 ) { next [ k ] [ j ] = Math . max ( next [ k ] [ j ] , next [ k ] [ j ] + w [ i ] [ j ] - next [ i ] [ j ] ) ; } } } ans += next [ 0 ] [ d ] ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n + 1 ] ; long [ ] b = new long [ n + 1 ] ; long [ ] c = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; } for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = a [ i - 1 ] + a [ i ] ; } Arrays . sort ( a ) ; for ( int i = 1 ; i <= n ; i ++ ) { b [ i ] = b [ i - 1 ] + a [ i ] ; } int m = sc . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int f = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; if ( f == 1 ) { System . out . println ( a [ t ] - a [ 1 ] ) ; } else { System . out . println ( b [ t ] - b [ 1 ] ) ; } } } }
import java . util . * ; public class GFG { static int findMinimumX ( int a [ ] , int n ) { HashSet < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) st . add ( a [ i ] ) ; if ( st . size ( ) == 1 ) return 0 ; if ( st . size ( ) == 2 ) { st = new HashSet < Integer > ( ) ; int el1 = st . get ( 0 ) ; int el2 = st . get ( 1 ) ; if ( ( el2 - el1 ) % 2 == 0 ) return ( ( el2 - el1 ) / 2 ) ; else return ( el2 - el1 ) ; } if ( st . size ( ) == 3 ) { int el1 = st . get ( 0 ) ; int el2 = st . get ( 1 ) ; int el3 = st . get ( 2 ) ; if ( ( el2 - el1 ) == ( el3 - el2 ) ) return ( el2 - el1 ) ; else return - 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 4 , 7 , 4 , 1 } ; int n = a . length ; System . out . print ( findMinimumX ( a , n ) ) ; } }
import java . util . * ; public class GFG { static int findX ( int n , int k ) { int r = n ; int m = ( int ) Math . sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) i = k ; int u = 0 , v = 0 ; while ( k % i == 0 ) { k /= i ; v ++ ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } } return r ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . println ( findX ( n , k ) ) ; } }
import java . io . * ; public class GFG { static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) System . out . println ( " Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle " ) ; else System . out . println ( " Given ▁ point ▁ does ▁ not ▁ lie ▁ on ▁ the ▁ rectangle " ) ; } }
import java . io . * ; public class GFG { static int N = 1000 ; static int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ ] = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) ans += ( freq [ i ] * freq [ j ] ) ; } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
public class Main { public static double getAvg ( int x , int n , double sum ) { sum = sum + x ; return ( double ) sum / n ; } public static void streamAvg ( int [ ] arr , int n ) { double avg = 0 ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( arr [ i ] , i + 1 , sum ) ; sum = avg * ( i + 1 ) ; System . out . print ( " Average ▁ of ▁ " ) ; System . out . print ( i + 1 ) ; System . out . print ( " ▁ numbers ▁ is ▁ " ) ; System . out . println ( avg ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }
import java . util . * ; public class GFG { static int MAX = 10000 ; static Set < Integer > s = new HashSet < > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] == true ) { product = product * p ; s . add ( product + 1 ) ; } } } static boolean isEuclid ( int n ) { if ( s . contains ( n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { int evens = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 0 ) evens ++ ; else if ( arr [ j ] == 1 ) evens ++ ; } if ( evens == arr . length - 1 ) { int diff = arr [ i ] - arr [ i + 1 ] ; res ++ ; if ( diff > b ) res ++ ; } } } System . out . println ( res ) ; } }
public class GFG { static int maxOperations ( String str ) { int i , g = 0 , gk = 0 , gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' g ' ) g ++ ; else if ( str . charAt ( i ) == ' k ' ) { if ( g > 0 ) g -- ; gk ++ ; } else if ( str . charAt ( i ) == ' s ' ) { if ( gk > 0 ) { gk -- ; gks ++ ; } } } return gks ; } public static void main ( String [ ] args ) { String a = " ggkssk " ; System . out . println ( maxOperations ( a ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] - arr [ i + 1 ] > 1 ) { sum ++ ; } } System . out . println ( n - sum ) ; } }
import java . util . * ; public class BallsOfSteals { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; ArrayList < ArrayList < Integer > > al = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { al . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; al . get ( a ) . add ( b ) ; al . get ( b ) . add ( a ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int v = i ; int count = 0 ; int u = 0 ; int v1 = i ; while ( u != v ) { int v2 = u ; u = v2 ; v1 = v2 ; count ++ ; if ( al . get ( v2 ) . size ( ) == 1 && al . get ( v1 ) . get ( u ) == 1 ) { break ; } } u = v1 ; v1 = u ; count ++ ; } if ( count % 2 == 1 ) { System . out . println ( count ) ; } else { System . out . println ( count + 1 ) ; } } }
import java . util . Arrays ; public class GFG { static int kthSmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 3 , 5 , 7 , 19 } ; int n = arr . length ; int k = 2 ; System . out . println ( " K ' th ▁ smallest ▁ element ▁ is ▁ " + kthSmallest ( arr , n , k ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { System . out . print ( " ▁ " ) ; } else { System . out . print ( arr [ i ] + " ▁ " ) ; } } if ( n == 1 ) { System . out . println ( - 1 ) ; } else { int temp = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n - 2 ] ; arr [ n - 2 ] = temp ; for ( int i = n - 2 ; i > 0 ; i -- ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } } } }
public final class p045 { public static void main ( String [ ] args ) { System . out . println ( new p045 ( ) . run ( ) ) ; } private static final int START_NUM = 1 ; private static final int END_NUM = 500 ; private static final String CROAK_SEQ = " PPPPNNPPPNPPNPN " ; public String run ( ) { int [ ] CROAK_TRIALS = Library . listPrimality ( END_NUM ) ; int globalnumerator = 0 ; int isPrime = Library . listPrimality ( END_NUM ) ; for ( int i = START_NUM ; i <= END_NUM ; i ++ ) { for ( int j = 0 ; j < CROAK_TRIALS ; j ++ ) { int pos = i ; int trialnumerator ; if ( isPrime . charAt ( pos ) == ' P ' ) { trialnumerator *= 2 ; } for ( int k = 0 ; k < NUM_JUMPS ; k ++ ) { if ( pos <= START_NUM ) pos ++ ; else if ( pos >= END_NUM ) pos -- ; else if ( ( j & k ) & 1 == 0 ) pos ++ ; else pos -- ; if ( isPrime . charAt ( pos ) == ' P ' ) trialnumerator *= 2 ; } globalnumerator += trialnumerator ; } } int globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ; return Integer . toString ( globalnumerator , globaldenominator ) ; } }
import java . lang . Math ; public class Main { public static void main ( String [ ] args ) { double lat1 = 53.32055555555556 ; double lat2 = 53.31861111111111 ; double lon1 = - 1.7297222222222221 ; double lon2 = - 1.6997222222222223 ; System . out . println ( distance ( lat1 , lat2 , lon1 , lon2 ) + " ▁ K . M " ) ; } public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = Math . sin ( dlat / 2 ) * Math . sin ( dlat / 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . sin ( dlon / 2 ) * Math . sin ( dlon / 2 ) ; double c = 2 * Math . atan2 ( Math . sqrt ( a ) , Math . sqrt ( 1 - a ) ) ; double r = 6371 ; return c * r ; } }
import java . io . * ; public class GFG { static int centeredOctahedral ( int n ) { return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) / 3 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( centeredOctahedral ( n ) ) ; n = 9 ; System . out . println ( centeredOctahedral ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int min = 100 ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ p ] <= s ) { p ++ ; } else { p -- ; } if ( p < 0 ) { min = Math . min ( min , 100 * ( 100 - s - p ) ) ; } else { p ++ ; } } System . out . println ( min * p ) ; } }
import java . util . * ; public class GFG { static void SumDivPrime ( int [ ] A , int n ) { int max_val = Arrays . stream ( A ) . max ( ) . getAsInt ( ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ A [ i ] ] ) sum += A [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ A [ i ] ] && sum % A [ i ] == 0 ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 } ; int n = A . length ; SumDivPrime ( A , n ) ; } }
import java . io . * ; public class GFG { static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . length ; int k = 2 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 3 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 4 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; } }
import java . io . * ; public class GFG { static int closestMultiple ( int n , int x ) { if ( x > n ) return x ; int z = x / 2 ; n = n + z ; n = n - ( n % x ) ; return n ; } public static void main ( String [ ] args ) { int n = 56287 ; int x = 27 ; System . out . println ( closestMultiple ( n , x ) ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long y = sc . nextLong ( ) ; if ( y % 3 == 0 ) { System . out . println ( " cryeadn " ) ; } else { long n = y % 10 ; if ( n == 1 || n == 2 || n == 3 ) { System . out . println ( " cryeadn " ) ; } else { boolean flag = false ; for ( long i = 1 ; i <= n ; i ++ ) { if ( i == 5 || i == 7 ) { flag = true ; break ; } } if ( flag ) { System . out . println ( " cryeadn " ) ; } } } } } }
import java . util . * ; public class GFG { static int [ ] [ ] [ ] dp = new int [ 901 ] [ 8101 ] [ 8101 ] ; static int minimumNumberOfDigits ( int a , int b ) { if ( a > b || a < 0 || b < 0 || a > 900 || b > 8100 ) return - 1 ; if ( a == 0 && b == 0 ) return 0 ; if ( dp [ a ] [ b ] != - 1 ) return dp [ a ] [ b ] ; int ans = 101 ; for ( int i = 9 ; i >= 1 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != - 1 ) ans = Math . min ( ans , k + 1 ) ; } return dp [ a ] [ b ] = ans ; } static void printSmallestNumber ( int a , int b ) { for ( int i = 0 ; i < 901 ; i ++ ) { for ( int j = 0 ; j < 8101 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } dp [ 0 ] [ 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( k == - 1 || k > 100 ) System . out . print ( - 1 ) ; else { while ( a > 0 && b > 0 ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) { System . out . print ( i ) ; a -= i ; b -= i * i ; break ; } } } } } public static void main ( String [ ] args ) { int a = 18 , b = 162 ; printSmallestNumber ( a , b ) ; } }
import java . util . * ; public class GFG { static int N = 5005 ; static int k = 2 ; static List < Integer > [ ] gr = new ArrayList [ N ] ; static int [ ] [ ] d = new int [ N ] [ 505 ] ; static int ans = 0 ; static void Add_edge ( int x , int y ) { gr [ x ] . add ( y ) ; gr [ y ] . add ( x ) ; } static void dfs ( int v , int par ) { d [ v ] [ 0 ] = 1 ; for ( int i = 0 ; i < gr [ v ] . size ( ) ; i ++ ) { if ( gr [ v ] . get ( i ) != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ i ] [ j ] += d [ i ] [ j - 1 ] ; } } } public static void main ( String [ ] args ) { int N = 5 ; int k = 2 ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; System . out . println ( ans ) ; } }
public class GFG { static int findSubsequence ( int arr [ ] , int n ) { int len = 1 ; int [ ] dp = new int [ 10 ] ; int tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( int i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; int locMax = 1 ; int [ ] cnt = new int [ 10 ] ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( int d = 0 ; d < 10 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ d ] ++ ; locMax = Math . max ( locMax , dp [ d ] ) ; } } for ( int d = 0 ; d < 10 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ d ] = locMax ; } } length = Math . max ( len , locMax ) ; } return len ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , 44 , 29 , 33 , 96 , 89 } ; int n = arr . length ; System . out . println ( findSubsequence ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; Set < Integer > s = new TreeSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( sc . nextInt ( ) ) ; } int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( sc . nextInt ( ) ) ) { c ++ ; } } System . out . println ( c ) ; } } }
import java . io . * ; public class GFG { static int totalPrimeFactors ( int n ) { int count = 0 ; if ( ( n % 2 ) == 0 ) { count ++ ; while ( ( n % 2 ) == 0 ) n /= 2 ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( ( n % i ) == 0 ) { count ++ ; while ( ( n % i ) == 0 ) n /= i ; } } if ( n > 2 ) count ++ ; return count ; } static int countPairs ( int G , int L ) { if ( L % G != 0 ) return 0 ; int div = L / G ; return ( 1 << totalPrimeFactors ( div ) ) ; } public static void main ( String [ ] args ) { int G = 2 , L = 12 ; System . out . print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + G + " ▁ & ▁ LCM ▁ " + L + " \n " ) ; System . out . print ( " ▁ = ▁ " + countPairs ( G , L ) ) ; } }
import java . io . * ; public class GFG { static void calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; System . out . println ( " Sum ▁ of ▁ multiples ▁ of ▁ " + a + " ▁ up ▁ to ▁ " + N + " ▁ = ▁ " + ans ) ; } public static void main ( String [ ] args ) { calculate_sum ( 7 , 49 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; Map < String , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String name = sc . next ( ) ; int value = sc . nextInt ( ) ; if ( map . containsKey ( name ) ) { int value = map . get ( name ) ; map . put ( name , value ) ; } else { map . put ( name , value ) ; } } int count = 0 ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { int value = entry . getValue ( ) ; if ( value / 100 >= k ) { count ++ ; } } System . out . println ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { System . out . print ( String . format ( " % s ▁ % d " , entry . getKey ( ) , value ) ) ; if ( i != count - 1 ) System . out . print ( " ▁ " ) ; } } }
import java . io . * ; public class GFG { static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }
import java . io . * ; public class GFG { static int next ( int arr [ ] , int target ) { int start = 0 ; int end = arr . length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 , 8 , 12 } ; System . out . println ( next ( arr , 8 ) ) ; } }
public class GFG { static String word [ ] = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; static void printWordsWithoutIfSwitch ( int n ) { int [ ] digits = new int [ 10 ] ; int dc = 0 ; while ( true ) { digits [ dc ] = n % 10 ; n = n / 10 ; dc ++ ; if ( n == 0 ) break ; } for ( int i = dc - 1 ; i >= 0 ; i -- ) System . out . print ( word [ digits [ i ] ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 350 ; printWordsWithoutIfSwitch ( n ) ; } }
import java . util . * ; import java . io . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) , k = in . nextInt ( ) , m = in . nextInt ( ) ; ArrayList < Integer > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l . add ( in . nextInt ( ) ) ; } Collections . sort ( l ) ; double max = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { sum += l . get ( i ) ; } else { sum += l . get ( j ) ; } } double temp = ( double ) sum / ( Math . min ( k , m - i ) ) ; if ( temp > max ) { max = temp ; } } pw . println ( max ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
public class GFG { static void solve ( String a , String b ) { int l = a . length ( ) ; int min = 0 , max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a . charAt ( i ) == ' + ' || b . charAt ( i ) == ' + ' || a . charAt ( i ) != b . charAt ( i ) ) max ++ ; if ( a . charAt ( i ) != ' + ' && b . charAt ( i ) != ' + ' && a . charAt ( i ) != b . charAt ( i ) ) min ++ ; } System . out . print ( min + max ) ; } public static void main ( String [ ] args ) { String s1 = " a + c " ; String s2 = " + + b " ; solve ( s1 , s2 ) ; } }
import java . io . * ; public class GFG { static int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 , s = 2 ; System . out . println ( " Total ▁ Ways ▁ = ▁ " + TotalWays ( n , s , k ) ) ; } }
import java . io . * ; public class GFG { static int countEvenOdd ( int n ) { int even_count = 0 ; int odd_count = 0 ; while ( n > 0 ) { int rem = n % 10 ; if ( rem % 2 == 0 ) even_count ++ ; else odd_count ++ ; n /= 10 ; } System . out . println ( " Even ▁ count ▁ : ▁ " + even_count ) ; System . out . println ( " \n Odd ▁ count ▁ : ▁ " + odd_count ) ; if ( even_count % 2 == 0 && odd_count % 2 != 0 ) return 1 ; else return 0 ; } public static void main ( String [ ] args ) { int n = 2335453 ; int t = countEvenOdd ( n ) ; if ( t == 1 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { static int [ ] [ ] c ; static int [ ] [ ] dp ; static int max ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; c = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] [ 0 ] = sc . nextInt ( ) ; c [ i ] [ 1 ] = sc . nextInt ( ) ; } dp = new int [ 2 ] [ k + 1 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = 0 ; max = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( int m = 0 ; m < 10 ; m ++ ) { dp [ i ] [ j ] += c [ m ] [ j ] + dp [ i ] [ j ] ; if ( m < 0 ) dp [ i ] [ j ] = 0 ; } max = 0 ; for ( int j = 0 ; j <= k ; j ++ ) max = Math . max ( max , dp [ i ] [ j ] ) ; } System . out . println ( max ) ; } }
import java . io . * ; public class GFG { static int findmin ( int p [ ] [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] [ 0 ] <= 0 ) a ++ ; else if ( p [ i ] [ 0 ] >= 0 ) b ++ ; if ( p [ i ] [ 1 ] >= 0 ) c ++ ; else if ( p [ i ] [ 1 ] <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; } public static void main ( String [ ] args ) { int p [ ] [ ] = { { 1 , 1 } , { 2 , 2 } , { - 1 , - 1 } , { - 2 , 2 } } ; int n = p . length ; System . out . println ( findmin ( p , n ) ) ; } }
import java . util . * ; public class GFG { static int maxGCD ( int N , int P ) { int ans = 1 ; HashMap < Integer , Integer > prime_factors = new HashMap < Integer , Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( P ) ; i ++ ) { while ( P % i == 0 ) { if ( ! prime_factors . containsKey ( i ) ) prime_factors . put ( i , 0 ) ; prime_factors . put ( i , prime_factors . get ( i ) + 1 ) ; P /= i ; } } if ( P != 1 ) prime_factors . put ( P , 1 ) ; for ( Map . Entry < Integer , Integer > entry : prime_factors . entrySet ( ) ) { ans *= ( int ) entry . getValue ( ) / N ; } return ans ; } public static void main ( String [ ] args ) { int N = 3 , P = 24 ; System . out . println ( maxGCD ( N , P ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] b = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } boolean [ ] output = new boolean [ n ] ; for ( int i = 0 ; i < ( 1 << k ) ; i ++ ) { output [ i ] = true ; int index = 0 ; for ( int j = 0 ; j < k ; j ++ ) { if ( output [ index ] ) { output [ index ++ ] = false ; } } if ( index == n ) { output [ index ] = false ; } } for ( int i = 0 ; i < ( 1 << k ) ; i ++ ) { System . out . print ( i + " : " ) ; for ( int j = 0 ; j < k ; j ++ ) { if ( output [ j ] ) System . out . print ( " ▁ " + b [ j ] ) ; } System . out . println ( ) ; } } }
import java . util . * ; public class GFG { static void generateDivisors ( int curIndex , int curDivisor , Vector < Vector < Integer > > arr ) { if ( curIndex == arr . size ( ) ) { System . out . print ( curDivisor + " ▁ " ) ; return ; } for ( int i = 0 ; i <= arr . get ( curIndex ) . size ( ) ; i ++ ) { generateDivisors ( curIndex + 1 , curDivisor , arr ) ; curDivisor *= arr . get ( curIndex ) . get ( 1 ) ; } } static void findDivisors ( int n ) { Vector < Vector < Integer > > arr = new Vector < Vector < Integer > > ( ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } arr . add ( new Vector < Integer > ( count , i ) ) ; } } if ( n > 1 ) { arr . add ( new Vector < Integer > ( new Integer ( 1 , n ) ) ) ; } } public static void main ( String [ ] args ) { int n = 6 ; findDivisors ( n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] l = new int [ 1000010 ] ; int [ ] dp = new int [ 1000010 ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; l [ a ] = b ; } if ( l [ 0 ] > 0 ) { dp [ 0 ] = 1 ; } int mx = 0 ; for ( int i = 1 ; i < 1000010 ; i ++ ) { if ( l [ i ] == 0 ) { dp [ i ] = dp [ i - 1 ] ; } else { if ( l [ i ] >= i ) { dp [ i ] = 1 ; } else { dp [ i ] = dp [ i - l [ i ] - 1 ] + 1 ; } } if ( dp [ i ] > mx ) { mx = dp [ i ] ; } } System . out . println ( n - mx ) ; } }
public class Main { public static String largestPalinSub ( String s ) { String res = " " ; char mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { mx = ( char ) Math . max ( mx , s . charAt ( i ) ) ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == mx ) { res += s . charAt ( i ) ; } } return res ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( largestPalinSub ( s ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { int n = in . nextInt ( ) ; String s = in . next ( ) ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int c = 0 ; int cnt = 0 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { cnt ++ ; } else { while ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { c ++ ; } i ++ ; } if ( c == n ) { out . print ( s . charAt ( i ) ) ; p ++ ; } else { while ( p < s . length ( ) ) { out . print ( "1" ) ; p ++ ; } c = 0 ; } } out . println ( ) ; } return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ j ] = Math . max ( dp [ j ] , dp [ j - 1 ] + 1 ) ; } if ( j * j > a [ i ] ) { dp [ j ] = Math . max ( dp [ j ] , dp [ i ] + 1 ) ; } } } int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { ans = Math . max ( ans , dp [ i ] ) ; } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int initializeDiffArray ( int [ ] A ) { int n = A . length ; int [ ] D = new int [ n + 1 ] ; D [ 0 ] = A [ 0 ] ; D [ n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) D [ i ] = A [ i ] - A [ i - 1 ] ; return D ; } static void update ( int D [ ] , int l , int r , int x ) { D [ l ] += x ; D [ r + 1 ] -= x ; } static void printArray ( int [ ] A , int [ ] D ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( i == 0 ) A [ i ] = D [ i ] ; else A [ i ] = D [ i ] + A [ i - 1 ] ; System . out . print ( A [ i ] + " ▁ " ) ; } System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int [ ] A = { 10 , 5 , 20 , 40 } ; int [ ] D = initializeDiffArray ( A ) ; update ( D , 0 , 1 , 10 ) ; printArray ( A , D ) ; update ( D , 1 , 3 , 20 ) ; update ( D , 2 , 2 , 30 ) ; printArray ( A , D ) ; } }
import java . util . * ; public class GFG { static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 ; int max_guests = 1 ; int time = arrl [ 0 ] ; for ( int i = 1 , j = 0 ; i < n && j < n ; i ++ , j ++ ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } } else { guests_in -- ; j ++ ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; } public static void main ( String [ ] args ) { int arrl [ ] = { 1 , 2 , 10 , 5 , 5 } ; int exit [ ] = { 4 , 5 , 12 , 9 , 12 } ; int n = arrl . length ; findMaxGuests ( arrl , exit , n ) ; } }
import java . util . * ; public class Main { static int [ ] bit ; static int len ; static void dfs ( int i , int j , int sum , int pre ) { if ( i == j ) { if ( bit [ i ] == 0 && bit [ j ] == 1 ) { dfs ( i + 1 , j , 1 ) ; } else if ( bit [ i ] == 1 && bit [ j ] == 0 ) { dfs ( i + 1 , j , 1 ) ; } else if ( bit [ i ] == 0 && bit [ j ] == 1 ) { dfs ( i + 1 , j , 1 ) ; } } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { String str = sc . next ( ) ; if ( str . equals ( " # " ) ) break ; len = str . length ( ) ; bit = new int [ 1 << len ] ; for ( int i = 0 ; i < len ; i ++ ) { bit [ i ] = 1 ; } dfs ( 0 , 0 , 0 ) ; dfs ( 0 , 0 , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( bit [ i ] == 1 ) continue ; dfs ( i , i + 1 , 1 ) ; } System . out . println ( len + 1 + " ▁ " + dfs ( 0 , 0 , 0 ) ) ; } } }
import java . io . * ; public class GFG { static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( int ) ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; } public static void main ( String [ ] args ) { int n = 6 ; int r = 2 ; System . out . print ( "1 / " + calcFunction ( n , r ) ) ; } }
import java . io . * ; public class GFG { static void isPerfectSquare ( int x ) { int sr = ( int ) Math . sqrt ( x ) ; if ( sr * sr == x ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int n = 7 , k = 2 ; isPerfectSquare ( n + k ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % n ) % 2 != 0 ) { count ++ ; } } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] - a [ i - 1 ] == a [ i - 2 ] - a [ i - 1 ] ) { c ++ ; } } if ( c == n ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { int n = parseInt ( line ) ; if ( n == 0 ) break ; int [ ] seq = new int [ n ] ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) seq [ i ] = parseInt ( st . nextToken ( ) ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( seq [ i ] == 0 ) cnt ++ ; else cnt += seq [ i ] - 1 ; } int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( len == 0 ) break ; for ( int j = 0 ; j < seq . length ; j ++ ) { if ( seq [ j ] == i ) { if ( seq [ j ] == i + 1 ) cnt ++ ; else break ; } } } System . out . println ( cnt ) ; } } }
import java . io . * ; public class GFG { static int sum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) sum += ( int ) s . charAt ( i ) - 48 ; return sum ; } static boolean isDivisible ( String s ) { int n = s . length ( ) ; if ( s . charAt ( n - 1 ) != '5' && s . charAt ( n - 1 ) != '0' ) return false ; int sum = sum ( s ) ; return ( sum % 3 == 0 ) ; } public static void main ( String [ ] args ) { String s = "15645746327462384723984023940239" ; if ( isDivisible ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; s = "15645746327462384723984023940235" ; if ( isDivisible ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; s = "15645746327462384723984023940239" ; if ( isDivisible ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int sum = 10 ; while ( true ) { int [ ] issquare = new int [ sum + 1 ] ; for ( int a = 1 ; ; a ++ ) { if ( a * a >= limit ) break ; for ( int b = 1 ; a <= a ; b ++ ) { if ( ( a + b ) % 2 != 0 ) continue ; int x = ( a * a + b * b ) / 2 ; int y = ( a * a - b * b ) / 2 ; if ( x + y + 1 >= limit ) continue ; int zLimit = Math . min ( y , limit - x - y ) ; for ( int c = 0 ; c <= Math . sqrt ( y ) ; c ++ ) { int z = c * c - y ; if ( z >= zLimit ) break ; if ( issquare [ x + z ] && issquare [ x - z ] && issquare [ y - z ] ) return x + y + z ; } } } } return Integer . toString ( sum ) ; } }
public class EncryptString { public static void main ( String [ ] args ) { String s = " hello " ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encryptString ( s , n , k ) ) ; } public static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } public static String encryptString ( String s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; String ans = " " ; for ( int l = 0 ; l < n - k + 1 ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r < l + k ; r ++ ) { if ( isVowel ( s . charAt ( r ) ) == true ) { countVowels += 1 ; } else { countConsonants += 1 ; } } ans += Integer . toString ( countVowels * countConsonants ) ; } return ans ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; sc . nextLine ( ) ; String s = sc . nextLine ( ) ; String t = sc . nextLine ( ) ; int leng = n * m ; String [ ] s1 = s . split ( " " ) ; String [ ] t2 = t . split ( " " ) ; int [ ] l = new int [ leng ] ; for ( int i = 0 ; i < leng ; i ++ ) { l [ i ] = s1 . length ( ) + i ; } for ( int i = 0 ; i < leng ; i ++ ) { l [ i ] = t2 . length ( ) + i ; } int ans = l [ 0 ] == l [ 1 ] ? leng : - 1 ; for ( int i = 0 ; i < leng ; i ++ ) { int l2 = i ; for ( int j = 0 ; j < l2 ; j ++ ) { if ( l [ j ] != l2 ) { System . out . println ( - 1 ) ; return ; } if ( l2 == l2 ) { boolean flag = true ; for ( int j = 0 ; j < l . length ; j ++ ) { if ( j != l [ j ] ) { flag = false ; break ; } } if ( flag ) { break ; } } if ( i == 0 ) { ans = l2 ; break ; } } if ( ans == - 1 ) { System . out . println ( - 1 ) ; } else { int l = lcm ( leng , leng ) ; System . out . println ( l ) ; } } } static int gcd ( int a , int b ) { return ( a % b == 0 ) ? b : gcd ( b % a , a ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] map = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { map [ i ] [ j ] = sc . nextInt ( ) + 5 ; } } int ans = - 1 ; for ( int i = 1 ; i <= m ; i ++ ) { int x = sc . nextInt ( ) + 1 ; int y = sc . nextInt ( ) + 1 ; boolean [ ] [ ] visited = new boolean [ n + 1 ] [ n + 1 ] ; for ( int j = 1 ; j <= n ; j ++ ) { visited [ x ] [ j ] = true ; } for ( int j = 1 ; j <= n ; j ++ ) { for ( int k = 1 ; k <= n ; k ++ ) { boolean [ ] [ ] visited2 = new boolean [ n + 1 ] [ n + 1 ] ; visited2 [ j ] [ k ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { visited2 [ i ] [ j ] = false ; } } if ( visited [ x ] [ y ] ) continue ; boolean found = false ; for ( int k = 1 ; k <= n ; k ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { int nx = x + i ; int ny = y + j ; if ( visited [ nx ] [ ny ] ) continue ; if ( nx < x || ny < y ) continue ; visited [ nx ] [ ny ] = true ; if ( nx == x && ny == y ) continue ; if ( nx == x && ny == y ) continue ; if ( nx == x && ny == y ) continue ; if ( visited2 [ ny ] [ nx ] ) { found = true ; break ; } } } if ( found ) { ans = i ; break ; } } } } System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; class Main { public static void main ( final String [ ] args ) { final Scanner stdin = new Scanner ( System . in ) ; while ( true ) { final int n = stdin . nextInt ( ) ; if ( n == 0 ) { break ; } final int [ ] [ ] grid = new int [ 2 * n ] [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { for ( int j = 0 ; j < 2 * n ; j ++ ) { grid [ i ] [ j ] = stdin . nextInt ( ) ; } } int max = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { for ( int j = 0 ; j < 2 * n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j + k < 2 * n ) { int left = i - grid [ i ] [ k ] ; int right = j + k ; int l = i - grid [ i ] [ k + l ] ; int r = j + l ; max = max ( max , left ) ; } if ( l + r < 2 * n ) { int left = i - grid [ i ] [ k ] ; int right = j + r ; max = max ( max , right ) ; } } } } System . out . println ( max ) ; } } }
import java . io . * ; public class GFG { static double fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fourthPowerSum ( n ) ) ; } }
import java . util . * ; public class GFG { static int maxLenSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int length = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && length < um . get ( arr [ i ] - 1 ) ) length = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] ) && length < um . get ( arr [ i ] ) ) length = um . get ( arr [ i ] ) ; if ( um . containsKey ( arr [ i ] + 1 ) && length < um . get ( arr [ i ] + 1 ) ) length = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , length + 1 ) ; if ( maxLen < um . get ( arr [ i ] ] ) maxLen = um . get ( arr [ i ] ) ; } return maxLen ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = arr . length ; System . out . println ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " + maxLenSub ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ; static void rearrange ( int n ) { if ( n % 2 == 1 ) return ; int currIdx = ( n - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx ; int swapIdx = currIdx ; while ( count > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; count -- ; } currIdx = currIdx - 1 ; } } public static void main ( String [ ] args ) { rearrange ( arr . length ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . * ; public class Main { static int N , K ; static int [ ] [ ] f ; static int [ ] cost ; static boolean [ ] used ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { N = sc . nextInt ( ) ; K = sc . nextInt ( ) ; if ( N == 0 && K == 0 ) break ; f = new int [ N ] [ N ] ; used = new boolean [ N ] ; cost = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Arrays . fill ( cost [ i ] , 1 << 25 ) ; for ( int i = 0 ; i < K ; i ++ ) { int odr = sc . nextInt ( ) ; int odr = sc . nextInt ( ) ; if ( odr == 0 ) { for ( int j = 0 ; j < N ; j ++ ) { f [ j ] [ i ] = Math . min ( cost [ j ] [ i ] , f [ j ] [ odr ] + odr ) ; } } else { for ( int j = 0 ; j < N ; j ++ ) { cost [ j ] [ i ] = Math . min ( cost [ j ] [ i ] , cost [ j ] [ odr ] + odr ) ; } } } int res = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( used [ i ] ) continue ; used [ i ] = true ; res = - 1 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ! used [ j ] && F [ j ] [ i ] != 1 && cost [ j ] [ i ] != 1 ) continue ; used [ j ] = false ; cost [ i ] [ j ] = Math . min ( cost [ j ] [ i ] , cost [ j ] [ i ] + f [ j ] [ i ] ) ; } } System . out . println ( res ) ; } } }
public class GFG { static void countCharacterType ( String str ) { int vowels = 0 ; int consonant = 0 ; int specialChar = 0 ; int digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) { ch = Character . toLowerCase ( ch ) ; if ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } System . out . println ( " Vowels : ▁ " + vowels ) ; System . out . println ( " Consonant : ▁ " + consonant ) ; System . out . println ( " Digit : ▁ " + digit ) ; System . out . println ( " Special ▁ Character : ▁ " + specialChar ) ; } public static void main ( String [ ] args ) { String str = " geeks ▁ for ▁ geeks121 " ; countCharacterType ( str ) ; } }
import java . io . * ; public class GFG { static float increaseInVol ( float l , float b , float h ) { float percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -- ; percentInc *= 100 ; return percentInc ; } public static void main ( String [ ] args ) { float l = 50 , b = 20 , h = 10 ; System . out . print ( increaseInVol ( l , b , h ) + " ▁ % " ) ; } }
import java . util . * ; public class GFG { static int MaxTotalRectangleArea ( int a [ ] , int n ) { Arrays . sort ( a ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i != 0 ) i ++ ; if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) { sum += a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; } public static void main ( String [ ] args ) { int a [ ] = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 } ; int n = a . length ; System . out . println ( MaxTotalRectangleArea ( a , n ) ) ; } }
public class GFG { static class Node { int data ; Node next ; Node ( int data ) { this . data = data ; this . next = null ; } } ; static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; return newNode ; } static Node insertEnd ( Node head , Node new_node ) { if ( head == null ) { new_node . next = new_node ; new_node . prev = new_node ; head = new_node ; return head ; } Node last = head . prev ; new_node . next = head ; head . prev = new_node ; last . next = new_node ; return head ; } static Node reverse ( Node head ) { if ( head == null ) return null ; Node new_head = null ; Node last = head . prev ; Node curr = last ; while ( curr . prev != last ) { prev = curr . prev ; new_head = insertEnd ( new_head , curr ) ; curr = prev ; } new_head = insertEnd ( new_head , curr ) ; return new_head ; } static void display ( Node head ) { if ( head == null ) return ; Node temp = head ; System . out . print ( " Forward ▁ direction : ▁ " ) ; while ( temp . next != head ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } System . out . print ( temp . data ) ; last = head . prev ; temp = last ; System . out . print ( " Backward ▁ direction : ▁ " ) ; while ( temp . prev != last ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . prev ; } System . out . print ( temp . data ) ; } public static void main ( String [ ] args ) { Node head = null ; head = insertEnd ( head , getNode ( 1 ) ) ; head = insertEnd ( head , getNode ( 2 ) ) ; head = insertEnd ( head , getNode ( 3 ) ) ; head = insertEnd ( head , getNode ( 4 ) ) ; head = insertEnd ( head , getNode ( 5 ) ) ; System . out . print ( " Current ▁ list : " ) ; display ( head ) ; } }
import java . io . * ; public class GFG { static void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( n / 100 ) % 10 ; n = n * 1000 + ( n % 10 ) * 100 + ( n % 10 ) * 10 ; n = n / 1000 ; } public static void main ( String [ ] args ) { int n = 12345 ; lastFiveDigits ( n ) ; System . out . println ( ans ) ; } }
public final class p028 { public static void main ( String [ ] args ) { System . out . println ( new p028 ( ) . run ( ) ) ; } private static final int DIGITS = 100 ; private static final int MULTIPLIER = 100 ; public String run ( ) { int sum = 0 ; for ( int i = 0 ; i < DIGITS ; i ++ ) { int x = Library . sqrt ( i * MULTIPLIER ) ; if ( x * x * x != i ) sum += x ; } return Integer . toString ( sum ) ; } }
import java . io . * ; public class GFG { static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( " No ▁ Pythagoras ▁ Triplets " + " ▁ exist ▁ i . e . ▁ " ) ; else if ( n % 2 == 0 ) { int var = n * n / 4 ; System . out . print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( n + " ▁ " + var - 1 + " ▁ " + var + 1 ) ; } else if ( n % 2 != 0 ) { int var = n * n + 1 ; System . out . print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( n + " ▁ " + var / 2 - 1 + " ▁ " + var / 2 ) ; } } public static void main ( String [ ] args ) { int n = 22 ; evaluate ( n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String [ ] inputArr = scanner . nextLine ( ) . split ( " ▁ " ) ; int [ ] abx = new int [ inputArr . length ] ; for ( int i = 0 ; i < inputArr . length ; i ++ ) { abx [ i ] = Integer . parseInt ( inputArr [ i ] ) ; } int a = d ( abx [ 0 ] - 1 , abx [ 2 ] ) ; int b = d ( abx [ 1 ] , abx [ 2 ] ) ; System . out . println ( b - a ) ; } public static int d ( int a , int b ) { if ( a < 0 ) { return - 1 ; } else { return a / b ; } } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findNumber ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 4 } ; int n = arr . length ; System . out . println ( findNumber ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int countKdivPairs ( int A [ ] , int n , int K ) { int [ ] freq = new int [ K ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; if ( rem != 0 ) ans += freq [ K - rem ] ; else ans += freq [ 0 ] ; freq [ rem ] ++ ; } return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 2 , 1 , 7 , 5 , 3 } ; int n = A . length ; int K = 4 ; System . out . println ( countKdivPairs ( A , n , K ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String str = sc . next ( ) ; String [ ] strs = str . split ( " , " ) ; String ans = " " ; for ( int i = 0 ; i < strs . length ; i ++ ) { ans += strs [ i ] ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class B_Beautiful_Paintings { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int ans = 0 ; if ( arr [ 0 ] == arr [ n - 1 ] ) { ans = n - 1 ; } else { int j = n - 2 ; while ( j >= 0 && arr [ j ] == arr [ j - 1 ] ) { j -- ; } ans = n - j - 1 ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] = hash_negative [ - difference ] + 1 ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] = hash_positive [ difference ] + 1 ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 } ; int n = arr . length ; System . out . println ( " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ " + countSubarrays ( arr , n ) ) ; } }
public class GFG { static int SIZE = 26 ; static void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 0 ) { System . out . print ( str . charAt ( i ) ) ; } } } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; printChar ( str , n ) ; } }
import java . util . * ; public class GFG { static void printChar ( String str , int n ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( freq [ str . charAt ( i ) - ' a ' ] ) % 2 == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; printChar ( str , n ) ; } }
import java . io . * ; public class GFG { static int countGreater ( int arr [ ] , int n , int k ) { int l = 0 , r = n - 1 , leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 } ; int n = arr . length ; int k = 7 ; System . out . println ( countGreater ( arr , n , k ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; long [ ] [ ] [ ] dp = new long [ n + 1 ] [ 3 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 3 ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { if ( i == j ) { dp [ i + 1 ] [ j ] [ k ] += dp [ i ] [ j ] [ k ] ; dp [ i + 1 ] [ j ] [ k ] += dp [ i ] [ j ] [ k ] ; } else { dp [ i + 1 ] [ j ] [ k ] += dp [ i ] [ j ] [ k ] ; dp [ i + 1 ] [ j ] [ k ] += dp [ i ] [ j ] [ k ] ; } } } } long ans = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { ans += dp [ n ] [ i ] [ i ] ; } System . out . println ( ans % 1000000 ) ; } }
import java . io . * ; public class GFG { static void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { System . out . println ( " NO " ) ; return ; } double a = ( double ) ( N + Math . sqrt ( val ) ) / 2.0 ; double b = ( double ) ( N - Math . sqrt ( val ) ) / 2.0 ; System . out . println ( " a ▁ = ▁ " + a ) ; System . out . println ( " b ▁ = ▁ " + b ) ; } public static void main ( String [ ] args ) { double N = 69.0 ; findAandB ( N ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; if ( x > max ) { max = x ; } if ( y > min ) { min = y ; } } if ( max > min ) { System . out . println ( max - min ) ; } else { System . out . println ( 0 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; String x = " X " ; boolean yes = true ; while ( n -- > 0 ) { String s = sc . next ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( s . charAt ( i ) == ' X ' ) { yes = false ; break ; } } if ( yes ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { String a = sc . next ( ) ; if ( a . equals ( "0" ) ) break ; String b = sc . next ( ) ; String c = sc . next ( ) ; int [ ] [ ] dp = new int [ a . length ( ) + 1 ] [ 3 ] ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 10 ; k ++ ) { if ( a . charAt ( i ) == ' ? ' && b . charAt ( i ) == ' ? ' && c . charAt ( i ) == ' ? ' ) continue ; int v = ( a . charAt ( i ) - '0' + j ) % 10 ; if ( b . charAt ( i ) - '0' + k < c . charAt ( i ) - '0' ) { dp [ i + 1 ] [ j + ( v == 0 ? 1 : 0 ) ] += dp [ i ] [ j ] [ k ] ; dp [ i + 1 ] [ j + ( v == 0 ? 0 : 1 ) ; } else if ( ( a . charAt ( i ) - '0' + j ) % 10 == 0 && b . charAt ( i ) - '0' + k < c . charAt ( i ) - '0' ) { dp [ i + 1 ] [ j + ( v == 0 ? 1 : 0 ) ] += dp [ i ] [ j ] [ k ] ; } } } } int ans = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { ans += dp [ i ] [ j ] ; } } System . out . println ( ans % 1000000007 ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { long n = sc . nextLong ( ) ; long ans = 0 ; while ( n > 1 ) { if ( n % 6 == 0 ) n /= 6 ; else if ( n % 3 == 0 ) n = 2 * n / 3 ; else break ; ans ++ ; } System . out . println ( ans ) ; } } }
import java . util . * ; public class GFG { static int minIncrementForUnique ( int [ ] A ) { int count = new int [ A . length ] ; HashSet < Integer > taken = new HashSet < > ( ) ; int ans = 0 ; for ( int x = 0 ; x < count ; x ++ ) { if ( count [ x ] >= 2 ) taken . add ( x ) ; else if ( count [ x ] == 0 ) { ans += x - taken . pop ( ) ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 2 , 1 , 2 , 1 , 7 } ; System . out . println ( minIncrementForUnique ( A ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; pw . println ( pow ( 3 , n - 1 ) ) ; pw . close ( ) ; } public static long pow ( long a , long b ) { if ( b == 0 ) return 1 ; long res = pow ( a , b / 2 ) ; if ( b % 2 == 0 ) res = ( res * res ) % 1000003 ; return res ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . util . * ; public class GFG { static int MOD = ( int ) ( 1e9 + 7 ) ; static int modulo_13 ( String s , int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 13 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = s . charAt ( i ) - '0' ; if ( s . charAt ( i ) == ' ? ' ) nxt = j ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( s . charAt ( i ) != ' ? ' ) break ; } } return dp [ n ] [ 5 ] ; } public static void main ( String [ ] args ) { String s = " ? 44 " ; int n = s . length ( ) ; System . out . println ( modulo_13 ( s , n ) ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / __gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return ( b - a + 1 - x - y + z ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 50 , c = 4 , d = 6 ; System . out . println ( countNums ( a , b , c , d ) ) ; } }
import java . util . * ; public class GFG { static void printSubstrings ( int n ) { int s = ( int ) ( Math . log10 ( n ) ) ; int d = ( int ) Math . pow ( 10 , s ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { System . out . println ( n / d ) ; d /= 10 ; } n = n % k ; k = k / 10 ; d = k ; } } public static void main ( String [ ] args ) { int n = 123 ; printSubstrings ( n ) ; } }
import java . util . * ; public class GFG { static char NthCharacter ( int n ) { String s = " " ; int c = 1 ; while ( true ) { if ( c < 10 ) { s += ( char ) ( ' a ' + c ) ; } else { String s1 = " " ; int dup = c ; while ( dup > 0 ) { s1 += ( char ) ( ( dup % 10 ) + ' a ' ) ; dup /= 10 ; } s1 = reverse ( s1 ) ; s += s1 ; } c ++ ; if ( s . length ( ) >= n ) return s . charAt ( n - 1 ) ; } return ( char ) ( s . charAt ( n - 1 ) ) ; } static String reverse ( String input ) { char [ ] temp = input . toCharArray ( ) ; Arrays . sort ( temp ) ; return new String ( temp ) ; } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( NthCharacter ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int y = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { if ( j % 3 == 0 ) ans += 200 ; else if ( j % 2 == 0 ) ans += 195 ; else if ( j % 2 == 1 ) ans += 20 ; else { ans += 20 ; } } if ( j == m - 1 ) ans += 1 ; System . out . println ( ans ) ; } } }
import java . util . * ; public class GFG { static boolean check_prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int countPrimeFrequent ( String s ) { int count = 0 ; HashMap < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { mp . put ( s . charAt ( i ) , 0 ) ; mp . put ( s . charAt ( i ) , mp . get ( s . charAt ( i ) ) + 1 ) ; } for ( Map . Entry < Character , Integer > entry : mp . entrySet ( ) ) { if ( check_prime ( entry . getValue ( ) ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( countPrimeFrequent ( s ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; int i = 0 , j = 0 ; while ( a [ i ] < b [ j ] ) { i ++ ; j ++ ; } System . out . println ( n - i - j ) ; } }
import java . io . * ; public class GFG { static int catalan ( int n ) { if ( n == 0 || n == 1 ) return 1 ; int [ ] catalan = new int [ n + 1 ] ; catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 10 ; i ++ ) System . out . print ( catalan ( i ) + " ▁ " ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int TARGET = Library . Fraction ( 15499 , 94744 ) ; int totient = 1 , denominator = 1 ; for ( int p = 2 ; ; p ++ ) { totient *= p - 1 ; denominator *= p ; while ( Library . isPrime ( p ) ) break ; } if ( Library . Fraction ( totient , denominator ) < TARGET ) { for ( int i = 1 ; i < p ; i ++ ) { int numer = i * totient ; int denom = i * denominator ; if ( Library . Fraction ( numer , denom - 1 ) < TARGET ) return Integer . toString ( denom ) ; } } return Integer . toString ( denom ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; sc . close ( ) ; int [ ] [ ] move = { { 0 , 1 } , { 1 , 0 } , { - 1 , 0 } , { 0 , - 1 } , { 1 , 0 } } ; int [ ] u = { 0 , 1 } , { 0 , - 1 } , { 0 , 1 } , { 1 , - 1 } } ; String [ ] v = " BUG " . split ( " " ) ; for ( int i = 0 ; i < v . length ; i ++ ) { int x = v [ i ] . indexOf ( " U " ) ; int y = v [ i ] . indexOf ( " R " ) ; if ( x == - 1 || x == 0 ) { continue ; } for ( int j = x + 1 ; j < v . length ; j ++ ) { if ( move [ j ] [ x ] != - 1 ) { System . out . println ( " BUG " ) ; return ; } } } for ( int i = 0 ; i < v . length ; i ++ ) { int u = v [ i ] . indexOf ( " U " ) ; int v = v [ i ] . indexOf ( " R " ) ; if ( u != - 1 && u != 0 ) { move [ u ] [ v ] = move [ u ] [ v - 1 ] + 1 ; } } int [ ] [ ] move2 = { { - 1 , 0 } , { 0 , - 1 } , { 1 , 0 } } ; Queue < Integer > q = new ArrayDeque < Integer > ( ) ; q . offer ( 0 ) ; while ( ! q . isEmpty ( ) ) { int x = q . poll ( ) ; int y = q . poll ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int nx = x + move [ i ] [ 0 ] ; int ny = y + move [ i ] [ 1 ] ; if ( ! move2 [ nx ] [ ny ] ) { q . offer ( nx ) ; move2 [ nx ] [ ny ] = 1 ; } } } System . out . println ( " OK " ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n == 2 ) return true ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i * i <= n ; i = i + 2 ) if ( n % i == 0 ) return false ; return true ; } static boolean isPossible ( int n ) { if ( isPrime ( n ) && isPrime ( n - 2 ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isPossible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static double countDyckPaths ( int n ) { double res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " + countDyckPaths ( n ) ) ; } }
import java . util . * ; import java . io . * ; public class codeHundredSixtyTwo { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int o = 0 ; o < t ; o ++ ) { int n = input . nextInt ( ) ; int [ ] arrayOne = new int [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) { arrayOne [ i ] = input . nextInt ( ) ; } int sum = 0 ; if ( n > 30 ) { System . out . println ( " NO " ) ; } else { if ( n == 40 || n == 36 || n == 44 ) { System . out . println ( " YES " ) ; System . out . println ( ( arrayOne [ 0 ] + 1 ) + " ▁ " + ( arrayOne [ 1 ] + 31 ) ) ; } else { System . out . println ( " YES " ) ; System . out . println ( ( arrayOne [ 0 ] + 1 ) + " ▁ " + ( arrayOne [ 1 ] + 31 ) ) ; } } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . PriorityQueue ; import java . util . Queue ; import java . util . Set ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = gcd ( gcd , sc . nextInt ( ) ) ; } System . out . println ( gcd ) ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int ans = 0 ; for ( int i = 1 ; i < 20000 ; i ++ ) { int now = a [ i ] / 14 ; int next = a [ i ] % 14 ; if ( now % 2 == 0 ) { ans += now ; } else { now -- ; if ( now < 0 ) { ans += now ; } } } System . out . println ( ans ) ; } }
public class Main { public static void main ( String [ ] args ) { int a = 6 ; System . out . println ( pentdiagonal ( a ) ) ; } public static double pentdiagonal ( int a ) { if ( a < 0 ) { return - 1 ; } double d = 1.22 * a ; return d ; } }
import java . io . * ; public class GFG { static double hexDiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.73 * a ; return d ; } public static void main ( String [ ] args ) { double a = 9 ; System . out . println ( hexDiagonal ( a ) ) ; } }
import java . util . * ; public class GFG { static void translate ( char str [ ] ) { int l = str . length ; if ( l < 2 ) return ; int i = 0 , j = 0 ; while ( j < l - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j += 2 ; str [ i ] = ' C ' ; i ++ ; continue ; } str [ i ] = str [ j ] ; i ++ ; j ++ ; } if ( j == l - 1 ) { str [ i ] = str [ j ] ; i ++ ; } str [ i ] = ' ▁ ' ; str [ l - 1 ] = ' ▁ ' ; } public static void main ( String [ ] args ) { translate ( " helloABworldABGfG " ) ; System . out . println ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; System . out . println ( str ) ; } }
import java . util . * ; public class GFG { static void translate ( String str ) { for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i - 1 ) == ' A ' && str . charAt ( i ) == ' B ' ) { str . setCharAt ( i - 1 , ' C ' ) ; for ( int j = i ; j < str . length ( ) - 1 ; j ++ ) { str . setCharAt ( j , str . charAt ( j + 1 ) ) ; } str . setCharAt ( str . length ( ) - 1 , ' ▁ ' ) ; } } } public static void main ( String [ ] args ) { String str = " helloABworldABGfG " ; translate ( str ) ; System . out . println ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; System . out . println ( str ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int TARGET = 2000 ; int count = 2 ; for ( int ring = 2 ; ; ring ++ ) { if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 1 ) && Library . isPrime ( ring * 6 + 5 ) ) { count ++ ; if ( count == TARGET ) return Integer . toString ( ring * ( ring - 1 ) * 3 + 2 ) ; } if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 5 ) && Library . isPrime ( ring * 12 - 7 ) ) { count ++ ; if ( count == TARGET ) return Integer . toString ( ring * ( ring + 1 ) * 3 + 1 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; int x = Math . min ( n , m ) ; List < Pair < Integer , Integer > > li = new ArrayList < > ( ) ; for ( int i = 0 ; i <= x ; i ++ ) { int x1 = ( int ) Math . pow ( i , 2 ) ; for ( int j = 0 ; j <= x ; j ++ ) { int y1 = ( int ) Math . pow ( j , 2 ) ; if ( x1 + j == n && i + y1 == m ) { li . add ( new Pair < > ( i , j ) ) ; } } } System . out . println ( li . size ( ) ) ; } }
import java . util . * ; public class GFG { static void Digits ( int n ) { int largest = 0 , smallest = 9 ; while ( n > 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } System . out . println ( largest + " ▁ " + smallest ) ; } public static void main ( String [ ] args ) { int n = 2346 ; Digits ( n ) ; } }
import java . io . * ; public class GFG { static void solve ( int d1 , int d2 , int d3 ) { int maxx = Math . max ( d1 , Math . max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( 2 * maxx > sum || sum % 2 == 1 ) { System . out . println ( " - 1" ) ; return ; } int x1 = 0 , y1 = 0 ; int x2 = d1 , y2 = 0 ; int x3 = ( d1 + d2 - d3 ) / 2 ; int y3 = ( d2 + d3 - d1 ) / 2 ; System . out . println ( " ( " + x1 + " , ▁ " + y1 + " ) , ▁ ( " + x2 + " , ▁ " + y2 + " ) , ▁ ( " + x3 + " , ▁ " + y3 + " ) " ) ; } public static void main ( String [ ] args ) { int d1 = 3 , d2 = 4 , d3 = 5 ; solve ( d1 , d2 , d3 ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static boolean distributingBalls ( int k , int n , String str ) { int a [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) a [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; } public static void main ( String [ ] args ) { int n = 6 , k = 3 ; String str = " aacaab " ; if ( distributingBalls ( k , n , str ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; import java . io . * ; public class codeHundredSixtyTwo { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int o = 0 ; o < t ; o ++ ) { int n = input . nextInt ( ) ; String s = input . next ( ) ; int p = 0 ; int t = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' F ' ) { p ++ ; } else { if ( p > 0 && s . charAt ( i ) == ' T ' ) { t ++ ; } } } if ( p < 0 || t > n / 3 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int j = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( a [ i ] < a [ j ] ) { j ++ ; } } if ( j == 10 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static int R = 4 ; static int C = 4 ; static int first ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 || arr [ mid - 1 ] == 0 ) && arr [ mid ] == 1 ) return mid ; else if ( arr [ mid ] == 0 ) return first ( arr , ( mid + 1 ) , high ) ; else return first ( arr , low , ( mid - 1 ) ) ; } return - 1 ; } static void rowWith0s ( int mat [ ] [ ] ) { int row_index = 0 , max = Integer . MIN_VALUE , min_row_index = 0 , min = Integer . MAX_VALUE ; for ( int i = 0 ; i < R ; i ++ ) { int index = first ( mat [ i ] [ 0 , C - 1 ) ; int cntZeroes = 0 ; if ( index == - 1 ) cntZeroes = C ; else cntZeroes = index ; if ( max < cntZeroes ) { max = cntZeroes ; max_row_index = i ; } if ( min > cntZeroes ) { min = cntZeroes ; min_row_index = i ; } } System . out . println ( " Row ▁ with ▁ min ▁ 0s : ▁ " + min_row_index + 1 ) ; System . out . println ( " Row ▁ with ▁ max ▁ 0s : ▁ " + max_row_index + 1 ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 } , { 0 , 0 , 0 , 0 } } ; rowWith0s ( mat ) ; } }
import java . io . * ; public class GFG { static int bitAtGivenPosSetOrUnset ( int n , int k ) { int new_num = n >> ( k - 1 ) ; return ( new_num & 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; int k = 2 ; if ( bitAtGivenPosSetOrUnset ( n , k ) == 1 ) System . out . println ( " Set " ) ; else System . out . println ( " Unset " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; if ( n % 4 == 0 ) { int cnt = 0 ; for ( int i = 0 ; i < n / 4 ; i ++ ) { if ( s . charAt ( i ) == ' ? ' ) cnt ++ ; else cnt = 0 ; } if ( cnt == n / 4 ) { System . out . println ( " = = = = " ) ; return ; } int cnta = 0 , cntg = 0 , cntt = 0 ; String ans = " " ; for ( int i = 0 ; i < n / 4 ; i ++ ) { if ( s . charAt ( i ) == ' A ' ) cnta ++ ; else if ( s . charAt ( i ) == ' G ' ) cntg ++ ; else if ( s . charAt ( i ) == ' C ' ) cntc ++ ; else if ( s . charAt ( i ) == ' T ' ) cntt ++ ; } for ( int i = 0 ; i < cnta ; i ++ ) { if ( cntg > cntt ) { ans += " A " ; cntg ++ ; } else if ( cntc > cntt ) { ans += " G " ; cntt ++ ; } } System . out . println ( ans ) ; } else { System . out . println ( " = = = " ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] [ ] [ ] t = new int [ n ] [ 3 ] [ 4 ] ; int s = sc . nextInt ( ) - 1 ; int t1 = sc . nextInt ( ) - 1 ; int t2 = sc . nextInt ( ) - 1 ; int s3 = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; int x = s - 1 ; int y = s - 1 ; int z = t1 - s2 ; int [ ] [ ] [ ] f = new int [ n ] [ 3 ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { f [ i ] [ j ] [ 0 ] = 1 ; } for ( int k = 0 ; k < 3 ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { f [ i ] [ j ] [ k ] = ( f [ i ] [ j ] [ k ] + f [ i ] [ k ] [ j ] ) / 4 ; } } } } double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += f [ i ] [ n ] [ i ] ; } System . out . println ( ans ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long l = sc . nextLong ( ) ; long r = sc . nextLong ( ) ; long count = 0 ; for ( long i = 1 ; i < 25 ; i ++ ) { for ( long j = 1 ; j < 25 ; j ++ ) { if ( l <= Math . pow ( 2 , i ) * Math . pow ( 3 , j ) && l <= r ) { count ++ ; } } } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans += Math . min ( k , i ) ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static boolean arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = a . length ; int m = b . length ; if ( arePermutations ( a , b , n , m ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static void findAndPrintUncommonChars ( String str1 , String str2 ) { int [ ] present = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) present [ i ] = 0 ; int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) present [ str1 . charAt ( i ) - ' a ' ] = 1 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - ' a ' ] == 1 || present [ str2 . charAt ( i ) - ' a ' ] == - 1 ) present [ str2 . charAt ( i ) - ' a ' ] = - 1 ; else present [ str2 . charAt ( i ) - ' a ' ] = 2 ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) System . out . print ( ( char ) ( i + ' a ' ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str1 = " characters " , str2 = " alphabets " ; findAndPrintUncommonChars ( str1 , str2 ) ; } }
public class GFG { static boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } public static void main ( String [ ] args ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) System . out . println ( " Inside " ) ; else System . out . println ( " Outside " ) ; } }
import java . io . * ; public class GFG { static int minSum ( int arr [ ] , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = ( sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ) ; return Math . min ( sum , sumAfterOperation ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 5 , 5 , 6 } ; int n = arr . length ; int x = 3 ; System . out . println ( minSum ( arr , n , x ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { int nth = 0 ; if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( nthTerm ( n ) ) ; n = 25 ; System . out . println ( nthTerm ( n ) ) ; n = 25000000 ; System . out . println ( nthTerm ( n ) ) ; n = 250000007 ; System . out . println ( nthTerm ( n ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int n = sc . nextInt ( ) ; Node p = new Node ( 0 , null ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = sc . nextInt ( ) ; if ( d == 0 ) { p . next = p ; } else if ( d == 1 ) { int x = sc . nextInt ( ) ; p . prev = p ; } else if ( d == 2 ) { int x = sc . nextInt ( ) ; p . next = x ; } else if ( d == 3 ) { int y = sc . nextInt ( ) ; p . prev = p ; } else if ( d == 4 ) { int z = sc . nextInt ( ) ; p . next = z ; } else { int x = sc . nextInt ( ) ; if ( x != null ) { p . prev . next = x ; } p . prev = p ; } } } } } class Node { int data ; Node prev ; Node ( int data ) { this . data = data ; prev = null ; } void print ( ) { for ( int i = 0 ; i < data ; i ++ ) { System . out . print ( this . data . charAt ( i ) ) ; } System . out . println ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int k = input . nextInt ( ) ; input . nextLine ( ) ; String s = input . nextLine ( ) ; int common = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String a = s . substring ( n - 1 - i ) ; String b = s . substring ( 0 , i + 1 ) ; if ( a . equals ( b ) ) { common = i + 1 ; continue ; } } int ans = ( n ) + ( k - 1 ) * ( n - common ) ; String finalStr = s ; for ( int i = 0 ; i < k - 1 ; i ++ ) { finalStr += s . substring ( common ) ; } System . out . println ( finalStr ) ; } }
public class BinaryTree { Node root ; BinaryTreeUtil ( ) { root = null ; } static class Node { int data ; Node left , right ; Node ( int data ) { this . data = data ; this . left = this . right = null ; } } ; static void prInorder ( Node node ) { if ( node == null ) return ; prInorder ( node . left ) ; System . out . print ( node . data + " ▁ " ) ; prInorder ( node . right ) ; } static Node constructBinaryTreeUtil ( Node pre , int preM [ ] , int preIndex , int l , int h , int size ) { if ( preIndex >= size || l > h ) return null ; Node root = newNode ( pre [ preIndex ++ ] ) ; if ( l == h ) return root ; int i = 0 ; for ( i = l ; i <= h ; i ++ ) if ( pre [ preIndex ] == preM [ i ] ) break ; if ( i <= h ) { root . left = constructBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) ; root . right = constructBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) ; } return root ; } static void constructBinaryTree ( Node root , BinaryTree pre , BinaryTreeMirror [ ] ) { int preIndex = 0 ; int preMIndex = 0 ; BinaryTree x = constructBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) ; root = constructBinaryTree ( root , preOrder , preOrderMirror , size ) ; } public static void main ( String args [ ] ) { BinaryTree tree = new BinaryTree ( ) ; int preOrder [ ] = { 1 , 2 , 4 , 5 , 3 , 6 , 7 } ; int preOrderMirror [ ] = { 1 , 3 , 7 , 6 , 2 , 5 , 4 } ; int size = 7 ; Node node = new Node ( 0 ) ; tree . constructBinaryTree ( root , tree , preOrder , preOrderMirror , size ) ; } }
public class GFG { static final int no_of_chars = 256 ; static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int [ ] hash_pat = new int [ no_of_chars ] ; int [ ] hash_str = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) ] ++ ; if ( hash_pat [ str . charAt ( j ) ] != 0 && str . charAt ( j ) <= hash_pat [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . charAt ( start ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return str . substring ( start_index , start_index + min_len ) ; } public static void main ( String [ ] args ) { String str = " this ▁ is ▁ a ▁ test ▁ string " ; String pat = " tist " ; System . out . println ( " Smallest ▁ window ▁ is ▁ : �
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; while ( true ) { try { double x1 = scanner . nextDouble ( ) ; double y1 = scanner . nextDouble ( ) ; double x2 = scanner . nextDouble ( ) ; double y2 = scanner . nextDouble ( ) ; double x3 = scanner . nextDouble ( ) ; double y3 = scanner . nextDouble ( ) ; double x = scanner . nextDouble ( ) ; double y = scanner . nextDouble ( ) ; double abc = tri ( x1 , y1 , x2 , y2 , x3 , y3 ) ; double abp = tri ( x1 , y1 , x2 , y2 , x , y ) ; double acp = tri ( x1 , y1 , x3 , y3 , x , y ) ; double bcp = tri ( x2 , y2 , x3 , y3 , x , y ) ; int xInt = ( int ) ( abc * Math . pow ( 10 , 5 ) ) ; int yInt = ( int ) ( ( abp + acp + bcp ) * Math . pow ( 10 , 5 ) ) ; System . out . println ( xInt >= yInt ? " YES " : " NO " ) ; } catch ( Exception e ) { break ; } } scanner . close ( ) ; } public static double tri ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { return Math . abs ( ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) / 2 ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; if ( n > m ) { System . out . println ( " YES " ) ; } else if ( n == m ) { for ( int i = 0 ; i < m ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { System . out . println ( " YES " ) ; return ; } } } System . out . println ( " NO " ) ; } }
import java . util . * ; public class GFG { static int MAX = 100005 ; static Vector < Integer > addPrimes ( int n ) { int [ ] prime = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = 1 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; } static boolean isPrime ( int n ) { if ( n == 3 || n == 5 || n == 7 ) return true ; return false ; } static int find_Sum ( int n ) { int sum = 0 ; Vector < Integer > v = addPrimes ( n ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int flag = 1 ; int a = v . get ( i ) ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( isPrime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } } return sum ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( find_Sum ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 2 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( a ) ; int ans = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { ans += a [ i ] ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int ans = a [ 0 ] <= 90 ? a [ 0 ] : 90 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < 15 ) { ans = a [ i ] + 15 ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int [ ] [ ] [ ] dp = new int [ 18 ] [ ] [ ] [ ] ; static int memo ( int index , int evenSum , int oddSum , int tight ) { if ( index == v . length ) { if ( evenSum > oddSum ) return 1 ; else return 0 ; } if ( dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 ) return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] ; int limit = v . charAt ( index ) == tight ? 9 : v . charAt ( index ) ; int ans = 0 ; for ( int d = 0 ; d <= limit ; d ++ ) { int currTight = 0 ; if ( d == v . charAt ( index ) ) currTight = tight ; if ( d % 2 != 0 ) ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) ; else ans += memo ( index + 1 , evenSum + d , oddSum + d , currTight ) ; } return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans ; } static int countNum ( int n ) { v . clear ( ) ; for ( int i = 0 ; i < 18 ; i ++ ) for ( int j = 0 ; j < 180 ; j ++ ) dp [ i ] [ j ] [ i ] [ j ] = - 1 ; return memo ( 0 , 0 , 0 , 1 ) ; } public static void main ( String [ ] args ) { int L = 2 , R = 10 ; System . out . println ( countNum ( R ) - countNum ( L - 1 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] a = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { a [ i ] [ j ] = sc . nextInt ( ) ; } } int sum = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { sum += a [ i ] [ j ] ; } } if ( sum % 3 == 0 ) { System . out . println ( " Yes " ) ; return ; } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( a [ i ] [ j ] != 0 && a [ i ] [ j ] != 0 ) { System . out . println ( " No " ) ; return ; } } } System . out . println ( " Yes " ) ; } }
import java . util . Scanner ; public class test284 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int n = in . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } int sum = 0 ; int x = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { sum = sum + a [ i - 1 ] ; } else { x = sum - a [ i - 1 ] ; if ( x != - 1 ) { System . out . println ( - 1 ) ; } else { sum = sum + a [ i - 1 ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } System . out . println ( ) ; } in . close ( ) ; } }
public class Main { public static String compute ( ) { return "0" ; } public static void main ( String [ ] args ) { System . out . println ( compute ( ) ) ; } }
import java . io . * ; public class GFG { static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = arr . length ; int result = search ( arr , n , x ) ; if ( result == - 1 ) System . out . println ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else System . out . println ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long c = sc . nextLong ( ) ; long sum1 = 0 ; long sum2 = 0 ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; long [ ] sum = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; sum1 += a [ i ] ; sum2 += b [ i ] ; } long ans = Math . max ( sum1 , sum2 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long t1 = Math . abs ( sum1 - a [ i + 1 ] - a [ i ] ) ; long t2 = Math . abs ( sum2 - b [ i + 1 ] - a [ i ] ) ; long t3 = Math . abs ( sum1 - t2 ) ; long t4 = Math . abs ( sum2 - t3 ) ; long s = Math . max ( 0 , t1 - s2 + t3 ) ; ans = Math . max ( ans , t4 - s ) ; } System . out . println ( ans ) ; } }
public class GFG { static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( n ^ num ) ; } static int unsetBitsInGivenRange ( int n , int l , int r ) { int num = ( 1 << ( 4 * 8 - 1 ) ) - 1 ; num = toggleBitsFromLToR ( num , l , r ) ; return ( n & num ) ; } public static void main ( String [ ] args ) { int n = 42 ; int l = 2 , r = 5 ; System . out . println ( unsetBitsInGivenRange ( n , l , r ) ) ; } }
public class GFG { static int MinStep ( int a [ ] , int n ) { int positive = 0 , negative = 0 , zero = 0 ; int step = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) zero ++ ; else if ( a [ i ] < 0 ) { negative ++ ; step = step + ( - 1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( negative % 2 == 0 ) { step = step + zero ; } else { if ( zero > 0 ) { step = step + zero ; } else { step = step + 2 ; } } return step ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , - 2 , - 1 , - 3 , 4 } ; int n = a . length ; System . out . println ( MinStep ( a , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; String s = sc . next ( ) ; if ( a == b ) { System . out . println ( 0 ) ; } else { if ( s . charAt ( a ) == s . charAt ( b ) ) { System . out . println ( 1 ) ; } else { System . out . println ( 0 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( arr [ n - 1 ] + arr [ n - 2 ] ) ; } } }
public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int x1 = 1 , y1 = 1 , x2 = 4 , y2 = 3 ; noOfSquares ( x1 , y1 , x2 , y2 ) ; } }
public class GFG { static String get_maximum ( char [ ] a , int [ ] s ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . valueOf ( s ) ; } } return String . valueOf ( s ) ; } public static void main ( String [ ] args ) { String s = "1337" ; int [ ] a = { 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 } ; System . out . println ( get_maximum ( s , a ) ) ; } }
import java . util . * ; public class GFG { static int MAX_DIGITS = 20 ; static boolean isOctal ( int n ) { while ( n > 0 ) { if ( ( n % 10 ) >= 8 ) return false ; else n /= 10 ; } return true ; } static boolean isPalindrome ( int n ) { if ( ! isOctal ( n ) ) return false ; int divide = ( isOctal ( n ) == false ) ? 8 : 10 ; Vector < Integer > octal = new Vector < > ( ) ; while ( n != 0 ) { octal . add ( n % divide ) ; n /= divide ; } int j = octal . size ( ) - 1 ; int k = 0 ; while ( k <= j ) { if ( octal . get ( j ) != octal . get ( k ) ) return false ; j -- ; k ++ ; } return true ; } public static void main ( String [ ] args ) { int n = 97 ; if ( isPalindrome ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Codeforces { public static void main ( String args [ ] ) { Scanner kali = new Scanner ( System . in ) ; int money = kali . nextInt ( ) ; String s = kali . next ( ) ; int temp1 = 0 ; int temp2 = 0 ; int temp3 = 0 ; int temp4 = 0 ; int temp5 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' || s . charAt ( i ) == '4' || s . charAt ( i ) == '7' ) { temp1 += Integer . parseInt ( s . substring ( i ) ) ; } else { temp2 += Integer . parseInt ( s . substring ( i ) ) ; } } if ( temp1 == temp2 && temp3 == temp4 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static int binarySearch ( int arr [ ] , int low , int high ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; int midValue = arr [ mid ] ; if ( mid == arr [ mid ] ) return mid ; int leftindex = Math . min ( mid - 1 , midValue ) ; int left = binarySearch ( arr , low , leftindex ) ; if ( left >= 0 ) return left ; int rightindex = Math . max ( mid + 1 , midValue ) ; int right = binarySearch ( arr , rightindex , high ) ; return right ; } public static void main ( String [ ] args ) { int arr [ ] = { - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 } ; int n = arr . length ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + binarySearch ( arr , 0 , n - 1 ) ) ; int arr1 [ ] = { - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 } ; int n1 = arr1 . length ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + binarySearch ( arr1 , 0 , n1 - 1 ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 10000 ; static int prodDig [ ] = new int [ MAX ] ; static int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; prodDig [ x ] = prod ; return prod ; } static void findSeed ( int n ) { Vector < Integer > res = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= n / 2 + 1 ; i ++ ) { if ( i * getDigitProduct ( i ) == n ) res . add ( i ) ; } if ( res . size ( ) == 0 ) { System . out . print ( " NO ▁ seed ▁ exists " ) ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 138 ; findSeed ( n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; int [ ] X = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { X [ i ] = sc . nextInt ( ) ; } int min = Integer . MAX_VALUE ; for ( int i = 0 ; i + K <= N ; i ++ ) { int x = X [ i + K - 1 ] - X [ i ] ; int y = X [ i + K - 1 ] - X [ i ] ; int z = x + y ; if ( z < 0 ) { z = Math . abs ( X [ i ] ) ; } else if ( z > 0 ) { x = Math . abs ( X [ i ] ) ; y = Math . abs ( Y [ i ] ) ; } min = Math . min ( min , Math . max ( x , y ) ) ; } System . out . println ( min ) ; } }
import java . io . * ; public class GFG { static float diff ( float n , float mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; } static float cubicRoot ( float n ) { float start = 0 , end = n ; float e = 0.0000001 ; while ( true ) { float mid = ( start + end ) / 2 ; float error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } return ( float ) n ; } public static void main ( String [ ] args ) { float n = 3 ; System . out . println ( " Cubic ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + cubicRoot ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int x = arr [ 0 ] ; int y = arr [ n - 1 ] ; System . out . println ( x + " ▁ " + y ) ; } }
import java . io . * ; public class GFG { static int inv ( int a , int m ) { int m0 = m ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 = x1 + m0 ; return x1 ; } static int findMinX ( int num [ ] , int rem [ ] , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod = prod * num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result = result + rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; } public static void main ( String [ ] args ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = num . length ; System . out . println ( " x ▁ is ▁ " + findMinX ( num , rem , k ) ) ; } }
import java . util . * ; public class GFG { static int findMaxOR ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int maxOR = arr [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( maxOR | arr [ i ] ) > maxOR ) { maxOR = maxOR | arr [ i ] ; count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 4 , 2 } ; int n = arr . length ; System . out . println ( findMaxOR ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( seriessum ( n ) ) ; } }
public class Main { public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( aliquotSum ( n ) ) ; } public static int aliquotSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( n % i == 0 ) { sm = sm + i ; } } return sm ; } }
import java . io . * ; public class GFG { static int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum += p ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pentagon_pyramidal ( n ) ) ; } }
import java . io . * ; public class GFG { static int fifthPowerSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i * i * i * i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fifthPowerSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( squaresum ( n ) ) ; } }
import java . io . * ; public class GFG { static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( seriessum ( n ) ) ; } }
import java . io . * ; public class GFG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int fourthPowerSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fourthPowerSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int squareSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; } public static void main ( String [ ] args ) { int ans = squareSum ( 8 ) ; System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static double AvgofSquareN ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( AvgofSquareN ( n ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int solve ( int n , int base ) { int sum = 0 ; while ( n > 0 ) { int remainder = n % base ; sum = sum + remainder ; n = n / base ; } return sum ; } static void SumsOfDigits ( int n ) { int sum = 0 ; int N = ( int ) Math . floor ( n / 2 ) ; for ( int base = 2 ; base <= N ; base ++ ) { sum = sum + solve ( n , base ) ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int n = 8 ; SumsOfDigits ( n ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { int n = in . nextInt ( ) ; if ( n == 0 ) return false ; int cnt = 0 ; for ( int i = 2 ; i <= n / 2 ; i ++ ) { if ( solve ( i ) ) cnt ++ ; } out . println ( cnt ) ; return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class GFG { public static void main ( String [ ] args ) { int count = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) if ( ( i & ( 1 << i ) ) != 0 ) count ++ ; System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { int cost [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; if ( i >= n || j >= n ) break ; cost [ i ] [ j ] = Integer . MAX_VALUE ; for ( int r = i ; r <= j ; r ++ ) { int c = 0 ; if ( r > i ) c += cost [ i ] [ r - 1 ] ; if ( r < j ) c += cost [ r + 1 ] [ j ] ; c += sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; } static int sum ( int freq [ ] , int i , int j ) { int sum = 0 ; for ( int k = i ; k <= j ; k ++ ) sum += freq [ k ] ; return sum ; } public static void main ( String [ ] args ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = keys . length ; System . out . println ( " Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ " + optimalSearchTree ( keys , freq , n ) ) ; } }
import java . io . * ; public class GFG { static int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; } public static void main ( String [ ] args ) { int x = 1 , y = 5 , z = 8 ; System . out . println ( get ( x , y , z ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { sum += Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; } } System . out . println ( sum ) ; } }
import java . io . * ; public class GFG { static int binomialCoeff ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static int maxcoefficientvalue ( int n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( maxcoefficientvalue ( n ) ) ; } }
public class GFG { static boolean isVowel ( char ch ) { if ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' ) return true ; else return false ; } static int vowelPairs ( String s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) && isVowel ( s . charAt ( i + 1 ) ) ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { String s = " abaebio " ; int n = s . length ( ) ; System . out . println ( vowelPairs ( s , n ) ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; class Main { public static void main ( final String [ ] args ) { final Scanner stdin = new Scanner ( System . in ) ; while ( true ) { final int n = stdin . nextInt ( ) ; if ( n == 0 ) { break ; } final int W = stdin . nextInt ( ) ; final int H = stdin . nextInt ( ) ; final int [ ] [ ] grid = new int [ W + 2 ] [ H + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { final int x = stdin . nextInt ( ) ; final int y = stdin . nextInt ( ) ; grid [ x ] [ y ] = 1 ; } for ( int i = 1 ; i <= W ; i ++ ) { for ( int j = 1 ; j <= H ; j ++ ) { grid [ i ] [ j ] = grid [ i - 1 ] [ j ] + grid [ i ] [ j - 1 ] + grid [ i ] [ j - 1 ] - grid [ i - 1 ] [ j - 1 ] + 1 ; } } final int S = stdin . nextInt ( ) ; final int T = stdin . nextInt ( ) ; int max = 0 ; for ( int i = S ; i <= W ; i ++ ) { for ( int j = T ; j <= H ; j ++ ) { int tmp = 0 ; for ( int k = 0 ; k < 2 ; k ++ ) { tmp += grid [ i ] [ j ] ; if ( k < S ) { tmp += grid [ i ] [ j ] ; } } max = max ( max , tmp ) ; } } System . out . println ( max ) ; } } }
public class GFG { static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M + 1 ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; } if ( j + 1 == M ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { String s1 = " for " ; String s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) System . out . println ( " Not ▁ Present " ) ; else System . out . println ( " Present ▁ at ▁ index ▁ " + res ) ; } }
import java . io . * ; public class GFG { static float angleOncirCumference ( float z ) { return ( z / 2 ) ; } public static void main ( String [ ] args ) { float angle = 65 ; float z = angleOncirCumference ( angle ) ; System . out . println ( " The ▁ angle ▁ is ▁ " + z + " ▁ degrees " ) ; } }
import java . io . * ; public class GFG { static void countSubarraysof1and0 ( int a [ ] , int n ) { int count1 = 0 , count0 = 0 , number1 = 0 , number0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count1 ++ ; else number1 += ( ( count1 ) * ( count1 + 1 ) / 2 ) ; count1 = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count0 ++ ; else number0 += ( count0 ) * ( count0 + 1 ) / 2 ; count0 = 0 ; } if ( count1 > 0 ) number1 += ( count1 ) * ( count1 + 1 ) / 2 ; if ( count0 > 0 ) number0 += ( count0 ) * ( count0 + 1 ) / 2 ; System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : ▁ " + number0 ) ; System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : ▁ " + number1 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 } ; int n = a . length ; countSubarraysof1and0 ( a , n ) ; } }
public class GFG { static void printNumbers ( int N ) { int flag = 1 ; int x = N ; if ( N > 0 ) { while ( x > 0 && flag == 1 ) { int digit = x % 10 ; if ( digit != 1 && digit != 3 ) flag = 0 ; x = x / 10 ; } if ( flag == 1 ) System . out . print ( N + " ▁ " ) ; printNumbers ( N - 1 ) ; } } public static void main ( String [ ] args ) { int N = 20 ; printNumbers ( N ) ; } }
import java . io . * ; public class GFG { static void printPermutation ( int n , int k ) { int mx = n ; for ( int i = 1 ; i <= k ; i ++ ) { System . out . print ( mx + " ▁ " ) ; mx -- ; } for ( int i = 1 ; i <= mx ; i ++ ) { System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 5 , K = 3 ; if ( K >= N - 1 ) System . out . println ( " Not ▁ Possible " ) ; else printPermutation ( N , K ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; sum += a [ i ] ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sum > a [ i ] ) { ans = i + 1 ; break ; } } System . out . println ( ans ) ; } }
public class GFG { static boolean is_member ( String List , String key ) { for ( int i = 0 ; i < List . length ( ) ; i ++ ) if ( key . equals ( List . get ( i ) ) ) return true ; return false ; } static boolean overlap ( String List1 , String List2 ) { for ( String key : List1 . split ( " " ) ) { if ( is_member ( List2 , key ) ) return true ; } return false ; } public static void main ( String [ ] args ) { String s1 = " geeksforgeeks " ; String s2 = " geeks " ; boolean yes_or_no = overlap ( List1 , List2 ) ; if ( yes_or_no ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; if ( n * a > c + b || n * a < c + d ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } }
import java . io . * ; public class GFG { static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }
import java . io . * ; public class GFG { static int N = 3 ; static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; } public static void main ( String [ ] args ) { int tri [ ] [ ] = { { 1 , 0 , 0 } , { 4 , 8 , 0 } , { 1 , 5 , 3 } } ; System . out . println ( maxPathSum ( tri , 2 , 2 ) ) ; } }
import java . io . * ; public class GFG { static boolean isHeap ( int [ ] arr , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; } public static void main ( String [ ] args ) { int [ ] arr = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . length ; if ( isHeap ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . length - 1 ; if ( isHeap ( arr , 0 , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; if ( Math . pow ( a - b , 2 ) * Math . pow ( c - a , 2 ) == Math . pow ( d , 2 ) && Math . pow ( c - b , 2 ) * Math . pow ( d , 2 ) == Math . pow ( a , 2 ) && Math . pow ( c - b , 2 ) * Math . pow ( c - a , 2 ) == Math . pow ( c - b , 2 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class GFG { static int findMinDel ( int arr [ ] , int n ) { int min_num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 2 } ; int n = arr . length ; System . out . println ( findMinDel ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int count ( int x , int y ) { int ans = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; while ( x % y != 0 ) { x %= y ; ans ++ ; if ( m . containsKey ( x ) ) return - 1 ; m . put ( x , 1 ) ; x *= 10 ; } return ans ; } public static void main ( String [ ] args ) { int res ; res = count ( 1 , 2 ) ; if ( res == - 1 ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; res = count ( 5 , 3 ) ; if ( res == - 1 ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; res = count ( 3 , 5 ) ; if ( res == - 1 ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; } }
import java . io . * ; public class GFG { static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 40 , 50 , 90 } ; int n = 3 ; if ( isPossibleToMakeDivisible ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { b [ a [ i ] ] ++ ; } int ans = 0 ; PriorityQueue < Path > queue = new PriorityQueue < > ( ) ; queue . add ( new Path ( 0 , 0 ) ) ; while ( queue . size ( ) > 0 ) { Path p = queue . poll ( ) ; if ( k <= b [ p . idx ] ) { continue ; } if ( queue . size ( ) == 0 ) { continue ; } if ( queue . size ( ) == 0 ) { continue ; } queue . add ( new Path ( b [ p . idx ] , p . value + 1 ) ) ; for ( int i = 0 ; i < k - 1 ; i ++ ) { queue . add ( new Path ( b [ p . idx ] , p . value + 1 ) ) ; } } ans ++ ; for ( int i = 0 ; i < n ; i ++ ) { queue . add ( new Path ( b [ i ] , 0 ) ) ; } System . out . println ( ans ) ; } static class Path implements Comparable < Path > { int idx ; int value ; public Path ( int idx , int value ) { this . idx = idx ; this . value = value ; } public int compareTo ( Path another ) { return value - another . value ; } } }
import java . io . * ; public class GFG { static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int j = 1 ; for ( j = j * j ; j <= i ; j ++ ) if ( j * j * j == i ) System . out . print ( j * j + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a = 1 , b = 100 ; System . out . println ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : ▁ " ) ; printCubes ( a , b ) ; } }
import java . io . * ; public class GFG { static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 6 , d = 4 ; System . out . println ( n + " moduo ▁ " + d + " ▁ is ▁ " + getModulo ( n , d ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) <= d ) { count ++ ; } } } System . out . println ( count ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int n = s . length ( ) ; int ans = 0 ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { x ++ ; } else if ( s . charAt ( i ) == '6' ) { y ++ ; } else if ( s . charAt ( i ) == '3' ) { x ++ ; } else if ( s . charAt ( i ) == '2' ) { x ++ ; } else if ( s . charAt ( i ) == '7' ) { x ++ ; } else if ( s . charAt ( i ) == '0' ) { ans += 16 ; } } ans += x ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) { ans += 4 ; } else if ( s . charAt ( i ) == '6' ) { ans += 5 ; } else if ( s . charAt ( i ) == '3' ) { ans += 6 ; } else if ( s . charAt ( i ) == '2' ) { ans += 7 ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static boolean isPerfectCube ( int x ) { int cr = ( int ) Math . cbrt ( x ) ; return ( cr * cr * cr == x ) ; } static void canBePerfectCube ( int N , int K ) { if ( isPerfectCube ( N + K ) || isPerfectCube ( N - K ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int N = 7 , K = 1 ; canBePerfectCube ( N , K ) ; N = 5 ; K = 4 ; canBePerfectCube ( N , K ) ; N = 7 ; K = 2 ; canBePerfectCube ( N , K ) ; N = 7 ; K = 2 ; canBePerfectCube ( N , K ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = n + 1 ; String left = s . substring ( 0 , i ) ; String right = t . substring ( len - i , len ) ; if ( left . equals ( right ) ) ans = len ; } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static class Graph { ArrayList < Integer > [ ] graph ; boolean [ ] visited ; Graph ( ) { graph = new ArrayList [ graph . size ( ) ] ; for ( int i : graph . get ( 0 ) ) { graph [ i ] = new ArrayList < Integer > ( ) ; } } void addEdge ( int u , int v ) { graph [ u ] . add ( v ) ; } void DFSUtil ( int v , boolean [ ] visited ) { visited [ v ] = true ; System . out . print ( v + " ▁ " ) ; for ( int i = 0 ; i < graph [ v ] . size ( ) ; i ++ ) if ( ! visited [ graph [ v ] . get ( i ) ] ) DFSUtil ( graph [ v ] . get ( i ) , visited ) ; } void DFS ( int v ) { visited [ v ] = true ; dfsUtil ( v ) ; } public static void main ( String [ ] args ) { g = new Graph ( ) ; g . addEdge ( 0 , 1 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 1 , 2 ) ; g . addEdge ( 2 , 0 ) ; g . addEdge ( 2 , 3 ) ; g . addEdge ( 3 , 3 ) ; System . out . println ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 " ) ; g . DFS ( 2 ) ; } }
import java . util . * ; public class GFG { static void countDigits ( int val , int arr [ ] ) { while ( val > 0 ) { int digit = val % 10 ; arr [ ( int ) digit ] ++ ; val = val / 10 ; } } static void countFrequency ( int x , int n ) { int freq_count [ ] = new int [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { int val = ( int ) Math . pow ( x , i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( freq_count [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int i = n - 1 ; while ( i >= 0 ) { if ( arr [ i ] < arr [ i + 1 ] ) { i -- ; } else if ( arr [ i ] > arr [ i + 1 ] && arr [ i ] < arr [ i + 1 ] ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; if ( n == 1 ) System . out . println ( "0" ) ; else { System . out . println ( n - 2 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] h = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { h [ i ] = sc . nextInt ( ) ; } int m = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int ag = sc . nextInt ( ) ; while ( h [ 0 ] != y || h [ 1 ] != e ) { h [ 2 ] = e ; h [ 3 ] = m ; m -- ; } while ( y [ 0 ] != y [ 1 ] ) { y [ 1 ] = y [ 0 ] ; m ++ ; } while ( y [ 1 ] != e ) { y [ 1 ] = y [ 1 ] ; m -- ; } if ( m == 1 ) { System . out . println ( " agrudy ! " ) ; } else { System . out . println ( " IO ▁ hb , e ▁ cmoym , e ▁ ek , e ▁ etyhbeo , agrudy ! " ) ; } } }
public class GFG { static int m = 6 , n = 4 ; static int linearCheck ( int ar [ ] [ ] , int arr [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { boolean matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 0 , 1 , 0 } , { 10 , 9 , 22 , 23 } , { 40 , 40 , 40 , 40 } , { 43 , 44 , 55 , 68 } , { 81 , 73 , 100 , 132 } , { 100 , 75 , 125 , 133 } } ; int row [ ] = { 10 , 9 , 22 , 23 } ; System . out . println ( linearCheck ( mat , row ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int p = sc . nextInt ( ) ; int [ ] arr = new int [ p ] ; int sum = 0 ; for ( int j = 0 ; j < p ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; sum += arr [ j ] ; } int ans = 0 ; for ( int j = 0 ; j < p ; j ++ ) { if ( sum % p == 0 ) { int val = sum / p ; if ( val > arr [ j ] ) { ans ++ ; } } } if ( ans > 0 ) { System . out . println ( ans ) ; } else { System . out . println ( - 1 ) ; } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] t = new int [ n ] ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { t [ i ] = sc . nextInt ( ) * 2 ; } for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = sc . nextInt ( ) ; } double [ ] min = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { min [ i + 1 ] = 2 * v [ i ] + ( 2 * t [ i ] - t [ i ] ) ; } double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += 2 * min [ i ] ; } ans /= 4 ; System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return 7 * ( int ) Math . pow ( n , 2 ) - 7 * n + 7 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 3 ) + ( int ) Math . pow ( n , 2 ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) - n - 1 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) - 2 * n + 2 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + n - 2 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int a = 0 , b = 0 ; if ( x > 0 && y > 0 ) { a = Math . abs ( x ) ; b = Math . abs ( y ) ; } else if ( x < 0 && y != 0 ) { a = Math . abs ( x ) ; b = Math . abs ( y ) ; } else if ( x == 0 && y != 0 ) { a = Math . abs ( x ) + Math . abs ( y ) ; } else if ( x == 0 && y != 0 ) { a = Math . abs ( y ) - Math . abs ( x ) + Math . abs ( y ) ; } else if ( x == 0 && y != 0 ) { a = Math . abs ( x ) + Math . abs ( y ) ; b = Math . abs ( x ) + Math . abs ( y ) ; } System . out . println ( a + " ▁ " + b + " ▁ " + a ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int k = sc . nextInt ( ) ; String out = " " ; Set < String > set = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i ; j < s . length ( ) ; j ++ ) { set . add ( s . substring ( i , j + 1 ) ) ; } if ( set . size ( ) == k ) { out = s ; break ; } } System . out . println ( out ) ; } }
import java . util . * ; public class Solution { public int fib ( int N ) { List < Integer > memo = new ArrayList < > ( ) ; memo . add ( 0 ) ; memo . add ( 1 ) ; return memo . get ( N ) ; } public int fib ( int N ) { if ( N < memo . size ( ) ) return memo . get ( N ) ; for ( int i = memo . size ( ) ; i <= N ; i ++ ) memo . add ( memo . get ( i - 1 ) + memo . get ( i - 2 ) ) ; return memo . get ( N ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int n = 2 ; int out = sObj . fib ( n ) ; System . out . println ( out ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String a = sc . next ( ) ; String b = sc . next ( ) ; char [ ] ch = a . toCharArray ( ) ; Arrays . sort ( ch ) ; int i = 0 , j = 0 ; while ( i < a . length ( ) && j < b . length ( ) ) { if ( ch [ i ] == ' c ' ) { i ++ ; j ++ ; } else if ( ch [ i ] == ' b ' ) { i ++ ; j ++ ; } else if ( ch [ i ] == ' a ' ) { i ++ ; } else { j ++ ; } } if ( i == b . length ( ) ) { System . out . println ( " " ) ; continue ; } int flag = 0 ; while ( i < a . length ( ) ) { if ( a . charAt ( i ) == ' c ' ) { if ( flag == 0 ) { System . out . print ( ch [ i ] ) ; flag = 1 ; i ++ ; continue ; } else { System . out . print ( ch [ j ] ) ; flag = 0 ; i -- ; } } else { if ( flag == 0 ) { System . out . print ( ch [ i ] ) ; flag = 1 ; i ++ ; continue ; } } } } } }
import java . io . * ; public class GFG { static float PI = 3.142 ; static float cosXSertiesSum ( float x , float n ) { x = x * ( PI / 180.0 ) ; float res = 1 ; int sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < n ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res += sign * pow / fact ; } return res ; } public static void main ( String [ ] args ) { float x = 50 ; float n = 5 ; System . out . print ( cosXSertiesSum ( x , n ) ) ; } }
import java . io . * ; public class GFG { static int findNumber ( int N , int S ) { int i = ( ( ( N ) * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) ; return i ; } static void check ( int N , int S ) { int i = findNumber ( N , S ) ; int integerI = Integer . parseInt ( i ) ; if ( i - integerI == 0 ) { System . out . println ( " Yes : " + Integer . toString ( integerI ) + " , ▁ " + Integer . toString ( integerI + 1 ) ) ; } else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int N = 4 ; int S = 3 ; check ( N , S ) ; N = 5 ; S = 3 ; check ( N , S ) ; } }
import java . io . * ; public class GFG { static boolean multipleOfThree ( int K , int dig0 , int dig1 ) { int sum = 0 ; int temp = ( dig0 + dig1 ) % 10 ; sum = dig0 + dig1 ; if ( K == 2 ) { if ( sum % 3 == 0 ) return true ; else return false ; } sum += temp ; int numberofGroups = ( K - 3 ) / 4 ; int remNumberofDigits = ( K - 3 ) % 4 ; sum += ( numberofGroups * 20 ) ; for ( int i = 0 ; i < remNumberofDigits ; i ++ ) { temp = ( 2 * temp ) % 10 ; sum += temp ; } if ( sum % 3 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int K = 5 , dig0 = 3 , dig1 = 4 ; if ( multipleOfThree ( K , dig0 , dig1 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int suma = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; suma += a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; if ( a [ n - 1 ] + b [ n - 2 ] < suma ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static int countOcc ( String s ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j < i + 4 ; j ++ ) { if ( s . charAt ( j ) == ' c ' ) c ++ ; else if ( s . charAt ( j ) == ' l ' ) l ++ ; else if ( s . charAt ( j ) == ' a ' ) a ++ ; else if ( s . charAt ( j ) == ' p ' ) p ++ ; } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { String s = " clapc " ; System . out . println ( countOcc ( s . toLowerCase ( ) ) ) ; } }
import java . io . * ; public class GFG { static int countSteps ( int x , int y ) { if ( x % y == 0 ) return ( int ) Math . floor ( x / y ) ; return ( int ) Math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; } public static void main ( String [ ] args ) { int x = 100 , y = 19 ; System . out . println ( countSteps ( x , y ) ) ; } }
import java . io . * ; public class GFG { static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 3 ; if ( isSunnyNum ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static double PI = 3.14159265 ; static double area_inscribed ( double P , double B , double H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double P = 3 , B = 4 , H = 5 ; System . out . println ( area_inscribed ( P , B , H ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; TreeMap < String , Integer > map = new TreeMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; int p = sc . nextInt ( ) ; map . put ( s , p ) ; } int m = sc . nextInt ( ) ; for ( int j = 0 ; j < m ; j ++ ) { String t = sc . next ( ) ; if ( map . containsKey ( t ) ) { println ( map . get ( t ) ) ; } else { println ( t ) ; } } } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class GFG { static int getCount ( Vector < Integer > v , int n ) { Collections . sort ( v ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = n - 1 - upper_bound ( v , v . get ( i ) ) ; if ( tmp == v . get ( i ) ) cnt ++ ; } return cnt ; } static int upper_bound ( Vector < Integer > v , int a ) { int low = 0 ; int high = v . size ( ) ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( v . get ( mid ) > a ) high = mid ; else low = mid + 1 ; } return low ; } public static void main ( String [ ] args ) { int n = 4 ; Vector < Integer > v = new Vector < Integer > ( ) ; v . add ( 1 ) ; v . add ( 2 ) ; v . add ( 3 ) ; v . add ( 4 ) ; System . out . println ( getCount ( v , n ) ) ; } }
import java . io . * ; public class GFG { static int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = Math . min ( count_of_two , count_of_five ) ; return ans ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( trailing_zeros ( N ) ) ; } }
import java . io . * ; public class GFG { static int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; } static boolean isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 105 , b = 106 ; if ( isEqual ( a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int M = 1000000007 ; int [ ] t = new int [ N ] ; int [ ] u = new int [ N ] ; int [ ] v = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { t [ i ] = sc . nextInt ( ) - 1 ; u [ i ] = sc . nextInt ( ) - 1 ; v [ i ] = sc . nextInt ( ) - 1 ; } long [ ] p = new long [ N + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( u [ i ] == 1 ) { p [ i ] = 2 ; } else if ( u [ i ] == 2 ) { p [ i ] = 3 ; } else if ( u [ i ] == 3 ) { p [ i ] = 4 ; } u [ i ] = 1 ; } long cnt = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( u [ i ] == 0 ) cnt ++ ; } if ( cnt == 0 ) System . out . println ( 0 ) ; else if ( u [ 0 ] == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( u [ j ] == 1 ) continue ; cnt += p [ j ] * ( long ) ( u [ j ] + 1 ) ; } } } else if ( u [ 0 ] == 2 ) { for ( int j = 1 ; j < N ; j ++ ) { if ( u [ j ] == 1 ) cnt ++ ; } } else if ( u [ 0 ] == 3 ) { for ( int i = 1 ; i < N ; i ++ ) { if ( u [ i ] == 1 ) { cnt += p [ i ] * p [ j ] ; } cnt %= M ; } System . out . println ( cnt ) ; } else { System . out . println ( - cnt ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] + arr [ n - 2 ] ; System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int min = Math . min ( a , b ) ; if ( min == a || min == b ) System . out . println ( "0 ▁ 0" ) ; else System . out . println ( min + " ▁ " + ( Math . abs ( a - b ) / 2 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] arr = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { arr [ i ] = n / m ; arr [ n % m ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
public class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static int totalPairs ( String s1 , String s2 ) { int count = 0 ; int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = countSetBits ( s1 . charAt ( i ) ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = countSetBits ( s2 . charAt ( i ) ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i < 7 ; i ++ ) { count += ( arr1 [ i ] * arr2 [ i ] ) ; } return count ; } public static void main ( String [ ] args ) { String s1 = " geeks " ; String s2 = " forgeeks " ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }
import java . io . * ; public class GFG { static int countSubSeq ( int i , int sum , int cnt , int a [ ] , int n ) { if ( i == n ) { if ( sum == 0 && cnt > 0 ) return 1 ; else return 0 ; } int ans = 0 ; ans += countSubSeq ( i + 1 , sum , cnt , a , n ) ; ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) ; return ans ; } public static void main ( String [ ] args ) { int a [ ] = { - 1 , 2 , - 2 , 1 } ; int n = a . length ; System . out . println ( countSubSeq ( 0 , 0 , 0 , a , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . charAt ( i ) - '0' ; } int x = n / 2 ; int y = x - ( ( n - x ) / 2 ) ; int z = x + y ; while ( z <= n ) { a [ z ] = a [ z - x ] ; a [ z - x ] = a [ z ] ; z -- ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] ) ; } System . out . println ( ) ; sc . close ( ) ; } }
import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int a = scanner . nextInt ( ) ; int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; int count = 0 ; List < Integer > checkList = new ArrayList < > ( ) ; int i = 0 ; if ( a == 0 ) { i = 1 ; } while ( Math . pow ( i + a , n ) < m ) { checkList . add ( ( int ) Math . pow ( i + a , n ) ) ; i ++ ; } for ( int x : checkList ) { List < Integer > xl = new ArrayList < > ( ) ; for ( char c : Integer . toString ( x ) . toCharArray ( ) ) { xl . add ( Character . getNumericValue ( c ) ) ; } int y = 0 ; for ( int digit : xl ) { y += digit ; } if ( x == Math . pow ( y + a , n ) ) { count ++ ; } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static int pivotedBinarySearch ( int arr [ ] , int n , int key ) { int pivot = findPivot ( arr , 0 , n - 1 ) ; if ( pivot == - 1 ) return binarySearch ( arr , 0 , n - 1 , key ) ; if ( arr [ pivot ] == key ) return pivot ; if ( arr [ 0 ] <= key ) return binarySearch ( arr , 0 , pivot - 1 , key ) ; return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; } static int findPivot ( int arr [ ] , int low , int high ) { if ( high < low ) return - 1 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ( mid - 1 ) ; if ( arr [ low ] >= arr [ mid ] ) return findPivot ( arr , low , mid - 1 ) ; return findPivot ( arr , mid + 1 , high ) ; } static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 } ; int n = arr1 . length ; int key = 3 ; System . out . println ( " Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ " + pivotedBinarySearch ( arr1 , n , key ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int mod = 1000000007 ; long [ ] [ ] dp = new long [ n + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) % mod ; dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) % mod ; dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) % mod ; } } System . out . println ( dp [ n ] [ 0 ] - dp [ n ] [ 0 ] ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; List < String > answer = new ArrayList < String > ( ) ; int n = Integer . parseInt ( stdin . nextLine ( ) ) ; int [ ] a = new int [ n ] ; String [ ] aStr = stdin . nextLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( aStr [ i ] ) ; } int [ ] b = a . clone ( ) ; Arrays . sort ( b ) ; Map < Integer , Integer > d = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { d . put ( a [ i ] , i ) ; } int [ ] visited = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == 1 ) { continue ; } List < Integer > seq = new ArrayList < Integer > ( ) ; seq . add ( i ) ; visited [ i ] = 1 ; int hold = a [ i ] ; while ( hold != b [ seq . get ( seq . size ( ) - 1 ) ] ) { int z = d . get ( b [ seq . get ( seq . size ( ) - 1 ) ] ) ; visited [ z ] = 1 ; seq . add ( z ) ; } StringBuilder str = new StringBuilder ( ) ; str . append ( seq . size ( ) ) ; for ( int j = 0 ; j < seq . size ( ) ; j ++ ) { str . append ( " ▁ " + ( seq . get ( j ) + 1 ) ) ; } answer . add ( str . toString ( ) ) ; } System . out . println ( answer . size ( ) ) ; for ( String str : answer ) { System . out . println ( str ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] move = { { 0 , 1 } , { 1 , 0 } , { - 1 , 0 } , { 0 , 1 } , { 1 , - 1 } } ; while ( n -- > 0 ) { int m = sc . nextInt ( ) ; int [ ] [ ] map = new int [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { map [ i ] [ 0 ] = 2 ; map [ i ] [ 1 ] = 2 ; } int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int x_diff = 0 , y_diff = 0 ; boolean judge = true ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( map [ i ] [ j ] == 2 ) { x_diff = j ; if ( x < 0 ) x = - x ; if ( y < 0 ) y = 0 ; if ( map [ i ] [ j ] == 1 ) { judge = false ; break ; } } x = x_diff + move [ i ] [ 0 ] ; y = y_diff + move [ i ] [ 1 ] ; if ( x < 0 ) x = 0 ; if ( x_diff == 0 ) x = 1 ; if ( y_diff == 0 ) y = 0 ; if ( j < 4 ) j = 0 ; if ( map [ i ] [ j ] == 1 ) j = 0 ; if ( j < 4 ) j = 0 ; if ( x < 0 ) x = x_diff + move [ i ] [ 0 ] ; if ( y < 0 ) y = 0 ; if ( x_diff == 0 ) y = 0 ; if ( y < 4 ) y = 0 ; if ( j < 4 ) System . out . print ( " # " ) ; System . out . println ( ) ; } for ( int i = 0 ; i < 4 ; i ++ ) System . out . println ( " # " ) ; } } } }
public final class p048 { public static void main ( String [ ] args ) { System . out . println ( new p048 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = i ; j < 1 << 10 ; j ++ ) { if ( Library . popCount ( i ) == Library . popCount ( j ) && isArrangementValid ( i , j ) ) sum += 1 ; } } return Integer . toString ( sum ) ; } private static boolean isArrangementValid ( int a , int b ) { if ( testBit ( a , 6 ) || testBit ( a , 9 ) ) return true ; if ( testBit ( b , 6 ) || testBit ( b , 9 ) ) return true ; return false ; } private static boolean testBit ( int a , int b ) { int c = Integer . bitCount ( a ) ; int d = Integer . bitCount ( b ) ; return ( testBit ( a , c ) && testBit ( b , d ) || testBit ( a , d ) && testBit ( b , c ) ) ; } private static int testBit ( int x , int i ) { return ( ( x >> i ) & 1 ) != 0 ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; for ( int j = 0 ; j < k ; j ++ ) { a [ i ] [ sc . nextInt ( ) - 1 ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( a [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; char [ ] [ ] arr = new char [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . next ( ) . toCharArray ( ) ; } int count = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( arr [ i ] [ j ] == ' a ' && arr [ i + 1 ] [ j ] == ' a ' && arr [ i + 1 ] [ j + 1 ] == ' a ' && arr [ i + 1 ] [ j + 1 ] == ' a ' && arr [ i + 1 ] [ j + 1 ] == ' c ' && arr [ i + 1 ] [ j + 1 ] == ' c ' ) { count ++ ; } } } System . out . println ( count ) ; } }
import java . util . Scanner ; import java . util . Stack ; public class SG { public static void main ( String [ ] args ) { new SG ( ) . runApp ( ) ; } void runApp ( ) { Scanner in = new Scanner ( System . in ) ; String a = in . next ( ) ; Stack < String > s = new Stack < String > ( ) ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { if ( ! s . isEmpty ( ) && s . peek ( ) . equals ( a . substring ( i , i + 1 ) ) ) { s . pop ( ) ; } else { if ( s . isEmpty ( ) ) { System . out . println ( " No " ) ; return ; } s . push ( a ) ; } } System . out . println ( " Yes " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; ArrayList < ArrayList < Integer > > graph = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { graph . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { graph . get ( sc . nextInt ( ) - 1 ) . add ( sc . nextInt ( ) - 1 ) ; } long ans = 0 ; for ( int e : graph . get ( 0 ) ) { ArrayList < Integer > list = graph . get ( 0 ) ; for ( int i : list ) { if ( e == graph . get ( i ) ) { ans += dfs ( i , graph ) ; } } } System . out . println ( ans ) ; } static long dfs ( int v , ArrayList < ArrayList < Integer > > graph ) { if ( graph . get ( v ) == null ) { return 0 ; } if ( graph . get ( v ) . size ( ) == 0 ) { return 1 ; } int [ ] visited = new int [ graph . get ( v ) . size ( ) ] ; visited [ v ] = 1 ; for ( int i = 0 ; i < graph . get ( v ) . size ( ) ; i ++ ) { int v = graph . get ( v ) . get ( i ) ; visited [ v ] = 1 ; } return dfs ( graph , visited ) ; } }
import java . io . * ; public class GFG { static int MAX = 100 ; static int countMountains ( int a [ ] [ ] , int n ) { int A [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; int count = 0 ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { for ( int j = 0 ; j <= n + 1 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) A [ i ] [ j ] = Integer . MAX_VALUE ; else A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } for ( int i = 0 ; i <= n + 1 ; i ++ ) { for ( int j = 0 ; j <= n + 1 ; j ++ ) { if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i
import java . io . * ; public class GFG { static int N = 100005 ; static int d [ ] = new int [ N ] ; static int pre [ ] = new int [ N ] ; static void Positive_Divisors ( ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } } public static void main ( String [ ] args ) { Positive_Divisors ( ) ; int n = 15 ; System . out . println ( pre [ n ] ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ m ] ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; int x = sc . nextInt ( ) ; for ( int j = 0 ; j < m - x + 1 ; j ++ ) { if ( a [ j ] == x ) { b [ j ] = 1 ; System . out . println ( j ) ; return ; } } } if ( x == 0 ) System . out . println ( " NULL " ) ; else { for ( int i = 0 ; i < m - x + 1 ; i ++ ) { if ( b [ i ] == 1 ) { System . out . println ( i + 1 ) ; return ; } } } } }
import java . io . * ; public class GFG { static float area_of_regular_polygon ( int n , int len ) { float P = ( float ) ( len * n ) ; float A = len / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; float area = ( P * A ) / 2 ; return area ; } static float area_of_triangle_inscribed ( int n , int len ) { float area = area_of_regular_polygon ( n , len ) ; float triangle = area / n ; float ins_tri = triangle * 3 ; return ins_tri ; } public static void main ( String [ ] args ) { int n = 6 , len = 10 ; System . out . println ( area_of_triangle_inscribed ( n , len ) ) ; } }
public class GFG { static int MAX = 256 ; static String lastNonRepeating ( String str , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) ] ++ ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . charAt ( i ) ; if ( freq [ ch ] == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int n = str . length ( ) ; System . out . println ( lastNonRepeating ( str , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = Integer . MAX_VALUE , y = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; if ( x < min ) { min = x ; } if ( y < max ) { max = y ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x == min && y == max ) { res = i + 1 ; break ; } } System . out . println ( res ) ; } }
import java . io . * ; public class GFG { static double y ( double x ) { return ( 1 / ( 1 + x ) ) ; } static double BooleRule ( double a , double b ) { int n = 4 ; double h = ( ( b - a ) / n ) ; double sum = 0 ; double bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; } public static void main ( String [ ] args ) { double lowlimit = 0 , upplimit = 4 ; System . out . println ( " f ( x ) ▁ = ▁ " + BooleRule ( lowlimit , upplimit ) ) ; } }
public class GFG { static int maxN = 20 ; static int maxM = 256 ; static int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; static boolean [ ] [ ] v = new boolean [ maxN ] [ maxM ] ; static int findLen ( int arr [ ] , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = arr . length ; int m = 3 ; int ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) ; if ( ans == - 1 ) System . out . println ( 0 ) ; else System . out . println ( ans ) ; } }
public class GFG { static int maxN = 20 ; static int maxM = 64 ; static int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; static int [ ] [ ] v = new int [ maxN ] [ maxM ] ; static int findLen ( int arr [ ] , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = arr . length ; int m = 3 ; int ans = findLen ( arr , 0 , 0 , n , m ) ; if ( ans == - 1 ) System . out . println ( 0 ) ; else System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] [ ] map = new int [ n ] [ n ] ; int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int a = sc . nextInt ( ) - 1 , b = sc . nextInt ( ) - 1 , t = sc . nextInt ( ) ; map [ a ] [ b ] = t ; map [ b ] [ a ] = t ; max = max ( max , map [ a ] [ b ] ) ; } int max2 = 0 , max1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max2 = max ( max2 , map [ i ] [ i ] ) ; max1 = max ( max1 , map [ i ] [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { max2 = max ( max2 , map [ i ] [ i ] ) ; max1 = max ( max1 , map [ i ] [ i ] ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += max2 - max1 ; if ( map [ i ] [ i ] > 0 && map [ i ] [ i ] != 0 ) { ans -= map [ i ] [ i ] * 2 ; } } System . out . println ( ans ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( n % 10 == 3 || n % 10 == 5 || n % 10 == 7 ) count ++ ; } System . out . println ( count ) ; } }
import java . util . Arrays ; public class GFG { static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . 2147483647 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 100 , 300 , 200 , 1000 , 20 , 30 } ; int n = arr . length ; int k = 3 ; System . out . println ( minDiff ( arr , n , k ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n ; int [ ] a ; int [ ] b ; while ( true ) { n = sc . nextInt ( ) ; a = new int [ n ] ; b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } boolean x = true ; boolean y = true ; while ( x ) { if ( a [ x ] > a [ x - 1 ] ) { if ( ! x ) { System . out . println ( " NO " ) ; x = false ; } else { x = false ; } } else { if ( b [ x ] < a [ x - 1 ] ) { if ( ! y ) { System . out . println ( " NO " ) ; y = false ; } else { x = true ; } } else { if ( ! x ) { x = false ; } } if ( y ) { if ( ! x ) { System . out . println ( " NO " ) ; y = false ; } else { x = false ; } } } } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int sum = 1 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( ( n - j ) % ( j - 1 ) == 0 ) { sum ++ ; } } System . out . println ( sum ) ; } } }
import java . io . * ; public class GFG { static double Mean ( int arr [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } static double meanAbsoluteDeviation ( int arr [ ] , int n ) { double absSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) absSum = absSum + Math . abs ( arr [ i ] - Mean ( arr , n ) ) ; return absSum / n ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 15 , 15 , 17 , 18 , 21 } ; int n = arr . length ; System . out . println ( meanAbsoluteDeviation ( arr , n ) ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 9 ) ; public String run ( ) { int [ ] primes = Library . listPrimes ( 100 ) ; return Integer . toString ( count ( 0 , 1 ) ) ; } private static int count ( int primeIndex , int product ) { if ( primeIndex == primes . length ) return ( product <= LIMIT ) ? 1 : 0 ; else { int result = 0 ; while ( product <= LIMIT ) { result += count ( primeIndex + 1 , product ) ; product *= primes [ primeIndex ] ; } return result ; } } }
import java . io . * ; public class GFG { static int maximumXOR ( int n , int l , int r ) { int x = 0 ; for ( int i = ( int ) Math . log10 ( r ) ; i >= 0 ; i -- ) { if ( ( n & ( 1 << i ) ) > 0 ) { if ( x > r || ( x + ( 1 << i ) - 1 < l ) ) x ^= ( 1 << i ) ; } else { if ( ( x ^ ( 1 << i ) ) <= r ) x ^= ( 1 << i ) ; } } return n ^ x ; } public static void main ( String [ ] args ) { int n = 7 ; int l = 2 , r = 23 ; System . out . println ( " The ▁ output ▁ is ▁ " + maximumXOR ( n , l , r ) ) ; } }
import java . util . * ; public class GFG { static int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = false ; } } } Vector < Integer > prime = new Vector < Integer > ( ) ; prime . add ( 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( arr [ i ] ) { prime . add ( i ) ; } } int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }
import java . util . * ; public class GFG { static int CountTrailingZeros ( int n ) { int bit = Integer . toBinaryString ( n ) . length ( ) ; int zero = 0 ; for ( int i = 0 ; i < bit . length ( ) ; i ++ ) { if ( bit . charAt ( i ) == '0' ) zero ++ ; else break ; } return zero ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( CountTrailingZeros ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int c = input . nextInt ( ) ; int case_1 = a + b + c ; int case_2 = a + a + b + b ; int case_3 = a + c + c + a ; int case_4 = b + c + c + b ; System . out . println ( Math . min ( case_1 , Math . min ( case_2 , Math . min ( case_3 , case_4 ) ) ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } int count = 0 ; for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { count ++ ; } } System . out . println ( count ) ; } } }
import java . util . * ; public class GFG { static int distinctSubstring ( String P , String Q , int K , int N ) { Set < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int sum = 0 ; String s = " " ; for ( int j = i ; j < N ; j ++ ) { int pos = P . charAt ( j ) - 97 ; sum = sum + Q . charAt ( pos ) - 48 ; s += P . charAt ( j ) ; if ( sum <= K ) S . add ( s ) ; else break ; } } return S . size ( ) ; } public static void main ( String [ ] args ) { String P = " abcde " ; String Q = "12345678912345678912345678" ; int K = 5 ; int N = P . length ( ) ; System . out . println ( distinctSubstring ( P , Q , K , N ) ) ; } }
public class GFG { static String makeEven ( String arr [ ] , int n ) { int first_e_i = - 1 , last_e_i = - 1 , last_n_i = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 && arr [ i ] < arr [ last_n_i ] ) { first_e_i = i ; break ; } if ( arr [ i ] % 2 == 0 ) last_e_i = i ; } if ( first_e_i != - 1 ) { swap ( arr , first_e_i , last_n_i ) ; return arr ; } if ( first_e_i == - 1 && last_e_i != - 1 ) { swap ( arr , last_e_i , last_n_i ) ; return arr ; } return arr ; } static void swap ( String str , int i , int j ) { String str_str = " " + str + str . charAt ( i ) ; char ch_ch [ ] = str_str . toCharArray ( ) ; char ch_ch1 [ ] = ch_ch . toCharArray ( ) ; char ch_ch2 [ ] = ch_ch . toCharArray ( ) ; String str_str = new String ( str_str ) ; System . out . println ( makeEven ( str_str , str_str . length ( ) ) ) ; } public static void main ( String [ ] args ) { String str = "1356425" ; String result = makeEven ( str , str . length ( ) ) ; System . out . println ( result ) ; } }
import java . io . * ; public class GFG { static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j * i <= n ) { div [ i * j ] ++ ; } } } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( div [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 10 ; findDivisors ( n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s1 = sc . next ( ) ; String s2 = sc . next ( ) ; long count = 0 ; long len = s2 . length ( ) ; long len1 = s1 . length ( ) - len1 ; long len0 = 0 ; long len1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s1 . charAt ( i ) == '0' ) { len0 ++ ; } if ( s2 . charAt ( i ) == '0' ) { len1 ++ ; } if ( s2 . charAt ( i ) == '1' ) { len1 ++ ; } } long ans = 0 ; for ( int i = len - len1 ; i >= 0 ; i -- ) { if ( s2 . charAt ( i ) == '0' ) { ans += len1 ; } else { ans += len0 ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static final int MAX_CHAR = 256 ; static void printDistinct ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ MAX_CHAR ] ; int index [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { int x = str . charAt ( i ) - ' a ' ; count [ x ] ++ ; if ( count [ x ] == 1 && x != ' ▁ ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( index [ i ] == n ) break ; System . out . print ( str . charAt ( index [ i ] ) ) ; } } public static void main ( String [ ] args ) { printDistinct ( str ) ; } }
import java . io . * ; public class GFG { static int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k > 0 ) { result = ( int ) Math . pow ( result , x ) ; if ( result > m ) result = result % m ; k -- ; } return result ; } public static void main ( String [ ] args ) { int x = 5 , k = 2 , m = 3 ; System . out . println ( calculate ( x , k , m ) ) ; } }
public class GFG { static void converthenumber ( int n ) { String s = Integer . toString ( n ) ; String res = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' || s . charAt ( i ) == '3' || s . charAt ( i ) == '5' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) { res += s . charAt ( i ) ; } if ( res . length ( ) == 2 ) break ; } if ( res . length ( ) == 2 ) System . out . println ( res ) ; else System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 18720 ; converthenumber ( n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; String s = sc . next ( ) ; String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { char x = ( char ) ( ( int ) ' a ' + ( i % 2 ) ) ; if ( s . indexOf ( x ) < 0 ) { res = x ; break ; } } System . out . println ( res ) ; } } }
import java . util . Scanner ; import java . util . ArrayList ; import java . util . HashSet ; class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int num = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = 0 ; i < num ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; String [ ] temp = input . nextLine ( ) . split ( " ▁ " ) ; ArrayList < Integer > l = new ArrayList < > ( ) ; for ( String s : temp ) { l . add ( Integer . parseInt ( s ) ) ; } HashSet < Integer > a = new HashSet < > ( l ) ; ArrayList < Integer > l1 = new ArrayList < > ( ) ; for ( int j = 1 ; j <= n ; j ++ ) { l1 . add ( Math . max ( j , a . size ( ) ) ) ; } for ( int x : l1 ) { System . out . print ( x + " ▁ " ) ; } System . out . println ( ) ; } } }
import java . io . * ; public class GFG { static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } static int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; char [ ] [ ] m = new char [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { m [ i ] = sc . next ( ) . toCharArray ( ) ; } int [ ] [ ] sum = new int [ h * w ] ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( m [ i ] [ j ] == ' J ' ) sum [ i + 1 ] ++ ; if ( j + 1 < w ) sum [ i + 1 ] ++ ; if ( j + 1 < h ) sum [ i + 1 ] ++ ; } } int ans = 0 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( m [ i ] [ j ] == ' O ' ) sum [ j + 1 ] ++ ; if ( j + 1 < w ) sum [ j + 1 ] ++ ; } } for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { ans += sum [ i ] * sum [ j ] ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int countDivisors ( int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % k == 0 ) count ++ ; if ( ( n / i ) % k == 0 ) count ++ ; } if ( ( i * i == n ) && ( i % k == 0 ) ) count -- ; } return count ; } public static void main ( String [ ] args ) { int n = 12 , k = 3 ; System . out . println ( countDivisors ( n , k ) ) ; } }
import java . io . * ; public class GFG { static int countDivisors ( int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int n = 12 , k = 3 ; System . out . println ( countDivisors ( n , k ) ) ; } }
public class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y > 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int findModuloByM ( int X , int N , int M ) { if ( N < 6 ) { int temp = ( char ) ( 48 + X ) * N ; res = ( int ) ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } public static void main ( String [ ] args ) { int X = 6 , N = 14 , M = 9 ; System . out . println ( findModuloByM ( X , N , M ) ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { int n = s . nextInt ( ) ; int [ ] p = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = s . nextInt ( ) ; } int m = s . nextInt ( ) ; int [ ] q = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { q [ i ] = s . nextInt ( ) ; } int even = 0 , odd = 0 , evenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 == 0 ) { even ++ ; } else { odd ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( q [ i ] % 2 == 0 ) { odd ++ ; } else { evenCount ++ ; } } System . out . println ( ( evenCount * oddCount ) + ( evenCount * oddCount ) ) ; } } }
import java . io . * ; public class GFG { static int findMaxDiff ( int a [ ] , int n ) { if ( n < 2 ) { System . out . println ( " Invalid ▁ " ) ; return 0 ; } int min_val = Integer . MAX_VALUE , max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] - i ) > max_val ) max_val = a [ i ] - i ; if ( ( a [ i ] - i ) < min_val ) min_val = a [ i ] - i ; } return ( max_val - min_val ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 15 , 4 , 12 , 13 } ; int n = arr . length ; System . out . println ( findMaxDiff ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = s . charAt ( j ) ; } } boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] [ j ] > ( arr [ i + 1 ] [ j + 1 ] + arr [ i ] [ j + 1 ] - 1 ) || arr [ i ] [ j ] > ( arr [ i + 1 ] [ j + 1 ] + arr [ i ] [ j + 1 ] - 1 ) ) { arr [ i ] [ j ] = arr [ i ] [ j ] + arr [ i + 1 ] [ j + 1 ] - 1 ; arr [ i ] [ j ] = arr [ i ] [ j ] - 1 ; arr [ i ] [ j ] = arr [ i + 1 ] [ j + 1 ] - 1 ; } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] [ j ] > ( arr [ i + 1 ] [ j ] + arr [ i ] [ j + 1 ] - 1 ) ) { flag = false ; break ; } } } if ( flag ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; return count [ m - 1 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int m = 3 , n = 3 ; System . out . println ( numberOfPaths ( m , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; long sum = 0 ; boolean ok = false ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; sum += a ; if ( a % n == 0 ) ok = true ; } if ( ok ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
public class GFG { static boolean isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) & 1 ) return true ; return false ; } static int setKthBit ( int n , int k ) { return ( ( 1 << ( k - 1 ) ) | n ) ; } static boolean allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } static boolean bitsAreInAltOrder ( int n ) { int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; } static boolean bitsAreInAltPatrnInGivenRange ( int n , int l , int r ) { if ( isKthBitSet ( n , r ) ) { num = n ; int left_shift = r ; } else { num = setKthBit ( n , ( r + 1 ) ) ; left_shift = r + 1 ; } num = num & ( ( 1 << left_shift ) - 1 ) ; num = num >> ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; } public static void main ( String [ ] args ) { int n = 18 , l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; } static int nCr ( int n , int r ) { return ( factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ) ; } static int NumberOfWays ( int n , int x , int y ) { return ( nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ) ; } public static void main ( String [ ] args ) { int n = 5 , x = 4 , y = 2 ; System . out . println ( NumberOfWays ( n , x , y ) ) ; } }
import java . util . * ; public class GFG { static String commonPrefixUtil ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; String result = " " ; int j = 0 ; int i = 0 ; while ( i <= n1 - 1 && j <= n2 - 1 ) { if ( str1 . charAt ( i ) != str2 . charAt ( j ) ) break ; result += ( str1 . charAt ( i ) ) ; i ++ ; j ++ ; } return ( result ) ; } static void commonPrefix ( String arr [ ] , int n ) { Arrays . sort ( arr ) ; System . out . println ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) ; } public static void main ( String [ ] args ) { String arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = arr . length ; commonPrefix ( arr , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] arr = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextLong ( ) ; Arrays . sort ( arr ) ; long ans = arr [ n - 1 ] * n ; for ( int i = n - 2 ; i >= 0 ; i -= 2 ) { ans += arr [ i ] * n ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) { ans ++ ; } else if ( a [ i ] == 2 ) { ans ++ ; } } System . out . println ( ans ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int a = 0 , b = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { a = b ; b = a + b ; } return Integer . toString ( a ) ; } }
import java . util . * ; public class GFG { static void findFrequencyUtil ( int arr [ ] , int low , int high , int freq [ ] ) { if ( arr [ low ] == arr [ high ] ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( low + high ) / 2 ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } } static void findFrequency ( int arr [ ] , int n ) { int freq [ ] = new int [ n - 1 + 1 ] ; findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr [ n - 1 ] ; i ++ ) { if ( freq [ i ] != 0 ) { System . out . println ( " Element ▁ " + i + " ▁ occurs ▁ " + freq [ i ] + " ▁ times " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 } ; int n = arr . length ; findFrequency ( arr , n ) ; } }
public final class p036 { public static void main ( String [ ] args ) { System . out . println ( new p036 ( ) . run ( ) ) ; } public String run ( ) { int minnumer = 1 ; int mindenom = 0 ; int [ ] totients = Library . listTotients ( Library . pow ( 10 , 7 - 1 ) ) ; for ( int i = 2 ; i < totients . length ; i ++ ) { if ( i * mindenom < minnumer * tot && Integer . toString ( i ) . compareTo ( Integer . toString ( totients [ i ] ) ) < 0 ) { minnumer = i ; mindenom = totients [ i ] ; } } return Integer . toString ( minnumer ) ; } }
import java . util . * ; public class GFG { static void intersection ( int a [ ] , int b [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) j ++ ; else { if ( b [ j ] > a [ i ] ) i ++ ; else { System . out . print ( a [ i ] + " ▁ " ) ; i ++ ; j ++ ; } } } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 } ; int b [ ] = { 3 , 3 , 5 } ; int n = a . length ; int m = b . length ; intersection ( a , b , n , m ) ; } }
import java . io . * ; public class GFG { static int findMin ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) Math . log ( a [ i ] ) ; double x = Math . exp ( sum / n ) ; return ( int ) x + 1 ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 4 } ; int n = a . length ; System . out . println ( findMin ( a , n ) ) ; } }
import java . io . * ; public class GFG { static int lcmOfArray ( int [ ] arr , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } static int minPerfectSquare ( int [ ] arr , int n ) { int lcm = lcmOfArray ( arr , n ) ; int minPerfectSq = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 2 != 0 ) minPerfectSq *= 2 ; for ( int i = 3 ; lcm > 1 ; i += 2 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 2 != 0 ) minPerfectSq *= i ; } return minPerfectSq ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ; System . out . println ( minPerfectSquare ( arr , n ) ) ; } }
public class GFG { static int subarrayCount ( int arr [ ] , int n ) { int result = 0 ; int fast = 0 , slow = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) fast ++ ; else { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; fast = i ; slow = i ; } } if ( fast != slow ) { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( subarrayCount ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long n = sc . nextLong ( ) ; if ( n == 1 ) { System . out . println ( 1 ) ; } else { long count = 0 ; long n2 = n ; while ( true ) { if ( n % 2 == 0 ) { n2 = n / 2 ; count ++ ; } else { long x = n / 2 ; count = count + ( x * 2 ) - 1 ; n = n2 / 2 ; } } System . out . println ( count + n2 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int max = 0 , min = Integer . MAX_VALUE , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( arr [ i ] > max ) { max = arr [ i ] ; } sum += arr [ i ] ; } System . out . println ( max + " ▁ " + min + " ▁ " + sum ) ; } }
import java . util . * ; public class GFG { static int MAX_CHARS = 256 ; static String findSubString ( String str ) { int n = str . length ( ) ; if ( n <= 1 ) return str ; int dist_count = str . length ( ) ; HashSet < Character > curr_count = new HashSet < > ( ) ; int count = 0 ; int start = 0 , min_len = n ; for ( int j = 0 ; j < n ; j ++ ) { curr_count . add ( str . charAt ( j ) ) ; if ( curr_count . contains ( str . charAt ( j ) ) ) count ++ ; if ( count == dist_count ) { while ( curr_count . contains ( str . charAt ( start ) ) ) { if ( curr_count . contains ( str . charAt ( start ) ) ) curr_count . remove ( str . charAt ( start ) ) ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start = start ; } } } return str . substring ( start_index , start_index + min_len ) ; } public static void main ( String [ ] args ) { System . out . println ( " Smallest ▁ window ▁ containing ▁ " + " all ▁ distinct ▁ characters ▁ is : ▁ " + findSubString ( " aabcbcdbca " ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int w1 = sc . nextInt ( ) ; int w2 = sc . nextInt ( ) ; int w3 = sc . nextInt ( ) ; int h1 = sc . nextInt ( ) ; int w4 = sc . nextInt ( ) ; int h5 = sc . nextInt ( ) ; int max = w1 * w2 ; int h6 = w1 * w3 ; int max2 = h5 * h6 ; int max = w4 * h5 ; int max5 = w4 * w3 ; int max = h6 * h6 ; for ( int i = 1 ; i <= max ; i ++ ) { int x = w1 + i ; if ( x <= w2 ) { int y = x * w2 + w3 * w4 ; if ( y <= max ) { max = y ; max2 = y ; } } } System . out . println ( max2 + " ▁ " + max ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = null ; int [ ] [ ] grid = new int [ 2 ] [ grid . length ] ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] input = line . trim ( ) . split ( " , " ) ; for ( int i = 0 ; i < input . length ; i ++ ) { grid [ 0 ] [ i ] = Integer . parseInt ( input [ i ] ) ; } grid [ 1 ] [ 0 ] = 0 ; for ( int i = 1 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) { for ( int k = 1 ; k < grid [ 0 ] . length ; k ++ ) { if ( j == 0 || j + 1 < grid . length || grid [ 0 ] [ j ] > grid [ 0 ] [ i ] ) { grid [ 0 ] [ i ] = grid [ 0 ] [ i ] ; grid [ 0 ] [ i ] = 0 ; } else if ( j > grid [ 0 ] [ i ] ) { grid [ 0 ] [ i ] = grid [ 0 ] [ i ] ; grid [ 0 ] [ i ] = grid [ 0 ] [ i - 1 ] + grid [ 1 ] [ j ] ; grid [ 1 ] [ j ] = 0 ; } else if ( j == grid [ 0 ] [ i ] ) { grid [ 0 ] [ i ] = grid [ 0 ] [ i - 1 ] + grid [ 1 ] [ i ] ; } } } } System . out . println ( grid [ 0 ] [ 0 ] ) ; } } }
import java . io . * ; public class GFG { static void countPairs ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int odd_pairs = odd * ( n - 1 ) ; int even_pairs = even * ( n - 1 ) ; System . out . println ( odd_pairs ) ; System . out . println ( even_pairs ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int n = arr . length ; countPairs ( arr , n ) ; } }
import java . util . Scanner ; public class A_Two_Rabbits { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int e = 0 , f = 0 , d1 = 0 , f2 = 0 ; for ( int i = 0 ; i < c ; ++ i ) { if ( i == a ) { e = i ; break ; } } d = Math . abs ( b - c ) + 1 ; if ( a < e ) { System . out . println ( " > " ) ; } else if ( a == e ) { System . out . println ( " = " ) ; } else if ( a == e ) { System . out . println ( " = " ) ; } else if ( a > e ) { System . out . println ( " < " ) ; } else { System . out . println ( " > " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; for ( int j = 0 ; j < m ; j ++ ) { arr [ i ] [ j ] = s . charAt ( j ) ; } } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' S ' ) { if ( arr [ i ] [ j ] == 1 ) { cnt ++ ; } } } } if ( cnt == 0 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( cnt ) ; } } }
import java . io . * ; public class GFG { static boolean search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x || arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 80 , 30 , 60 , 50 , 100 , 130 , 170 } ; int x = 130 ; int n = arr . length ; if ( search ( arr , n , x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . HashMap ; public class Main { public static void countFreq ( int [ ] arr , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , 0 ) ; } mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( arr [ i ] ) != - 1 ) { System . out . println ( arr [ i ] + " ▁ " + mp . get ( arr [ i ] ) ) ; } mp . put ( arr [ i ] , - 1 ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = arr . length ; countFreq ( arr , n ) ; } }
import java . util . * ; public class GFG { static int MinCostTree ( int arr [ ] , int n ) { int ans = 0 ; Stack < Integer > st = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! st . empty ( ) && st . peek ( ) <= arr [ i ] ) { int x = st . peek ( ) ; st . pop ( ) ; ans += x * Math . min ( st . peek ( ) , arr [ i ] ) ; st . push ( arr [ i ] ) ; } st . push ( arr [ i ] ) ; } for ( int i = 2 ; i < st . size ( ) ; i ++ ) ans += st . peek ( ) * st . peek ( ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 } ; int n = arr . length ; System . out . println ( MinCostTree ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; ArrayList < Integer > arr = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr . add ( s . indexOf ( t . charAt ( i ) ) ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) != null ) { count ++ ; } } if ( count != 0 ) { System . out . println ( - 1 ) ; } else { int temp = arr . get ( 0 ) ; System . out . print ( arr . indexOf ( temp ) + 1 + " ▁ " ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { System . out . print ( arr . get ( i ) + 1 + " ▁ " ) ; } } } }
import java . io . * ; public class GFG { static void findEquation ( int a , int b ) { int summ = ( a + b ) ; int product = ( a * b ) ; System . out . println ( " x ^ 2 ▁ - ▁ ( " + summ + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 ; findEquation ( a , b ) ; } }
import java . io . * ; public class GFG { static void circle_equation ( int x1 , int y1 , int r ) { int a = - 2 * x1 ; int b = - 2 * y1 ; int c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " x ) ▁ + ▁ " ) ; System . out . print ( " y ^ 2 ▁ + ▁ ( " + b + " y ) ▁ = ▁ " ) ; System . out . print ( c + " . " ) ; } public static void main ( String [ ] args ) { int x1 = 2 , y1 = - 3 , r = 8 ; circle_equation ( x1 , y1 , r ) ; } }
import java . util . * ; public class GFG { static void unique_combination ( int l , int sum , int K , Vector < Integer > local , Vector < Integer > A ) { if ( sum == K ) { System . out . print ( " { " ) ; for ( int i = 0 ; i < local . size ( ) ; i ++ ) { if ( i != 0 ) System . out . print ( " ▁ " ) ; System . out . print ( local . get ( i ) ) ; if ( i != local . size ( ) - 1 ) System . out . print ( " , ▁ " ) ; } System . out . println ( " } " ) ; return ; } for ( int i = l ; i < A . size ( ) ; i ++ ) { if ( sum + A . get ( i ) > K ) continue ; if ( i == 1 && A . get ( i ) == A . get ( i - 1 ) && i > l ) continue ; local . add ( A . get ( i ) ) ; unique_combination ( i + 1 , sum + A . get ( i ) , K , local , A ) ; local . remove ( local . size ( ) - 1 ) ; } } static void Combination ( int [ ] A , int K ) { Arrays . sort ( A ) ; Vector < Integer > local = new Vector < Integer > ( ) ; unique_combination ( 0 , 0 , K , local , A ) ; } public static void main ( String [ ] args ) { int A [ ] = { 10 , 1 , 2 , 7 , 6 , 1 , 5 } ; int K = 8 ; Combination ( A , K ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { int key = sc . nextInt ( ) ; int tmp = arr [ 0 ] ; arr [ 0 ] = key ; arr [ n - 1 ] = tmp ; } int m = sc . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int key = sc . nextInt ( ) ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] >= key ) { l = mid ; } else { r = mid ; } } System . out . println ( l ) ; } } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String s = sc . next ( ) ; char [ ] ch = s . toCharArray ( ) ; boolean [ ] p = new boolean [ 26 ] ; Arrays . fill ( p , true ) ; p [ 0 ] = false ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ch [ i ] ) { for ( int j = 1 ; j < s . length ( ) ; j ++ ) { if ( ch [ j ] ) p [ j ] = false ; else if ( j > 0 && ch [ j - 1 ] ) p [ j ] = false ; } } } boolean t = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( p [ i ] ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == ' a ' || s . charAt ( j ) == ' h ' || s . charAt ( j ) == ' i ' || s . charAt ( j ) == ' s ' ) break ; } if ( t ) { t = false ; break ; } } } } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( p [ i ] ) System . out . print ( s . charAt ( i ) ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } } }
import java . io . * ; public class GFG { static boolean findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) ; if ( n == 1 ) return ( b & 1 ) ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ? true : false ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ? true : false ; else return ( n + 1 ) % 3 != 0 ) ? true : false ; } return false ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 , n = 3 ; if ( findNature ( a , b , n ) == true ) System . out . print ( " Odd ▁ " ) ; else System . out . print ( " Even ▁ " ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { int d = in . nextInt ( ) ; int e = in . nextInt ( ) ; if ( d == 0 && e == 0 ) return false ; double dist = Math . sqrt ( ( double ) d * d ) ; for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) { double dist = Math . sqrt ( ( double ) i * i + ( double ) j * j ) ; if ( dist - e <= dist ) { out . println ( i + 1 ) ; return true ; } } return false ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class GFG { static int max_sum ( int a [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; else if ( n == 2 ) dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; else if ( n >= 3 ) { dp [ 0 ] = Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ; dp [ 1 ] = Math . max ( a [ 2 ] , Math . max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = Math . max ( a [ 2 ] , Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ) ; for ( int i = 3 ; i < n ; i ++ ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; } } return dp [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , - 2 , 4 , 3 } ; int n = arr . length ; System . out . println ( max_sum ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; if ( isPalindrome ( s ) && isReflectable ( s ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } public static boolean isPalindrome ( String s ) { int i = 0 ; int j = s . length ( ) - 1 ; while ( i < j ) { if ( s . charAt ( i ) != ' ? ' && s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) { i ++ ; j -- ; } else if ( s . charAt ( i ) != ' ? ' && s . charAt ( i ) != ' a ' ) { i ++ ; } else if ( s . charAt ( i ) != ' ? ' && s . charAt ( i ) != ' a ' ) { j -- ; } else if ( s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) { i ++ ; } else if ( s . charAt ( i ) != ' ? ' && s . charAt ( i ) != ' ? ' ) { j -- ; } } if ( isPalindrome ( s ) ) { return true ; } return false ; } }
import java . io . * ; public class GFG { static int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; } } return mini ; } public static void main ( String [ ] args ) { int n = 4 , k = 6 ; System . out . println ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; System . out . println ( minimumX ( n , k ) ) ; } }
import java . io . * ; import java . util . * ; public class B { static int N ; static List < Integer > [ ] graph ; static boolean [ ] visited ; static int [ ] longest ; static int [ ] [ ] dfs ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( " input . txt " ) ) ; PrintWriter pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( " output . txt " ) ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( " output . txt " ) ) ; int caseN = Integer . parseInt ( br . readLine ( ) ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { N = Integer . parseInt ( br . readLine ( ) ) ; graph = new ArrayList [ N + 1 ] ; visited = new boolean [ N + 1 ] ; longest = new int [ N + 1 ] ; dfs = new ArrayList [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { graph [ i ] = new ArrayList < > ( ) ; } for ( int i = 0 ; i < N ; i ++ ) { graph [ i ] . add ( Integer . parseInt ( br . readLine ( ) ) ) ; } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { dfs [ i ] = 1 ; dfs [ i ] += dfs [ i ] ; ans = Math . max ( ans , dfs [ i ] + 1 ) ; } } pw . println ( " Case ▁ # " + caseID + " : ▁ " + ans ) ; } pw . close ( ) ; } public static void dfs ( int id ) { visited [ id ] = true ; int sum = 0 ; for ( int i = 0 ; i < graph [ id ] . size ( ) ; i ++ ) { if ( graph [ id ] . get ( i ) == id ) continue ; dfs ( graph [ id ] . get ( i ) ) ; sum += dfs ( graph [ id ] . get ( i ) ) ; } } }
import java . io . * ; public class GFG { static int SellingPrice ( int CP , int PP ) { int Pdecimal = 1 + ( PP / 100 ) ; int res = Pdecimal * CP ; return res ; } public static void main ( String [ ] args ) { int C = 720 , P = 13 ; System . out . println ( SellingPrice ( C , P ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int l = arr [ 0 ] , r = arr [ 0 ] , count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == l ) { count ++ ; } else if ( arr [ i ] > r ) { count ++ ; } } System . out . println ( count ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long s = sc . nextLong ( ) ; long ans = 0 ; long k = 0 ; for ( long i = 2 ; i * i <= n ; i ++ ) { if ( ( n - i ) % i == 0 && ( n - i ) / i + 1 < s ) { ans = i ; k = n - i / i ; } } System . out . println ( k == 0 ? - 1 : ans ) ; } }
import java . util . Scanner ; public class b { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int m = in . nextInt ( ) ; int b = in . nextInt ( ) ; int max = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { int temp = i ; max = Math . max ( max , temp ) ; } for ( int i = 0 ; i <= m ; i ++ ) { int temp = i ; max = Math . max ( max , temp * ( i - 1 ) * ( m - i ) + temp * ( m - i ) ) ; } System . out . println ( max ) ; } }
import java . io . * ; public class GFG { static void check ( int n , int m ) { if ( m % n == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 10 ; check ( n , m ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set . add ( sc . nextInt ( ) ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( set . contains ( i ) ) { System . out . println ( " YES " ) ; continue ; } if ( i == n - 1 ) { System . out . println ( " NO " ) ; continue ; } if ( i == n - 2 ) { System . out . println ( " YES " ) ; continue ; } if ( set . contains ( i - 1 ) ) { System . out . println ( " NO " ) ; continue ; } } System . out . println ( " YES " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int ans = 0 ; if ( a == b ) System . out . println ( 0 ) ; else if ( a > b ) { if ( a < b ) ans = a - b ; else ans = b - a ; System . out . println ( ans ) ; } else if ( a < b ) { if ( b < a ) ans = b - a ; else ans = 0 ; System . out . println ( ans ) ; } else { if ( a < b ) ans = b - a ; else ans = 0 ; System . out . println ( ans ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; String s = sc . next ( ) ; HashMap < String , String > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String str = s . substring ( i , i + n ) ; map . put ( str , map . get ( str ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { String [ ] str2 = sc . next ( ) . split ( " ▁ " ) ; String a = str2 [ 0 ] ; String b = str2 [ 1 ] ; String c = str3 [ 0 ] ; String d = str3 [ 1 ] ; String e = map . get ( a ) ; String f = map . get ( b ) ; map . put ( a , f ) ; map . put ( b , d ) ; } String ans = " " ; for ( int i = 0 ; i < n ; i ++ ) { ans += map . get ( s . substring ( i , i + n ) ) ; } System . out . println ( ans ) ; } }
public class GFG { static int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occur ++ ; } if ( occur == N ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { String str = " geeks " ; char ch = ' e ' ; int N = 2 ; System . out . println ( findNthOccur ( str , ch , N ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; if ( a == b && c > d ) { System . out . println ( " Elephant " ) ; } else if ( a == c && b > d ) { System . out . println ( " Elephant " ) ; } else if ( a == d && b > e ) { System . out . println ( " Alien " ) ; } else if ( a == d && b > e ) { System . out . println ( " Elephant " ) ; } else if ( a == c && b > d ) { System . out . println ( " Alien " ) ; } else if ( a == d && b > d ) { System . out . println ( " Elephant " ) ; } else if ( a == d && b == e ) { System . out . println ( " Bear " ) ; } } }
public final class p039 { public static void main ( String [ ] args ) { System . out . println ( new p039 ( ) . run ( ) ) ; } private static final long LIMIT = Library . pow ( 10 , 15 ) ; private static final long MODULUS = Library . pow ( 10 , 9 ) ; public String run ( ) { long sum = 0 ; int splitCount = Library . sqrt ( LIMIT ) ; int splitat = LIMIT / ( splitCount + 1 ) ; for ( int i = 1 ; i <= splitat ; i ++ ) { sum += ( long ) ( i * i * ( long ) ( LIMIT / i ) ) ; sum %= MODULUS ; } return Long . toString ( sum ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int z = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = sc . nextInt ( ) ; } long max = Long . MIN_VALUE ; long sum = 0 ; for ( int j = 0 ; j <= k ; j ++ ) { if ( j % 2 == 0 ) { if ( a [ j ] + a [ j + 1 ] <= z ) { max = Math . max ( max , a [ j ] + a [ j + 1 ] ) ; } } else { sum += a [ j ] ; } if ( j % 2 == 1 ) { if ( a [ j ] + a [ j + 1 ] <= z ) { max = Math . max ( max , a [ j ] + a [ j + 1 ] ) ; } } } sum += a [ n - 1 ] ; if ( sum > max ) max = sum ; } System . out . println ( max ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int l = arr [ 0 ] ; int r = arr [ n - 1 ] ; int min = 0 ; int i = 0 ; while ( l < r ) { if ( arr [ l ] == min ) { System . out . print ( ( l + 1 ) + " ▁ " ) ; break ; } if ( arr [ l ] == min ) { i ++ ; min ++ ; } else { i -- ; } } if ( i == - 1 ) { System . out . print ( 0 ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] start = new int [ n ] ; int [ ] end = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { start [ i ] = sc . nextInt ( ) * 60 + sc . nextInt ( ) ; end [ i ] = sc . nextInt ( ) * 60 + sc . nextInt ( ) ; } int ans = 0 ; for ( int i = 0 ; i < 2 ; i ++ ) { int [ ] start = new int [ i ] ; int [ ] end = new int [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { start [ j ] = ( start [ j ] == i ) ? 1 : 0 ; end [ j ] = ( end [ j ] == i ) ? 1 : 0 ; } for ( int j = 0 ; j < n ; j ++ ) { if ( start [ j ] == i ) continue ; int [ ] start_times = new int [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( start [ k ] == j ) start_times [ k ] ++ ; } for ( int k = 0 ; k < n ; k ++ ) { if ( end [ k ] == k ) end [ k ] ++ ; } int len = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( end [ j ] == i ) { len ++ ; } } if ( len > ans ) ans = len ; } } System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) , v = sc . nextInt ( ) ; if ( ( n | v ) == 0 ) break ; LinkedList < Integer > list = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) list . add ( i ) ; int max = 0 , cnt = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { cnt = 0 ; for ( int j = i ; j < list . size ( ) ; j ++ ) { if ( list . get ( j ) == v ) { list . remove ( j ) ; cnt -- ; break ; } else if ( list . get ( j ) == v ) { list . remove ( j ) ; cnt = 0 ; break ; } } max = max ( max , cnt ) ; } for ( ; ; ) { int c = 0 ; for ( int i : list ) c += cnt ; System . out . println ( c ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] x = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { x [ i ] = sc . nextInt ( ) ; } int sum = 0 ; int left = 0 ; int right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( left < m && sum + a [ right ] <= x [ left ] ) { left ++ ; } right ++ ; sum += a [ left ] ; sum -= a [ right ] ; } int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) { ans += right - left ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class A_Two_Rabbits { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( solve ( a , b ) ) ; } sc . close ( ) ; } static int solve ( int a , int b ) { return Math . abs ( a - b ) / 10 ; } }
import java . util . * ; public class GFG { static int maxSize = 100005 ; static boolean [ ] isFib = new boolean [ maxSize ] ; static int prefix [ ] = new int [ maxSize ] ; static int digitSum ( int num ) { int s = 0 ; while ( num != 0 ) { s = s + num % 10 ; num = num / 10 ; } return s ; } static void generateFibonacci ( ) { int prev = 0 , curr = 1 ; isFib [ prev ] = true ; isFib [ curr ] = true ; while ( curr < maxSize ) { int temp = curr + prev ; if ( temp < maxSize ) isFib [ temp ] = true ; prev = curr ; curr = temp ; } } static void precompute ( int k ) { generateFibonacci ( ) ; prefix [ 0 ] = 1 ; for ( int i = 1 ; i < maxSize ; i ++ ) { int sum = digitSum ( i ) ; if ( isFib [ sum ] == true && sum % k == 0 ) prefix [ i ] ++ ; } for ( int i = 1 ; i < maxSize ; i ++ ) prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] ; } static void performQueries ( int k , int q , int query [ ] [ ] ) { precompute ( k ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int cnt = prefix [ r ] - prefix [ l - 1 ] ; System . out . println ( cnt ) ; } } public static void main ( String [ ] args ) { int [ ] [ ] query = { { 1 , 11 } , { 5 , 15 } , { 2 , 24 } } ; int k = 2 ; int q = query . length ; performQueries ( k , q , query ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = Integer . parseInt ( scanner . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] coordinates1 = scanner . nextLine ( ) . split ( " ▁ " ) ; int x1 = Integer . parseInt ( coordinates1 [ 0 ] ) ; int y1 = Integer . parseInt ( coordinates1 [ 1 ] ) ; String [ ] coordinates2 = scanner . nextLine ( ) . split ( " ▁ " ) ; int x2 = Integer . parseInt ( coordinates2 [ 0 ] ) ; int y2 = Integer . parseInt ( coordinates2 [ 1 ] ) ; String [ ] coordinates3 = scanner . nextLine ( ) . split ( " ▁ " ) ; int x3 = Integer . parseInt ( coordinates3 [ 0 ] ) ; int y3 = Integer . parseInt ( coordinates3 [ 1 ] ) ; int alpha = 0 ; if ( y1 == y2 && y3 < y1 ) { alpha += Math . abs ( x1 - x2 ) ; } if ( y2 == y3 && y1 < y2 ) { alpha += Math . abs ( x2 - x3 ) ; } if ( y3 == y1 && y2 < y3 ) { alpha += Math . abs ( x3 - x1 ) ; } System . out . println ( alpha ) ; } scanner . close ( ) ; } }
import java . util . * ; public class GFG { static boolean isPalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( l - 1 - i ) ) return false ; } return true ; } static boolean createStringAndCheckPalindrome ( int N ) { String sub = " " + ( char ) ( N ) ; String res_str = " " ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length ( ) < sum ) { res_str += sub ; } if ( res_str . length ( ) > sum ) { res_str = res_str . substring ( 0 , sum ) ; } if ( isPalindrome ( res_str ) ) return true ; return false ; } public static void main ( String [ ] args ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String [ ] s = new String [ n ] ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = sc . next ( ) ; a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s [ i ] . charAt ( j ) == ' S ' && j < a [ j ] . length ( ) ) { if ( s [ i ] . charAt ( j ) == ' H ' && j < b [ j ] . length ( ) ) { if ( a [ i ] == j && j < a [ j ] . length ( ) ) { System . out . println ( s [ i ] + " ▁ " + a [ j ] ) ; break ; } } } } } } }
import java . io . * ; public class GFG { static int sum_even_and_even_index ( int arr [ ] , int n ) { int i ; int sum = 0 ; for ( i = 0 ; i < n ; i = i + 2 ) { if ( arr [ i ] % 2 == 0 ) sum += arr [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 12 , 1 , 18 , 8 } ; int n = arr . length ; System . out . println ( " Sum ▁ of ▁ even ▁ numbers ▁ at ▁ " + " ▁ " + " even ▁ indices ▁ is ▁ " + sum_even_and_even_index ( arr , n ) ) ; } }
import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { String str = s . next ( ) ; char [ ] arr = str . toCharArray ( ) ; String res = " YES " ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { res = " NO " ; break ; } } System . out . println ( res ) ; } } }
import java . io . * ; public class GFG { static void printDuplicates ( int arr [ ] , int n ) { boolean fl = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { System . out . print ( arr [ i ] % n + " ▁ " ) ; fl = true ; } } arr [ arr [ i ] % n ] += n ; } if ( fl == false ) System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arr_size = arr . length ; printDuplicates ( arr , arr_size ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans ++ ; for ( int j = 1 ; j <= i ; j ++ ) { if ( i + j == n ) { ans ++ ; } } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( sum ( n ) ) ; } }
import java . io . * ; public class GFG { static int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( maxHandshake ( n ) ) ; } }
import java . io . * ; public class GFG { static int grayCode ( int n ) { return n ^ ( n >> 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( grayCode ( n ) ) ; } }
import java . io . * ; public class GFG { static int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( Max_Sum ( n ) ) ; } }
import java . io . * ; public class GFG { static int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( possibleways ( n ) ) ; } }
public class GFG { static int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; } public static void main ( String [ ] args ) { int n = 21 ; System . out . println ( CountSetBits ( n ) ) ; } }
import java . io . * ; public class GFG { static int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; } public static void main ( String [ ] args ) { int m = 3 , n = 2 ; System . out . println ( sum ( m , n ) ) ; } }
import java . io . * ; public class GFG { static int sum ( int n , int m ) { if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; int sum = sum ( n , m - 1 ) ; return sum * ( sum + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 5 , m = 3 ; System . out . println ( " Sum ( " + n + " , ▁ " + m + " ) : ▁ " + sum ( n , m ) ) ; } }
import java . io . * ; public class GFG { static int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( maxLCM ( n ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int cntWays ( int n ) { if ( n % 2 == 1 ) return 0 ; else return ( n - 2 ) / 4 ; } public static void main ( String [ ] args ) { int n = 18 ; System . out . println ( cntWays ( n ) ) ; } }
import java . io . * ; public class GFG { static void find_composite_nos ( int n ) { System . out . print ( 9 * n + " ▁ " + 8 * n ) ; } public static void main ( String [ ] args ) { int n = 4 ; find_composite_nos ( n ) ; } }
import java . io . * ; public class GFG { static int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return ( n == 1 ) ? 1 : 6 ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( findThirdDigit ( n ) ) ; } }
import java . io . * ; public class GFG { static int countMaxIntersect ( int n ) { return n * ( n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countMaxIntersect ( n ) ) ; } }
import java . io . * ; public class GFG { static int sum ( int n ) { if ( n == 1 ) return 2 ; else return n * ( n + 1 ) + sum ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( sum ( n ) ) ; } }
import java . io . * ; public class GFG { static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; } public static void main ( String [ ] args ) { int n = 48 ; System . out . println ( highestPowerOf2 ( n ) ) ; } }
import java . io . * ; public class GFG { static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntersections ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; String result = " " ; char c = ' a ' ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) >= c ) { c = s . charAt ( i ) ; } } if ( c != ' z ' ) { result = ( char ) ( c + 97 ) ; } System . out . println ( result ) ; } }
import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; scanner . nextLine ( ) ; String [ ] array = scanner . nextLine ( ) . split ( " ▁ " ) ; int [ ] intArray = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { intArray [ i ] = Integer . parseInt ( array [ i ] ) ; } int smallest = Arrays . stream ( intArray ) . min ( ) . getAsInt ( ) ; Arrays . sort ( intArray ) ; int i = 1 ; boolean t_or_f = true ; while ( i < n ) { if ( intArray [ i ] / smallest != intArray [ i ] / smallest ) { t_or_f = false ; } i ++ ; } if ( t_or_f == true ) { System . out . println ( smallest ) ; } else { System . out . println ( - 1 ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int a = Integer . parseInt ( br . readLine ( ) ) ; if ( a < 1200 ) { System . out . println ( " ABC " ) ; } else { System . out . println ( " ARC " ) ; } } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int size = 0 ; boolean first = true ; while ( in . hasNext ( ) ) { char [ ] str = in . next ( ) . toCharArray ( ) ; if ( str [ 0 ] == '0' ) { size ++ ; } else if ( str [ 0 ] == '1' ) { size -- ; } else { first = false ; } } for ( int i = size - 1 ; i >= 0 ; i -- ) { if ( first ) { out . print ( str [ i ] ) ; } else { out . print ( " ▁ " + str [ i ] ) ; } } out . flush ( ) ; } }
import java . io . * ; public class GFG { static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } public static void main ( String [ ] args ) { int x = 12 , y = 15 , z = 5 ; System . out . println ( " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ " + smallest ( x , y , z ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int D = sc . nextInt ( ) ; int E = sc . nextInt ( ) ; int F = sc . nextInt ( ) ; int sum = A + B + C + D + E + F + D + E + F + D + F + E + B + F + D + E + B + F + A ; System . out . println ( sum > 1000 ? 1 : 0 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; double ans = 0 ; double sum = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { sum += 2 * ( i - 1 ) * ( i - 1 ) * ( i - 1 ) ; ans += 2 * r * i ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int countCubes ( int a , int b ) { return ( int ) ( Math . floor ( Math . cbrt ( a ) ) - Math . ceil ( Math . cbrt ( a ) ) + 1 ) ; } public static void main ( String [ ] args ) { int a = 7 , b = 28 ; System . out . println ( " Count ▁ of ▁ cubes ▁ is ▁ " + countCubes ( a , b ) ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; int INF = 1 << 28 ; double EPS = 1e-12 ; int d , n ; int [ ] [ ] a ; void run ( ) { for ( ; ; ) { d = sc . nextInt ( ) ; n = sc . nextInt ( ) ; if ( ( d | n ) == 0 ) { break ; } a = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { a [ i ] [ j ] = sc . nextInt ( ) ; } } solve ( ) ; } } void solve ( ) { int [ ] [ ] b = new int [ n ] [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { b [ i ] [ j ] = sc . nextInt ( ) ; } } int ans = - 1 ; for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { if ( b [ i ] [ j ] >= d && b [ i ] [ j ] <= d ) { ans = i + 1 ; break ; } } } if ( ans == - 1 ) { println ( " NA " ) ; } else { println ( ans ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int triangle = 0 ; for ( int i = 1 ; ; i ++ ) { triangle += i ; if ( numDivisors ( triangle ) > 500 ) return Integer . toString ( triangle ) ; } } private static int numDivisors ( int n ) { int end = Library . sqrt ( n ) ; int result = 0 ; for ( int i = 1 ; i <= end ; i ++ ) { if ( n % i == 0 ) result += 2 ; } if ( end * end == n ) result -- ; return result ; } }
import java . io . * ; public class GFG { static int findDelta ( int a , int b , int c , int d ) { return ( b * c - a * d ) / ( d - c ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 9 , c = 3 , d = 5 ; System . out . println ( " \u0394 X ▁ = ▁ " + findDelta ( a , b , c , d ) ) ; } }
import java . util . * ; public class GFG { static void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { for ( int i = 0 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static void findPrimePair ( int n ) { boolean [ ] isPrime = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) if ( isPrime [ i ] && isPrime [ n - i ] ) { System . out . println ( i + " ▁ " + ( n - i ) ) ; return ; } } public static void main ( String [ ] args ) { int n = 74 ; findPrimePair ( n ) ; } }
import java . io . * ; public class GFG { static int replaceDigit ( int x , int d1 , int d2 ) { int result = 0 ; int multiply = 1 ; while ( x % 10 > 0 ) { int remainder = x % 10 ; if ( remainder == d1 ) result = ( result + d2 * multiply ) ; else result = ( result + remainder * multiply ) ; multiply *= 10 ; x /= 10 ; } return result ; } public static void main ( String [ ] args ) { int x = 645 ; int d1 = 6 ; int d2 = 5 ; System . out . println ( replaceDigit ( x , d1 , d2 ) ) ; } }
import java . io . * ; public class GFG { static void printPattern ( int i , int j , int n ) { if ( j >= n ) return 0 ; if ( i >= n ) return 1 ; if ( j == i || j == n - 1 - i ) { if ( i == n - 1 - j ) System . out . print ( " / " ) ; else System . out . print ( " \\ " ) ; } else { System . out . print ( " * " ) ; } if ( printPattern ( i , j + 1 , n ) == 1 ) return 1 ; System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; } public static void main ( String [ ] args ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; } }
import java . io . * ; public class GFG { static int getPairsCount ( int arr [ ] , int n , int sum ) { int m [ ] = new int [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twice_count += m [ sum - arr [ i ] ] ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 , - 1 , 5 } ; int n = arr . length ; int sum = 6 ; System . out . println ( " Count ▁ of ▁ pairs ▁ is ▁ " + getPairsCount ( arr , n , sum ) ) ; } }
import java . io . * ; public class GFG { static int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . println ( Count_subarray ( arr , n ) ) ; } }
import java . util . Scanner ; public class B1618 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int N = in . nextInt ( ) ; int X = in . nextInt ( ) ; int A = in . nextInt ( ) ; int B = in . nextInt ( ) ; int answer = X + ( Math . abs ( A - B ) ) ; if ( answer >= N - 1 ) { System . out . println ( N - 1 ) ; } else { System . out . println ( answer ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = sc . nextInt ( ) ; } Arrays . sort ( s ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += s [ i ] ; if ( sum % 10 != 0 ) { System . out . println ( sum ) ; return ; } } for ( int i = 0 ; i < n ; i ++ ) { sum += s [ i ] ; if ( i == n - 1 ) break ; } System . out . println ( sum ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int count = 0 ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == i + k && arr [ j ] == i + k ) { count ++ ; } else { count = 0 ; } } ans = Math . min ( ans , count ) ; } System . out . println ( ans ) ; } } }
import java . util . * ; public class GFG { static int findRepeatingNumber ( int arr [ ] , int n ) { int sq = ( int ) Math . sqrt ( n ) ; int [ ] count = new int [ n / sq + 1 ] ; for ( int i = 0 ; i <= n / sq ; i ++ ) count [ ( arr [ i ] - 1 ) / sq ] ++ ; int selected_block = 0 ; for ( int i = 0 ; i <= count . length - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( selected_block + 1 ) * sq ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; if ( m . get ( arr [ i ] ) > 1 ) return arr [ i ] ; } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 3 , 5 , 4 } ; int n = 5 ; System . out . println ( " One ▁ of ▁ the ▁ numbers ▁ repeated ▁ in ▁ the ▁ array ▁ is : ▁ " + findRepeatingNumber ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int maxPrimeFactors ( int n ) { int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) maxPrime = n ; return maxPrime ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( maxPrimeFactors ( n ) ) ; n = 25698751364526 ; System . out . println ( maxPrimeFactors ( n ) ) ; } }
import java . util . Scanner ; import java . util . ArrayList ; import java . util . List ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { l . add ( scanner . nextInt ( ) ) ; } int count = 0 ; for ( int num : l ) { count += num % 2 ; } System . out . println ( Math . min ( count , n - count ) ) ; } scanner . close ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int n = s . length ( ) ; int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { zero ++ ; } else { one ++ ; } } System . out . println ( Math . min ( zero , one ) * 2 ) ; } }
import java . io . * ; public class GFG { static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k && i * i + j * j == k * k ) { System . out . println ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } System . out . println ( " No ▁ Triplet " ) ; } public static void main ( String [ ] args ) { int n = 12 ; pythagoreanTriplet ( n ) ; } }
import java . io . * ; public class GFG { static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; } public static void main ( String [ ] args ) { int a = 33 , b = - 24 ; System . out . println ( countDigits ( a , b ) ) ; } }
public class GFG { static int indexOfFirstOne ( int arr [ ] , int low , int high ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == 1 && ( mid == 0 || arr [ mid - 1 ] == 0 ) ) break ; else if ( arr [ mid ] == 1 ) high = mid - 1 ; else low = mid + 1 ; } return mid ; } static int posOfFirstOne ( int arr [ ] ) { int l = 0 , h = 1 ; while ( arr [ h ] == 0 ) { l = h ; h = 2 * h ; } return indexOfFirstOne ( arr , l , h ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 1 , 1 , 1 , 1 , 1 } ; System . out . println ( " Index ▁ = ▁ " + posOfFirstOne ( arr ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int ans = 0 ; if ( n % 3 == 0 ) ans = n / 3 * 2 ; else if ( n % 3 == 1 ) ans = n / 3 * 2 + 1 ; else ans = n / 3 * 2 + 2 ; System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { double n = in . nextDouble ( ) ; if ( n == 0 ) return false ; double min = n * 16 ; double max = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { int sum = 0 ; while ( true ) { sum += ( int ) ( ( n - i ) * Math . pow ( 2 , i ) ) ; } if ( sum > max ) { out . println ( " NA " ) ; return true ; } n -= min ; } out . println ( ) ; return false ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . io . * ; public class GFG { static int digSum ( int n ) { int sum = 0 ; int rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum = sum + rem ; n = n / 10 ; } return sum ; } static int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( i + digSum ( i ) == n ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 43 ; System . out . println ( " x ▁ = ▁ " + findX ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { p [ i ] = sc . nextInt ( ) ; } int max = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( p [ i ] > max ) { max = p [ i ] ; } } System . out . println ( n - max + 1 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { a = a - i ; System . out . println ( a ) ; } } }
import java . util . * ; public class GFG { static void performQueries ( int [ ] A , int [ ] q ) { int n = A . length ; int [ ] pref_xor = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] ; for ( int i = 0 ; i < q . length ; i ++ ) { int L = i , R = i , L1 = L ; int R1 = R ; if ( L > R ) { L = R ; R = L ; } if ( L != R && pref_xor [ R ] == pref_xor [ L1 ] ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int [ ] Arr = { 1 , 1 , 2 , 2 , 1 } ; int [ ] q = { { 1 , 5 } , { 1 , 4 } , { 3 , 4 } } ; performQueries ( Arr , q ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == count ) { count ++ ; } } System . out . println ( n - count + 1 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; double ro = sc . nextDouble ( ) ; double p = sc . nextDouble ( ) ; double q = sc . nextDouble ( ) ; double pi = sc . nextDouble ( ) ; double a = sc . nextDouble ( ) ; double b = sc . nextDouble ( ) ; double x = Math . sqrt ( ro * ro ) ; double y = Math . sqrt ( p * p / q ) ; double ans = Math . sqrt ( x * y * x ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { public static void main ( String [ ] args ) { int num = 3 ; int lterm = 1 ; int rterm = num * num + 1 ; for ( int i = num ; i >= 0 ; i -- ) { for ( int space = num ; space > i ; space -- ) { System . out . print ( " ▁ " ) ; } for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( lterm + " * " ) ; lterm ++ ; } for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( rterm + " * " ) ; rterm ++ ; } rterm = rterm - ( i - 1 ) * 2 - 1 ; System . out . println ( ) ; } } }
import java . util . * ; public class GFG { static void findPerm ( int n , int differences [ ] ) { Vector < Integer > ans = new Vector < Integer > ( ) ; ans . add ( 0 ) ; int x = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = differences [ i ] ; x = x + diff ; ans . add ( x ) ; } Collections . sort ( ans ) ; int flag = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { int res = ans . get ( i ) - ans . get ( i - 1 ) ; if ( res != 1 ) { flag = 0 ; } } if ( flag == - 1 ) { System . out . println ( " - 1" ) ; return ; } else { Map < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; int j = 1 ; for ( int x : ans ) { mpp . put ( x , j ) ; j ++ ; } for ( int x : anss ) { value_at_index . add ( mpp . get ( x ) ) ; } for ( int x : value_at_index ) { System . out . print ( x + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int differences [ ] = { 2 , - 3 , 2 } ; int n = differences . length + 1 ; findPerm ( n , differences ) ; } }
import java . io . * ; public class GFG { static int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } static void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( countPrimeFactors ( num ) == k ) { System . out . print ( num + " ▁ " ) ; System . out . print ( " ▁ " ) ; } num ++ ; } return ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( " First ▁ " + n + " ▁ " + k + " - almost ▁ prime ▁ numbers : " ) ; printKAlmostPrimes ( k , n ) ; } }
import java . io . * ; public class GFG { static int solve ( int N , int K ) { int combo [ ] = new int [ N + 1 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) combo [ j ] += combo [ j - i ] ; } } return combo [ N ] ; } public static void main ( String [ ] args ) { int N = 29 , K = 5 ; System . out . println ( solve ( N , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; while ( true ) { String X = input . nextLine ( ) ; if ( X . equals ( "0" ) ) break ; String r = " " ; boolean minus = false ; if ( X . charAt ( 0 ) == ' - ' ) { minus = true ; X = X . substring ( 1 ) ; } int kuri = 0 ; int idx = X . length ( ) - 1 ; while ( idx >= 0 ) { int a = Integer . parseInt ( String . valueOf ( X . charAt ( idx ) ) ) ; if ( minus ) { r = Integer . toString ( ( 10 - a - kuri ) % 10 ) + r ; kuri = ( kuri + a == 0 ) ? 0 : 1 ; } else { r = Integer . toString ( ( kuri + a ) % 10 ) + r ; kuri = ( kuri + a ) / 10 ; } minus = ! minus ; if ( idx == 0 && kuri > 0 ) { X = "0" + X ; } else { idx -= 1 ; } } r = Integer . toString ( kuri ) + r ; System . out . println ( Integer . parseInt ( r ) ) ; } } }
import java . io . * ; public class GFG { static double normal ( double m , double n ) { double N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; } public static void main ( String [ ] args ) { double m = - 5 , n = 3 ; System . out . println ( normal ( m , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; double l = 1.0 ; double [ ] v = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = Math . sqrt ( ( double ) i / n ) * ( double ) h ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( v [ i ] + " ▁ " ) ; } } }
import java . io . * ; public class GFG { static int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; } public static void main ( String [ ] args ) { int i = 65 ; System . out . println ( countBits ( i ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int h , w , a , b ; h = scanner . nextInt ( ) ; w = scanner . nextInt ( ) ; a = scanner . nextInt ( ) ; b = scanner . nextInt ( ) ; System . out . println ( h * w - ( a * b * ( ( h / a ) * ( w / b ) ) ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] t = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { t [ i ] = sc . nextInt ( ) ; } Arrays . sort ( t ) ; int max = t [ n - 1 ] ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i ; while ( j <= max ) { ans += t [ j ] - t [ j ] ; j ++ ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int LongestSubarray ( int arr [ ] , int n , int k ) { int [ ] arr2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr2 [ i ] = arr [ i ] % k ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current_length = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr2 [ j ] == arr2 [ i ] ) current_length ++ ; else break ; } max_length = Math . max ( max_length , current_length ) ; i = j ; } return max_length ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 9 , 7 , 18 , 29 , 11 } ; int n = arr . length ; int k = 11 ; System . out . println ( LongestSubarray ( arr , n , k ) ) ; } }
import java . util . Scanner ; public class cf137B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; if ( n == 1 && m == 1 ) { System . out . println ( 1 ) ; } else if ( n == 1 && m == 1 ) { System . out . println ( m - 1 ) ; } else if ( m == 1 && n != 1 ) { System . out . println ( m - 1 ) ; } else if ( m == 1 && n != 1 ) { System . out . println ( m ) ; } else { System . out . println ( m + 1 ) ; } } }
import java . util . * ; public class GFG { static boolean isHeterogram ( String s , int n ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ▁ ' ) { if ( hash [ s . charAt ( i ) - ' a ' ] == 0 ) { hash [ s . charAt ( i ) - ' a ' ] = 1 ; } else return false ; } } return true ; } public static void main ( String [ ] args ) { String s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; int n = s . length ( ) ; if ( isHeterogram ( s , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = i + 1 ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( Library . isPermutation ( arr [ i ] ) ) { System . out . print ( i ) ; } else { System . out . print ( " " + arr [ i ] ) ; } } } public static List < Integer > run ( ) { List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] == i ) list . add ( i ) ; } return list ; } }
public class GFG { static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; else return false ; } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static final int N = 2001 ; static final int ON = 1000 ; static class point { int x , y ; public point ( int x , int y ) { this . x = x ; this . y = y ; } } static int countPoints ( int n , Point points [ ] ) { int [ ] minx = new int [ N ] ; int [ ] miny = new int [ N ] ; int [ ] maxx = new int [ N ] ; int [ ] maxy = new int [ N ] ; int x , y ; for ( int i = 0 ; i < n ; i ++ ) { points [ i ] . x += OFF ; points [ i ] . y += OFF ; x = points [ i ] . x ; y = points [ i ] . y ; minx [ y ] = Math . min ( minx [ y ] , x ) ; maxx [ y ] = Math . max ( maxx [ y ] , x ) ; minx [ y ] = Math . min ( minx [ y ] , y ) ; maxx [ y ] = Math . max ( maxx [ y ] , x ) ; miny [ x ] = Math . min ( miny [ x ] , y ) ; maxy [ x ] = Math . max ( maxy [ x ] , y ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = points [ i ] . x ; y = points [ i ] . y ; if ( x > minx [ y ] && x < maxx [ y ] ) { if ( y > miny [ x ] && y < maxy [ x ] ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { Point points [ ] = new Point [ N ] ; points [ 0 ] = new Point ( ) ; points [ 0 ] . x = new Point ( ) ; points [ 0 ] . y = new Point ( ) ; points [ 0 ] . x = new Point ( ) ; points [ 0 ] . y = new Point ( ) ; points [ 0 ] . y = new Point ( ) ; points [ n ] = points ; System . out . println ( countPoints ( n , points ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int ans = 0 ; while ( x <= y ) { x *= 2 ; ans ++ ; } System . out . println ( ans ) ; } }
public class GFG { static int sticks [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; static int countSticks ( String str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += sticks [ str . charAt ( i ) - '0' ] ; } return cnt ; } public static void main ( String [ ] args ) { String str = "56" ; int n = str . length ( ) ; System . out . println ( countSticks ( str , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i - 2 ] ) { count ++ ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { count ++ ; } } System . out . println ( count ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } } }
public class GFG { static void command ( int arr [ ] , int a , int b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; } static void process ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { arr [ k ] ^= arr [ k - 1 ] ; } } static void result ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { System . out . print ( arr [ k ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 5 , m = 3 ; int arr [ ] = new int [ n + 2 ] ; command ( arr , 1 , 5 ) ; command ( arr , 2 , 5 ) ; command ( arr , 3 , 5 ) ; process ( arr , n ) ; result ( arr , n ) ; } }
import java . util . * ; public class GFG { static int mostFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( mostFrequent ( arr , n ) ) ; } }
public class GFG { static int MAX = 26 ; static int maxLength ( String str , int len ) { int res = 0 ; int [ ] lastPos = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) lastPos [ i ] = - 1 ; for ( int i = 0 ; i < len ; i ++ ) { int C = str . charAt ( i ) - ' a ' ; if ( lastPos [ C ] != - 1 ) res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; lastPos [ C ] = i ; } return res ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; System . out . println ( maxLength ( str , len ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 1000000 ; static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) b [ arr [ i ] ] = 1 ; for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) k -- ; if ( k != 1 ) return j ; } return - 1 ; } public static void main ( String [ ] args ) { int k = 1 ; int arr [ ] = { 1 } ; int n = arr . length ; System . out . println ( ksmallest ( arr , n , k ) ) ; } }
import java . io . * ; public class GFG { static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; } public static void main ( String [ ] args ) { int N = 2795 ; if ( isDivisible ( N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; } public static void main ( String [ ] args ) { int n = 59173 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static boolean isDivisible ( long n ) { while ( n / 100 != 0 ) { long d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; } public static void main ( String [ ] args ) { long n = 1922 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; } public static void main ( String [ ] args ) { int N = 5041 ; if ( isDivisible ( N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int Odd_Sum ( int n ) { int total = ( n + 1 ) / 2 ; int odd = total * total ; return odd ; } static int Even_Sum ( int n ) { int total = n / 2 ; int even = total * ( total + 1 ) ; return even ; } static int sumLtoR ( int L , int R ) { int odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) ; int even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) ; return even_sum - odd_sum ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . println ( sumLtoR ( L , R ) ) ; } }
import java . io . * ; public class GFG { static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; } public static void main ( String [ ] args ) { int lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int Log2 ( int x ) { if ( x == 0 ) return 0 ; return ( int ) ( Math . log10 ( x ) / Math . log10 ( 2 ) ) ; } static boolean isPowerOfTwo ( int n ) { return ( ( Math . ceil ( Log2 ( n ) ) == Math . floor ( Log2 ( n ) ) ) ; } public static void main ( String [ ] args ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . math . BigInteger ; import java . util . HashSet ; import java . util . Set ; public final class p075 { public static void main ( String [ ] args ) { System . out . println ( new p075 ( ) . run ( ) ) ; } private static final int LIMIT = 50000000 ; public String run ( ) { Set < Integer > sums = new HashSet < > ( ) ; for ( int i = 2 ; i <= 5 ; i ++ ) { for ( int p : primes ) { int q = ( int ) Math . pow ( p , i ) ; if ( q > LIMIT ) break ; for ( int x : sums ) { if ( x + q <= LIMIT ) { sums . add ( x + q ) ; } } } } return Integer . toString ( sums . size ( ) ) ; } }
import java . util . HashMap ; public class Longest_length_subsequence { static int longLenSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i - 1 ] ) && len < um . get ( arr [ i - 1 ] ) ) len = um . get ( arr [ i - 1 ] ) ; if ( um . containsKey ( arr [ i + 1 ] ) && len < um . get ( arr [ i + 1 ] ) ) len = um . get ( arr [ i + 1 ] ) ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = arr . length ; System . out . println ( " Longest ▁ length ▁ subsequence ▁ = ▁ " + longLenSub ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a + b ) ; } } }
import java . io . * ; public class GFG { static int calculateSum ( int n ) { int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " Sum ▁ of ▁ all ▁ elements : ▁ " + calculateSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int calculateSum ( int n ) { int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) sum = sum + ( 1 << row ) ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " Sum ▁ of ▁ all ▁ elements : ▁ " + calculateSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 80 , 2 , 6 , 3 , 100 } ; int n = arr . length ; System . out . println ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { String s = sc . next ( ) ; if ( s . equals ( " # " ) ) break ; int [ ] [ ] dp = new int [ 5 ] [ s . length ( ) + 1 ] ; for ( int i = 1 ; i <= s . length ( ) ; i ++ ) { for ( int j = 1 ; j <= s . length ( ) ; j ++ ) { if ( s . charAt ( i - 1 ) == ' _ ' ) { dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] * 8 ) % 7 ; } else { dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] * 8 ) % 7 ; } } } int ans = 1 ; for ( int i = 1 ; i <= s . length ( ) ; i ++ ) { for ( int j = 1 ; j <= s . length ( ) ; j ++ ) { if ( s . charAt ( i - 1 ) == ' _ ' ) { ans = ( ans * dp [ i ] [ j ] ) % 7 ; } else { ans = ( ans * dp [ i ] [ j ] ) % 7 ; } } } System . out . println ( ans ) ; } } }
import java . io . * ; public class GFG { static int countPairs ( int n ) { int num = ( n / 2 ) + 1 ; int Max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == Max ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countPairs ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int n = s . length ( ) ; int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 1 ) arr [ i ] -- ; } int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; System . out . println ( arr [ y ] - arr [ x - 1 ] ) ; } } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; if ( ( n | m ) == 0 ) break ; int [ ] a = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) a [ i + 1 ] = sc . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == 1 ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] == 2 ) { a [ j + 1 ] = a [ j ] + 3 ; } } } } int min = a [ 0 ] , v = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( a [ i ] == 0 ) v = i ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == 1 ) min = min ( min , v + a [ i ] ) ; } if ( min <= m ) System . out . println ( min ) ; else System . out . println ( - 1 ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class GFG { static int MAX = 100000 ; static void prints ( int g1 [ ] , int a [ ] , int g2 [ ] , int b ) { for ( int i = 0 ; i < a ; i ++ ) System . out . print ( g1 [ i ] + " ▁ " ) ; System . out . print ( " and ▁ " ) ; for ( int i = 0 ; i < b ; i ++ ) System . out . print ( g2 [ i ] + " ▁ " ) ; System . out . println ( ) ; } static boolean checksum ( int g1 [ ] , int a [ ] , int g2 [ ] , int b ) { int x = 0 ; for ( int i = 0 ; i < a ; i ++ ) x += g1 [ i ] ; for ( int i = 0 ; i < b ; i ++ ) x -= g2 [ i ] ; return ( x == 0 ) ; } static void formgroups ( int arr [ ] , int x , int g1 [ ] , int a [ ] , int g2 [ ] , int b , int n ) { if ( x == n ) { if ( checksum ( g1 , a , g2 , b ) ) { printlns ( g1 , a , g2 , b ) ; } return ; } g1 [ a ] = arr [ x ] ; formgroups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) ; g2 [ b ] = arr [ x ] ; formgroups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 9 , 4 , 5 } ; int n = arr . length ; int g1 [ ] = new int [ MAX ] ; int g2 [ ] = new int [ MAX ] ; formgroups ( arr , 0 , g1 , 0 , g2 , 0 , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int ans = 0 ; int max = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i * a + j * b == n ) { ans = i ; max = j ; } } } if ( n % a == 0 ) { ans = n / a ; } else { for ( int i = 1 ; i <= n / a ; i ++ ) { for ( int j = 1 ; j <= n / b ; j ++ ) { if ( i * a + j * b == n ) { ans = Math . max ( ans , i + j + c ) ; } } } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int maxSubseq ( int [ ] vec , int n ) { int suffix = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( vec [ i ] == 1 ) { suffix ++ ; } vec [ i ] = suffix ; } int res = 0 , zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vec [ i ] == 0 ) zero ++ ; if ( vec [ i ] > 0 ) res = Math . max ( res , zero + vec [ i ] ) ; } return res ; } public static void main ( String [ ] args ) { int [ ] input = { 0 , 1 , 0 , 0 , 1 , 0 } ; int n = input . length ; System . out . println ( maxSubseq ( input , n ) ) ; } }
public class GFG { static int R = 4 ; static int C = 4 ; static int countPaths ( int maze [ ] [ ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } if ( maze [ R - 1 ] [ C - 1 ] > 0 ) return maze [ R - 1 ] [ C - 1 ] ; else return 0 ; } public static void main ( String [ ] args ) { int maze [ ] [ ] = { { 0 , 0 , 0 , 0 } , { 0 , - 1 , 0 , 0 } , { - 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; System . out . println ( countPaths ( maze ) ) ; } }
import java . io . * ; public class GFG { static void isPrime ( int N ) { boolean isPrime = true ; int arr [ ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) isPrime = false ; if ( N % 2 == 0 || N % 3 == 0 || N % 5 == 0 ) isPrime = false ; for ( int i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) { for ( int c = 0 ; c <= Math . sqrt ( N ) ; c ++ ) { if ( c > ( int ) Math . sqrt ( N ) ) break ; else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) System . out . println ( " Prime ▁ Number " ) ; else System . out . println ( " Not ▁ a ▁ Prime ▁ Number " ) ; } public static void main ( String [ ] args ) { int N = 121 ; isPrime ( N ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x1 = sc . nextInt ( ) ; int y1 = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) ; int y2 = sc . nextInt ( ) ; int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; System . out . println ( dx + " ▁ " + dy + " ▁ " + ( x1 + dx ) ) ; } }
public class GFG { static int max ( int x , int y ) { if ( x > y ) return x ; return y ; } static int lps ( String seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq . charAt ( i ) == seq . charAt ( j ) && i + 1 == j ) return 2 ; if ( seq . charAt ( i ) == seq . charAt ( j ) ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return Math . max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void main ( String [ ] args ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + lps ( seq , 0 , n - 1 ) ) ; } }
import java . io . * ; public class GFG { static int findLength ( String str , int n ) { int [ ] total = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) total [ i ] = total [ i - 1 ] + str . charAt ( i - 1 ) - '0' ; int ans = 0 ; for ( int l = 2 ; l <= n ; l ++ ) { for ( int i = 0 ; i <= n - l ; i ++ ) { int j = i + l - 1 ; if ( total [ i + ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + ( l / 2 ) ] ) ans = Math . max ( ans , l ) ; } } return ans ; } public static void main ( String [ ] args ) { String str = "123123" ; System . out . println ( " Length ▁ of ▁ the ▁ substring ▁ is ▁ " + findLength ( str , str . length ( ) ) ) ; } }
import java . io . * ; public class GFG { static void prints ( char a [ ] , int n , int ind ) { int i = ind ; while ( i < n + ind ) { System . out . print ( a [ ( i % n ) ] + " ▁ " ) ; i ++ ; } } public static void main ( String [ ] args ) { char a [ ] = { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; int n = a . length ; prints ( a , n , 3 ) ; } }
import java . util . * ; public class GFG { static void prints ( char a [ ] , int n , int ind ) { int b [ ] = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = b [ n + i ] = a [ i ] ; } for ( int i = ind ; i < n + ind ; i ++ ) System . out . print ( b [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { char a [ ] = { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; int n = a . length ; prints ( a , n , 3 ) ; } }
import java . util . Scanner ; public class BuyAShovel { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n , a , b , x ; n = scan . nextInt ( ) ; a = scan . nextInt ( ) ; b = scan . nextInt ( ) ; x = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char [ ] s = scan . next ( ) . toCharArray ( ) ; int sho = 0 , smo = 0 ; for ( int j = 0 ; j < s . length ; j ++ ) { if ( s [ j ] == ' * ' ) { sho ++ ; } else { smo ++ ; } } if ( smo == 0 || smo == 0 ) { System . out . println ( x ) ; return ; } if ( x == a ) { x = b ; } else if ( x == b ) { System . out . println ( b ) ; return ; } int y = Math . min ( a , Math . min ( x , b ) ) ; int z = Math . min ( a , Math . min ( y , b ) ) ; System . out . println ( z + smo ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] grid = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { grid [ i ] [ j ] = sc . nextInt ( ) ; } } boolean [ ] [ ] visited = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { dfs ( i , grid , visited , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( " . " ) ; } System . out . println ( ) ; } } static void dfs ( int index , int [ ] [ ] visited , int 1 ) { if ( index == grid . length ) { for ( int i = 1 ; i < n ; i ++ ) { if ( visited [ i ] ) continue ; dfs ( index + 1 , visited , - 1 ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int v1 = sc . nextInt ( ) ; int v2 = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int ans = 0 ; int i = 0 ; int j = 1 ; while ( i < t ) { ans += Math . min ( v1 + ( i * d ) , v2 + ( j * d ) ) ; j ++ ; i ++ ; } System . out . println ( ans ) ; } }
import java . util . * ; public class JavaApplication75 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > arrA = new ArrayList < > ( ) ; ArrayList < Integer > arrB = new ArrayList < > ( ) ; ArrayList < Integer > arrC = new ArrayList < > ( ) ; int num = sc . nextInt ( ) ; String s = sc . next ( ) ; for ( int i = 0 ; i < num ; i ++ ) { arrA . add ( sc . nextInt ( ) ) ; } for ( int i = 0 ; i < num ; i ++ ) { arrB . add ( sc . nextInt ( ) ) ; } int x = 0 ; int y = 0 ; for ( int i = 0 ; i < num ; i ++ ) { if ( arrA . get ( i ) < arrB . get ( i ) ) { x ++ ; } else if ( arrA . get ( i ) > arrB . get ( i ) ) { y ++ ; } } System . out . println ( x ) ; System . out . println ( y ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 100000 ] ; int cnt = 0 ; int ans = 0 ; for ( int i = 0 ; i < 100000 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 100000 ; i ++ ) { cnt += a [ i ] / 2 ; if ( cnt > a [ i + 1 ] ) { ans += 2 ; } else { ans += 1 ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( i == j ) System . out . print ( "1 ▁ " ) ; else System . out . print ( "0 ▁ " ) ; } System . out . println ( ) ; } } } }
import java . io . * ; public class GFG { static void bin ( int n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . print ( ( n & 1 ) ) ; } public static void main ( String [ ] args ) { bin ( 131 ) ; System . out . println ( ) ; bin ( 3 ) ; } }
public final class p036 { public static void main ( String [ ] args ) { System . out . println ( new p036 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int x = 0 ; x < 1000 ; x ++ ) { if ( x % 3 == 0 || x % 5 == 0 ) sum += x ; } return Integer . toString ( sum ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int [ ] a = new int [ 3 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' n ' ) a [ 0 ] ++ ; else if ( s . charAt ( i ) == ' z ' ) a [ 1 ] ++ ; } for ( int i = 0 ; i < a . length ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( 2 * b - a ) ; } }
import java . io . * ; public class GFG { static int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( Circular ( n - 1 ) ) ; } }
import java . io . * ; public class GFG { static int productDiagonals ( int arr [ ] [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * arr [ i ] [ i ] ; product = product * arr [ i ] [ n - i - 1 ] ; } if ( n % 2 == 1 ) { product = product / arr [ n / 2 ] [ n / 2 ] ; } return product ; } public static void main ( String [ ] args ) { int arr1 [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 7 , 4 , 2 } , { 2 , 2 , 2 , 1 } } ; System . out . println ( productDiagonals ( arr1 , 4 ) ) ; int arr2 [ ] [ ] = { { 2 , 1 , 2 , 1 , 2 } , { 1 , 2 , 1 , 2 , 1 } , { 2 , 1 , 2 , 1 , 2 } , { 1 , 2 , 1 , 2 , 1 } , { 2 , 1 , 2 , 1 , 2 } } ; System . out . println ( productDiagonals ( arr2 , 5 ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] == a [ i ] ) { System . out . print ( " * " ) ; } else { System . out . print ( " - " ) ; } } System . out . println ( ) ; } } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
public class GFG { static char getSecondMostFreq ( String str ) { int NO_OF_CHARS = 256 ; int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; int first = 0 , second = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; char res = getSecondMostFreq ( str ) ; if ( res != ' \ 0' ) System . out . println ( " Second ▁ most ▁ frequent ▁ char ▁ is ▁ " + res ) ; else System . out . println ( " No ▁ second ▁ most ▁ frequent ▁ character " ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = " " ; int [ ] conis = new int [ 400000 ] ; for ( int i = 0 ; i < 400000 ; i ++ ) { conis [ i ] = 0 ; } for ( int i = 0 ; i < 400000 ; i ++ ) { if ( i == 0 || i > 6000 ) { conis [ i ] = ( int ) Math . pow ( 2 , i ) * ( conis [ i - 1 ] + 1 ) / 6 ; } else if ( i == 1 || i == 2 || i == 3 ) { conis [ i ] = ( int ) Math . pow ( 2 , i - 1 ) * ( conis [ i - 3 ] + 1 ) / 6 ; } } while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { int n = Integer . parseInt ( line ) ; System . out . println ( conis [ n ] ) ; } } }
import java . util . Arrays ; public class GFG { static void mySort ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; Arrays . sort ( arr ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 } ; int n = arr . length ; mySort ( arr , n ) ; System . out . println ( " Modified ▁ Array ▁ : ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
public class GFG { static int minflip ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) flip ++ ; return ( flip <= p + q ) ? flip : - 1 ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 0 , 1 , 1 , 1 , 1 , 1 } ; int arr2 [ ] = { 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 } ; int arr3 [ ] = { 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 } ; int n = arr1 . length ; int p = 2 , q = 4 ; System . out . println ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) ; } }
import java . io . * ; public class GFG { static double sum ( int n ) { double i = 1 ; double s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " Sum ▁ is ▁ " + sum ( n ) ) ; } }
import java . util . Arrays ; public class BitonicGenerator { public static void bitonicGenerator ( int [ ] arr ) { int n = arr . length ; int [ ] evenArr = new int [ n / 2 ] ; int [ ] oddArr = new int [ n / 2 ] ; int evenIndex = 0 ; int oddIndex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { evenArr [ evenIndex ++ ] = arr [ i ] ; } else { oddArr [ oddIndex ++ ] = arr [ i ] ; } } Arrays . sort ( evenArr ) ; Arrays . sort ( oddArr ) ; reverse ( oddArr ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . length ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; } for ( int j = 0 ; j < oddArr . length ; j ++ ) { arr [ i ++ ] = oddArr [ j ] ; } } public static void reverse ( int [ ] arr ) { int left = 0 ; int right = arr . length - 1 ; while ( left < right ) { int temp = arr [ left ] ; arr [ left ] = arr [ right ] ; arr [ right ] = temp ; left ++ ; right -- ; } } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; bitonicGenerator ( arr ) ; for ( int i : arr ) { System . out . print ( i + " ▁ " ) ; } } }
class CountPairs { public static void main ( String [ ] args ) { int [ ] arr = { 1 , 4 , 2 , 4 , 3 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } static int countPairs ( int [ ] arr , int n ) { int count = 0 ; int right = 0 ; int left = 0 ; boolean [ ] visited = new boolean [ n ] ; while ( right < n ) { while ( right < n && visited [ arr [ right ] ] == false ) { count += ( right - left ) ; visited [ arr [ right ] ] = true ; right += 1 ; } while ( left < right && ( right != n && visited [ arr [ right ] ] == true ) ) { visited [ arr [ left ] ] = false ; left += 1 ; } } return count ; } }
public class Solution { public boolean isSubtree ( TreeNode root , TreeNode left , TreeNode right ) { return ( root == null ) || ( root . val != null && root . left . left != null && root . right != null ) ; } public String preorder ( TreeNode root , boolean isLeft ) { if ( root == null ) return ( isLeft ) ? " lnull " : " rnull " ; return " # " + root . val + " ▁ " + preorder ( root . left , true ) + " ▁ " + preorder ( root . right , false ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; TreeNode root = new TreeNode ( 3 ) ; root . left = new TreeNode ( 4 ) ; root . right = new TreeNode ( 5 ) ; root . left . left = new TreeNode ( 1 ) ; root . left . right = new TreeNode ( 2 ) ; TreeNode subRoot = new TreeNode ( 4 ) ; subRoot . left = new TreeNode ( 1 ) ; subRoot . right = new TreeNode ( 2 ) ; boolean out = sObj . isSubtree ( root , subRoot ) ; System . out . println ( out ) ; } }
import java . util . * ; public class GFG { static int MOD = 998244353 ; static int [ ] [ ] dp = new int [ M ] [ M ] ; static int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; int K = 0 ; System . out . println ( M * solve ( 2 , 0 , N , M , K ) ) ; } }
public final class p038 { public static void main ( String [ ] args ) { System . out . println ( new p038 ( ) . run ( ) ) ; } private static final int NUM_SPHERES = 21 ; public String run ( ) { int [ ] sphereradii = new int [ NUM_SPHERES ] ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) sphereradii [ i ] = ( i + 30 ) * 1000 ; int [ ] [ ] minlength = new int [ NUM_SPHERES ] [ 2 << NUM_SPHERES ] ; for ( int [ ] [ ] minlength : minlength ) Arrays . fill ( minlength , Integer . MAX_VALUE ) ; for ( int [ ] [ ] minlength : minlength ) Arrays . fill ( minlength , Integer . MAX_VALUE ) ; int minLength = Integer . MAX_VALUE ; for ( int i = 0 ; i < ( 1 << NUM_SPHERES ) ; i ++ ) { if ( ( sphereradii [ i ] & ( 1 << i ) ) == 0 ) throw new IllegalArgumentException ( ) ; int result ; int newSetofspheres = ( int ) sphereradii [ i ] ; for ( int j = 0 ; j < 2 << NUM_SPHERES ; j ++ ) { if ( ( sphereradii [ j ] & ( 1 << i ) ) == 0 ) continue ; double temp = ( double ) Math . sqrt ( ( sphereradii [ i ] + sphereradii [ currentsphereindex ] - 50000 ) * 200000 ) ; temp += findMinLength ( i , newSetofspheres ) ; result = Math . min ( temp , result ) ; } minlength [ currentsphereindex ] [ setofspheres ] = result ; } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) ans = Math . min ( ( minLength [ i ] [ 1 << NUM_SPHERES ] - 1 ) + sphereradii [ i ] ) ; return Integer . toString ( ans ) ; } }
import java . util . * ; import java . io . * ; public class codeHundredSixtyTwo { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int o = 0 ; o < t ; o ++ ) { double a = input . nextDouble ( ) ; double b = input . nextDouble ( ) ; double c = input . nextDouble ( ) ; double d = input . nextDouble ( ) ; double sqrt = Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ; if ( sqrt == ( sqrt * sqrt ) && ( c * c == sqrt ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
import java . io . * ; public class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int l = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; System . out . println ( l / ( a + b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( arr [ n - 1 ] - arr [ n - 2 ] ) ; } } }
import java . util . Scanner ; import java . util . HashMap ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] t = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { t [ i ] = input . nextInt ( ) ; } int ans = 0 ; HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( - t [ i ] ) ) { ans += freq . get ( - t [ i ] ) ; } if ( freq . containsKey ( t [ i ] ) ) { freq . put ( t [ i ] , freq . get ( t [ i ] ) + 1 ) ; } else { freq . put ( t [ i ] , 1 ) ; } } System . out . println ( ans ) ; } }
import java . util . Scanner ; import java . util . ArrayList ; import java . util . HashSet ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int pya = Integer . parseInt ( scanner . nextLine ( ) ) ; ArrayList < String > arre = new ArrayList < > ( ) ; while ( pya > 0 ) { pya -- ; arre . add ( scanner . nextLine ( ) . toLowerCase ( ) ) ; } String oString = scanner . nextLine ( ) ; String lowString = oString . toLowerCase ( ) ; String letter1 = String . valueOf ( scanner . nextLine ( ) . toLowerCase ( ) . charAt ( 0 ) ) ; String letter2 = ( letter1 . toLowerCase ( ) . equals ( " a " ) ) ? " b " : " a " ; int [ ] valid = new int [ oString . length ( ) ] ; HashSet < Integer > setcito = new HashSet < > ( ) ; for ( String x : arre ) { if ( lowString . indexOf ( x ) >= 0 ) { int wat = 0 ; while ( true ) { int index = lowString . indexOf ( x , wat ) ; if ( index < 0 ) { break ; } for ( int i = index ; i < index + x . length ( ) ; i ++ ) { setcito . add ( i ) ; } wat = index + 1 ; } } } char [ ] oStringArray = oString . toCharArray ( ) ; for ( int i : setcito ) { String letter = ( lowString . charAt ( i ) != letter1 . charAt ( 0 ) ) ? letter1 : letter2 ; oStringArray [ i ] = ( Character . isLowerCase ( oStringArray [ i ] ) ) ? letter . charAt ( 0 ) : Character . toUpperCase ( letter . charAt ( 0 ) ) ; } for ( char x : oStringArray ) { System . out . print ( x ) ; } System . out . println ( ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) throws java . lang . Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st ; int big_prime = 1000000007 ; int N = Integer . parseInt ( br . readLine ( ) ) ; char [ ] S = br . readLine ( ) . toCharArray ( ) ; int [ ] Wn = new int [ N ] ; int [ ] En = new int [ N ] ; int Wc = 0 ; int Ec = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' W ' ) { Wc += 1 ; } else { Ec += 1 ; } Wn [ i ] = Wc ; En [ i ] = Ec ; } int ans = ( int ) Math . pow ( 10 , 10 ) ; int [ ] new_Wn = new int [ N + 1 ] ; int [ ] new_En = new int [ N + 1 ] ; new_Wn [ 0 ] = 0 ; new_En [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { new_Wn [ i ] = Wn [ i - 1 ] ; new_En [ i ] = En [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { ans = Math . min ( new_Wn [ i ] + new_En [ N ] - new_En [ i + 1 ] , ans ) ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int oddCount = 0 ; int evenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) evenCount ++ ; else oddCount ++ ; } if ( arr . length > 1 ) { System . out . println ( Math . min ( evenCount , oddCount ) ) ; } else { System . out . println ( Math . min ( evenCount , oddCount ) ) ; } } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static boolean solve ( ) { int n = in . nextInt ( ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! solve ( i ) ) cnt ++ ; } out . println ( cnt ) ; return true ; } static boolean solve ( int p ) { if ( p == 1 ) return false ; for ( int i = 2 ; i * i <= p ; i ++ ) if ( p % i == 0 ) return false ; return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int sum = 0 ; int even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( arr [ i ] == 1 ) { sum += arr [ i ] ; if ( i != n - 1 ) { if ( sum % 2 == 0 ) { System . out . println ( 1 ) ; } else { System . out . println ( 2 ) ; } } else { even ++ ; } } else { sum += arr [ i ] ; if ( i != n - 1 ) { System . out . println ( 2 ) ; } else { System . out . println ( 1 ) ; } } } } }
import java . io . * ; public class GFG { static boolean powerOfTwo ( int n ) { return ( n & n - 1 ) == 0 ; } static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; return powerOfTwo ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X ) ; Arrays . sort ( Y ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) { total += X [ i ++ ] ; } res += total * vert ; total = 0 ; while ( j < n ) { total += Y [ j ++ ] ; j ++ ; } res += total * hzntl ; return res ; } public static void main ( String [ ] args ) { int m = 6 , n = 4 ; int X [ ] = { 2 , 1 , 3 , 1 , 4 } ; int Y [ ] = { 4 , 1 , 2 } ; System . out . println ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int countPairs ( int G , int L ) { int count = 0 ; int p = G * L ; for ( int a = 1 ; a <= L ; a ++ ) { if ( ! ( p % a ) && gcd ( a , p / a ) == G ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int G = 2 , L = 12 ; System . out . print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + G + " ▁ LCM ▁ " + L + " ▁ = ▁ " + countPairs ( G , L ) ) ; } }
public class GFG { static int multiply ( int a [ ] [ ] , int b [ ] [ ] ) { int mul [ ] [ ] = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) { mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { a [ i ] [ j ] = mul [ i ] [ j ] ; } } return a ; } static int power ( int F [ ] [ ] , int n ) { int M [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , n / 2 ) ; F = multiply ( F , F ) ; if ( n % 2 != 0 ) { F = multiply ( F , M ) ; } return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; } static int findNthTerm ( int n ) { int F [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; return power ( F , n - 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " F ( 5 ) ▁ is ▁ " + findNthTerm ( n ) ) ; } }
import java . io . * ; public class GFG { static void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . println ( a + " ▁ " + b + " ▁ " + c ) ; } public static void main ( String [ ] args ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; } }
public class Solution { public boolean checkPossibility ( int [ ] nums ) { int broken_num = 0 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] > nums [ i + 1 ] ) { broken_num ++ ; if ( broken_num >= 2 ) return false ; if ( i - 1 < 0 || nums [ i - 1 ] <= nums [ i + 1 ] ) nums [ i ] = nums [ i + 1 ] ; else nums [ i + 1 ] = nums [ i ] ; } } return true ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 4 , 2 , 3 } ; boolean out = sObj . checkPossibility ( nums ) ; System . out . println ( out ) ; } }
import java . io . * ; public class GFG { static boolean check ( int mid , int array [ ] , int n , int K ) { int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] > mid ) return false ; sum += array [ i ] ; if ( sum > mid ) count ++ ; sum = array [ i ] ; } count ++ ; if ( count <= K ) return true ; return false ; } static int solve ( int array [ ] , int n , int K ) { int start = 1 , end = 0 ; for ( int i = 0 ; i < n ; i ++ ) end += array [ i ] ; int answer = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , array , n , K ) ) { answer = mid ; end = mid - 1 ; } else start = mid + 1 ; } return answer ; } public static void main ( String [ ] args ) { int array [ ] = { 1 , 2 , 3 , 4 } ; int n = array . length ; int K = 3 ; System . out . println ( solve ( array , n , K ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int m = sc . nextInt ( ) , n = sc . nextInt ( ) ; if ( ( m | n ) == 0 ) break ; int [ ] [ ] dp = new int [ 1 << m ] [ n ] ; for ( int i = 0 ; i < ( 1 << m ) ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = INF ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i < ( 1 << m ) ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int [ ] a = new int [ n ] ; for ( int k = 0 ; k < n ; k ++ ) a [ k ] |= 1 << i ; for ( int j = 0 ; j < n ; j ++ ) if ( a [ j ] & ( 1 << k ) <= 1 ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i | 1 ] [ j ] ) + 1 ; for ( int j = 0 ; j < m ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) if ( ( a [ j ] & ( 1 << k ) ) > 0 ; dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i | 1 << k ] [ j ] ) ; } System . out . println ( dp [ 0 ] [ 0 ] ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Fast f = new Fast ( System . in ) ; int t = f . nextInt ( ) ; while ( t -- != 0 ) { int a = f . nextInt ( ) , b = f . nextInt ( ) , ans = 2 * a * b ; System . out . println ( Math . sqrt ( ans ) ) ; } System . out . flush ( ) ; System . out . close ( ) ; } } class Fast { StringTokenizer st ; BufferedReader br ; public Fast ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Fast ( String file ) throws IOException { br = new BufferedReader ( new FileReader ( file ) ) ; } public Fast ( FileReader r ) { br = new BufferedReader ( r ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public String readAllLines ( BufferedReader reader ) throws IOException { StringBuilder content = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { content . append ( line ) ; content . append ( System . lineSeparator ( ) ) ; } return content . toString ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public int [ ] nextIntArray ( int n ) throws IOException { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } } class Pair { int d ; int k ; public Pair ( int d , int k ) { this . d = d ; this . k = k ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } int minus = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < b [ i ] && minus < b [ i ] ) { minus = i ; } } if ( a [ n - 1 ] == 0 || b [ n - 1 ] == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . io . * ; public class GFG { static String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' ) return ( " Even " ) ; else return ( " Odd " ) ; } public static void main ( String [ ] args ) { String N = "735" ; System . out . println ( even_or_odd ( N ) ) ; } }
import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; List < List < Integer > > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = scan . nextInt ( ) ; String b = scan . next ( ) ; switch ( a ) { case 0 : list . get ( a ) . add ( scan . nextInt ( ) ) ; break ; case 1 : System . out . print ( list . get ( a ) . get ( b ) ) ; break ; case 2 : list . remove ( b ) ; break ; } } } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even ++ ; } else { odd ++ ; } } if ( even == 1 ) { System . out . println ( even ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { System . out . println ( odd ) ; } } } } }
public class GFG { static int solve ( String X , String Y , int N , int K ) { int i , j ; int sol = 0 ; int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 0 ; for ( i = 1 ; i <= N ; i ++ ) { count [ i ] = ( count [ i - 1 ] + Math . abs ( X . charAt ( i - 1 ) - Y . charAt ( i - 1 ) ) ) ; } j = 0 ; for ( i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) j ++ ; sol = Math . max ( sol , i - j ) ; } return sol ; } public static void main ( String [ ] args ) { int N = 4 ; String X = " abcd " ; String Y = " bcde " ; int K = 3 ; System . out . println ( solve ( X , Y , N , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int a = sc . nextInt ( ) ; int now = a ; while ( now > 1 ) { n = n / now ; now = now % now ; } } System . out . println ( n == 1 ? " Yes " : " No " ) ; } }
import java . io . * ; public class GFG { static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; } public static void main ( String [ ] args ) { int n = 15 ; if ( isPrime ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static boolean isPrime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; } public static void main ( String [ ] args ) { int n = 27 ; System . out . println ( minimumSum ( n ) ) ; } }
public class GFG { static boolean isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } static int minimumCost ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( minimumCost ( n ) ) ; } }
import java . io . * ; public class GFG { static int snoob ( int x ) { int next = 0 ; if ( x != 0 ) { int rightOne = x & - ( x ) ; int nextHigherOneBit = x + rightOne ; int rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( int ) ( rightOnesPattern / rightOne ) ; rightOnesPattern = ( int ) ( rightOnesPattern ) >> 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; } public static void main ( String [ ] args ) { int x = 156 ; System . out . println ( " Next ▁ higher ▁ number ▁ with ▁ same ▁ number ▁ of ▁ set ▁ bits ▁ is ▁ " + snoob ( x ) ) ; } }
import java . io . * ; public class GFG { static int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( properDivisorSum ( n ) ) ; n = 5 ; System . out . println ( properDivisorSum ( n ) ) ; } }
public class GFG { static int getMinLength ( int arr [ ] , int n ) { int count = 0 ; int result = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count ++ ; else { if ( count != 0 ) result = Math . min ( result , count ) ; count = 0 ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( getMinLength ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int getLevenstein ( String inpt ) { String revInput = inpt . reverse ( ) ; int n = inpt . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( inpt . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = Integer . MAX_VALUE ; for ( int i = n ; i >= 0 ; i -- ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; } public static void main ( String [ ] args ) { String inpt = " myfirstgeekarticle " ; System . out . println ( getLevenstein ( inpt ) ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } private static final int LIMIT = 12000 ; public String run ( ) { long sum = 0 ; Set < Integer > minSumProduct = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= LIMIT * 2 ; i ++ ) { if ( remain == 1 ) { if ( sum > i ) throw new AssertionError ( ) ; terms += n - sum ; if ( terms <= LIMIT && ( minSumProduct . contains ( terms ) || minSumProduct . contains ( terms ) ) ) minSumProduct . add ( terms , n ) ; } else { for ( int i = 2 ; i <= maxFactor ; i ++ ) { if ( remain % i == 0 ) { int factor = i ; factorize ( n , remain / factor , Math . min ( factor , maxFactor ) , sum + factor , terms + 1 ) ; } } } } long sum = sum ; for ( int x : minSumProduct ) sum += x ; return Long . toString ( sum ) ; } private static final int LIMIT = 12000 ; private Set < Integer > minSumProduct = new HashSet < Integer > ( ) ; private static void factorize ( int n , int remain , int maxFactor , int sum , int terms ) { if ( remain == 1 ) { if ( sum > n ) throw new AssertionError ( ) ; terms += n - sum ; if ( terms <= LIMIT && ( minSumProduct . contains ( terms ) == null || n < minSumProduct . get ( terms ) ) ) minSumProduct . add ( terms , n ) ; } else { for ( int i = 2 ; i <= maxFactor ; i ++ ) { if ( remain % i == 0 ) { int factor = i ; factorize ( n , remain / factor , Math . min ( factor , maxFactor ) , sum + factor , terms + 1 ) ; } } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; long MOD = 1000000007 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = b [ i ] + a [ i ] ; } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = ( ans + ( ( ( long ) a [ i ] * b [ n - i - 1 ] ) % MOD ) * a [ i ] ) % MOD ; } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static class Queue { int data ; Queue ( int data ) { this . data = data ; } } static Queue <= Queue ; public static void reverseQueue ( Queue < Integer > q ) { if ( q . isEmpty ( ) ) return ; int data = q . front ( ) ; q . remove ( ) ; reverseQueue ( q ) ; q . add ( data ) ; } public static void add ( int item ) { q . add ( item ) ; } public static void printQueue ( Queue < Integer > q ) { for ( int i = q . peek ( ) ; i > 0 ; i -- ) { System . out . print ( i + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { Queue q = new Queue ( ) ; q . add ( 56 ) ; q . add ( 27 ) ; q . add ( 30 ) ; q . add ( 45 ) ; q . add ( 85 ) ; q . add ( 92 ) ; q . add ( 58 ) ; q . add ( 80 ) ; q . add ( 90 ) ; q . add ( 100 ) ; reverseQueue ( q ) ; q . printQueue ( ) ; } }
import java . util . * ; public class GFG { static int MAX = 1000000 ; static boolean prime [ ] = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { c ++ ; if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int findDiff ( int arr [ ] , int n ) { int min = MAX + 2 ; int max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == true ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } } return ( max == - 1 ) ? - 1 : ( max - min ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 4 ; int arr [ ] = { 1 , 2 , 3 , 5 } ; int res = findDiff ( arr , n ) ; if ( res == - 1 ) System . out . println ( " No ▁ prime ▁ numbers " ) ; else System . out . println ( " Difference ▁ is ▁ " + res ) ; } }
import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int n , m ; static int [ ] [ ] cost ; static boolean [ ] used ; public static void main ( String [ ] args ) { while ( read ( ) ) solve ( ) ; } static boolean read ( ) { n = sc . nextInt ( ) ; if ( n == 0 ) return false ; m = sc . nextInt ( ) ; cost = new int [ n ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { String [ ] str = sc . next ( ) . split ( " , " ) ; cost [ i ] [ 0 ] = Integer . parseInt ( str [ 0 ] ) ; cost [ i ] [ 1 ] = Integer . parseInt ( str [ 1 ] ) ; cost [ i ] [ 2 ] = Integer . parseInt ( str [ 2 ] ) ; } return true ; } static void solve ( ) { used = new boolean [ n ] ; Arrays . fill ( used , false ) ; cost [ 0 ] [ 0 ] = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ! used [ j ] && ( cost [ j ] [ i ] < cost [ i ] [ j ] ) ) { continue ; } used [ j ] = true ; cost [ j ] [ i ] = cost [ i ] [ j ] + cost [ j ] [ i ] ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! used [ i ] ) { ans += cost [ i ] [ n ] ; used [ i ] = false ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { ans = i * ( n / 2 ) + ans ; if ( n % 2 == 0 ) { ans = ( ans + 1 ) * ( n / 2 ) + ans ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int distinctSubstring ( String P , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean [ ] freq = new boolean [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; j ++ ) { int pos = P . charAt ( j ) - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P . charAt ( j ) ; S . add ( s ) ; } } return S . size ( ) ; } public static void main ( String [ ] args ) { String S = " abba " ; int N = S . length ( ) ; System . out . println ( distinctSubstring ( S , N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int count = 0 ; if ( ( n - k ) % ( k - 1 ) != 0 ) { count ++ ; } System . out . println ( count ) ; } }
import java . util . * ; public class GFG { static int minimumAdjacentDifference ( int a [ ] , int n , int k ) { int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i < 1 << n ; i ++ ) { int cnt = Integer . bitCount ( i ) ; if ( cnt == n - k ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) temp . add ( a [ j ] ) ; } int maxDiff = Integer . MIN_VALUE ; for ( int j = 0 ; j < temp . size ( ) - 1 ; j ++ ) { maxDiff = Math . max ( maxDiff , temp . get ( j + 1 ) - temp . get ( j ) ) ; } minDiff = Math . min ( minDiff , maxDiff ) ; } } return minDiff ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; int a [ ] = { 3 , 7 , 8 , 10 , 14 } ; System . out . println ( minimumAdjacentDifference ( a , n , k ) ) ; } }
import java . util . * ; public class GFG { static void difference ( int arr [ ] , int n ) { int largest = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( largest < arr [ i ] ) largest = arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = largest - arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 5 , 9 , 3 , 2 } ; int n = arr . length ; difference ( arr , n ) ; } }
import java . io . * ; public class GFG { static int countKdivPairs ( int [ ] A , int n , int K ) { int freq [ ] = new int [ K ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ A [ i ] % K ] ++ ; int sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i <= K / 2 && i != ( K - i ) ; i ++ ) sum += freq [ i ] * freq [ K - i ] ; if ( K % 2 == 0 ) sum += ( freq [ K / 2 ] * ( freq [ K / 2 ] - 1 ) / 2 ) ; return sum ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 2 , 1 , 7 , 5 , 3 } ; int n = A . length ; int K = 4 ; System . out . println ( countKdivPairs ( A , n , K ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { String s = sc . next ( ) ; if ( s . length ( ) == 0 ) break ; char [ ] c = s . toCharArray ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { c [ i ] = ( char ) ( ' a ' + i ) ; } boolean f = false ; for ( int i = 0 ; i < 4 ; i ++ ) { f |= c [ i ] == ' a ' || c [ i ] == ' b ' || c [ i ] == ' w ' || c [ i ] == ' w ' || c [ i ] == ' b ' ) ; } if ( ! f ) { println ( " NA " ) ; continue ; } int [ ] [ ] dp = new int [ 4 ] [ 3 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( dp [ i ] [ j ] == 0 ) continue ; dp [ i ] [ j ] = 1 ; for ( int k = 0 ; k < 3 ; k ++ ) { if ( j + k < 3 ) continue ; dp [ i ] [ j + k ] = dp [ i ] [ j + k ] ; if ( dp [ i ] [ j ] == 1 ) continue ; dp [ i ] [ j ] = dp [ i ] [ j ] + 1 ; } } } println ( " " + dp [ 0 ] [ 0 ] ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . io . * ; public class GFG { static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 , max_index = 0 ; int prev_zero = - 1 , prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; curr ++ ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " + maxOnesIndex ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = k - 1 ; i >= 1 ; i -- ) { if ( n % i == 0 ) ans = Math . min ( ans , i + ( n / i ) * k ) ; } return ans ; } public static void main ( String [ ] args ) { int n = 4 , k = 6 ; System . out . println ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; System . out . println ( minimumX ( n , k ) ) ; } }
public class Main { public static void main ( String [ ] args ) { long a = 10123465234878998L ; long b = 65746311545646431L ; long m = 10005412336548794L ; System . out . println ( moduloMultiplication ( a , b , m ) ) ; } public static long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a = a % mod ; while ( b != 0 ) { if ( ( b & 1 ) != 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; HashMap < Character , Integer > map = new HashMap < Character , Integer > ( ) ; map . put ( ' a ' , 0 ) ; map . put ( ' e ' , 0 ) ; boolean [ ] vis = new boolean [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; String e = sc . next ( ) ; map . computeIfAbsent ( s , k -> new HashMap < Character , Integer > ( ) ) ; map . computeIfAbsent ( e , k -> new HashMap < Character , Integer > ( ) ) ; map . computeIfAbsent ( s , k -> new HashMap < Character , Integer > ( ) ) . put ( s . charAt ( 0 ) - ' a ' , 1 ) ; vis [ s . charAt ( 0 ) - ' a ' ] = true ; map . computeIfAbsent ( e , k -> new HashMap < Character , Integer > ( ) ) ; map . computeIfAbsent ( e , k -> new HashMap < Character , Integer > ( ) ) . put ( s . charAt ( 1 ) - ' a ' , 1 ) ; } boolean flag = true ; for ( Map . Entry < Character , Integer > e : map . entrySet ( ) ) { if ( ! vis [ e . getKey ( ) ] ) { flag = false ; break ; } } if ( flag ) { System . out . println ( " NG " ) ; } else { System . out . println ( " OK " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; long min = Long . MAX_VALUE , max = Long . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; if ( a [ i ] < min ) { min = a [ i ] ; } } Arrays . sort ( a ) ; max = a [ n - 1 ] ; long [ ] ans = new long [ n ] ; int j = 0 , k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] += a [ i + 1 ] ; if ( Math . abs ( max ) < Math . abs ( min ) ) { j = i + 1 ; ans [ k ] = j + 1 ; } else { k = i + 1 ; ans [ j ] = k ; j = i + 2 ; } } System . out . println ( k ) ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = ans [ i ] + b [ k ] ; System . out . println ( j + " ▁ " + k ) ; } } }
import java . util . * ; public class GFG { static boolean checkPalindrome ( String str ) { int len = str . length ( ) ; len -- ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( len ) ) return false ; len -- ; } return true ; } static void printSolution ( Vector < String > partitions ) { for ( int i = 0 ; i < partitions . size ( ) ; i ++ ) { for ( int j = 0 ; j < partitions . get ( i ) . length ( ) ; j ++ ) System . out . print ( partitions . get ( i ) . charAt ( j ) + " ▁ " ) ; System . out . println ( ) ; } } static void addStrings ( Vector < String > v , String s , Vector < String > temp , int index ) { int len = s . length ( ) ; String str = " " ; Vector < String > current = new Vector < String > ( ) ; if ( index == 0 ) temp = new Vector < String > ( ) ; for ( int i = index ; i < len ; i ++ ) { str += s . charAt ( i ) ; if ( checkPalindrome ( str ) ) { temp . add ( str ) ; if ( i + 1 < len ) addStrings ( v , s , temp , i + 1 ) ; } else { v . add ( temp ) ; } temp = current ; } } static void addStrings ( Vector < String > v , String s , Vector < String > temp , int i ) { int len = s . length ( ) ; String str = " " ; Vector < String > current = new Vector < String > ( ) ; if ( checkPalindrome ( str ) ) { temp . add ( str ) ; if ( i + 1 < len ) addStrings ( v , s , temp , i + 1 ) ; } else v . add ( temp ) ; temp = current ; } static void partition ( String s , Vector < String > v ) { Vector < String > temp = new Vector < String > ( ) ; addStrings ( v , s , temp , 0 ) ; printSolution ( v ) ; } public static void main ( String [ ] args ) { String s = " geeks " ; Vector < String > partitions = new Vector < String > ( ) ; partitions . addStrings
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int r = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int a1 = sc . nextInt ( ) ; int a2 = sc . nextInt ( ) ; int b1 = sc . nextInt ( ) ; int b2 = sc . nextInt ( ) ; int mod = 1000000007 ; long [ ] [ ] dp = new long [ r + 1 ] [ c + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 0 ; j <= c ; j ++ ) { if ( i == j ) { dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] * 2 ) % mod ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; dp [ i ] [ j ] %= mod ; } } } System . out . println ( dp [ r ] [ c ] ) ; } }
import java . util . * ; public class GFG { static void findSubsequence ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( M . containsKey ( arr [ i ] ) ) { M . put ( arr [ i ] , M . get ( arr [ i ] ) + 1 ) ; } else { M . put ( arr [ i ] , 1 ) ; } } int numCount [ ] = new int [ k + 1 ] ; for ( int p : M . keySet ( ) ) { if ( p <= k ) { for ( int i = 1 ; i * p <= k ; i ++ ) { numCount [ i * p ] += M . get ( p ) ; } } else { break ; } } int lcm = 0 , len = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { if ( numCount [ i ] > len ) { len = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) { System . out . print ( " - 1" ) ; } else { System . out . print ( " LCM ▁ = ▁ " + lcm + " , ▁ Length ▁ = ▁ " + len ) ; System . out . print ( " Indexes ▁ = ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( lcm % arr [ i ] == 0 ) { System . out . print ( i + " ▁ " ) ; } } } } public static void main ( String [ ] args ) { int k = 14 ; int arr [ ] = { 2 , 3 , 4 , 5 } ; int n = arr . length ; findSubsequence ( arr , n , k ) ; } }
import java . io . * ; public class GFG { static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 , odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = a . length ; int m = b . length ; System . out . println ( count_pairs ( a , b , n , m ) ) ; } }
import java . io . * ; public class GFG { static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 , odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = a . length ; int m = b . length ; System . out . println ( count_pairs ( a , b , n , m ) ) ; } }
import java . io . * ; public class GFG { static int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int min_element = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] - min_element > max_diff ) max_diff = arr [ i ] - min_element ; if ( arr [ i ] < min_element ) min_element = arr [ i ] ; } return max_diff ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 6 , 80 , 100 } ; int size = arr . length ; System . out . println ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , size ) ) ; } }
import java . io . * ; public class GFG { static int binomialCoeff ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static int findMax ( int n ) { return binomialCoeff ( n , n / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( findMax ( n ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 26 ; static int minimumAddition ( String str , int len ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int maxFreq = Arrays . stream ( freq ) . max ( ) . getAsInt ( ) ; int minAddition = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 0 ) minAddition += Math . abs ( maxFreq - freq [ i ] ) ; } return minAddition ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; System . out . println ( minimumAddition ( str , len ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < 2 * n ; i ++ ) { int c = sc . nextInt ( ) ; int d = a [ i + 1 ] - a [ i ] ; int e = c - d ; if ( e < 0 ) { e = 0 ; } else { e = e + 1 ; } } System . out . println ( e ) ; } }
import java . util . * ; public class GFG { static int MAX = 32 ; static int pow2 [ ] = new int [ MAX ] ; static boolean visited [ ] = new boolean [ MAX ] ; static Vector < Integer > ans = new Vector < Integer > ( ) ; static void power_2 ( ) { int an = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = an ; an *= 2 ; } } static int countSetBits ( int x ) { int setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; } static void add ( int num ) { int point = 0 ; int value = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( visited [ i ] ) continue ; else { if ( num % 2 == 1 ) value += ( 1 << i ) ; num = num / 2 ; } } ans . add ( value ) ; } static void solve ( int n , int k ) { ans . add ( k ) ; int countk = countSetBits ( k ) ; if ( pow2 [ countk ] < n ) { System . out . println ( " - 1" ) ; return ; } int count = 0 ; for ( int i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( count == n ) break ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 3 , k = 5 ; power_2 ( ) ; solve ( n , k ) ; } }
import java . math . BigInteger ; import java . util . ArrayList ; import java . util . List ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public final class p038 { public static void main ( String [ ] args ) { System . out . println ( new p038 ( ) . run ( ) ) ; } public String run ( ) { List < Pair > primes = Library . listPrimality ( 1000 ) ; int max = 0 ; for ( int a = - 1000 ; a <= 1000 ; a ++ ) for ( int b = 2 ; b <= 1000 ; b ++ ) primes . add ( new Pair ( a , b ) ) ; Collections . sort ( primes ) ; return Integer . toString ( primes . get ( 0 ) . x * primes . get ( 1 ) . x ) ; } private static List < Pair > listPrimality ( int n ) { if ( n < 0 ) return false ; if ( n < isPrimes . size ( ) ) return isPrimes . get ( n ) ; return Library . isPrime ( n ) ; } private static class Pair { public final int x , y ; public Pair ( int x , int y ) { this . x = x ; this . y = y ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int n = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; System . out . println ( solve ( n , r ) ) ; } sc . close ( ) ; } static long solve ( int n , int r ) { if ( r > n - 1 ) return ( ( r - n ) * ( r - n ) ) / 2 ; else return ( n - 1 ) * ( r + 1 ) / 2 + 1 ; } }
import java . util . * ; public class GFG { static int MAX = 100001 ; static int [ ] isPrime = new int [ MAX ] ; static void sieve ( ) { for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == 0 ) { for ( int i = 2 * p ; i < MAX ; i += p ) isPrime [ i ] = 1 ; } } } static void findSubset ( int [ ] a , int n ) { int cnt1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) cnt1 ++ ; } if ( cnt1 > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] != 1 ) && ( isPrime [ a [ i ] + 1 ] == 0 ) ) { System . out . println ( cnt1 + 1 ) ; for ( int j = 0 ; j < cnt1 ; j ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . println ( a [ i ] ) ; return ; } } } if ( cnt1 >= 2 ) { System . out . println ( cnt1 ) ; for ( int i = 0 ; i < cnt1 ; i ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . println ( ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) { System . out . println ( 2 ) ; System . out . println ( a [ i ] + " ▁ " + a [ j ] ) ; } } } System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { sieve ( ) ; int [ ] A = { 2 , 1 , 1 } ; int n = A . length ; findSubset ( A , n ) ; } }
import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int r = input . nextInt ( ) ; int t = input . nextInt ( ) ; int [ ] speed = new int [ n ] ; int [ ] point = new int [ n ] ; int [ ] bottle = new int [ r ] ; for ( int i = 0 ; i < n ; i ++ ) { speed [ i ] = input . nextInt ( ) ; } input . close ( ) ; for ( int i = 0 ; i < n ; i ++ ) { point [ i ] = ( point [ i ] + speed [ i ] ) % r ; bottle [ point [ i ] ] += 1 ; } for ( int x = 0 ; x < t - 1 ; x ++ ) { int [ ] nums = new int [ r ] ; for ( int i = 0 ; i < n ; i ++ ) { bottle [ point [ i ] ] -= 1 ; point [ i ] = ( point [ i ] + speed [ i ] ) % r ; nums [ point [ i ] ] += 1 ; } for ( int i = 0 ; i < r ; i ++ ) { if ( bottle [ i ] < nums [ i ] ) { bottle [ i ] = nums [ i ] ; } bottle [ i ] += nums [ i ] ; } } int totalBottles = 0 ; for ( int i = 0 ; i < r ; i ++ ) { totalBottles += bottle [ i ] ; } System . out . println ( totalBottles ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String s = sc . next ( ) ; if ( s . equals ( " Hoshina " ) ) { System . out . println ( " Hoshina " ) ; } else { System . out . println ( s . replaceAll ( " Hoshino " , " Hoshina " ) ) ; } } } }
import java . io . * ; public class GFG { static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = arr . length ; System . out . println ( countRotations ( arr , 0 , n - 1 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int ans = 0 ; int i = 0 ; while ( true ) { ans ++ ; i ++ ; if ( i == m ) break ; } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) { if ( temp [ j ] ) DP [ j ] = true ; } DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 7 } ; int n = arr . length ; int m = 5 ; if ( modularSum ( arr , n , m ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int b = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int count = 0 ; for ( int j = b ; j < e ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } System . out . println ( count ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } long ans = Long . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( i + j < n ) { if ( a [ j ] > a [ j - 1 ] ) { sum += a [ j ] ; } } else { sum += a [ j ] ; } } ans = Math . min ( ans , sum * x ) ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; if ( ( h | w ) == 0 ) break ; int [ ] [ ] field = new int [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) for ( int j = 0 ; j < w ; j ++ ) { field [ i ] [ j ] = sc . nextInt ( ) ; } int [ ] [ ] dp = new int [ h ] [ w ] ; int ans = 0 ; for ( int i = 0 ; i < h ; i ++ ) for ( int j = 0 ; j < w ; j ++ ) { for ( int k = 0 ; k < h ; k ++ ) { for ( int l = 0 ; l < w ; l ++ ) { int [ ] [ ] dp = new int [ h ] [ w ] ; dp [ i ] [ j ] = dp [ i ] [ j ] ; for ( int s = 0 ; s < 2 ; s ++ ) { if ( s < 2 ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; } if ( s < 2 ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ s ] + dp [ s ] [ l ] ) ; } if ( s < 2 ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ s ] + dp [ s ] [ l ] ) ; } dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ j ] - dp [ i ] [ s ] + dp [ s ] [ l ] ) ; } } ans = Math . max ( ans , dp [ h - 1 ] [ w - 1 ] - dp [ h - 1 ] [ w - 1 ] ) ; } } } System . out . println ( ans ) ; } } }
import java . util . * ; public class _820A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k != 0 && arr [ i ] / k != 0 ) { max = Math . max ( max , i ) ; } } System . out . println ( max ) ; } }
import java . io . * ; public class GFG { static int sum ( int k , int n ) { int sum = ( int ) Math . pow ( k , n + 1 ) - ( int ) Math . pow ( k - 1 , n + 1 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; int K = 3 ; System . out . println ( sum ( K , n ) ) ; } }
import java . util . * ; public class GFG { static int solve ( int i , int tight , int sum_so_far , int sum , String number , int len ) { if ( i == len ) { if ( sum_so_far == sum ) return 1 ; else return 0 ; } int ans = dp [ i ] [ tight ] [ sum_so_far ] ; if ( ans != - 1 ) return ans ; ans = 0 ; for ( int currdigit = 0 ; currdigit < 10 ; currdigit ++ ) { int ntight = tight && currdigitstr > number . charAt ( i ) ; if ( ! tight && currdigitstr < number . charAt ( i ) ) break ; int nsum_so_far = sum_so_far + currdigit ; int sum = tight || currdigitstr < number . charAt ( i ) ; int ntight = tight || currdigitstr < number . charAt ( i ) ; int nsum_so_far = sum_so_far + currdigit ; ans += solve ( i + 1 , ntight , nsum_so_far , sum , number , len ) ; } return ans ; } public static void main ( String [ ] args ) { int count = 0 , sum = 4 ; String number = "100" ; int [ ] [ ] [ ] dp = new int [ 18 ] [ 18 ] [ 162 ] ; for ( int k = 0 ; k < 18 ; k ++ ) for ( int i = 0 ; i < 18 ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int l = 0 ; l < 162 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; System . out . println ( solve ( 0 , 0 , 0 , sum , number , number . length ( ) ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } if ( n >= 2 ) { count ++ ; } } System . out . println ( count ) ; } }
import java . util . * ; public class GFG { static class Node { int data ; Node left , right ; } ; static int evenOddLevelDifference ( Node root ) { if ( root == null ) return 0 ; Queue < Node > q = new LinkedList < Node > ( ) ; q . add ( root ) ; int level = 0 ; int evenSum = 0 ; int oddSum = 0 ; while ( q . size ( ) > 0 ) { int size = q . size ( ) ; level ++ ; while ( size -- > 0 ) { Node temp = q . peek ( ) ; q . remove ( ) ; if ( level % 2 == 0 ) evenSum += temp . data ; else oddSum += temp . data ; if ( temp . left != null ) q . add ( temp . left ) ; if ( temp . right != null ) q . add ( temp . right ) ; } } return ( oddSum - evenSum ) ; } public static void main ( String args [ ] ) { Node root = new Node ( 5 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 6 ) ; root . left . left = new Node ( 1 ) ; root . left . right = new Node ( 4 ) ; root . left . right . left = new Node ( 3 ) ; root . right . right = new Node ( 8 ) ; root . right . right . right = new Node ( 9 ) ; Node result = evenOddLevelDifference ( root ) ; System . out . println ( " Difference ▁ between ▁ sums ▁ is ▁ " + result ) ; } }
import java . io . * ; public class GFG { static int countSubarrays ( int a [ ] , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) count ++ ; else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( count > 0 ) number += ( count ) * ( count + 1 ) / 2 ; return number ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 } ; int n = a . length ; int k = 5 ; System . out . println ( countSubarrays ( a , n , k ) ) ; } }
import java . io . * ; public class GFG { static int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 3 , 1 , 5 } ; int n = arr . length ; System . out . println ( minCost ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static void printLastOccurrence ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( a [ i ] , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] ) == i ) { System . out . print ( a [ i ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 5 , 5 , 1 , 6 , 1 } ; int n = a . length ; printLastOccurrence ( a , n ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { int n = in . nextInt ( ) ; if ( n == 0 ) return false ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; int f = 0 , t = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { f ++ ; } else if ( a [ i ] > a [ i - 1 ] ) { t ++ ; } } if ( f == 1 ) out . println ( " NA " ) ; else { out . println ( t ) ; } } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . io . * ; public class GFG { static int countPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; System . out . println ( countPaths ( n , m ) ) ; } }
import java . io . * ; public class GFG { static double sumOfAP ( double a , double d , int n ) { double sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; } public static void main ( String [ ] args ) { int n = 20 ; double a = 2.5 ; double d = 1.5 ; System . out . println ( sumOfAP ( a , d , n ) ) ; } }
import java . io . * ; public class GFG { static int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 0 , 3 , 1 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static void coordinateCompression ( int arr [ ] , int n ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( arr [ i ] , 1 ) ; int index = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int itr : s . values ( ) ) { index ++ ; mp . put ( itr , index ) ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = mp . get ( arr [ i ] ) ; } static int query ( int BIT [ ] , int index , int n ) { int ans = 0 ; while ( index > 0 ) { ans = Math . max ( ans , BIT [ index ] ) ; index -= index & ( - index ) ; } return ans ; } static void update ( int BIT [ ] , int index , int n ) { int x = query ( BIT , index - 1 , n ) ; int value = x + 1 ; while ( index <= n ) { BIT [ index ] = Math . max ( BIT [ index ] , value ) ; index += index & ( - index ) ; } } static int findLISLength ( int arr [ ] , int n ) { coordinateCompression ( arr , n ) ; int BIT [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { update ( BIT , arr [ i ] , n ) ; } int ans = query ( BIT , n , n ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 } ; int n = arr . length ; System . out . println ( findLISLength ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { arr [ i ] [ j ] = sc . nextInt ( ) ; } } boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { int count = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] [ j ] == 1 && arr [ i ] [ k ] == 1 ) count ++ ; } if ( count >= n / 2 && count >= n / 2 ) { found = true ; break ; } } } if ( found ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } private static final int BASE = 10 ; private static final int DIGITS = 20 ; private static final int CONSECUTIVE = 3 ; private static final int MAX_SUM = 9 ; public String run ( ) { int [ ] [ ] ways = new int [ DIGITS + CONSECUTIVE + 1 ] [ MAX_SUM ] ; int [ ] [ ] newrow = new int [ DIGITS + CONSECUTIVE + 1 ] [ MAX_SUM ] ; ways [ 0 ] [ 0 ] = 1 ; for ( int digits = 1 ; digits <= DIGITS + CONSECUTIVE ; digits ++ ) { for ( int prefix = 0 ; prefix < innerlen ; prefix ++ ) { int sum = 0 ; if ( digitSum ( prefix ) <= MAX_SUM ) { for ( int nextdigit = 0 ; nextdigit < BASE ; nextdigit ++ ) sum += ways [ digits - 1 ] [ prefix % ( BASE * Math . pow ( CONSECUTIVE - 1 , 0 ) ) * BASE + nextdigit ; } newrow [ digits ] [ sum ] = sum ; } ways [ digits ] [ 0 ] = 1 ; } int ans = ways [ DIGITS ] [ 0 ] - ways [ DIGITS - 2 ] [ 0 ] ; return Integer . toString ( ans ) ; } private static int digitSum ( int n ) { return Integer . parseInt ( String . valueOf ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . nextLine ( ) ; String [ ] arr = s . split ( " " ) ; int [ ] [ ] a = new int [ 4 ] [ 3 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { a [ i ] [ 0 ] = Integer . parseInt ( arr [ i ] ) ; a [ i ] [ 1 ] = Integer . parseInt ( arr [ i ] ) ; a [ i ] [ 2 ] = Integer . parseInt ( arr [ i ] ) ; } for ( int i = 1 ; i < 4 ; i ++ ) { for ( int j = 1 ; j < 4 ; j ++ ) { if ( a [ i - 1 ] [ j - 1 ] == 1 && a [ i ] [ j ] == 1 && a [ i ] [ j - 1 ] == 1 ) { System . out . println ( " YES " ) ; return ; } } } System . out . println ( " NO " ) ; } }
public class Solution { public boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { for ( int r = 0 ; r < matrix . length - 1 ; r ++ ) { for ( int c = 0 ; c < matrix [ 0 ] . length - 1 ; c ++ ) { if ( matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] ) return false ; } } return true ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 } , { 5 , 1 , 2 , 3 } , { 9 , 5 , 1 , 2 } } ; boolean out = sObj . isToeplitzMatrix ( matrix ) ; System . out . println ( out ) ; } }
public final class p031 { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } public String run ( ) { int LIMIT = Library . pow ( 10 , 9 ) ; long sum = 0 ; for ( int s = 1 ; ; s ++ ) { if ( s * s > ( LIMIT + 1 ) / 3 ) break ; for ( int t = s - 2 ; ; t -- ) { if ( Library . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( a * 2 == c + 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } } } } } return Long . toString ( sum ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; class Main { public static void main ( final String [ ] args ) { final Scanner stdin = new Scanner ( System . in ) ; while ( true ) { final int n = stdin . nextInt ( ) ; final int t = stdin . nextInt ( ) ; final int l = stdin . nextInt ( ) ; final int b = stdin . nextInt ( ) ; if ( n == 0 && t == 0 && l == 0 && b == 0 ) { break ; } final int [ ] [ ] data = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { data [ i ] [ j ] = stdin . nextInt ( ) ; } } final boolean [ ] [ ] isLose = new boolean [ n + 1 ] [ n + 1 ] ; final boolean [ ] [ ] backs = new boolean [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( isLose [ i ] [ j ] ) { for ( int k = 1 ; k <= n ; k ++ ) { if ( j - k >= 0 && data [ i - k ] [ j - 1 ] == false ) { isLose [ i ] [ j - k ] = true ; } else if ( j - k >= 0 && data [ i ] [ j - k ] == false ) { isLose [ i ] [ j - k - 1 ] = true ; } } } } } double sum = 0 ; for ( double value : isLose ) { sum += value * ( value - 1 ) / 6 ; } System . out . printf ( " % .6f \n " , sum ) ; } } }
import java . util . * ; public class oddSet { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int oddCount = 0 ; int evenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int num = sc . nextInt ( ) ; if ( num % 2 == 0 ) evenCount ++ ; else oddCount ++ ; } if ( evenCount >= 2 ) { System . out . println ( " YES " ) ; } else { if ( oddCount >= 2 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } }
import java . io . * ; public class GFG { static int minInsertions ( int H [ ] , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; } public static void main ( String [ ] args ) { int H [ ] = { 2 , 4 , 8 , 16 } ; int K = 3 ; int n = H . length ; System . out . println ( minInsertions ( H , n , K ) ) ; } }
public class GFG { static int countWords ( String str , int l ) { int count = 1 ; if ( l == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < l - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) count *= 1 ; else count *= 2 ; return count ; } public static void main ( String [ ] args ) { String str = " abc " ; int l = str . length ( ) ; System . out . println ( countWords ( str , l ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; sum += arr [ i ] ; } Arrays . sort ( arr ) ; if ( arr [ n - 1 ] % 2 == 0 ) { System . out . println ( sum ) ; } else { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] % 2 != 0 ) { System . out . println ( sum - arr [ i ] ) ; break ; } } } } }
import java . util . * ; public class GFG { static Vector < Integer > getPerfectSquares ( int n ) { Vector < Integer > perfectSquares = new Vector < Integer > ( ) ; int current = 1 ; int i = 1 ; while ( current <= n ) { perfectSquares . add ( current ) ; i ++ ; current = ( int ) Math . pow ( i , 2 ) ; } return perfectSquares ; } static int maxPairSum ( int arr [ ] ) { int n = arr . length ; int max = 0 , secondMax = 0 ; if ( arr [ 0 ] > arr [ 1 ] ) { max = arr [ 0 ] ; secondMax = arr [ 1 ] ; } else { max = arr [ 1 ] ; secondMax = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) secondMax = arr [ i ] ; } return ( max + secondMax ) ; } static int countPairsWith ( int n , Vector < Integer > perfectSquares , Vector < Integer > nums ) { int count = 0 ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int temp = perfectSquares . get ( i ) - n ; if ( temp > n && ( nums . contains ( temp ) ) ) count ++ ; } return count ; } static int countPairs ( int arr [ ] ) { int n = arr . length ; int max = maxPairSum ( arr ) ; Vector < Integer > perfectSquares = getPerfectSquares ( max ) ; Vector < Integer > nums = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) nums . add ( arr [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 6 , 9 , 10 , 20 } ; System . out . println ( countPairs ( arr ) ) ; } }
import java . io . * ; public class GFG { static double findHypotenuse ( int side1 , int side2 ) { double h = Math . sqrt ( ( ( side1 * side1 ) + ( side2 * side2 ) ) ) ; return h ; } public static void main ( String [ ] args ) { int side1 = 3 , side2 = 4 ; System . out . println ( findHypotenuse ( side1 , side2 ) ) ; } }
import java . io . * ; public class GFG { static void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int n = size - 2 ; int x = 0 , y = 0 ; for ( int i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int minIdx = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > max ) { max = arr [ j ] ; minIdx = j ; } if ( arr [ j ] < min ) { min = arr [ j ] ; minIdx = j ; } } int x = n - minIdx + 1 ; if ( x < 0 ) { min = x ; } if ( x > 0 ) { max = arr [ x ] ; } if ( x < n - 1 ) { min = x ; } if ( x == 0 ) { if ( minIdx != - 1 ) { min = x - 1 ; } } if ( x == n - 1 ) { min = n - 1 ; } if ( x == 0 ) { if ( minIdx != - 1 ) { min = x - 1 ; } } System . out . println ( min ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int [ ] month = new int [ 12 ] ; for ( int i = 0 ; i < 12 ; i ++ ) month [ i ] = parseInt ( st . nextToken ( ) ) ; int [ ] day = new int [ 12 ] ; for ( int i = 0 ; i < 12 ; i ++ ) { day [ i ] = getDay ( month [ i ] , i ) ; } if ( isLeapYear ( day ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } static int isLeapYear ( int month [ ] , int i ) { if ( i <= 1 ) return 31 ; if ( month [ i - 1 ] == 1 || month [ i ] == 2 || month [ i ] == 3 || month [ i ] == 4 || month [ i ] == 5 || month [ i ] == 6 || month [ i ] == 7 ) return 30 ; else if ( month [ i - 1 ] == 2 || month [ i - 1 ] == 3 || month [ i ] == 4 || month [ i ] == 6 || month [ i ] == 7 ) return 31 ; else return 28 ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . next ( ) . toCharArray ( ) ; } if ( n == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static class Node { int data ; Node next ; } ; static void printList ( Node head ) { if ( head == null ) return ; Node temp = head ; System . out . print ( temp . data + " - > " ) ; temp = temp . next ; while ( temp != head ) { System . out . print ( temp . data + " - > " ) ; temp = temp . next ; } System . out . print ( head . data ) ; } static void deleteK ( Node head_ref , int k ) { head = head_ref ; if ( head == null ) return ; Node curr = head ; Node prev = null ; while ( true ) { if ( curr . next == head && curr == head ) break ; prList ( head ) ; for ( int i = 0 ; i < k ; i ++ ) { prev = curr ; curr = curr . next ; } if ( curr == head ) { prev = head ; while ( prev . next != head ) prev = prev . next ; head = curr . next ; prev . next = head ; head_ref = head ; } else if ( curr . next == head ) prev . next = head ; else prev . next = curr . next ; } } static Node insertNode ( Node head_ref , int x ) { Node temp = new Node ( x ) ; if ( head == null ) { temp . next = temp ; head_ref = temp ; return head_ref ; } else { Node temp1 = head ; while ( temp1 . next != head ) temp1 = temp1 . next ; temp1 . next = temp ; temp . next = head ; } return head ; } public static void main ( String [ ] args ) { Node head = null ; head = insertNode ( head , 1 ) ; head = insertNode ( head , 2 ) ; head = insertNode ( head , 3 ) ; head = insertNode ( head , 4 ) ; head = insertNode ( head , 5 ) ; head = insertNode ( head , 6 ) ; head = insertNode ( head , 7 ) ; head = insertNode ( head , 8 ) ; head = insertNode ( head , 9 ) ; int k = 4 ; deleteK ( head , k ) ; } }
import java . util . * ; public class GFG { static int steps ( int cur , int x , int n ) { if ( x == 0 ) return Integer . MAX_VALUE ; if ( x > 0 ) return Math . abs ( ( n - cur ) / x ) ; else return Math . abs ( ( cur - 1 ) / x ) ; } static int countSteps ( int curx , int cury , int n , int m , int moves [ ] [ ] ) { int count = 0 ; int k = moves . length ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i ] [ 0 ] ; int y = moves [ i ] [ 1 ] ; int stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 , x = 1 , y = 1 ; int moves [ ] [ ] = { { 1 , 1 } , { 1 , 1 } , { 0 , - 2 } } ; System . out . println ( countSteps ( x , y , n , m , moves ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int ans = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { ans ++ ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int cntSubArr ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ? 1 : 0 ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( cntSubArr ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static boolean isVowel ( char c ) { if ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) return true ; return false ; } static boolean isVowelPrime ( String str , int n ) { boolean [ ] prime = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < n ; i += p ) prime [ i ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) && prime [ i ] == false ) return false ; } return true ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; if ( isVowelPrime ( str , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; for ( int l = 1 ; l <= N ; l ++ ) { for ( int i = 0 , j = l - 1 ; j < N ; j ++ ) { if ( l == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) { if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ N - 1 ] ; } public static void main ( String [ ] args ) { String str = "2553432" ; System . out . println ( minStepToDeleteString ( str ) ) ; } }
public class GFG { static int limit = 1000000 ; static int position [ ] = new int [ limit + 1 ] ; static void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { pos ++ ; position [ i ] = pos ; for ( int j = i * 2 ; j <= limit ; j += i ) { position [ j ] = - 1 ; } } } } public static void main ( String [ ] args ) { sieve ( ) ; int n = 11 ; System . out . println ( position [ n ] ) ; } }
import java . io . * ; public class GFG { static int DP_s = 9 ; static int getNumMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < len ; i ++ ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } public static void main ( String [ ] args ) { System . out . println ( getNumMonotone ( 10 ) ) ; } }
import java . io . * ; public class GFG { static int DP_s = 9 ; static int getNumMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < len ; i ++ ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } public static void main ( String [ ] args ) { System . out . println ( getNumMonotone ( 10 ) ) ; } }
import java . util . * ; public class GFG { static int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , a [ i ] ) ; int count [ ] = new int [ mx + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int res [ ] = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { int k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 1 , 2 , 3 , 2 , 2 , 1 } ; int l = 1 , r = 1 ; int n = a . length ; System . out . println ( maxCost ( a , n , l , r ) ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; for ( int j = 0 ; j < m ; j ++ ) { arr [ i ] [ j ] = s . charAt ( j ) ; } } int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == 0 ) { continue ; } max = Math . max ( max , Math . abs ( i + j ) ) ; min = Math . min ( min , arr [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == 0 ) { System . out . println ( " NO " ) ; return ; } } } System . out . println ( " YES " ) ; } } }
import java . io . * ; public class GFG { static float findArea ( float r ) { float PI = 3.142f ; return PI * ( r * r ) ; } public static void main ( String [ ] args ) { System . out . println ( " Area ▁ is ▁ " + findArea ( 5 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) - 1 ; b [ i ] = sc . nextInt ( ) - 1 ; } int [ ] [ ] dp = new int [ n ] [ n ] ; int [ ] s = new int [ n ] ; int [ ] t = new int [ n ] ; Arrays . fill ( t , - 1 ) ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( k <= a [ j ] && b [ j ] == i ) { s [ j ] = t [ j ] ; t [ j ] = count ; } else if ( b [ j ] == i && a [ j ] == i ) { s [ j ] = count ; t [ j ] = count ; } } } dp [ 0 ] [ 0 ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( k <= s [ j ] && b [ j ] == i ) { s [ j ] = count ; dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , s [ j ] + 2 * ( k - s [ j ] ) ) ; } } } System . out . println ( dp [ 0 ] [ n - 1 ] ) ; } }
import java . io . * ; public class GFG { static int nthTerm ( int N ) { return ( Math . abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ) ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( nthTerm ( N ) ) ; } }
public class GFG { static int getHeight ( int X ) { return ( 2 * X ) ; } public static void main ( String [ ] args ) { int X = 35 ; System . out . println ( getHeight ( X ) ) ; } }
import java . io . * ; public class GFG { static int V = 4 ; static int countwalks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; return count ; } public static void main ( String [ ] args ) { int graph [ ] [ ] = { { 0 , 1 , 1 , 1 , } , { 0 , 0 , 0 , 1 , } , { 0 , 0 , 0 , 1 , } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; int u = 0 , v = 3 , k = 2 ; System . out . println ( countwalks ( graph , u , v , k ) ) ; } }
import java . io . * ; public class GFG { static int findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) ; return ( int ) ( Math . floor ( x ) + 1 ) ; } public static void main ( String [ ] args ) { System . out . println ( findDigits ( 4 , 16 ) ) ; System . out . println ( findDigits ( 5 , 8 ) ) ; System . out . println ( findDigits ( 12 , 16 ) ) ; System . out . println ( findDigits ( 19 , 13 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; int [ ] add = new int [ n + 1 ] ; for ( int i = 0 ; i < q ; i ++ ) { int type = sc . nextInt ( ) ; if ( type == 0 ) { add [ sc . nextInt ( ) ] ++ ; } else { add [ sc . nextInt ( ) ] = sc . nextInt ( ) ; } System . out . print ( solve ( add , add [ sc . nextInt ( ) ] ) ) ; } } static int solve ( int [ ] add , int [ ] add ) { int n = add . length ; int [ ] ans = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = add [ i ] ; } return ans ; } static int lcm ( int x , int y ) { return x * y / gcd ( x , y ) ; } static int gcd ( int x , int y ) { return x * y % gcd ( y , x ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long MOD = 1000000007 ; long [ ] [ ] dp = new long [ 61 ] [ 61 ] ; dp [ 0 ] [ 0 ] = 1 ; long ans = 0 ; for ( int i = 1 ; i < 61 ; i ++ ) { long d = n >> i ; for ( int j = 0 ; j < 61 ; j ++ ) { if ( j < 0 ) dp [ j ] [ i ] = 0 ; else dp [ j ] [ i ] = dp [ j - 1 ] [ i ] + dp [ j ] [ i - 1 ] ; dp [ j ] [ i ] %= MOD ; if ( j > 0 ) dp [ j ] [ i ] = ( dp [ j ] [ i ] + dp [ j - 1 ] [ i - 1 ] * 2 ) % MOD ; dp [ j ] [ i ] %= MOD ; } dp [ j ] [ i ] = dp [ j - 1 ] [ i ] + dp [ j ] [ i ] ; ans = ( ans + dp [ j ] [ i ] ) % MOD ; } System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean solve ( ) { int p = in . nextInt ( ) ; int q = in . nextInt ( ) ; int a = in . nextInt ( ) ; int n = in . nextInt ( ) ; if ( p + q + a + n == 0 ) return false ; int [ ] cnt = new int [ 10000 ] ; long ans = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { cnt [ i ] = cnt [ i - 1 ] + 1 ; if ( p + a == 0 && q == 0 && a == 0 && n == 0 ) return false ; a -- ; q -- ; a -- ; n -- ; if ( a == 0 ) break ; cnt [ p ] += cnt [ q ] ; ans += cnt [ q ] ; } return true ; } public static void main ( String [ ] args ) { long start = System . currentTimeMillis ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . currentTimeMillis ( ) ; in . close ( ) ; out . close ( ) ; } static void trace ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } }
import java . util . * ; public class GFG { static String binary_conversion ( String s , int m ) { while ( m > 0 ) { int temp = m % 2 ; s += ( char ) ( temp + '0' ) ; m /= 2 ; } return new StringBuilder ( s ) . reverse ( ) . toString ( ) ; } static int find_character ( int n , int m , int i ) { String s = " " ; s = binary_conversion ( s , m ) ; String s1 = " " ; for ( int x = 0 ; x < n ; x ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '1' ) s1 += '10' ; else s1 += '01' ; } s = s1 ; s1 = " " ; } int e = s . charAt ( i ) ; int r = ( int ) ( s . charAt ( i ) ) ; return ( int ) ( e - r ) ; } public static void main ( String [ ] args ) { int m = 5 , n = 2 , i = 8 ; System . out . println ( find_character ( n , m , i ) ) ; } }
import java . util . * ; public class GFG { static int countSubSets ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ; } even_count = us . size ( ) ; return ( int ) Math . pow ( 2 , even_count ) - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 } ; int n = arr . length ; System . out . println ( " Number ▁ of ▁ subsets ▁ = ▁ " + countSubSets ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 1000 ; static int f [ ] = new int [ MAX ] ; static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return f [ n ] = 1 ; if ( f [ n ] != 0 ) return f [ n ] ; int k = ( n & 1 ) > 0 ? ( n + 1 ) / 2 : n / 2 ; if ( ( n & 1 ) > 0 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 12 ; System . out . println ( findLCMFibonacci ( a , b ) ) ; } }
import java . io . * ; public class GFG { static int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) x = 9 - w ; else if ( w >= - 9 && w <= - 1 ) x = 10 + w ; sum = ( int ) Math . pow ( 10 , n - 2 ) ; sum = ( int ) ( x * sum ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 , w = 4 ; System . out . println ( findNumbers ( n , w ) ) ; } }
public class Main { public static char findKthChar ( String s , int k ) { int len1 = s . length ( ) ; int i = 0 ; int total_len = 0 ; while ( i < len1 ) { if ( Character . isAlphabetic ( s . charAt ( i ) ) ) { total_len ++ ; if ( total_len == k ) { return s . charAt ( i ) ; } i ++ ; } else { int n = 0 ; while ( i < len1 && ! Character . isAlphabetic ( s . charAt ( i ) ) ) { n = n * 10 + ( int ) ( s . charAt ( i ) - '0' ) ; i ++ ; } int next_total_len = total_len * n ; if ( k <= next_total_len ) { int pos = k % total_len ; if ( pos == 0 ) { pos = total_len ; } return findKthChar ( s , pos ) ; } else { total_len = next_total_len ; } } } return ( char ) - 1 ; } public static void main ( String [ ] args ) { String s = " ab2c3" ; int k = 5 ; System . out . println ( findKthChar ( s , k ) ) ; } }
public class GFG { static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { String s = " abcde " ; System . out . println ( countNonEmptySubstr ( s ) ) ; } }
