import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE L = 50000 NEW_LINE sq = int ( L ** .5 ) NEW_LINE p = [ 1 ] * ( L + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = 0 NEW_LINE pn = [ ] NEW_LINE for x in range ( sq + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT for y in range ( x * x , L + 1 , x ) : NEW_LINE INDENT p [ y ] = 0 NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT for x in range ( sq + 1 , L + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT pp = [ 0 ] * ( L + 1 ) NEW_LINE L0 = len ( pn ) NEW_LINE for i in range ( L0 ) : NEW_LINE INDENT x = pn [ i ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT z = x + pn [ j ] NEW_LINE if z > L : NEW_LINE INDENT break NEW_LINE DEDENT pp [ z ] += 1 NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT write ( " % d \n " % pp [ N ] ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def countFreq ( str , freq , Len ) : NEW_LINE INDENT for i in range ( Len ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , Len ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT if ( Len % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_str = odd_str + chr ( i + ord ( ' a ' ) ) NEW_LINE return odd_str NEW_LINE DEDENT DEDENT return odd_str NEW_LINE DEDENT def findPalindromicString ( str ) : NEW_LINE INDENT Len = len ( str ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE countFreq ( str , freq , Len ) NEW_LINE if ( canMakePalindrome ( freq , Len ) == False ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) NEW_LINE front_str = " " NEW_LINE rear_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " NEW_LINE if ( freq [ i ] != 0 ) : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) NEW_LINE for j in range ( 1 , ( freq [ i ] // 2 ) + 1 ) : NEW_LINE INDENT temp = temp + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT front_str = front_str + temp NEW_LINE rear_str = temp + rear_str NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " malayay ▁ string " NEW_LINE str = " mal
import sys NEW_LINE import os NEW_LINE import pprint NEW_LINE def judge ( lst ) : NEW_LINE INDENT x0 , y0 , x1 , y1 , x2 , y2 = lst NEW_LINE v0 = ( x1 - x0 , y1 - y0 ) NEW_LINE v1 = ( x2 - x0 , y2 - y0 ) NEW_LINE dot = v0 [ 0 ] * v1 [ 0 ] + v0 [ 1 ] * v1 [ 1 ] NEW_LINE cross = v0 [ 0 ] * v1 [ 1 ] - v0 [ 1 ] * v1 [ 0 ] NEW_LINE if dot == 0 : NEW_LINE INDENT cross = 0 NEW_LINE DEDENT elif cross == 0 : NEW_LINE INDENT cross = 1 NEW_LINE DEDENT print ( " { 0 : . 10f } " . format ( dot ) ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE judge ( lst ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 for i in range ( 9 ) ] NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( ord ( number [ i ] ) - ord ( '0' ) ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ( ord ( number [ i ] ) - ord ( '0' ) ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( count9s ( "01809" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE print ( count9s ( "4189" ) ) NEW_LINE DEDENT
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = fastPow ( N , K // 2 ) ; NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp ; NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( countWays ( N , K ) ) ; NEW_LINE
def solve ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE mark = ( 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE mark = ( a >> x ) & 1 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT if mark [ i ] == 1 : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT step = [ ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE solve ( a ) NEW_LINE DEDENT DEDENT def solve ( a ) : NEW_LINE INDENT mark = ( 0 , 0 , 1 , 1 , 0 , 1 , 0 ) NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT step . append ( 0 ) NEW_LINE DEDENT for i in range ( 0 , 7 ) : NEW_LINE INDENT next_step = [ ] NEW_LINE for j in range ( 0 , 4 ) : NEW_LINE INDENT if ( a >> j ) & 1 : NEW_LINE INDENT next_step . append ( step [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT next_step . append ( step [ j ] ) NEW_LINE DEDENT DEDENT DEDENT x = next_step [ 0 ] NEW_LINE count = 0 NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT if ( a >> i ) & 1 and ( a >> i ) & 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == 4 : NEW_LINE INDENT print ( "4" , end = " " ) NEW_LINE DEDENT elif count == 3 : NEW_LINE INDENT print ( "3" , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i < MAX ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE arr = [ ] NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT k = int ( MAX ** ( 0.5 ) ) NEW_LINE for p in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if ( not prime [ n ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = arr [ i ] NEW_LINE if ( product + 1 == n or product - 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " ▁ * ▁ " , i , " ▁ = ▁ " , N * i ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE DEDENT
def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m ; NEW_LINE n1 = m * q ; NEW_LINE n2 = ( n * m ) ; NEW_LINE if ( n * m ) : NEW_LINE INDENT print ( ( m * ( q + 1 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( m * ( q - 1 ) ) ) ; NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 ; NEW_LINE DEDENT return n2 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 ; NEW_LINE m = 4 ; NEW_LINE print ( closestNumber ( n , m ) ) ; NEW_LINE n = - 15 ; NEW_LINE m = 6 ; NEW_LINE print ( closestNumber ( n , m ) ) ; NEW_LINE n = 0 ; NEW_LINE m = 8 ; NEW_LINE print ( closestNumber ( n , m ) ) ; NEW_LINE n = 18 ; NEW_LINE m = - 7 ; NEW_LINE print ( closestNumber ( n , m ) ) ; NEW_LINE DEDENT
def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ans = 1 ; NEW_LINE freq = ( ang * n ) / 180 ; NEW_LINE ans = ans * ( n - 1 - freq ) ; NEW_LINE ans = ans * n ; NEW_LINE return ans ; NEW_LINE DEDENT  ang = 90 ; NEW_LINE n = 4 ; NEW_LINE print ( solve ( ang , n ) ) ; NEW_LINE
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ None ] * n NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ lps [ i ] ] ) : NEW_LINE INDENT lps [ i ] = l NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT lps [ lps [ lps [ lps [ lps - 1 ] ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 : lps [ i ] ] ) NEW_LINE return NEW_LINE DEDENT DEDENT if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : lps [ lps [ n - 1 ] - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " fixprefixsuffix " NEW_LINE Longestsubstring ( s ) NEW_LINE DEDENT
def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = float ( ' inf ' ) NEW_LINE maxEle = - float ( ' inf ' ) NEW_LINE minIndex = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( minIndex == 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT if ( flag1 and flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE DEDENT
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE step = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a_next = a [ i + 1 ] NEW_LINE if a_next == a [ i ] : NEW_LINE INDENT step = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b = a_next - a_next NEW_LINE b = a_next NEW_LINE a_next = a_next // d * ( b + 1 ) NEW_LINE if a_next == a [ i ] : NEW_LINE INDENT step += 1 NEW_LINE DEDENT else : NEW_LINE INDENT step += 1 NEW_LINE DEDENT DEDENT DEDENT print ( step ) NEW_LINE
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input = num NEW_LINE count = 0 NEW_LINE factor = [ 0 ] * ( num + 1 ) NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE num //= 2 NEW_LINE DEDENT factor [ 2 ] = count NEW_LINE DEDENT for i in range ( 3 , num + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE num //= i NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( num + 1 ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i NEW_LINE DEDENT DEDENT if ( product == input ) : NEW_LINE INDENT print ( " Power - isolated ▁ Integer " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT checkIfPowerIsolated ( 12 ) NEW_LINE checkIfPowerIsolated ( 18 ) NEW_LINE checkIfPowerIsolated ( 35 ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( - 1 if s . isalpha ( ) or s . isdigit ( ) or s . islower ( ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT elif s [ 0 ] == " A " or s . isupper ( ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT elif s [ 1 : ] == " Z " : NEW_LINE INDENT print ( " A " * ( len ( s ) - 1 ) + " Z " * ( len ( s ) - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] not in d : NEW_LINE INDENT d [ l [ i ] ] = [ l [ i ] , i ] NEW_LINE DEDENT else : NEW_LINE INDENT d [ l [ i ] ] . append ( l [ i ] ) NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for item in d : NEW_LINE INDENT if d [ item ] [ 0 ] == 1 : NEW_LINE INDENT mx = max ( mx , item [ 1 ] - d [ item [ 0 ] ] [ 1 ] + n - i ) NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , item [ 1 ] - d [ item [ 0 ] ] [ 1 ] + n - i ) NEW_LINE DEDENT DEDENT print ( mx ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if ( len1 == 0 or len2 == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) ; NEW_LINE i_n1 = 0 ; NEW_LINE i_n2 = 0 ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 ; NEW_LINE n1 = ord ( num1 [ i ] ) - ord ( '0' ) ; NEW_LINE i_n2 = 0 ; NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - ord ( '0' ) ; NEW_LINE sum = ( n1 * n2 + ( result [ i_n1 + i_n2 ] + carry ) ) ; NEW_LINE carry = int ( sum / 10 ) ; NEW_LINE result [ i_n1 + i_n2 ] = int ( sum % 10 ) ; NEW_LINE i_n2 += 1 ; NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry ; NEW_LINE DEDENT i_n1 += 1 ; NEW_LINE DEDENT i = len ( result ) - 1 ; NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" ; NEW_LINE DEDENT s = " " ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += ( result [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT return s ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "12354214154545454545454544" ; NEW_LINE str2 = "1714546546546545454454544" ; NEW_LINE if ( ( str1 [ 0 ] == ' - ' or str2 [ 0 ] == ' - ' ) and ( str1 [ 0 ] != ' - ' and str2 [ 0 ] != ' - ' ) ) : NEW_LINE INDENT str2 = str1 [ 1 : ] ; NEW_LINE DEDENT elif ( str1 [ 0 ] != ' - ' and str2 [ 0 ] != ' - ' ) : NEW_LINE INDENT str1 = str2 ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = sum ( a ) NEW_LINE y = x / n NEW_LINE if y >= x : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE left = 0 NEW_LINE right = n NEW_LINE if k < left : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( left ) : NEW_LINE INDENT print ( s [ i ] , end = " ▁ " ) NEW_LINE DEDENT if i != n - 1 : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT dp = [ [ False for i in range ( sum + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True ; NEW_LINE for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True ; NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True ; NEW_LINE DEDENT DEDENT DEDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printDistSum ( arr , n ) ; NEW_LINE DEDENT
def Subtract ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT a , b = 2 , 3 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE a , b = 9 , 7 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE
import math NEW_LINE n = int ( input ( ) ) NEW_LINE if ( n == 0 ) : print ( 0 ) NEW_LINE elif ( n == 1 ) : print ( 1 ) NEW_LINE elif ( n == 2 ) : print ( 2 ) NEW_LINE else : NEW_LINE INDENT k = 4 + 8 * ( int ( math . sqrt ( n * n / 2 ) ) ) NEW_LINE p = int ( math . sqrt ( n * n / 2 ) ) NEW_LINE if ( p * p + ( p + 1 ) * ( p + 1 ) > n ) : k -= 4 NEW_LINE print ( k ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = len ( l ) NEW_LINE if l [ x - 1 ] == x : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < len ( occurrences ) : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE if n > 26 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT ch = list ( string ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( 97 + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT return " " . join ( ch ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE print ( getModifiedString ( string ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE arn = lambda x : '0' + str ( x ) if x . isnumeric ( ) else str ( x ) NEW_LINE sd = lambda x : int ( x [ - 1 ] ) NEW_LINE sdl = lambda : list ( map ( int , input ( ) . split ( ' : ' ) ) ) NEW_LINE arn = lambda x : '0' + str ( x [ : - 1 ] ) NEW_LINE status = True NEW_LINE while True : NEW_LINE INDENT if status : NEW_LINE INDENT r = h * m + r NEW_LINE if r >= 0 : NEW_LINE INDENT status = False NEW_LINE DEDENT r = h * m + r NEW_LINE if status : NEW_LINE INDENT status = True NEW_LINE DEDENT DEDENT DEDENT return status NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE temp = 1 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT temp += a [ i ] NEW_LINE DEDENT print ( max ( temp - 2 , n - 1 ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = " " NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) : NEW_LINE INDENT ans += "01" NEW_LINE n >>= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += "0" NEW_LINE n //= 2 NEW_LINE DEDENT DEDENT print ( ans [ : : - 1 ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT if x < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if x == 2 : NEW_LINE INDENT return 3 NEW_LINE DEDENT if x % 2 == 0 : NEW_LINE INDENT return 4 NEW_LINE DEDENT if x % 2 == 1 : NEW_LINE INDENT return 5 NEW_LINE DEDENT if x % 2 == 2 : NEW_LINE INDENT return 6 NEW_LINE DEDENT z = 3 NEW_LINE while z <= n : NEW_LINE INDENT x = z * 2 - 1 NEW_LINE if x % 2 == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT print ( f ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l = int ( input ( ) ) NEW_LINE print ( a [ l - 1 ] ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ 0 ] * ( n + 1 ) NEW_LINE s [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s [ i ] = ( s [ i - 1 ] + s [ i ] ) % m NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i * n - i ) >= 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import collections NEW_LINE def printMax ( arr , n , k ) : NEW_LINE INDENT Qi = collections . deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( Qi ) != 0 and arr [ i ] >= arr [ Qi [ - 1 ] ] ) : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ Qi [ 0 ] ] , end = " ▁ " ) NEW_LINE while ( len ( Qi ) != 0 and Qi [ 0 ] <= i - k ) : NEW_LINE INDENT Qi . popleft ( ) NEW_LINE DEDENT while ( len ( Qi ) != 0 and arr [ i ] >= arr [ Qi [ - 1 ] ] ) : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT print ( arr [ Qi [ - 1 ] ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 1 , 78 , 90 , 57 , 89 , 56 ] NEW_LINE k = 3 NEW_LINE printMax ( arr , len ( arr ) , k ) NEW_LINE DEDENT
def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE
def isValid ( str , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if ( str [ i ] == str [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "0110" NEW_LINE length = len ( str ) NEW_LINE if isValid ( str , length ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
import random NEW_LINE import math NEW_LINE def lehmann ( n , t ) : NEW_LINE INDENT random = random . randint ( 0 , 13 ) ; NEW_LINE a = int ( random . randint ( 0 , n - 3 ) + 2 ) ; NEW_LINE e = ( n - 1 ) / 2 ; NEW_LINE while ( t > 0 ) : NEW_LINE INDENT result = ( ( pow ( a , e ) ) ) % n ; NEW_LINE if ( ( result % n ) == 1 or ( result % n ) == ( n - 1 ) ) : NEW_LINE INDENT a = int ( random . randint ( 0 , n - 3 ) + 2 ) ; NEW_LINE t -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 13 ; NEW_LINE t = 10 ; NEW_LINE if ( n == 2 ) : NEW_LINE INDENT print ( " ▁ 2 ▁ is ▁ Prime . " ) ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( n , " is ▁ Composite " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = lehmann ( n , t ) ; NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT print ( n , " may ▁ be ▁ Prime . " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ Composite . " ) ; NEW_LINE DEDENT DEDENT
def solve ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE while max ( a , b ) != 0 : NEW_LINE INDENT if a >= b : NEW_LINE INDENT a = a % b NEW_LINE DEDENT else : NEW_LINE INDENT b = b % a NEW_LINE DEDENT cnt += a // b NEW_LINE a = a % b NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
s , k = map ( str , input ( ) . split ( ) ) NEW_LINE print ( " impossible " if k >= len ( s ) else " impossible " ) NEW_LINE
N = 3 NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE trace = 0 NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT trace += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] NEW_LINE print ( MaxTraceSub ( mat ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE x1 , y1 , x2 , y2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x3 , y3 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x2 , y2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x3 , y3 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = x1 - x3 NEW_LINE b = y1 - y3 NEW_LINE if a >= 0 and a <= x3 or b >= 0 and b <= y3 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math NEW_LINE def is_prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE while ( t != 0 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num = [ 0 ] * 30 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( 30 ) : NEW_LINE INDENT tmp = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( num [ j ] >> i ) & 1 and ( tmp + 1 << j ) & 1 : NEW_LINE INDENT if is_prime ( a [ i ] ) : NEW_LINE INDENT tmp += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " % d ▁ % d " % ( i , tmp ) , end = " " ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( ( divCount % 2 ) != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = 1 , 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = ( r + a [ i ] ) // m NEW_LINE if r < r : NEW_LINE INDENT r = a [ i ] NEW_LINE DEDENT DEDENT print ( r + 1 ) NEW_LINE
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 ; neg_sum = 0 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) ; NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] ; NEW_LINE DEDENT arr [ i ] = abs ( diff ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] ; NEW_LINE replacepedArray ( N , arr ) ; NEW_LINE printArray ( N , arr ) ; NEW_LINE N = 6 ; NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] ; NEW_LINE replacepedArray ( N , arr1 ) ; NEW_LINE printArray ( N , arr1 ) ; NEW_LINE DEDENT
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 ; neg_sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos_sum = 0 ; NEW_LINE neg_sum = 0 ; NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ j ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] ; NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) ; NEW_LINE arr [ i ] = abs ( diff ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 ; NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] ; NEW_LINE replacepedArray ( N , arr ) ; NEW_LINE printArray ( N , arr ) ; NEW_LINE N = 6 ; NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] ; NEW_LINE replacepedArray ( N , arr1 ) ; NEW_LINE printArray ( N , arr1 ) ; NEW_LINE DEDENT
def countDivisbleby4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "124" NEW_LINE print ( countDivisbleby4 ( s ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a > min ( b , c ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT if b > min ( a , c ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT
from itertools import product NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE def solve ( n ) : NEW_LINE INDENT mask = ( 1 << 31 ) - 1 NEW_LINE for i in range ( 31 , 0 , - 1 ) : NEW_LINE INDENT mask |= ( mask << i ) NEW_LINE DEDENT for i , v in enumerate ( product ( mask , range ( 1 , 31 ) ) ) : NEW_LINE INDENT if v & ( 1 << i ) : NEW_LINE INDENT n |= ( 1 << i ) NEW_LINE break NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT def test ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE ans = " no " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ a [ i ] ] == x : NEW_LINE INDENT d [ a [ i ] ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if a [ i ] < x : NEW_LINE INDENT d [ a [ i ] ] += 1 NEW_LINE ans = " yes " NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE def foo ( ifile ) : NEW_LINE INDENT C , D , M , N = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE if N == 1 : NEW_LINE INDENT return D NEW_LINE DEDENT if M == 0 : NEW_LINE INDENT return a [ 0 ] * D NEW_LINE DEDENT if a [ 0 ] == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT d = a [ i ] NEW_LINE if d > M : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT j = min ( j , d + a [ i - 1 ] - a [ j - 1 ] ) NEW_LINE DEDENT d = M * ( abs ( a [ j - 1 ] - a [ j ] ) // M ) + d NEW_LINE DEDENT a [ i ] = j NEW_LINE DEDENT return d NEW_LINE DEDENT def solve ( ifile ) : NEW_LINE INDENT D , M , N = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE dp = [ - 1 ] * 256 NEW_LINE for x in a : NEW_LINE INDENT dp [ x ] = min ( dp [ x ] , dp [ x - 1 ] + D ) NEW_LINE DEDENT return dp [ N - 1 ] NEW_LINE DEDENT for tc in range ( 1 , int ( ifile . readline ( ) ) + 1 ) : NEW_LINE INDENT def main ( ifile , ofile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( " Case ▁ # % s : ▁ % s \n " % ( tc + 1 , solve ( sys . stdin , sys . stdout ) ) NEW_LINE DEDENT DEDENT main ( sys . stdout , sys . stdin ) NEW_LINE
import sys NEW_LINE from itertools import product NEW_LINE readline = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT P = [ list ( map ( int , readline ( ) . strip ( ) ) ) for _ in range ( int ( readline ( ) . strip ( ) ) ) ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if P [ i ] [ i ] == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT d = [ ( i , c ) for ( i , c ) in enumerate ( P [ i : ] , start = 1 ) if c == '1' ] NEW_LINE for dx , dy in product ( ( - 1 , 0 , 1 ) , repeat = 2 ) : NEW_LINE INDENT if ( dx , dy ) in d : NEW_LINE INDENT if ( dx , dy ) in d : NEW_LINE INDENT P [ i ] [ j ] = '0' NEW_LINE DEDENT DEDENT DEDENT print ( sum ( d ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : print ( " Yes " ) NEW_LINE else : print ( " No " ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE print ( sum ( abs ( i - j ) for i , j in zip ( a , a [ 1 : ] ) ) ) NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if len ( mp ) < k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp [ arr [ i ] ] == 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE
def fib ( f ) : NEW_LINE INDENT f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , 59 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 NEW_LINE DEDENT DEDENT def findLastDigit ( n ) : NEW_LINE INDENT f = [ 0 ] * 60 NEW_LINE fib ( f ) NEW_LINE index = n % 60 NEW_LINE return f [ index ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1 NEW_LINE print ( ob . findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( ob . findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( ob . findLastDigit ( n ) ) NEW_LINE n = 67 NEW_LINE print ( ob . findLastDigit ( n ) ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 5 and b == 7 and c == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 7 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif b == 7 and c == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE input = sys . stdin . readline NEW_LINE N , Z , W = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] NEW_LINE d = { } NEW_LINE def minmax ( x , y , c , f ) : NEW_LINE INDENT if ( c , f ) in d : NEW_LINE INDENT return d [ ( c , f ) ] NEW_LINE DEDENT if c == N : NEW_LINE INDENT return abs ( x - y ) NEW_LINE DEDENT if f == 0 : NEW_LINE INDENT ret = - float ( ' inf ' ) NEW_LINE for i in range ( 1 , N - c + 1 ) : NEW_LINE INDENT ret = max ( ret , minmax ( a [ c + i - 1 ] , y , c + i , f ^ 1 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ret = float ( ' inf ' ) NEW_LINE for i in range ( 1 , N - c + 1 ) : NEW_LINE INDENT ret = min ( ret , minmax ( x , a [ c + i - 1 ] , c + i , f ^ 1 ) ) NEW_LINE DEDENT DEDENT d [ ( c , f ) ] = ret NEW_LINE return ret NEW_LINE DEDENT print ( minmax ( Z , W , 0 , 0 ) ) NEW_LINE
def countEleLessThanOrEqual ( arr1 , arr2 , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr2 [ j ] <= arr1 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT return m NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE countEleLessThanOrEqual ( arr1 , arr2 , len ( arr1 ) , len ( arr2 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( min ( l [ 0 ] , l [ - 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( min ( l ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( l ) ) NEW_LINE DEDENT DEDENT
import sys , math , os NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT a , b = [ input ( ) . split ( ) for i in range ( n ) ] NEW_LINE if a == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE print ( a [ n // 2 ] ) NEW_LINE
import sys NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def main ( ) : NEW_LINE INDENT K , P = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE ans += int ( s [ - 1 ] ) NEW_LINE ans %= P NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE p = [ int ( x ) - 1 for x in input ( ) . split ( ) ] NEW_LINE p2 = sorted ( enumerate ( p ) , key = lambda x : x [ 1 ] , reverse = True ) NEW_LINE ans = 0 NEW_LINE s = [ - 1 , - 1 , n , n ] NEW_LINE for i , ( idx , p ) in enumerate ( p2 ) : NEW_LINE INDENT t = bisect . bisect_left ( s , idx ) NEW_LINE s . insert ( t , idx ) NEW_LINE l1 = s [ t - 1 ] NEW_LINE l2 = s [ t - 2 ] NEW_LINE r1 = s [ t + 1 ] NEW_LINE r2 = s [ t + 2 ] NEW_LINE ans += ( p + 1 ) * ( ( idx - l1 ) * ( r2 - r1 ) + ( r1 - idx ) * ( l1 - l2 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( seq [ i ] == seq [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is " , lps ( seq ) ) NEW_LINE DEDENT
def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = " ▁ " ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " ▁ + ▁ " , x , end = " " ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( last ) : NEW_LINE INDENT if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) : NEW_LINE INDENT print ( N , end = " ▁ = ▁ " ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b and a != 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif a <= b and a >= 2 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import gcd NEW_LINE def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = gcd ( x , y ) NEW_LINE ans = ( x * y ) / ( s * s ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 385 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE c = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c . append ( s [ i ] ) ; NEW_LINE DEDENT c . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbcc " ; NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def printKMax ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] > max ) : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( max , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE k = 3 NEW_LINE printKMax ( arr , len ( arr ) , k ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE class Impossible ( ValueError ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE lrds = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE lrds . append ( ( a , b ) ) NEW_LINE DEDENT adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE parents = [ i for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = lrds [ i ] NEW_LINE union ( parents , a , b ) NEW_LINE adj [ a ] . append ( b ) NEW_LINE adj [ b ] . append ( a ) NEW_LINE DEDENT ds = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ds . add ( find ( parents , i ) ) NEW_LINE DEDENT def find ( parents , i ) : NEW_LINE INDENT if i == parent [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT else : NEW_LINE INDENT root = find ( parents , i ) NEW_LINE if root == find ( parents , i ) : NEW_LINE INDENT return find ( parents , i ) NEW_LINE DEDENT DEDENT DEDENT def union ( parents , i , j ) : NEW_LINE INDENT root = find ( parents , j ) NEW_LINE union ( parents , i , j ) NEW_LINE DEDENT ds = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in adj [ i ] : NEW_LINE INDENT if ds . count ( j ) > 1 : NEW_LINE INDENT ds . add ( find ( parents , j ) , 1 ) NEW_LINE DEDENT DEDENT DEDENT result = len ( ds ) * ( len ( ds ) - len ( ds ) ) + root * ( root + 1 ) // 2 NEW_LINE print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE while a < m : NEW_LINE INDENT a += 1 NEW_LINE b += 1 NEW_LINE if a == n : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( max ( m - b , 0 ) ) NEW_LINE
import sys NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def main ( ) : NEW_LINE INDENT n , k = MI ( ) NEW_LINE xy = [ LI ( ) for _ in range ( n ) ] NEW_LINE ans = inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT x1 , y1 = xy [ i ] NEW_LINE for j , y2 in xy [ j : ] : NEW_LINE INDENT d = min ( y1 - y2 , x1 - x2 , y1 - y2 ) NEW_LINE if d == k : NEW_LINE INDENT ans = min ( ans , ( x2 - x1 ) * ( y2 - y1 ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( a [ m - 1 ] ) NEW_LINE
def pre_process ( substrings , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dup = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE s = s [ count : ] + dup NEW_LINE count += 1 NEW_LINE DEDENT DEDENT size = len ( substrings ) NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( substrings ) ) : NEW_LINE INDENT if ( substrings [ i ] > substrings [ j ] ) : NEW_LINE INDENT temp = substrings [ i ] NEW_LINE substrings [ i ] = substrings [ j ] NEW_LINE substrings [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT s = " geek " NEW_LINE substrings = [ 0 ] * 10 NEW_LINE pre_process ( substrings , s ) NEW_LINE queries = [ 1 , 5 , 10 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( substrings [ queries [ i ] - 1 ] ) NEW_LINE DEDENT
while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT h = w NEW_LINE flag = False NEW_LINE for _ in range ( h ) : NEW_LINE INDENT p = input ( ) NEW_LINE if p == " S " : NEW_LINE INDENT print ( h + 1 , w + 1 ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT elif p == " R " : NEW_LINE INDENT if flag : NEW_LINE INDENT w -= int ( p ) NEW_LINE flag = False NEW_LINE DEDENT continue NEW_LINE DEDENT if flag : NEW_LINE INDENT x = int ( p ) NEW_LINE y += int ( p ) NEW_LINE if y < h : NEW_LINE INDENT y = h NEW_LINE DEDENT flag = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT x += int ( p ) NEW_LINE if flag : NEW_LINE INDENT y -= int ( p ) NEW_LINE flag = False NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE x = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x + 2 ) NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while s != '0' : NEW_LINE INDENT if s [ 0 ] == '0' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif s [ 0 ] == '1' : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT DEDENT for i in range ( cnt ) : NEW_LINE INDENT s = s . replace ( ' A ' , str ( i ) ) NEW_LINE DEDENT print ( cnt , end = ' ▁ ' ) NEW_LINE DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == '0' : NEW_LINE INDENT break NEW_LINE DEDENT solve ( s ) NEW_LINE DEDENT
def fact ( N ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( N * N ) * fact ( N ) NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE DEDENT
for _ in range ( ( int ) ( input ( ) ) ) : NEW_LINE INDENT n , m = ( list ) ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( n * ( 9 - m ) ) NEW_LINE DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( left , right ) , max ( above , below ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 8 NEW_LINE B = 8 NEW_LINE X = 0 NEW_LINE Y = 0 NEW_LINE maximumArea ( L , B , X , Y ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallesteSubstr_maxDistictChar ( str , n ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = max_distinct_char ( str , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT  subs = None NEW_LINE if ( i < j ) : NEW_LINE INDENT  subs = str [ i : j ] NEW_LINE DEDENT else : NEW_LINE INDENT  subs = str [ j : i ] NEW_LINE DEDENT sub_distinct_char = max_distinct_char ( subs , subs_lenght ) NEW_LINE if ( subs_lenght < minl and max_distinct == sub_distinct_char ) : NEW_LINE INDENT minl = subs_lenght NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " AABBBCBB " NEW_LINE len = smallesteSubstr_maxDistictChar ( str ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : ▁ " , len ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( input ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE c = ' EMPTY ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b . index ( a [ i ] ) > 0 : NEW_LINE INDENT c += a [ i ] NEW_LINE DEDENT elif b . index ( a [ i ] ) < 0 : NEW_LINE INDENT c += ' NO ' NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 for i in range ( n ) ] NEW_LINE col = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] NEW_LINE y = q [ i ] [ 1 ] NEW_LINE row [ x - 1 ] += 1 NEW_LINE col [ y - 1 ] += 1 NEW_LINE DEDENT r1 , r2 , c1 , c2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] % 2 == 0 ) : NEW_LINE INDENT r1 += 1 NEW_LINE DEDENT if ( row [ i ] % 2 == 1 ) : NEW_LINE INDENT r2 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 0 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT count = r1 * c1 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE q = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 1 ] ] NEW_LINE size = len ( q ) NEW_LINE print ( findNumberOfEvenCells ( n , q , size ) ) NEW_LINE DEDENT
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkType ( arr , n ) ; NEW_LINE DEDENT
from sys import stdin , stdout NEW_LINE import sys NEW_LINE def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 2 ** 31 - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if s [ j ] != s [ i - j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = min ( ans , count ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE g = a * d - b * c NEW_LINE p = b * d NEW_LINE q = a * c - b * d NEW_LINE g1 = g NEW_LINE g2 = p // g1 NEW_LINE print ( p , q , sep = ' / ' ) NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 1 ] * ( x + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE rearrange ( arr , n ) ; NEW_LINE print ( arr ) ; NEW_LINE
def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( " % sth ▁ Centered ▁ square ▁ number ▁ : ▁ % d " % centered_square_num ( n ) ) NEW_LINE DEDENT
for s in [ * open ( 0 ) ] [ 1 : ] : n , k = map ( int , s . split ( ) ) ; print ( ' YNEOS ' [ n * k - n : : 2 ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k += a [ i ] NEW_LINE DEDENT print ( ( k // 2 ) ** 2 + ( n - k ) ** 2 ) NEW_LINE
def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def lenOfLongSubarrWithGivenSum ( arr , n , k ) : NEW_LINE INDENT um = { } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT if ( sum in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( sum - k in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - k ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - k ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT def lenLongSubarrWithGivenSum ( arr , n ) : NEW_LINE INDENT maxSum = maxSubArraySum ( arr , n ) NEW_LINE return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 2 , - 1 , 3 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ longest ▁ subarray ▁ having ▁ maximum ▁ sum ▁ = ▁ " , lenLongSubarrWithGivenSum ( arr , n ) ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 10 ** 6 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for k in range ( N ) : NEW_LINE INDENT if i > j and a [ k ] ** 2 == a [ j ] ** 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == N : NEW_LINE INDENT ans = max ( ans , a [ i ] * a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def find ( dividend , divisor , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return [ 0 , dividend ] ; NEW_LINE DEDENT mid = start + ( end - start ) // 2 ; NEW_LINE n = dividend - divisor * mid ; NEW_LINE if ( n > divisor ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT elif ( n < 0 ) : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == divisor ) : NEW_LINE INDENT mid += 1 ; NEW_LINE n = 0 ; NEW_LINE DEDENT return find ( dividend , divisor , start , end ) ; NEW_LINE DEDENT DEDENT def divide ( dividend , divisor ) : NEW_LINE INDENT return find ( dividend , divisor , 1 , dividend ) ; NEW_LINE DEDENT dividend = 10 ; divisor = 3 ; NEW_LINE ans = divide ( dividend , divisor ) ; NEW_LINE print ( ans [ 0 ] , " , " , ans [ 1 ] ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 , 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT d . append ( abs ( w [ i + 1 ] - w [ i ] ) ) NEW_LINE d . append ( abs ( w [ i + 1 ] - w [ i ] ) ) NEW_LINE DEDENT w = sorted ( d ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( w [ i - 1 ] , w [ i ] ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE ans = 0 NEW_LINE while l < n : NEW_LINE INDENT if a [ l ] > k * 2 : NEW_LINE INDENT for i in range ( l + 1 , n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l + 1 , n ) : NEW_LINE INDENT if a [ i ] > k * 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT l += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def towerOfHanoi ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move ▁ disk " , ( n - 1 ) , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE print ( " Move ▁ disk " , ( n - 1 ) , " from ▁ rod " , aux_rod2 , " to ▁ rod " , to_rod ) NEW_LINE towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT n = 4 NEW_LINE towerOfHanoi ( n , ' A ' , ' D ' , ' B ' , ' C ' ) NEW_LINE
import sys NEW_LINE import math NEW_LINE from bisect import bisect_left NEW_LINE from bisect import bisect_right NEW_LINE import collections NEW_LINE import copy NEW_LINE import heapq NEW_LINE from collections import defaultdict NEW_LINE from heapq import heappop , heappush NEW_LINE import itertools NEW_LINE input = sys . stdin . readline NEW_LINE def inputInt ( ) : return int ( input ( ) ) NEW_LINE def inputMap ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def inputList ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) NEW_LINE S = S [ : - 1 ] NEW_LINE mod = 10 ** 9 + 7 NEW_LINE pre = [ " [ " , " , " ] " , " - " , " . " ] NEW_LINE for ch in S [ : : - 1 ] : NEW_LINE INDENT pre . append ( ch ) NEW_LINE DEDENT ans = 0 NEW_LINE add = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == ' ? ' : NEW_LINE INDENT if add == 1 : NEW_LINE INDENT ans += pow ( 2 , i , mod ) NEW_LINE add = 0 NEW_LINE DEDENT elif S [ i ] == ' + ' : NEW_LINE INDENT add += 1 NEW_LINE DEDENT elif S [ i ] == ' - ' : NEW_LINE INDENT add -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += pow ( 2 , i , mod ) NEW_LINE add = 1 NEW_LINE DEDENT DEDENT pre = add NEW_LINE DEDENT print ( ans % mod ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def resolve ( ) : NEW_LINE INDENT import sys NEW_LINE import bisect NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE ans = dict ( ) NEW_LINE need_sort = True NEW_LINE sorted_keys = None NEW_LINE for _ in range ( n ) : NEW_LINE INDENT q , key , * x = input ( ) . split ( ) NEW_LINE if q == "0" : NEW_LINE INDENT if key in ans : NEW_LINE INDENT ans [ key ] = x [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans [ key ] = x [ 0 ] NEW_LINE need_sort = True NEW_LINE DEDENT DEDENT elif q == "1" : NEW_LINE INDENT if key in ans : NEW_LINE INDENT print ( ans [ key ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT elif q == "2" : NEW_LINE INDENT ans [ key ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT if sorted_keys is None : NEW_LINE INDENT sorted_keys = sorted ( ans . keys ( ) ) NEW_LINE DEDENT if need_sort : NEW_LINE INDENT sorted_keys = sorted ( ans . keys ( ) ) NEW_LINE need_sort = False NEW_LINE DEDENT l , r = key , x [ 0 ] NEW_LINE fr = bisect . bisect_left ( sorted_keys , l ) NEW_LINE to = bisect . bisect_right ( sorted_keys , r ) NEW_LINE if ans [ fr ] == "0" : NEW_LINE INDENT sorted_keys = sorted_keys [ : fr ] NEW_LINE DEDENT print ( sorted_keys [ to ] ) NEW_LINE DEDENT DEDENT DEDENT resolve ( ) NEW_LINE
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] <= prev ) : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 ; NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 ; NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k ; NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 7 ; NEW_LINE res = findN ( k ) ; NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ possible " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT DEDENT
import math as mt NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( mt . log2 ( max_ele ) ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE N , G = map ( int , readline ( ) . split ( ) ) NEW_LINE P = [ ] NEW_LINE C = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT d , c = map ( int , readline ( ) . split ( ) ) NEW_LINE P . append ( ( d , c ) ) NEW_LINE DEDENT K = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT D = P [ 0 ] NEW_LINE G = P [ 1 ] NEW_LINE for i in range ( D - 1 ) : NEW_LINE INDENT if P [ i ] == 1 : NEW_LINE INDENT s = 0 NEW_LINE for j in range ( 1 , D ) : NEW_LINE INDENT s += C [ j ] NEW_LINE DEDENT if s < G : NEW_LINE INDENT continue NEW_LINE DEDENT if i ^ ( 1 << j ) == 0 : NEW_LINE INDENT G -= 1 NEW_LINE DEDENT DEDENT write ( " % d \n " % P [ i ] ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if s == x : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a . sort ( ) NEW_LINE c = 0 NEW_LINE i = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ i ] < a [ j ] : NEW_LINE INDENT c += 1 NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( c ) NEW_LINE
import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = int ( math . pow ( 2 , int ( math . log ( n ) / math . log ( 2 ) ) ) ; NEW_LINE right = left * 2 ; NEW_LINE return min ( ( n - left ) , ( right - n ) ) ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( minAbsDiff ( n ) ) ; NEW_LINE
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr1 = [ 3 , 4 , 9 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( " Length ▁ of ▁ LCIS ▁ is " , LCIS ( arr1 , n , arr2 , m ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( x % 2 == 0 ) + countSetBitsUtil ( x // 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( " Total ▁ set ▁ bit ▁ count ▁ is " , countSetBits ( n ) ) NEW_LINE DEDENT
def partition ( arr , left , right ) : NEW_LINE INDENT pivot = arr [ left ] NEW_LINE i = low - 1 NEW_LINE j = right + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( arr [ i ] < pivot ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] > pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT return j NEW_LINE DEDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT def quickSort ( arr , left , right ) : NEW_LINE INDENT if ( left < right ) : NEW_LINE INDENT pi = partition ( arr , left , right ) NEW_LINE quickSort ( arr , left , pi ) NEW_LINE quickSort ( arr , pi + 1 , right ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT
def partition ( arr , left , right ) : NEW_LINE INDENT pivot = arr [ right ] NEW_LINE i = ( left - 1 ) NEW_LINE for j in range ( left , right ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr = arr [ : i ] + arr [ i + 1 : j ] + arr [ j + 1 : ] NEW_LINE DEDENT DEDENT arr = arr [ : i + 1 ] + arr [ i + 1 : right ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , left , right ) : NEW_LINE INDENT if ( left < right ) : NEW_LINE INDENT pi = partition ( arr , left , right ) NEW_LINE quickSort ( arr , left , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , right ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE printArray ( arr , n ) NEW_LINE
import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minPossibleSum ( a , n , x ) : NEW_LINE INDENT mxSum = maxSubArraySum ( a , n ) ; NEW_LINE Sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] ; NEW_LINE DEDENT Sum = Sum - mxSum + mxSum / x ; NEW_LINE print ( Sum ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE X = 2 ; NEW_LINE A = [ 1 , - 2 , 3 ] ; NEW_LINE minPossibleSum ( A , N , X ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE k = { } NEW_LINE while i < n : NEW_LINE INDENT k [ a [ i ] ] = i NEW_LINE i += 1 NEW_LINE DEDENT a = list ( reversed ( k ) ) NEW_LINE for x in a : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def printArray ( N , SUM , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) // 2 ; NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) // 2 ; NEW_LINE if ( minSum > SUM or maxSum < SUM ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) ; NEW_LINE return ; NEW_LINE DEDENT arr = [ 0 ] * ( N + 1 ) ; NEW_LINE sum = minSum ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT arr [ i ] = i ; NEW_LINE DEDENT sum = sumSum ; NEW_LINE for i in range ( N >= 1 ) : NEW_LINE INDENT x = sum + ( K - i ) ; NEW_LINE if ( x < SUM ) : NEW_LINE INDENT sum = sum + ( K - i ) ; NEW_LINE arr [ i ] = K ; NEW_LINE K -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( SUM - sum ) ; NEW_LINE sum = SUM ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; SUM = 15 ; K = 8 ; NEW_LINE printArray ( N , SUM , K ) ; NEW_LINE DEDENT
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST ; NEW_LINE x %= COST ; NEW_LINE type2 = y // COST ; NEW_LINE y %= COST ; NEW_LINE type3 = z // COST ; NEW_LINE z %= COST ; NEW_LINE type4 = min ( x , min ( y , z ) ) ; NEW_LINE maxItems = type1 + type2 + type3 + type4 ; NEW_LINE return maxItems ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 4 ; y = 5 ; z = 6 ; NEW_LINE print ( maxItems ( x , y , z ) ) ; NEW_LINE DEDENT
def run_tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) > 0 ) : NEW_LINE INDENT x = A [ 0 ] NEW_LINE y = B [ 0 ] NEW_LINE if ( x == y ) : NEW_LINE INDENT A . pop ( 0 ) NEW_LINE total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT A . pop ( 0 ) NEW_LINE A . append ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT A = [ 3 , 2 , 1 , 4 ] NEW_LINE A . append ( 1 ) NEW_LINE A . append ( 4 ) NEW_LINE B = [ 2 , 3 , 2 ] NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 3 ) NEW_LINE B . append ( 2 ) NEW_LINE print ( run_tasks ( A , B ) ) NEW_LINE
def line ( x0 , y0 ) : NEW_LINE INDENT c = ( 2 * y0 * x0 ) NEW_LINE print ( " { 0 : . 1 f } " . format ( y0 ) , " x " , " + " , " % . 1 f " , x0 ) , " y ▁ = ▁ " , c ) NEW_LINE DEDENT x0 = 4 ; NEW_LINE y0 = 3 ; NEW_LINE line ( x0 , y0 ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT ans = " " NEW_LINE for i in set ( s ) : NEW_LINE INDENT t = " " NEW_LINE for j in s : NEW_LINE INDENT if ( j not in t ) : NEW_LINE INDENT t += j NEW_LINE DEDENT DEDENT ans += t . count ( t [ - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE import math NEW_LINE def angleis ( p1 , p2 ) : NEW_LINE INDENT return True if p1 [ 0 ] * p2 [ 1 ] - p1 [ 1 ] * p2 [ 0 ] > 0 else False NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT c = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ 0 , 0 , 0 , 1 ] NEW_LINE b = [ 0 , 0 , 0 , 1 ] NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c [ i ] = c [ i - 1 ] * p [ i ] + p [ i - 2 ] * p [ i - 1 ] NEW_LINE DEDENT for i in range ( 2 ) : NEW_LINE INDENT if angleis ( c [ i ] , b [ i ] ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT unique [ s [ i ] ] = 1 NEW_LINE DEDENT if len ( unique ) > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaab " NEW_LINE if isAnyNotPalindrome ( s ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d = input ( ) NEW_LINE if d == " North " : NEW_LINE INDENT x += int ( d ) NEW_LINE DEDENT elif d == " South " : NEW_LINE INDENT x -= int ( d ) NEW_LINE DEDENT elif d == " East " : NEW_LINE INDENT x += int ( d ) NEW_LINE DEDENT if x < 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 for i in range ( 3 ) ] NEW_LINE arr [ 0 ] = a NEW_LINE arr [ 1 ] = b NEW_LINE arr [ 2 ] = c NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a1 = 6 NEW_LINE b1 = 3 NEW_LINE c1 = 2 NEW_LINE k1 = 7 NEW_LINE if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def insert ( x , y ) : NEW_LINE INDENT adjacent = [ [ ] ] * N NEW_LINE visited [ x ] = 0 NEW_LINE def dfs ( node , leaf , vis ) : NEW_LINE INDENT leaf [ node ] = 0 NEW_LINE vis [ node ] = 1 NEW_LINE for i in range ( len ( adjacency [ node ] ) ) : NEW_LINE INDENT it = adjacency [ node ] [ i ] NEW_LINE if ( vis [ it ] == 0 ) : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_LINE leaf [ node ] += leaf [ it ] NEW_LINE DEDENT DEDENT if ( len ( adjacency [ node ] ) == 0 ) : NEW_LINE INDENT leaf [ node ] = 1 NEW_LINE DEDENT DEDENT def printLeaf ( n , leaf ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " The ▁ node ▁ " , i , " ▁ has ▁ " , leaf [ i ] , " ▁ leaf ▁ nodes " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT adjacent = [ [ ] for i in range ( N + 1 ) ] NEW_LINE DEDENT insert ( 1 , 2 ) NEW_LINE insert ( 1 , 3 ) NEW_LINE insert ( 3 , 4 ) NEW_LINE insert ( 3 , 5 ) NEW_LINE insert ( 3 , 6 ) NEW_LINE leaf = [ 0 ] * N + 1 NEW_LINE vis = [ 0 ] * N + 1 NEW_LINE dfs ( 1 , leaf , vis ) NEW_LINE printLeaf ( N , leaf ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = str ( n ) [ : : - 1 ] NEW_LINE a = len ( s ) NEW_LINE if k >= a or s . count ( '1' ) < k : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT if s [ i ] != '0' : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE if s1 == s2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = [ 0 ] * 26 NEW_LINE b = [ 0 ] * 26 NEW_LINE for i in s1 : NEW_LINE INDENT if i in s2 : NEW_LINE INDENT a [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in s2 : NEW_LINE INDENT if i in a : NEW_LINE INDENT c += a [ ord ( i ) - ord ( ' a ' ) ] NEW_LINE DEDENT else : NEW_LINE INDENT c += b [ ord ( i ) - ord ( ' a ' ) ] NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( o + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT X = " AGGT12" NEW_LINE Y = "12TXAYB " NEW_LINE Z = "12XBA " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( " Length ▁ of ▁ LCS ▁ is " , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE
import math NEW_LINE import sys NEW_LINE import itertools NEW_LINE import queue NEW_LINE from fractions import gcd NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return a * b // gcd ( a , b ) NEW_LINE DEDENT mod = 1000000007 NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] NEW_LINE cost = sum ( abs ( a [ i + 1 ] - a [ i ] ) for i in range ( n - 1 ) ) NEW_LINE print ( cost ) NEW_LINE DEDENT
def isSpiltPossible ( n , a ) : NEW_LINE INDENT sum = 0 ; NEW_LINE c1 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( ( sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE a = [ 1 , 1 , 2 ] ; NEW_LINE if ( isSpiltPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE k = l . count ( 1 ) NEW_LINE if ( 1 in l ) : NEW_LINE INDENT print ( l [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l [ - 1 ] ) NEW_LINE DEDENT
def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True NEW_LINE  aeven = False NEW_LINE n = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] ; b = steps [ i ] [ 1 ] NEW_LINE if ( not ( aeven or ( a & 1 ) > 0 ) ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif ( not ( ( a & 1 ) > 0 ) ) : NEW_LINE INDENT if ( not ( ( b & 1 ) > 0 ) ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if ( beven ) : NEW_LINE INDENT even = ( max // 2 - ( min - 1 ) // 2 ) NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = ( max // 2 - ( min - 1 ) // 2 ) NEW_LINE odd = 0 NEW_LINE DEDENT if ( not ( beven ^ aeven ) ) : NEW_LINE INDENT even += max - min + 1 - ( max // 2 + ( min - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += max - min + 1 - ( max // 2 + ( min - 1 ) // 2 ) NEW_LINE DEDENT print ( " even ▁ = " , even , " , ▁ odd ▁ = " , odd ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT min = 1 NEW_LINE max = 4 NEW_LINE steps = [ [ 1 , 2 ] , [ 3 , 4 ] ] NEW_LINE count_even_odd ( min , max , steps ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n + k - 1 ) // k ) NEW_LINE
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) ; NEW_LINE p_factors = [ 0 ] * ( B + 1 ) ; NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = 14 ; B = 18 ; K = 2 ; NEW_LINE printKPFNums ( A , B , K ) ; NEW_LINE DEDENT
def reverseWords ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( len ( st ) == 0 ) : NEW_LINE INDENT print ( st [ - 1 ] , end = " ▁ " ) NEW_LINE DEDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT while ( len ( st ) == 0 ) : NEW_LINE INDENT print ( st [ - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " Geeks ▁ for ▁ Geeks " NEW_LINE reverseWords ( str ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 and b [ i ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif a [ i ] == 0 and b [ i ] == 1 : NEW_LINE INDENT ans += - 1 NEW_LINE DEDENT DEDENT if ans == - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans // ans ) NEW_LINE DEDENT
import math NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n == 1 : return False NEW_LINE for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % k == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT x = [ i for i in range ( 2 , 55556 ) if is_prime ( i ) and i % 2 == 1 ] NEW_LINE print ( x [ 0 ] , end = ' ▁ ' ) NEW_LINE n = int ( input ( ) ) NEW_LINE print ( '2 ▁ ' * ( n + 1 ) , end = ' ▁ ' ) NEW_LINE
import sys NEW_LINE def solve ( data ) : NEW_LINE INDENT ans = 0.0 NEW_LINE for d in data : NEW_LINE INDENT if d == " . " : NEW_LINE INDENT ans += int ( d ) NEW_LINE DEDENT elif d == " + " : NEW_LINE INDENT ans += int ( d ) NEW_LINE DEDENT elif d == " - " : NEW_LINE INDENT ans -= int ( d ) NEW_LINE DEDENT elif d == " * " : NEW_LINE INDENT ans *= int ( d ) NEW_LINE DEDENT elif d == " / " : NEW_LINE INDENT ans = ans / int ( d ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT data = [ ] NEW_LINE for line in sys . stdin : NEW_LINE INDENT data . append ( list ( map ( str , line . split ( ) ) ) ) NEW_LINE DEDENT solve ( data ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) ; print ( 0 - - n * ( k + 1 ) // n ) NEW_LINE
from math import pow NEW_LINE def findNthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE print ( pow ( 3 , n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( pow ( 2 , n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE N = 11 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) // 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNonIncreasing ( arr , n ) ) NEW_LINE
def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE sum += A1 [ i ] NEW_LINE DEDENT temp = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( c [ i ] < c [ i + 1 ] ) : NEW_LINE INDENT temp = c [ i ] NEW_LINE c [ i ] = c [ i + 1 ] NEW_LINE c [ i + 1 ] = temp NEW_LINE DEDENT DEDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT A1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE A2 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = 5 NEW_LINE x = 3 NEW_LINE y = 3 NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = input ( ) NEW_LINE res = int ( " " . join ( n ) ) NEW_LINE print ( res ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 2147483647 ) NEW_LINE INF = float ( " inf " ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def bisection ( l , r , f , left = True , discrete = True ) : NEW_LINE INDENT eps = 1 if ( discrete ) else 10 ** - 8 NEW_LINE if ( ( not left ) ^ f ( r ) ) : return r if ( left ) else r + 1 NEW_LINE elif ( left ^ f ( l ) ) : return l - 1 if ( left ) else l NEW_LINE while ( r - l > eps ) : NEW_LINE INDENT h = ( l + r ) // 2 if ( discrete ) else ( l + r ) / 2 NEW_LINE if ( ( not left ) ^ f ( h ) ) : l = h NEW_LINE else : r = h NEW_LINE DEDENT return ( l + r ) / 2 if ( not discrete ) else l if ( left ) else r NEW_LINE DEDENT from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE N = int ( input ( ) ) NEW_LINE D = defaultdict ( int ) NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE D [ a - 1 ] [ b - 1 ] = c NEW_LINE D [ b - 1 ] [ a - 1 ] = d NEW_LINE DEDENT P = list ( map ( int , input ( ) . split ( ' , ' ) ) ) NEW_LINE print ( bisection ( 0 , N , False , recursive = True ) ) NEW_LINE
r1 , r2 , c1 , c2 , d1 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE if r1 + r2 + c1 + d2 == 0 and c1 + c2 == r1 + d2 : NEW_LINE INDENT print ( 0 , 0 , 0 , 0 ) NEW_LINE DEDENT elif r1 + r2 + c1 + d2 == r1 + d2 : NEW_LINE INDENT print ( '0 ▁ 0 ▁ 0' , c1 , d1 , d2 ) NEW_LINE DEDENT elif r1 + r2 + c1 == r2 + c2 : NEW_LINE INDENT print ( '0 ▁ 0 ▁ 0' , c1 , d2 ) NEW_LINE DEDENT else : NEW_LINE INDENT c = ( r1 + r2 + c1 ) // 2 NEW_LINE a = d1 + c2 - a NEW_LINE b = d2 + c1 - b NEW_LINE c = ( d1 + c2 ) // 2 NEW_LINE if a < 1 or b < 1 or c < 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT alst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE wlst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE add_list = [ ] NEW_LINE for a in alst : NEW_LINE INDENT add_list . append ( a ) NEW_LINE DEDENT add_list = [ ] NEW_LINE for b in wlst : NEW_LINE INDENT add_list . append ( b - a ) NEW_LINE DEDENT add_list . sort ( reverse = True ) NEW_LINE idx = 0 NEW_LINE for a in add_list : NEW_LINE INDENT if a == idx : NEW_LINE INDENT break NEW_LINE DEDENT num_add = len ( add_list ) NEW_LINE add_list = [ add_list [ 0 ] ] * num_add NEW_LINE add_list = add_list [ 1 : idx + 1 ] NEW_LINE if num_add > len ( add_list ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if num_add < len ( add_list ) : NEW_LINE INDENT break NEW_LINE DEDENT idx += 1 NEW_LINE DEDENT ans = - 1 NEW_LINE for a in add_list : NEW_LINE INDENT if a in add_list : NEW_LINE INDENT ans = a NEW_LINE break NEW_LINE DEDENT DEDENT if ans == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def solve ( ) : NEW_LINE INDENT from sys import stdin NEW_LINE f_i = stdin NEW_LINE n = int ( f_i . readline ( ) ) NEW_LINE s = f_i . readline ( ) . rstrip ( ) NEW_LINE ans = f ( ) NEW_LINE dp = [ float ( ' inf ' ) ] * ( 1 << 7 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT if j < 2 ** ( 7 - i ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + v NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ j ] + v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( dp [ - 1 ] if dp [ - 1 ] < float ( ' inf ' ) else - 1 ) NEW_LINE DEDENT solve ( ) NEW_LINE
def startsWith ( str , pre ) : NEW_LINE INDENT strLen = len ( str ) NEW_LINE preLen = len ( pre ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < strLen and j < preLen ) : NEW_LINE INDENT if ( str [ i ] != pre [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def endsWith ( str , suff ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if ( str [ i ] != suff [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkString ( str , a , b ) : NEW_LINE INDENT if ( len ( str ) != len ( a ) + len ( b ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( startsWith ( str , a ) ) : NEW_LINE INDENT if ( endsWith ( str , b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( startsWith ( str , b ) ) : NEW_LINE INDENT if ( endsWith ( str , a ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE a = " Geeksfo " NEW_LINE b = " rGeeks " NEW_LINE if ( checkString ( str , a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 ) : NEW_LINE INDENT for k in range ( 0 , ( n - i - j ) + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE
T10 = 10 NEW_LINE def digitSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT Sum += n % T10 NEW_LINE n //= T10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT Sum = digitSum ( n ) NEW_LINE if ( Sum % T10 == 0 ) : NEW_LINE INDENT return ( n * T10 ) NEW_LINE DEDENT extra = T10 - ( Sum % T10 ) NEW_LINE return ( ( n * T10 ) + extra ) NEW_LINE DEDENT def firstNTTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE firstNTTerms ( n ) NEW_LINE
def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT if ( ( a & 1 ) > 0 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , N // 3 ) NEW_LINE DEDENT if ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , ( N // 3 ) - 1 ) NEW_LINE DEDENT if ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , N // 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT maxProduct = breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE DEDENT
import math NEW_LINE read = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE f = [ 0 ] * ( 10 ** 6 + 1 ) NEW_LINE for i in range ( 2 , 10 ** 6 + 1 ) : NEW_LINE INDENT if f [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT f [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , 10 ** 6 + 1 ) : NEW_LINE INDENT if f [ i ] : NEW_LINE INDENT n -= f [ i ] NEW_LINE f [ i ] = 0 NEW_LINE DEDENT DEDENT if n > 1 : NEW_LINE INDENT f [ n ] = 1 NEW_LINE DEDENT for i in range ( 1 , 10 ** 6 + 1 ) : NEW_LINE INDENT n = f [ n ] NEW_LINE f [ n ] = 1 NEW_LINE DEDENT print ( n ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE return s . replace ( '2019' , ' ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def firstNonRepeating ( str ) : NEW_LINE INDENT charCount = [ 0 ] * MAX_CHAR NEW_LINE q = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE q . append ( ch ) NEW_LINE charCount [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT if ( charCount [ ord ( q [ 0 ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q [ 0 ] , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( len ( q ) == 0 ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " aabc " NEW_LINE firstNonRepeating ( str ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE class Unionfind : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . par = [ i for i in range ( n ) ] NEW_LINE self . rank = [ 1 ] * n NEW_LINE DEDENT def root ( self , x ) : NEW_LINE INDENT p = self . par [ x ] NEW_LINE while not p : NEW_LINE INDENT p = self . par [ p ] NEW_LINE DEDENT for x in p : NEW_LINE INDENT self . par [ x ] = p NEW_LINE DEDENT return p NEW_LINE DEDENT def unite ( self , x , y ) : NEW_LINE INDENT rx , ry = self . root ( x ) , self . root ( y ) NEW_LINE if rx == ry : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ rx ] < self . rank [ ry ] : NEW_LINE INDENT self . par [ ry ] += self . par [ rx ] NEW_LINE self . par [ rx ] = ry NEW_LINE if self . rank [ rx ] == self . rank [ ry ] : NEW_LINE INDENT self . rank [ ry ] += 1 NEW_LINE DEDENT DEDENT DEDENT def same ( self , x , y ) : NEW_LINE INDENT return self . root ( x ) == self . root ( y ) NEW_LINE DEDENT def count ( self , x ) : NEW_LINE INDENT return - self . par [ self . root ( x ) ] NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE edges = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) ] NEW_LINE uf = Unionfind ( n ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT uf . unite ( i , j ) NEW_LINE DEDENT edges . sort ( key = lambda e : e [ 2 ] ) NEW_LINE ans = 0 NEW_LINE for a , b in edges : NEW_LINE INDENT if a > b : NEW_LINE INDENT ans += n - a - b NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def solve ( n , m , obstacles , range ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE range . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT range [ i ] = 2 * range [ i ] NEW_LINE val -= range [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n , m = 4 , 5 , 3 NEW_LINE range = [ 1.0 , 1.25 , 1.15 ] NEW_LINE print ( solve ( n , m , obstacles , range ) ) NEW_LINE
a = input ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( input ( ) ) NEW_LINE if a == str ( a ) : NEW_LINE INDENT print ( " U " ) NEW_LINE DEDENT elif a == str ( a ) : NEW_LINE INDENT print ( " M " ) NEW_LINE DEDENT elif a == str ( a ) : NEW_LINE INDENT print ( " L " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " I " ) NEW_LINE DEDENT
class MinStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . minStack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT if len ( self . stack ) == 0 or x <= self . minStack [ - 1 ] : NEW_LINE INDENT self . minStack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . minStack . append ( self . stack [ - 1 ] ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT self . stack . pop ( ) NEW_LINE DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ 0 ] NEW_LINE DEDENT def min ( self , x ) : NEW_LINE INDENT return self . minStack [ - 1 ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = MinStack ( ) NEW_LINE m . push ( - 2 ) NEW_LINE m . push ( 0 ) NEW_LINE m . push ( - 3 ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE m . pop ( ) NEW_LINE print ( m . top ( ) ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE DEDENT
one = [ " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT string = " " ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT string += ten [ n // 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT string += one [ n ] ; NEW_LINE DEDENT if ( n != 0 ) : NEW_LINE INDENT string += s ; NEW_LINE DEDENT return string ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = " " ; NEW_LINE print ( numToWords ( ( n // 10000000 ) , " crore ▁ " ) ; NEW_LINE print ( numToWords ( ( n // 100000 ) % 100 ) , " lakh ▁ " ) ; NEW_LINE print ( numToWords ( ( n // 1000 ) % 100 ) , " thousand ▁ " ) ; NEW_LINE print ( numToWords ( ( n // 100 ) % 10 ) , " hundred " ) ; NEW_LINE if ( n > 100 and n % 100 > 0 ) : NEW_LINE INDENT out += " and ▁ " ; NEW_LINE DEDENT print ( " " , " " , numToWords ( ( n // 1000 ) % 100 ) , " thousand ▁ " ) ; NEW_LINE print ( numToWords ( ( n // 100 ) % 10 ) , " hundred " ) ; NEW_LINE if ( n > 100 and n % 100 > 0 ) : NEW_LINE INDENT out += " and ▁ " ; NEW_LINE DEDENT return out ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT numToWords (
def flipSign ( a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = 1 if ( a < 0 ) else - 1 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE DEDENT def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipSign ( b ) NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return mul ( b , a ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( abs ( b ) , - 1 , - 1 ) : NEW_LINE INDENT sum += a NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT sum = flipSign ( sum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT quotient = 0 NEW_LINE divisor = flipSign ( abs ( b ) ) NEW_LINE for dividend in range ( abs ( a ) , abs ( divisor ) , divisor ) : NEW_LINE INDENT quotient += 1 NEW_LINE DEDENT if ( areDifferentSign ( a , b ) ) : NEW_LINE INDENT quotient = flipSign ( quotient ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT print ( " Subtraction ▁ is " , sub ( 4 , - 2 ) ) NEW_LINE print ( " Product ▁ is " , mul ( - 9 , 6 ) ) NEW_LINE print ( " Division ▁ is " , division ( 8 , 2 ) ) NEW_LINE
def factorial ( n ) : NEW_LINE INDENT i = n ; fact = 1 NEW_LINE while ( n // i != n ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT num = 5 ; NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( num ) ) NEW_LINE
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( ( number % x == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE from collections import Counter NEW_LINE b = [ ] NEW_LINE for i in a : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT c = Counter ( b ) NEW_LINE ans = 0 NEW_LINE for i in c . values ( ) : NEW_LINE INDENT ans += i * ( i - 1 ) // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) // k NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = 4 NEW_LINE k = 5 NEW_LINE print ( min_noOf_operation ( arr , N , k ) ) NEW_LINE DEDENT
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = pow ( 2 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 6 , 7 ] NEW_LINE X = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubSet ( arr , n , X ) ) NEW_LINE DEDENT
n = 5 NEW_LINE def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 1 ) <= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 1 ] , [ 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 1 , 0 ] , [ 9 , 6 , 4 , 2 , 3 ] ] NEW_LINE n = 5 NEW_LINE print ( FindMaxProduct ( arr , n ) ) NEW_LINE DEDENT
MAX = 50002 ; NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime = [ True ] * MAX ; NEW_LINE p = 2 ; NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i < MAX ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE z = y ; NEW_LINE while ( x >= z ) : NEW_LINE INDENT count += int ( x / z ) ; NEW_LINE z *= y ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def modMult ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b //= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT def countWays ( n , m ) : NEW_LINE INDENT ans = 1 ; NEW_LINE for i in range ( 1 , len ( primes ) ) : NEW_LINE INDENT powers = power ( n , primes [ i ] ) ; NEW_LINE if ( powers == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans = modMult ( ans , powers + 1 , m ) % m ; NEW_LINE DEDENT if ( ( ans - 1 ) % m ) < 0 : NEW_LINE INDENT return ( ans - 1 + m ) % m ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans - 1 ) % m ; NEW_LINE DEDENT DEDENT sieve ( ) ; NEW_LINE n = 4 ; NEW_LINE m = 7 ; NEW_LINE print ( countWays ( n , m ) ) ; NEW_LINE
def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestIndexsum ( arr , n ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE a , b = map ( int , s . split ( ' : ' ) ) NEW_LINE c = int ( s [ 2 : ] ) NEW_LINE d = int ( s [ 4 : ] ) NEW_LINE print ( abs ( a - d ) // 1000 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( sum ( [ ( len ( i ) - 1 ) // 3 for i in ( s . split ( ' A ' ) + s . split ( ' Q ' ) ) ] ) ) NEW_LINE
import sys NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE import itertools NEW_LINE N , K , * A = map ( int , read ( ) . split ( ) ) NEW_LINE A = [ x if x <= K else K + 1 for x in A ] NEW_LINE A . sort ( ) NEW_LINE mask = ( 1 << K ) - 1 NEW_LINE def test ( x ) : NEW_LINE INDENT if A [ x ] > K : NEW_LINE INDENT return True NEW_LINE DEDENT dp = 1 NEW_LINE for a in itertools . chain ( A [ : x ] , A [ x + 1 : ] ) : NEW_LINE INDENT dp |= ( dp << a ) NEW_LINE dp &= mask NEW_LINE DEDENT dp >>= ( K - A [ x ] ) NEW_LINE return ( dp > 0 ) NEW_LINE DEDENT left = - 1 NEW_LINE right = N NEW_LINE while left + 1 < right : NEW_LINE INDENT x = ( left + right ) // 2 NEW_LINE if test ( x ) : NEW_LINE INDENT right = x NEW_LINE DEDENT else : NEW_LINE INDENT left = x NEW_LINE DEDENT DEDENT answer = left + 1 NEW_LINE print ( answer ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( s + ( n - 1 ) // n ) * ( s + ( n - 1 ) // n ) ) NEW_LINE
import math NEW_LINE v = [ ] NEW_LINE def multiply ( x ) : NEW_LINE INDENT carry = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT res = ( carry + v [ i ] * x ) NEW_LINE v [ i ] = res % 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT while ( carry ) : NEW_LINE INDENT v . append ( carry % 10 ) NEW_LINE carry = ( int ) ( math . floor ( math . log ( v [ 0 ] ) ) ) NEW_LINE DEDENT DEDENT def findSumOfDigits ( n ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT multiply ( i ) NEW_LINE DEDENT sum = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1000 NEW_LINE print ( findSumOfDigits ( n ) ) NEW_LINE
n , m , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE x = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] == " U " : NEW_LINE INDENT x [ j ] += 1 NEW_LINE DEDENT elif a [ i ] [ j ] == " D " : NEW_LINE INDENT x [ j ] += 1 NEW_LINE DEDENT elif a [ i ] [ j ] == " L " : NEW_LINE INDENT x [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT output = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT output . append ( str ( x [ i ] ) + " ▁ " ) NEW_LINE DEDENT output . sort ( ) NEW_LINE print ( " ▁ " . join ( output ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( range ) NEW_LINE nq = int ( input ( ) ) NEW_LINE for _ in range ( nq ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE w [ a - 1 ] = c NEW_LINE while w [ a - 1 ] > c : NEW_LINE INDENT w [ a - 1 ] , w [ a - 1 ] = w [ a - 1 ] , w [ a - 1 ] NEW_LINE DEDENT w [ a - 1 ] = 0 NEW_LINE DEDENT print ( * w ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE mx = a [ - 1 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE if ( a [ i ] == mx ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( mx - a [ i ] + 1 ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , n ** 2 + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT DEDENT n = n ** 2 NEW_LINE for i in range ( n * n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i % 2 == j : NEW_LINE INDENT print ( a [ i ] , b [ i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ j ] , b [ j - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def printSmall ( arr , asize , n ) : NEW_LINE INDENT copy_arr = [ 0 ] * asize NEW_LINE copy_arr [ 0 ] = arr [ asize ] NEW_LINE copy_arr [ 1 ] = arr [ 0 ] NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , asize ) : NEW_LINE INDENT if ( copy_arr [ 0 : n ] . count ( arr [ i ] ) > - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT k = 0 ; NEW_LINE count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += pow ( 2 , k ) ; NEW_LINE DEDENT k += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 ; NEW_LINE print ( countNumbers ( n ) ) ; NEW_LINE DEDENT
n , m , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= s : NEW_LINE INDENT e = a [ i ] NEW_LINE DEDENT DEDENT t = s // ( a [ n - 1 ] ) NEW_LINE print ( e * t + s ) NEW_LINE
import sys NEW_LINE maximum = - ( sys . maxsize - 1 ) NEW_LINE ans = sys . maxsize NEW_LINE graph = [ ] NEW_LINE weight = [ 0 ] * 60 NEW_LINE def __builtin_popcount ( x ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT if ( ( x >> i ) & 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT a = __builtin_popcount ( weight [ node ] + x ) NEW_LINE if maximum < a : NEW_LINE INDENT maximum = a NEW_LINE ans = node NEW_LINE DEDENT elif maximum == a : NEW_LINE INDENT ans = min ( ans , node ) NEW_LINE DEDENT for to in graph [ node ] : NEW_LINE INDENT if to == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node ) NEW_LINE DEDENT DEDENT x = 15 NEW_LINE weight [ 1 ] = 5 NEW_LINE weight [ 2 ] = 10 NEW_LINE weight [ 3 ] = 11 NEW_LINE weight [ 4 ] = 8 NEW_LINE weight [ 5 ] = 6 NEW_LINE graph . append ( [ 2 , 3 , 4 , 5 ] ) NEW_LINE graph . append ( [ 1 , 1 , 1 ] ) NEW_LINE print ( ans ) NEW_LINE
MAX = 26 ; NEW_LINE def updateFreq ( string , freq ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT def maxCount ( string , patt ) : NEW_LINE INDENT stringFreq = [ 0 ] * MAX ; NEW_LINE updateFreq ( string , stringFreq ) ; NEW_LINE factorulFreq = [ 0 ] * MAX ; NEW_LINE updateFreq ( patt , pattFreq ) ; NEW_LINE ans = 10 ** 9 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( pattFreq [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT ans = min ( ans , int ( stringFreq [ i ] / pattFreq [ i ] ) ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " ; NEW_LINE patternulFreq = " geeks " ; NEW_LINE print ( maxCount ( string , patt ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( res , res | a [ i ] + b [ i ] ) NEW_LINE DEDENT print ( res ) NEW_LINE
import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n , l , r , a , b = _input ( ) NEW_LINE w = list ( _input ( ) ) NEW_LINE s = list ( 0 ) * ( n + 1 ) NEW_LINE for i in range ( n ) : w [ i ] = w [ i ] + w [ i + 1 ] NEW_LINE s . insert ( 0 , 0 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s [ i ] += w [ i - 1 ] NEW_LINE DEDENT ans = math . inf NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if i - l + 1 >= 0 : NEW_LINE INDENT ans = min ( ans , ( w [ i - l ] - w [ i - l ] ) * a + ( s [ i - l ] - s [ i - l - 1 ] ) * b ) NEW_LINE DEDENT if i - r - 1 >= 0 : NEW_LINE INDENT ans = min ( ans , ( w [ i - r - 1 ] - w [ i - r - 1 ] ) * a + ( s [ i - r - 1 ] - s [ i - r - 1 ] ) * b ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def wastedWater ( V , M , N ) : NEW_LINE INDENT  amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE
def maxSubStr ( string , n ) : NEW_LINE INDENT count0 = 0 ; count1 = 0 ; NEW_LINE cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 ; NEW_LINE DEDENT if ( count0 == count1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( count0 != count1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "0100110101" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( maxSubStr ( string , n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def solve ( X : int , Y : int , Z : int ) : NEW_LINE INDENT print ( " { } ▁ { } " . format ( Z , X ) ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE X = int ( next ( tokens ) ) NEW_LINE Y = int ( next ( tokens ) ) NEW_LINE Z = int ( next ( tokens ) ) NEW_LINE solve ( X , Y , Z ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n ; NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = 15 ; NEW_LINE n = findS ( s ) ; NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) ; NEW_LINE DEDENT DEDENT
def maximumAbsolute ( arr , n ) : NEW_LINE INDENT mn = + 2147483647 NEW_LINE mx = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = max ( mx , arr [ i - 1 ] ) NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max ( mx , arr [ i + 1 ] ) NEW_LINE DEDENT DEDENT common_integer = ( mn + mx ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == - 1 ) : NEW_LINE INDENT arr [ i ] = common_integer NEW_LINE DEDENT DEDENT max_diff = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE if ( diff > max_diff ) : NEW_LINE INDENT max_diff = diff NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , - 1 , 11 , - 1 , 3 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumAbsolute ( arr , n ) ) NEW_LINE DEDENT
MOD = 1000000007 ; NEW_LINE def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for i in range ( N + 1 ) ] ; NEW_LINE dp [ 1 ] [ 0 ] = 1 ; NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE dp [ 1 ] [ 2 ] = 0 ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE print ( countStrings ( N ) ) ; NEW_LINE DEDENT
def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE max_length = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) ; NEW_LINE lower = max ( 0 , curr - k ) ; NEW_LINE upper = min ( 25 , curr + k ) ; NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) ; NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in dp : NEW_LINE INDENT ans = max ( i , ans ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " ; NEW_LINE n = len ( s ) ; NEW_LINE k = 3 ; NEW_LINE print ( longest_subseq ( n , k , s ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = - sys . maxsize - 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT len = len + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE
def minimumSubarrays ( ar , n ) : NEW_LINE INDENT se = [ ] ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ar [ i ] not in se ) : NEW_LINE INDENT se . append ( ar [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 ; NEW_LINE se . clear ( ) ; NEW_LINE se . append ( ar [ i ] ) ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 ] ; NEW_LINE n = len ( ar ) ; NEW_LINE print ( minimumSubarrays ( ar , n ) ) ; NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while s : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if xor__ == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = 122233 NEW_LINE if check ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE k = s // m NEW_LINE for i in l : NEW_LINE INDENT k -= s - i NEW_LINE s -= k // m NEW_LINE k = k % m NEW_LINE DEDENT print ( k , end = " ▁ " ) NEW_LINE
MAXN = 1000005 NEW_LINE even = [ 0 ] * MAXN ; NEW_LINE odd = [ 0 ] * MAXN ; NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd [ i ] = 1 ; NEW_LINE DEDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even [ i ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] ; NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] ; NEW_LINE DEDENT DEDENT def isOdd ( L , R ) : NEW_LINE INDENT cnt = odd [ R ] ; NEW_LINE if ( L > 0 ) : NEW_LINE INDENT cnt -= odd [ L - 1 ] ; NEW_LINE DEDENT if ( cnt == R - L + 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def performQueries ( a , n , q , m ) : NEW_LINE INDENT precompute ( a , n ) ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT L = q [ i ] [ 0 ] ; R = q [ i ] [ 1 ] ; NEW_LINE if ( isOdd ( L , R ) ) : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE q = [ [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 6 ] ] ; NEW_LINE m = len ( q ) ; NEW_LINE performQueries ( a , n , q , m ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 7 == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 3 == 0 : NEW_LINE INDENT print ( n // 3 , n // 5 , n // 7 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 3 , n // 5 , n // 7 ) NEW_LINE DEDENT DEDENT DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE t = input ( ) NEW_LINE x = c * 60 + d NEW_LINE y = c * 60 + a NEW_LINE z = x // b NEW_LINE w = x % b NEW_LINE if z >= m : NEW_LINE INDENT print ( ( z - m ) // d + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( z - ( m - 1 ) // d + 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = [ a [ 0 ] , a [ 1 ] , a [ 2 ] ] NEW_LINE if a [ 0 ] == x [ 1 ] and a [ 1 ] == x [ 2 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 ; NEW_LINE previous_level = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level ; NEW_LINE current_level = current_level + steps [ i ] ; NEW_LINE if ( ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT steps = [ 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 ] ; NEW_LINE n = len ( steps ) ; NEW_LINE print ( times ( steps , n ) ) ; NEW_LINE
import sys NEW_LINE import math NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT m , d , s = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( ( m * 60 + d ) / 2 ) NEW_LINE DEDENT a . append ( ( 360 - m * 60 + s ) / 2 ) NEW_LINE ans = a [ 0 ] * 2 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT t = a [ i + 1 ] - a [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if t < a [ j ] : NEW_LINE INDENT ans = min ( ans , t - a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] - x ) % 2 == 1 : NEW_LINE INDENT x = ( a [ i ] - x ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT x = a [ i ] - x - 1 NEW_LINE DEDENT DEDENT if x == n : NEW_LINE INDENT print ( ' Petr ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Um _ nik ' ) NEW_LINE DEDENT
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == 0 or b == 0 ) and ( a == 1 or b == 2 ) and ( a == 3 or b == 4 ) and ( a == 5 or b == 6 ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
import sys NEW_LINE def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = sys . maxsize NEW_LINE found = False NEW_LINE sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( sum > k ) : NEW_LINE INDENT while ( sum > k ) : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE
s = list ( input ( ) ) NEW_LINE if '0' in s : NEW_LINE INDENT cnt = s . count ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = s . count ( '1' ) NEW_LINE DEDENT print ( cnt ) NEW_LINE
import math NEW_LINE def nthPalindrome ( n , k ) : NEW_LINE INDENT temp = ( k // 2 ) if ( k & 1 ) else ( k // 2 - 1 ) NEW_LINE palindrome = int ( math . pow ( 10 , temp ) ) NEW_LINE palindrome += n - 1 NEW_LINE print ( str ( palindrome ) , end = " " ) NEW_LINE if ( ( k & 1 ) > 0 ) : NEW_LINE INDENT palindrome //= 10 NEW_LINE DEDENT while ( palindrome > 0 ) : NEW_LINE INDENT print ( str ( palindrome % 10 ) , end = " " ) NEW_LINE palindrome //= 10 NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " digit ▁ = " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " digit ▁ = " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import collections NEW_LINE import bisect NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10000001 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n , x = ns ( ) NEW_LINE a = na ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] -= a [ i - 1 ] NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = x NEW_LINE tmp = a [ i ] NEW_LINE ind = bisect . bisect_left ( a , x - tmp ) NEW_LINE if ind != 0 : NEW_LINE INDENT if len ( a ) > ( ind - 1 ) : NEW_LINE INDENT tmp -= a [ ind - 1 ] NEW_LINE ans = min ( ans , tmp ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , tmp ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 10000 NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE hashTable = [ 0 ] * MAX ; NEW_LINE def hashTable_find ( arr , n ) : NEW_LINE INDENT hashTable [ arr [ 0 ] ] += 1 ; NEW_LINE DEDENT res = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] != 0 ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 ; NEW_LINE DEDENT DEDENT res += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minOperations ( arr , n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE def solve ( A , B , C , D ) : NEW_LINE INDENT x = min ( A , B ) NEW_LINE y = min ( C , D ) NEW_LINE if x < y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT A , B , C , D = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE s = set ( [ A , B , C ] ) NEW_LINE print ( s . count ( min ( A , B ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 = n % 10 NEW_LINE n1 = n // 10 NEW_LINE d0 = d % 10 NEW_LINE d1 = d // 10 NEW_LINE if ( n1 == d0 and n0 * d == n * d1 or n0 == d1 and n1 * d == n * d0 ) : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom / eulerlib . gcd ( numer , denom ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return int ( count ) ; NEW_LINE DEDENT def countOfOddsPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) ; NEW_LINE return int ( pow ( 2 , c ) ) ; NEW_LINE DEDENT n = 20 ; NEW_LINE print ( countOfOddsPascal ( n ) ) ; NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE buf = list ( map ( int , s . split ( ) ) ) NEW_LINE a , b , x , y = buf NEW_LINE fir_a = 0 NEW_LINE fir_b = 0 NEW_LINE dif_a = a - x NEW_LINE dif_b = b - y NEW_LINE if dif_a <= dif_b : NEW_LINE INDENT a -= dif_a NEW_LINE n = dif_a NEW_LINE if dif_b <= dif_a : NEW_LINE INDENT b -= dif_b NEW_LINE n = dif_b NEW_LINE DEDENT else : NEW_LINE INDENT b -= dif_b NEW_LINE n = 0 NEW_LINE fir_a = a * n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a -= n NEW_LINE n = 0 NEW_LINE fir_a = a * n NEW_LINE DEDENT a , b , x , y = buf NEW_LINE if dif_b <= dif_a : NEW_LINE INDENT a -= dif_b NEW_LINE n = dif_a NEW_LINE if dif_b <= dif_b : NEW_LINE INDENT b -= dif_b NEW_LINE n = dif_b NEW_LINE DEDENT else : NEW_LINE INDENT b -= dif_b NEW_LINE n = 0 NEW_LINE fir_b = a * n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a -= n NEW_LINE n = 0 NEW_LINE fir_b = a * n NEW_LINE DEDENT print ( fir_b ) NEW_LINE DEDENT
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE arrpos = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrpos . append ( ( arr [ i ] , i ) ) ; NEW_LINE DEDENT arrpos . sort ( ) ; NEW_LINE vis = [ False ] * n ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrpos [ i ] [ 0 ] == i ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT cycle_size = 0 ; NEW_LINE j = i ; NEW_LINE while ( not vis [ j ] ) : NEW_LINE INDENT vis [ j ] = True ; NEW_LINE j = arrpos [ j ] [ 0 ] ; NEW_LINE cycle_size += 1 ; NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 5 , 4 , 3 , 2 ] ; NEW_LINE print ( minSwaps ( a ) ) ; NEW_LINE DEDENT
from math import ceil NEW_LINE N = 1000005 NEW_LINE prime = [ True ] * N NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( prime [ num ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while ( num // power > 0 ) : NEW_LINE INDENT if ( prime [ num % power ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 25 NEW_LINE sieve ( ) NEW_LINE print ( sumTruncatablePrimes ( n ) ) NEW_LINE DEDENT
def findWeights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE number = 3 NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = number - 1 NEW_LINE sum //= 2 NEW_LINE power += 1 NEW_LINE number *= 3 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " ▁ " ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 2 NEW_LINE findWeights ( X ) NEW_LINE DEDENT
import math as mt NEW_LINE def addToArrayForm ( A , K ) : NEW_LINE INDENT v = [ ] NEW_LINE ans = [ ] NEW_LINE rem = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT my = A [ i ] + K % 10 + rem NEW_LINE if ( my > 9 ) : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( my ) NEW_LINE rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT while ( K > 0 ) : NEW_LINE INDENT my = K % 10 + rem NEW_LINE v . append ( my % 10 ) NEW_LINE if ( my // 10 > 0 ) : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT if ( rem > 0 ) : NEW_LINE INDENT v . append ( rem ) NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( v [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 2 , 7 , 4 ] NEW_LINE K = 181 NEW_LINE ans = addToArrayForm ( A , K ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT
def printPaths ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , " " , 0 , i , R , C ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] NEW_LINE R = len ( input ) NEW_LINE C = len ( input [ 0 ] ) NEW_LINE printPaths ( input , R , C ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' L ' : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT elif s [ i ] == ' R ' : NEW_LINE INDENT a [ - 1 ] = i NEW_LINE DEDENT DEDENT ans = ' ' NEW_LINE for i in a : NEW_LINE INDENT if i == ' R ' : NEW_LINE INDENT ans += '0' if a [ i ] == ' L ' else str ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + c == d ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif ( a + c == d ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def precisionCompute ( x , y , n ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT print ( " Infinite " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( x == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT print ( x // y , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : NEW_LINE INDENT print ( " - " , end = " " ) ; NEW_LINE x = x > 0 ; NEW_LINE y = y > 0 ; NEW_LINE DEDENT d = x // y ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( d , end = " " ) ; NEW_LINE x = x - ( y * d ) ; NEW_LINE if ( x == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT x = x * 10 ; NEW_LINE d = x // y ; NEW_LINE if ( x == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT x = x * 10 ; NEW_LINE d = x // y ; NEW_LINE if ( i == 0 ) : NEW_LINE INDENT print ( " . " , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 22 ; y = 7 ; n = 15 ; NEW_LINE  precisionCompute ( x , y , n ) ; NEW_LINE print ( " " ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT minPerfectCube = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printSpecificLevelOrderUtil ( root , s ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root . left ) NEW_LINE q . append ( root . right ) NEW_LINE first = None NEW_LINE second = None NEW_LINE while ( not len ( q ) ) : NEW_LINE INDENT first = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE second = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE s . append ( second . left ) NEW_LINE s . append ( first . right ) NEW_LINE s . append ( second . right ) NEW_LINE s . append ( first . left ) NEW_LINE if ( first . left . left != None ) : NEW_LINE INDENT q . append ( first . right ) NEW_LINE q . append ( first . left ) NEW_LINE q . append ( second . right ) NEW_LINE DEDENT DEDENT DEDENT def printSpecificLevelOrder ( root ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( root ) NEW_LINE if ( root . left != None ) : NEW_LINE INDENT s . append ( root . right ) NEW_LINE s . append ( root . left ) NEW_LINE DEDENT if ( root . left . left != None ) : NEW_LINE INDENT printSpecificLevelOrderUtil ( root , s ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT print ( s [ - 1 ] . data , end = " ▁ " ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( " Specific ▁ Level ▁ Order ▁ Traversal ▁ of ▁ Binary ▁ Tree ▁ is " ) NEW_LINE printSpecificLevelOrder ( root ) NEW_LINE DEDENT
def hollowSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( i == 1 or i == rows ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( j == 1 or j == rows ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT def solidSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def printPattern ( rows ) : NEW_LINE INDENT print ( " Solid ▁ Square : " ) NEW_LINE  solidSquare ( rows ) NEW_LINE print ( " \n Hollow ▁ Square : " ) NEW_LINE hollowSquare ( rows ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT rows = 5 NEW_LINE printPattern ( rows ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = " abc " NEW_LINE while n : NEW_LINE INDENT s += " % s \n " % s NEW_LINE n -= 1 NEW_LINE DEDENT print ( s ) NEW_LINE
N = int ( input ( ) ) NEW_LINE lis = [ ] NEW_LINE lis_append = lis . append NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( " ▁ " ) ) NEW_LINE lis_append ( ( b , a ) ) NEW_LINE DEDENT lis . sort ( ) NEW_LINE dp = [ 2 ** 60 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for b , a in lis : NEW_LINE INDENT tmp = list ( dp ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if dp [ i - a ] + a <= b : NEW_LINE INDENT tmp [ i ] = min ( dp [ i ] , dp [ i - a ] + a ) NEW_LINE DEDENT DEDENT dp = tmp NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if dp [ i ] < 2 ** 60 : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b ) < x : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findLargest ( arr , n ) : NEW_LINE INDENT __gcd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT __gcd = gcd ( arr [ i ] , __gcd ) ; NEW_LINE DEDENT return __gcd ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findLargest ( arr , n ) ) ; NEW_LINE DEDENT
def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE findWinner ( n ) NEW_LINE
from collections import deque NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE queue = deque ( ) NEW_LINE visited [ s ] = True NEW_LINE queue . append ( s ) NEW_LINE while len ( queue ) != 0 : NEW_LINE INDENT s = queue . popleft ( ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for node in self . adj [ s ] : NEW_LINE INDENT if not visited [ node ] : NEW_LINE INDENT visited [ node ] = True NEW_LINE queue . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def bfs ( self , s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE queue = deque ( ) NEW_LINE q . append ( s ) NEW_LINE while len ( queue ) != 0 : NEW_LINE INDENT s = queue . popleft ( ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for node in self . adj [ s ] : NEW_LINE INDENT if not visited [ node ] : NEW_LINE INDENT visited [ node ] = True NEW_LINE queue . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . BFS ( 2 ) NEW_LINE DEDENT
from collections import deque NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE queue = deque ( ) NEW_LINE visited [ s ] = True NEW_LINE queue . append ( s ) NEW_LINE while len ( queue ) != 0 : NEW_LINE INDENT s = queue . popleft ( ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for node in self . adj [ s ] : NEW_LINE INDENT if not visited [ node ] : NEW_LINE INDENT visited [ node ] = True NEW_LINE queue . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def bfs ( self , s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE queue = deque ( ) NEW_LINE q . append ( s ) NEW_LINE while len ( queue ) != 0 : NEW_LINE INDENT s = queue . popleft ( ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for node in self . adj [ s ] : NEW_LINE INDENT if not visited [ node ] : NEW_LINE INDENT visited [ node ] = True NEW_LINE queue . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . BFS ( 2 ) NEW_LINE DEDENT
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 0 ] * ( n + 1 ) NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 13 , 2 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE a = 5 NEW_LINE getElements ( a , arr , n ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE def solve ( N , R , P , S ) : NEW_LINE INDENT D = { } NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT D [ i ] = { 0 : 0 , 1 : 0 , 2 : 0 } NEW_LINE DEDENT for k in range ( 3 ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT if D [ i ] [ k ] == 0 : NEW_LINE INDENT D [ k ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if D [ k ] [ i - 1 ] > D [ k ] [ i - 2 ] : NEW_LINE INDENT D [ k ] [ i ] = D [ k ] [ i - 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT D [ k ] [ i ] = D [ k ] [ i - 2 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return D [ N ] [ N ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT N , R , P , S = map ( int , input ( ) . split ( ) ) NEW_LINE ans = solve ( N , R , P , S ) NEW_LINE if ans is None : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Case ▁ # { } : ▁ { } " . format ( t , ans ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( k ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a [ x ] += 1 NEW_LINE b [ y ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += ( ( n - i ) // 2 ) * ( a [ i ] > 0 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = math . sqrt ( S * S - 4 * P ) NEW_LINE x = ( D + S ) / 2 NEW_LINE y = ( S - D ) / 2 NEW_LINE print ( " The ▁ two ▁ repeating " , " elements ▁ are ▁ : ▁ " , x , " ▁ & ▁ " , y ) NEW_LINE print ( ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE L = 50000 NEW_LINE sq = int ( L ** .5 ) NEW_LINE p = [ 1 ] * ( L + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = 0 NEW_LINE pn = [ ] NEW_LINE for x in range ( sq + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT for y in range ( x * x , L + 1 , x ) : NEW_LINE INDENT p [ y ] = 0 NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT for x in range ( sq + 1 , L + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT pp = [ 0 ] * ( L + 1 ) NEW_LINE L0 = len ( pn ) NEW_LINE for i in range ( L0 ) : NEW_LINE INDENT x = pn [ i ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT z = x + pn [ j ] NEW_LINE if z > L : NEW_LINE INDENT break NEW_LINE DEDENT pp [ z ] += 1 NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT write ( " % d \n " % pp [ N ] ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE info = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = info [ i ] NEW_LINE info [ i ] = ( math . atan2 ( y , x ) , x , y ) NEW_LINE DEDENT info = sorted ( info ) NEW_LINE info = info + info NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = info [ i ] NEW_LINE info [ i ] = ( math . atan2 ( y , x ) , math . pi ) [ i + 1 ] / 2 NEW_LINE DEDENT ans = max ( ans , info [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def solve ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' q ' or c == ' w ' or c == ' a ' or c == ' z ' or c == ' v ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( s ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE x = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == ' S ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif s [ i ] == ' T ' : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT if x == 0 or x == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans . append ( max ( l [ i ] * l [ i - 1 ] , l [ i + 1 ] * l [ i ] ) ) NEW_LINE DEDENT print ( max ( ans ) ) NEW_LINE DEDENT
def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( gcd ( a , b ) ) NEW_LINE DEDENT def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = n // a - ( m - 1 ) // a NEW_LINE b_divisor = n // b - ( m - 1 ) // b NEW_LINE common_divisor = n // lcm - ( m - 1 ) // lcm NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT m = 3 ; n = 11 ; a = 2 ; b = 3 ; NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE m = 11 ; NEW_LINE n = 1000000 ; NEW_LINE a = 6 ; NEW_LINE b = 35 ; NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) ; NEW_LINE
s = input ( ) NEW_LINE t = " " NEW_LINE for i in s : NEW_LINE INDENT if i . isalpha ( ) : NEW_LINE INDENT t += i NEW_LINE DEDENT elif i == " . " or i == " , " : NEW_LINE INDENT t += " ! " NEW_LINE DEDENT elif i == " ! " or i == " ? " : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE
import sys NEW_LINE def smallestKFreq ( a , n , k ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = m . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for temp in m : NEW_LINE INDENT if ( m [ temp ] == k ) : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT return res if ( res != sys . maxsize ) else - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE print ( smallestKFreq ( arr , len ( arr ) , k ) ) NEW_LINE
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE c = chr ( 64 ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if ( s [ i ] < c ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbddeecc " ; NEW_LINE if areVowelsInOrder ( s ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = int ( n ** ( 1 / 2 ) ) NEW_LINE l = [ 0 ] * ( m + 1 ) NEW_LINE for k in range ( m ) : NEW_LINE INDENT tmp = int ( 2 * tmp ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT l [ k ] = tmp NEW_LINE DEDENT else : NEW_LINE INDENT tmp = min ( l [ k ] , tmp + 1 ) NEW_LINE DEDENT DEDENT m = tmp // 2 NEW_LINE l [ 0 ] = l [ 1 ] NEW_LINE for k in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if l [ k ] % 2 == 0 : NEW_LINE INDENT l [ k ] = tmp NEW_LINE DEDENT else : NEW_LINE INDENT l [ k ] = tmp NEW_LINE DEDENT DEDENT print ( l [ n ] , l [ n - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def countOfLetters ( string ) : NEW_LINE INDENT letter = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ( string [ i ] >= ' A ' and string [ i ] <= ' Z ' ) or ( string [ i ] >= ' a ' and string [ i ] <= ' z ' ) ) : NEW_LINE INDENT letter += 1 ; NEW_LINE DEDENT DEDENT return letter ; NEW_LINE DEDENT def countOfNumbers ( string ) : NEW_LINE INDENT number = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] >= '0' and string [ i ] <= '9' ) : NEW_LINE INDENT number += 1 ; NEW_LINE DEDENT DEDENT return number ; NEW_LINE DEDENT def check ( string ) : NEW_LINE INDENT if ( countOfLetters ( string ) == countOfNumbers ( string ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeKs01324" ; NEW_LINE check ( string ) ; NEW_LINE DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT print ( int ( input ( ) ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
from collections import deque NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE def main ( ) : NEW_LINE INDENT lines = sys . stdin . readlines ( ) NEW_LINE for line in lines : NEW_LINE INDENT N , X = map ( int , line . split ( ) ) NEW_LINE if N * 2 < X : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE if X - 1 in ( 0 , 1 ) : NEW_LINE INDENT P = [ 1 ] * ( N + 1 ) NEW_LINE P [ 0 ] = X NEW_LINE print ( P [ 1 ] ) NEW_LINE print ( P [ 0 ] + 1 ) NEW_LINE print ( P [ 1 ] + 1 ) NEW_LINE DEDENT elif X - 1 in ( 0 , 1 ) : NEW_LINE INDENT P = [ N - 1 ] * ( N + 1 ) NEW_LINE print ( P [ 0 ] + 1 ) NEW_LINE print ( P [ 1 ] + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT P = [ 1 ] * ( N + 1 ) NEW_LINE print ( P [ 0 ] + 1 ) NEW_LINE print ( P [ 1 ] + 2 ) NEW_LINE print ( P [ 0 ] - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 100001 ; NEW_LINE perfectDivisors = [ 0 ] * MAX ; NEW_LINE def precomputeCount ( ) : NEW_LINE INDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDivisors [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDivisors [ n ] ; NEW_LINE DEDENT precomputeCount ( ) ; NEW_LINE n = 16 ; NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = " , countPerfectDivisors ( n ) ) ; NEW_LINE n = 12 ; NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = " , countPerfectDivisors ( n ) ) ; NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( n ) * sum ( m ) ) NEW_LINE
n , t , e = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] <= t : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT elif l [ i ] * t - l [ i ] >= ( t - e ) : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ans == n : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
import math NEW_LINE def cal_IST ( h , r ) : NEW_LINE INDENT IST = ( h * r * 1.0 ) / 360 ; NEW_LINE int_IST = int ( IST ) ; NEW_LINE float_IST = math . ceil ( ( ( IST - int_IST ) * 60 ) ) ; NEW_LINE print ( int_IST , " : " , float_IST ) ; NEW_LINE DEDENT h = 20 ; NEW_LINE r = 150 ; NEW_LINE cal_IST ( h , r ) ; NEW_LINE
from math import cos , sin , ceil NEW_LINE def printRoots ( n ) : NEW_LINE INDENT theta = float ( pi * 2 / n ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT real = cos ( k * theta ) NEW_LINE img = sin ( k * theta ) NEW_LINE print ( " { 0 : . 3 f } " . format ( real ) , end = " " ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " " ) NEW_LINE DEDENT print ( " { 0 : . 3 f } " . format ( ceil ( img ) ) , end = " " ) NEW_LINE DEDENT DEDENT printRoots ( 1 ) NEW_LINE printRoots ( 2 ) NEW_LINE printRoots ( 3 ) NEW_LINE
def findCart ( arr1 , arr2 , n , n1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n1 ) : NEW_LINE INDENT print ( " { " , arr1 [ i ] , " , " , arr2 [ j ] , " } , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE findCart ( arr1 , arr2 , n1 , n2 ) NEW_LINE
def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE count_right = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE SumOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE solve ( arr , n , k ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = True NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( p * p > MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE productOfKthPrimes ( arr , n , k ) NEW_LINE
def findAllSequences ( diff , out , start , end ) : NEW_LINE INDENT if ( abs ( diff ) > ( end - start + 1 ) // 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT out = " " . join ( out ) NEW_LINE print ( out , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT out [ start ] = '0' NEW_LINE out [ end ] = '1' NEW_LINE findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '1' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '0' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = '1' NEW_LINE out [ end ] = '0' NEW_LINE findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE out = [ ' \0' ] * ( 2 * n + 1 ) NEW_LINE out [ 2 * n ] = ' ▁ ' NEW_LINE print ( out [ 0 ] ) NEW_LINE DEDENT
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = a . copy ( ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in d : NEW_LINE INDENT d [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] in d : NEW_LINE INDENT d [ a [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT t = 0 NEW_LINE for i in d : NEW_LINE INDENT t += d [ i ] NEW_LINE DEDENT if t == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " ▁ - > ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " NULL " ) NEW_LINE DEDENT def cntNodes ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cntNodes ( node . next ) ) NEW_LINE DEDENT def updateList ( head , m ) : NEW_LINE INDENT cnt = cntNodes ( head ) NEW_LINE if ( cnt != m and m < cnt ) : NEW_LINE INDENT skip = cnt - m NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while ( skip > 0 ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE skip -= 1 NEW_LINE DEDENT prev . next = None NEW_LINE tempHead = head NEW_LINE head = curr NEW_LINE while ( curr . next != None ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT curr . next = tempHead NEW_LINE DEDENT printList ( head ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = Node ( 4 ) NEW_LINE head . next = Node ( 5 ) NEW_LINE head . next . next = Node ( 6 ) NEW_LINE head . next . next . next = Node ( 1 ) NEW_LINE head . next . next . next . next = Node ( 2 ) NEW_LINE head . next . next . next . next . next = Node ( 3 ) NEW_LINE m = 3 NEW_LINE updateList ( head , m ) NEW_LINE DEDENT
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 0 , 26 ) : NEW_LINE INDENT ch = chr ( 97 + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT s = " aaacaabbaa " NEW_LINE k = 2 NEW_LINE print ( maxSubStrings ( s , k ) ) NEW_LINE
def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * 100 ; NEW_LINE prefeven = [ 0 ] * 100 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] ; NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; NEW_LINE DEDENT DEDENT i = 0 ; NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE l = [ 1 , 1 , 2 ] ; NEW_LINE r = [ 2 , 3 , 4 ] ; NEW_LINE q = len ( l ) ; NEW_LINE wrapper ( arr , n , l , r , q ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT res += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res += a [ i + 1 ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = a [ : n ] NEW_LINE ans = 0 NEW_LINE for j in range ( 0 , n , k ) : NEW_LINE INDENT ans += b [ j ] NEW_LINE b [ j ] = 0 NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT b = a [ n // 2 : ] NEW_LINE DEDENT ans += a [ n // 2 : ] NEW_LINE print ( ans ) NEW_LINE DEDENT
from collections import deque NEW_LINE class Queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . Q = deque ( ) NEW_LINE DEDENT def enqueue ( self , x ) : NEW_LINE INDENT self . Q . appendleft ( x ) NEW_LINE DEDENT def front ( self ) : NEW_LINE INDENT if len ( self . Q ) > 0 : NEW_LINE INDENT print ( self . Q [ - 1 ] ) NEW_LINE DEDENT DEDENT def dequeue ( self ) : NEW_LINE INDENT if len ( self . Q ) > 0 : NEW_LINE INDENT self . Q . pop ( ) NEW_LINE DEDENT DEDENT DEDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE QList = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT QList . append ( Queue ( ) ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT cmd = input ( ) NEW_LINE if cmd . startswith ( "0" ) : NEW_LINE INDENT c , t , x = map ( int , cmd . split ( " ▁ " ) ) NEW_LINE QList [ t ] . enqueue ( x ) NEW_LINE DEDENT if cmd . startswith ( "1" ) : NEW_LINE INDENT c , t = map ( int , cmd . split ( " ▁ " ) ) NEW_LINE QList [ t ] . front ( ) NEW_LINE DEDENT if cmd . startswith ( "2" ) : NEW_LINE INDENT c , t = map ( int , cmd . split ( " ▁ " ) ) NEW_LINE QList [ t ] . dequeue ( ) NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] ; NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) ; NEW_LINE DEDENT printArray ( arr , n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE modifyArray ( arr , n , k ) ; NEW_LINE DEDENT
def find_Centroid ( v ) : NEW_LINE INDENT ans = [ None ] * 2 NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( " { 0 : . 3 f } ▁ { 1 : . 3 f } " . format ( ans [ 0 ] , ans [ 1 ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE a . append ( s ) NEW_LINE DEDENT x = ' blue ' NEW_LINE for i in a : NEW_LINE INDENT if ( i == ' lock ' ) : NEW_LINE INDENT x = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE
def minOperations ( ar , k ) : NEW_LINE INDENT ar . sort ( ) NEW_LINE opsNeeded = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT opsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = opsNeeded NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , opsNeeded ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 1 , 9 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minOperations ( arr , k ) ) NEW_LINE DEDENT
def charCheck ( input_char ) : NEW_LINE INDENT if ( ( input_char >= 65 and input_char <= 90 ) or ( input_char >= 97 and input_char <= 122 ) ) : NEW_LINE INDENT print ( " ▁ Alphabet ▁ " ) NEW_LINE DEDENT elif ( input_char >= 48 and input_char <= 57 ) : NEW_LINE INDENT print ( " ▁ Digit ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Special ▁ Character " ) NEW_LINE DEDENT DEDENT input_char = ' $ ' NEW_LINE charCheck ( input_char ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = l . index ( max ( l ) ) NEW_LINE while ( x + 1 < n ) : NEW_LINE INDENT l [ x ] , l [ x + 1 ] = l [ x + 1 ] , l [ x ] NEW_LINE x += 1 NEW_LINE DEDENT DEDENT print ( * l ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] not in d : NEW_LINE INDENT d [ l [ i ] ] = [ l [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT d [ l [ i ] ] . append ( l [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE try : NEW_LINE INDENT if d [ a - 1 ] [ b - 1 ] : NEW_LINE INDENT print ( min ( l [ a - 1 ] + l [ b - 1 ] + l [ a - 1 ] , d [ a - 1 ] + l [ b - 1 ] ) ) NEW_LINE DEDENT except : NEW_LINE INDENT d [ a - 1 ] = [ l [ b - 1 ] , l [ a - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
from sys import stdin , stdout NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ll = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ll . append ( l [ i ] ) NEW_LINE DEDENT s = 0 NEW_LINE ll . reverse ( ) NEW_LINE for i in l : NEW_LINE INDENT s = i + k NEW_LINE DEDENT ll . reverse ( ) NEW_LINE if s < n : NEW_LINE INDENT s = n NEW_LINE DEDENT ll . append ( s ) NEW_LINE DEDENT print ( * ll ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT id_list = [ [ i + 1 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT id_list [ a [ i ] [ 0 ] ] . append ( i ) NEW_LINE id_list [ a [ i ] [ 1 ] ] . append ( i ) NEW_LINE DEDENT id_list . sort ( ) NEW_LINE nums = [ id_list [ i ] [ 1 ] for i in range ( n ) ] NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if id_list [ i ] [ j ] == id_list [ i ] [ j ] : NEW_LINE INDENT k += 1 NEW_LINE prinum = [ id_list [ i ] [ j ] , id_list [ i ] [ j ] ] NEW_LINE print ( i + 1 , j + 1 ) NEW_LINE prinum . sort ( ) NEW_LINE list_x = [ id_list [ i ] [ j ] , id_list [ i ] [ j ] ] NEW_LINE list_x [ prinum [ 0 ] ] = list_x [ prinum [ 0 ] - 1 ] NEW_LINE list_x [ prinum [ 1 ] = list_x [ prinum [ 1 ] - 1 ] NEW_LINE list_y [ prinum [ 0 ] = id_list [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( f " { i } ▁ { i + 1 } ▁ { list_y [ i ] } " ) NEW_LINE DEDENT
def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ctX = 0 NEW_LINE ctY = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT ctX += 1 NEW_LINE DEDENT elif ( arr [ j ] == y ) : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT if ( ctX == ctY ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x , y = 2 , 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE DEDENT
for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = 0 NEW_LINE for i in s : NEW_LINE INDENT if ( i == "0" ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( min ( c , max ( c ) - 1 ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = max ( w ) NEW_LINE ans = " Conan " NEW_LINE if s in w : NEW_LINE INDENT ans = " Agasa " NEW_LINE DEDENT else : NEW_LINE INDENT for i in w : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT ans = " Agasa " NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE print ( * a ) NEW_LINE
def findTriplets ( target , arr , length ) : NEW_LINE INDENT tripletsCount = 0 NEW_LINE for i in range ( 0 , length - 2 ) : NEW_LINE INDENT if ( target % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if ( arr [ k ] == toFind ) : NEW_LINE INDENT tripletsCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return tripletsCount NEW_LINE DEDENT target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( 0 , length - 2 ) : NEW_LINE INDENT if ( target % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if ( arr [ k ] == toFind ) : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " , totalCount ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( 1 , 1 ) NEW_LINE print ( a [ 0 ] - '0' * ( n - 1 ) + ' ▁ ' + '1 ▁ ' * ( n - 1 ) ) NEW_LINE print ( a [ n - 1 ] ) NEW_LINE
from math import gcd NEW_LINE def finalNum ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = gcd ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( finalNum ( arr , n ) ) ; NEW_LINE DEDENT
N = 1000 NEW_LINE def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ [ ] for i in range ( N ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT while ( len ( v [ steps ] ) > 1 ) : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if ( steps % 2 == 1 ) : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT a = [ 1 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE index = 0 NEW_LINE value = 2 NEW_LINE a [ 0 ] = 2 NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE index = 3 NEW_LINE value = 5 NEW_LINE a [ index ] = value NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE
def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) // 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE DEDENT
import bisect NEW_LINE import heapq NEW_LINE import math NEW_LINE import random NEW_LINE import sys NEW_LINE from collections import Counter , defaultdict , deque NEW_LINE from decimal import ROUND_CEILING , ROUND_HALF_UP , Decimal NEW_LINE from functools import lru_cache , reduce NEW_LINE from itertools import combinations , combinations_with_replacement , product , permutations NEW_LINE from operator import add , mul , sub NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def read_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_int_n ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_float ( ) : NEW_LINE INDENT return float ( input ( ) ) NEW_LINE DEDENT def read_float_n ( ) : NEW_LINE INDENT return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_str ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def read_str_n ( ) : NEW_LINE INDENT return list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE DEDENT def error_print ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT def mt ( f ) : NEW_LINE INDENT import time NEW_LINE def wrap ( * args , ** kwargs ) : NEW_LINE INDENT s = time . time ( ) NEW_LINE ret = f ( * args , ** kwargs ) NEW_LINE e = time . time ( ) NEW_LINE error_print ( e - s , ' sec ' ) NEW_LINE return ret NEW_LINE DEDENT return wrap NEW_LINE DEDENT @ mt NEW_LINE def slv ( S ) : NEW_LINE INDENT p = S . count ( ' p ' ) NEW_LINE return len ( S ) // 2 - p NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT S = read_str ( ) NEW_LINE print ( slv ( ' ' . join ( S ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def pattern ( N ) : NEW_LINE INDENT k , space , rows = 0 , 1 , N NEW_LINE for i in range ( rows , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if ( i != rows ) : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT space = space + 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != rows ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n = 9 NEW_LINE k = 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def pathSum ( self , root , sum ) : NEW_LINE INDENT result = 0 NEW_LINE cache = dict ( ) NEW_LINE cache [ 0 ] = 1 NEW_LINE pathSumHelper ( root , sum , 0 ) NEW_LINE return result NEW_LINE DEDENT def pathSumHelper ( self , root , target , soFar ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT complement = soFar + root . val - target NEW_LINE if complement in cache : NEW_LINE INDENT result += cache [ complement ] NEW_LINE DEDENT cache [ soFar + root . val ] = cache . get ( soFar + root . val , 0 ) + 1 NEW_LINE pathSumHelper ( self . left , target , soFar + root . val ) NEW_LINE pathSumHelper ( self . right , target , soFar + root . val ) NEW_LINE cache [ soFar + root . val ] -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE tree = TreeNode ( 10 ) NEW_LINE tree . left = TreeNode ( 5 ) NEW_LINE tree . right = TreeNode ( - 3 ) NEW_LINE tree . left . left = TreeNode ( 3 ) NEW_LINE tree . left . right = TreeNode ( 2 ) NEW_LINE tree . right . right = TreeNode ( 11 ) NEW_LINE tree . left . left . left = TreeNode ( 3 ) NEW_LINE tree . left . left . right = TreeNode ( - 2 ) NEW_LINE tree . left . right . right = TreeNode ( 1 ) NEW_LINE sum = 8 NEW_LINE out = sObj . pathSum ( tree , sum ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT
import sys NEW_LINE from fractions import gcd NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT def reverse ( nr ) : NEW_LINE INDENT return int ( str ( nr ) [ : : - 1 ] ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT n = int ( fin . readline ( ) ) NEW_LINE count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT digits = str ( n ) NEW_LINE halfcount = ( len ( digits ) + 1 ) // 2 NEW_LINE rev = reverse ( n ) NEW_LINE mod = n % ( 10 ** halfcount ) NEW_LINE if mod == 1 and n != rev : NEW_LINE INDENT n = rev NEW_LINE count += 1 NEW_LINE DEDENT elif mod <= 1 : NEW_LINE INDENT n -= 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n -= ( mod - 1 ) NEW_LINE count += ( mod - 1 ) NEW_LINE DEDENT DEDENT print ( " Case ▁ { } : " . format ( case ) ) NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE L = 50000 NEW_LINE sq = int ( L ** .5 ) NEW_LINE p = [ 1 ] * ( L + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = 0 NEW_LINE pn = [ ] NEW_LINE for x in range ( sq + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT for y in range ( x * x , L + 1 , x ) : NEW_LINE INDENT p [ y ] = 0 NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT for x in range ( sq + 1 , L + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT pp = [ 0 ] * ( L + 1 ) NEW_LINE L0 = len ( pn ) NEW_LINE for i in range ( L0 ) : NEW_LINE INDENT x = pn [ i ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT z = x + pn [ j ] NEW_LINE if z > L : NEW_LINE INDENT break NEW_LINE DEDENT pp [ z ] += 1 NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT write ( " % d \n " % pp [ N ] ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxVal ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxOR ( arr , n ) ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT j_hash = { } NEW_LINE for j in range ( len ( J ) ) : NEW_LINE INDENT j_hash [ J [ j ] ] = 1 NEW_LINE DEDENT for s in S : NEW_LINE INDENT if s in j_hash : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE J = ' a A ' NEW_LINE S = ' aAAbbbb ' NEW_LINE out = sObj . numJewelsInStones ( J , S ) NEW_LINE print ( out ) NEW_LINE DEDENT
import numpy as np NEW_LINE MAX = 100 ; NEW_LINE store = [ 0 ] * MAX ; NEW_LINE graph = np . zeros ( ( MAX , MAX ) ) ; NEW_LINE d = [ 0 ] * MAX ; NEW_LINE def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT def maxCliques ( i , l ) : NEW_LINE INDENT max_ = 0 ; NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j ; NEW_LINE if ( is_clique ( l + 1 ) ) : NEW_LINE INDENT max_ = max ( max_ , l ) ; NEW_LINE max_ = max ( max_ , maxCliques ( j , l + 1 ) ) ; NEW_LINE DEDENT DEDENT return max_ ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] ; NEW_LINE size = len ( edges ) ; NEW_LINE n = 4 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; NEW_LINE graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; NEW_LINE d [ edges [ i ] [ 0 ] ] += 1 ; NEW_LINE d [ edges [ i ] [ 1 ] ] += 1 ; NEW_LINE DEDENT print ( maxCliques ( 0 , 1 ) ) ; NEW_LINE DEDENT
import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( math . pow ( 2 , k ) ) ; NEW_LINE DEDENT n = 273 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , s , f = map ( int , input ( ) . split ( ) ) NEW_LINE d = { } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a ] = [ c , b ] NEW_LINE DEDENT x = s NEW_LINE for i in d : NEW_LINE INDENT if x [ i ] [ 0 ] > x [ 1 ] : NEW_LINE INDENT x = d [ i ] [ 0 ] NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in d : NEW_LINE INDENT if d [ i ] [ 1 ] > x [ i ] [ 2 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT z = ' L ' if x [ n - 1 ] == 0 else ' R ' NEW_LINE print ( z * c + z * ' L ' if x [ n - 1 ] >= z [ n - 2 ] else ' X ' ) NEW_LINE
def subsetPairNotDivisibleByK ( arr , N , K ) : NEW_LINE INDENT f = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( subsetPairNotDivisibleByK ( arr , N , K ) ) NEW_LINE
def check ( v ) : NEW_LINE INDENT global gen NEW_LINE if v > g : NEW_LINE INDENT return False NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT m = 10 ** i - ( v - 1 ) NEW_LINE ans += m * 9 * 10 ** ( i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT global gen NEW_LINE gen , st , t = map ( int , input ( ) . split ( ) ) NEW_LINE start = s NEW_LINE end = 0 NEW_LINE while solve ( ) : NEW_LINE INDENT ans = ( start + 1 ) // 2 NEW_LINE check ( start ) NEW_LINE if check ( end ) : NEW_LINE INDENT end = start NEW_LINE DEDENT else : NEW_LINE INDENT start = start + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT solve ( ) NEW_LINE
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , ▁ " , c // ( a * 1.0 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c = 2 , 3 , - 5 NEW_LINE printRoots ( a , b , c ) NEW_LINE DEDENT
def dp ( pos , fl , pr , bin ) : NEW_LINE INDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) : NEW_LINE INDENT return memo [ pos ] [ fl ] [ pr ] NEW_LINE DEDENT val = 0 NEW_LINE if ( bin [ pos ] == '0' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , fl , 0 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , 1 , 0 , bin ) NEW_LINE DEDENT if ( pr == 0 ) : NEW_LINE INDENT if ( fl == 1 ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT DEDENT if ( bin [ pos ] == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT DEDENT memo [ pos ] [ fl ] [ pr ] = val NEW_LINE return memo [ pos ] [ fl ] [ pr ] NEW_LINE DEDENT def findIntegers ( num ) : NEW_LINE INDENT bin = " " NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( num % 2 == 1 ) : NEW_LINE INDENT bin += "1" NEW_LINE DEDENT else : NEW_LINE INDENT bin += "0" NEW_LINE DEDENT num //= 2 NEW_LINE DEDENT bin = bin [ : : - 1 ] NEW_LINE return dp ( 0 , 0 , 0 , bin ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE print ( findIntegers ( N ) ) NEW_LINE DEDENT
N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE
def createHash ( maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPair ( n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE createHash ( hash , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i in hash ) and ( n - i in hash ) : NEW_LINE INDENT print ( i , " , ▁ " , ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT N = 90 NEW_LINE findFibonacciPair ( N ) NEW_LINE
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if ( xs == 0 ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE
import sys NEW_LINE def maxLength ( s , n ) : NEW_LINE INDENT ans = - sys . maxsize ; NEW_LINE A = [ ] ; NEW_LINE L = [ ] ; NEW_LINE R = [ ] ; NEW_LINE freq = [ 0 ] * ( n + 5 ) ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT freq [ j ] = count ; NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) ; NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) ; NEW_LINE DEDENT max_len = MIN ; NEW_LINE min_val = sys . maxsize ; NEW_LINE for j in range ( len ( L ) ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) ; NEW_LINE A . append ( min_val ) ; NEW_LINE l = 0 ; NEW_LINE r = j ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 ; NEW_LINE if ( A [ mid ] <= R [ j ] ) : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) ; NEW_LINE r = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) ; NEW_LINE A . clear ( ) ; NEW_LINE R . clear ( ) ; NEW_LINE L . clear ( ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababbbacbcbcca " ; NEW_LINE n = len ( s ) ; NEW_LINE print ( maxLength ( s , n ) ) ; NEW_LINE DEDENT
N = 100005 NEW_LINE gr = [ [ ] for i in range ( N ) ] NEW_LINE colum = [ 0 ] * N NEW_LINE def add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE edges . append ( ( x , y ) ) NEW_LINE DEDENT def dfs ( x , col ) : NEW_LINE INDENT colum [ x ] = col NEW_LINE for i in gr [ x ] : NEW_LINE INDENT if colum [ i ] == - 1 : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT elif colum [ i ] == col : NEW_LINE INDENT bip = False NEW_LINE DEDENT DEDENT DEDENT def Directed_Graph ( n , m ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT colum [ i ] = - 1 NEW_LINE DEDENT bip = True NEW_LINE dfs ( 1 , 1 ) NEW_LINE if not bip : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if colum [ edges [ i ] [ 0 ] ] == 0 : NEW_LINE INDENT temp = edges [ edges [ i ] [ 0 ] ] NEW_LINE edges [ i ] [ 0 ] , edges [ i ] [ 1 ] = edges [ i ] [ 1 ] , edges [ i ] [ 1 ] NEW_LINE DEDENT print ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE m = 3 NEW_LINE add_edge ( 1 , 2 ) ; NEW_LINE add_edge ( 1 , 3 ) ; NEW_LINE add_edge ( 1 , 4 ) NEW_LINE Directed_Graph ( n , m ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE k = [ ] NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT k . append ( i ) NEW_LINE DEDENT DEDENT a = sorted ( l ) NEW_LINE for i in k : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
import math NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( math . ceil ( ( a * c ) / b ) - ( a * b ) ) ) NEW_LINE
def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( isPrime ( k ) == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ chr ( 97 + i ) for i in range ( 26 ) ] NEW_LINE if n < k + 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif k == 1 and n > 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n == k : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = chr ( 97 + i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = [ chr ( 97 + i ) for i in range ( 26 + i ) ] NEW_LINE for i in range ( n - k , n ) : NEW_LINE INDENT a [ i ] = a [ i + k - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] NEW_LINE DEDENT DEDENT for s in a : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
maxn = 16 NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ - 1 for i in range ( maxn ) ] NEW_LINE arr = [ 4 , 6 , 9 ] NEW_LINE for i in range ( maxn ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = arr [ k ] NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT def Maximum_Summands ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = ( n - maxn ) // 4 + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE dp = precompute ( ) NEW_LINE print ( Maximum_Summands ( dp , n ) ) NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is ▁ " , countSquares ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = [ 0 ] NEW_LINE for a in A : NEW_LINE INDENT b = ( B [ - 1 ] + ( a - 1 ) ) % M NEW_LINE B . append ( b ) NEW_LINE DEDENT ans = 0 NEW_LINE dic = { } NEW_LINE for i , b in enumerate ( B ) : NEW_LINE INDENT if b in dic : NEW_LINE INDENT dic [ b ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT dic [ b ] = [ i ] NEW_LINE DEDENT DEDENT ans += len ( dic [ b ] ) // M NEW_LINE dic [ b ] = deque ( dic [ b ] ) NEW_LINE for i , j in dic . items ( ) : NEW_LINE INDENT ans += ( dic [ b ] [ i ] - 1 ) * dic [ b ] [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def FindSubarray ( arr , n , k ) : NEW_LINE INDENT count_one = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_one [ i ] = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE DEDENT sum = count_one [ 0 ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT if ( count_one [ 0 ] >= k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT ans = sys . maxsize ; NEW_LINE i = 1 ; NEW_LINE j = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( k == count_one [ j ] ) : NEW_LINE INDENT ans = 1 ; NEW_LINE break ; NEW_LINE DEDENT elif ( k == count_one [ i ] ) : NEW_LINE INDENT ans = 1 ; NEW_LINE break ; NEW_LINE DEDENT elif ( sum + count_one [ i ] < k ) : NEW_LINE INDENT sum += count_one [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT elif ( sum + count_one [ i ] > k ) : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) ; NEW_LINE sum -= count_one [ j ] ; NEW_LINE j += 1 ; NEW_LINE DEDENT elif ( sum + count_one [ i ] == k ) : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) ; NEW_LINE sum += count_one [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT if ( ans != sys . maxsize ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( FindSubarray ( arr , n , k ) ) ; NEW_LINE DEDENT
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 ; NEW_LINE loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; NEW_LINE print ( " Loss ▁ = " , round ( loss , 3 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT SP = 2400 ; P = 30 ; NEW_LINE Loss ( SP , P ) ; NEW_LINE DEDENT
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = a [ 0 ] NEW_LINE M = a [ 1 ] NEW_LINE X = a [ 2 ] NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ a [ i ] ] -= 1 NEW_LINE DEDENT b = [ 0 ] * N NEW_LINE for i in range ( M ) : NEW_LINE INDENT b [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] += b [ i + 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += b [ i ] NEW_LINE DEDENT print ( min ( ans , X ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] == 1 : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT twos += 1 NEW_LINE DEDENT DEDENT print ( n - max ( ones , twos ) ) NEW_LINE
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE ans = sum ( 1 for i in range ( 1 , LIMIT ) if isClass89 ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def isClass89 ( x ) : NEW_LINE INDENT while True : NEW_LINE INDENT if x == 1 or x == 89 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT x = int ( next ( itertools . count ( 1 ) ) ) NEW_LINE DEDENT DEDENT DEDENT def next_number ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x != 0 : NEW_LINE INDENT ans += ( x % 10 ) * ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( str , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( str [ i ] ) NEW_LINE DEDENT return fact ( len ( distinct_char ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE print ( countStrings ( str , n ) ) NEW_LINE DEDENT
M = 4 NEW_LINE N = 5 NEW_LINE def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if ( i == M - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 1 , 4 , 8 ] , [ 3 , 7 , 8 , 5 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] , [ 8 , 1 , 2 , 7 , 9 ] ] NEW_LINE printCommonElements ( mat ) NEW_LINE
n , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( a ) NEW_LINE y . append ( b ) NEW_LINE DEDENT x = sorted ( x ) NEW_LINE y = sorted ( y ) NEW_LINE if x [ 2 ] == y [ 2 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 998244353 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE while True : NEW_LINE INDENT n , t = LI ( ) NEW_LINE aa = [ LI ( ) for _ in range ( n ) ] NEW_LINE t = aa [ 0 ] [ 1 ] NEW_LINE for c , d in aa [ 1 : ] : NEW_LINE INDENT t -= c NEW_LINE if t <= 0 : NEW_LINE INDENT rr . append ( c + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ' \n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + a ; NEW_LINE a = a + d ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 20 ; NEW_LINE a = 2.5 ; NEW_LINE d = 1.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE
def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( " No ▁ such ▁ triplet ▁ found " ) NEW_LINE return NEW_LINE DEDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , large , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE DEDENT
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) NEW_LINE i = 0 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT n = 96 NEW_LINE numbersWith3Divisors ( n ) NEW_LINE
import math as mt NEW_LINE def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 for i in range ( K ) ] NEW_LINE rem [ 0 ] = N // K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 10 NEW_LINE K = 4 NEW_LINE print ( findPairCount ( N , K ) ) NEW_LINE
while True : NEW_LINE INDENT n , m = [ int ( s ) for s in input ( ) . split ( " ▁ " ) ] NEW_LINE if n == m == 0 : break NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE b = [ int ( input ( ) ) for i in range ( m ) ] NEW_LINE b . sort ( ) NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = max ( x , b [ i ] - b [ i ] ) NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( a ) NEW_LINE if sum ( a ) % 2 == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
ph190 = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while ( t < n ) : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT n = 9 NEW_LINE print ( " % d th ▁ Fibonacci ▁ Number ▁ = ▁ " % n , fib ( n ) ) NEW_LINE
def kthSmallest ( n , k ) : NEW_LINE INDENT return ( 2 * k ) NEW_LINE DEDENT n = 8 NEW_LINE k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE
n = 5 NEW_LINE def printSumTricky ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT k = 3 NEW_LINE printSumTricky ( mat , k ) NEW_LINE
a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE x = a ** n - b ** 0.5 NEW_LINE print ( " No ▁ solution " ) if x < 0 else print ( x ) NEW_LINE
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE DEDENT X = 4 ; Y = 3 ; M = 6 ; W = 5 NEW_LINE print ( totalWays ( X , Y , M , W ) ) NEW_LINE
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if ( n == a or n == a - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == a - 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import collections NEW_LINE import bisect NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10000001 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n , p = ns ( ) NEW_LINE a = ns ( ) NEW_LINE if p == 0 : NEW_LINE INDENT print ( 1 << n ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT a_odd = [ 0 for _ in range ( n ) ] NEW_LINE for a in a : NEW_LINE INDENT if a % 2 : NEW_LINE INDENT a_odd [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a_even [ 0 ] += 1 NEW_LINE DEDENT DEDENT ans = 2 ** ( n ) NEW_LINE if a_odd [ 0 ] == 0 : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE
def sumOfDigits ( x ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT Sum += x % 10 ; NEW_LINE x = x // 10 ; NEW_LINE DEDENT return Sum ; NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1000 ; r = 6000 ; NEW_LINE print ( countNumbers ( l , r ) ) ; NEW_LINE DEDENT
import math NEW_LINE def findGreater ( a , b ) : NEW_LINE INDENT x = a * ( math . log ( b ) ) ; NEW_LINE y = b * ( math . log ( a ) ) ; NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( " a ^ b ▁ is ▁ greater " ) ; NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( " b ^ a ▁ is ▁ greater " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " both ▁ are ▁ equal " ) ; NEW_LINE DEDENT DEDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE c = 2 ; NEW_LINE d = 4 ; NEW_LINE findGreater ( a , b ) ; NEW_LINE findGreater ( c , d ) ; NEW_LINE
def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l = 0 ; r = 0 ; NEW_LINE ans = 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT i = n - 1 ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT r = i ; NEW_LINE break ; NEW_LINE DEDENT i -= 1 ; NEW_LINE DEDENT if ( r < l ) : NEW_LINE INDENT return 26 * ( n + 1 ) ; NEW_LINE DEDENT elif ( l == r ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i - 1 ] ) : NEW_LINE INDENT ans -= 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] != str2 [ i ] ) : NEW_LINE INDENT ans -= 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " toy " ; NEW_LINE str2 = " try " ; NEW_LINE n = len ( str1 ) ; NEW_LINE print ( findAnswer ( str1 , str2 , n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , m = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > x : NEW_LINE INDENT c = a NEW_LINE x = b NEW_LINE DEDENT DEDENT if x > 0 : NEW_LINE INDENT c = x NEW_LINE DEDENT print ( c + 1 ) NEW_LINE DEDENT
def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE for i in range ( 1 , ( r - l ) + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE zero = a . count ( 0 ) NEW_LINE one = a . count ( 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT p = [ ] NEW_LINE q = [ ] NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE p . append ( [ x , y ] ) NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT x , y = p [ i ] NEW_LINE if y - x <= 1 : NEW_LINE INDENT if x % 2 == 1 and y % 2 == 1 : NEW_LINE INDENT q . append ( 0 ) NEW_LINE DEDENT elif x % 2 == 0 and y % 2 != 0 : NEW_LINE INDENT q . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT p . append ( 1 ) NEW_LINE DEDENT DEDENT for z in q : NEW_LINE INDENT t = z [ 0 ] - p [ 0 ] [ 0 ] NEW_LINE if t < 2 : NEW_LINE INDENT if ( x % 2 == 1 and y % 2 == 1 ) or ( x % 2 == 0 and y % 2 == 0 ) : NEW_LINE INDENT q . append ( 1 ) NEW_LINE DEDENT elif x % 2 == 0 and y % 2 != 0 : NEW_LINE INDENT q . append ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT p . append ( 1 ) NEW_LINE DEDENT DEDENT DEDENT for z in q : NEW_LINE INDENT print ( z [ z ] ) NEW_LINE DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE ans = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 0 : NEW_LINE INDENT ans [ i ] [ j ] = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 0 : NEW_LINE INDENT ans [ i ] [ j ] = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 0 : NEW_LINE INDENT if ans [ i ] [ j ] == 1 : NEW_LINE INDENT ans [ i ] [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if ans [ i ] [ 0 ] == ans [ i ] [ 0 ] and ans [ i ] [ 1 ] == ans [ i ] [ 1 ] : NEW_LINE INDENT ans [ i ] [ 0 ] = 0 NEW_LINE while ans [ i ] [ 0 ] != ans [ i ] [ 0 ] and ans [ i ] [ 1 ] == ans [ i ] [ 1 ] : NEW_LINE INDENT ans [ i ] [ 0 ] += 1 NEW_LINE DEDENT if ans [ i ] [ 0 ] == ans [ i ] [ 0 ] and ans [ i ] [ 1 ] == ans [ i ] [ 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ans [ 0 ] [ 0 ] == ans [ i ] [ 0 ] and ans [ i ] [ 1 ] == ans [ i ] [ 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans [ 0 ] [ 0 ] ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = sum ( l ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT x = x - ( l [ i ] + l [ i + 1 ] ) NEW_LINE if x <= k : NEW_LINE INDENT l [ i ] = l [ i ] + k - x NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE print ( * l ) NEW_LINE
MAX = 1000000 ; NEW_LINE def maximumOccurredElement ( L , R , n ) : NEW_LINE INDENT arr = [ 0 ] * MAX ; NEW_LINE maxi = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 ; NEW_LINE arr [ R [ i ] + 1 ] -= 1 ; NEW_LINE if ( R [ i ] > maxi ) : NEW_LINE INDENT maxi = R [ i ] ; NEW_LINE DEDENT DEDENT msum = arr [ 0 ] ; NEW_LINE ind = 0 ; NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] ; NEW_LINE if ( msum < arr [ i ] ) : NEW_LINE INDENT msum = arr [ i ] ; NEW_LINE ind = i ; NEW_LINE DEDENT DEDENT return ind ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = [ 1 , 4 , 9 , 13 , 21 ] ; NEW_LINE R = [ 15 , 8 , 12 , 20 , 30 ] ; NEW_LINE n = len ( L ) ; NEW_LINE print ( maximumOccurredElement ( L , R , n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( set ( a ) ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n == 0 and m == 0 ) or ( m == 0 and n != 0 ) : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , m + n - 1 ) NEW_LINE DEDENT
def func ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT value = ( upper_limit - lower_limit ) / interval_limit NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = ( sum + 2 * func ( lower_limit + i * interval_size ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( 3 * interval_size / 8 ) * sum NEW_LINE DEDENT interval_limit = 10 NEW_LINE lower_limit = 1 NEW_LINE upper_limit = 10 NEW_LINE  integral_res = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( " { 0 : . 4 f } " . format ( integral_res ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if k >= n : NEW_LINE INDENT print ( n * x + y * ( n - k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n * x + ( n - k ) * y ) NEW_LINE DEDENT
import math NEW_LINE while True : NEW_LINE INDENT x , h = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( math . sqrt ( x ** 2 + h ** 2 ) ) NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT from collections import Counter NEW_LINE for i in range ( 1 , 20 ) : NEW_LINE INDENT res = 0 NEW_LINE for j in str ( i ) : NEW_LINE INDENT res += j NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT k = int ( MAX ** ( 0.5 ) ) NEW_LINE for p in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( 0 , n - 7 , 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , " ▁ " , i + 2 , " ▁ " , i + 6 , " ▁ " , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT n = 20 NEW_LINE sieve ( ) NEW_LINE printPrimeQuad ( n ) NEW_LINE
MAX = 1000 ; NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = " ABCD " ; NEW_LINE y = " BACDBDCD " ; NEW_LINE n = len ( x ) ; NEW_LINE m = len ( y ) ; NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) ; NEW_LINE DEDENT
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE b = [ 0 ] * 26 NEW_LINE for i in s1 : NEW_LINE INDENT if i in s2 : NEW_LINE INDENT a [ ord ( i ) - ord ( " a " ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ ord ( i ) - ord ( " a " ) ] += 1 NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in s2 : NEW_LINE INDENT if i not in a : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c , a . count ( x ) ) NEW_LINE
MAX = 1000 NEW_LINE sequence = [ 0 ] * MAX NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT vanEckSequence ( ) NEW_LINE n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE
MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 NEW_LINE i = n - 1 NEW_LINE while ( sequence [ i + 1 ] != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE i = i - sequence [ i + 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE
MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sequence [ i ] == nthTerm ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT vanEckSequence ( ) ; NEW_LINE n = 5 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE
from math import gcd , sqrt NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // gcd ( a , b ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = int ( mid / a + int ( mid / b - int ( lcm ) ) ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return max ( ( mid // a ) * a , ( mid // b ) * b ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE r = n % 400 NEW_LINE if r == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT if r < 6 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT h = ( n - r ) // 7 * 6 NEW_LINE if h % 4 == 0 : NEW_LINE INDENT print ( n - r ) NEW_LINE DEDENT elif h % 100 == 0 : NEW_LINE INDENT print ( n - r ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = readline ( ) . strip ( ) NEW_LINE res = 0 NEW_LINE for s in RK : NEW_LINE INDENT if s == ' OUT ' : NEW_LINE INDENT res += 0 NEW_LINE DEDENT else : NEW_LINE INDENT k = i & ( - i ) NEW_LINE if k != 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT write ( " % d \n " % res ) NEW_LINE DEDENT T = int ( readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
from math import gcd , sqrt NEW_LINE def findValue ( x , y , z ) : NEW_LINE INDENT g = gcd ( y , z ) NEW_LINE return ( x * g ) // gcd ( x , g ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , z = 30 , 40 , 400 NEW_LINE print ( int ( findValue ( x , y , z ) ) ) NEW_LINE DEDENT
def foot ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE print ( " x2 ▁ = ▁ " , end = " ▁ " ) NEW_LINE print ( " y2 ▁ = ▁ " , end = " ▁ " ) NEW_LINE print ( " z2 ▁ = ▁ " , end = " ▁ " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE foot ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE DEDENT
A , B = map ( str , input ( ) . split ( ) ) NEW_LINE print ( ' YES ' if A [ 0 ] == B [ 0 ] and B [ - 1 ] == A [ - 1 ] else ' NO ' ) NEW_LINE
import numpy as np NEW_LINE def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = np . zeros ( ( large + 1 , large + 1 ) ) NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = np . 2147483647 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 - 1 ) ) NEW_LINE DEDENT a = 7 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE
def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n // 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) // 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 ; n = 9 ; NEW_LINE check ( n , m ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ls = [ ] NEW_LINE for i in a : NEW_LINE INDENT ls . append ( i // m ) NEW_LINE DEDENT ls . sort ( ) NEW_LINE if sum ( ls ) < n : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT if ls [ 0 ] < 2 or ls [ - 1 ] < 2 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ls [ 0 ] % 2 == 1 : NEW_LINE INDENT if ls [ 1 ] % 2 == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ls [ 1 ] % 2 == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( negProdSubArr ( arr , n ) ) NEW_LINE DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) // 2 NEW_LINE cntNeg = negProdSubArr ( arr , n ) NEW_LINE return ( total - cntNeg ) NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdSubArr ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE d = 3 NEW_LINE while d * 2 <= n : NEW_LINE INDENT ans += 1 NEW_LINE d *= 2 NEW_LINE DEDENT print ( ans - ( n - d ) // k ) NEW_LINE DEDENT
def gcd ( m , n ) : NEW_LINE INDENT r = m % n NEW_LINE return gcd ( n , r ) if r else n NEW_LINE DEDENT x , y , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE while max ( a , b ) > 0 : NEW_LINE INDENT if x % gcd ( a , b ) == 0 : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT elif x < y : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT if y < a : NEW_LINE INDENT max_ = y NEW_LINE DEDENT else : NEW_LINE INDENT max_ = a NEW_LINE DEDENT DEDENT print ( max_ ) NEW_LINE
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 1 for i in range ( n ) ] NEW_LINE Len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT Len = max ( Len , LIS [ i ] ) NEW_LINE DEDENT return n - Len NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE
def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 for i in range ( n ) ] NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) != 0 and a [ s [ - 1 ] ] < a [ i ] ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT while ( j < i or max_upto [ j ] < i + k - 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print_max ( a , n , k ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = max ( a ** b for a in range ( 1 , 100 ) for b in range ( 1 , 100 ) ) NEW_LINE return str ( max ( ans ) ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += int ( s [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countWindowDistinct ( win , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT if ( win [ i ] == win [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT print ( countWindowDistinct ( arr [ i : i + k ] , k ) ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE countDistinct ( arr , len ( arr ) , k ) NEW_LINE
def evenNumSubstring ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "1234" NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE DEDENT
max = 4 NEW_LINE def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; NEW_LINE dp [ index ] [ cnt ] = ans ; NEW_LINE return dp [ index ] [ cnt ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; m = 3 ; k = 2 ; NEW_LINE dp = [ [ - 1 for i in range ( max ) ] for j in range ( n + 1 ) ] ; NEW_LINE print ( m * countWays ( 1 , 0 , dp , n , m , k ) ) ; NEW_LINE DEDENT
import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return sum - n NEW_LINE DEDENT def printAliquot ( n ) : NEW_LINE INDENT print ( str ( n ) , end = " ▁ " ) NEW_LINE s = set ( ) NEW_LINE s . add ( n ) NEW_LINE next = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if n in s : NEW_LINE INDENT print ( " \n Repeats ▁ with " , n , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT print ( n , end = " ▁ " ) NEW_LINE s . add ( n ) NEW_LINE DEDENT DEDENT printAliquot ( 12 ) NEW_LINE
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE n = n + 1 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] - 1 == ans [ i ] : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( 2 ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n + ~ i + 1 ] = arr [ n + ~ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printSeriessum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE Sum += a NEW_LINE while ( cnt < N ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT NextElement = a * 2 NEW_LINE Sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT NextElement = a * 3 / 2 NEW_LINE Sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( Sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE printSeriessum ( N ) NEW_LINE DEDENT
import math NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE m = math . gcd ( h , w ) NEW_LINE h , w = m , h NEW_LINE while h != 0 and w != 0 : NEW_LINE INDENT if h % 2 == 0 : NEW_LINE INDENT if w % 2 == 0 : NEW_LINE INDENT print ( int ( ( h / 2 ) + 1 ) , int ( ( w / 2 ) + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( ( h / 2 ) + 1 ) , int ( ( w / 2 ) + 1 ) ) NEW_LINE DEDENT h , w = w , h NEW_LINE DEDENT else : NEW_LINE INDENT if h % 2 == 0 : NEW_LINE INDENT print ( int ( w / 2 ) + 1 , int ( w / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( h / 2 ) , int ( w / 2 ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT
from math import sqrt NEW_LINE sz = 10 ** 5 NEW_LINE isPrime = [ True for i in range ( sz + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] , isPrime [ 1 ] = False , False NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT four = 0 NEW_LINE for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT four = i NEW_LINE break NEW_LINE DEDENT DEDENT slow = 0 NEW_LINE for i in range ( fst + 1 , R + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT slow = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( snd == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = snd - fst NEW_LINE left = snd + 1 NEW_LINE right = R NEW_LINE for i in range ( left , right + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT if ( i - snd <= diff ) : NEW_LINE INDENT four = snd NEW_LINE slow = i NEW_LINE diff = snd - fst NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sieve ( ) NEW_LINE L = 21 NEW_LINE R = 50 NEW_LINE print ( minDifference ( L , R ) ) NEW_LINE DEDENT
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT suffCnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT midCnt += 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT DEDENT return max ( result , preCnt + suffCnt ) NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) NEW_LINE
def solve ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE D , N = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE dp = [ [ 0 ] * ( N + 1 ) for _ in range ( D + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE c -= 1 NEW_LINE dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( D ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if A [ i ] [ j ] <= A [ j ] : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + abs ( c - dp [ k ] [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + abs ( c - dp [ k ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( D ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ N ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = k = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] > s [ i + 1 ] : NEW_LINE INDENT t = 1 NEW_LINE print ( " NO " ) NEW_LINE break NEW_LINE DEDENT elif s [ i ] < s [ i + 1 ] : NEW_LINE INDENT k = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if t == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( k + 1 , k + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; NEW_LINE N = 0 ; NEW_LINE i = ( int ) ( s ) ; NEW_LINE while ( i > 0 ) : NEW_LINE INDENT j = 1 ; NEW_LINE while ( j < i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = s - pSq ; NEW_LINE P = d / ( 2.0 * N ) ; NEW_LINE A = N + P ; NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; NEW_LINE return sqrt_of_s ; NEW_LINE DEDENT num = 9.2345 ; NEW_LINE sqroot_of_num = sqroot ( num ) ; NEW_LINE print ( " Square ▁ root ▁ of " , num , " = ▁ " , round ( sqroot_of_num * 100000.0 ) / 100000.0 ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE b = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= b [ i ] : NEW_LINE INDENT b [ i ] = True NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def solve ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT r , n = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE data . sort ( ) NEW_LINE city = 0 NEW_LINE for d in data : NEW_LINE INDENT c = data [ d ] [ 0 ] - d [ 0 ] NEW_LINE r = d [ 1 ] - d [ 1 ] NEW_LINE if c < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if city < c : NEW_LINE INDENT city = c NEW_LINE DEDENT DEDENT distance = math . sqrt ( r ** 2 + 2 * r ** 2 ) NEW_LINE distance_ = distance / 2 NEW_LINE data = data [ 0 : city ] NEW_LINE data . sort ( ) NEW_LINE print ( " { 0 : . 8f } : ▁ { 1 : . 8f } " . format ( city , distance ) ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] - a [ i - 1 ] == 1 : NEW_LINE INDENT ans = i + 2 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = " " NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if n % 10 == 9 : NEW_LINE INDENT ans += "9" NEW_LINE n //= 10 NEW_LINE DEDENT elif n % 10 == 0 : NEW_LINE INDENT ans += "01" NEW_LINE n //= 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans += n NEW_LINE n //= 10 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n ) ] NEW_LINE inc = [ 0 for i in range ( n ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ = ▁ " , maxAlternateSum ( arr , n ) ) NEW_LINE
def generateArr ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] & arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] ; NEW_LINE arr [ i ] = prev & arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev & arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] ; NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT A = 3 NEW_LINE B = 2 NEW_LINE C = 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE
from math import sqrt , pow NEW_LINE MAX = 100000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = int ( pow ( 10 , d - 1 ) ) NEW_LINE r = int ( pow ( 10 , d ) ) - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def largestPrime ( d ) : NEW_LINE INDENT l = int ( pow ( 10 , d - 1 ) ) NEW_LINE r = int ( pow ( 10 , d ) ) - 1 NEW_LINE for i in range ( r , l - 1 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE queries = [ 2 , 5 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( smallestPrime ( queries [ i ] ) , largestPrime ( queries [ i ] ) ) NEW_LINE DEDENT DEDENT
def solve ( n , m , d , c ) : NEW_LINE INDENT dp = [ 0 ] + [ float ( " inf " ) ] * n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT d [ i ] = d [ i - 1 ] + int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT c = int ( input ( ) ) NEW_LINE c += d [ i - 1 ] * c NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + d [ i - 1 ] * c ) NEW_LINE DEDENT print ( dp [ n - 1 ] ) NEW_LINE DEDENT n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = [ int ( input ( ) ) for i in range ( m ) ] NEW_LINE c = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE solve ( n , m , d , c ) NEW_LINE
n , k , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l [ : k ] ) NEW_LINE print ( s - s ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m , a , d = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c , x = 0 , 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT x += w [ i ] // a NEW_LINE if x <= n : NEW_LINE INDENT c += x // a NEW_LINE x = ( x - 1 ) // a + 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += x // a NEW_LINE x = ( x - 1 ) // a + 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
import math NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE d = 1 NEW_LINE while d < n : NEW_LINE INDENT d += 1 NEW_LINE DEDENT ans += d * ( n - d ) NEW_LINE print ( ans ) NEW_LINE DEDENT
s = input ( ) NEW_LINE a = [ 0 , ' Second ' ] NEW_LINE for c in s : NEW_LINE INDENT if ord ( c ) - ord ( ' a ' ) == 1 : NEW_LINE INDENT a . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ ord ( c ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT print ( ' First ' if a [ 1 ] % 2 == 0 else ' Second ' ) NEW_LINE
def reverse ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT n = reverse ( n ) ; NEW_LINE sumOdd = 0 ; NEW_LINE sumEven = 0 ; NEW_LINE c = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT sumEven += n % 10 ; NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += n % 10 ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE c += 1 ; NEW_LINE DEDENT print ( " Sum ▁ odd ▁ = " , sumOdd ) ; NEW_LINE print ( " Sum ▁ even ▁ = " , sumEven ) ; NEW_LINE DEDENT n = 457892 ; NEW_LINE getSum ( n ) ; NEW_LINE
def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT def row ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE row_no = 0 NEW_LINE if h < w : NEW_LINE INDENT row_no = row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( ht , h ) NEW_LINE DEDENT disp ( row_no , no_block ) NEW_LINE DEDENT l = 50 NEW_LINE w = 20 NEW_LINE h = 35 NEW_LINE a = 700 NEW_LINE ht = 140 NEW_LINE calculate ( l , w , h , a , ht ) NEW_LINE
bin = [ "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" ] NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] NEW_LINE DEDENT count = 1 NEW_LINE prev = - 1 NEW_LINE j = 0 NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) NEW_LINE prev = j NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT octal = "13" NEW_LINE print ( maxFreq ( octal ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 for i in range ( n ) ] NEW_LINE cc = [ 0 for i in range ( n ) ] NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT cv [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) ) NEW_LINE if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) ) NEW_LINE DEDENT DEDENT ans = " " NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += str ( prod ) NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ) NEW_LINE ans += str ( prod ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = Sum + ( freq [ i ] / arr [ i ] ) NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( frequency_sum / Sum ) NEW_LINE DEDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = len ( num ) NEW_LINE print ( harmonicMean ( num , freq , n ) ) NEW_LINE
import math as mt NEW_LINE def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * math . pi / 180 ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( polyarea ( n , a ) ) NEW_LINE DEDENT
from math import sqrt , gcd NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return ( a // gcd ( a , b ) * b ) NEW_LINE DEDENT def getMinValue ( c ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( 1 , int ( sqrt ( c ) ) + 1 ) : NEW_LINE INDENT if ( c % i == 0 and lcm ( i , c // i ) == c ) : NEW_LINE INDENT ans = min ( ans , max ( i , c // i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT c = 6 NEW_LINE print ( getMinValue ( c ) ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n , m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == n == 0 : break NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = a [ 0 : n - 1 ] NEW_LINE ans = 0 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT if b [ i ] <= a [ i ] : ans = i NEW_LINE else : break NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT X , K , M , Q = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( M ) ] NEW_LINE inf = float ( ' inf ' ) NEW_LINE for a in A : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT inf = 1 NEW_LINE DEDENT elif a == 1 : NEW_LINE INDENT inf = 1 NEW_LINE DEDENT DEDENT if inf == int ( ' inf ' ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif inf == int ( ' inf ' ) : NEW_LINE INDENT print ( ' inf ' ) NEW_LINE DEDENT elif x < 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if x * K < M : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 NEW_LINE while x * K <= M : NEW_LINE INDENT if A [ x ] == inf : NEW_LINE INDENT k += 1 NEW_LINE x *= K NEW_LINE DEDENT elif A [ x ] > inf : NEW_LINE INDENT x *= - 1 NEW_LINE DEDENT DEDENT print ( k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a , reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ i + 1 ] : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEW_LINE return round ( fibo ) NEW_LINE DEDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n2 < n1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT if ( isSmaller ( str1 , str2 ) ) : NEW_LINE INDENT t = str1 NEW_LINE str1 = str2 NEW_LINE str2 = t NEW_LINE DEDENT str = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE str1 = str1 [ : : - 1 ] NEW_LINE str2 = str2 [ : : - 1 ] NEW_LINE carry = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT sub = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) - ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) - carry ) ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + ord ( '0' ) ) NEW_LINE DEDENT for i in range ( n2 , n1 ) : NEW_LINE INDENT sub = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) - carry ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + ord ( '0' ) ) NEW_LINE DEDENT return str [ : : - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "978" NEW_LINE str2 = "12977" NEW_LINE print ( findDiff ( str1 , str2 ) ) NEW_LINE s1 = "100" NEW_LINE s2 = "1000000" NEW_LINE print ( findDiff ( s1 , s2 ) ) NEW_LINE DEDENT
def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 ; c1 = 0 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT elif ( s1 [ i ] == '1' and s2 [ i ] == '0' ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT ans = c0 // 2 + c1 // 2 ; NEW_LINE if ( c0 % 2 == 0 and c1 % 2 == 0 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT elif ( ( c0 + c1 ) % 2 == 0 ) : NEW_LINE INDENT return ans + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = "0011" ; NEW_LINE s2 = "1111" ; NEW_LINE ans = minSwaps ( s1 , s2 ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from functools import lru_cache NEW_LINE @ lru_cache ( maxsize = None ) NEW_LINE def search ( x , i , l , r ) : NEW_LINE INDENT if i < l or r < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a [ i ] <= x or i > l : NEW_LINE INDENT return 0 NEW_LINE DEDENT a [ i ] += x NEW_LINE r += 1 NEW_LINE DEDENT a [ i ] = 0 NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] <= x : NEW_LINE INDENT a [ i + 1 ] += x [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a [ i + 1 ] = x [ i ] NEW_LINE DEDENT DEDENT return a [ - 1 ] NEW_LINE DEDENT print ( search ( 0 , n - 1 , a ) ) NEW_LINE
s = list ( input ( ) ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == " ^ " : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif s [ i ] != "1" : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT if r < l : NEW_LINE INDENT print ( " left " ) NEW_LINE DEDENT elif r > l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " balance " ) NEW_LINE DEDENT
def normalSieve ( n ) : NEW_LINE INDENT prime = [ False ] * ( n // 2 ) NEW_LINE i = 3 NEW_LINE while ( i * i < n ) : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT for j in range ( i * i , n , i * 2 ) : NEW_LINE INDENT prime [ j // 2 ] = True NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT print ( "2 ▁ " , end = " " ) NEW_LINE for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 100 NEW_LINE normalSieve ( n ) NEW_LINE
word = input ( ) NEW_LINE word_count = 0 NEW_LINE for word in word : NEW_LINE INDENT if word . isupper ( ) : NEW_LINE INDENT word_count += 1 NEW_LINE DEDENT DEDENT if word_count == len ( word ) : NEW_LINE INDENT print ( word . lower ( ) ) NEW_LINE DEDENT elif word_count == 1 : NEW_LINE INDENT print ( word . upper ( ) ) NEW_LINE DEDENT elif word_count == 2 : NEW_LINE INDENT print ( word . lower ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( word . upper ( ) ) NEW_LINE DEDENT
def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT mn = arr [ 0 ] NEW_LINE freq = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < mn ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE freq = 1 NEW_LINE DEDENT elif ( arr [ i ] == mn ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 , 4 ] NEW_LINE print ( frequencyOfSmallest ( N , arr ) ) NEW_LINE DEDENT
def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i = 0 ; j = 0 ; NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE j += 1 ; NEW_LINE if ( j == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 ; NEW_LINE j = 0 ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] ; NEW_LINE n = len ( A ) ; NEW_LINE B = [ 3 , 0 , 5 , 1 ] ; NEW_LINE m = len ( B ) ; NEW_LINE if ( isSubArray ( A , B , n , m ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) . split ( ) NEW_LINE s = [ int ( i ) for i in s ] NEW_LINE print ( s [ n - 1 ] + 1 + sum ( abs ( i - s [ n - 2 ] ) for i in range ( n - 1 ) ) ) NEW_LINE
def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE def LI2 ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) ) ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def LS2 ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE N = I ( ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if N >= 5 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT if N < 3 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT if N < 6 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT x = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = list ( S ( ) ) NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT t = ' ' NEW_LINE if a [ j ] == ' A ' : NEW_LINE INDENT t += ' C ' NEW_LINE DEDENT if a [ j ] == ' G ' : NEW_LINE INDENT t += ' T ' NEW_LINE DEDENT DEDENT x [ i ] += 1 NEW_LINE DEDENT print ( x [ N - 1 ] % ( 10 ** 9 + 7 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s = ' A ' NEW_LINE for j in range ( N + 1 ) : NEW_LINE INDENT if a [ j ] == ' C ' : NEW_LINE INDENT s += ' G ' NEW_LINE DEDENT if b [ j ] == ' G ' : NEW_LINE INDENT s += ' T ' NEW_LINE DEDENT if c [ j ] == ' T ' : NEW_LINE INDENT s += ' A ' NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
import sys , math , os NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT c , t = [ [ int ( _ ) for _ in input ( ) . split ( ' , ' ) ] for __ in range ( 3 ) ] NEW_LINE print ( sum ( [ c [ i ] [ 0 ] * t [ 1 ] for i in range ( 3 ) ] ) // len ( c ) ) NEW_LINE
MAX = 100 ; NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE C [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( sumOfproduct ( n ) ) ; NEW_LINE
a = input ( ) NEW_LINE b = input ( ) NEW_LINE if a == b : NEW_LINE INDENT print ( " Are ▁ both ▁ ▁ strings ▁ same : ▁ " , " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math as mt NEW_LINE def pairCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairCount ( arr , n ) ) NEW_LINE
import math as mt NEW_LINE def getPrime ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( int ( v ) for v in NUMBERS ) NEW_LINE return str ( ans ) NEW_LINE DEDENT NUMBERS = [ "37107287533902102798797998220837590246510135740250" , "46376937677490009712648124896970078050417018260538" , "74324986199524741059474233309513058123726617309629" , "23067588207539346171171980310421047513778063246676" , "89261670696623633820136378418383684178734361726757" , "28112879812849979408065481931592621691275889832738" , "44274228917432520321923589422876796487670272189318" , "47451445736001306439091167216856844588711603153276" , "703864861058430254399396198289175936656560629502157223196586755079324193331" , "64906352462741904929101432445813822663347944758178" , "92575867718337217661963751590579239728245598838407" , "58203565325359399008402633568948830189458628227828" , "80121989404" , "05444244359399008402633568948830189458628227828" , "8013198948948830189458628227829' , "054442458617866458359894041861786645835900422421989488314260769004224219894022626262626" , "05444
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printDistinct ( arr , n ) ; NEW_LINE DEDENT
import sys NEW_LINE def main ( args ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( A * B ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif ( n % 6 == 4 ) : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT if ( n % 6 == 0 ) : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT a = 10 NEW_LINE b = 17 NEW_LINE n = 3 NEW_LINE print ( nth_term ( a , b , n ) ) NEW_LINE
def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def combinedSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE range = ( 1 << n ) - 1 NEW_LINE for i in range ( range ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT s = "123" NEW_LINE print ( combinedSum ( s ) ) NEW_LINE
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 ; dp2 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) ; NEW_LINE dp2 = dp1 ; NEW_LINE dp1 = dp0 ; NEW_LINE DEDENT return min ( dp1 , dp2 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minimumCost ( a , n ) ) ; NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return ( int ( n / 3 ) + int ( n / 7 ) - int ( n / 21 ) ) NEW_LINE DEDENT print ( " Count ▁ = " , countMultiples ( 25 ) ) NEW_LINE
SIZE = 26 NEW_LINE def longSubstring ( str , k ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE start = 0 NEW_LINE maxLen = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE freq [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT if ( maxLen < ( i - start ) ) : NEW_LINE INDENT maxLen = i - start NEW_LINE DEDENT while ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT freq [ ord ( str [ start ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT if ( maxLen < ( n - start ) ) : NEW_LINE INDENT maxLen = n - start NEW_LINE DEDENT return maxLen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " babcaag " NEW_LINE k = 1 NEW_LINE print ( " Length ▁ = " , longSubstring ( str , k ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = 0 NEW_LINE a , b = 0 , 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE s += x NEW_LINE a += y NEW_LINE b += y NEW_LINE if a < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT elif a <= s : NEW_LINE INDENT print ( s ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT hex_map = "0123456789abcdef " NEW_LINE if num == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT res = " " NEW_LINE while num != 0 and len ( res ) < 8 : NEW_LINE INDENT res = hex_map [ num & 15 ] + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . toHex ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if ( k * 2 + ( n // 2 ) ) ** 0.5 == int ( ( k * 2 + ( n // 2 ) ) ** 0.5 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( " L " , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " S " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 for i in range ( 26 ) ] NEW_LINE count2 = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result += chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " geeks " NEW_LINE str2 = " cake " NEW_LINE longestString ( str1 , str2 ) NEW_LINE DEDENT
def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l / mul ) * mul == ( r / mul ) * mul ) : NEW_LINE INDENT if ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( r & ( 1 << i ) ) != 0 and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( odd_c != 0 ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if ( l % 2 == 1 and r % 2 == 1 ) : NEW_LINE INDENT zero_bit_cnt += 1 NEW_LINE DEDENT if ( zero_bit_cnt % 2 == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE DEDENT
def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q4 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abbaabb " ; NEW_LINE q0 ( s , 0 ) ; NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE s = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s . append ( a ) NEW_LINE for k in range ( n * b , 0 , - 1 ) : NEW_LINE INDENT for t in range ( 0 , - ~ int ( k / a ) ) : NEW_LINE INDENT s [ k + t ] += s [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( * s , sep = " \n " ) NEW_LINE DEDENT
def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( ord ( T [ 0 ] ) - ord ( '0' ) ) * 10 + ( ord ( T [ 1 ] ) - ord ( '0' ) ) * 60 + ( ( ord ( T [ 3 ] ) - ord ( '0' ) ) * 10 + T [ 4 ] - ord ( '0' ) ) ) NEW_LINE minutes += K NEW_LINE hour = ( minutes // 60 ) % 24 NEW_LINE min = minutes % 60 NEW_LINE if ( hour < 10 ) : NEW_LINE INDENT print ( "0" , hour , " : " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( hour , " : " , end = " " ) NEW_LINE DEDENT if ( min < 10 ) : NEW_LINE INDENT print ( "0" , min , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min , end = " " ) NEW_LINE DEDENT DEDENT T = "21:39" NEW_LINE K = 43 NEW_LINE findTime ( T , K ) NEW_LINE
import sys NEW_LINE def maxProductSum ( str , m ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxProd = - ( sys . maxsize - 1 ) NEW_LINE maxSum = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - m ) : NEW_LINE INDENT product = 1 NEW_LINE sum = 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ = " , maxProd ) NEW_LINE print ( " Maximum ▁ Sum ▁ = " , maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " 3675356291" NEW_LINE m = 5 NEW_LINE maxProductSum ( str , m ) NEW_LINE DEDENT
import sys NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE k = n // 2 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k -= a [ i ] NEW_LINE res += abs ( k - a [ 2 * i ] ) NEW_LINE DEDENT print ( res ) NEW_LINE
class UnionFind : NEW_LINE INDENT def __init__ ( self , size ) : NEW_LINE INDENT self . table = [ None ] * size NEW_LINE DEDENT def find ( self , x ) : NEW_LINE INDENT if self . table [ x ] == None : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT self . table [ x ] = self . find ( self . table [ x ] ) NEW_LINE return self . table [ x ] NEW_LINE DEDENT DEDENT def unite ( self , x , y ) : NEW_LINE INDENT x = self . find ( x ) NEW_LINE y = self . find ( y ) NEW_LINE if x == y : NEW_LINE INDENT return NEW_LINE DEDENT if self . table [ x ] < self . table [ y ] : NEW_LINE INDENT self . table [ x ] = y NEW_LINE DEDENT else : NEW_LINE INDENT self . table [ y ] = x NEW_LINE if self . table [ x ] == self . table [ y ] : NEW_LINE INDENT self . table [ x ] = y NEW_LINE DEDENT DEDENT DEDENT def same ( self , x , y ) : NEW_LINE INDENT return self . find ( x ) == self . find ( y ) NEW_LINE DEDENT DEDENT N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE if N == Q : NEW_LINE INDENT return False NEW_LINE DEDENT parent = [ 0 ] * ( N ) NEW_LINE rank = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if parent [ i ] != i : NEW_LINE INDENT if rank [ parent [ i ] ] > 1 : NEW_LINE INDENT rank [ parent [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT rank [ parent [ i ] ] -= 1 NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT op , x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE if op == 0 : NEW_LINE INDENT if same ( x , y ) : NEW_LINE INDENT print ( " ? " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( rank [ x ] - rank [ y ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT unite ( x , y ) NEW_LINE DEDENT DEDENT DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( A , B ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 6 ; B = 15 ; M = 3 ; NEW_LINE print ( sumDivisibles ( A , B , M ) ) ; NEW_LINE DEDENT
import math NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = ( int ) ( math . log10 ( n ) ) NEW_LINE a = [ 0 for i in range ( d + 2 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + math . ceil ( math . pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to " , n , " that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is " , countNumbersWith4 ( n ) ) NEW_LINE
import math NEW_LINE from functools import reduce NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE import itertools NEW_LINE from collections import deque , Counter NEW_LINE def i_input ( ) : return int ( input ( ) ) NEW_LINE def i_map ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def i_list ( ) : return list ( i_map ( ) ) NEW_LINE def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] NEW_LINE def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] NEW_LINE def s_input ( ) : return input ( ) NEW_LINE def s_map ( ) : return input ( ) . split ( ) NEW_LINE def s_list ( ) : return list ( s_map ( ) ) NEW_LINE def s_row ( N ) : return [ s_input for _ in range ( N ) ] NEW_LINE def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] NEW_LINE def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] NEW_LINE def main ( ) : NEW_LINE INDENT x , y = i_map ( ) NEW_LINE dic = { } NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i , j in dic . items ( ) : NEW_LINE INDENT if j % 2 == 1 : NEW_LINE INDENT dic [ i , j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dic [ i , j ] = 0 NEW_LINE DEDENT DEDENT k = s_input ( ) NEW_LINE ans = 0 NEW_LINE for k in dic . keys ( ) : NEW_LINE INDENT ans += ( k - 1 ) * dic [ k ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def findPostOrderUtil ( self , pre , n , minval , maxval , preIndex ) : NEW_LINE INDENT if ( preIndex . data == n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( pre [ preIndex . data ] < minval or pre [ preIndex . data ] > maxval ) : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ preIndex . data ] NEW_LINE preIndex . data += 1 NEW_LINE findPostOrderUtil ( pre , n , minval , val , preIndex ) NEW_LINE findPostOrderUtil ( pre , n , val , maxval , preIndex ) NEW_LINE print ( val , end = " ▁ " ) NEW_LINE DEDENT def findPostOrder ( self , pre , n ) : NEW_LINE INDENT preIndex = 0 NEW_LINE findPostOrderUtil ( self . pre , n , - 2147483648 , 2147483647 , preIndex ) NEW_LINE DEDENT pre = [ 40 , 30 , 35 , 80 , 100 ] NEW_LINE n = len ( pre ) NEW_LINE findPostOrder ( pre , n ) NEW_LINE
def countWays ( n , arr , k ) : NEW_LINE INDENT if ( k <= 0 or k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( ) NEW_LINE for i in arr : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT if ( len ( s ) <= k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( n , arr , k ) ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = readline ( ) . strip ( ) NEW_LINE res = [ ] NEW_LINE for c in S [ : : - 1 ] . split ( ' : ' ) : NEW_LINE INDENT res . append ( '0' * ( 8 - len ( c ) ) ) NEW_LINE DEDENT write ( " \n " . join ( map ( " , " . join ( res ) ) ) ) NEW_LINE DEDENT T = int ( readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
from math import sqrt , floor NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 ; NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return ( flag == 1 ) ; NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) ; NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) ; NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT j = 1 ; NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 ; NEW_LINE break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 ; NEW_LINE print ( countInterestingPrimes ( N ) ) ; NEW_LINE DEDENT
import sys NEW_LINE import re NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from copy import copy NEW_LINE from collections import deque , Counter NEW_LINE from decimal import Decimal NEW_LINE import functools NEW_LINE def v ( ) : return input ( ) NEW_LINE def k ( ) : return int ( input ( ) ) NEW_LINE def S ( ) : return input ( ) . split ( ) NEW_LINE def I ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def X ( ) : return list ( input ( ) ) NEW_LINE def L ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def lcm ( a , b ) : return a * b // math . gcd ( a , b ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE cnt = 0 NEW_LINE ans = 1 NEW_LINE inf = float ( " inf " ) NEW_LINE al = " abcdefghijklmnopqrstuvwxyz " NEW_LINE AL = al . upper ( ) NEW_LINE n = k ( ) NEW_LINE S = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT S . append ( input ( ) ) NEW_LINE DEDENT L . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if L [ i ] [ 0 ] != L [ i - 1 ] [ 0 ] : NEW_LINE INDENT print ( " No " ) NEW_LINE quit ( ) NEW_LINE DEDENT DEDENT print ( " Yes " ) NEW_LINE
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT div = [ 8 , 3 ] ; NEW_LINE rem = [ 2 , 2 ] ; NEW_LINE N = len ( div ) ; NEW_LINE print ( findNum ( div , rem , N ) ) ; NEW_LINE DEDENT
def segregate0and1 ( arr ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = len ( arr ) - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT arr [ type1 ] = arr [ type1 ] + arr [ type0 ] NEW_LINE arr [ type0 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE arr [ type1 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT array = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE segregate0and1 ( array ) NEW_LINE print ( " Array ▁ after ▁ segregation ▁ is " , end = " ▁ " ) NEW_LINE for a in array : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = set ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( l [ i ] ) NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT l . append ( ' U ' ) NEW_LINE DEDENT elif s [ i ] == t [ i ] : NEW_LINE INDENT l . append ( ' D ' ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( ' L ' ) NEW_LINE DEDENT DEDENT a = abs ( l [ 0 ] [ 0 ] - l [ 0 ] [ 1 ] ) NEW_LINE b = abs ( l [ 1 ] [ 0 ] - l [ 1 ] [ 0 ] ) NEW_LINE c = abs ( l [ 1 ] [ 1 ] - l [ 1 ] [ 1 ] ) NEW_LINE ans = ' ' NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if l [ i ] > 0 : NEW_LINE INDENT ans += ' U ' NEW_LINE DEDENT elif l [ i ] < 0 : NEW_LINE INDENT ans += ' D ' NEW_LINE DEDENT else : NEW_LINE INDENT ans += ' L ' NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE import itertools NEW_LINE import time NEW_LINE import math NEW_LINE import heapq NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] NEW_LINE acc = [ [ 0 ] * ( W + 1 ) for _ in range ( H ) ] NEW_LINE for h in range ( H ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT acc [ h ] [ w ] += 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT res += A [ i ] [ j ] * ( acc [ i ] [ j ] + acc [ i ] [ 0 ] * ( H - i ) ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
n = int ( input ( ) ) NEW_LINE lis = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT val = [ '1' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lis [ i ] [ 0 ] == val [ i ] : NEW_LINE INDENT val [ i ] = '0' NEW_LINE DEDENT DEDENT flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if lis [ i ] [ j ] == val [ j ] : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE readlines = sys . stdin . readlines NEW_LINE from functools import lru_cache NEW_LINE X , Y = map ( int , readline ( ) . split ( ) ) NEW_LINE @ lru_cache ( None ) NEW_LINE def can_make ( A , B ) : NEW_LINE INDENT if A == B : NEW_LINE INDENT return False NEW_LINE DEDENT if B % 2 == 0 : NEW_LINE INDENT return can_make ( ( A + 1 ) // 2 , B // 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT @ lru_cache ( None ) NEW_LINE def F ( A , B ) : NEW_LINE INDENT if A == B : NEW_LINE INDENT return 1 NEW_LINE DEDENT ev = F ( ( A + 1 ) // 2 , B // 2 ) NEW_LINE if A % 2 == 0 : NEW_LINE INDENT A += 1 NEW_LINE DEDENT if B % 2 == 1 : NEW_LINE INDENT od = F ( A // 2 , B // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT od = F ( A // 2 , B // 2 ) NEW_LINE if not can_make ( A // 2 , B // 2 ) : NEW_LINE INDENT od -= 1 NEW_LINE DEDENT DEDENT return ev + od NEW_LINE DEDENT answer = F ( A , B ) NEW_LINE print ( answer ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT c = bin ( n ) [ 2 : ] NEW_LINE ans . append ( c ) NEW_LINE DEDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT c = bin ( n ^ i ) [ 2 : ] NEW_LINE ans . append ( c ) NEW_LINE DEDENT t = 1 NEW_LINE for i in range ( 1 , 32 ) : NEW_LINE INDENT t *= 2 NEW_LINE DEDENT print ( * ans , sep = ' ' ) NEW_LINE
import sys NEW_LINE def solve ( N : int , S : " List [ str ] " ) : NEW_LINE INDENT a = [ 0 ] * 5 NEW_LINE b = [ 0 ] * 5 NEW_LINE for s in S : NEW_LINE INDENT a [ ord ( s ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT b [ ord ( S [ i - 1 ] ) - 97 ] += 1 NEW_LINE DEDENT b [ ord ( S [ 0 ] ) - 97 ] += 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT c = b [ i ] * b [ j - 1 ] * b [ i ] NEW_LINE if c < a [ i ] : NEW_LINE INDENT c = a [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( sum ( c ) ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE S = [ next ( tokens ) for _ in range ( N ) ] NEW_LINE solve ( N , S ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , m = [ int ( s ) for s in input ( ) . split ( " ▁ " ) ] NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE b = [ int ( input ( ) ) for i in range ( m ) ] NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = c [ i ] + a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT c [ i ] = c [ i ] + b [ i ] NEW_LINE DEDENT j = 0 NEW_LINE ans = 0 NEW_LINE f = 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if c [ i ] < c [ j ] : NEW_LINE INDENT f = 1 NEW_LINE c [ i ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] = c [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while f and i < n and j < m : NEW_LINE INDENT if c [ i ] < c [ j ] : NEW_LINE INDENT f = 1 NEW_LINE c [ i ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c [ j ] = c [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT ans = ans + f NEW_LINE i = j + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " ? " : NEW_LINE INDENT break NEW_LINE DEDENT val = int ( s [ 2 : - 1 ] ) NEW_LINE if s [ 1 ] == " + " : NEW_LINE INDENT print ( val + int ( s [ 3 : ] ) ) NEW_LINE DEDENT elif s [ 1 ] == " - " : NEW_LINE INDENT print ( val - int ( s [ 2 : ] ) ) NEW_LINE DEDENT elif s [ 1 ] == " * " : NEW_LINE INDENT print ( val * int ( s [ 3 : ] ) ) NEW_LINE DEDENT elif s [ 1 ] == " / " : NEW_LINE INDENT print ( int ( s [ 2 : ] ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE import numpy as np NEW_LINE stdin = sys . stdin NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) NEW_LINE def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n = ni ( ) NEW_LINE A = nl ( ) NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT if a != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= n : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT n = 6 NEW_LINE arr = [ 100 , 11 , 500 , 2 , 17 , 1 ] NEW_LINE sortedArray ( arr , n ) NEW_LINE
from math import gcd as __gcd NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def gcdFibonacciFreq ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE createHash ( hash , max ( arr ) ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT __gcd = 0 NEW_LINE for it in m : NEW_LINE INDENT if ( dic [ it ] ) : NEW_LINE INDENT __gcd = __gcd ( __gcd , it ) NEW_LINE DEDENT DEDENT return __gcd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdFibonacciFreq ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = ( 3.14 * R * R ) / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 ; NEW_LINE print ( " ▁ Area ▁ of ▁ semicircle ▁ = " , round ( find_Area ( a ) , 4 ) ) ; NEW_LINE DEDENT
def findQuadruples ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 0 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findQuadruples ( a , b , c , d , x , n ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE class Query : NEW_LINE INDENT def __init__ ( self , l , r , n ) : NEW_LINE INDENT self . l = l NEW_LINE self . r = r NEW_LINE self . n = n NEW_LINE DEDENT DEDENT def printSmallest ( s , q ) : NEW_LINE INDENT N = len ( s ) NEW_LINE H = np . zeros ( ( N + 1 , 26 ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT H [ i ] [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT m = len ( q ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT l = q [ j ] [ 0 ] NEW_LINE r = q [ j ] [ 1 ] NEW_LINE n = q [ j ] [ n ] NEW_LINE sum = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] NEW_LINE if sum >= n : NEW_LINE INDENT print ( chr ( 97 + i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " afbccdeb " NEW_LINE q = [ ( Query ( 2 , 4 , 1 ) , ( Query ( 1 , 6 , 4 ) , Query ( 1 , 8 , 7 ) ) ] NEW_LINE printSmallest ( s , q ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE min_el = 1 NEW_LINE while min_el <= n : NEW_LINE INDENT if s . count ( '1' ) == 0 : NEW_LINE INDENT ans += n NEW_LINE min_el += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += min_el NEW_LINE min_el = 0 NEW_LINE DEDENT DEDENT if s . count ( '0' ) == 0 : NEW_LINE INDENT ans += n NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - min_el ) * k NEW_LINE min_el = s . count ( '0' ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( ( n + 2 ) // 3 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % x == 0 : NEW_LINE INDENT for i in range ( x , n , x ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE break NEW_LINE DEDENT DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) ; NEW_LINE DEDENT print ( " Double ▁ factorial ▁ is " , doublefactorial ( 5 ) ) NEW_LINE
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 ; NEW_LINE h = len ( str ) - 1 ; NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT l += 1 ; NEW_LINE h -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def minRemovals ( str ) : NEW_LINE INDENT if ( str [ 0 ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 2 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( minRemovals ( "010010" ) ) ; NEW_LINE print ( minRemovals ( "0100101" ) ) ; NEW_LINE DEDENT
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 ] * n NEW_LINE sumofdigit [ 0 ] = ord ( num [ 0 ] ) - ord ( '0' ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = "1234" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE ans += n * ( a // n ) * ( b // n ) ; NEW_LINE ans += ( a // n ) * ( b % n ) ; NEW_LINE ans += ( ( a % n ) * ( b // n ) ) ; NEW_LINE ans += ( ( a % n ) + ( b % n ) ) / n ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT a = 5 ; b = 13 ; n = 3 ; NEW_LINE print ( findCountOfPairs ( a , b , n ) ) ; NEW_LINE
def compute ( ) : NEW_LINE INDENT LIMIT = 1000000 NEW_LINE ans = max_d = 1 NEW_LINE for d in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if n * max_d > ans * d : NEW_LINE INDENT ans = n * max_d NEW_LINE ans_d = d NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
c = [ 0 ] * 100 ; NEW_LINE def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 1 + i ] = 1 ; NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] ; NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT coef ( n ) ; NEW_LINE c [ 0 ] += 1 ; NEW_LINE c [ n ] -= 1 ; NEW_LINE i = n ; NEW_LINE while ( ( i ) > 0 ) : NEW_LINE INDENT if ( c [ i ] % n == 0 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT return i < 0 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 37 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Prime " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) ; NEW_LINE DEDENT DEDENT
import sys NEW_LINE def count_greater ( arr , n ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE counter = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT counter += 1 ; NEW_LINE DEDENT if ( arr [ i ] <= min ) : NEW_LINE INDENT min = arr [ i ] ; NEW_LINE DEDENT DEDENT return counter ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( count_greater ( arr , n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def eat ( i , j , candies , counter ) : NEW_LINE INDENT s = candies [ i ] + candies [ j ] NEW_LINE if s > x : NEW_LINE INDENT if candies [ i ] >= s - x : NEW_LINE INDENT candies [ i ] -= s - x NEW_LINE DEDENT else : NEW_LINE INDENT candies [ j ] -= s - x - candies [ i ] NEW_LINE candies [ i ] = 0 NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT def main ( n , x , candies ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT counter = eat ( i , i - 1 , candies , counter ) NEW_LINE DEDENT return counter NEW_LINE DEDENT n , x = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE candies = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE print ( main ( n , x , candies ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE ok = False NEW_LINE for _ in range ( n ) : NEW_LINE INDENT p , q = input ( ) . split ( ) NEW_LINE if int ( q ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if int ( p ) == 1 : NEW_LINE INDENT ok = True NEW_LINE DEDENT DEDENT if ok : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT t , d , l = map ( int , input ( ) . split ( ) ) NEW_LINE if t == d == l == 0 : break NEW_LINE a = [ int ( input ( ) ) for _ in range ( t ) ] NEW_LINE s = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] <= d : s += 1 NEW_LINE if a [ i ] >= l : s += 1 NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def minimumSwaps ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumSwaps ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 500500 NEW_LINE MODULUS = 500500507 NEW_LINE queue = PriorityQueue ( ) NEW_LINE nextPrime = 2 NEW_LINE queue . put ( nextPrime ) NEW_LINE product = 1 NEW_LINE for i in range ( TARGET ) : NEW_LINE INDENT item = queue . get ( ) NEW_LINE product *= item % MODULUS NEW_LINE queue . put ( item * item ) NEW_LINE if item == nextPrime : NEW_LINE INDENT while True : NEW_LINE INDENT nextPrime += 1 NEW_LINE if nextPrime >= eulerlib . is_prime ( nextPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT queue . put ( nextPrime ) NEW_LINE DEDENT DEDENT return str ( product ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( ( arr [ i ] & set_bit_no ) > 0 ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( " , x , " , " , y , " ) " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] NEW_LINE n = len ( a ) NEW_LINE findUniquePair ( a , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE a . append ( s ) NEW_LINE DEDENT x = a [ 0 ] [ : : - 1 ] NEW_LINE if len ( x ) > len ( a ) or a [ x ] == x : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT j = 0 NEW_LINE f = 0 NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if a [ i ] [ 0 ] != x [ j ] [ 0 ] or a [ i ] [ 1 ] != x [ j ] [ 1 ] : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if f == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == len ( a ) - 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT t = " " NEW_LINE for i in s : NEW_LINE INDENT if i == " @ " : NEW_LINE INDENT t += i NEW_LINE continue NEW_LINE DEDENT t += str ( int ( i ) ) NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in a : NEW_LINE INDENT if i in mp . keys ( ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] >= n // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isMajority ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
N , W = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE value = [ ] NEW_LINE weight = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT a , b = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE value . append ( a ) NEW_LINE weight . append ( b ) NEW_LINE DEDENT def knap ( N , W , value , weight ) : NEW_LINE INDENT dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT if weight [ i - 1 ] <= w : NEW_LINE INDENT dp [ i ] [ w ] = max ( dp [ i - 1 ] [ w ] , dp [ i - 1 ] [ w - weight [ i - 1 ] ] + value [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ w ] = dp [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ N ] [ W ] NEW_LINE DEDENT print ( knap ( N , W , value , weight ) ) NEW_LINE
from math import radians , cos , sin , ceil , floor NEW_LINE g = 90 NEW_LINE while 1 : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE if b == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT s = 0 NEW_LINE a = g NEW_LINE while g > 1 : NEW_LINE INDENT if a > s : NEW_LINE INDENT a = s / 2 NEW_LINE b = g NEW_LINE g -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += a NEW_LINE g -= a NEW_LINE DEDENT DEDENT print ( radians ( g ) ) NEW_LINE g = a / 2 NEW_LINE DEDENT
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT count = 0 ; curr = 1 ; NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT curr += 1 ; NEW_LINE DEDENT while ( count < k ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) ; NEW_LINE curr += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE printKMissing ( arr , n , k ) ; NEW_LINE DEDENT
def printNumbers ( a , n ) : NEW_LINE INDENT mpp = { } ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] ; NEW_LINE for j in range ( 1 , int ( num ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT mpp [ j ] = mpp [ j ] + 1 ; NEW_LINE DEDENT if ( ( num // j ) != j ) : NEW_LINE INDENT mpp [ num // j ] = mpp [ num // j ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT maxi = 0 ; NEW_LINE for it in mpp : NEW_LINE INDENT maxi = max ( mpp [ it ] , maxi ) ; NEW_LINE DEDENT for it in mpp : NEW_LINE INDENT if ( mpp [ it ] == maxi ) : NEW_LINE INDENT print ( it , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 12 , 15 , 27 , 20 , 40 ] ; NEW_LINE n = len ( a ) ; NEW_LINE printNumbers ( a , n ) ; NEW_LINE DEDENT
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' a ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt > ( n - cnt ) // 2 : NEW_LINE INDENT print ( ' : ( ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ : n - cnt ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( s ) NEW_LINE print ( max ( s ) ) NEW_LINE
def checkIfStartsWithCapital ( string ) : NEW_LINE INDENT if ( string [ 0 ] . isupper ( ) and string [ 0 ] . islower ( ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def check ( string ) : NEW_LINE INDENT if ( checkIfStartsWithCapital ( string ) ) : NEW_LINE INDENT print ( " Accepted " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Accepted " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksforGeeks " ; NEW_LINE check ( string ) ; NEW_LINE string = " geeksforgeeks " ; NEW_LINE check ( string ) ; NEW_LINE DEDENT
def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) / ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( "Average ▁ of " , ( i + 1 ) , " numbers ▁ is " , avg ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE isprime = eulerlib . list_primality ( LIMIT ) NEW_LINE primes = eulerlib . list_primes ( LIMIT ) NEW_LINE maxsum = 0 NEW_LINE maxrun = - 1 NEW_LINE for i in itertools . count ( len ( primes ) ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in itertools . count ( i ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE if sum > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT elif j - i > maxrun and sum > maxsum and isprime [ sum ] : NEW_LINE INDENT maxsum = sum NEW_LINE maxrun = j - i NEW_LINE DEDENT DEDENT DEDENT return str ( maxsum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE lst = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 ) : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lst [ i ] ) : NEW_LINE INDENT max = lst [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ lst ▁ is " , lis ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Yes " if sqrt ( a ) == int ( sqrt ( b ) ) + 1 else " No " ) NEW_LINE
def fix ( A , len ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT s . add ( A [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ) : NEW_LINE INDENT if i in s : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 ] NEW_LINE fix ( A , len ( A ) ) NEW_LINE print ( A ) NEW_LINE
a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a [ 0 ] += a [ 1 ] NEW_LINE a [ 1 ] += a [ 0 ] NEW_LINE a [ 2 ] += a [ 1 ] NEW_LINE a [ 3 ] += a [ 2 ] NEW_LINE print ( min ( a [ 0 ] , a [ 1 ] , a [ 3 ] ) ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def makeOddNode ( head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE i = 0 NEW_LINE while ( ptr != None ) : NEW_LINE INDENT next = ptr . next NEW_LINE if ( ptr . data % 2 == 0 ) : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE Arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 6 ) NEW_LINE n = len ( Arr ) NEW_LINE print ( " Original ▁ List : ▁ " , end = " " ) NEW_LINE printList ( head ) NEW_LINE print ( ) NEW_LINE head = makeOddNode ( head , Arr , n ) NEW_LINE print ( " New ▁ odd ▁ List : ▁ " , end = " " ) NEW_LINE printList ( head ) NEW_LINE DEDENT
from __future__ import division , print_function NEW_LINE from sys import stdin , exit NEW_LINE def make_number_of_combination ( ) : NEW_LINE INDENT pre = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE now = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE for a in range ( 101 ) : NEW_LINE INDENT now [ a ] [ 0 ] = 1 NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT if i + a > 10 : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( 9 ) : NEW_LINE INDENT now [ i + a ] [ j + 1 ] += pre [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT pre [ i ] [ j ] = now [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return pre NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ans = make_number_of_combination ( ) NEW_LINE for line in stdin : NEW_LINE INDENT n , s = ( int ( s ) for s in line . split ( ) ) NEW_LINE ans [ n ] [ s ] += 1 NEW_LINE DEDENT for line in ans : NEW_LINE INDENT print ( line ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , n // 2 ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT
MAX = 1000001 NEW_LINE primeUpto = [ 0 ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * MAX NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - primeUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT ans = N - ans + 1 if ans else 0 NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT
def countOperations ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( ( i * i ) < n and ( n % i ) > 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( ( i * i ) > n ) : NEW_LINE INDENT i = n ; NEW_LINE DEDENT return ( 1 + ( n - i ) // 2 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE print ( countOperations ( n ) ) ; NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . find ( " A " ) NEW_LINE b = s . rfind ( " C " ) NEW_LINE num = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( i + 1 < a ) : NEW_LINE INDENT num += ( b [ i + 1 ] - b [ i ] + 1 ) NEW_LINE DEDENT DEDENT for i in range ( m - 1 ) : NEW_LINE INDENT num , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a - b ) NEW_LINE DEDENT
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT data = list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE print ( f " { data [ 0 ] } ▁ { data [ 1 ] } " ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MOD = 10000000000000000 NEW_LINE numsubsets = [ 0 ] * ( LIMIT * LIMIT // 2 ) NEW_LINE subsets [ 0 ] = 1 NEW_LINE maxsum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if not eulerlib . is_primality ( LIMIT * LIMIT // 2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxsum += i NEW_LINE for j in range ( maxsum , i + 1 , - 1 ) : NEW_LINE INDENT subsets [ j ] += numsubsets [ j - i ] NEW_LINE if temp < MOD : NEW_LINE INDENT numsubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numsubsets [ j ] = temp - MOD NEW_LINE DEDENT DEDENT DEDENT ans = sum ( subsets ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT isprime = eulerlib . list_primality ( LIMIT * LIMIT // 2 ) NEW_LINE numsubsets = [ 0 ] * ( LIMIT * LIMIT // 2 ) NEW_LINE numsubsets [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( numsubsets ) ) : NEW_LINE INDENT if isprime [ i ] : NEW_LINE INDENT ans = ( ans + numsubsets [ i ] ) % MOD NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( row_num ) : NEW_LINE INDENT count += row_num & 1 ; NEW_LINE row_num >>= 1 ; NEW_LINE DEDENT return ( 1 << count ) ; NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( n ) : NEW_LINE INDENT print ( countOddNumber ( row_num ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 16 ; NEW_LINE gouldSequence ( n ) ; NEW_LINE
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 93 NEW_LINE print ( " Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ for ▁ " , n , " ▁ : ▁ " , end = " " ) NEW_LINE findMin ( n ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT for i in itertools . count ( 1 ) : NEW_LINE INDENT if i > 10 ** 9 or len ( str ( i ) ) < 6 : NEW_LINE INDENT raise ArithmeticException ( " Overflow " ) NEW_LINE DEDENT if multiples_have_same_digits ( i ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT def multiples_have_same_digits ( x ) : NEW_LINE INDENT return all ( [ str ( i ) for i in itertools . product ( str ( x ) , str ( x * x ) ) ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = 2 ** n - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = 2 ** count - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == sum - arr [ i ] ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 6 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findEle ( arr , n ) ) NEW_LINE DEDENT
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( 0 , len ( strB ) ) : NEW_LINE INDENT m1 [ ord ( strB [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( strA ) ) : NEW_LINE INDENT m1 [ ord ( strA [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( 0 , len ( m1 ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return chr ( i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT strA = " abcd " NEW_LINE strB = " cbdad " NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE DEDENT
import sys NEW_LINE from itertools import product NEW_LINE sum = [ 0 ] * 101 NEW_LINE for i , j , k , l in product ( range ( 101 ) , repeat = len ( list ( range ( 1 , 101 ) ) ) : NEW_LINE INDENT sum [ i ] += sum [ j - i - 1 ] NEW_LINE DEDENT for i in range ( len ( list ( product ( range ( 1 , 101 ) ) ) , range ( 1 , 101 ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( sum [ i ] ) NEW_LINE DEDENT
import sys NEW_LINE from operator import itemgetter NEW_LINE inf = 1 << 30 NEW_LINE def solve ( ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT N = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return NEW_LINE DEDENT amari = 0 NEW_LINE spruce = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT name , lname = sys . stdin . readline ( ) . rstrip ( ) . split ( ) NEW_LINE amari += 1 NEW_LINE spruce += [ name ] NEW_LINE DEDENT spruce . append ( spruce [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( N ) : NEW_LINE INDENT if spruce [ i ] [ j ] != amari : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from collections import defaultdict NEW_LINE d = defaultdict ( lambda : 0 ) NEW_LINE for elem in a : NEW_LINE INDENT d [ elem ] += 1 NEW_LINE DEDENT flag = True NEW_LINE for key in d : NEW_LINE INDENT if d [ key ] > 1 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
INT_MIN = - 2147483648 NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = INT_MIN NEW_LINE max2 = INT_MIN NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE
import sys NEW_LINE def operations ( op , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE nVal = 0 ; NEW_LINE min = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] ; NEW_LINE min = min ( min , nVal ) ; NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return ( i + 1 ) ; NEW_LINE DEDENT DEDENT if ( nVal >= 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT times = ( k - abs ( min ) ) // abs ( nVal ) ; NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) ; NEW_LINE count = ( times * n ) ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] ; NEW_LINE count += 1 ; NEW_LINE if ( k <= 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT op = [ - 60 , 65 , - 1 , 14 , - 25 ] ; NEW_LINE n = len ( op ) ; NEW_LINE k = 100000 ; NEW_LINE print ( operations ( op , n , k ) ) ; NEW_LINE DEDENT
from math import ceil , sqrt NEW_LINE pref = [ 0 ] * 100010 NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( sqrt ( x ) ) NEW_LINE if ( cr * cr * cr == x ) : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT compute ( ) NEW_LINE Q = 4 NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , r , l = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT d [ i ] [ 0 ] , d [ i ] [ 1 ] , d [ i ] [ 2 ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 0 ] = d [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT d [ i ] [ 0 ] = a [ i - 1 ] [ 0 ] + d [ i - 1 ] [ 1 ] NEW_LINE if d [ i - 1 ] [ 0 ] == 0 : NEW_LINE INDENT a [ i ] [ 1 ] = a [ i - 1 ] [ 1 ] + d [ i - 1 ] [ 2 ] NEW_LINE DEDENT DEDENT v = a [ 1 ] [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] [ 1 ] == v and d [ i ] [ 2 ] < a [ i - 1 ] [ 1 ] : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE print ( str ( n ) , " th ▁ Centered ▁ cube ▁ number : ▁ " , centered_cube ( n ) ) ; NEW_LINE n = 10 ; NEW_LINE print ( str ( n ) + " th ▁ Centered ▁ cube ▁ number : ▁ " , centered_cube ( n ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n and s [ i ] == '1' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < n and s [ i ] == '0' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( s [ : i ] ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " True " ) if isPower ( 10 , 1 ) else print ( " False " ) NEW_LINE print ( " True " ) if isPower ( 1 , 20 ) else print ( " False " ) NEW_LINE print ( " True " ) if isPower ( 2 , 128 ) else print ( " False " ) NEW_LINE print ( " True " ) if isPower ( 2 , 30 ) else print ( " False " ) NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( isPower ( 10 , 1 ) ) NEW_LINE print ( isPower ( 1 , 20 ) ) NEW_LINE print ( isPower ( 2 , 128 ) ) NEW_LINE print ( isPower ( 2 , 30 ) ) NEW_LINE DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( minimumValue ( arr , n , k ) ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import collections NEW_LINE import bisect NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10000001 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n = ni ( ) NEW_LINE data = [ input ( ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , t , d = data [ i ] NEW_LINE if s == ' lock ' : NEW_LINE INDENT data [ s ] = True NEW_LINE DEDENT else : NEW_LINE INDENT data [ s ] = False NEW_LINE DEDENT DEDENT seen = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if data [ i ] [ 0 ] == ' s ' : NEW_LINE INDENT seen [ data [ i ] [ 1 ] ] = True NEW_LINE DEDENT else : NEW_LINE INDENT seen [ data [ i ] [ 1 ] ] = False NEW_LINE DEDENT DEDENT arr = [ set ( ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur = data [ i ] [ 2 ] NEW_LINE if s == ' find ' : NEW_LINE INDENT while len ( seen ) > 0 : NEW_LINE INDENT a = seen . pop ( ) NEW_LINE if a [ 1 ] not in seen : NEW_LINE INDENT arr [ a [ 1 ] ] . add ( data [ 0 ] ) NEW_LINE DEDENT seen [ a [ 1 ] ] = True NEW_LINE for t in seen : NEW_LINE INDENT x = seen . index ( t ) NEW_LINE if not seen [ x ] : NEW_LINE INDENT arr [ x ] = True NEW_LINE seen [ x ] = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if len ( arr ) != 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) // 2 ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE print ( countWays ( N ) ) ; NEW_LINE DEDENT
from math import gcd , sqrt NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( arr [ i ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = findLCM ( arr , n ) NEW_LINE count = ( r // lcm ) - ( ( l - 1 ) // lcm ) NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countNumbers ( arr , n , l , r ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a , reverse = True ) NEW_LINE print ( a [ 0 ] + a [ 1 ] + a [ 2 ] ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE print ( " YES " if a [ 2 * n - 1 ] * a [ n - 2 ] == a [ 0 ] * a [ 1 ] or a [ 2 * n - 1 ] * a [ n - 2 ] == a [ n - 1 ] * a [ 0 ] else " NO " ) NEW_LINE DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT mp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in mp : NEW_LINE INDENT x = i ; NEW_LINE frequency = mp [ i ] ; NEW_LINE if ( x <= frequency ) : NEW_LINE INDENT ans += ( frequency - x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinDeletion ( a , n ) ) ; NEW_LINE DEDENT
inp = 1234 NEW_LINE n = int ( inp ) NEW_LINE d = 3 NEW_LINE print ( " num _ after _ deleted _ from _ starting ▁ " , inp . strip ( ) ) NEW_LINE print ( " num _ after _ deleted _ from _ ending ▁ " , inp . strip ( ) ) NEW_LINE
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 ; NEW_LINE while ( x >= 1 ) : NEW_LINE INDENT no = x ; NEW_LINE prev_dig = 11 ; NEW_LINE flag = True ; NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT prev_dig = no % 10 ; NEW_LINE no = int ( no / 10 ) ; NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break ; NEW_LINE DEDENT x -= 1 ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT n = 200 ; NEW_LINE print ( nondecdigits ( n ) ) ; NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 == x2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif y1 == y2 : NEW_LINE INDENT print ( x1 , x2 , y1 ) NEW_LINE DEDENT elif x1 + y1 == x2 : NEW_LINE INDENT print ( x1 , x2 , y1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if x1 + y1 == x2 : NEW_LINE INDENT print ( x1 , y1 , x2 ) NEW_LINE DEDENT elif x1 - x2 == y1 - y2 : NEW_LINE INDENT print ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y = a [ 0 ] , a [ 1 ] NEW_LINE if y <= 0 : NEW_LINE INDENT print ( " Ciel " ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT if y % 2 == 0 : NEW_LINE INDENT print ( " Ciel " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Hanako " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT print ( " Ciel " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Hanako " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE w . append ( s ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT b . append ( " W " ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( " B " ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( " " . join ( w [ i ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i > 0 and a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT print ( max ( a ) ) NEW_LINE
def countDistictSubarray ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( 0 , n ) : NEW_LINE INDENT while ( right < n and window < k ) : NEW_LINE INDENT vis [ arr [ right ] ] = vis [ arr [ right ] ] + 1 NEW_LINE if ( vis [ arr [ right ] ] == 1 ) : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if ( window == k ) : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vis [ arr [ left ] ] = vis [ arr [ left ] ] - 1 NEW_LINE if ( vis [ arr [ left ] ] == 0 ) : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 1 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistictSubarray ( arr , n ) ) NEW_LINE DEDENT
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE max_joy : int = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f , t = map ( int , input ( ) . split ( ) ) NEW_LINE joy . append ( f + t ) NEW_LINE max_joy . append ( max_joy ) NEW_LINE DEDENT print ( max_joy ) NEW_LINE
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT tot_bit = 0 NEW_LINE count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bin ( i ) . count ( '1' ) NEW_LINE if ( isPrime ( tot_bit ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 6 NEW_LINE r = 10 NEW_LINE print ( primeBitsInRange ( l , r ) ) NEW_LINE
def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( bin ( arr [ i ] ) ) . count ( '1' ) NEW_LINE if sum == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE def reverseQueueFirstKElements ( k ) : NEW_LINE INDENT if ( len ( queue ) == 1 or k > len ( queue ) ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT stack = deque ( ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT stack . append ( queue . pop ( 0 ) ) NEW_LINE DEDENT while ( len ( stack ) != 0 ) : NEW_LINE INDENT stack . append ( stack . pop ( 0 ) ) NEW_LINE DEDENT for i in range ( 0 , len ( queue ) - k ) : NEW_LINE INDENT queue . append ( queue . pop ( 0 ) ) NEW_LINE DEDENT DEDENT def Print ( ) : NEW_LINE INDENT while ( len ( queue ) != 0 ) : NEW_LINE INDENT print ( queue . pop ( 0 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queue = deque ( ) NEW_LINE k = 5 NEW_LINE reverseQueueFirstKElements ( k ) NEW_LINE Print ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if s % 2 == 0 : NEW_LINE INDENT print ( " maomao90" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " errorgorn " ) NEW_LINE DEDENT DEDENT
def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT k = 31 NEW_LINE print ( xorCalc ( k ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid * mid == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( mid * mid < num ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 16 NEW_LINE out = sObj . isPerfectSquare ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( " Yes " if ( a + b == c ) & 1 == ( a + b == c ) else " No " ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = sum ( l ) / n NEW_LINE print ( x ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == x : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT DEDENT
from collections import namedtuple NEW_LINE Data = namedtuple ( " Data " , " name ▁ cost " ) NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE data = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT p , x = input ( ) . split ( ) NEW_LINE data . append ( Data ( p , int ( x ) ) ) NEW_LINE DEDENT result = [ ] NEW_LINE for _ in data : NEW_LINE INDENT cost = 0 NEW_LINE for i , j in data : NEW_LINE INDENT cost += j NEW_LINE if cost <= m : NEW_LINE INDENT result . append ( Data ( i , cost ) ) NEW_LINE DEDENT DEDENT DEDENT print ( " \n " . join ( result ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE rotations = 2 NEW_LINE ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] NEW_LINE index = 1 NEW_LINE print ( findElement ( arr , ranges , rotations , index ) ) NEW_LINE DEDENT
MAXN = 1000001 NEW_LINE MAXN = MAXN NEW_LINE spf = [ 0 ] * MAXN ; NEW_LINE hash1 = [ 0 ] * MAXN ; NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i < MAXN ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i ; NEW_LINE DEDENT DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT temp = spf [ x ] ; NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 ; NEW_LINE x = x // spf [ x ] ; NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp ; NEW_LINE DEDENT DEDENT def check ( x ) : NEW_LINE INDENT temp = spf [ x ] ; NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def isExists ( a , n ) : NEW_LINE INDENT freq = { } NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in freq . keys ( ) : NEW_LINE INDENT freq [ a [ i ] ] = 0 NEW_LINE DEDENT freq [ a [ i ] ] += 1 NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if Sum % 2 == 0 : NEW_LINE INDENT if freq [ Sum // 2 ] != 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isExists ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( " Area ▁ of ▁ Kite ▁ = " , areaOfKite ( d1 , d2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( " + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) NEW_LINE DEDENT else : NEW_LINE INDENT table = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT if ( i % 2 ) == 0 : NEW_LINE INDENT table . append ( ' O . ' ) NEW_LINE DEDENT elif ( i % 3 ) == 0 : NEW_LINE INDENT table . append ( ' . . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT table . append ( ' | ' ) NEW_LINE DEDENT DEDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 1 , 11 ) : NEW_LINE INDENT if table [ i ] [ j ] == 1 : NEW_LINE INDENT table [ i ] [ j ] = ' | ' NEW_LINE DEDENT if table [ i ] [ j ] == 2 : NEW_LINE INDENT table [ i ] [ j ] = ' D | ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( table ) ) : NEW_LINE INDENT for j in range ( 1 , 11 ) : NEW_LINE INDENT if table [ i ] [ j ] == 1 : NEW_LINE INDENT table [ i ] [ j ] = ' | ' NEW_LINE DEDENT DEDENT DEDENT print ( " " . join ( table [ i ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n & ( n - 1 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def productEqual ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 NEW_LINE prodEven = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE prodOdd *= digit NEW_LINE n //= 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT digit = n % 10 NEW_LINE prodEven *= digit NEW_LINE n //= 10 NEW_LINE DEDENT if ( prodEven == prodOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4324 NEW_LINE if ( productEqual ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE d = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE if t in d : NEW_LINE INDENT d [ t ] = ' - ' NEW_LINE DEDENT else : NEW_LINE INDENT d [ t ] = str ( 90 ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( d . keys ( ) ) ) NEW_LINE DEDENT
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkEVENodd ( arr , n , 1 , 3 ) ; NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import string NEW_LINE import collections NEW_LINE import fractions NEW_LINE import random NEW_LINE from operator import itemgetter NEW_LINE import itertools NEW_LINE from collections import deque NEW_LINE import copy NEW_LINE import heapq NEW_LINE import bisect NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE INF = float ( ' inf ' ) NEW_LINE input = lambda : sys . stdin . readline ( ) . strip ( ) NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE W , H , x , y , r = map ( int , input ( ) . split ( ) ) NEW_LINE x -= r NEW_LINE y -= r NEW_LINE if x >= 0 and y >= 0 and r <= W : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime ( num ) ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( isPrime ( sum ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = ( max_val + 1 ) * [ True ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == False ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( compositeProduct ( arr , n ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if m [ 0 ] == 0 and m [ 1 ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT m . sort ( reverse = True ) NEW_LINE print ( " % d ▁ % d " % ( m [ 0 ] , m [ 1 ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " k " : NEW_LINE INDENT print ( " KOREAN " ) NEW_LINE DEDENT elif s [ 0 ] == " j " : NEW_LINE INDENT print ( " JAPANESE " ) NEW_LINE DEDENT elif s [ 0 ] == " m " : NEW_LINE INDENT print ( " JAPANO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " FILIPINO " ) NEW_LINE DEDENT DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ] NEW_LINE queries = 3 NEW_LINE q = [ [ 2 , 4 ] , [ 2 , 6 ] , [ 5 , 6 ] ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT
from math import ceil , floor NEW_LINE def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) // c NEW_LINE if floor ( z ) == ceil ( z ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + z ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE DEDENT
list_w = [ ] NEW_LINE for x in range ( 10 ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE list_w . append ( x ) NEW_LINE DEDENT list_k = [ ] NEW_LINE for y in range ( 10 ) : NEW_LINE INDENT y = int ( input ( ) ) NEW_LINE list_k . append ( y ) NEW_LINE DEDENT list_w . sort ( ) NEW_LINE list_k . sort ( ) NEW_LINE a = list_w [ 9 ] + list_w [ 8 ] + list_w [ 7 ] NEW_LINE b = list_k [ 9 ] + list_k [ 8 ] + list_k [ 7 ] NEW_LINE print ( a ) NEW_LINE print ( b ) NEW_LINE print ( c ) NEW_LINE
def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT def numberOfPossiblePallindrome ( str , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT k = 0 NEW_LINE num = 0 NEW_LINE den = 1 NEW_LINE fi = 1 NEW_LINE for it in mp : NEW_LINE INDENT if mp [ it ] % 2 == 0 : NEW_LINE INDENT fi = int ( mp [ it ] / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT fi = int ( mp [ it ] - 1 ) // 2 NEW_LINE k += 1 NEW_LINE DEDENT num = num + fi NEW_LINE den = den * fact ( fi ) NEW_LINE DEDENT if num != 0 : NEW_LINE INDENT num = fact ( num ) NEW_LINE DEDENT ans = num // den NEW_LINE if k != 0 : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ababab " NEW_LINE n = len ( str ) NEW_LINE print ( numberOfPossiblePallindrome ( str , n ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE ini = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE inl = lambda : list ( inm ( ) ) NEW_LINE ins = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE debug = lambda * a , ** kw : print ( " \ 033[33m " , * a , " \ 033[0m " , ** dict ( file = sys . stderr , ** kw ) ) NEW_LINE N = ini ( ) NEW_LINE A = inl ( ) NEW_LINE def solve ( ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT s = A [ i + 1 ] - A [ i ] NEW_LINE if s > 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if s < 0 : NEW_LINE INDENT return c NEW_LINE DEDENT if s > 0 : NEW_LINE INDENT return c NEW_LINE DEDENT return solve ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMBits ( n , m ) NEW_LINE print ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE first_1 = s . count ( " A " ) NEW_LINE second_1 = s . count ( " B " ) NEW_LINE if first_1 > second_1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif second_1 < first_1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def first_subString ( s ) : NEW_LINE INDENT n , c = len ( s ) , 0 NEW_LINE s1 , s2 = s , " " NEW_LINE mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' or s [ i ] == ' # ' ) : NEW_LINE INDENT s1 = s [ c : i ] NEW_LINE mpp [ s1 ] = 1 NEW_LINE c = i + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' ) : NEW_LINE INDENT break NEW_LINE DEDENT s1 = s [ i : j - i + 1 ] NEW_LINE s2 = s1 NEW_LINE s1 = s1 [ : : - 1 ] NEW_LINE if ( mpp . get ( s1 ) ) : NEW_LINE INDENT return s2 NEW_LINE DEDENT DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " mango ▁ is ▁ sweet ▁ when ▁ nam ▁ en ▁ tastes ▁ it # " NEW_LINE s1 = first_subString ( s ) NEW_LINE print ( s1 ) NEW_LINE DEDENT
def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = - 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 44522255 NEW_LINE print ( countConsecutive ( n ) ) NEW_LINE DEDENT
def findAngle ( n ) : NEW_LINE INDENT exteriorAngle = ( n - 2 ) * 180 // n NEW_LINE exteriorAngle = 360 // n NEW_LINE print ( " Interior ▁ angle : " , interiorAngle ) NEW_LINE print ( " Exterior ▁ angle : " , exteriorAngle ) NEW_LINE DEDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE
from math import sqrt , ceil , pow NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT print ( pow ( ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) , end = " ▁ " ) NEW_LINE print ( pow ( ceil ( sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " ( " : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cnt > n - cnt : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT cnt = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if cnt > n - cnt : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == " a " : NEW_LINE INDENT ans += " b " NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT if i == n - 1 : NEW_LINE INDENT ans += " a " NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE print ( s [ : i ] ) NEW_LINE
import math NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT if ( sum > k ) : NEW_LINE INDENT discard_count += pow ( 2 , n - i ) NEW_LINE return NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if ( sum + a [ i ] + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if ( sum + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT def countSubsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = math . log ( K ) NEW_LINE prefix = [ 0 for i in range ( n ) ] NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = math . log ( arr [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT total = power ( 2 , n ) - 1 NEW_LINE if ( sum <= k ) : NEW_LINE INDENT return total NEW_LINE DEDENT solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return ( total - discard_count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( countSubsequences ( arr , n , k ) ) NEW_LINE DEDENT
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " ▁ " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT def isIdentical ( root1 , root2 ) : NEW_LINE INDENT if root1 == None and root2 == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root1 != None and root2 == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root1 == None and root2 != None : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( root1 . data == root2 . data and isIdentical ( root1 . left , root2 . left ) == 1 and isIdentical ( root1 . right , root2 . right ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = newNode ( 5 ) NEW_LINE root2 = newNode ( 5 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 8 ) NEW_LINE root1 . left . left = newNode ( 2 ) NEW_LINE root1 . left . right = newNode ( 4 ) NEW_LINE root2 . left = newNode ( 3 ) NEW_LINE root2 . right = newNode ( 8 ) NEW_LINE root2 . left . left = newNode ( 2 ) NEW_LINE root2 . left . right = newNode ( 4 ) NEW_LINE if ( isIdentical ( root1 , root2 ) == 1 ) : NEW_LINE INDENT print ( " Both ▁ BSTs ▁ are ▁ identical " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " BSTs ▁ are ▁ not ▁ identical " ) NEW_LINE DEDENT DEDENT
import re NEW_LINE input ( ) NEW_LINE print ( re . sub ( r ' OX | XO ' , ' @ ' , input ( ) ) . count ( ' JOI ' ) ) NEW_LINE
import sys NEW_LINE def solve ( S : str , T : str ) : NEW_LINE INDENT answer = [ 0 ] * 6 NEW_LINE d = { " W " : " E " , " S " : " W " , " E " : " S " , " W " : " E " } NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT d [ S [ i ] ] = answer [ i - 1 ] + d [ S [ i ] ] NEW_LINE DEDENT return answer [ : : - 1 ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE S = next ( tokens ) NEW_LINE T = next ( tokens ) NEW_LINE solve ( S , T ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def add ( data ) : NEW_LINE INDENT newnode = Node ( data ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def printArr ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def findlength ( head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while ( curr != None ) : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT def convertArr ( head ) : NEW_LINE INDENT length = findlength ( head ) NEW_LINE arr = [ 0 ] * length NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT arr [ index ] = curr . data NEW_LINE index += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT printArr ( arr , length ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = Node ( ) NEW_LINE head . next = add ( 1 ) NEW_LINE head . next . next = add ( 2 ) NEW_LINE head . next . next = add ( 3 ) NEW_LINE head . next . next . next = add ( 4 ) NEW_LINE head . next . next . next . next = add ( 5 ) NEW_LINE convertArr ( head ) NEW_LINE DEDENT
def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = ( a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT n = 2 NEW_LINE print ( " Non - decreasing ▁ digits ▁ = ▁ " , nonDecNums ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i + a [ i ] % n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT min_num = min ( nums ) NEW_LINE ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT ans += num - min_num NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a * b < 0 : NEW_LINE INDENT print ( " Zero " ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( " Zero " ) NEW_LINE DEDENT elif a > 0 and b > 0 : NEW_LINE INDENT if ( a - b ) % 2 == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Negative " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT n = 12 NEW_LINE print ( firstSetBit ( n ) ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " abba " NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( ( a , b ) ) NEW_LINE DEDENT l . sort ( key = lambda l : l [ 0 ] , reverse = True ) NEW_LINE now = 0 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT x = l [ _ ] [ 0 ] NEW_LINE if x <= k : NEW_LINE INDENT now += x [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( now ) NEW_LINE
from math import sqrt NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = 5 * sqrt ( 3 ) * a * a NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * a * a * a NEW_LINE return volume NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area : " , findArea ( a ) , " Volume : " , findVolume ( a ) , sep = " ▁ " ) NEW_LINE
def compute ( ) : NEW_LINE INDENT nine_pyramidalPdf = [ 1 , 1 , 1 , 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE nine_pyramidalPdf = [ 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT nine_pyramidalPdf = convolve ( nine_pyramidalPdf , PYRAMIDAL_DIE_PDF ) NEW_LINE DEDENT six_cubicPdf = [ 1 ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT sixCubicPdf = convolve ( sixCubicPdf , CUBIC_DIE_PDF ) NEW_LINE DEDENT numnum = 0 NEW_LINE for i in range ( len ( nine_pyramidalPdf ) ) : NEW_LINE INDENT numnum += nine_pyramidalPdf [ i ] * sum ( sixCubicPdf , 0 , i ) NEW_LINE DEDENT denom = sum ( nine_pyramidalPdf , 0 , len ( six_cubicPdf ) * sum ( six_cubicPdf , 0 , len ( six_cubicPdf ) ) NEW_LINE return f " { num / denom } " NEW_LINE DEDENT def convolve ( a , b ) : NEW_LINE INDENT c = [ 0 for i in range ( len ( a ) ) ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( b ) ) : NEW_LINE INDENT c [ i + j ] += a [ i ] * b [ j ] NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 ; NEW_LINE Even = N / 2 ; NEW_LINE Odd = N - Even ; NEW_LINE print ( Even * Odd ) ; NEW_LINE DEDENT
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N // s ; NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 ; NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = M // s ; NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 ; NEW_LINE DEDENT return M * N ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 ; M = 13 ; s = 4 ; NEW_LINE print ( solve ( M , N , s ) ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ a [ 0 ] + a [ 1 ] + a [ 2 ] for a in range ( 6 ) ] NEW_LINE c = [ a [ 0 ] + a [ 1 ] + a [ 2 ] for a in range ( 6 ) ] NEW_LINE d = [ a [ 0 ] + a [ 1 ] + a [ 2 ] for a in range ( 6 ) ] NEW_LINE if b [ 0 ] == b [ 1 ] + a [ 2 ] == d [ 0 ] or b [ 1 ] == b [ 2 ] + a [ 3 ] or b [ 2 ] == b [ 3 ] + a [ 4 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def _popcnt32 ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT number = number // 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res | ( 1 << ( 32 - i ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in l : NEW_LINE INDENT if i <= k : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( a - ( b - a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def xorQueries ( self , arr , queries ) : NEW_LINE INDENT res = [ 0 ] * len ( queries ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] ^= arr [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( queries ) ) : NEW_LINE INDENT q = queries [ i ] NEW_LINE if q [ 0 ] : NEW_LINE INDENT res [ i ] = arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = arr [ q [ 1 ] ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE arr = [ 1 , 3 , 4 , 8 ] NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 2 ] , [ 0 , 3 ] , [ 3 , 3 ] ] NEW_LINE out = sObj . xorQueries ( arr , queries ) NEW_LINE print ( out ) NEW_LINE DEDENT
def encodedChar ( string , k ) : NEW_LINE INDENT Expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( string ) and string [ i ] >= ' a ' and string [ i ] <= ' z ' ) : NEW_LINE INDENT temp += string [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( string ) and string [ i ] >= '1' and string [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + int ( string [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT Expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expanded += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ab4c12ed3" NEW_LINE k = 21 NEW_LINE print ( encodedChar ( string , k ) ) NEW_LINE DEDENT
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE c = 2 ; NEW_LINE printPossible ( a , b , c ) ; NEW_LINE
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) / 2 ; NEW_LINE sign = 1 if ( n + 1 % 2 == 0 ) else - 1 ; NEW_LINE result_sum = sign * abs_sum ; NEW_LINE return result_sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2 ; NEW_LINE print ( summation ( N ) ) ; NEW_LINE DEDENT
def sortSquares ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT sortSquares ( arr , n ) NEW_LINE print ( " \n After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pos = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if pos + l [ i ] <= t : NEW_LINE INDENT count += 1 NEW_LINE pos += l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE quit ( ) NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 2147483647 ) NEW_LINE INF = float ( " inf " ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def bisection ( l , r , f , left = True , discrete = True ) : NEW_LINE INDENT eps = 1 if ( discrete ) else 10 ** - 8 NEW_LINE if ( ( not left ) ^ f ( r ) ) : return r if ( left ) else r + 1 NEW_LINE elif ( left ^ f ( l ) ) : return l - 1 if ( left ) else l NEW_LINE while ( r - l > eps ) : NEW_LINE INDENT h = ( l + r ) % len ( l ) NEW_LINE if ( ( not left ) ^ f ( h ) ) : l = h NEW_LINE else : r = h NEW_LINE DEDENT return ( l + r ) / 2 if ( not discrete ) else l if ( left ) else r NEW_LINE DEDENT def resolve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE D = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE D . sort ( ) NEW_LINE t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT T = D [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if D [ j ] > D [ i ] : NEW_LINE INDENT t += 1 NEW_LINE DEDENT DEDENT if t == n : print ( 0 ) ; break NEW_LINE DEDENT if t != 0 : print ( 1 ) NEW_LINE DEDENT resolve ( ) NEW_LINE
from math import sqrt NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b = 1 NEW_LINE a = 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 55 NEW_LINE if ( isTriangular ( num ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT DEDENT
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if ( d == 0 and k != 1 ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 4 NEW_LINE d = 4 NEW_LINE printNumberWithDR ( k , d ) NEW_LINE DEDENT
N = 3 NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE rotateMatrix ( mat ) NEW_LINE
print ( int ( input ( ) ) // 500 * 500 ) NEW_LINE
def getProduct ( n ) : NEW_LINE INDENT product = 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT product = product * ( n % 10 ) ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4513 ; NEW_LINE print ( getProduct ( n ) ) ; NEW_LINE DEDENT
while True : NEW_LINE INDENT a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 and c == 0 and d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( ( 100 * d + f ) - ( 2 * e * b + 3 * f ) ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE from bisect import bisect_right as br NEW_LINE from bisect import bisect_left as bl NEW_LINE sys . setrecursionlimit ( 2147483647 ) NEW_LINE from heapq import heappush , heappop , heappushpop NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from operator import itemgetter NEW_LINE from itertools import permutations NEW_LINE mod = 10 ** 9 + 7 NEW_LINE inf = float ( ' inf ' ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE n = I ( ) NEW_LINE cost = [ 1 ] * ( 2 * 10 ** 6 + 5 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] = cost [ i - 1 ] * i % mod NEW_LINE DEDENT l = [ 0 ] * ( 2 * 10 ** 6 + 5 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l [ i + 1 ] = l [ i ] * i % mod NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ( ans * cost [ i ] ) % mod NEW_LINE DEDENT print ( ans ) NEW_LINE
PI = 3.14159265 ; NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 7 ; NEW_LINE print ( length_rope ( r ) ) ; NEW_LINE DEDENT
def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = ( rev_num * 10 + num % 10 ) NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev_n = reverseDigits ( n ) NEW_LINE if ( rev_n == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4562 NEW_LINE print ( " Is " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , ( isPalindrome ( n ) == 1 ) ) NEW_LINE n = 2002 NEW_LINE print ( " Is " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , ( isPalindrome ( n ) == 1 ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT prev = ' ' NEW_LINE carry = 0 NEW_LINE for i in range ( len ( num1 ) - 1 , len ( num2 ) - 1 , - 1 ) : NEW_LINE INDENT x = int ( num1 [ i ] ) + int ( num2 [ j ] ) NEW_LINE y = int ( num2 [ j ] ) + int ( carry ) NEW_LINE if i < 0 : NEW_LINE INDENT x = abs ( x1 [ i ] ) + 10 NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT y = abs ( y1 [ j ] ) + 10 NEW_LINE DEDENT sb = ( x + y + carry ) % 10 NEW_LINE carry = ( x + y + carry ) // 10 NEW_LINE DEDENT return sb . strip ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num1 = '11' NEW_LINE num2 = '123' NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , 1001 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if sum == n and n != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT print ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) NEW_LINE for n in range ( 2 , 10000 ) : NEW_LINE INDENT if ( isPerfect ( n ) ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ perfect ▁ number " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT p = x NEW_LINE while ( p <= n ) : NEW_LINE INDENT p = p * x NEW_LINE if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( 2 , 100 , 1 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
from math import sqrt NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = pow ( x , y ) NEW_LINE while ( p <= n and p > 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
from math import gcd NEW_LINE def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( gcd == sum - gcd ) == gcd and sum != gcd : NEW_LINE INDENT print ( " a ▁ = " , min ( gcd , sum - gcd ) , " , ▁ b ▁ = " , sum - min ( gcd , sum - gcd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE m = max ( a , b ) NEW_LINE n = m - ( c - d ) NEW_LINE if n < 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT n , a , b , c , d = tuple ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE ans = min ( n * a , b * ( n - a * c ) + min ( n * d , c * d ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = countSetBits ( arr [ i ] ) NEW_LINE if count in m : NEW_LINE INDENT m [ count ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ count ] = 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for it in m : NEW_LINE INDENT value = m [ it ] NEW_LINE result += ( ( value * ( value - 1 ) ) // 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 5 , 3 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( totalPairs ( arr , n ) ) NEW_LINE DEDENT
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return ( 8 * n * n - 8 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT
q , h , s , d , n = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( q * 2 * h + s , ( n // 2 ) * d + n % 2 * h * ( n % 2 ) ) ) NEW_LINE
def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE DEDENT
import sys NEW_LINE import os NEW_LINE import math NEW_LINE x_per_liter = int ( input ( ) ) NEW_LINE y_base_cost = int ( input ( ) ) NEW_LINE y_limit = int ( input ( ) ) NEW_LINE y_addition = int ( input ( ) ) NEW_LINE liter = int ( input ( ) ) NEW_LINE x_cost = x_per_liter * liter NEW_LINE if liter <= y_limit : NEW_LINE INDENT y_cost = y_limit NEW_LINE DEDENT else : NEW_LINE INDENT y_cost = y_limit NEW_LINE DEDENT cost = y_addition * ( liter - y_limit ) + y_cost * ( liter - y_limit ) NEW_LINE print ( cost ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , A ) : NEW_LINE INDENT self . ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 2 ] * n NEW_LINE A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k < n ) : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 4 , 7 , 2 , 10 ] NEW_LINE print ( Solution ( a ) ) NEW_LINE DEDENT
def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 1 NEW_LINE freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i ) * d NEW_LINE if ( a0 in freq ) : NEW_LINE INDENT freq [ a0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT if ( freq [ a0 ] > maxFreq ) : NEW_LINE INDENT maxFreq = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - maxFreq ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE d = 1 NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] NEW_LINE print ( minimumChanges ( arr , n , d ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( [ x , y , z ] ) NEW_LINE DEDENT g = sorted ( a , key = lambda x : x [ 2 ] ) NEW_LINE print ( a . index ( min ( g ) ) + 1 ) NEW_LINE
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( a [ i ] + y < b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 1 , 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE m = len ( a ) NEW_LINE print ( countPoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n , s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] -= min ( a [ i ] , s ) NEW_LINE DEDENT if sum ( a ) < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT l = 0 NEW_LINE r = len ( a ) NEW_LINE while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if solve ( ) : NEW_LINE INDENT print ( mid ) NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT DEDENT if solve ( ) : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ccccdeededff " NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT
K = int ( input ( ) ) NEW_LINE n = K // ( n + 1 ) NEW_LINE ans = [ 0 ] * n NEW_LINE rem = K % ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans [ i ] = ( i + rem ) NEW_LINE DEDENT print ( n ) NEW_LINE print ( * ans ) NEW_LINE
import math NEW_LINE def zeroUpto ( digits ) : NEW_LINE INDENT first = ( math . pow ( 10 , digits ) - 1 ) // 9 NEW_LINE second = ( math . pow ( 9 , digits ) - 1 ) // 8 NEW_LINE return 9 * ( first - second ) NEW_LINE DEDENT def toInt ( c ) : NEW_LINE INDENT return ord ( c ) - 48 NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = zeroUpto ( k - 1 ) NEW_LINE non_zero = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT non_zero -= 1 NEW_LINE break NEW_LINE DEDENT non_zero += ( toInt ( num [ i ] ) - 1 ) * ( math . pow ( 9 , k - 1 - i ) ) NEW_LINE DEDENT no = 0 NEW_LINE remaining = 0 NEW_LINE calculatedUpto = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT no = no * 10 + ( toInt ( num [ i ] ) ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT calculatedUpto = calculatedUpto * 10 + 9 NEW_LINE DEDENT DEDENT remaining = no - calculatedUpto NEW_LINE ans = zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) NEW_LINE return ans NEW_LINE DEDENT num = "107" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1" , " ▁ to " , num , " ▁ is " , countZero ( num ) ) NEW_LINE num = "1264" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1" , " ▁ to " , num , " ▁ is " , countZero ( num ) ) NEW_LINE
import math NEW_LINE def cone ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( a * math . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * math . pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT a = 5 NEW_LINE print ( cone ( a ) ) NEW_LINE
def Prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkSumPrime ( str ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT summ += abs ( ord ( str [ i - 1 ] ) - ord ( str [ i ] ) ) NEW_LINE DEDENT if ( Prime ( summ ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT num = 142 NEW_LINE str = "142" NEW_LINE if ( checkSumPrime ( str ) ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT print ( " % . 3 f " % sum ( 8 ) , " % . 3 f " % sum ( 10 ) , sep = " " ) NEW_LINE
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = [ 2 , 5 , 1 , 3 , 4 ] NEW_LINE n = len ( p ) NEW_LINE print ( countElements ( p , n ) ) NEW_LINE DEDENT
a , b = map ( str , input ( ) . split ( " ▁ " ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( " > " ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( " < " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " = " ) NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE print ( " Volume ▁ of ▁ triangular ▁ prism : ▁ " , findVolume ( l , b , h ) ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE from bisect import bisect_right as br NEW_LINE from bisect import bisect_left as bl NEW_LINE sys . setrecursionlimit ( 2147483647 ) NEW_LINE from heapq import heappush , heappop , heappushpop NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from operator import itemgetter NEW_LINE from itertools import permutations NEW_LINE from itertools import product NEW_LINE mod = 10 ** 9 + 7 NEW_LINE inf = float ( ' inf ' ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE n , k = LI ( ) NEW_LINE s = input ( ) NEW_LINE cc = Counter ( s ) NEW_LINE mn = inf NEW_LINE ans = 0 NEW_LINE for v in cc . values ( ) : NEW_LINE INDENT mn = min ( mn , v ) NEW_LINE ans += min ( mn * v , mn - v ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def compute ( ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = i * ( i + 1 ) // 2 NEW_LINE pentagon = j * ( j * 3 - 1 ) // 2 NEW_LINE hexagon = k * ( k * 2 - 1 ) // 2 NEW_LINE min = min ( triangle , pentagon , hexagon ) NEW_LINE if ( min == triangle and min == pentagon and min == hexagon ) : NEW_LINE INDENT return str ( min ) NEW_LINE DEDENT if ( min == triangle ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( min == pentagon ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( min == hexagon ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ True ] * ( N + 1 ) NEW_LINE prod = 1 NEW_LINE res = 0 NEW_LINE p = 2 NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( arr [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = False NEW_LINE DEDENT prod *= p NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT p += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 500 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT
def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( X ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X // i != i ) : NEW_LINE INDENT b . append ( X // i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " All ▁ Non - empty ▁ Subarrays " ) NEW_LINE subArray ( arr , n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 6 == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif n % 6 == 4 : NEW_LINE INDENT if n % 4 == 0 : NEW_LINE INDENT x = n // 4 NEW_LINE DEDENT else : NEW_LINE INDENT x = n // 4 - 1 NEW_LINE DEDENT y = n // 6 - 2 NEW_LINE if n % 6 == 2 : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT y = 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT print ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( arr [ i ] * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 , 0 , - 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestLeftLeafNode ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( not len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( temp . left . left == None and temp . left . right == None ) : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . right . left = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE root . right . left . right = newNode ( 7 ) NEW_LINE root . right . right . right = newNode ( 8 ) NEW_LINE root . right . left . right . left = newNode ( 9 ) NEW_LINE root . right . right . right . right = newNode ( 10 ) NEW_LINE result = getDeepestLeftLeafNode ( root ) NEW_LINE if ( result != None ) : NEW_LINE INDENT print ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ left ▁ leaf ▁ not ▁ found " ) NEW_LINE DEDENT DEDENT
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestRightLeafNode ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( not len ( q ) ) : NEW_LINE INDENT temp = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . right . left = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE root . right . left . right = newNode ( 7 ) NEW_LINE root . right . right . right = newNode ( 8 ) NEW_LINE root . right . left . right . left = newNode ( 9 ) NEW_LINE root . right . right . right . right = newNode ( 10 ) NEW_LINE result = getDeepestRightLeafNode ( root ) NEW_LINE if ( result != None ) : NEW_LINE INDENT print ( " Deepest ▁ Right ▁ Leaf ▁ : : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE dict = { 0 : 1 , 1 : 1 } NEW_LINE def fib ( n ) : NEW_LINE INDENT if n in dict . keys ( ) : NEW_LINE INDENT return dict [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dict [ n ] = fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE return dict [ n ] NEW_LINE DEDENT DEDENT print ( fib ( n ) ) NEW_LINE
from math import gcd , sqrt NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE c = d NEW_LINE d = c NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT lcm = ( a * c ) // gcd ( a , c ) NEW_LINE x = lcm // a NEW_LINE b *= x NEW_LINE y = lcm // c NEW_LINE d *= y NEW_LINE k = gcd ( b , d ) NEW_LINE b //= k NEW_LINE d //= k NEW_LINE print ( b , " : " , d ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT
def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ : " , maxsum_SIS ( arr , n ) ) NEW_LINE
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT finalGCD = GCD ( arr [ i ] , finalGCD ) NEW_LINE DEDENT return finalGCD NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT maxElement = findMaxSumUtil ( arr , n ) NEW_LINE return ( maxElement * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT a = 20 NEW_LINE b = 52 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE w , h = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( int ( l [ 0 ] ) + 1 , int ( l [ 1 ] ) + 1 ) : NEW_LINE INDENT if l [ j ] < l [ 0 ] or l [ j ] > l [ 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def divisibleby37 ( n1 ) : NEW_LINE INDENT l = len ( n1 ) NEW_LINE if ( n1 == "0" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l % 3 == 1 ) : NEW_LINE INDENT n1 = "00" + n1 NEW_LINE l += 2 NEW_LINE DEDENT elif ( l % 3 == 2 ) : NEW_LINE INDENT n1 = "0" + n1 NEW_LINE l += 1 NEW_LINE DEDENT n = str ( n1 ) NEW_LINE gSum = 0 NEW_LINE while ( l != 0 ) : NEW_LINE INDENT gvalue = 0 NEW_LINE if ( l == 2 ) : NEW_LINE INDENT gvalue = ( ( n [ ( l - 2 ) ] - 48 ) * 100 + ( n [ ( l - 1 ) ] - 48 ) * 10 ) NEW_LINE DEDENT elif ( l == 1 ) : NEW_LINE INDENT gvalue = ( ( n [ ( l - 1 ) ] - 48 ) * 100 + ( n [ ( l - 2 ) ] - 48 ) * 10 + ( n [ ( l - 1 ) ] - 48 ) * 1 ) NEW_LINE DEDENT l = l - 3 NEW_LINE gSum = gSum + gvalue NEW_LINE DEDENT if ( gSum >= 1000 ) : NEW_LINE INDENT return ( divisibleby37 ( gSum ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 0 if ( gSum % 37 == 0 ) else 1 ) NEW_LINE DEDENT DEDENT s = "8955795758" NEW_LINE if ( divisibleby37 ( s ) == 1 ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x > y : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif x == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if y - n <= x : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def findMinCost ( X , Y , costX , costY ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE len_LCS = lcs ( X , Y , m , n ) NEW_LINE return ( costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = " ef " NEW_LINE Y = " gh " NEW_LINE print ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ identical ▁ is ▁ = ▁ " , findMinCost ( X , Y , 10 , 20 ) ) NEW_LINE DEDENT
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE
import math NEW_LINE def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 ; NEW_LINE mean = 0 ; NEW_LINE root = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT square = square + pow ( arr [ i ] , 2 ) ; NEW_LINE DEDENT mean = ( square / n ) ; NEW_LINE root = math . sqrt ( mean ) ; NEW_LINE return root ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 4 , 6 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " % . 4 f " % rmsValue ( arr , n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE f_inf = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def resolve ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE P . sort ( reverse = True ) NEW_LINE dp = [ f_inf ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + P [ i ] , dp [ i - 1 ] + P [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dp [ n ] < ans : NEW_LINE INDENT ans = dp [ n ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT resolve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( " node ▁ { } : ▁ key ▁ = ▁ { } , ▁ " . format ( i , a [ i ] ) , " parent ▁ key ▁ = ▁ { } , ▁ { } " . format ( a [ i - 1 ] , a [ i ] ) ) NEW_LINE DEDENT elif i % 2 == 1 : NEW_LINE INDENT print ( " node ▁ { } : ▁ key ▁ = ▁ { } , ▁ { } " . format ( i , a [ i ] ) , " left ▁ key ▁ = ▁ { } , ▁ { } " . format ( a [ i - 1 ] , a [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " node ▁ { } : ▁ parent ▁ key ▁ = ▁ { } , ▁ { } " . format ( i , a [ i - 1 ] , a [ i ] ) ) NEW_LINE if i % 2 == 1 : NEW_LINE INDENT print ( " right ▁ key ▁ = ▁ { } , ▁ { } " . format ( a [ i + 1 ] , a [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " node ▁ { } : ▁ { } , ▁ { } " . format ( i , a [ i + 1 ] , a [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT
n = 6 NEW_LINE m = 6 NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 ; m2 = 0 ; m3 = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ( j // ( m // 3 ) ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 1 ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE DEDENT print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) , end = " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] NEW_LINE maxSum ( arr ) ; NEW_LINE DEDENT
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( " No ▁ intersection " ) ; NEW_LINE return ; NEW_LINE DEDENT print ( " ( " , x5 , " , " , y5 , " ) ▁ " , end = " ▁ " ) ; NEW_LINE x7 = x5 ; NEW_LINE y7 = y6 ; NEW_LINE print ( " ( " , x7 , " , " , y7 , " ) ▁ " , end = " ▁ " ) ; NEW_LINE x8 = x6 ; NEW_LINE y8 = y5 ; NEW_LINE print ( " ( " , x8 , " ) ▁ " , end = " ▁ " ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 0 ; NEW_LINE x2 = 10 ; NEW_LINE y2 = 8 ; NEW_LINE x3 = 2 ; NEW_LINE y3 = 3 ; NEW_LINE x4 = 7 ; NEW_LINE y4 = 9 ; NEW_LINE FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE d = s . count ( " x " ) NEW_LINE a = s . count ( " x " ) NEW_LINE b = ( d - a ) / 2 NEW_LINE print ( b ) NEW_LINE sys . stdout . write ( " ▁ " . join ( map ( str , a ) ) ) NEW_LINE
n , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n - ( 5 * e + ( n % 5 ) * d ) , n % d ) ) NEW_LINE
import sys NEW_LINE def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - ( sys . maxsize - 1 ) NEW_LINE maxindex = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( val [ i ] // wt [ i ] ) > maxratio : NEW_LINE INDENT maxratio = ( val [ i ] // wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratio ) NEW_LINE DEDENT val = [ 14 , 27 , 44 , 19 ] NEW_LINE wt = [ 6 , 7 , 9 , 8 ] NEW_LINE n = len ( val ) NEW_LINE W = 50 NEW_LINE print ( knapSack ( W , wt , val , n ) ) NEW_LINE
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE v1 = [ ] ; NEW_LINE v2 = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT index = 0 ; NEW_LINE i = 0 ; j = 0 ; NEW_LINE flag = False ; NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] ; NEW_LINE i += 1 ; NEW_LINE index += 1 ; NEW_LINE flag = ! flag ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = v2 [ j ] ; NEW_LINE j += 1 ; NEW_LINE index += 1 ; NEW_LINE flag = ! flag ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 9 , 8 , 13 , 2 , 19 , 14 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE  AlternateRearrange ( arr , n ) ; NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= c and b <= c : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = n // 2 NEW_LINE i += 1 NEW_LINE DEDENT binary = " " NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += binaryNum [ j ] NEW_LINE DEDENT return binary NEW_LINE DEDENT def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == M - 1 ) : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findOccurrence ( arr , n , pattern ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT binary = decToBinary ( arr [ i ] ) NEW_LINE print ( countFreq ( pattern , binary ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 106 , 7 , 8 ] NEW_LINE pattern = "10" NEW_LINE n = len ( arr ) NEW_LINE findOccurrence ( arr , n , pattern ) NEW_LINE DEDENT
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def findKthLargest ( self , nums , k ) : NEW_LINE INDENT nums = sorted ( nums ) NEW_LINE k = len ( nums ) - k NEW_LINE lo = 0 NEW_LINE hi = len ( nums ) - 1 NEW_LINE while ( lo < hi ) : NEW_LINE INDENT j = partition ( nums , lo , hi ) NEW_LINE if ( j < k ) : NEW_LINE INDENT lo = j + 1 NEW_LINE DEDENT elif ( j > k ) : NEW_LINE INDENT hi = j - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return nums [ k ] NEW_LINE DEDENT def partition ( self , a , lo , hi ) : NEW_LINE INDENT i = lo NEW_LINE j = hi + 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( i < hi and less ( a [ i ] , a [ lo ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( j > lo and less ( a [ lo ] , a [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT break NEW_LINE DEDENT exch ( self , i , j ) NEW_LINE DEDENT self . exch ( self . lo , j ) NEW_LINE return self . exch ( self . lo , j ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE out = sObj . findKthLargest ( nums , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9876543 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE sum += k NEW_LINE n //= 10 NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 123 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE DEDENT
a = input ( ) NEW_LINE b = input ( ) NEW_LINE if a < b : NEW_LINE INDENT print ( " GREATER " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " LESS " ) NEW_LINE DEDENT else : NEW_LINE INDENT n = len ( a ) NEW_LINE res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t1 = ord ( a [ i ] ) - ord ( ' a ' ) NEW_LINE t2 = ord ( b [ i ] ) - ord ( ' a ' ) NEW_LINE if t1 < t2 : NEW_LINE INDENT res . append ( " greater " ) NEW_LINE DEDENT elif t1 > t2 : NEW_LINE INDENT res . append ( " less " ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( " equals " ) NEW_LINE DEDENT DEDENT if res [ 0 ] == "0" : NEW_LINE INDENT print ( " EQUAL " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LESS " ) NEW_LINE DEDENT
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = totalSquares * size * size NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 4 NEW_LINE b = 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE DEDENT
def arrange ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT if ( N == 2 or N == 3 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT even = - 1 NEW_LINE odd = - 1 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT even = N NEW_LINE odd = N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = N NEW_LINE even = N - 1 NEW_LINE DEDENT while ( odd >= 1 ) : NEW_LINE INDENT print ( odd , end = " ▁ " ) NEW_LINE odd = odd - 2 NEW_LINE DEDENT while ( even >= 2 ) : NEW_LINE INDENT print ( even , end = " ▁ " ) NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE arrange ( N ) NEW_LINE DEDENT
import sys NEW_LINE def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT sum1 = 0 ; sum2 = 0 ; NEW_LINE min = sys . maxsize ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] ; NEW_LINE sum2 = sum - sum1 ; NEW_LINE if ( abs ( sum1 - sum2 ) < min ) : NEW_LINE INDENT min = abs ( sum1 - sum2 ) ; NEW_LINE DEDENT if ( min == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return min ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 5 , 7 , 8 ] ; NEW_LINE N = len ( a ) ; NEW_LINE print ( findMinEqualSums ( a , N ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( "1" * ( n // 3 ) ) NEW_LINE DEDENT elif n % 3 == 1 : NEW_LINE INDENT print ( "12" * ( n // 3 ) + "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "22" * ( n // 3 ) + "2" ) NEW_LINE DEDENT DEDENT
def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findOptimalSolution ( a , N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE d = [ ] NEW_LINE x = [ 0 ] * ( n + 1 ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT d . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE x [ d . index ( max ( x ) ) ] += 1 NEW_LINE DEDENT a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = x [ i - 1 ] + d [ i ] [ 0 ] NEW_LINE DEDENT print ( * a [ 1 : ] ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] , reverse = True ) NEW_LINE k = sum ( a [ : : - 1 ] ) NEW_LINE if k <= m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def getPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( getPairs ( a , n ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE i = 0 NEW_LINE while i < n and k > 0 : NEW_LINE INDENT if i == 0 and s [ i ] == "0" : NEW_LINE INDENT s [ i ] = "1" NEW_LINE k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = "0" NEW_LINE k -= 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( " " . join ( s ) ) NEW_LINE
def check_bng ( t ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if t [ i ] == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if t [ 0 ] [ i ] == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if t [ 1 ] [ i ] == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if t [ 2 ] [ i ] == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if t [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT if t [ 1 ] [ 1 ] == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if t [ 2 ] [ 2 ] == 1 : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if t [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT if t [ 1 ] [ 0 ] == 1 : NEW_LINE INDENT d = 1 NEW_LINE DEDENT if t [ 2 ] [ 1 ] == 1 : NEW_LINE INDENT d = 1 NEW_LINE DEDENT if t [ 0 ] [ 2 ] == 1 : NEW_LINE INDENT d = 0 NEW_LINE DEDENT if t [ 1 ] [ 0 ] == 1 : NEW_LINE INDENT d = 1 NEW_LINE DEDENT if t [ 2 ] [ 1 ] == 1 : NEW_LINE INDENT d = 1 NEW_LINE DEDENT if t [ 0 ] [ 2 ] == 1 : NEW_LINE INDENT d = 0 NEW_LINE DEDENT if t [ 1 ] [ 1 ] == 1 : NEW_LINE INDENT d = 1 NEW_LINE DEDENT if t [ 2 ] [ 0 ] == 1 : NEW_LINE INDENT d = 1 NEW_LINE DEDENT if d == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT n = 0 NEW_LINE while n < 4 : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = n + 1 NEW_LINE DEDENT return n NEW_LINE DEDENT if check_bng ( t ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
N = 10000 NEW_LINE MOD = 1000000007 NEW_LINE F = [ 0 ] * N ; NEW_LINE def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 ; NEW_LINE F [ 2 ] = 3 ; NEW_LINE F [ 3 ] = 4 ; NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 ; NEW_LINE precompute ( ) ; NEW_LINE print ( F [ n ] ) ; NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT * S , = range ( N ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT S . sort ( ) NEW_LINE v0 = S [ 0 ] NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT S . append ( v0 ) NEW_LINE S . pop ( 0 ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if S [ i ] == v0 : NEW_LINE INDENT dfs ( i ) NEW_LINE DEDENT DEDENT DEDENT write ( " % d \n " % S . count ( "1" ) ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
import math NEW_LINE def CeilIndex ( A , l , r , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( A [ m ] >= key ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def LongestIncreasingSubsequenceLength ( A , size ) : NEW_LINE INDENT tailTable = [ 0 for i in range ( size ) ] NEW_LINE len1 = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT if ( A [ i ] < tailTable [ 0 ] ) : NEW_LINE INDENT tailTable [ 0 ] = A [ i ] NEW_LINE DEDENT elif ( A [ i ] > tailTable [ len1 - 1 ] ) : NEW_LINE INDENT tailTable [ len1 ] = A [ i ] NEW_LINE len1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tailTable [ CeilIndex ( tailTable , - 1 , len1 , A [ i ] ) ] = A [ i ] NEW_LINE DEDENT DEDENT return len1 NEW_LINE DEDENT A = [ 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Increasing ▁ Subsequence ▁ is " , LongestIncreasingSubsequenceLength ( A , n ) ) NEW_LINE
import sys NEW_LINE def solve ( N : int , v : " List [ int ] " ) : NEW_LINE INDENT v . sort ( ) NEW_LINE ans = ( v [ N - 1 ] - v [ 0 ] + 1 ) // 2 NEW_LINE print ( ans ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE v = [ int ( next ( tokens ) ) for _ in range ( N ) ] NEW_LINE solve ( N , v ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( 1 for i in range ( LIMIT ) if getChain_length ( i ) == 60 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def getChain_length ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT if n not in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT n = math . factorialize ( n ) NEW_LINE DEDENT DEDENT FACTORIAL = [ 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ] NEW_LINE FACTORIAL = [ 0 , 0 , 0 , 40320 , 362880 ] NEW_LINE def factorialize ( n ) : NEW_LINE INDENT _sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT _sum += FACTORIAL [ n % 10 ] NEW_LINE n //= 10 NEW_LINE DEDENT return _sum NEW_LINE DEDENT FACTORIAL = [ 0 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ] NEW_LINE def factorialize ( n ) : NEW_LINE INDENT _sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT _sum += FACTORIAL [ n % 10 ] NEW_LINE n //= 10 NEW_LINE DEDENT return _sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colum = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( height ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE
import math NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = math . log ( n , 8 ) ; NEW_LINE return ( i - math . floor ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 ; NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT c = a + b NEW_LINE d = ( c - b ) // 4 NEW_LINE DEDENT else : NEW_LINE INDENT d = a NEW_LINE DEDENT print ( d ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = [ int ( s ) for s in input ( ) . split ( " ▁ " ) ] NEW_LINE if n == m == 0 : break NEW_LINE t = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = [ int ( input ( ) ) for i in range ( m ) ] NEW_LINE t . append ( sum ( a ) ) NEW_LINE DEDENT print ( max ( map ( max , t ) ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c , b = map ( int , input ( ) . split ( ) ) NEW_LINE a [ i ] = max ( a [ i ] , c ) + 1 NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT n = 7 NEW_LINE m = 4 NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ " , countWays ( n , m ) ) NEW_LINE
def print1 ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print1 ( n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE bin_strlist = list ( bin ( n ) ) NEW_LINE bin_list = bin_strlist [ 2 : ] NEW_LINE if bin_list . count ( "0" ) == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( len ( bin_list ) > 1 ) : NEW_LINE INDENT bin_list = bin_list [ 1 : ] NEW_LINE if bin_list . count ( "0" ) == 0 : NEW_LINE INDENT print ( n ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT bin_list . insert ( 0 , "0" ) NEW_LINE DEDENT bin_list . sort ( ) NEW_LINE print ( n - int ( bin_list [ 0 ] ) ) NEW_LINE DEDENT DEDENT
s = list ( input ( ) ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT if s [ i - 1 ] == '0' : NEW_LINE INDENT s [ i - 1 ] = 'B ' NEW_LINE DEDENT DEDENT if s [ i ] == '0' : NEW_LINE INDENT if s [ i - 1 ] == 'B ' : NEW_LINE INDENT s [ i ] = '0' NEW_LINE DEDENT DEDENT DEDENT n = ' ' . join ( s ) NEW_LINE for i in n : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = set ( ) NEW_LINE for _ in [ 0 ] * a : NEW_LINE INDENT s . add ( tuple ( sorted ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def recur ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if ( cnt % 2 == 0 ) : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT dp [ ind ] [ cnt ] = ans NEW_LINE return dp [ ind ] [ cnt ] NEW_LINE DEDENT a = [ 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for j in range ( n ) ] NEW_LINE print ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > x [ i ] : NEW_LINE INDENT x . append ( x [ i ] ) NEW_LINE DEDENT DEDENT y = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < x [ i ] : NEW_LINE INDENT y . append ( a [ i ] ) NEW_LINE DEDENT DEDENT y . sort ( ) NEW_LINE print ( y [ 0 ] + min ( y [ 0 ] , n - y [ - 1 ] ) ) NEW_LINE
defequivalentBase4 ( bin ) : NEW_LINE INDENT if ( bin . compareTo ( "00" ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( bin . compareTo ( "01" ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bin . compareTo ( "10" ) == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT def isDivisibleBy5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if ( l % 2 != 0 ) : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE isOddDigit = 1 NEW_LINE for i in range ( 0 , len ( bin ) , 2 ) : NEW_LINE INDENT if ( isOddDigit != 0 ) : NEW_LINE INDENT odd_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT isOddDigit ^= 1 NEW_LINE DEDENT if ( abs ( odd_sum - even_sum ) % 5 == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT bin = "10000101001" NEW_LINE print ( " True " ) if ( isDivisibleBy5 ( bin ) ) else NEW_LINE DEDENT
from __future__ import ( division , absolute_import , print_function , unicode_literals ) NEW_LINE from sys import stdin NEW_LINE NUM = 100 NEW_LINE VALUE = ( - 1 , 0 , 1 , 4 , - 1 , 3 , 2 , 4 , - 1 , 5 , 6 , 7 , 8 , 9 ) NEW_LINE table = [ chr ( i ) for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) ] NEW_LINE for line in stdin : NEW_LINE INDENT s = [ i for i in line . split ( ) ] NEW_LINE count = 0 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif count == 2 and s [ i ] == '0' : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT elif count == 3 and s [ i ] == '9' : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT elif count < 0 or s [ i ] == '0' : NEW_LINE INDENT count += - 1 NEW_LINE DEDENT table [ s [ i ] ] = count NEW_LINE DEDENT for i in range ( 8 ) : NEW_LINE INDENT print ( table [ str ( i ) ] ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT tmp = a [ i ] + b [ j ] NEW_LINE if ( tmp == ' + ' ) : NEW_LINE INDENT ans = min ( ans , a [ i ] + b [ j ] ) NEW_LINE DEDENT elif ( tmp == ' * ' ) : NEW_LINE INDENT ans = min ( ans , a [ i ] * b [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N //= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT
x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( x % b - a ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = min ( a ) NEW_LINE a += [ p ] NEW_LINE ans , i , temp = 0 , 0 , 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] == p : NEW_LINE INDENT m = - ( - ( i - temp ) // 2 ) NEW_LINE ans = i - temp + 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE temp += 1 NEW_LINE DEDENT if m == - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " The ▁ number ▁ after ▁ unsetting " , " the ▁ rightmost ▁ set ▁ bit " , fun ( n ) ) NEW_LINE
def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( ) NEW_LINE for t in A : NEW_LINE INDENT S . add ( t ) NEW_LINE DEDENT maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 3 NEW_LINE while y in S and S [ y ] != last ( S ) : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT
def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE s = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] ; NEW_LINE if sum not in s . keys ( ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE s [ sum ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 12 , 2 , 7 ] ; NEW_LINE n = len ( a ) ; NEW_LINE b = [ 4 , 3 , 8 ] ; NEW_LINE m = len ( b ) ; NEW_LINE print ( countPairs ( a , b , n , m ) ) ; NEW_LINE DEDENT
import math NEW_LINE def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) NEW_LINE if ( math . floor ( y ) == math . ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from heapq import heapify , heappush , heappop NEW_LINE class Solver ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( input ( ) ) NEW_LINE self . items = [ ] NEW_LINE DEDENT def insert ( self , x ) : NEW_LINE INDENT heapify ( self . items ) NEW_LINE DEDENT def get ( self , x ) : NEW_LINE INDENT if self . items [ x ] == None : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def delete ( self , x ) : NEW_LINE INDENT if self . items [ x ] == None : NEW_LINE INDENT heapify ( self . items ) NEW_LINE DEDENT DEDENT def run ( self ) : NEW_LINE INDENT l = [ ] NEW_LINE for _ in range ( self . n ) : NEW_LINE INDENT op , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( x ) NEW_LINE if op == 0 : NEW_LINE INDENT heappush ( self . items , x ) NEW_LINE DEDENT elif op == 1 : NEW_LINE INDENT heappush ( self . items , - x ) NEW_LINE DEDENT elif op == 2 : NEW_LINE INDENT heappop ( self . items ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Solver ( ) NEW_LINE DEDENT
def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is ▁ " , calculate_min_sum ( a , n ) ) NEW_LINE print ( " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is ▁ " , calculate_max_sum ( a , n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = set ( [ int ( a ) for a in input ( ) . split ( ) ] ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = set ( [ int ( a ) for a in input ( ) . split ( ) ] ) NEW_LINE c = a . difference ( b ) NEW_LINE sorted_c = sorted ( c ) NEW_LINE if len ( sorted_c ) > 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from collections import Counter NEW_LINE c = Counter ( a ) NEW_LINE a0 = c [ 0 ] NEW_LINE for i in c : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT a0 -= 1 NEW_LINE DEDENT DEDENT if a0 >= a1 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT elif a0 >= a1 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ ord ( s2 [ len ( s2 ) - 1 ] ) + s2 NEW_LINE s2 = s2 [ : len ( s2 ) - 1 ] NEW_LINE if ( s == s2 or s == s2 ) and isPalindrome ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if ( len ( s ) <= 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if max ( cnt ) >= ( len ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 if ans ( s ) else 2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " nolon " NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( k , n ) ) NEW_LINE DEDENT
def minCost ( n , arr , cost ) : NEW_LINE INDENT sum = 0 NEW_LINE totalCost = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * sum NEW_LINE arr [ n - 1 ] += sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE z = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( a ) NEW_LINE y . append ( b ) NEW_LINE z . append ( c ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT z . append ( min ( x [ i ] + 1 , y [ i ] + 1 ) ) NEW_LINE DEDENT print ( min ( z ) ) NEW_LINE
import sys NEW_LINE def solve ( n , m , s ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n * m ) : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = solve ( n , m , s ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = 0 NEW_LINE se = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if i == "0" or i == "5" : NEW_LINE INDENT ans += 1 NEW_LINE se . add ( i ) NEW_LINE DEDENT elif i == "1" : NEW_LINE INDENT ans += - 1 NEW_LINE se . add ( i ) NEW_LINE DEDENT DEDENT if len ( se ) == 0 : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans + len ( se ) - 1 ) NEW_LINE DEDENT DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT if data > root . data : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " ▁ " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE root = None NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) NEW_LINE DEDENT inorder ( root ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " OldSite : GeeksforGeeks . org " NEW_LINE Y = " NewSite : GeeksQuiz . com " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is " , LCSubStr ( X , Y , m , n ) ) NEW_LINE DEDENT
def countOccurrences ( x , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def maxOccuring ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x NEW_LINE DEDENT result = 0 NEW_LINE max_count = 1 NEW_LINE for d in range ( 10 ) : NEW_LINE INDENT count = countOccurrences ( x , d ) NEW_LINE if ( count >= max_count ) : NEW_LINE INDENT max_count = count NEW_LINE result = d NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1223355 NEW_LINE print ( " Max ▁ occuring ▁ digit ▁ is " , maxOccuring ( x ) ) NEW_LINE DEDENT
def printLogestIncSubArr ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE len1 = 1 NEW_LINE maxIndex = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( max < len1 ) : NEW_LINE INDENT max = len1 NEW_LINE maxIndex = i - max NEW_LINE DEDENT len1 = 1 NEW_LINE DEDENT DEDENT if ( max < len1 ) : NEW_LINE INDENT max = len1 NEW_LINE maxIndex = n - max NEW_LINE DEDENT for i in range ( maxIndex , max + maxIndex ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printLogestIncSubArr ( arr , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = 1 NEW_LINE l = [ ] NEW_LINE while a ** 2 <= n : NEW_LINE INDENT if n % a == 0 : NEW_LINE INDENT l . append ( a ) NEW_LINE DEDENT a += 1 NEW_LINE DEDENT print ( * l ) NEW_LINE
from collections import Counter NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE lst = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT lst [ d [ i ] - 1 ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT l , r , x = map ( int , input ( ) . split ( ) ) NEW_LINE lst [ l - 1 ] -= 1 NEW_LINE lst [ r - 1 ] -= 1 NEW_LINE x -= 1 NEW_LINE if lst [ x ] == 0 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT if x < lst [ l - 1 ] : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT b [ i ] = res NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Maximum ▁ sum ▁ is : ▁ " , Max_Sum ( a , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 2 * ( min ( a , b ) - 1 ) + ( min ( a , b ) - 1 ) ) NEW_LINE DEDENT
def reverse ( str , x ) : NEW_LINE INDENT n = ( len ( str ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , len ( str ) ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE reverse ( str , x ) NEW_LINE DEDENT
def lps ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( string [ i ] == string [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( string [ i ] == string [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def minimumNumberOfDeletions ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE len = lps ( string ) NEW_LINE return ( n - len ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE print ( " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " , minimumNumberOfDeletions ( string ) ) NEW_LINE DEDENT
def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( n - arr . count ( min ( arr ) ) ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE ans = sum ( ( eulerlib . list_primes ( LIMIT // 2 ) ) for i in itertools . count ( 1 ) for p in itertools . count ( 2 ) if p > eulerlib . sqrt ( LIMIT ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def count ( pos , cnt , tight , nonz , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if cnt == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ cnt ] [ tight ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if tight else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currCnt = cnt NEW_LINE if dig == d : NEW_LINE INDENT if d != 0 or ( d == 0 and nonz != 0 ) : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT DEDENT currTight = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += count ( pos + 1 , currCnt , currTight , ( dig != 0 ) , num ) NEW_LINE DEDENT dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT global dp , K , M NEW_LINE num = [ ] NEW_LINE while x : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 11 NEW_LINE R = 100 NEW_LINE d = 2 NEW_LINE K = 1 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE count = 0 NEW_LINE while ( i <= n ) : NEW_LINE INDENT count += n - i + 1 NEW_LINE i *= 10 NEW_LINE DEDENT print ( count ) NEW_LINE
def isPeak ( arr , n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] > num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( j < n and arr [ j ] > num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def isTrough ( arr , n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] < num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( j < n and arr [ j ] < num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def printPeaksTroughs ( arr , n ) : NEW_LINE INDENT print ( " Peaks ▁ : ▁ " , end = " " ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPeak ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( " " ) ; NEW_LINE print ( " Troughs ▁ : ▁ " , end = " " ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isTrough ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 10 , 5 , 7 , 4 , 3 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printPeaksTroughs ( arr , n ) ; NEW_LINE
def index ( i ) : NEW_LINE INDENT return ( 1 + ( i >> 31 ) - ( - i >> 31 ) ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = " negative " NEW_LINE val = index ( n ) NEW_LINE print ( n , " ▁ is " , s [ val ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT check ( 30 ) NEW_LINE check ( - 20 ) NEW_LINE check ( 0 ) NEW_LINE DEDENT
def frequency ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( a ) NEW_LINE print ( frequency ( a , n , x ) ) NEW_LINE DEDENT
def isNumBalanced ( num ) : NEW_LINE INDENT num = abs ( num ) NEW_LINE str = num + " " NEW_LINE hs = set ( ) NEW_LINE for ch in str : NEW_LINE INDENT hs . add ( ch ) NEW_LINE DEDENT str_len = len ( str ) NEW_LINE hs_len = len ( hs ) NEW_LINE if ( hs_len <= str_len // 2 or hs_len == str_len ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 1234567890 NEW_LINE flag = isNumBalanced ( N ) NEW_LINE if ( flag ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = math . sqrt ( n ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isPrime ( sq ) NEW_LINE DEDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT n = 1 NEW_LINE d = 0 NEW_LINE for i in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT temp = ( contadorued_fraction_term ( i ) * n + d ) NEW_LINE d = n NEW_LINE n = temp NEW_LINE DEDENT ans = sum ( d ) NEW_LINE while n != 0 : NEW_LINE INDENT divisor = int ( n / 10 ) NEW_LINE if divisor > 2 : NEW_LINE INDENT ans += int ( i / 3 * 2 + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += int ( 1 ) NEW_LINE DEDENT n = divisor NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import gcd , sqrt NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) // ( gcd ( x , y ) ) ) NEW_LINE return ( ( z * ans ) // ( gcd ( ans , z ) ) ) NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = int ( pow ( 10 , n - 1 ) ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber += lcm - reminder NEW_LINE if ( ndigitnumber < pow ( 10 , n ) ) : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE z = 5 NEW_LINE res = int ( findDivisible ( n , x , y , z ) ) NEW_LINE if ( res != 0 ) : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT
from math import sqrt , gcd NEW_LINE MAXN = 100001 NEW_LINE prime = [ True ] * MAXN NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( MAXN ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAXN , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT __gcd = gcd ( a , b ) ; NEW_LINE for i in range ( 2 , int ( __gcd ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] and gcd % i == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE a = 6 ; NEW_LINE b = 12 ; NEW_LINE common_prime ( a , b ) ; NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = [ 0 ] * ( n + 1 ) NEW_LINE l = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] , l [ i ] , p = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE t = [ int ( input ( ) ) for _ in range ( m ) ] NEW_LINE dp = [ [ 0 ] * ( 393 + 1 ) for _ in range ( 393 + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( s [ i ] , l [ i ] + 1 ) : NEW_LINE INDENT if not dp [ j ] [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT t [ i ] [ j ] = max ( t [ i ] [ j ] , dp [ j - s [ i ] ] + p ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT print ( t [ int ( input ( ) ) ] if t [ i ] != - 1 else - 1 ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT def dfs ( v , p , graph ) : NEW_LINE INDENT cum = 0 NEW_LINE for i in graph [ v ] : NEW_LINE INDENT if not i == p : NEW_LINE INDENT cum += dfs ( i , v , graph ) NEW_LINE DEDENT DEDENT return cum NEW_LINE DEDENT dfs ( 0 , - 1 , graph ) NEW_LINE c = 0 NEW_LINE x = max ( 0 , c // 2 ) NEW_LINE if x % 2 == 0 and c % 2 == 0 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT elif x % 2 == 1 and c % 2 == 1 : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] == "3" : NEW_LINE INDENT if a [ i ] [ j + 1 ] == "0" and a [ i ] [ j + 1 ] == "0" : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = input ( ) NEW_LINE t = input ( ) NEW_LINE res = 0 NEW_LINE for l in l : NEW_LINE INDENT if len ( l ) < k : NEW_LINE INDENT break NEW_LINE DEDENT t += len ( l ) NEW_LINE DEDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if len ( t ) > k : NEW_LINE INDENT if t [ i ] == t [ i - 1 ] : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT x += t [ i ] NEW_LINE DEDENT DEDENT print ( x , res ) NEW_LINE
import re NEW_LINE class Word : NEW_LINE INDENT def __init__ ( self , word , cnt ) : NEW_LINE INDENT self . word = word NEW_LINE self . cnt = cnt NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT if self . cnt == other . cnt : NEW_LINE INDENT return self . word < other . word NEW_LINE DEDENT else : NEW_LINE INDENT return self . cnt > other . cnt NEW_LINE DEDENT DEDENT DEDENT s = input ( ) NEW_LINE next = input ( ) NEW_LINE for i in range ( 0 , int ( input ( ) ) ) : NEW_LINE INDENT t = input ( ) NEW_LINE if t . isupper ( ) : NEW_LINE INDENT print ( " WA " ) NEW_LINE DEDENT elif t . islower ( ) : NEW_LINE INDENT print ( " AC " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " WA " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE from itertools import zip_longest as zip NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , L = tuple ( int ( i ) for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a . append ( int ( sys . stdin . readline ( ) . strip ( ) ) ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT b . append ( int ( sys . stdin . readline ( ) . strip ( ) ) ) NEW_LINE DEDENT d = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( L ) : NEW_LINE INDENT if a [ i ] [ j ] == '1' : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( L ) : NEW_LINE INDENT if a [ i ] [ j ] == '1' : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT ans = ' NOT ▁ POSSIBLE ' NEW_LINE if not d . get ( i ) : NEW_LINE INDENT ans = ' POSSIBLE ' NEW_LINE DEDENT print ( ' Case ▁ # % d : ▁ % s ' % ( t + 1 , ans ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT dr = [ 1 , - 1 , 0 , 0 ] NEW_LINE dc = [ 0 , 0 , 1 , - 1 ] NEW_LINE ans = 0 NEW_LINE for r0 in range ( len ( grid ) ) : NEW_LINE INDENT for c0 in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ r0 ] [ c0 ] == 1 : NEW_LINE INDENT grid [ r0 ] [ c0 ] = 0 NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT nr = stack . pop ( ) NEW_LINE r = r + dr [ k ] NEW_LINE nc = c + dc [ k ] NEW_LINE if 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] == 1 : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = max ( ans , shape ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE grid = [ [ 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 ] ] NEW_LINE sObj = Solution ( ) NEW_LINE grid = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 ] ] NEW_LINE
import math NEW_LINE def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** 2 * n - 1 ) ) // ( math . pow ( x , 2 ) - 1 ) ) NEW_LINE sum2 = ( ( x * y * ( math . pow ( x , n ) * math . pow ( y , n ) - 1 ) ) // ( x * y - 1 ) ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT x , y , n = 2 , 2 , 2 NEW_LINE print ( int ( sum ( x , y , n ) ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) // 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def deleteNonPrimeNodes ( head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ( ptr != None and isPrime ( ptr . data ) == False ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if ( ptr == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while ( curr != None ) : NEW_LINE INDENT if ( isPrime ( curr . data ) == False ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT return head_ref NEW_LINE DEDENT def prList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE print ( " Original ▁ List : ▁ " , end = " " ) NEW_LINE prList ( head ) NEW_LINE head = deleteNonPrimeNodes ( head ) NEW_LINE print ( " \n Modified ▁ List : ▁ " , end = " " ) NEW_LINE prList
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE read = sys . stdin . read NEW_LINE readline = sys . stdin . readline NEW_LINE readlines = sys . stdin . readlines NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 1 << 60 NEW_LINE MOD = 1000000007 NEW_LINE def main ( ) : NEW_LINE INDENT N , M , L = map ( int , readline ( ) . split ( ) ) NEW_LINE X = [ [ ] for _ in range ( N * M ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT D , A , T = map ( int , readline ( ) . split ( ) ) NEW_LINE X [ D ] . append ( ( A , K , T ) ) NEW_LINE DEDENT dp = [ [ 0 ] * ( N * M + 1 ) for _ in range ( L + 1 ) ] NEW_LINE for i in range ( N * M ) : NEW_LINE INDENT for j in range ( L + 1 ) : NEW_LINE INDENT if X [ i ] [ j ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if 1 < dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = X [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] + X [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ N * M ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( inp ) : NEW_LINE INDENT ( N , M ) = map ( int , inp . readline ( ) . split ( ' ▁ ' ) ) NEW_LINE AB = [ list ( map ( int , inp . readline ( ) . split ( ' ▁ ' ) ) ) for i in range ( M ) ] NEW_LINE roads = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for ab in range ( M ) : NEW_LINE INDENT a , b = AB [ i ] NEW_LINE roads [ b ] [ a ] += 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( a , N ) : NEW_LINE INDENT if roads [ j ] [ i ] == 1 : NEW_LINE INDENT roads [ j ] [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT roads [ i ] [ i ] += roads [ i - 1 ] [ i ] NEW_LINE DEDENT print ( sum ( roads ) ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE M = int ( next ( tokens ) ) NEW_LINE AB = [ list ( map ( int , next ( tokens ) ) ) for _ in range ( M ) ] NEW_LINE solve ( N , M ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE MAP = [ list ( input ( ) ) for i in range ( H ) ] NEW_LINE BLIST = [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if MAP [ i ] [ j ] == " B " : NEW_LINE INDENT BLIST . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT BLIST . sort ( key = lambda x : x [ 0 ] + x [ 1 ] ) NEW_LINE ANS = abs ( BLIST [ 0 ] [ 0 ] - BLIST [ - 1 ] [ 0 ] ) + abs ( BLIST [ 0 ] [ 1 ] - BLIST [ - 1 ] [ 1 ] ) NEW_LINE BLIST . sort ( key = lambda x : x [ 0 ] - x [ 1 ] ) NEW_LINE ANS = max ( ANS , abs ( BLIST [ 0 ] [ 0 ] - BLIST [ - 1 ] [ 0 ] ) + abs ( BLIST [ 0 ] [ 1 ] - BLIST [ - 1 ] [ 1 ] ) ) NEW_LINE print ( ANS ) NEW_LINE
def minReplacement ( str ) : NEW_LINE INDENT if ( len ( str ) > 26 ) : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if ( hash [ j ] == 0 ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE str = list ( str ) NEW_LINE for i in range ( 0 , i , 1 ) : NEW_LINE INDENT if ( hash [ j ] == 0 ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE str = list ( str ) . replace ( str [ i + 1 : ] , chr ( j + ord ( ' a ' ) ) + str [ i + 1 : ] ) NEW_LINE hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' ' . join ( str ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " xxxxyyyy " NEW_LINE minReplacement ( str ) NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 ] * ( n + 2 ) ; NEW_LINE pre_count_1 = [ 0 ] * ( n + 1 ) ; NEW_LINE post_count_0 = [ 0 ] * ( n + 2 ) ; NEW_LINE pre_count_1 [ 0 ] = 0 ; NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; NEW_LINE if ( s [ j - 1 ] == '0' ) : NEW_LINE INDENT pre_count_0 [ j ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 ; NEW_LINE DEDENT if ( s [ n - j ] == '0' ) : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 ; NEW_LINE DEDENT DEDENT if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT s = "000011100000" ; NEW_LINE print ( longestSubseq ( s ) ) ; NEW_LINE
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False for i in range ( N + 1 ) ] NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N , 2 ) : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , ( N + 1 ) // i , 2 ) : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 for i in range ( N + 1 ) ] NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( " Factor ▁ Power " ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N //= s [ N ] NEW_LINE if curr == s [ N ] : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( curr , " \ t " , cnt ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE DEDENT
import math NEW_LINE import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num != 0 ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num //= 10 NEW_LINE DEDENT DEDENT longest = - ( sys . maxsize - 1 ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 & hash [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c ) // 2 ) NEW_LINE DEDENT
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 7 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( va [ 3 ] != vb [ 3 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = ( abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) ) NEW_LINE return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 14 NEW_LINE b = 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE DEDENT
N = 1000001 NEW_LINE def dfs ( a , b , v , vis ) : NEW_LINE INDENT vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT def Calculate ( v ) : NEW_LINE INDENT vis = [ 0 ] * ( n + 1 ) NEW_LINE c = 0 NEW_LINE dfs ( a , b , v , vis ) NEW_LINE ans1 = n - c - 1 NEW_LINE dfs ( b , a , v , vis ) NEW_LINE ans2 = n - c - 1 NEW_LINE print ( ans1 * ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE m = 7 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] NEW_LINE v = [ [ ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT v [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE v [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT Calculate ( v ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE count = 0 NEW_LINE while ( i <= n ) : NEW_LINE INDENT count += n - i + 1 NEW_LINE i *= 10 NEW_LINE DEDENT print ( count ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE results = ( a - 1 ) // ( b - 1 ) NEW_LINE print ( a + results ) NEW_LINE
import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE res = max ( res , getSum ( n // i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE
l , r = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE l = l // 2 NEW_LINE r = r // 2 NEW_LINE if l < r : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( l * ( r - l ) , l * ( r - l ) ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] > temp : NEW_LINE INDENT a [ j ] , a [ i ] = a [ i ] , a [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( * a ) NEW_LINE
from math import sqrt , floor NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( sqrt ( num ) ) + 1 , 1 ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num /= i NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( isProduct ( i ) == isPerfectSquare ( i ) == False ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for itr in vec : NEW_LINE INDENT print ( itr , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 30 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
import sys NEW_LINE import os NEW_LINE import math NEW_LINE import re NEW_LINE import random NEW_LINE tableA = { " A " : "00000" , " B " : "00001" , " C " : "00010" , " D " : "00011" , " E " : "00100" , " F " : "00010" , " G " : "00011" , " H " : "00100" , " I " : "010000" , " J " : "010101" , " K " : "00010011" , " L " : "010001001111" , " M " : "0100010100100" , " N " : "01000101010001" , " O " : "010010" , " P " : "0001010001" , " Q " : "0001001101000" , " R " : "0001001101000" , " S " : "0001110111001111" , " T " : "10101010001" , " U " : "1011011101001101000" , " V " : "10101010001" , " W " : "10110" , " X " : "11100111011101000010" , " Y " : "1011101010001" , " Z " : "10111010000100" } NEW_LINE tableB = { "1011101010001" : " ▁ " , "10101010000" : " ▁ " , "00000001" : "111111" , "010001" : "010001" , "10001" : "1011101010000" , "10101" : "1110101" , "010001" : "110010" , "0001" : "10111010001" , "0000" : "11" , "010001" : "11" , "10101" : "10101" , "10100" : "11" , "01000" : "11" , "1110101" : "10111" , "0001" : "11" , "010001" : "11" , "0011101" : "10101" , "010001" : "11" , "010010" : "10111010001" , "010011" : "11
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while n >= 10 : NEW_LINE INDENT ans += ( n - n % 10 ) // 10 + n // 10 NEW_LINE n = n // 10 + n % 10 NEW_LINE DEDENT print ( ans + n ) NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) NEW_LINE DEDENT num1 = 559 NEW_LINE num2 = 703 NEW_LINE if ( areEquivalent ( num1 , num2 ) ) : NEW_LINE INDENT print ( " Equivalent " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Equivalent " ) NEW_LINE DEDENT
def findY ( x ) : NEW_LINE INDENT if ( x > 2 ) : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE
MOD = 1000000007 ; NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = 2 ; NEW_LINE print ( modFact ( n , m ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE counter = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] < a [ - 1 ] : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE c . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT m = a [ i : ] . index ( a [ - 1 ] ) NEW_LINE b . append ( m ) NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE print ( counter ) NEW_LINE
import sys NEW_LINE import itertools NEW_LINE import time NEW_LINE import math NEW_LINE import heapq NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] NEW_LINE path = [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT x = ( i , j ) NEW_LINE path . append ( x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( W - 1 , - 1 , - 1 ) : NEW_LINE INDENT x = ( i , j ) NEW_LINE path . append ( x ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( len ( path ) - 1 ) : NEW_LINE INDENT p = path [ i ] NEW_LINE p2 = path [ i + 1 ] NEW_LINE if A [ p [ 0 ] ] [ p [ 1 ] ] == 1 : NEW_LINE INDENT A [ p2 [ 0 ] ] [ p2 [ 1 ] ] = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( l [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT l1 . append ( l [ n - 1 ] ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT l1 . append ( l [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( l1 [ i + 1 ] , end = ' ▁ ' ) NEW_LINE DEDENT
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE DEDENT
from math import pow NEW_LINE def find ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , pow ( 2 , length ) + 1 ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) % 2 == 1 ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE DEDENT DEDENT if ( sum == s ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( " NO " ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum = 5 ; NEW_LINE array = [ - 1 , 2 , 4 , 121 ] ; NEW_LINE length = len ( array ) ; NEW_LINE find ( array , length , sum ) ; NEW_LINE DEDENT
def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( fre [ i ] % k == 0 ) : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE while ( x != 0 ) : NEW_LINE INDENT str += chr ( i + ord ( ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print ( K_String ( s , k ) ) NEW_LINE DEDENT
import math NEW_LINE def solve ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans += 0.5 ** i NEW_LINE DEDENT for k in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if i == k : NEW_LINE INDENT ans += 1.0 ** i NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( ans / k ) ** i NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( n ) ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT s = str ( a ) NEW_LINE count = 0 NEW_LINE for i in s : NEW_LINE INDENT if i . isnumeric ( ) : NEW_LINE INDENT count += int ( i ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
import sys NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] NEW_LINE def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] NEW_LINE def Yes ( ) : print ( ' Yes ' ) NEW_LINE def No ( ) : print ( ' No ' ) NEW_LINE def YES ( ) : print ( ' YES ' ) NEW_LINE def NO ( ) : print ( ' NO ' ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = INT ( ) NEW_LINE A = LIST ( N ) NEW_LINE l = MAX NEW_LINE ans = 10 ** 18 NEW_LINE while l + 1 < r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if A [ mid ] < mid : NEW_LINE INDENT for i in range ( mid ) : NEW_LINE INDENT if A [ i ] == mid : NEW_LINE INDENT ans = mid NEW_LINE break NEW_LINE DEDENT DEDENT if i == N : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if n == 0 and k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE s = sum ( a [ 0 : k ] ) NEW_LINE ans = " Yes " NEW_LINE for i in range ( k ) : NEW_LINE INDENT if s >= a [ i ] : NEW_LINE INDENT ans = " No " NEW_LINE break NEW_LINE DEDENT s -= a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE s = "47744" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE DEDENT
import sys NEW_LINE def maxZeros ( n ) : NEW_LINE INDENT if ( n == 0 or ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE setBit = 1 NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , b * 8 ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT max0 = - sys . maxsize NEW_LINE cur = prev NEW_LINE for i in range ( i + 1 , b * 8 ) : NEW_LINE INDENT cur += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT if ( max0 < ( cur - prev - 1 ) ) : NEW_LINE INDENT max0 = cur - prev - 1 NEW_LINE DEDENT prev = cur NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT n = 549 NEW_LINE print ( maxZeros ( n ) ) NEW_LINE
def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE num *= k NEW_LINE DEDENT return sum NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) NEW_LINE sumAll = ( n * ( n + 1 ) ) // 2 NEW_LINE return ( sumAll - pwrK ) NEW_LINE DEDENT n , k = 10 , 3 NEW_LINE print ( getSum ( n , k ) ) NEW_LINE
def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE D = 8 NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE maxSum ( a , n ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE def replaceSpaces ( string ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' ) : NEW_LINE INDENT space_count += 1 NEW_LINE DEDENT DEDENT while ( string [ i - 1 ] == ' ▁ ' ) : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT new_length = i + space_count * 2 NEW_LINE if ( new_length > MAX ) : NEW_LINE INDENT return string NEW_LINE DEDENT index = new_length - 1 NEW_LINE new_str = string NEW_LINE string = list ( new_str ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( new_str [ j ] == ' ▁ ' ) : NEW_LINE INDENT string [ index ] = '0' NEW_LINE string [ index - 1 ] = '2' NEW_LINE string [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index ] = new_str [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " Mr ▁ John ▁ Smith ▁ " NEW_LINE string = replaceSpaces ( string ) NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
n , s , r , l = int ( input ( ) ) , input ( ) , 0 , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + r ) % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE if s [ i ] == '0' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( l ) ) NEW_LINE
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r ) : NEW_LINE INDENT if ( ( m % r ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( 10 , 20 ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( a , "0" ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT if a % 10 == 0 : NEW_LINE INDENT print ( str ( a ) + " ▁ " + str ( b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ( a ) + " ▁ " + str ( b ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE from collections import deque , defaultdict NEW_LINE from math import * NEW_LINE import bisect NEW_LINE import random NEW_LINE from itertools import permutations , accumulate , combinations NEW_LINE from operator import itemgetter NEW_LINE from sys import stdin , stdout NEW_LINE import sys NEW_LINE from decimal import Decimal NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . buffer . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def BI ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) NEW_LINE def SI ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( ) NEW_LINE def li ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def lli ( rows ) : return [ li ( ) for _ in range ( rows ) ] NEW_LINE def si ( ) : return input ( ) NEW_LINE def ii ( ) : return int ( input ( ) ) NEW_LINE def ins ( ) : return input ( ) . split ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = ii ( ) NEW_LINE a = li ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if abs ( a [ j - 1 ] - a [ j ] ) < sm : NEW_LINE INDENT sm = abs ( a [ j - 1 ] - a [ j ] ) NEW_LINE DEDENT DEDENT ans = min ( ans , sm ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = input ( ) NEW_LINE n = n . replace ( "7" , "0" ) NEW_LINE print ( sum ( int ( n [ i ] ) for i in range ( 10 ) ) ) NEW_LINE
k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in s : NEW_LINE INDENT a . append ( int ( i ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE d = 9 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT d += a [ i ] NEW_LINE DEDENT if k >= d : NEW_LINE INDENT print ( len ( a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( a ) - 1 ) NEW_LINE DEDENT
import math NEW_LINE n , k , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE count = 0 NEW_LINE value = 0 NEW_LINE if k == 1 : NEW_LINE INDENT print ( min ( n , k * a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( n - i ) % k == 0 : NEW_LINE INDENT value += a NEW_LINE DEDENT else : NEW_LINE INDENT value += b NEW_LINE DEDENT n = n // k NEW_LINE count += n * a NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum ; NEW_LINE sum = 0 ; NEW_LINE DEDENT sum = sum + n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 1234 ; NEW_LINE print ( digSum ( n ) ) ; NEW_LINE
def solve ( n , m , s , t ) : NEW_LINE INDENT dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for y in range ( n + 1 ) : NEW_LINE INDENT dp [ y ] [ 0 ] = 1 NEW_LINE DEDENT for x in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( 1 , m + 1 ) : NEW_LINE INDENT if s [ x - 1 ] == t [ y - 1 ] : NEW_LINE INDENT dp [ y ] [ x ] = dp [ y - 1 ] [ x ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ y ] [ x ] = dp [ y - 1 ] [ x - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for y in range ( 1 , n + 1 ) : NEW_LINE INDENT for x in range ( 1 , m + 1 ) : NEW_LINE INDENT if s [ y ] == t [ x - 1 ] : NEW_LINE INDENT ans = max ( ans , dp [ y - 1 ] [ x ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT n , m = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE print ( solve ( n , m , s , t ) ) NEW_LINE
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( " % sth ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ % d " % ( n , centered_heptagonal_num ( n ) ) ) NEW_LINE DEDENT
def missingNum ( arr , n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT list . append ( int ( arr [ i ] ) ) NEW_LINE DEDENT minvalue = min ( list ) NEW_LINE xornum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue += 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 13 , 12 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( missingNum ( arr , n ) ) NEW_LINE DEDENT
def smallestPermute ( n ) : NEW_LINE INDENT res = [ None ] * ( n + 1 ) ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) ; NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) ; NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) ; NEW_LINE res [ n - 2 ] = chr ( 48 + n ) ; NEW_LINE res [ n - 3 ] = chr ( 48 + n - 1 ) ; NEW_LINE DEDENT res [ n ] = ' \ 0' ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE smallestPermute ( n ) ; NEW_LINE
def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT b = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] & K ; NEW_LINE DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT try : NEW_LINE INDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT except KeyError : NEW_LINE INDENT map [ b [ i ] ] = False ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT map [ a [ i ] ] = False ; NEW_LINE DEDENT DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT if ( map [ b [ i ] ] ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT except KeyError : NEW_LINE INDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT K = 3 ; NEW_LINE a = [ 1 , 2 , 3 , 7 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minOperations ( a , n , K ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT person = 0 NEW_LINE for i in range ( 0 , H ) : NEW_LINE INDENT for j in range ( 0 , W ) : NEW_LINE INDENT if geo [ i ] [ j ] != " _ " : NEW_LINE INDENT search ( i , j ) NEW_LINE person += 1 NEW_LINE DEDENT DEDENT DEDENT print ( person , person ) NEW_LINE DEDENT def search ( i , j ) : NEW_LINE INDENT temp = geo [ i ] [ j ] NEW_LINE geo [ i ] [ j ] = " _ " NEW_LINE for a in range ( 0 , 4 ) : NEW_LINE INDENT idx , jdy = i + dx [ a ] , j + dy [ a ] NEW_LINE if ( isOnMap ( idx , jdy ) ) : NEW_LINE INDENT if ( isNeededToSolve ( temp , idx , jdy ) ) : NEW_LINE INDENT search ( idx , jdy ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def isOnMap ( i , j ) : return ( 0 <= i and 0 <= j and i < H and j < W ) NEW_LINE def isNeededToSolve ( temp , i , j ) : NEW_LINE INDENT target = geo [ i ] [ j ] NEW_LINE return ( target != " _ " and temp == target ) NEW_LINE DEDENT limit = 10 ** 7 NEW_LINE sys . setrecursionlimit ( limit ) NEW_LINE H , W , tempH = - 1 , - 1 , 0 NEW_LINE dx = [ - 1 , 0 , 1 , 0 ] NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE geo = [ [ 0 for i in range ( 1 ) ] for j in range ( 1 ) ] NEW_LINE while True : NEW_LINE INDENT line = input ( ) NEW_LINE if H == - 1 and W == - 1 : NEW_LINE INDENT p = line . split ( " ▁ " ) NEW_LINE H , W = int ( p [ 0 ] ) , int ( p [ 1 ] ) NEW_LINE geo = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] NEW_LINE DEDENT else : NEW_LINE INDENT geo [ tempH ] = list ( line ) NEW_LINE tempH += 1 NEW_LINE DEDENT if H == 0 and W == 0 : break NEW_LINE if tempH is H : NEW_LINE INDENT solve ( ) NEW_LINE H , W , tempH = - 1 , - 1 , 0 NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n > 180 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) if n % 180 == 0 else print ( " NO " ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT NUM_COLORS = 7 NEW_LINE BALLS_PER_COLOR = 10 NEW_LINE NUM_PICKED = 20 NEW_LINE numerator = 0 NEW_LINE denominator = eulerlib . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) NEW_LINE def explore ( NUM_PICKED , BALLS_PER_COLOR , history ) : NEW_LINE INDENT if ( remain == 0 ) : NEW_LINE INDENT hist = [ 0 for i in range ( NUM_COLORS ) ] NEW_LINE for i in range ( len ( history ) ) : NEW_LINE INDENT hist [ i ] = history [ i ] NEW_LINE DEDENT hist [ 0 ] = 0 NEW_LINE for x in hist : NEW_LINE INDENT hist [ x ] += 1 NEW_LINE DEDENT count = eulerlib . factorial ( NUM_COLORS ) NEW_LINE for x in hist : NEW_LINE INDENT count = divide_exactly ( count , math . factorial ( x ) ) NEW_LINE DEDENT for x in hist : NEW_LINE INDENT count = count * math . binomial ( BALLS_PER_COLOR , x ) NEW_LINE DEDENT disjointcolors = len ( history ) NEW_LINE numerator += disjointcolors * ( disjointcolors - 1 ) NEW_LINE return str ( numerator ) // ( 10 ** ( NUM_COLORS - 1 ) ) NEW_LINE DEDENT def divide_exactly ( x , y ) : NEW_LINE INDENT temp = x % y NEW_LINE explore ( NUM_PICKED , BALLS_PER_COLOR , NUM_PICKED ) NEW_LINE history . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE flag = True NEW_LINE t1 = t1 // 60 NEW_LINE t2 = t1 % 60 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if flag : NEW_LINE INDENT t1 = t1 - a * 60 + b NEW_LINE DEDENT else : NEW_LINE INDENT t1 = t1 + a * 60 + b NEW_LINE DEDENT if t2 < t1 : NEW_LINE INDENT flag = False NEW_LINE DEDENT t2 = t2 - a * 60 + b NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( "0 ▁ 0" ) NEW_LINE DEDENT else : NEW_LINE INDENT mins = min ( s1 , t2 ) NEW_LINE flag = True NEW_LINE ans = "0 ▁ 0" NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT k = ans + str ( k // 60 ) + str ( k % 60 ) NEW_LINE if k >= mins : NEW_LINE INDENT ans = k - mins NEW_LINE break NEW_LINE DEDENT t1 = k NEW_LINE DEDENT else : NEW_LINE INDENT ans = k NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( b == 1 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( a , " ▁ " , a * b , " ▁ " , b + a ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT a = list ( input ( ) ) NEW_LINE if a [ 0 ] == "0" : NEW_LINE INDENT break NEW_LINE DEDENT b = list ( input ( ) ) NEW_LINE hit = 0 NEW_LINE blow = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT hit += 1 NEW_LINE DEDENT elif a [ i ] == b [ i ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT DEDENT if a [ 0 ] == b [ 0 ] : NEW_LINE INDENT hit -= 1 NEW_LINE DEDENT if a [ 1 ] == b [ 1 ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT if a [ 2 ] == b [ 2 ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT if a [ 3 ] == b [ 3 ] : NEW_LINE INDENT blow -= 1 NEW_LINE DEDENT if a [ 0 ] == b [ 1 ] or a [ 0 ] == b [ 2 ] or a [ 0 ] == b [ 3 ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT if a [ 1 ] == b [ 0 ] or a [ 1 ] == b [ 2 ] or a [ 1 ] == b [ 3 ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT if a [ 2 ] == b [ 0 ] or a [ 2 ] == b [ 1 ] or a [ 2 ] == b [ 3 ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT DEDENT print ( hit , blow ) NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atleast ▁ 4 ▁ elements " ) NEW_LINE DEDENT table1 = [ 0 ] * n NEW_LINE table2 = [ 0 ] * n NEW_LINE table3 = [ 0 ] * n - 1 NEW_LINE table4 = [ 0 ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE
def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE centeredHexagonalSeries ( n ) NEW_LINE DEDENT
S = input ( ) NEW_LINE length = len ( S ) NEW_LINE S_list = list ( S ) NEW_LINE S_ex = ' ' . join ( ( [ '1' if ( k == ' A ' or k == ' B ' or k == ' C ' ) else '0' for k in S_list ] ) ) NEW_LINE S_ans = [ ' A ' , ' B ' , ' C ' ] NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT if S_ex . find ( S [ i ] ) != - 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT elif S_ex . find ( S [ i ] ) != - 1 : NEW_LINE INDENT S_ans [ i ] = ' No ' NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' . ' : NEW_LINE INDENT dp [ i ] = dp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' . ' : NEW_LINE INDENT n = i + 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if s [ i ] == ' . ' : NEW_LINE INDENT n = n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = dp [ i ] - 1 NEW_LINE if ( t == 0 ) : NEW_LINE INDENT print ( t , n ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
MAX = 100 NEW_LINE def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE
MAX = 100 NEW_LINE def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ i ] [ i ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count += 1 NEW_LINE sum += n NEW_LINE n = n - 2 NEW_LINE DEDENT return int ( sum / count ) NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT return ( n + 1 ) / 2 ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( averageOdd ( n ) ) ; NEW_LINE
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while ( curr_ele in us ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while ( curr_ele in us ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( " Yes " ) NEW_LINE else : print ( " No " ) NEW_LINE
from queue import Queue NEW_LINE def getLeftMostZero ( zero ) : NEW_LINE INDENT if ( zero . empty ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT def getLeftMostOne ( one ) : NEW_LINE INDENT if ( one . empty ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one . pop ( ) NEW_LINE return 1 NEW_LINE DEDENT def getLeftMostElement ( zero , one ) : NEW_LINE INDENT if ( zero . empty ( ) and one . empty ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( zero . empty ( ) ) : NEW_LINE INDENT one . remove ( ) NEW_LINE return 1 NEW_LINE DEDENT elif ( one . empty ( ) ) : NEW_LINE INDENT zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT res = 0 NEW_LINE if ( zero [ 0 ] < one [ 0 ] ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT if ( res == 0 ) : NEW_LINE INDENT zero . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res = 1 NEW_LINE DEDENT if ( res == 0 ) : NEW_LINE INDENT zero . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res = 1 NEW_LINE DEDENT DEDENT def performQueries ( arr , n , queries , q ) : NEW_LINE INDENT zero = Queue ( ) NEW_LINE one = Queue ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT type = queries [ i ] NEW_LINE if ( type == 1 ) : NEW_LINE INDENT print ( getLeftMostZero ( zero ) ) NEW_LINE DEDENT elif ( type == 2 ) : NEW_LINE INDENT print ( getLeftMostOne ( one ) ) NEW_LINE DEDENT elif ( type == 3 ) : NEW_LINE INDENT print ( getLeftMostElement ( zero , one ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE queries = [ 1 , 3 , 1 ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( arr , n , queries , q ) NEW_LINE DEDENT
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE if x < 0 : NEW_LINE INDENT val = val * ( - 1 ) NEW_LINE DEDENT print ( " { } ▁ 0 ▁ " . format ( val * ( - 1 ) ) , "0 ▁ " , val * ( - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 3 NEW_LINE y = 3 NEW_LINE Vertices ( x , y ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 for i in range ( n ) ] NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True NEW_LINE div1 = i NEW_LINE div2 = S // i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if ( j not in hash ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S // i , S + 1 , s // i ) : NEW_LINE INDENT if ( j not in hash ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in sorted ( res ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT
def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE temp . remove ( k ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE originalArray ( Arr , n ) NEW_LINE DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT s1 = input ( ) NEW_LINE w = list ( input ( ) ) NEW_LINE l . append ( w ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += min ( l [ i ] , l [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT houses . sort ( ) NEW_LINE result = - 999999999999 NEW_LINE for house in houses : NEW_LINE INDENT index = 0 NEW_LINE if index < 0 : NEW_LINE INDENT index = - ( index + 1 ) NEW_LINE DEDENT dist1 = house - heaters [ index - 1 ] NEW_LINE if index - 1 >= 0 : NEW_LINE INDENT dist1 = house - heaters [ index - 1 ] NEW_LINE DEDENT if index < len ( houses ) : NEW_LINE INDENT dist2 = heaters [ index ] - house NEW_LINE DEDENT result = max ( result , min ( dist1 , dist2 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE houses = [ 1 , 2 , 3 ] NEW_LINE heouses = [ 2 ] NEW_LINE out = sObj . findRadius ( houses , heaters ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( itertools . islice ( filter ( lambda x , y : ( x % y != 0 and eulerlib . is_prime ( x ) , 25 ) , 0 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def find_Least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > sys . maxsize // 10 : NEW_LINE INDENT raise ValueError ( " Arithmetic ▁ overflow " ) NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def checkRecursive ( num , x , k , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT r = int ( math . floor ( math . pow ( num , 1.0 / n ) ) ) NEW_LINE for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - math . pow ( i , n ) NEW_LINE if ( a >= 0 ) : NEW_LINE INDENT checkRecursive ( num , x - math . pow ( i , n ) , i , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( check ( 10 , 2 ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE import math NEW_LINE from statistics import * NEW_LINE from collections import * NEW_LINE from operator import itemgetter NEW_LINE def solve ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT t = n % 10 NEW_LINE if t == 0 : NEW_LINE INDENT res . append ( " + " ) NEW_LINE DEDENT elif t == 1 : NEW_LINE INDENT res . append ( " - " ) NEW_LINE DEDENT DEDENT x = n // 10 NEW_LINE res . append ( t ) NEW_LINE if x == 1 : NEW_LINE INDENT print ( "7" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " + " + " . join ( res ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE n = int ( next ( tokens ) ) NEW_LINE solve ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def solve ( N ) : NEW_LINE INDENT A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = inpl ( ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE DEDENT dp = [ [ INF ] * ( N + 1 ) for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if j + A [ i ] >= dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + A [ i ] ] ) NEW_LINE DEDENT if j < dp [ i ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if dp [ i ] [ i ] > ans : NEW_LINE INDENT ans = dp [ i ] [ i ] NEW_LINE DEDENT DEDENT print ( ans , end = " ▁ " ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N > 1 : NEW_LINE INDENT inputs = inpl ( ) NEW_LINE solve ( N ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = list ( map ( str , n ) ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '9' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( s [ i ] == '0' ) : NEW_LINE INDENT count += - 1 NEW_LINE DEDENT DEDENT s_m = [ ] NEW_LINE for i in s : NEW_LINE INDENT s_m . append ( int ( i ) ) NEW_LINE DEDENT print ( sum ( s_m ) ) NEW_LINE
def prime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = 0 NEW_LINE sum = a + b NEW_LINE temp = 1 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( not prime ( sum + temp ) ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m , a = 6 , 6 , 4 NEW_LINE print ( int ( Squares ( n , m , a ) ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) . split ( ' ▁ ' ) NEW_LINE n = int ( s [ 0 ] ) NEW_LINE m = int ( s [ 1 ] ) NEW_LINE if n % m == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j * j * j > i ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j * j * j == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 30 NEW_LINE print ( " Count ▁ of ▁ Cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( N : int , A : " List [ int ] " ) : NEW_LINE INDENT A . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE tmp = [ ] NEW_LINE while i < N - 1 : NEW_LINE INDENT if A [ i ] % 2 == 0 : NEW_LINE INDENT tmp . append ( A [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if len ( tmp ) > 1 : NEW_LINE INDENT ret = tmp [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT ret = tmp [ 1 ] NEW_LINE DEDENT print ( ret ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE A = [ int ( next ( tokens ) ) for _ in range ( N ) ] NEW_LINE solve ( N , A ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def SubString ( str , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( str [ i : j ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT str = " abcd " NEW_LINE SubString ( str , len ( str ) ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 and isPrime ( i ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if arr [ i ] == 1 and isPrime ( i ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ 0s ▁ = ▁ " , c0 ) NEW_LINE print ( " Number ▁ of ▁ 1s ▁ = ▁ " , c1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE countPrimePosition ( arr ) NEW_LINE DEDENT
def angleextcycquad ( z ) : NEW_LINE INDENT print ( " The ▁ exterior ▁ angle ▁ of " , " the ▁ cyclic ▁ quadrilateral ▁ is " , z , " degrees " ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT z = 48 ; NEW_LINE angleextcycquad ( z ) ; NEW_LINE DEDENT
import sys NEW_LINE def printMinIndexChar ( string , patt ) : NEW_LINE INDENT minIndex = sys . maxsize NEW_LINE m = len ( string ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == string [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != sys . maxsize ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = " , string [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE factorul = " set " NEW_LINE printMinIndexChar ( string , factorul ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE happy = ▁ Alex ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT happy += ▁ Alex ' NEW_LINE DEDENT else : NEW_LINE INDENT poor += ▁ Poor ▁ Alex ' NEW_LINE DEDENT DEDENT print ( happy ) NEW_LINE
def maxnumber ( n , k ) : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT ans = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( n / i ) : NEW_LINE INDENT temp = ( n // ( i * 10 ) ) * i + ( n % i ) ; NEW_LINE i *= 10 ; NEW_LINE ans = max ( ans , temp ) ; NEW_LINE DEDENT n = ans ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6358 ; NEW_LINE k = 1 ; NEW_LINE print ( maxnumber ( n , k ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def solve ( N , received ) : NEW_LINE INDENT received_set = received . copy ( ) NEW_LINE received_set . discard ( '0' ) NEW_LINE for t in range ( len ( received ) ) : NEW_LINE INDENT received_set . remove ( received [ t ] ) NEW_LINE DEDENT answer = [ len ( received ) ] * len ( received_set ) NEW_LINE N = int ( received_set [ 0 ] ) NEW_LINE M = int ( received_set [ 1 ] ) NEW_LINE received_set = set ( [ int ( t ) for t in received_set ] ) NEW_LINE C = [ 0 ] * ( N + 1 ) NEW_LINE for c , n in enumerate ( received_set ) : NEW_LINE INDENT C [ received [ c - 1 ] ] += 1 NEW_LINE DEDENT received_set = received_set . copy ( ) NEW_LINE C [ N - 1 ] = 1 NEW_LINE answer [ 0 ] = 1 NEW_LINE for c in range ( 1 , N + 1 ) : NEW_LINE INDENT if len ( received_set ) == 1 : NEW_LINE INDENT answer [ c ] += 1 NEW_LINE DEDENT elif len ( received_set ) == 2 : NEW_LINE INDENT answer [ c ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( c - 1 , received [ c ] ) NEW_LINE answer [ x ] = 1 NEW_LINE DEDENT DEDENT for received , b in zip ( received_set , answer ) : NEW_LINE INDENT print ( received , b ) NEW_LINE DEDENT return ' ▁ ' . join ( map ( str , answer ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE received_set = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT received_set . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT solve ( N , received_set ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import sys NEW_LINE import numpy as np NEW_LINE sr = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ir = lambda : int ( sr ( ) ) NEW_LINE lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) NEW_LINE N = ir ( ) NEW_LINE A = np . array ( [ 0 ] + lr ( ) + [ 0 ] ) NEW_LINE total = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT total += A [ i ] NEW_LINE DEDENT answer = np . sum ( A [ : , 0 ] ) - total NEW_LINE print ( answer ) NEW_LINE
def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N <= 10 ) : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return ans % 100 NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 1 NEW_LINE for N in range ( 1 , 10 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " ▁ : ▁ " , get_last_two_digit ( N ) ) NEW_LINE DEDENT DEDENT
def get_integer ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def get_string ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT binary_num = "1001" NEW_LINE print ( get_integer ( binary_num , 2 ) ) NEW_LINE
import math NEW_LINE def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z ; NEW_LINE if ( math . ceil ( a ) == 1 and math . floor ( a ) == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 0.70710678 ; NEW_LINE m = 0.5 ; NEW_LINE n = 0.5 ; NEW_LINE if ( isPossible ( l , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
MAX = 1000000 NEW_LINE MOD = 10000007 NEW_LINE result = [ 0 ] * ( MAX + 1 ) NEW_LINE fact = [ 0 ] * ( MAX + 1 ) NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE print ( ( a [ n - 1 ] - 1 ) * ( i + 1 ) // 2 ) NEW_LINE DEDENT
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if ( x - 1 < size and arr [ x - 1 ] > 0 ) : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE arr2 = [ 0 for i in range ( size - shift ) ] NEW_LINE j = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return findMissingPositive ( arr2 , j ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " , missing ) NEW_LINE
mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d , n = 9 , 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , a = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ ] NEW_LINE for x in a : NEW_LINE INDENT if x [ 0 ] + x [ 1 ] > x [ 2 ] : NEW_LINE INDENT c . append ( - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( len ( c ) + 1 , 2 , len ( c ) + 1 ) NEW_LINE DEDENT
def convert12 ( str ) : NEW_LINE INDENT h1 = int ( str [ 0 ] ) - ord ( '0' ) NEW_LINE h2 = int ( str [ 1 ] ) - ord ( '0' ) NEW_LINE hh = h1 * 10 + h2 NEW_LINE  Meridien = " " NEW_LINE if ( hh < 12 ) : NEW_LINE INDENT  Meridien = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT  Meridien = " PM " NEW_LINE DEDENT hh %= 12 NEW_LINE if ( hh == 0 ) : NEW_LINE INDENT print ( "12" , end = " " ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( hh , end = " " ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " ▁ " , Meridien ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "17:35:20" NEW_LINE convert12 ( str ) NEW_LINE DEDENT
def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , min ( len ( s ) , k ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " xaxa " NEW_LINE b = " xaxaxaxa " NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE DEDENT
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT i , w = 0 , 0 NEW_LINE K = [ [ 0 for i in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( res == K [ i - 1 ] [ w ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] , end = " ▁ " ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE printknapSack ( W , wt , val , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT removed = set ( ) NEW_LINE res = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ 1 ] == a [ j ] [ 0 ] and i != j and j not in removed : NEW_LINE INDENT removed . add ( j ) NEW_LINE res -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE
def indexedSequentialSearch ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 ] * 20 NEW_LINE indices = [ 0 ] * 20 NEW_LINE j = 0 NEW_LINE ind = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT elements [ ind ] = arr [ i ] NEW_LINE indices [ ind ] = i NEW_LINE ind += 1 NEW_LINE DEDENT if ( k < elements [ 0 ] ) : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if ( k < elements [ i ] ) : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end = indices [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( k == arr [ i ] ) : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 1 ) : NEW_LINE INDENT print ( " Found ▁ at ▁ index " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE  indexedSequentialSearch ( arr , n , k ) NEW_LINE DEDENT
def larrgestPalindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit *= 10 NEW_LINE upper_limit += 9 NEW_LINE DEDENT lower_limit = 1 + upper_limit // 10 NEW_LINE max_product = 0 NEW_LINE for i in range ( upper_limit , lower_limit , - 1 ) : NEW_LINE INDENT for j in range ( i , lower_limit , - 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if ( product < max_product ) : NEW_LINE INDENT break NEW_LINE DEDENT number = product NEW_LINE reverse = 0 NEW_LINE while ( number != 0 ) : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number //= 10 NEW_LINE DEDENT if ( product == reverse and product > max_product ) : NEW_LINE INDENT max_product = product NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT n = 2 NEW_LINE print ( larrgestPalindrome ( n ) ) NEW_LINE
import bisect NEW_LINE def solve ( a ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( solve ( a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 0 if a == 0 and b == 0 and c == 0 else ( 0 if a > 0 else ( 1 if b > 0 and c > 0 else ( 2 if a > 0 and b > 0 and c > 0 else ( 3 if a > 0 and b > 0 and c > 0 ) ) ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT x += abs ( a [ j ] - a [ j - 1 ] ) NEW_LINE DEDENT DEDENT if x < ans : NEW_LINE INDENT ans = x NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def maximumXor ( arr , n ) : NEW_LINE INDENT sForward = [ ] NEW_LINE sBackward = [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( sForward ) != 0 and arr [ i ] < arr [ sForward [ - 1 ] ] ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ sForward [ - 1 ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( i ) NEW_LINE while ( len ( sBackward ) != 0 and arr [ n - i - 1 ] < arr [ sBackward [ - 1 ] ] ) : NEW_LINE INDENT ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ - 1 ] ] ) NEW_LINE sBackward . pop ( ) NEW_LINE DEDENT sBackward . append ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumXor ( arr , n ) ) NEW_LINE DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT n = int ( n / 16 ) ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 2545 ; NEW_LINE decToHexa ( n ) ; NEW_LINE
from collections import Counter NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE print ( max ( Counter ( a + [ x - 1 for x in a ] + [ x + 1 for x in a ] ) . values ( ) ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT if s [ j ] == " _ " : NEW_LINE INDENT l . append ( ( i , j ) ) NEW_LINE DEDENT DEDENT DEDENT s = input ( ) NEW_LINE l . reverse ( ) NEW_LINE t = [ ] NEW_LINE for i in l : NEW_LINE INDENT if i [ 0 ] == " _ " : NEW_LINE INDENT t . append ( ( i [ 1 ] , i [ 0 ] ) ) NEW_LINE DEDENT DEDENT x = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if t [ i ] [ 0 ] != " _ " : NEW_LINE INDENT x += 1 NEW_LINE DEDENT if t [ i ] [ 1 ] != " _ " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT t [ i ] = ( x , y ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if t [ i ] [ 1 ] == " _ " : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Hello ▁ World " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT
def extractMaximum ( str ) : NEW_LINE INDENT num , res = 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT str = "100klh564abc365bg " NEW_LINE print ( extractMaximum ( str ) ) NEW_LINE
max = 50009 ; NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT Sum = [ 0 ] * max ; NEW_LINE index_1 , index_2 , index_3 , index = 1 , 0 , 0 ; NEW_LINE k , i = 0 , 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = Sum [ i - 1 ] + arr [ k ] ; NEW_LINE k += 1 ; NEW_LINE DEDENT ans = - ( 1e15 ) ; NEW_LINE index_1 = index_2 = index_3 = - 1 ; NEW_LINE for l in range ( n + 1 ) : NEW_LINE INDENT index = 0 ; NEW_LINE minx = 1e15 ; NEW_LINE for r in range ( l , n + 1 ) : NEW_LINE INDENT if ( Sum [ r ] < vmin ) : NEW_LINE INDENT minx = Sum [ r ] ; NEW_LINE index = r ; NEW_LINE DEDENT if ( Sum [ l ] + Sum [ r ] - vmin > ans ) : NEW_LINE INDENT ans = Sum [ l ] + Sum [ r ] - vmin ; NEW_LINE index_1 = l ; NEW_LINE index_2 = index ; NEW_LINE index_3 = r ; NEW_LINE DEDENT DEDENT DEDENT print ( index_1 , index_2 , index_3 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE find_Indices ( arr , n ) ; NEW_LINE DEDENT
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printElements ( arr , n ) NEW_LINE DEDENT
def valueofX ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ar [ i ] NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return int ( sum / n ) NEW_LINE DEDENT else : NEW_LINE INDENT A = int ( sum / n ) + 1 NEW_LINE B = int ( sum / n ) + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ( ValueA < ValueB ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 1 , 3 , 7 ] NEW_LINE print ( valueofX ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE num = [ 0 ] * l NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT c = 0 NEW_LINE for j in range ( 0 , l , 2 ) : NEW_LINE INDENT if a [ j ] & 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == l : NEW_LINE INDENT num [ l ] += 1 NEW_LINE DEDENT DEDENT print ( sorted ( num ) [ 0 ] * 2 + sum ( num [ l - 1 : ] ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE t = len ( s ) NEW_LINE for i in range ( t // 2 ) : NEW_LINE INDENT if s [ i : i + 2 ] == s [ i + 1 : ] : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 0 , - 1 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr = curr + 9 NEW_LINE DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE
def findNth ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for x in range ( curr , 0 , - 1 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 1 ; NEW_LINE DEDENT DEDENT print ( findNth ( 5 ) ) ; NEW_LINE
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 ; NEW_LINE currSum = 0 ; NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N ; NEW_LINE N -= 1 ; NEW_LINE countElements += 1 ; NEW_LINE DEDENT return countElements ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE S = 11 ; NEW_LINE count = countNumber ( N , S ) ; NEW_LINE print ( count ) ; NEW_LINE DEDENT
def stringmatch ( string , pattern , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = True NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE DEDENT elif ( pattern [ j - 1 ] == ' ? ' or string [ i - 1 ] == pattern [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " baaabab " NEW_LINE pattern = " * * * * * ba * * * * * ab " NEW_LINE if ( stringmatch ( string , pattern , len ( string ) , len ( pattern ) ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE primes = [ 2 ] NEW_LINE def check ( num , k ) : NEW_LINE INDENT for i in primes : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT k = num // i NEW_LINE if k > MAX : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if check ( i , k ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT def prime_factorize ( n ) : NEW_LINE INDENT primes = [ ] NEW_LINE while n % 2 == 0 : NEW_LINE INDENT primes . append ( 2 ) NEW_LINE n //= 2 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT primes . append ( n ) NEW_LINE DEDENT return primes NEW_LINE DEDENT primes = prime_factorize ( MAX ) NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if check ( i , i ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a , b = a , b NEW_LINE ans = 1 NEW_LINE while a != 1 and b != 1 : NEW_LINE INDENT if a % b == 0 : NEW_LINE INDENT a = a // b NEW_LINE DEDENT else : NEW_LINE INDENT b = b // a NEW_LINE DEDENT ans = ans * ( a - b ) NEW_LINE DEDENT print ( " a " if ans == 1 else " b " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT fac = [ 1 for i in range ( 100 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n ] // ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = ( nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) ) NEW_LINE print ( ans ) NEW_LINE
import numpy as np NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE a = np . array ( a ) NEW_LINE a = np . sort ( a ) NEW_LINE ai = a [ - 1 ] NEW_LINE a = a [ : - 1 ] NEW_LINE aj = a [ np . argmin ( np . abs ( a - ai / 2 ) ) ] NEW_LINE print ( ai , aj ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 5 NEW_LINE n = 2 NEW_LINE print ( powGCD ( a , n , b ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def int1 ( x ) : NEW_LINE INDENT return int ( x ) - 1 NEW_LINE DEDENT def II ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def MI ( ) : NEW_LINE INDENT return map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT def LI ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE A = LI ( ) NEW_LINE dct = { } NEW_LINE for a in A : NEW_LINE INDENT if a in dct : NEW_LINE INDENT dct [ a ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dct [ a ] = 1 NEW_LINE DEDENT DEDENT for k , v in dct . items ( ) : NEW_LINE INDENT if v > 1 : NEW_LINE INDENT print ( ' ▁ ' . join ( [ str ( s ) for s in v ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE sn = input ( ) NEW_LINE tm = n // 11 NEW_LINE pt = tm * 11 NEW_LINE while tm < n : NEW_LINE INDENT pt += 1 NEW_LINE n = tm - pt NEW_LINE DEDENT print ( pt ) NEW_LINE
def sumOfDigit ( n , b ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 50 NEW_LINE b = 2 NEW_LINE print ( sumOfDigit ( n , b ) ) NEW_LINE
import math NEW_LINE def printLargestDivisible ( n , a ) : NEW_LINE INDENT c0 = 0 ; NEW_LINE c5 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 ; NEW_LINE DEDENT DEDENT c5 = int ( math . floor ( c5 / 9 ) * 9 ) ; NEW_LINE if ( c0 == 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT elif ( c5 == 0 ) : NEW_LINE INDENT print ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c5 ) : NEW_LINE INDENT print ( 5 , end = " " ) ; NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 0 , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE printLargestDivisible ( n , a ) ; NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
import math NEW_LINE def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 NEW_LINE Min = ( ( S - S1 ) // math . floor ( S ) ) * 60 NEW_LINE return Min NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = 30 NEW_LINE S1 = 10 NEW_LINE print ( numberOfMinutes ( S , S1 ) , " min " ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pre = a [ 0 ] ; d = [ 0 ] * n NEW_LINE for x in a [ 1 : ] : NEW_LINE INDENT d [ x ] = d [ x - 1 ] + 1 NEW_LINE DEDENT pre = a [ 0 ] ; d [ 0 ] = 0 NEW_LINE for x in a [ 1 : ] : NEW_LINE INDENT pre [ x ] = pre [ x - 1 ] + 1 NEW_LINE DEDENT print ( sum ( d ) ) NEW_LINE
import math NEW_LINE def onesComplement ( n ) : NEW_LINE INDENT number_of_bits = ( math . floor ( math . log ( n ) / math . log ( 2 ) ) ) + 1 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT n = 22 NEW_LINE print ( onesComplement ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE if a & ( 1 << b ) > 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , ( 2 * x2 - x1 ) , " , " , ( 2 * y2 - y1 ) , " ▁ ) " ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 0 , 1 , 1 NEW_LINE findPoint ( x1 , y1 , x2 , y2 ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT if i [ 0 ] % 2 == 0 : NEW_LINE INDENT x = ( i [ 1 ] - i [ 0 ] ) % 3 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = ( i [ 1 ] - i [ 0 ] ) % 3 + 1 NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE
def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = " , x , " , ▁ Y ▁ = " , y ) NEW_LINE DEDENT x = 12 NEW_LINE y = 5 NEW_LINE alter ( x , y ) NEW_LINE
import sys NEW_LINE from collections import Counter NEW_LINE n = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE c = Counter ( a ) NEW_LINE m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ a [ i ] ] += 1 NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , c [ a [ i ] ] ) NEW_LINE DEDENT print ( m ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 , - 1 ) NEW_LINE DEDENT DEDENT
mod = 1000000007 NEW_LINE inv2 = 500000004 NEW_LINE def modulo ( num ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + ord ( num [ i ] ) - ord ( '0' ) ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a = modulo ( L ) NEW_LINE b = modulo ( R ) NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod NEW_LINE ret = ( r % mod - l % mod ) NEW_LINE if ( ret < 0 ) : NEW_LINE INDENT ret = ret + mod NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret % mod NEW_LINE DEDENT return ret NEW_LINE DEDENT L = "88949273204" NEW_LINE R = "98429729474298592" NEW_LINE print ( findSum ( L , R ) ) NEW_LINE
def unsort ( l , r , a , k ) : NEW_LINE INDENT if ( k < 1 or l + 1 == r ) : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = int ( ( l + r ) / 2 ) NEW_LINE a [ mid - 1 ] , a [ mid ] = a [ mid ] , a [ mid - 1 ] NEW_LINE unsort ( l , mid , a , k ) NEW_LINE unsort ( mid , r , a , k ) NEW_LINE DEDENT def arrayWithKCalls ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( " NO ▁ SOLUTION " ) ; NEW_LINE return ; NEW_LINE DEDENT a = [ 0 ] * ( n + 1 ) ; NEW_LINE a [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = i + 1 ; NEW_LINE DEDENT k -= 1 NEW_LINE unsort ( 0 , n , a , k ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 ; NEW_LINE k = 17 ; NEW_LINE arrayWithKCalls ( n , k ) ; NEW_LINE DEDENT
import math NEW_LINE def mean ( mid , freq , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = Sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT return Sum / freqSum NEW_LINE DEDENT def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ 0 for i in range ( n ) ] NEW_LINE Sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE Sum = Sum + freq [ i ] * mid [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT sd = math . sqrt ( ( Sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT lower_limit = [ 50 , 61 , 71 , 86 , 96 ] NEW_LINE upper_limit = [ 60 , 70 , 85 , 95 , 100 ] NEW_LINE freq = [ 9 , 7 , 9 , 12 , 8 ] NEW_LINE n = len ( lower_limit ) NEW_LINE print ( groupedSD ( lower_limit , upper_limit , freq , n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a , b = 2 , 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE
def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT a , b = 10 , 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n < a : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT if n % a == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE continue NEW_LINE DEDENT if n > a * b : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT if n % a == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def getsum ( x ) : NEW_LINE INDENT return ( x * ( x + 1 ) ) / 2 NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( getsum ( ans ) < n or ( ( getsum ( ans ) - n ) & 1 ) > 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE DEDENT
MAX = 10 NEW_LINE def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT except numpy as np NEW_LINE return ans NEW_LINE DEDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE dp = np . zeros ( ( MAX , MAX ) ) ; NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = - 1 NEW_LINE print ( lcs ( dp , arr1 , n , arr2 , m , k ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE def solve ( ) : NEW_LINE INDENT n , d , x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT d -= i * ( 5 / i ) NEW_LINE x += d // ( 2 * i * ( n - 0.5 ) ) NEW_LINE ans += x NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT N = 25 NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) NEW_LINE DEDENT else : NEW_LINE INDENT reverseorder ( N ) NEW_LINE DEDENT
def pattern ( min_stars , p_height ) : NEW_LINE INDENT p_space = p_height - 1 NEW_LINE i , j , k , n , x = 1 , 1 , 0 , 0 NEW_LINE x = 1 NEW_LINE for i in range ( p_height ) : NEW_LINE INDENT for j in range ( p_space , i , - 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for n in range ( p_height + p_height - 2 ) : NEW_LINE INDENT if n >= x : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT min_stars = min_stars + 2 NEW_LINE x = x + 2 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT min_stars = 1 NEW_LINE p_height = 5 NEW_LINE pattern ( min_stars , p_height ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = input ( ) NEW_LINE if a [ 0 ] == " M " : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif a [ 0 ] == " F " : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT elif a [ 0 ] == " L " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT print ( max ( x , y ) ) NEW_LINE
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return round ( math . pow ( phi , n ) / math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def sumFibonacci ( k ) : NEW_LINE INDENT l = ( k * ( k - 1 ) ) / 2 NEW_LINE r = l + k NEW_LINE sum = calculateSum ( l , r - 1 ) NEW_LINE return sum NEW_LINE DEDENT k = 3 NEW_LINE print ( sumFibonacci ( k ) ) NEW_LINE
import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return round ( math . pow ( phi , n ) / math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE
import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return round ( math . pow ( phi , n ) / math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return round ( sum ) NEW_LINE DEDENT l , r = 4 , 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE
from sys import stdin NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = stdin . readline ( ) . rstrip ( ) NEW_LINE ans = " " NEW_LINE for _ in range ( q ) : NEW_LINE INDENT l , r , c , a = map ( str , input ( ) . split ( ) ) NEW_LINE tmp = l - 1 NEW_LINE while True : NEW_LINE INDENT if int ( tmp ) >= res : NEW_LINE INDENT ans += c NEW_LINE break NEW_LINE DEDENT tmp = r - l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if res == c : NEW_LINE INDENT ans += s [ tmp ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def searchStr ( arr , str , first , last ) : NEW_LINE INDENT if ( first > last ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + first ) // 2 NEW_LINE if ( arr [ mid ] . is_empty ( ) ) : NEW_LINE INDENT left = mid - 1 NEW_LINE right = mid + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( left < right and right > last ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( right <= last and not arr [ right ] . is_empty ( ) ) : NEW_LINE INDENT mid = right NEW_LINE break NEW_LINE DEDENT if ( left >= right and not arr [ left ] . is_empty ( ) ) : NEW_LINE INDENT mid = left NEW_LINE break NEW_LINE DEDENT right += 1 NEW_LINE left -= 1 NEW_LINE DEDENT DEDENT if ( compareStrings ( str , arr [ mid ] ) == 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( compareStrings ( str , arr [ mid ] ) < 0 ) : NEW_LINE INDENT return searchStr ( arr , str , mid + 1 , last ) NEW_LINE DEDENT return searchStr ( arr , str , first , mid - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " for " , " , " , " geeks " , " ide " , " " , " practice " , " " , " " , " quiz " , " " , " " ] NEW_LINE str = " quiz " NEW_LINE n = len ( arr ) NEW_LINE print ( searchStr ( arr , str , 0 , n - 1 ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + ( "0" * ( len ( str ( b ) + 1 ) ) ) + str ( int ( str ( b ) [ : : - 1 ] ) ) ) NEW_LINE
x1 , y1 = map ( int , input ( ) . split ( ) ) NEW_LINE x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 3 ) NEW_LINE print ( x1 + x2 , y1 + y2 ) NEW_LINE print ( x3 + x2 , y3 + y2 ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE c = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] not in c . keys ( ) : NEW_LINE INDENT c [ s [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT c [ s [ i ] ] += 1 NEW_LINE DEDENT DEDENT for i in c : NEW_LINE INDENT ans += str ( i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) ; NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 ; NEW_LINE return int ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) ; NEW_LINE DEDENT n = 20 ; NEW_LINE print ( sumMultiples ( n ) ) ; NEW_LINE
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if sum ( a [ i ] [ 1 : ] ) > sum ( a [ i ] [ 2 : ] ) : NEW_LINE INDENT print ( " OK " ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( sum ( a ) ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while t : NEW_LINE INDENT ans . append ( str ( solve ( ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT print ( " \n " . join ( ans ) ) NEW_LINE
def fact ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while ( num > 1 ) : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE i , k = 0 , 0 NEW_LINE while ( k < n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ k ] ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT ctreean_leftBST = catalan ( s ) NEW_LINE ctreean_rightBST = catalan ( n - s - 1 ) NEW_LINE totalBST = catalan_rightBST * catalan_leftBST NEW_LINE print ( totalBST , end = " ▁ " ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a - b ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) if a % 2 == b % 2 else print ( 1 ) NEW_LINE DEDENT DEDENT
def countWays ( n , arr ) : NEW_LINE INDENT count = [ 1 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in arr : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT no_ways = no_ways + count [ i - j ] NEW_LINE DEDENT DEDENT count [ i ] = no_ways NEW_LINE DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE
while 1 : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a == 0 : break NEW_LINE b = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * 12 ] NEW_LINE print ( " NA " if sum ( b ) >= a else [ i for i , j in enumerate ( b ) if sum ( b ) >= a ] [ 0 ] ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b == c : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT d = abs ( a - b ) NEW_LINE e = abs ( b - c ) NEW_LINE f = abs ( c - a ) NEW_LINE g = d - ( e - f ) NEW_LINE print ( max ( 0 , g , f ) ) NEW_LINE DEDENT DEDENT
n , b , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if j + l [ i ] <= b : NEW_LINE INDENT j += l [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT if j != 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT print ( s ) NEW_LINE
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE key = 10 NEW_LINE print ( " Index : " , binarySearch ( arr , 0 , n , key ) ) NEW_LINE
def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE used = set ( [ ] ) NEW_LINE used2 = set ( [ ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT used . add ( a [ i ] ) NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( m - 1 ) : NEW_LINE INDENT same = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE used . remove ( a [ i ] ) NEW_LINE if len ( same ) > 1 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 NEW_LINE cntOdd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 NEW_LINE DEDENT DEDENT evenPairs = 0 NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) NEW_LINE oddPairs = 0 NEW_LINE oddPairs += ( cntEven * cntOdd ) NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findPairs ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def minBroadcastRange ( houses , towers ) : NEW_LINE INDENT n , m = len ( houses ) , len ( towers ) NEW_LINE leftTower = - ( sys . maxsize - 1 ) ; NEW_LINE rightTower = towers [ 0 ] ; NEW_LINE j = 0 ; NEW_LINE min_range = 0 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( houses [ j ] < rightTower ) : NEW_LINE INDENT left = houses [ j ] - leftTower ; NEW_LINE right = rightTower - towers [ j ] ; NEW_LINE local_max = left if left < right else right NEW_LINE if ( local_max > min_range ) : NEW_LINE INDENT min_range = local_max ; NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT leftTower = towers [ k ] ; NEW_LINE if ( k < m - 1 ) : NEW_LINE INDENT k += 1 ; NEW_LINE rightTower = towers [ k ] ; NEW_LINE DEDENT else : NEW_LINE INDENT rightTower = sys . maxsize ; NEW_LINE DEDENT DEDENT DEDENT return min_range ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 12 , 13 , 11 , 80 ] ; NEW_LINE b = [ 4 , 6 , 15 , 60 ] ; NEW_LINE max = minBroadcastRange ( a , b ) ; NEW_LINE print ( max ) ; NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( getRemainder ( 100 , 7 ) ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( a , b + 1 , 1 ) : NEW_LINE INDENT if ( i * a ) % b == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def solve ( m , n , prices ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , m , n ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT t += prices [ j ] NEW_LINE if t > m : NEW_LINE INDENT break NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT ans = max ( ans , t ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 and n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT prices = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) NEW_LINE ans = solve ( m , n , prices ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import sys , math , heapq , copy , itertools , string , queue , copy , time NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE eps = 10 ** - 7 NEW_LINE def inp ( ) : return int ( input ( ) ) NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpl_str ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def calc ( x , c ) : NEW_LINE INDENT if c <= x : NEW_LINE INDENT return x / c NEW_LINE DEDENT else : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT DEDENT n , w = inpl ( ) NEW_LINE v = [ 0 ] * n NEW_LINE w = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i ] , w [ i ] = inpl ( ) NEW_LINE DEDENT v . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if w [ i ] <= w [ i ] : NEW_LINE INDENT ans += v [ i ] NEW_LINE w [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans += w [ i ] * w [ i ] NEW_LINE w [ i ] = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def getSingle ( arr , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE common_bit_mask = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " , getSingle ( arr , n ) ) NEW_LINE
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in freq . keys ( ) : NEW_LINE INDENT freq [ arr [ i ] ] = 0 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 1 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxdiff ( arr , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE min = float ( ' inf ' ) NEW_LINE for i in range ( n * m ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE min = min if min < arr [ i ] else arr [ i ] NEW_LINE ans += arr [ i ] NEW_LINE DEDENT DEDENT if min < arr [ n * m - 1 ] : NEW_LINE INDENT ans -= min NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def makeAP ( arr , n ) : NEW_LINE INDENT if n == 3 : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) // 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( initial_term + ( i * common_difference ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT count = [ 0 ] * 128 NEW_LINE for c in s : NEW_LINE INDENT count [ ord ( c ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v // 2 * 2 NEW_LINE if ans % 2 == 0 and v % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = ' abccccdd ' NEW_LINE out = sObj . longestPalindrome ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return catalan ( n // 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( " Total ▁ possible ▁ expressions ▁ of ▁ length " , n , " is " , findWays ( 6 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = list ( input ( ) ) NEW_LINE for j in range ( 1 , 6 ) : NEW_LINE INDENT if k [ j ] == ' O ' : NEW_LINE INDENT print ( k [ j - 1 ] , ' ▁ ' , k // j , sep = ' ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( k [ 0 ] , ' ▁ ' , k [ 1 ] , ' ▁ ' , sep = ' ' ) NEW_LINE DEDENT DEDENT
def check ( x ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for _ in range ( int ( x ** 0.5 ) ) : NEW_LINE INDENT if b > x * 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n , t , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ 0 ] * 10001 NEW_LINE if a > a : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT l [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT l [ j ] = 1 NEW_LINE DEDENT if check ( l [ i ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE if ( isSumOfPowersOfTwo ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE DEDENT
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 4 ] , [ 7 , 3 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE
MAX = 1000000 ; NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) ; NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) ; NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 ; NEW_LINE sieve_count [ i ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT form_sieve ( ) ; NEW_LINE n = 2 ; NEW_LINE print ( " Count ▁ = " , sieve_count [ n ] + 1 ) ; NEW_LINE n = 3 ; NEW_LINE print ( " Count ▁ = " , sieve_count [ n ] + 1 ) ; NEW_LINE DEDENT
import math NEW_LINE n , k , t , u , v , l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE for x in a : NEW_LINE INDENT if i + t <= l : NEW_LINE INDENT ans += v * x // u NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( l - i - 1 ) // v * v NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 for i in range ( n ) ] NEW_LINE suffix = [ 0 for i in range ( n ) ] NEW_LINE seen = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = 0 NEW_LINE if ( i - 1 >= 0 ) : NEW_LINE INDENT prev = prefix [ i - 1 ] NEW_LINE DEDENT if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT seen [ i ] = 0 NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababa " NEW_LINE print ( int ( waysToSplit ( s ) ) ) NEW_LINE DEDENT
import math NEW_LINE def compute ( ) : NEW_LINE INDENT TURNS = 15 NEW_LINE ways = [ [ 1 ] for i in range ( TURNS + 1 ) ] NEW_LINE for i in range ( 1 , TURNS + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j < i : NEW_LINE INDENT ways [ i ] [ j ] *= i NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT ways [ i ] [ j ] += ways [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT ways [ i ] [ j ] = ways [ i ] [ j ] + ways [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT numer = 0 NEW_LINE for i in range ( TURNS // 2 + 1 , TURNS + 1 ) : NEW_LINE INDENT numer += ways [ i ] [ i ] NEW_LINE DEDENT denom = math . factorial ( TURNS + 1 ) // numer NEW_LINE return str ( numer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ai , bi = 0 , 0 NEW_LINE stride = 0 NEW_LINE while ai < n and bi < n : NEW_LINE INDENT ax , bx = a [ ai ] , b [ bi ] NEW_LINE if ax == bx : NEW_LINE INDENT cnt = 2 NEW_LINE ai += 1 NEW_LINE while ai < n and a [ ai ] == 1 : NEW_LINE INDENT ai += 1 NEW_LINE DEDENT bi_copy = bi NEW_LINE bi += 1 NEW_LINE while bi < n and b [ bi ] == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE bi += 1 NEW_LINE DEDENT if cnt > stride : NEW_LINE INDENT stride = cnt NEW_LINE DEDENT DEDENT print ( stride , end = " ▁ " ) NEW_LINE print ( bi ) NEW_LINE DEDENT main ( ) NEW_LINE
def merge ( arr1 , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = arr1 [ m - 1 ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr1 [ j ] > arr2 [ i ] ) : NEW_LINE INDENT arr1 [ j + 1 ] = arr1 [ j ] NEW_LINE DEDENT if ( j != m - 2 or last > arr2 [ i ] ) : NEW_LINE INDENT arr1 [ j + 1 ] = arr2 [ i ] NEW_LINE arr2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT DEDENT arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE arr2 = [ 2 , 3 , 8 , 13 ] NEW_LINE def merge ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( len ( arr1 ) ) : NEW_LINE INDENT j = m - 2 NEW_LINE last = arr1 [ i ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr1 [ j ] > arr2 [ i ] ) : NEW_LINE INDENT arr1 [ j + 1 ] = arr2 [ i ] NEW_LINE arr2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " , end = " " ) NEW_LINE print ( arr1 ) NEW_LINE print ( " Second ▁ Array : ▁ " , end = " " ) NEW_LINE print ( arr2 ) NEW_LINE DEDENT arr1 = merge ( arr1 , arr2 ) NEW_LINE print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " , end = " " ) NEW_LINE print ( arr1 ) NEW_LINE print ( " Second ▁ Array : ▁ " , end = " " ) NEW_LINE print ( arr2 ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 237 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c = sorted ( [ a , b , c ] ) NEW_LINE print ( d - a + b if d - a + b > 0 else 0 ) NEW_LINE
dp = [ [ [ - 1 for i in range ( 5 ) ] for j in range ( 5001 ) ] for k in range ( 5001 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 5001 ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( ( a + b ) // 2 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = 2 NEW_LINE b = 16 NEW_LINE print ( find_k ( a , b ) ) NEW_LINE
N = 101 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE  exactnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT  exactsum [ i ] [ j ] [ k ] += ( exactnum [ i - 1 ] [ j ] [ k ] ) % mod NEW_LINE  exactnum [ i ] [ j ] [ k ] +=  exactnum [ i - 1 ] [ j ] [ k ] % mod NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT  exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] ) % mod NEW_LINE  exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT  exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod NEW_LINE  exactnum [ i ] [ j ] [ k ] +=  exactnum [ i ] [ j ] [ k - 1 ] % mod NEW_LINE DEDENT ans += exactnum [ i ] [ j ] [ k ] % mod NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , z = 1 , 1 , 1 NEW_LINE print ( getSum ( x , y , z ) % mod ) NEW_LINE DEDENT
CHARS = 26 ; NEW_LINE def isValidString ( string ) : NEW_LINE INDENT freq = [ 0 ] * CHARS ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT i = 0 ; NEW_LINE freq1 = 0 ; NEW_LINE count_freq1 = 0 ; NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 = freq [ i ] ; NEW_LINE count_freq1 = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT j = 0 ; NEW_LINE freq2 = 0 ; NEW_LINE count_freq2 = 0 ; NEW_LINE for i in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 ; NEW_LINE freq2 = freq [ j ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 ; NEW_LINE DEDENT if ( freq [ k ] == freq2 ) : NEW_LINE INDENT count_freq2 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abcbc " ; NEW_LINE if ( isValidString ( string ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT b = input ( ) NEW_LINE print ( b [ : : 2 ] + ' a ' + b [ - 1 ] . lower ( ) ) NEW_LINE DEDENT
def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE dSizeB = len ( B ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ inf for i in range ( sizeOfB ) ] for i in range ( 26 ) ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB ) : NEW_LINE INDENT next [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT next [ B [ i ] - ord ( ' a ' ) ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( next [ i ] [ j ] == inf ) : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while ( i < sizeOfA ) : NEW_LINE INDENT if ( pos == 0 and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] == inf ) : NEW_LINE INDENT numberOfSubsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif ( pos < sizeOfB and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] < inf ) : NEW_LINE INDENT numIndex = next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] + 1 NEW_LINE pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = " aacbe " NEW_LINE B = " aceab " NEW_LINE print ( findMinimumSubsequences ( A , B ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT c = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT if c < 0 : NEW_LINE INDENT a [ i ] = c NEW_LINE DEDENT DEDENT a [ i + 1 ] = c NEW_LINE DEDENT for j in range ( m - 1 ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if a [ j ] < c : NEW_LINE INDENT b [ k ] = abs ( a [ j ] - c ) NEW_LINE DEDENT else : NEW_LINE INDENT b [ k ] = max ( b [ k ] , abs ( a [ j ] - c ) + abs ( b [ k ] - d ) ) NEW_LINE DEDENT DEDENT DEDENT print ( * b ) NEW_LINE DEDENT DEDENT
def FindRank ( arr , length ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 88 , 14 , 69 , 30 , 29 , 89 ] NEW_LINE length = len ( arr ) NEW_LINE FindRank ( arr , length ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE from bisect import bisect_right as br NEW_LINE from bisect import bisect_left as bl NEW_LINE sys . setrecursionlimit ( 1000000 ) NEW_LINE from heapq import heappush , heappop , heappushpop NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from operator import itemgetter NEW_LINE from itertools import permutations NEW_LINE from itertools import product NEW_LINE mod = 10 ** 9 + 7 NEW_LINE inf = float ( ' inf ' ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE n , h = LI ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = LI ( ) NEW_LINE a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE ans = inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] > h : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , bisect_right ( a , b [ i ] [ 0 ] ) + ( h - a [ i ] [ 1 ] ) // a [ i ] [ 0 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( int ( product / pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = int ( product / 10 ) NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE
import sys NEW_LINE for line in sys . stdin . readlines ( ) : NEW_LINE INDENT a , b = map ( int , line . split ( ) ) NEW_LINE ans = 1 NEW_LINE while True : NEW_LINE INDENT if b == 1 : NEW_LINE INDENT break NEW_LINE DEDENT ans = a * b NEW_LINE a , b = b , a NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
s = input ( ) NEW_LINE s_list = [ s [ _ ] for _ in range ( 10 ) ] NEW_LINE dic = dict ( ) NEW_LINE for c in s_list : NEW_LINE INDENT if c in dic : NEW_LINE INDENT dic [ c ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dic [ c ] = 1 NEW_LINE DEDENT DEDENT dic = dict ( ) NEW_LINE sum_value = 0 NEW_LINE for key in dic : NEW_LINE INDENT if dic [ key ] % 2 != 0 : NEW_LINE INDENT sum_value += dic [ key ] // 2 NEW_LINE DEDENT DEDENT print ( sum_value ) NEW_LINE
def complement ( num ) : NEW_LINE INDENT len = 0 NEW_LINE temp = num NEW_LINE while True : NEW_LINE INDENT len += 1 NEW_LINE num = num // 10 NEW_LINE if abs ( num ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT num = temp NEW_LINE comp = int ( pow ( 10 , len ) ) - num NEW_LINE return comp NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( complement ( 25 ) ) NEW_LINE print ( complement ( 456 ) ) NEW_LINE DEDENT
def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return bin ( x ^ n ) . count ( '1' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] , dp [ 1 ] [ 1 ] = 0 , M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] , dp [ 1 ] [ 1 ] = 1 , M - 2 NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] , dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , c = 2 , 4 , 4 NEW_LINE print ( getMinNum ( a , b , c ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE st = input ( ) NEW_LINE index_dict = { } NEW_LINE count = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if st [ i ] == ' I ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif st [ i ] == ' D ' : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if st [ i ] == ' I ' : NEW_LINE INDENT if count > cnt : NEW_LINE INDENT cnt = count NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * n ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , p = a [ i ] NEW_LINE b . append ( ( d , p ) ) NEW_LINE DEDENT b . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] [ 0 ] < m : NEW_LINE INDENT count += b [ i ] [ 1 ] * b [ i ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT count += b [ i ] [ 1 ] * b [ i ] [ 0 ] NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
import sys NEW_LINE import heapq NEW_LINE def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE heapq . heapify ( a ) NEW_LINE heapq . heapify ( b ) NEW_LINE seats = 0 NEW_LINE total1 = 0 NEW_LINE total2 = 0 NEW_LINE while seats < n : NEW_LINE INDENT total1 += a [ seats ] NEW_LINE seats += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT t1 = heapq . heappop ( a ) NEW_LINE t2 = heapq . heappush ( a , a [ i ] ) NEW_LINE num1 = t1 + t2 NEW_LINE total1 += t1 - t2 NEW_LINE t2 = heapq . heappop ( b ) NEW_LINE total2 += t2 - t1 NEW_LINE if total1 > total2 : NEW_LINE INDENT print ( total2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
arr = [ 1 , 5 , 6 ] NEW_LINE def countWays ( N ) : NEW_LINE INDENT count = [ 0 for i in range ( N + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 NEW_LINE print ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " , countWays ( N ) ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def countFreq ( a , n ) : NEW_LINE INDENT hm = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] != 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE DEDENT
def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE if ( L % 2 > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( not ( L % 2 > 0 ) ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( " ( " , possibleA , " , " , possibleB , " , " , possibleC , " ) ▁ is ▁ one ▁ such " , " possible ▁ triplet ▁ between " , L , " and " , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Such ▁ Triplet ▁ exists ▁ between " , L , " and " , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE
alphabets = " abcdefghijklmnopqrstuvwxyz " ; NEW_LINE def conversion ( charSet , str1 ) : NEW_LINE INDENT s2 = " " ; NEW_LINE for i in str1 : NEW_LINE INDENT s2 += alphabets [ charSet . find ( i ) ] ; NEW_LINE DEDENT return s2 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT charSet = " qwertyuiopasdfghjklzxcvbnm " ; NEW_LINE str1 = " egrt " ; NEW_LINE print ( conversion ( charSet , str1 ) ) ; NEW_LINE DEDENT
def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if count == k : NEW_LINE INDENT set . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( " The " , len ( set ) , " distinct ▁ integers ▁ are : ▁ " , end = " " ) NEW_LINE print ( * set ) NEW_LINE i = [ ] NEW_LINE while i : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE i . append ( 0 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 8 , 17 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE printDistinctIntegers ( k , arr , n ) NEW_LINE DEDENT
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT b = str ( r ) NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = b NEW_LINE curr [ i ] = ( ( ( curr [ i ] - ord ( '0' ) ) - 1 ) + ( ord ( '0' ) ) ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ j ] = '9' NEW_LINE DEDENT num = 0 NEW_LINE for j in range ( len ( curr ) ) : NEW_LINE INDENT num = num * 10 + ( ord ( curr [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( num >= l and product ( ans ) < product ( num ) ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE l = 51 NEW_LINE r = 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE isPrime = [ True for i in range ( MAX ) ] NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( MAX ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] == False ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime [ num ] == False ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( isPrime [ sum ] == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT
MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) NEW_LINE if ( bits_count [ d ] > n // 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if s . count ( ' . ' ) + s . count ( ' ! ' ) + s . count ( ' ? ' ) > n : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT q = 0 NEW_LINE index = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == ' . ' or i == ' ! ' or i == ' ? ' : NEW_LINE INDENT q += 1 NEW_LINE DEDENT else : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if index == n : NEW_LINE INDENT print ( q ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT index += 1 NEW_LINE DEDENT DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE from pprint import pprint as pp NEW_LINE from pprint import pformat as pf NEW_LINE import math NEW_LINE import bisect NEW_LINE class Solver : NEW_LINE INDENT def __init__ ( self , n , a_s ) : NEW_LINE INDENT self . n = n NEW_LINE self . a_s = a_s NEW_LINE self . extra = 1 if self . n % 2 == 0 else 2 NEW_LINE self . dp = self . prepare_dp ( ) NEW_LINE DEDENT def prepare_dp ( self ) : NEW_LINE INDENT dp = [ None ] * ( self . n + 1 ) NEW_LINE for i , _ in enumerate ( dp ) : NEW_LINE INDENT dp [ i ] = [ - 1 ] * ( 1 + self . extra ) NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE return dp NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT extra = 1 + self . n % self . n NEW_LINE for i , v in enumerate ( self . a_s ) : NEW_LINE INDENT for j in self . dp [ i ] : NEW_LINE INDENT if v == extra : NEW_LINE INDENT continue NEW_LINE DEDENT if dp [ i + 1 ] [ j ] == - 1 : NEW_LINE INDENT dp [ i + 1 ] [ j ] = i + 1 NEW_LINE extra += 1 NEW_LINE DEDENT DEDENT DEDENT return self . dp [ n ] [ extra ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a_s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = Solver ( n , a_s ) . run ( ) NEW_LINE print ( ans [ 0 ] , ' ▁ ' . join ( [ str ( i ) for i in ans ] ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += max ( b [ i ] - 1 , m [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE
S = list ( input ( ) ) NEW_LINE Q = int ( input ( ) ) NEW_LINE r_count = 0 NEW_LINE for i in range ( Q ) : NEW_LINE INDENT command , * args = input ( ) . split ( ) NEW_LINE if command == " delete " : NEW_LINE INDENT R = int ( args [ 1 ] ) NEW_LINE pos = int ( args [ 2 ] ) NEW_LINE if R > pos : NEW_LINE INDENT R -= pos NEW_LINE pos = R NEW_LINE DEDENT ans = " " NEW_LINE if command == " insert " : NEW_LINE INDENT R = R NEW_LINE if R < pos : NEW_LINE INDENT ans += S [ pos ] NEW_LINE DEDENT DEDENT elif command == " delete " : NEW_LINE INDENT R = R NEW_LINE if R > pos : NEW_LINE INDENT ans += S [ R - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans += S [ pos ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import numpy as np NEW_LINE import sys NEW_LINE def solve ( A , n ) : NEW_LINE INDENT dp = np . zeros ( ( 2000 , 2000 ) ) ; NEW_LINE flag = 1 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] ; NEW_LINE DEDENT for i in range ( - sum , sum + 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ 0 ] [ i ] = sys . maxsize ; NEW_LINE DEDENT except Exception : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 ; NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ flag ] [ j ] = sys . maxsize ; NEW_LINE if ( j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= - sum ) : NEW_LINE INDENT dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] ; NEW_LINE DEDENT if ( j + A [ i - 1 ] <= sum and j + A [ i - 1 ] >= - sum and dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != sys . maxsize ) : NEW_LINE INDENT dp [ flag ] [ j ] = min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) ; NEW_LINE DEDENT DEDENT except Exception : NEW_LINE INDENT pass ; NEW_LINE DEDENT DEDENT flag = flag ^ 1 ; NEW_LINE DEDENT for i in range ( sum + 1 ) : NEW_LINE INDENT if ( dp [ flag ^ 1 ] [ i ] != sys . maxsize ) : NEW_LINE INDENT return dp [ flag ^ 1 ] [ i ] ; NEW_LINE DEDENT DEDENT return n - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( solve ( arr , n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT e = list ( map ( int , e . split ( ) ) ) NEW_LINE print ( [ ' YES ' , ' NO ' ] [ sum ( ( e [ i ] - e [ ( 2 + i ) % 8 ] ) * ( e [ ( 5 + i ) % 8 ] - e [ ( 3 + i ) % 8 ] ) - ( e [ 1 + i ] - e [ ( 3 + i ) % 8 ] ) * ( e [ ( 4 + i ) % 8 ] - e [ ( 2 + i ) % 8 ] ) > 0 for i in range ( 0 , 8 , 2 ) ) % ( 10 ** 9 + 7 ) > 0 ] ) NEW_LINE DEDENT
def count_div ( start , end , div ) : NEW_LINE INDENT return ( end - 1 ) // div - ( start - 1 ) // div NEW_LINE DEDENT def calc_start ( mid ) : NEW_LINE INDENT cnt , i = 0 , 1 NEW_LINE while i < mid : NEW_LINE INDENT d , p = input ( ) . split ( ) NEW_LINE fif , three , five = count_div ( d , int ( p ) , int ( p ) ) , count_div ( d , int ( p ) ) NEW_LINE num = i NEW_LINE del d [ 0 ] NEW_LINE if num == 0 : NEW_LINE INDENT return start NEW_LINE DEDENT i = 1 NEW_LINE while True : NEW_LINE INDENT if num % 15 == 0 : NEW_LINE INDENT c = calc_start ( i , end , div ) NEW_LINE if c : NEW_LINE INDENT start = c NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT cnt += 1 NEW_LINE DEDENT return start NEW_LINE DEDENT while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = calc_start ( m ) NEW_LINE print ( ' ▁ ' . join ( [ str ( i ) for i in ans ] ) ) NEW_LINE DEDENT
l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( min ( a , b ) == min ( c , d ) and a + b + c == d ) * ( 1 ) or ( ( a + b ) == min ( c , d ) and c + d + 1 == a ) * ( 2 ) or ( a + b > min ( b , c , d ) and d + c > a ) * ( 3 ) ) NEW_LINE
import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT x = math . floor ( a [ i ] / mul ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = a [ n - 1 ] NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT ans = b [ i ] NEW_LINE if a [ i ] != b [ i + 1 ] : NEW_LINE INDENT ans = c [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n and s [ i ] == ' < ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT ans = i NEW_LINE i = n - 1 NEW_LINE while i >= 0 and s [ i ] == ' > ' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE n += 1 NEW_LINE while 1 : NEW_LINE INDENT n //= 2 NEW_LINE ans += 1 NEW_LINE if n == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE p , d = map ( int , input ( ) . split ( ) ) NEW_LINE t , f , c = map ( int , input ( ) . split ( ) ) NEW_LINE x = 0 NEW_LINE for i in range ( 16 ) : NEW_LINE INDENT if ( i * p + d * t ) / ( 2 * v ) >= c : NEW_LINE INDENT x = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE hh , mm = map ( int , input ( ) . split ( " : " ) ) NEW_LINE hh %= 24 NEW_LINE mm %= mm NEW_LINE print ( format ( hh , mm ) , " : " , end = " " ) NEW_LINE print ( format ( hh , mm ) , sep = " " ) NEW_LINE
def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] * a [ i - 1 ] < 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestAlternatingSubarray ( a , n ) ) NEW_LINE DEDENT
def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( " Right - angled ▁ Triangle " ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( " Obtuse - angled ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled ▁ Triangle " ) NEW_LINE DEDENT DEDENT a , b , c = 2 , 2 , 2 NEW_LINE checkTypeOfTriangle ( a , b , c ) NEW_LINE
max = 100 ; NEW_LINE def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 ; cntF = 0 ; result = 0 ; C = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 ; NEW_LINE result += C ; NEW_LINE DEDENT elif ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 ; NEW_LINE C += cntG ; NEW_LINE DEDENT else : NEW_LINE INDENT continue ; NEW_LINE DEDENT DEDENT print ( result ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GFGFG " ; NEW_LINE n = len ( s ) ; NEW_LINE countSubsequence ( s , n ) ; NEW_LINE DEDENT
import sys NEW_LINE from operator import itemgetter NEW_LINE import itertools NEW_LINE from collections import deque NEW_LINE import copy NEW_LINE import heapq NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE INF = float ( ' inf ' ) NEW_LINE input = lambda : sys . stdin . readline ( ) . strip ( ) NEW_LINE NI = lambda : int ( input ( ) ) NEW_LINE NMI = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE SI = lambda : input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = NI ( ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y , h = NMI ( ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , d = MI ( ) NEW_LINE a . append ( ( c , d ) ) NEW_LINE DEDENT a . sort ( key = itemgetter ( 0 ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] + a [ i ] [ 1 ] : NEW_LINE INDENT print ( a [ i ] [ 1 ] , a [ i ] [ 0 ] + a [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from math import pow NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( pow ( n , 1.0 / 3.0 ) ) ; NEW_LINE n -= ( largest * largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 150 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE def solve ( cards ) : NEW_LINE INDENT for i in range ( 0 , 8 ) : NEW_LINE INDENT for j in range ( 0 , 8 ) : NEW_LINE INDENT if cards [ i ] [ 0 ] == cards [ j ] [ 0 ] : NEW_LINE INDENT return ( cards [ i ] [ 0 ] , cards [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 8 ) : NEW_LINE INDENT for j in range ( 0 , 8 ) : NEW_LINE INDENT if cards [ i ] [ 1 ] == cards [ j ] [ 1 ] : NEW_LINE INDENT return ( cards [ i ] [ 0 ] , cards [ i ] [ 2 ] ) NEW_LINE DEDENT DEDENT DEDENT return ( cards , [ 0 ] ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE cards = [ ] NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT cards . append ( list ( map ( float , input ( ) . split ( ' ▁ ' ) ) ) ) NEW_LINE DEDENT result = solve ( cards ) NEW_LINE print ( ' { } ▁ { } ' . format ( result [ 0 ] , result [ 1 ] ) ) NEW_LINE print ( ' { } ▁ { } ' . format ( result [ 2 ] , result [ 3 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx , c = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx == a [ i ] : mx += 1 NEW_LINE else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( mx - mx , c * ( c - 1 ) // 2 ) NEW_LINE
def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE DEDENT
from math import ceil NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( " YES " if ceil ( sum ( a ) / ( n * ( n + 1 ) ) ) % n == 0 else " NO " ) NEW_LINE
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE x = list ( map ( str , input ( ) ) ) NEW_LINE k = 1 NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( len ( x [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT p = min ( l ) NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT q = l [ i ] * p - l [ j ] NEW_LINE if q > p : NEW_LINE INDENT p = q NEW_LINE DEDENT DEDENT DEDENT print ( p ) NEW_LINE
import math NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x . append ( b [ 0 ] * b [ 1 ] + b [ 1 ] * b [ 0 ] ) NEW_LINE y . append ( b [ 1 ] * b [ 0 ] ) NEW_LINE DEDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE print ( math . sqrt ( x [ n - 1 ] ** 2 + y [ n - 1 ] ** 2 ) ) NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE DEDENT
def reduceString ( s , l ) : NEW_LINE INDENT count = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( count // 2 ) NEW_LINE count = 1 NEW_LINE DEDENT DEDENT steps += count // 2 NEW_LINE return steps NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE l = len ( s ) NEW_LINE print ( reduceString ( s , l ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE return NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif i == b - 1 : NEW_LINE INDENT print ( " ! " , c , " Y " ) NEW_LINE return NEW_LINE DEDENT DEDENT x = ( a - b ) // 2 NEW_LINE y = ( b - 1 ) // 2 NEW_LINE push_cnt = 0 NEW_LINE if x == y : NEW_LINE INDENT push_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT push_cnt = 0 NEW_LINE for j in range ( x + 1 ) : NEW_LINE INDENT if ( c [ j ] == " ? " ) : NEW_LINE INDENT push_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT push_cnt -= 1 NEW_LINE DEDENT DEDENT if push_cnt >= y : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT DEDENT print ( f " ? ▁ { y } ▁ { push_cnt } " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n , m , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n , m ) ) NEW_LINE for i in range ( a , n + 1 ) : NEW_LINE INDENT for j in range ( b , m + 1 ) : NEW_LINE INDENT if i <= j : NEW_LINE INDENT print ( i , j ) NEW_LINE DEDENT DEDENT DEDENT
mod = 1000000007 NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( pow ( n , 1 / 2 ) ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans , ( 2 ) ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 193748576239475639 NEW_LINE mod = 17 NEW_LINE print ( calculate_factors ( n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE if s [ 0 ] == ' - ' : s = s [ 1 : ] NEW_LINE if ' . ' in s : NEW_LINE INDENT print ( s . replace ( ' . ' , ' - ' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE if input is None or input . strip ( ) == '0' : NEW_LINE INDENT break NEW_LINE DEDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for _ in [ 0 ] * int ( input ( ) ) : NEW_LINE INDENT f , * g = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE c -= 1 NEW_LINE if a == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif f == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if g [ i ] == 1 : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT elif g [ i ] == 2 : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT elif g [ i ] == 3 : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in countA . keys ( ) : NEW_LINE INDENT countA [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countA [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] in countB . keys ( ) : NEW_LINE INDENT countB [ b [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countB [ b [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE s = list ( countA ) NEW_LINE for x in s : NEW_LINE INDENT if x in countB . keys ( ) : NEW_LINE INDENT res += countB [ x ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE b = [ 2 , 3 , 4 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( minRemove ( a , b , n , m ) ) NEW_LINE
def count ( pos , firstD , lastD , tight , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT if ( firstD == lastD ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ firstD ] [ lastD ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ firstD ] [ lastD ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if ( tight == 1 ) else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currFirst = firstD NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT currFirst = dig NEW_LINE DEDENT if ( currFirst == 0 and dig != 0 ) : NEW_LINE INDENT currFirst = dig NEW_LINE DEDENT currTight = tight NEW_LINE if ( dig < num [ pos ] ) : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += count ( pos + 1 , currFirst , dig , currTight , num ) NEW_LINE DEDENT dp [ pos ] [ firstD ] [ lastD ] [ tight ] = ans NEW_LINE return dp [ pos ] [ firstD ] [ lastD ] [ tight ] NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT global dp NEW_LINE num = [ ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ - 1 for i in range ( M ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 60 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE L = 1 NEW_LINE R = 1000 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 1 NEW_LINE if a [ 0 ] == 1 : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans *= ( i - a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans *= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT x = x // 2 ; NEW_LINE ans += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if ( bit ( x // d ) <= bit ( d ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 ; r = int ( math . sqrt ( n ) ) ; NEW_LINE while ( l < r ) : NEW_LINE INDENT m = ( l + r ) // 2 ; NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT if ( check ( l , n ) == False ) : NEW_LINE INDENT return l + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return l ; NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countDivisor ( n ) ) ; NEW_LINE
import sys NEW_LINE def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ sys . maxsize ] * n NEW_LINE s1 , s2 = " " , " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if s1 == s2 : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaaaaa " NEW_LINE n = len ( s ) NEW_LINE print ( minimalSteps ( s , n ) // 2 ) NEW_LINE DEDENT
def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num // base , dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 32 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = list ( map ( int , s . split ( " A " ) ) ) NEW_LINE s = input ( ) NEW_LINE m = max ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " B " : NEW_LINE INDENT m += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m -= a [ i ] NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 = [ float ( x ) for x in input ( ) . split ( ) ] NEW_LINE x3 = x1 - x2 NEW_LINE y3 = y1 - y2 NEW_LINE x4 = y3 - y4 NEW_LINE if ( x3 * x1 + y3 * y1 ) / ( x3 - x4 ) == 0 or ( y3 * y1 + y3 * x2 ) / ( x3 - x4 ) == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( a ^ b ) NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT a , b , n = 1 , 2 , 10 NEW_LINE print ( nthXorFib ( n , a , b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if a > b : NEW_LINE INDENT a += 3 NEW_LINE DEDENT elif a < b : NEW_LINE INDENT b += 3 NEW_LINE DEDENT DEDENT print ( b , a ) NEW_LINE
import math as mt NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = ( sternBrocotCount ( 1 , 3 , 1 , 2 ) + sternBrocotCount ( n , d , rightN , rightD ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def sternBrocotCount ( leftN , leftD , rightN , rightD ) : NEW_LINE INDENT n = leftN + rightN NEW_LINE d = leftD + rightD NEW_LINE if d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 + sternBrocotCount ( leftN , leftD , n , d ) + sternBrocotCount ( n , d , rightN , rightD ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** ( n // 2 ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT i = int ( pow ( 10 , d ) ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE
from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = pow ( 2 , d ) - 1 NEW_LINE prime = [ True ] * ( maxVal + 1 ) NEW_LINE sieve ( prime , maxVal ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = 8 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( k > 0 and i < n ) : NEW_LINE INDENT if ( a [ i ] + a [ i + 1 ] ) / ( j + 1 ) >= k : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( j ) NEW_LINE DEDENT
import datetime NEW_LINE import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT days = line . strip ( ) . split ( ' ▁ ' ) NEW_LINE days = list ( map ( int , days ) ) NEW_LINE da = datetime . datetime ( 2016 , 7 , 11 , days [ 0 ] , days [ 1 ] , days [ 2 ] ) NEW_LINE db = datetime . datetime ( 2016 , 7 , 11 , days [ 3 ] , days [ 4 ] , days [ 5 ] ) NEW_LINE delta = str ( db - da ) . split ( ' , ▁ ' ) NEW_LINE if delta [ 0 ] in dayNumbers : NEW_LINE INDENT print ( delta [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( delta [ 1 ] ) NEW_LINE DEDENT DEDENT
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE max_so_far = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) ; NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxPartitions ( arr , n ) ) ; NEW_LINE DEDENT
def countMaxContiguous ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 4 , 3 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countMaxContiguous ( arr , n ) ) NEW_LINE
from math import sqrt NEW_LINE def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ) ; NEW_LINE return a ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT h , r = 5 , 6 ; NEW_LINE print ( " { 0 : . 6 } " . format ( cube ( h , r ) ) ) ; NEW_LINE DEDENT
def pattern ( rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( rows_no - 1 , 0 , - 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows_no = 7 NEW_LINE pattern ( rows_no ) NEW_LINE
n = input ( ) NEW_LINE if n [ 0 ] == "0" : NEW_LINE INDENT print ( "10" ) NEW_LINE DEDENT elif n [ 0 ] == "1" : NEW_LINE INDENT print ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT k = n [ 0 ] NEW_LINE s = sum ( n [ 1 : : ] ) NEW_LINE print ( k * ( 10 ** ( len ( k ) - 1 ) ) ) NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2397 ; NEW_LINE print ( smallest_number ( N ) ) ; NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT N = 2397 ; NEW_LINE print ( smallest_number ( N ) ) ; NEW_LINE
def triangular_series ( n ) : NEW_LINE INDENT j = 1 ; NEW_LINE k = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = " ▁ " ) ; NEW_LINE j = j + 1 ; NEW_LINE k = k + j ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE triangular_series ( n ) ; NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( m - max ( a ) * ( n - a . count ( x ) ) // 2 ) NEW_LINE
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 ; NEW_LINE f2 = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( " Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in ▁ Fibonacci ▁ Series ▁ is " , findPosition ( k , n ) ) ; NEW_LINE
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE t = ' ' NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == t : NEW_LINE INDENT flag = 1 NEW_LINE t = ' ' NEW_LINE DEDENT t += s [ i ] NEW_LINE DEDENT if flag == 0 and n != 1 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT elif flag == 1 and n != 2 : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT
def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( countMinimumMoves ( arr , n , K ) ) NEW_LINE DEDENT
def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT def printPower ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT a , b , n = 5 , 4 , 2 NEW_LINE print ( powerGCD ( a , b , n ) ) NEW_LINE
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 998244353 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE while True : NEW_LINE INDENT n , t , q = LI ( ) NEW_LINE t = t * q NEW_LINE r = 0 NEW_LINE while t <= n : NEW_LINE INDENT r += 1 NEW_LINE t = t * q NEW_LINE DEDENT rr . append ( r ) NEW_LINE break NEW_LINE DEDENT return ' \n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( n * ( n - 2 ) ) NEW_LINE
def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT hs = dict ( ) NEW_LINE for j in range ( len ( mat [ i ] ) ) : NEW_LINE INDENT hs [ mat [ i ] [ j ] ] = 1 NEW_LINE DEDENT if ( len ( hs ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] NEW_LINE print ( countIdenticalRows ( mat ) ) NEW_LINE DEDENT
def createSorted ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( b == [ ] ) : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start = 0 NEW_LINE end = len ( b ) - 1 NEW_LINE pos = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = int ( start + ( end - start ) / 2 ) NEW_LINE if ( b [ mid ] == a [ j ] ) : NEW_LINE INDENT b . append ( ( max ( 0 , mid + 1 ) ) , a [ j ] ) NEW_LINE break NEW_LINE DEDENT elif ( b [ mid ] > a [ j ] ) : NEW_LINE INDENT pos = end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = start = mid + 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT pos = start NEW_LINE b . append ( max ( 0 , pos ) , a [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 2 , 5 , 4 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE
def countTotalDistinct ( string ) : NEW_LINE INDENT cnt = 0 NEW_LINE items = dict ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " ABCA " NEW_LINE ans = dict ( ) NEW_LINE for j in range ( i , len ( string ) ) : NEW_LINE INDENT temp = temp + string [ j ] NEW_LINE ans [ string [ j ] ] = 1 NEW_LINE if temp not in items : NEW_LINE INDENT items [ temp ] = 1 NEW_LINE cnt += len ( ans ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ABCA " NEW_LINE print ( countTotalDistinct ( string ) ) NEW_LINE DEDENT
import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = math . log10 ( n ) NEW_LINE n = n // ( math . pow ( 10 , digits ) ) NEW_LINE return n NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 NEW_LINE print ( firstDigit ( n ) , end = " ▁ " ) NEW_LINE print ( lastDigit ( n ) ) NEW_LINE
def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) NEW_LINE return NEW_LINE DEDENT b = [ 0 for i in range ( n - ind ) ] NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE
def find_maxm ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for x in mp : NEW_LINE INDENT value = x [ 0 ] NEW_LINE freq = mp [ x [ 1 ] ] NEW_LINE if ( value == freq ) : NEW_LINE INDENT ans = max ( ans , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maxm ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE N = int ( readline ( ) ) NEW_LINE A = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE L = A [ : ] NEW_LINE L . sort ( ) NEW_LINE R = A [ N : ] + [ - 1 ] NEW_LINE ok = 0 NEW_LINE ng = 10 ** 10 NEW_LINE ans = - 1 NEW_LINE while L < N : NEW_LINE INDENT while N - ok > 1 : NEW_LINE INDENT mid = ( L + ng ) // 2 NEW_LINE if A [ mid ] > A [ mid ] : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT if ok - ng > 1 : NEW_LINE INDENT print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT ans += A [ ok ] NEW_LINE for i in range ( mid , N ) : NEW_LINE INDENT if ans + A [ i ] <= A [ i - 1 ] : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT ans += x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) NEW_LINE DEDENT N = 35 NEW_LINE print ( sumOfDigitsTwoParts ( N ) ) NEW_LINE
import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT a , b = map ( float , e . split ( ) ) NEW_LINE c = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' ] NEW_LINE d = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' ] NEW_LINE print ( [ ' NA ' , ' F ' , ' G ' , ' H ' , ' I ' , ' J ' , ' K ' , ' L ' , ' M ' , ' N ' , ' O ' , ' P ' , ' Q ' , ' R ' , ' S ' , ' T ' , ' U ' , ' V ' , ' W ' , ' X ' , ' Y ' , ' Z ' ] [ a > b ] ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a - 1 , c - 1 ) + max ( b - 1 , d - 1 ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) NEW_LINE ans = " YES " NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] - a [ i - 1 ] >= 2 : NEW_LINE INDENT ans = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
from math import fabs , sin NEW_LINE def cal_sin ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = n NEW_LINE sinx = n NEW_LINE sinval = sin ( n ) NEW_LINE i = 1 NEW_LINE denominator = 2 * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE while ( accuracy <= sinval - sinx ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT print ( ' { 0 : . 6 } ' . format ( sinx ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 90 NEW_LINE cal_sin ( n ) NEW_LINE DEDENT
def multiply ( arr , n ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = pro * arr [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( multiply ( arr , n ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE Q = sys . stdin . readline ( ) NEW_LINE for _ in range ( int ( Q ) ) : NEW_LINE INDENT s = Q [ : - 1 ] NEW_LINE ans = 0 NEW_LINE if s [ 0 ] == "0" : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT if s [ 1 ] == "1" : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT if s [ 2 ] == "0" : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = ( incl > excl ) NEW_LINE excl = excl + arr [ i ] NEW_LINE excl = excl_new NEW_LINE DEDENT return ( incl > excl ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT c_l = [ ] NEW_LINE for i in s : NEW_LINE INDENT c_l . append ( len ( i ) ) NEW_LINE DEDENT t = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j == " C " : NEW_LINE INDENT t += c_l [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT t += c_l [ j ] NEW_LINE DEDENT DEDENT p = ( t + 1 ) // 2 NEW_LINE print ( p ) NEW_LINE
def findMinIndex ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low ; NEW_LINE DEDENT mid = ( low + high ) // 2 ; NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) ; NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return findMinIndex ( arr , low , mid - 1 ) ; NEW_LINE DEDENT return findMinIndex ( arr , mid + 1 , high ) ; NEW_LINE DEDENT def binary_search ( arr , l , h , x ) : NEW_LINE INDENT while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 ; NEW_LINE if ( arr [ mid ] <= x ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 ; NEW_LINE DEDENT DEDENT return h ; NEW_LINE DEDENT def countEleLessThanOrEqual ( arr , n , x ) : NEW_LINE INDENT min_index = findMinIndex ( arr , 0 , n - 1 ) ; NEW_LINE if ( x <= arr [ n - 1 ] ) : NEW_LINE INDENT return ( binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ; NEW_LINE DEDENT if ( ( min_index - 1 ) >= 0 and x <= arr [ min_index - 1 ] ) : NEW_LINE INDENT return ( n - min_index + binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 10 , 12 , 15 , 2 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x = 14 ; NEW_LINE print ( " Count ▁ = " , countEleLessThanOrEqual ( arr , n , x ) ) ; NEW_LINE DEDENT
def f ( x , y ) : NEW_LINE INDENT v = y - 2 * x * x + 1 ; NEW_LINE return v ; NEW_LINE DEDENT def predict ( x , y , h ) : NEW_LINE INDENT y1p = y + h * f ( x , y ) ; NEW_LINE return y1p ; NEW_LINE DEDENT def correct ( x , y , x1 , y1 , h ) : NEW_LINE INDENT e = 0.00001 ; NEW_LINE y1c = y1 ; NEW_LINE while ( abs ( y1c - y1 ) > e ) : NEW_LINE INDENT y1 = y1c ; NEW_LINE y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) ; NEW_LINE DEDENT return y1c ; NEW_LINE DEDENT def printFinalValues ( x , xn , y , h ) : NEW_LINE INDENT while ( x < xn ) : NEW_LINE INDENT x1 = x + h ; NEW_LINE y1p = predict ( x , y , h ) ; NEW_LINE y1c = correct ( x , y , x1 , y1p , h ) ; NEW_LINE x = x1 ; NEW_LINE y = y1c ; NEW_LINE DEDENT print ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = ▁ " , int ( x ) , " is ▁ : ▁ " , " { 0 : . 4 f } " . format ( y ) ) ; NEW_LINE DEDENT x = 0 ; NEW_LINE y = 0.5 ; NEW_LINE xn = 1 ; NEW_LINE h = 0.2 ; NEW_LINE printFinalValues ( x , xn , y , h ) ; NEW_LINE
def D_Pattern ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( ( i == 0 or i == n - 1 ) and ( j > 1 and j < n - 2 ) ) or ( j == n - 2 and i != 0 and i != n - 1 ) ) : NEW_LINE INDENT print ( " * " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 ; NEW_LINE D_Pattern ( n ) ; NEW_LINE DEDENT
def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE j = first_y_position + 1 NEW_LINE while ( second_y_position > 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE k = 7 NEW_LINE kthString ( n , k ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE C [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def count_of_subarrays ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N - 1 , N ) ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE print ( count_of_subarrays ( N ) ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def productExceptSelf ( self , nums ) : NEW_LINE INDENT n = len ( nums ) NEW_LINE res = [ 1 ] * n NEW_LINE res [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT res [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 ] NEW_LINE out = sObj . productExceptSelf ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ 0 : k ] NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : k ] + s [ i ] NEW_LINE if lexMax < currStr : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if lexMin > currStr : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE getSmallestAndLargest ( str , k ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE print ( * a ) NEW_LINE
INT_BITS = 32 NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT maxInd = index NEW_LINE maxEle = INT_BITS - 1 NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT if ( ( set [ j ] & ( 1 << i ) ) != 0 and set [ j ] > maxEle ) : NEW_LINE INDENT maxEle = set [ j ] NEW_LINE maxInd = j NEW_LINE DEDENT DEDENT if ( maxEle == - 2147483648 ) : NEW_LINE INDENT continue NEW_LINE DEDENT set [ index ] , set [ maxInd ] = set [ maxInd ] , set [ index ] NEW_LINE maxInd = index NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( j != maxInd and ( set [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT set [ j ] = set [ j ] ^ set [ maxInd ] NEW_LINE DEDENT DEDENT index += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res ^= set [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT set = [ 9 , 8 , 5 ] NEW_LINE n = len ( set ) NEW_LINE print ( " Max ▁ subset ▁ XOR ▁ is " , maxSubarrayXOR ( set , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in b : NEW_LINE INDENT b [ a [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT m = max ( b ) NEW_LINE c = [ ] NEW_LINE for k in b : NEW_LINE INDENT if b [ k ] == m : NEW_LINE INDENT c . append ( k ) NEW_LINE DEDENT DEDENT print ( max ( c ) , len ( c ) ) NEW_LINE
def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum = 999999 NEW_LINE min_sum = 999999 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT arr = [ ( 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE def partition ( arr , l , r ) : NEW_LINE INDENT pivot = arr [ r ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( l , r ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ r ] = arr [ r ] , arr [ i + 1 ] NEW_LINE return i + 1 NEW_LINE DEDENT def sort ( arr , l , r ) : NEW_LINE INDENT if ( l < r ) : NEW_LINE INDENT mid = partition ( arr , l , r ) NEW_LINE sort ( arr , l , mid - 1 ) NEW_LINE sort ( arr , mid + 1 , high ) NEW_LINE DEDENT return ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( s ) , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( s ) , 1 ) : NEW_LINE INDENT if ( freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = ' leetcode ' NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkStackPermutation ( ip , op , n ) : NEW_LINE INDENT input = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT input . append ( ip [ i ] ) NEW_LINE DEDENT output = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . append ( op [ i ] ) NEW_LINE DEDENT tempStack = [ ] NEW_LINE while ( len ( input ) > 0 ) : NEW_LINE INDENT ele = input [ 0 ] NEW_LINE if ( ele == output [ 0 ] ) : NEW_LINE INDENT output . pop ( 0 ) NEW_LINE while ( len ( tempStack ) > 0 ) : NEW_LINE INDENT if ( tempStack [ - 1 ] == output [ - 1 ] ) : NEW_LINE INDENT tempStack . pop ( ) NEW_LINE output . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT tempStack . append ( ele ) NEW_LINE DEDENT DEDENT return ( len ( input ) == len ( tempStack ) and len ( tempStack ) == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = [ 1 , 2 , 3 ] NEW_LINE output = [ 2 , 1 , 3 ] NEW_LINE n = 3 NEW_LINE if ( checkStackPermutation ( input , output , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT
s = input ( ) NEW_LINE t = input ( ) NEW_LINE ans = " Yes " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != t [ i ] : NEW_LINE INDENT ans = " No " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s , t , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n : NEW_LINE INDENT b = s - m NEW_LINE c = n - m NEW_LINE DEDENT else : NEW_LINE INDENT b = s - m + n - m NEW_LINE c = n - m NEW_LINE DEDENT print ( b - c ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT e , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( e - s , e - t ) + 1 ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 10 NEW_LINE K = 2 NEW_LINE print ( findSum ( N , K ) ) NEW_LINE
import math NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n == 0 ) : print ( 1 ) NEW_LINE elif ( n == 1 ) : print ( 4 ) NEW_LINE elif ( n % 2 == 0 ) : NEW_LINE INDENT k = 4 * n - 1 NEW_LINE print ( int ( math . log ( k / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k = 4 * n - 1 NEW_LINE print ( int ( math . log ( k / 2 ) ) + 1 ) NEW_LINE DEDENT DEDENT
import math NEW_LINE PI = 3.14 NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI ; NEW_LINE R += pow ( r , 2 ) ; NEW_LINE R = math . sqrt ( R ) ; NEW_LINE area = PI * math . pow ( R , 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r , d = 4 , 5 ; NEW_LINE print ( find_area ( r , d ) ) ; NEW_LINE DEDENT
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s // n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s // n NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 11 NEW_LINE print ( minimumNumbers ( n , s ) ) NEW_LINE DEDENT
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE end = n - 1 NEW_LINE mid = 1 NEW_LINE start = 0 NEW_LINE mid = 0 NEW_LINE for end in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = arr [ end ] * arr [ start ] * arr [ mid ] NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isSatisfied ( string , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) == False and isVowel ( string [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) == False and isVowel ( string [ i - 1 ] ) == False and isVowel ( string [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " acaba " NEW_LINE n = len ( string ) NEW_LINE if ( isSatisfied ( string , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( countWays ( n ) ) ; NEW_LINE
import math NEW_LINE def expect ( m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT ans += ( math . pow ( i / m , n ) - math . pow ( ( i - 1 ) / m , n ) ) * i NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 6 ; n = 3 ; NEW_LINE print ( math . pow ( expect ( m , n ) , 5 ) ) ; NEW_LINE DEDENT
def ProdOfPrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT n = 10 NEW_LINE print ( ProdOfPrimes ( n ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for y in range ( 1901 , 2000 ) for m in range ( 1 , 12 ) if dayOfWeek ( y , m , 1 ) == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def dayOfWeek ( year , month , day ) : NEW_LINE INDENT if ( year < 0 or year > 10000 or month < 1 or month > 12 or day < 1 or day > 31 ) : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT y = ( year + m // 12 ) % 4800 NEW_LINE m %= 12 NEW_LINE return ( y + y // 4 - y // 100 + ( 13 * m + 2 ) // 5 + day + 2 ) % 7 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countLeapYears ( d ) : NEW_LINE INDENT years = d . y NEW_LINE if d . m <= 2 : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT return ( years // 4 - years // 100 + years // 400 ) NEW_LINE DEDENT def getDifference ( dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 36 + dt1 . d NEW_LINE for i in range ( 0 , dt1 . m - 1 ) : NEW_LINE INDENT n1 += monthDays [ i ] NEW_LINE DEDENT n1 += countLeapYears ( dt1 ) NEW_LINE n2 = dt2 . y * 36 + dt2 . d NEW_LINE for i in range ( 0 , dt2 . m - 1 ) : NEW_LINE INDENT n2 += monthDays [ i ] NEW_LINE DEDENT n2 += countLeapYears ( dt2 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT dt1 = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE dt2 = [ 1 , 2 , 2004 ] NEW_LINE print ( " Difference ▁ between ▁ two ▁ dates ▁ is ▁ " , getDifference ( dt1 , dt2 ) ) NEW_LINE DEDENT
st = dict ( ) NEW_LINE def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT st [ num ] = 1 NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num * 10 + a > num ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( i + 1 , 10 ) : NEW_LINE INDENT generateNumbers ( n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( " The ▁ numbers ▁ are : ▁ " , end = " " ) NEW_LINE print ( st ) NEW_LINE st . clear ( ) NEW_LINE DEDENT n = 12 NEW_LINE printNumbers ( n ) NEW_LINE
import math NEW_LINE n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE t = math . ceil ( ( n * k ) / 100 ) NEW_LINE res = [ ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT res . append ( k ) NEW_LINE if i < n - 1 : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT if t == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( t ) NEW_LINE t -= k NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT infos = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT info = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE tmp = info . pop ( 0 ) NEW_LINE infos . append ( info ) NEW_LINE DEDENT infos . sort ( ) NEW_LINE tmp = info . pop ( 0 ) NEW_LINE ans = None NEW_LINE for i , info in enumerate ( infos ) : NEW_LINE INDENT for t in info : NEW_LINE INDENT if t >= q : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def getOddOccurrence ( ar , ar_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( getOddOccurrence ( ar , n ) ) NEW_LINE
def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = ( ( x & ( 1 << ( k - 1 ) ) ) ) if ( x & ( 1 << ( k - 1 ) ) ) else 0 ; NEW_LINE return rslt ; NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 ; NEW_LINE r = ( int ) ( SIZE / 8 ) * 8 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT x = 1 << 15 + 1 << 16 ; NEW_LINE print ( isPalindrome ( x ) ) ; NEW_LINE x = ( 1 << 31 ) + 1 ; NEW_LINE print ( isPalindrome ( x ) ) ; NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE isPrime = [ False ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( n , isPrime ) ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = int ( n / i ) ; NEW_LINE if ( isPrime [ i ] and isPrime [ x ] and x != i and x * i == n ) : NEW_LINE INDENT print ( i , x ) ; NEW_LINE flag = 1 ; NEW_LINE return ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ found " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 39 ; NEW_LINE findPrimePair ( n ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE
def compute ( ) : NEW_LINE INDENT SIZE_LIMIT = 1000000 NEW_LINE type_LIMIT = 10 NEW_LINE def count ( ) : NEW_LINE INDENT type_pairs = { } NEW_LINE for n in range ( 3 , ( n - 1 ) * 4 , SIZE_LIMIT ) : NEW_LINE INDENT for m in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT tiles = n * n - m * m NEW_LINE if tiles > SIZE_LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT type_pairs [ tiles ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for t in type_pairs . values ( ) : NEW_LINE INDENT if 1 <= t <= type_LIMIT : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE s = s . strip ( '1' ) NEW_LINE if ( '1' in s ) == True : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT elif ( '0' in s ) == True : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT if ( N & 1 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT N = 14 NEW_LINE print ( maxZeros ( N ) ) NEW_LINE
def getLongestSeq ( a , n ) : NEW_LINE INDENT maxIdx = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currIdx = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( a [ k ] > 0 ) : NEW_LINE INDENT currLen += 1 NEW_LINE if ( currLen == 1 ) : NEW_LINE INDENT currIdx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( currLen > maxLen ) : NEW_LINE INDENT maxLen = currLen NEW_LINE maxIdx = currIdx NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT DEDENT if ( maxLen > 0 ) : NEW_LINE INDENT print ( " Index ▁ : " , maxIdx , " , ▁ : " , maxLen ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ positive ▁ sequence ▁ detected . " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE getLongestSeq ( arr , n ) NEW_LINE DEDENT
class Linked_list_2D_Matrix : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = None NEW_LINE self . down = None NEW_LINE DEDENT DEDENT def construct ( arr , i , j , m , n ) : NEW_LINE INDENT if i > n - 1 or j > m - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT temp = Node ( arr [ i ] [ j ] ) NEW_LINE temp . right = construct ( arr , i , j + 1 , m , n ) NEW_LINE temp . down = construct ( arr , i + 1 , j , m , n ) NEW_LINE return temp NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT Rp = head NEW_LINE while Dp != None : NEW_LINE INDENT Rp = Dp NEW_LINE while Rp != None : NEW_LINE INDENT print ( Rp . data , end = " ▁ " ) NEW_LINE Rp = Rp . right NEW_LINE DEDENT print ( ) NEW_LINE Dp = Dp . down NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE m = 3 NEW_LINE n = 3 NEW_LINE head = construct ( arr , 0 , 0 , m , n ) NEW_LINE display ( head ) NEW_LINE DEDENT
import math NEW_LINE import itertools NEW_LINE def sieve_of_erastosthenes ( num ) : NEW_LINE INDENT input_list = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( num ) ] NEW_LINE input_list [ 0 ] = input_list [ 1 ] = False NEW_LINE input_list [ 2 ] = input_list [ 3 ] = input_list [ 5 ] = True NEW_LINE sqrt = math . sqrt ( num ) NEW_LINE for serial in range ( 3 , num , 2 ) : NEW_LINE INDENT if serial >= sqrt : NEW_LINE INDENT return input_list NEW_LINE DEDENT for s in range ( serial ** 2 , num , serial ) : NEW_LINE INDENT input_list [ s ] = False NEW_LINE DEDENT DEDENT DEDENT primeTable = sieve_of_erastosthenes ( 10 ** 6 ) NEW_LINE prime_table = [ False if i % 2 == 0 else True for i in range ( 10 ** 6 ) ] NEW_LINE c = 0 NEW_LINE input_list = [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] NEW_LINE for input_list in input_list : NEW_LINE INDENT if primeTable [ int ( input ( ) ) ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def findNthTerm ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a == b and a == c and a == d and c == d and b == c and b == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE if isRectangle ( a , b , c , d ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = ( int ) ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * m NEW_LINE cur = an NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE m = 5 NEW_LINE print ( discreteLogarithm ( a , b , m ) ) NEW_LINE a = 3 NEW_LINE b = 7 NEW_LINE m = 11 NEW_LINE print ( discreteLogarithm ( a , b , m ) ) NEW_LINE DEDENT
import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , ( abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return dp [ ind ] NEW_LINE DEDENT DEDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE
from math import gcd NEW_LINE def Probability ( sum , times ) : NEW_LINE INDENT favable = 0 NEW_LINE total = 36 NEW_LINE probability = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( ( i + j ) == sum ) : NEW_LINE INDENT favable += 1 NEW_LINE DEDENT DEDENT DEDENT __gcd1 = gcd ( favorable , total ) NEW_LINE favable = favorable // __gcd1 NEW_LINE total = total // __gcd1 NEW_LINE probability = int ( 1 ** times ) NEW_LINE return probability NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum , times = 7 , 7 NEW_LINE print ( "1" , " / " , Probability ( sum , times ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE K , N = map ( int , input ( ) . split ( ) ) NEW_LINE if K % 2 == 0 : NEW_LINE INDENT L = K // 2 NEW_LINE R = K - L NEW_LINE dp = [ [ 0 ] * ( K + 1 ) for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , L + 1 ) : NEW_LINE INDENT dpn = dp [ i - 1 ] [ : i ] NEW_LINE for j in range ( i , L + 1 ) : NEW_LINE INDENT dpn [ j ] = dpn [ j - 1 ] + dpn [ j ] NEW_LINE DEDENT DEDENT answer = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT answer += dp [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( K , N ) : NEW_LINE INDENT answer += dp [ i - 1 ] [ 0 ] * ( dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT answer %= 998244353 NEW_LINE print ( answer ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = sum ( map ( float , input ( ) . split ( ) ) for _ in [ 0 ] * n ) NEW_LINE print ( a , ' \n ' . join ( [ ' JPY ' if i == ' JPY ' else str ( i ) for i in a ] ) ) NEW_LINE
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = n - 1 NEW_LINE while ( j >= i + 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE num1 = 5 NEW_LINE num2 = 4 NEW_LINE print ( getCount ( arr , n , num1 , num2 ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE d = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT d . append ( l [ i + 1 ] - l [ i ] ) NEW_LINE DEDENT print ( min ( d ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE setBits = [ 0 ] * ( n + 1 ) ; NEW_LINE setBits [ 0 ] = 0 ; NEW_LINE setBits [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i // 2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 ; NEW_LINE print ( countSetBits ( n ) ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def largestGCD1Subset ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if ( currentGCD == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestGCD1Subset ( A , n ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT numDivisors = [ 2 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( numDivisors ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( numDivisors ) , i ) : NEW_LINE INDENT numDivisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( 1 for i in range ( 2 , len ( numDivisors ) - 1 ) if numDivisors [ i ] == numDivisors [ i + 1 ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT
def findEncryptedArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE findEncryptedArray ( arr , N ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT min = secondMax = arr [ 0 ] NEW_LINE secondMin = arr [ 1 ] NEW_LINE max = secondMin = arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min ) : NEW_LINE INDENT secondMin = min NEW_LINE min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max - secondMin , secondMax - min ) NEW_LINE return diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE def prime_factorize ( n ) : NEW_LINE INDENT a = set ( ) NEW_LINE a . add ( 1 ) NEW_LINE while n % 2 == 0 : NEW_LINE INDENT a . add ( 2 ) NEW_LINE n //= 2 NEW_LINE DEDENT f = 3 NEW_LINE while f * f <= n : NEW_LINE INDENT if n % f == 0 : NEW_LINE INDENT a . add ( f ) NEW_LINE n //= f NEW_LINE DEDENT else : NEW_LINE INDENT f += 2 NEW_LINE DEDENT DEDENT if n != 1 : NEW_LINE INDENT a . add ( n ) NEW_LINE DEDENT return a NEW_LINE DEDENT def solve ( A , B ) : NEW_LINE INDENT factors = set ( ) NEW_LINE for p in prime_factorize ( A ) : NEW_LINE INDENT while True : NEW_LINE INDENT if p * p > A : NEW_LINE INDENT break NEW_LINE DEDENT factors . add ( p * p ) NEW_LINE DEDENT DEDENT if len ( factors ) == 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return factors [ 0 ] NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE DEDENT print ( solve ( A , B ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c = 0 NEW_LINE a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c >= a [ i ] : print ( a [ i ] ) ; c = 1 NEW_LINE c += 1 NEW_LINE DEDENT if c > n / 2 : print ( ' NO ▁ COLOR ' ) NEW_LINE else : print ( c ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( num ) ) ; NEW_LINE
n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] NEW_LINE s = [ 0 ] * ( x + 1 ) NEW_LINE for i in range ( d ) : NEW_LINE INDENT s [ i ] = list ( map ( lambda x : x - c [ i ] , input ( ) . split ( ) ) ) NEW_LINE DEDENT c . sort ( ) NEW_LINE memo = { } NEW_LINE for i in range ( x ) : NEW_LINE INDENT if i + 1 not in memo : NEW_LINE INDENT memo [ i + 1 ] = 0 NEW_LINE DEDENT s [ i ] = memo [ i + 1 ] NEW_LINE DEDENT for i in range ( d ) : NEW_LINE INDENT for j in range ( len ( c [ i ] ) ) : NEW_LINE INDENT if s [ i ] [ j ] < s [ i ] [ j - c [ i ] [ j ] ] : NEW_LINE INDENT memo [ i ] = s [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT memo [ i ] = max ( memo [ i ] , s [ i ] [ j - c [ i ] ] + c [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( memo [ x ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] + x ) NEW_LINE x += 1 NEW_LINE DEDENT b . sort ( ) NEW_LINE for k in range ( int ( input ( ) ) ) : NEW_LINE INDENT t , l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 1 : NEW_LINE INDENT c . append ( b [ r ] - b [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( c [ l - 1 ] - c [ r - 1 ] ) NEW_LINE DEDENT DEDENT print ( ' \n ' . join ( map ( str , c ) ) ) NEW_LINE
def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT el1 , el2 = map ( int , st ) NEW_LINE if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return ( el2 - el1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT el1 , el2 , el3 = map ( int , st ) NEW_LINE if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE
from math import sqrt NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE m = int ( sqrt ( k ) ) + 1 NEW_LINE for i in range ( 2 , m and k > 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT u = v = 0 NEW_LINE while ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( int ( findX ( n , k ) ) ) NEW_LINE DEDENT
def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 7 NEW_LINE b = 2 NEW_LINE x = 4 NEW_LINE y = 5 NEW_LINE if ( LiesInsieRectangle ( a , b , x , y ) ) : NEW_LINE INDENT print ( " Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Given ▁ point ▁ does ▁ " + " not ▁ lie ▁ on ▁ the ▁ rectangle " ) NEW_LINE DEDENT
import math as mt NEW_LINE N = 1000 NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 ; NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] ; NEW_LINE freq [ x + N ] += 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) // 2 ; NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if ( freq [ j ] > 0 and ( freq [ ( i + j ) // 2 ] > 0 ) ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT
sum , n = 0 , n NEW_LINE def getAvg ( x ) : NEW_LINE INDENT sum += x NEW_LINE return ( ( float ) ( sum ) / n ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( int ( arr [ i ] ) ) NEW_LINE print ( "Average ▁ of " , i + 1 , " numbers ▁ is " , avg ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE
MAX = 10000 NEW_LINE s = set ( ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( p * p > MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT product = product * p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT if n in s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m <= a [ i ] % 2 : NEW_LINE INDENT c += 1 NEW_LINE m -= a [ i ] // 2 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def maxOperations ( str ) : NEW_LINE INDENT i = g = gk = gks = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' g ' ) : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif ( str [ i ] == ' k ' ) : NEW_LINE INDENT if ( g > 0 ) : NEW_LINE INDENT g -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' s ' ) : NEW_LINE INDENT if ( gk > 0 ) : NEW_LINE INDENT gk -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " ggkssk " NEW_LINE print ( maxOperations ( a ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ls = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxm = max ( ls ) NEW_LINE minm = min ( ls ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ls . remove ( max ( ls ) ) NEW_LINE answ = 0 NEW_LINE for l in ls : NEW_LINE INDENT if l > maxm : NEW_LINE INDENT break NEW_LINE DEDENT answ += 1 NEW_LINE DEDENT print ( answ ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE m , n = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE graph = [ [ ] for _ in range ( m + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT graph [ l [ i ] [ 0 ] - 1 ] . append ( l [ i ] [ 1 ] - 1 ) NEW_LINE graph [ l [ i ] [ 1 ] - 1 ] . append ( l [ i ] [ 0 ] - 1 ) NEW_LINE DEDENT visited = [ False for _ in range ( m + 1 ) ] NEW_LINE count = 0 NEW_LINE def dfs ( v ) : NEW_LINE INDENT if visited [ v ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT visited [ v ] = True NEW_LINE for nv in graph [ v ] : NEW_LINE INDENT if not visited [ nv ] : NEW_LINE INDENT dfs ( nv ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT dfs ( 0 ) NEW_LINE print ( count ) NEW_LINE
def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( " K ' th ▁ smallest ▁ element ▁ is " , kthSmallest ( arr , k ) ) NEW_LINE DEDENT
for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = [ 0 , * map ( int , s . split ( ) ) , 0 ] ; i = 1 NEW_LINE while a [ i ] == a [ i - 1 ] : i += 1 NEW_LINE print ( ( i , - 1 ) [ i > - 1 ] ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = " PPPPNNPPPNPPNPN " NEW_LINE def is_prime ( start_num , end_num , CROAK_SEQ ) : NEW_LINE INDENT is_prime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_num , end_num ) : NEW_LINE INDENT for j in range ( NUM_triALs ) : NEW_LINE INDENT pos = i NEW_LINE trialNumerator = 1 NEW_LINE if is_prime [ pos ] == CROAK_SEQ [ 0 ] == ' P ' : NEW_LINE INDENT trialNumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_num : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_num : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( ( j >> k ) & 1 ) == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if is_prime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialNumerator *= 2 NEW_LINE DEDENT DEDENT globalNumerator += trialNumerator NEW_LINE DEDENT DEDENT return str ( ( END_num + 1 - START_num ) * ( 3 ** ( CROAK_SEQ . count ( ' P ' ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = ( lon1 ) * math . pi / 180.0 NEW_LINE lon2 = ( lon2 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = ( pow ( math . sin ( dlat / 2 ) , 2 ) + math . cos ( lat1 ) * math . cos ( lat2 ) * math . sin ( dlon / 2 ) , 2 ) NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT lat1 = 53.32055555555556 NEW_LINE lat2 = 53.31861111111111 NEW_LINE lon1 = - 1.72972222222221 NEW_LINE lon2 = - 1.69972222222223 NEW_LINE print ( distance ( lat1 , lat2 , lon1 , lon2 ) , " K . M " ) NEW_LINE DEDENT
def centeredOctahedral ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE print ( " " , end = " " ) NEW_LINE n = 9 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import deque NEW_LINE import bisect NEW_LINE input = sys . stdin . readline NEW_LINE N , M , P = map ( int , input ( ) . split ( ) ) NEW_LINE D = [ int ( input ( ) ) for _ in range ( M ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT que = deque ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT d = D [ i ] NEW_LINE que . append ( d ) NEW_LINE DEDENT visited = [ False ] * ( N + 1 ) NEW_LINE visited [ 0 ] = True NEW_LINE que . append ( ( 1 , 0 ) ) NEW_LINE while len ( que ) > 0 : NEW_LINE INDENT cur = que . popleft ( ) NEW_LINE if len ( que ) == M : NEW_LINE INDENT visited [ cur ] = True NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT que . append ( ( i , cur ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return P NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT D [ i ] = int ( input ( ) ) NEW_LINE DEDENT P = [ 0 ] + ( N * 100 ) NEW_LINE visited = [ False ] * ( N + 1 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT d = D [ i ] NEW_LINE if not visited [ d ] : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT print ( solve ( ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math as mt NEW_LINE def SumDivPrime ( A , n ) : NEW_LINE INDENT max_val = mt . ceil ( mt . sqrt ( max_val ) ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ A [ i ] ] ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prime [ A [ i ] ] and sum % A [ i ] == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE SumDivPrime ( A , n ) NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 3 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 4 NEW_LINE leftRotate ( arr , n , k ) ; NEW_LINE print ( ) NEW_LINE
def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT n = 56287 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE
import sys NEW_LINE from os import path NEW_LINE if ( path . exists ( ' input . txt ' ) ) : NEW_LINE INDENT sys . stdin = open ( ' input . txt ' , ' r ' ) NEW_LINE sys . stdout = open ( ' output . txt ' , ' w ' ) NEW_LINE DEDENT def process ( S ) : NEW_LINE INDENT y = len ( S ) NEW_LINE x = 0 NEW_LINE for i in range ( y ) : NEW_LINE INDENT if S [ i ] != '0' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT if x % 3 == 0 : NEW_LINE INDENT print ( " yellow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " red " ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT S = input ( ) NEW_LINE process ( S ) NEW_LINE DEDENT
dp = [ [ - 1 for i in range ( 8101 ) ] for j in range ( 901 ) ] NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or a < 0 or b < 0 or a > 900 or b > 8100 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 0 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = ans NEW_LINE return dp [ a ] [ b ] NEW_LINE DEDENT def printSmallestNumber ( a , b ) : NEW_LINE INDENT for row in dp : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 18 NEW_LINE b = 162 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE DEDENT
N = 5005 NEW_LINE gr = [ [ ] for i in range ( N ) ] NEW_LINE d = [ [ 0 for i in range ( 505 ) ] for j in range ( N ) ] NEW_LINE ans = 0 NEW_LINE def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( v , par ) : NEW_LINE INDENT d [ v ] [ 0 ] = 1 NEW_LINE for i in gr [ v ] : NEW_LINE INDENT if i != par : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ v ] [ j ] += d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT g = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT g . append ( [ ] ) NEW_LINE DEDENT Add_edge ( 1 , 2 ) NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 3 , 4 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE dfs ( 1 , 0 ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def findSubsequence ( arr , n ) : NEW_LINE INDENT Len = 1 NEW_LINE tmp = 0 NEW_LINE i , j , d = 0 , 0 , 0 NEW_LINE dp = [ 0 for i in range ( 10 ) ] NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE locMax = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] = locMax NEW_LINE DEDENT DEDENT Len = max ( Len , locMax ) NEW_LINE DEDENT return Len NEW_LINE DEDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE a = set ( [ int ( s ) for s in input ( ) . split ( ) ] ) NEW_LINE b = set ( [ int ( s ) for s in input ( ) . split ( ) ] ) NEW_LINE c = a . intersection ( b ) NEW_LINE print ( len ( c ) ) NEW_LINE DEDENT
def totalPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT while ( ( n % i == 0 ) ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT if ( L % G != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L // G NEW_LINE return ( 1 << totalPrimeFactors ( div ) ) NEW_LINE DEDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD " , G ) NEW_LINE print ( " & ▁ LCM " , L ) NEW_LINE print ( " ▁ = ▁ " , countPairs ( G , L ) ) NEW_LINE
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE N = 49 NEW_LINE print ( " Sum ▁ of ▁ multiples ▁ of " , a , " up ▁ to " , N , " = " , calculate_sum ( a , N ) ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = { } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT k , p = input ( ) . split ( ) NEW_LINE p = int ( p ) NEW_LINE a [ k ] = min ( a [ k ] , p * k // 100 ) NEW_LINE DEDENT print ( len ( a ) ) NEW_LINE for i in sorted ( a ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT
def next ( arr , target ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( arr ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] NEW_LINE print ( next ( arr , 8 ) ) NEW_LINE
word = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " ] ; NEW_LINE def printWordsWithoutIfSwitch ( n ) : NEW_LINE INDENT digits = [ 0 ] * 10 ; NEW_LINE dc = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT digits [ dc ] = n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE dc += 1 ; NEW_LINE DEDENT for i in range ( dc - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( word [ digits [ i ] ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 350 ; NEW_LINE printWordsWithoutIfSwitch ( n ) ; NEW_LINE
n , k , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst . sort ( ) NEW_LINE data = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT data . append ( 0 ) NEW_LINE DEDENT if m == n : NEW_LINE INDENT print ( sum ( lst [ 0 : len ( lst ) * k ] ) / n ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT data . append ( lst [ i ] + min ( k * ( i + 1 ) , m - i ) ) NEW_LINE DEDENT print ( data [ - 1 ] ) NEW_LINE
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) ; NEW_LINE min = 0 ; max = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT max += 1 ; NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 ; NEW_LINE DEDENT DEDENT print ( min + max ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = " a + c " ; NEW_LINE s2 = " + + b " ; NEW_LINE solve ( s1 , s2 ) ; NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE s = 2 NEW_LINE print ( " Total ▁ Ways ▁ = " , TotalWays ( n , s , k ) ) NEW_LINE
def countEvenOdd ( n ) : NEW_LINE INDENT even_count = 0 ; NEW_LINE odd_count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem % 2 == 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Even ▁ count ▁ : " , even_count ) NEW_LINE print ( " Odd ▁ count ▁ : " , odd_count ) NEW_LINE if ( even_count % 2 == 0 and odd_count % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 2335453 NEW_LINE t = countEvenOdd ( n ) NEW_LINE if t == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT from random import sample NEW_LINE from operator import itemgetter NEW_LINE e = enumerate NEW_LINE n , k = input ( ) . split ( ) NEW_LINE n , k = int ( n ) , int ( k ) NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE a , b = int ( a ) , int ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT a = sorted ( a , reverse = True ) NEW_LINE dist = [ 10 ** 9 ] * k NEW_LINE dist [ 0 ] = 0 NEW_LINE for to in range ( 1 , 10 ) : NEW_LINE INDENT for v in graph [ to ] : NEW_LINE INDENT dist_now = dist [ to ] + sum ( v ) NEW_LINE dist_nxt = dist [ to ] NEW_LINE if dist_nxt > dist_now + dist_nxt : NEW_LINE INDENT dist [ to ] = dist_now + dist_nxt NEW_LINE DEDENT DEDENT DEDENT print ( dist [ n - 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] [ 0 ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] [ 1 ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] [ 2 ] <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( min ( a , b ) , min ( c , d ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = [ [ 1 , 1 ] , [ 2 , 2 ] , [ - 1 , - 1 ] , [ - 2 , 2 ] ] NEW_LINE n = len ( p ) NEW_LINE print ( findmin ( p , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 ; NEW_LINE prime_factors = { } ; NEW_LINE for i in range ( 2 , int ( sqrt ( P ) ) + 1 ) : NEW_LINE INDENT while ( P % i == 0 ) : NEW_LINE INDENT if i not in prime_factors : NEW_LINE INDENT prime_factors [ i ] = 0 NEW_LINE DEDENT prime_factors [ i ] += 1 NEW_LINE P //= i NEW_LINE DEDENT DEDENT if ( P != 1 ) : NEW_LINE INDENT if prime_factors [ P ] not in prime_factors : NEW_LINE INDENT prime_factors [ P ] = 0 NEW_LINE DEDENT prime_factors [ P ] += 1 NEW_LINE DEDENT st = prime_factors . keys ( ) ; NEW_LINE for k , v in st : NEW_LINE INDENT ans *= pow ( k , v // N ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; P = 24 ; NEW_LINE print ( maxGCD ( N , P ) ) ; NEW_LINE DEDENT
def subset ( n , mask ) : NEW_LINE INDENT for i in range ( 2 ** n ) : NEW_LINE INDENT if i & mask == mask : NEW_LINE INDENT yield i , [ v for v in range ( n ) if i & ( 1 << v ) > 0 ] NEW_LINE DEDENT DEDENT DEDENT def run ( ) : NEW_LINE INDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE mask = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for i , vs in subset ( n , k ) : NEW_LINE INDENT print ( " { } : { } " . format ( i , " " . join ( [ " ▁ { } " . format ( v ) for v in vs ] ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT run ( ) NEW_LINE DEDENT
import math NEW_LINE def primeFactorization ( countOfPf , primeFactor ) : NEW_LINE INDENT countOfPf , primeFactor = countOfPf , primeFactor NEW_LINE ( curIndex , curDivisor ) = ( curIndex , curDivisor ) NEW_LINE class generateDivisors : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . curIndex = curDivisor NEW_LINE self . primeFactor = primeFactor NEW_LINE DEDENT DEDENT def generateDivisors ( curIndex , curDivisor , arr ) : NEW_LINE INDENT if ( curIndex == len ( arr ) ) : NEW_LINE INDENT print ( curDivisor , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT for i in range ( curIndex + 1 , int ( math . sqrt ( curIndex ) ) + 1 ) : NEW_LINE INDENT generateDivisors ( curIndex + 1 , curDivisor , arr ) NEW_LINE curDivisor *= arr [ curIndex ] . primeFactor NEW_LINE DEDENT DEDENT def findDivisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( primeFactorization ( count , i ) ) NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT arr . append ( primeFactorization ( 1 , n ) ) NEW_LINE DEDENT curIndex = 0 NEW_LINE curDivisor = 1 NEW_LINE generateDivisors ( curIndex , curDivisor , arr ) NEW_LINE DEDENT n = 6 NEW_LINE findDivisors ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE beauty = [ 0 ] * 1000001 NEW_LINE beauty [ 0 ] = 1 NEW_LINE beauty [ 1 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE beauty [ a ] = max ( beauty [ a ] , b ) NEW_LINE DEDENT beauty . insert ( 0 , 0 ) NEW_LINE beauty . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = beauty [ i ] NEW_LINE if x - beauty [ x - 1 ] == 0 : NEW_LINE INDENT print ( n ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT a = beauty [ x - 1 ] NEW_LINE beauty [ x - 1 ] = x NEW_LINE DEDENT DEDENT
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , ord ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE s = list ( input ( ) ) NEW_LINE t = " " NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT t += s [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT
from math import sqrt NEW_LINE from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in a : NEW_LINE INDENT ans = max ( ans , i ) NEW_LINE DEDENT print ( ans + 1 ) NEW_LINE
def initializeDiffArray ( A , D ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE D [ 0 ] = A [ 0 ] ; NEW_LINE D [ n ] = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] ; NEW_LINE DEDENT DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x ; NEW_LINE D [ r + 1 ] -= x ; NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] ; NEW_LINE DEDENT print ( A [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 10 , 5 , 20 , 40 ] ; NEW_LINE n = len ( A ) ; NEW_LINE D = [ 0 ] * ( n + 1 ) ; NEW_LINE initializeDiffArray ( A , D ) ; NEW_LINE update ( D , 0 , 1 , 10 ) ; NEW_LINE printArray ( A , D ) ; NEW_LINE update ( D , 1 , 3 , 20 ) ; NEW_LINE update ( D , 2 , 2 , 30 ) ; NEW_LINE printArray ( A , D ) ; NEW_LINE DEDENT
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) NEW_LINE exit . sort ( ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in += 1 NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ guestests ▁ = ▁ " , max_guests , " ▁ at ▁ time " , time ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arrl = [ 1 , 2 , 10 , 5 , 5 ] NEW_LINE exit = [ 4 , 5 , 12 , 9 , 12 ] NEW_LINE n = len ( arrl ) NEW_LINE findMaxGuests ( arrl , exit , n ) NEW_LINE DEDENT
def lcs_len ( X , Y ) : NEW_LINE INDENT m , n = len ( X ) , len ( Y ) NEW_LINE LCS_r = [ 0 for _ in range ( m + 1 ) ] NEW_LINE for y in Y : NEW_LINE INDENT previous = LCS_r [ : ] NEW_LINE for i , x in enumerate ( X ) : NEW_LINE INDENT if x == y : NEW_LINE INDENT LCS_r [ i + 1 ] = previous [ i ] + 1 NEW_LINE DEDENT elif LCS_r [ i ] > previous [ i + 1 ] : NEW_LINE INDENT LCS_r [ i + 1 ] = LCS_r [ i ] NEW_LINE DEDENT DEDENT DEDENT return LCS_r [ : ] NEW_LINE DEDENT while True : NEW_LINE INDENT S = input ( ) NEW_LINE if S == " # END " : NEW_LINE INDENT break NEW_LINE DEDENT print ( " " . join ( map ( str , S ) ) ) NEW_LINE DEDENT
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT n , r = 6 , 2 NEW_LINE print ( "1 / " , calcFunction ( n , r ) ) NEW_LINE
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE k = 2 NEW_LINE isPerfectSquare ( n + k ) NEW_LINE DEDENT
import sys NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] NEW_LINE def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] NEW_LINE def Yes ( ) : print ( ' Yes ' ) NEW_LINE def No ( ) : print ( ' No ' ) NEW_LINE def YES ( ) : print ( ' YES ' ) NEW_LINE def NO ( ) : print ( ' NO ' ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = INT ( ) NEW_LINE A = LIST ( N ) NEW_LINE ans = 0 NEW_LINE tmp_ans = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if A [ i ] % 2 == 0 : NEW_LINE INDENT tmp_ans += 1 NEW_LINE DEDENT A [ i ] = A [ i ] // 2 NEW_LINE DEDENT if tmp_ans % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if a [ i ] + a [ i + 1 ] == 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 998244353 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE while True : NEW_LINE INDENT n = I ( ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = LI ( ) NEW_LINE t = 0 NEW_LINE while True : NEW_LINE INDENT b = a [ 0 ] NEW_LINE if 1 not in a : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] != 1 : NEW_LINE INDENT t = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if t == - 1 : NEW_LINE INDENT r = - 1 NEW_LINE break NEW_LINE DEDENT a = a [ 1 : ] NEW_LINE break NEW_LINE DEDENT rr . append ( r ) NEW_LINE DEDENT return ' \n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
def isDivisible ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( S [ n - 1 ] != '5' and S [ n - 1 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( S [ i ] ) NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT S = "15645746327462384723984023940239" NEW_LINE if ( isDivisible ( S ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT S1 = "15645746327462384723984023940235" NEW_LINE if ( isDivisible ( S1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isSquare = [ False ] * sumLimit NEW_LINE def find_sum ( sumLimit ) : NEW_LINE INDENT for i in range ( 100000 ) : NEW_LINE INDENT isSquare [ i * i ] = True NEW_LINE DEDENT sum = find_sum ( sumLimit ) NEW_LINE if sum != - 1 : NEW_LINE INDENT sum = sumLimit NEW_LINE break NEW_LINE DEDENT sumLimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum = find_sum ( sumLimit ) NEW_LINE if sum == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT sumLimit = sumLimit NEW_LINE DEDENT def find_sum ( limit ) : NEW_LINE INDENT for a in range ( 1 , eulerlib . sqrt ( a ) + 1 ) : NEW_LINE INDENT for b in range ( a - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( a + b ) % 2 != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a + b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE for c in eulerlib . sqrt ( y ) + 1 + c * c - y < zlimit : NEW_LINE INDENT z = c * c - y NEW_LINE if isSquare [ x + z ] and isSquare [ x - z ] and isSquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = " " NEW_LINE for l in range ( 0 , n - k + 1 ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE for r in range ( l , l + k - 1 + 1 ) : NEW_LINE INDENT if ( isVowel ( s [ r ] ) == True ) : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT DEDENT ans += countVowels * countConsonants NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT r = a % b NEW_LINE a , b = b , r NEW_LINE DEDENT return a NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE d = gcd ( n , m ) NEW_LINE n = n // d NEW_LINE m = m // d NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt == n : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT if n < m : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if t < n : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT else : NEW_LINE INDENT t += 1 NEW_LINE DEDENT cnt = n // d NEW_LINE if t == 1 : NEW_LINE INDENT print ( t * cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT a = n // d NEW_LINE b = n % d NEW_LINE if a == b : NEW_LINE INDENT print ( a * cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a * cnt ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( [ x , y ] ) NEW_LINE DEDENT covered = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT covered [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if covered [ i ] [ j ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT covered [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT if not covered [ n - 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT
import sys NEW_LINE from itertools import product NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE while True : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE dp [ i ] [ 0 ] = int ( line ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if dp [ i ] [ j ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if dp [ i ] [ j ] != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( dp [ i ] [ j ] , dp [ i ] [ j - k ] + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - k ] + 1 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dp [ i ] [ i ] == 1 : NEW_LINE INDENT ans = max ( ans , i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) // 30 NEW_LINE DEDENT n = 6 ; NEW_LINE print ( fourthPowerSum ( n ) ) ; NEW_LINE
def maxLengthSub ( arr , size ) : NEW_LINE INDENT max_val = 0 ; NEW_LINE start = 0 ; NEW_LINE map = { } ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT temp = 0 ; NEW_LINE if ( arr [ i ] - 1 ) in map : NEW_LINE INDENT temp = map [ arr [ i ] - 1 ] ; NEW_LINE DEDENT if arr [ i ] in map : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] ] ) ; NEW_LINE DEDENT if ( arr [ i ] + 1 ) in map : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] + 1 ] ) ; NEW_LINE DEDENT temp += 1 ; NEW_LINE if ( temp > max_val ) : NEW_LINE INDENT max_val = temp ; NEW_LINE DEDENT map [ arr [ i ] ] = temp ; NEW_LINE DEDENT return max_val ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] ; NEW_LINE print ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " , maxLengthSub ( arr , 6 ) ) ; NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT if ( arr == None or n % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = int ( ( n - 1 ) / 2 ) NEW_LINE while ( currIdx > 0 ) : NEW_LINE INDENT count = currIdx NEW_LINE swapIdx = currIdx NEW_LINE while ( count ) : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE count -= 1 NEW_LINE DEDENT currIdx -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
from heapq import heappush , heappop NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT costs = [ [ float ( " inf " ) for i in range ( n ) ] for i in range ( n ) ] NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT flag , num , lst = map ( int , input ( ) . split ( ) ) NEW_LINE if flag == False : NEW_LINE INDENT continue NEW_LINE DEDENT if lst [ num - 1 ] [ num - 1 ] == 1 : NEW_LINE INDENT costs [ num - 1 ] [ num - 1 ] = lst [ num - 1 ] [ num ] NEW_LINE for x in range ( num - 1 , num ) : NEW_LINE INDENT if costs [ x ] [ y ] > costs [ y ] [ x ] + costs [ x ] [ y ] : NEW_LINE INDENT heappush ( costs , ( costs [ y ] [ x ] , y ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( costs [ num - 1 ] [ num - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countCharacterType ( str ) : NEW_LINE INDENT vowels , consonant , digit = 0 , 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : ▁ " , vowels ) NEW_LINE print ( " Consonant : ▁ " , consonant ) NEW_LINE print ( " Digit : ▁ " , digit ) NEW_LINE print ( " Special ▁ Character : ▁ " , specialChar ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeks ▁ for ▁ geeks121" NEW_LINE countCharacterType ( str ) NEW_LINE DEDENT
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) ; NEW_LINE  percentInc -= 1 ; NEW_LINE percentInc *= 100 ; NEW_LINE return percentInc ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 50 ; b = 20 ; h = 10 ; NEW_LINE print ( increaseInVol ( l , b , h ) , " % " ) ; NEW_LINE DEDENT
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and not flag ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = head . prev NEW_LINE new_node . next = head NEW_LINE ( head ) . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last NEW_LINE prev = None NEW_LINE while ( curr . prev != last ) : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( " Forward ▁ direction : ▁ " , end = " ▁ " , end = " ▁ " ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = " ▁ " , end = " ▁ " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data , end = " ▁ " ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( " \n Backward ▁ direction : ▁ " , end = " ▁ " ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = " ▁ " , end = " ▁ " ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data , end = " ▁ " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head ,
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( n // 10000 ) * 10000 + ( ( n // 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n // 10 ) % 10 ) * 10 + ( n // 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( int ( str ( i ) * ( 100 ** 2 ) ) for i in itertools . count ( 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def sqrt ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( x ** ( 100 * 2 ) > x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = int ( sqrt ( x ) ) NEW_LINE if ( y ** ( 100 * 2 ) == x ) : NEW_LINE INDENT s = str ( y ) [ : 100 ] NEW_LINE if ( s == s ) : NEW_LINE INDENT return str ( s ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def check ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT y = 0 NEW_LINE for i in itertools . count ( 9 ) : NEW_LINE INDENT temp = ( j ** ( i ) ) ** ( i ) NEW_LINE delta = y ** ( 10 ** ( i * 2 ) ) * temp NEW_LINE if ( delta >= x ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j < 0 ) : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT x = x - delta NEW_LINE y = y + ( j ** ( i ) ) * temp NEW_LINE DEDENT return y NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = 1 * n * n // 4 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . " , end = " ▁ " ) NEW_LINE print ( n , " ▁ " , var - 1 , " ▁ " , var + 1 , " ▁ " ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = 1 * n * n + 1 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . " , end = " ▁ " ) NEW_LINE print ( n , " ▁ " , var // 2 - 1 , " ▁ " , var // 2 , " ▁ " ) NEW_LINE DEDENT DEDENT n = 22 NEW_LINE  evaluate ( n ) NEW_LINE
a , b , x = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE if x == 0 : NEW_LINE INDENT print ( b // x ) NEW_LINE DEDENT else : NEW_LINE INDENT if a < b : NEW_LINE INDENT print ( b // x + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + a // x + 1 NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 for i in range ( K ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( X : str , Y : str , Z : str ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( Z , X , Y ) ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ' , ' ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE X = next ( tokens ) NEW_LINE Y = next ( tokens ) NEW_LINE Z = next ( tokens ) NEW_LINE solve ( X , Y , Z ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def check ( x ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] != x [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ t ] : NEW_LINE INDENT t = 1 NEW_LINE DEDENT l = max ( l , i + 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ t - 1 ] : NEW_LINE INDENT r = i NEW_LINE DEDENT DEDENT print ( l , r ) NEW_LINE
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are " , countSubarrays ( arr , n ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE SIZE = 26 ; NEW_LINE def printChar ( str , n ) : NEW_LINE INDENT freq = np . zeros ( SIZE ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " ; NEW_LINE n = len ( str ) ; NEW_LINE printChar ( str , n ) ; NEW_LINE DEDENT
def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( countGreater ( arr , n , k ) ) NEW_LINE DEDENT
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE dp = [ [ 0 ] * W for _ in range ( H ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for h in range ( H ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT for x in range ( H ) : NEW_LINE INDENT if h == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT dp [ 0 ] [ w ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ h + 1 ] [ w ] = ( dp [ h ] [ w ] + dp [ h ] [ w - 1 ] ) % MOD NEW_LINE DEDENT DEDENT elif h == 0 : NEW_LINE INDENT dp [ h + 1 ] [ w ] = ( dp [ h ] [ w ] + dp [ h ] [ w - 1 ] ) % MOD NEW_LINE DEDENT else : NEW_LINE INDENT dp [ h + 1 ] [ w ] = dp [ h ] [ w ] * 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( dp [ H ] [ W - 1 ] ) NEW_LINE
from math import * NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l1 = set ( ) NEW_LINE l2 = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k , t = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 . add ( k ) NEW_LINE l2 . add ( t ) NEW_LINE DEDENT if len ( l1 ) == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( l1 ) - max ( l2 ) ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " X " : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT s1 = list ( input ( ) ) NEW_LINE if s1 == [ "0" ] : NEW_LINE INDENT break NEW_LINE DEDENT s2 = list ( input ( ) ) NEW_LINE s1 . reverse ( ) NEW_LINE s2 . reverse ( ) NEW_LINE N = len ( s1 ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE dp = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if s1 [ i ] == " ? " : NEW_LINE INDENT if j != 0 : NEW_LINE INDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j - 1 ] NEW_LINE dp [ i + 1 ] [ j ] %= MOD NEW_LINE DEDENT elif j != 0 : NEW_LINE INDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j - 1 ] NEW_LINE dp [ i + 1 ] [ j ] %= MOD NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j ] NEW_LINE dp [ i + 1 ] [ j ] %= MOD NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j - 1 ] NEW_LINE dp [ i + 1 ] [ j ] %= MOD NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] [ MOD ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE count += 1 NEW_LINE DEDENT while n % 3 == 0 : NEW_LINE INDENT n //= 3 NEW_LINE count += 1 NEW_LINE DEDENT if count > 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT
def minIncrementForUnique ( A ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in range ( 0 , len ( A ) , 1 ) : NEW_LINE INDENT mpp [ i ] = mpp . get ( i , 0 ) + 1 NEW_LINE DEDENT taken = [ ] NEW_LINE ans = 0 NEW_LINE for x in range ( 0 , 100000 , 1 ) : NEW_LINE INDENT if ( mpp [ x ] and mpp [ x ] >= 2 ) : NEW_LINE INDENT taken . append ( x * ( mpp [ x ] - 1 ) ) NEW_LINE DEDENT elif ( len ( taken ) > 0 and ( ( mpp [ x ] and mpp [ x ] == 0 ) or not mpp [ x ] ) ) : NEW_LINE INDENT ans += x - taken [ len ( taken ) - 1 ] NEW_LINE del taken [ len ( taken ) - 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 3 , 2 , 1 , 2 , 1 , 7 ] NEW_LINE print ( minIncrementForUnique ( A ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pow ( 3 , n - 1 , 1000003 ) ) NEW_LINE DEDENT
MOD = 10 ** 9 + 7 NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 13 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ 5 ] NEW_LINE DEDENT s = " ? 44" NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE
from math import gcd , sqrt NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // c NEW_LINE y = b // d - ( a - 1 ) // d NEW_LINE k = ( c * d ) // gcd ( c , d ) NEW_LINE z = b // k - ( a - 1 ) // k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 10 , 50 , 4 , 6 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE DEDENT
import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = math . log10 ( n ) NEW_LINE d = ( math . pow ( 10 , s ) + 0.5 ) NEW_LINE k = d NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d ) : NEW_LINE INDENT print ( int ( n / d ) ) NEW_LINE d = int ( d / 10 ) NEW_LINE DEDENT n = n % k NEW_LINE k = k // 10 NEW_LINE d = k NEW_LINE DEDENT DEDENT n = 123 NEW_LINE printSubstrings ( n ) NEW_LINE
def NthCharacter ( n ) : NEW_LINE INDENT s = " " ; NEW_LINE c = 1 ; NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( c < 10 ) : NEW_LINE INDENT s += str ( c ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " ; NEW_LINE dup = c ; NEW_LINE while ( dup ) : NEW_LINE INDENT s1 += str ( dup % 10 ) ; NEW_LINE dup //= 10 ; NEW_LINE DEDENT s += s1 ; NEW_LINE DEDENT c += 1 ; NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return ord ( s [ n - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 ; NEW_LINE print ( NthCharacter ( n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT i , m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if d < 2 : NEW_LINE INDENT t = ( d - 1 ) * 20 + 1200 NEW_LINE DEDENT else : NEW_LINE INDENT t = ( d - 1 ) * 200 + 1400 NEW_LINE DEDENT print ( t // 3 * d + ( 1 if t % 3 else 0 ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimeFrequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m . get ( s [ i ] , 0 ) + 1 NEW_LINE DEDENT for it in m : NEW_LINE INDENT if ( check_prime ( m [ it ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( countPrimeFrequent ( s ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] < a [ ans ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 ] * ( n + 2 ) ; NEW_LINE catalan [ 0 ] = 1 ; NEW_LINE catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT return catalan [ n ] ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = " ▁ " ) ; NEW_LINE DEDENT
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totient = 1 NEW_LINE denominator = 1 NEW_LINE for p in itertools . count ( 2 ) : NEW_LINE INDENT totient = totient * ( p - 1 ) NEW_LINE denominator = denominator * p NEW_LINE p += 1 NEW_LINE while not eulerlib . is_prime ( p ) : NEW_LINE INDENT p += 1 NEW_LINE DEDENT if ( fractions . Fraction ( totient , denominator ) < TARGET ) : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numerator = i * totient NEW_LINE denominator = i * denominator NEW_LINE if ( fractions . Fraction ( numer , denom - 1 ) < TARGET ) : NEW_LINE INDENT return str ( denom ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE x , y = 0 , 0 NEW_LINE for i in s : NEW_LINE INDENT if i == ' L ' : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT elif i == ' R ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif i == ' U ' : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif i == ' D ' : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT DEDENT if x == 0 or y == 0 : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' BUG ' ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( N ) : NEW_LINE INDENT if ( isPrime ( N ) and isPrime ( N - 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE if ( isPossible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res // ( n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is " , countDyckPaths ( n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 30 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif n == 31 : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( "6 ▁ 10 ▁ 15" ) NEW_LINE DEDENT elif n == 40 : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( "10 ▁ 15" ) NEW_LINE DEDENT elif n == 44 : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( "6 ▁ 10 ▁ 40" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def gcd ( x , y ) : NEW_LINE INDENT p = min ( x , y ) NEW_LINE q = max ( x , y ) NEW_LINE while p != q : NEW_LINE INDENT if q > p : NEW_LINE INDENT q = q - p NEW_LINE DEDENT else : NEW_LINE INDENT p = p - q NEW_LINE DEDENT DEDENT return q NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = sorted ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE while len ( a ) > 1 : NEW_LINE INDENT p = a [ 0 ] NEW_LINE q = a [ 1 ] NEW_LINE g = gcd ( p , q ) NEW_LINE a . append ( p * q // g ) NEW_LINE a . pop ( 0 ) NEW_LINE a . pop ( 0 ) NEW_LINE a = sorted ( a ) NEW_LINE DEDENT print ( * a ) NEW_LINE
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] -= a [ i ] % 2 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT ans += a [ i ] // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += a [ i ] // 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.73 * a NEW_LINE return d NEW_LINE DEDENT a = 9 NEW_LINE print ( hexDiagonal ( a ) ) NEW_LINE
def translate ( string ) : NEW_LINE INDENT l = len ( string ) ; NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT i = 0 ; NEW_LINE j = 0 ; NEW_LINE while ( j < l ) : NEW_LINE INDENT if ( string [ j ] == ' A ' and string [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 ; NEW_LINE i += 1 ; NEW_LINE string [ i ] = ' C ' ; NEW_LINE i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT string [ i ] = string [ j ] ; NEW_LINE i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( j == l - 1 ) : NEW_LINE INDENT string [ i ] = string [ j ] ; NEW_LINE i += 1 ; NEW_LINE string [ i ] = ' ▁ ' ; NEW_LINE string [ l - 1 ] = ' ▁ ' ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " helloAB worldABGfG " ; NEW_LINE string = list ( string ) ; NEW_LINE  translate ( string ) ; NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; NEW_LINE print ( string ) ; NEW_LINE DEDENT
def translate ( string ) : NEW_LINE INDENT for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( string [ i - 1 ] == ' A ' and string [ i ] == ' B ' ) : NEW_LINE INDENT string [ i - 1 ] = ' C ' ; NEW_LINE for j in range ( i , len ( string ) - 1 ) : NEW_LINE INDENT string [ j ] = string [ j + 1 ] ; NEW_LINE DEDENT string [ j ] = ' ▁ ' ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " helloAB worldABGfG " ; NEW_LINE string = list ( string ) ; NEW_LINE  translate ( string ) ; NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; NEW_LINE print ( string ) ; NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 2000 NEW_LINE count = 2 NEW_LINE for ring in itertools . count ( 2 ) : NEW_LINE INDENT if ring * 12 + 5 > 10 ** 9 : NEW_LINE INDENT raise ArithmeticException ( ) NEW_LINE DEDENT if eulerlib . is_prime ( ring * 6 - 1 ) and eulerlib . is_prime ( ring * 6 + 1 ) and eulerlib . is_prime ( ring * 12 + 5 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if eulerlib . is_prime ( ring * 6 - 1 ) and eulerlib . is_prime ( ring * 6 + 5 ) and eulerlib . is_prime ( ring * 12 - 7 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( a , b + 1 ) : NEW_LINE INDENT if i ** 2 + j ** 2 == a and j ** 2 + c == b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE
def Digits ( n ) : NEW_LINE INDENT largest = 0 ; NEW_LINE smallest = 9 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 ; NEW_LINE largest = max ( r , largest ) ; NEW_LINE smallest = min ( r , smallest ) ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT print ( largest , smallest ) ; NEW_LINE DEDENT n = 2346 ; NEW_LINE Digits ( n ) ; NEW_LINE
def solve ( d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , d2 , d3 ) NEW_LINE sum = ( d1 + d2 + d3 ) NEW_LINE if ( 2 * maxx > sum or sum % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT x1 , y1 = 0 , 0 NEW_LINE x2 , y2 = d1 , 0 NEW_LINE x3 = ( d1 + d2 - d3 ) // 2 NEW_LINE y3 = ( d2 + d3 - d1 ) // 2 NEW_LINE print ( " ( " , x1 , " , " , y1 , " ) , ▁ ( " , x2 , " , " , y2 , " ) ▁ and ▁ ( " , x3 , " , " , y3 , " ) " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d1 = 3 NEW_LINE d2 = 4 NEW_LINE d3 = 5 NEW_LINE solve ( d1 , d2 , d3 ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def distributingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE string = " aacaab " NEW_LINE if ( distributingBalls ( k , n , string ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . count ( ' M ' ) NEW_LINE b = s . count ( ' T ' ) NEW_LINE if ( a == b or a == c ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE if a [ 0 ] == a [ 1 ] and a [ 2 ] == a [ 3 ] and a [ 4 ] == a [ 5 ] : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] == 0 ) and arr [ mid ] == 1 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] == 0 ) : NEW_LINE INDENT return first ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def rowWith0s ( mat ) : NEW_LINE INDENT max_row_index = 0 NEW_LINE min_row_index = 0 NEW_LINE min = 10 ** 9 NEW_LINE for i in range ( R ) : NEW_LINE INDENT index = first ( mat [ i ] , 0 , C - 1 ) NEW_LINE cntZeroes = 0 NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT cntZeroes = C NEW_LINE DEDENT else : NEW_LINE INDENT cntZeroes = index NEW_LINE DEDENT if ( max < cntZeroes ) : NEW_LINE INDENT max = cntZeroes NEW_LINE max_row_index = i NEW_LINE DEDENT if ( min > cntZeroes ) : NEW_LINE INDENT min = cntZeroes NEW_LINE min_row_index = i NEW_LINE DEDENT DEDENT print ( " Row ▁ with ▁ min ▁ 0s : ▁ " , min_row_index + 1 ) NEW_LINE print ( " Row ▁ with ▁ max ▁ 0s : ▁ " , max_row_index + 1 ) NEW_LINE DEDENT mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE rowWith0s ( mat ) NEW_LINE
def bitAtGivenPosSetOrUnset ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( bitAtGivenPosSetOrUnset ( n , k ) == 1 ) : NEW_LINE INDENT print ( " Set " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unset " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " = = = " ) NEW_LINE DEDENT else : NEW_LINE INDENT s = input ( ) NEW_LINE a = s . count ( " A " ) NEW_LINE b = s . count ( " G " ) NEW_LINE c = s . count ( " C " ) NEW_LINE d = s . count ( " T " ) NEW_LINE ans = [ ] NEW_LINE for i in range ( a // 4 ) : NEW_LINE INDENT for j in range ( b // 4 ) : NEW_LINE INDENT if s [ i ] == " ? " and ( ( s [ i ] == " A " or s [ i ] == " C " ) or s [ i ] == " G " ) or s [ i ] == " T " ) : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT DEDENT DEDENT if len ( ans ) == 0 or a > n or b > n or c > n : NEW_LINE INDENT print ( " = = = " ) NEW_LINE DEDENT else : NEW_LINE INDENT for x in ans : NEW_LINE INDENT if x == " ? " : NEW_LINE INDENT ans . remove ( x ) NEW_LINE DEDENT elif x == " A " : NEW_LINE INDENT ans . remove ( x ) NEW_LINE DEDENT elif x == " C " : NEW_LINE INDENT ans . remove ( x ) NEW_LINE DEDENT elif x == " G " : NEW_LINE INDENT ans . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( x ) NEW_LINE DEDENT DEDENT DEDENT print ( " = = = " . join ( ans ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT from sys import stdin NEW_LINE f_i = stdin NEW_LINE ans = [ 0 ] * 10 NEW_LINE while True : NEW_LINE INDENT n = int ( f_i . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s , t , e , l = map ( str , f_i . readline ( ) . split ( ) ) NEW_LINE if s == ' A ' : NEW_LINE INDENT s , t , l = map ( str , f_i . readline ( ) . split ( ) ) NEW_LINE DEDENT elif s == ' B ' : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT ans [ s ] = 1.0 NEW_LINE DEDENT elif l == 1 : NEW_LINE INDENT ans [ s ] = 0.0 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ s ] = ans [ s ] + solve ( s - 1 , s , l - 1 ) NEW_LINE ans [ s ] = 1.0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if l == 1 : NEW_LINE INDENT ans [ s ] = 1.0 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ s ] = ans [ s - 1 ] * 1.0 + solve ( s - 1 , s , l - 1 ) NEW_LINE ans [ s ] = ans [ s ] * 1.0 + solve ( s - 1 , s , l , 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( ' { : . 12f } ' . format ( ans [ t ] ) ) NEW_LINE DEDENT solve ( ) NEW_LINE
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( ( r - l + 1 ) // 2 ** i for i in range ( 1 , r + 1 ) for j in range ( 1 , r + 1 ) ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( 2 * k + 1 , n ) ) NEW_LINE
def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 , sum2 = 0 , 0 NEW_LINE mul1 , mul2 = 1 , 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if arePermutations ( a , b , n , m ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " characters " NEW_LINE str2 = " alphabets " NEW_LINE findAndPrintUncommonChars ( str1 , str2 ) NEW_LINE DEDENT
def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x , y = 1 , 1 NEW_LINE circle_x , circle_y , rad = 0 , 1 , 2 NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( " Inside " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible = - 1 NEW_LINE minimum = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minimum ) : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if ( largestDivisible == - 1 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) NEW_LINE return min ( sum , sumAfterOperation ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT nth = 0 ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE n = 25 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE n = 25000000 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE n = 250000007 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE DEDENT
from collections import deque NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE A = deque ( [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = input ( ) NEW_LINE if S [ 0 ] == '0' : NEW_LINE INDENT if S [ 2 ] == '0' : NEW_LINE INDENT A . appendleft ( S [ 4 : ] ) NEW_LINE DEDENT elif S [ 2 ] == '1' : NEW_LINE INDENT A . popleft ( ) NEW_LINE DEDENT DEDENT elif S [ 0 ] == '1' : NEW_LINE INDENT print ( A [ int ( S [ 2 : ] ) ] ) NEW_LINE DEDENT elif S [ 0 ] == '2' : NEW_LINE INDENT if S [ 2 ] == '0' : NEW_LINE INDENT A . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n // k + 1 ) : NEW_LINE INDENT if s [ 0 : i + 1 ] == s [ i + 1 : ] : NEW_LINE INDENT print ( s [ : i ] + s [ i + 1 : ] ) NEW_LINE quit ( ) NEW_LINE DEDENT DEDENT print ( s [ : n // k ] ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def printInorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( node . left ) NEW_LINE print ( node . data , end = " ▁ " ) NEW_LINE printInorder ( node . right ) NEW_LINE DEDENT def conBinaryTreeUtil ( pre , preM , preIndex , l , h , size ) : NEW_LINE INDENT if ( preIndex . a >= size or l > h ) : NEW_LINE INDENT return None NEW_LINE DEDENT root = newNode ( pre [ preIndex . a ] ) NEW_LINE preIndex . a += 1 NEW_LINE if ( l == h ) : NEW_LINE INDENT return root NEW_LINE DEDENT i = l NEW_LINE while ( i <= h ) : NEW_LINE INDENT if ( pre [ preIndex . a ] == preM [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i <= h ) : NEW_LINE INDENT root . left = conBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) NEW_LINE root . right = conBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) NEW_LINE DEDENT return root NEW_LINE DEDENT def conBinaryTree ( root , pre , preMirror , size ) : NEW_LINE INDENT preIndex = 0 NEW_LINE preMIndex = 0 NEW_LINE root = conBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) NEW_LINE printInorder ( root ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT preOrder = [ 1 , 2 , 4 , 5 , 3 , 6 , 7 ] NEW_LINE preOrderMirror = [ 1 , 3 , 7 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( preOrder ) NEW_LINE root = newNode ( root ) NEW_LINE conBinaryTree ( root , preOrder , preOrderMirror , size ) NEW_LINE DEDENT
import sys NEW_LINE no_of_chars = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 for i in range ( no_of_chars ) ] NEW_LINE hash_str = [ 0 for i in range ( no_of_chars ) ] NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_pat [ pat [ i ] ] += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if ( start_index == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = " this ▁ is ▁ a ▁ test ▁ string " NEW_LINE pat = " tist " NEW_LINE print ( " Smallest ▁ window ▁ is �
import sys NEW_LINE def angleis ( p1 , p2 ) : NEW_LINE INDENT return True if p1 [ 0 ] * p2 [ 1 ] - p1 [ 1 ] * p2 [ 0 ] > 0 else False NEW_LINE DEDENT Ps = sys . stdin . readlines ( ) NEW_LINE for P in Ps : NEW_LINE INDENT xa , ya , xb , yb , xc , yc , xd , yd = map ( float , P . split ( ) ) NEW_LINE p = [ [ xb - xa , yb - ya ] , [ xc - xb , yc - yb ] , [ xd - xc , yd - yc ] , [ xa - xd , ya - yd ] , [ xb - xa , yb - ya ] ] NEW_LINE a = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT a . append ( angleis ( p [ i ] , p [ i + 1 ] ) ) NEW_LINE DEDENT if a . count ( True ) == 0 or a . count ( True ) == 4 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE stx = input ( ) . split ( ) NEW_LINE d = { } NEW_LINE for i in stx : NEW_LINE INDENT if ( i in d ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT for j in d . keys ( ) : NEW_LINE INDENT if ( d [ j ] ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT DEDENT if n % 2 == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT return ( n == 3 or n == 5 or n == 7 ) NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE i = 0 NEW_LINE while ( i < len ( v ) and n > 0 ) : NEW_LINE INDENT flag , a = 1 , v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 NEW_LINE a = a // 10 NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = sum + v [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = sum ( a ) NEW_LINE if ( e < c ) : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT elif ( e == c ) : NEW_LINE INDENT print ( d ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( e + f ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( l ) ) NEW_LINE
v = [ ] NEW_LINE def memo ( index , evenSum , oddSum , tight ) : NEW_LINE INDENT if ( index == len ( v ) ) : NEW_LINE INDENT if ( evenSum > oddSum ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] NEW_LINE DEDENT limit = v [ index ] if ( tight > 0 ) else 9 NEW_LINE ans = 0 NEW_LINE for d in range ( limit + 1 ) : NEW_LINE INDENT currTight = 0 NEW_LINE if ( d == v [ index ] ) : NEW_LINE INDENT currTight = tight NEW_LINE DEDENT if ( d % 2 != 0 ) : NEW_LINE INDENT ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) NEW_LINE DEDENT DEDENT dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT def CountNum ( n ) : NEW_LINE INDENT v . reverse ( ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT dp = [ [ [ - 1 for i in range ( 180 ) ] for j in range ( 18 ) ] for k in range ( 180 ) ] NEW_LINE return memo ( 0 , 0 , 0 , 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 10 NEW_LINE print ( CountNum ( R ) - CountNum ( L - 1 ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import deque NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def SL ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT x , y , z = IL ( ) NEW_LINE if ( x + y <= 3 ) : NEW_LINE INDENT print ( ' No ' ) NEW_LINE exit ( ) NEW_LINE DEDENT for a , b , c in zip ( x , y , z ) : NEW_LINE INDENT if a + b == c or a + c == b + c or b + c == a + c : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' No ' ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = [ 0 ] * 101 NEW_LINE for x in s . split ( ) : a [ x ] += int ( x ) ; i = 0 NEW_LINE while a [ i ] > 0 and a [ i + 1 ] > 0 : i += 1 NEW_LINE print ( * ( a [ i : ] + a [ i + 1 : ] ) , [ - 1 ] ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def search ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = search ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index " , result ) NEW_LINE DEDENT
n , c = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ 0 ] NEW_LINE y = [ 0 ] NEW_LINE rf = [ 0 ] * ( n + 2 ) NEW_LINE rg = [ 0 ] * ( n + 2 ) NEW_LINE lf = [ 0 ] * ( n + 2 ) NEW_LINE lg = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT X , V = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( X ) NEW_LINE y . append ( V ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT rf [ i + 1 ] = rf [ i ] + x [ i + 1 ] NEW_LINE rg [ i + 1 ] = max ( rg [ i ] , rf [ i + 1 ] - x [ i + 1 ] ) NEW_LINE DEDENT for i in range ( n + 1 , 1 , - 1 ) : NEW_LINE INDENT lf [ i - 1 ] = lf [ i ] + y [ i - 1 ] NEW_LINE lg [ i - 1 ] = max ( lg [ i ] , lf [ i - 1 ] - ( c - x [ i - 1 ] ) ) NEW_LINE DEDENT ans = max ( rg [ n ] , lg [ 1 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = max ( ans , rg [ i ] + lg [ i + 1 ] - x [ i ] , rg [ i ] + lg [ i + 1 ] - ( c - x [ i + 1 ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def unsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 * 8 - 1 ) ) - 1 NEW_LINE num = toggleBitsFromLToR ( num , l , r ) NEW_LINE return ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( unsetBitsInGivenRange ( n , l , r ) ) NEW_LINE
def MinStep ( a , n ) : NEW_LINE INDENT positive , negative , zero = 0 , 0 , 0 NEW_LINE step = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step = step + ( a [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , - 2 , - 1 , - 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinStep ( a , n ) ) NEW_LINE DEDENT
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE if s [ a - 1 ] == s [ b - 1 ] : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ a - 1 ] - s [ b - 1 ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lis = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lis . sort ( ) NEW_LINE print ( lis [ - 1 ] + lis [ - 2 ] ) NEW_LINE DEDENT
from math import gcd , sqrt NEW_LINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) ; NEW_LINE dy = abs ( y2 - y1 ) ; NEW_LINE ans = dx + dy - gcd ( dx , dy ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 = 1 ; y1 = 1 ; x2 = 4 ; y2 = 3 ; NEW_LINE noOfSquares ( x1 , y1 , x2 , y2 ) ; NEW_LINE DEDENT
def get_maximum ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT s = ( chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) + s [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT return " " . join ( s ) NEW_LINE DEDENT DEDENT return " " . join ( s ) NEW_LINE DEDENT s = "1337" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print ( get_maximum ( s , a ) ) NEW_LINE
MAX_DIGITS = 20 NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) >= 8 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if ( isOctal ( n ) == 0 ) else 10 NEW_LINE octal = [ 0 ] * MAX_DIGITS NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal [ i ] = n % divide NEW_LINE i += 1 NEW_LINE n = n // divide NEW_LINE DEDENT j = i - 1 NEW_LINE k = 0 NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 97 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = int ( s [ : n // 2 ] ) NEW_LINE b = int ( s [ n // 2 : ] ) NEW_LINE if a + b == a and a + c == b and a + c == b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE midValue = arr [ mid ] NEW_LINE if ( mid == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , midValue ) NEW_LINE left = binarySearch ( arr , low , leftindex ) NEW_LINE if ( left >= 0 ) : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , midValue ) NEW_LINE right = binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ] NEW_LINE print ( " Fixed ▁ Point ▁ is " , binarySearch ( arr , 0 , len ( arr ) - 1 ) ) NEW_LINE arr1 = [ - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 ] NEW_LINE print ( " Fixed ▁ Point ▁ is " , binarySearch ( arr1 , 0 , len ( arr1 ) - 1 ) ) NEW_LINE
MAX = 10000 ; NEW_LINE prodDig = [ 0 ] * MAX ; NEW_LINE def getDigitProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] ; NEW_LINE DEDENT prod = ( x % 10 ) * getDigitProduct ( x // 10 ) ; NEW_LINE return ( prodDig [ x ] = prod ) ; NEW_LINE DEDENT def findSeed ( n ) : NEW_LINE INDENT res = [ ] ; NEW_LINE for i in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " NO ▁ seed ▁ exists " ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 138 ; NEW_LINE findSeed ( n ) ; NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if x [ i + k - 1 ] <= 0 : NEW_LINE INDENT ans = min ( ans , - x [ i ] ) NEW_LINE DEDENT elif x [ i ] >= 0 : NEW_LINE INDENT ans = min ( ans , x [ i + k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , x [ i + k - 1 ] - x [ i ] + min ( x [ i + k - 1 ] , - x [ i ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) ; NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = n ; NEW_LINE e = 0.0000001 ; NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 ; NEW_LINE error = diff ( n , mid ) ; NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( ( mid * mid * mid ) > n ) : NEW_LINE INDENT end = mid ; NEW_LINE DEDENT else : NEW_LINE INDENT start = mid ; NEW_LINE DEDENT DEDENT DEDENT n = 3 ; NEW_LINE print ( " Cubic ▁ root ▁ of " , n , " is " , cubicRoot ( n ) ) ; NEW_LINE
import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd NEW_LINE from itertools import accumulate , permutations , combinations , product , groupby NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE from bisect import bisect , bisect_left NEW_LINE from fractions import gcd NEW_LINE from heapq import heappush , heappop NEW_LINE from functools import reduce NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE N , M = MAP ( ) NEW_LINE a = LIST ( ) NEW_LINE lis = sorted ( a ) NEW_LINE num = lis [ - 1 ] NEW_LINE for i , j in lis [ : - 1 ] : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT num += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = num // gcd ( a [ i ] , j ) NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if a [ i ] == num : NEW_LINE INDENT ans . append ( str ( a [ i ] ) + " ▁ " + str ( i + 1 ) ) NEW_LINE DEDENT DEDENT print ( " \n " . join ( ans ) ) NEW_LINE
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT prod *= num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result += rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( " x ▁ is " , findMinX ( num , rem , k ) ) NEW_LINE
def sort ( arr ) : NEW_LINE INDENT maxOR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT maxOR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( maxOR | arr [ i ] ) > maxOR ) : NEW_LINE INDENT maxOR = maxOR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sort ( arr ) ) NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 ; NEW_LINE DEDENT return int ( sum ) ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( seriesSum ( n ) ) ; NEW_LINE
def aliquotSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 12 NEW_LINE print ( aliquotSum ( n ) ) NEW_LINE
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE
def fifthPowerSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( fifthPowerSum ( n ) ) ; NEW_LINE
def squaresum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( squaresum ( n ) ) ; NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 ; NEW_LINE DEDENT return int ( sum ) ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( seriesSum ( n ) ) ; NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) // 6 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( fourthPowerSum ( n ) ) ; NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) ; NEW_LINE DEDENT return sum / n ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( AvgofSquareN ( n ) ) ; NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum += remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for base in range ( 2 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT sum += solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT * S , = set ( i for i in range ( 2 , N + 1 ) ) NEW_LINE S . add ( i ) NEW_LINE L = len ( S ) NEW_LINE C = [ 1 ] * N NEW_LINE D = [ 0 ] * ( ( N - 1 ) // 2 ) NEW_LINE for i in range ( L ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if S [ i ] : NEW_LINE INDENT D [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if D [ i ] : NEW_LINE INDENT C [ i ] = 0 NEW_LINE DEDENT DEDENT write ( " % d \n " % C [ i ] ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
print ( bin ( 4 ) . count ( '1' ) ) NEW_LINE print ( bin ( 15 ) . count ( '1' ) ) NEW_LINE
def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE cost [ i ] [ j ] = float ( ' inf ' ) NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT c = ( ( cost [ i ] [ r - 1 ] ) + ( cost [ i ] [ r < j ) ) + Sum ( freq , i , j ) NEW_LINE if ( c < cost [ i ] [ j ] ) : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT def Sum ( freq , i , j ) : NEW_LINE INDENT s = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT if ( k >= n ) : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ k ] NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT keys = [ 10 , 12 , 20 ] NEW_LINE freq = [ 34 , 8 , 50 ] NEW_LINE n = len ( keys ) NEW_LINE print ( " Cost ▁ of ▁ Optimal ▁ BST ▁ is " , optimalSearchTree ( keys , freq , n ) ) NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y , z = 1 , 5 , 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE k = l [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT k = l [ i ] NEW_LINE ans += abs ( k - l [ i - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def maxcoefficientvalue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , ( n + 1 ) // 2 ) ; NEW_LINE DEDENT DEDENT n = 4 ; NEW_LINE print ( maxcoefficientvalue ( n ) ) ; NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abaebio " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE mapp = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE mapp . append ( [ w , h ] ) NEW_LINE DEDENT s , t = map ( int , input ( ) . split ( ) ) NEW_LINE max_diff = 0 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT for j in range ( m - 1 ) : NEW_LINE INDENT diff = 0 NEW_LINE for l in range ( i , s - 1 ) : NEW_LINE INDENT for k in range ( j , t - 1 ) : NEW_LINE INDENT diff += mapp [ l ] [ k ] NEW_LINE DEDENT DEDENT if diff > max_diff : NEW_LINE INDENT max_diff = diff NEW_LINE DEDENT DEDENT DEDENT print ( max_diff ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == M - 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = " for " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Present ▁ at ▁ index " , res ) NEW_LINE DEDENT DEDENT
def angleOncirCumference ( z ) : NEW_LINE INDENT return ( z / 2 ) NEW_LINE DEDENT angle = 65 NEW_LINE z = angleOncirCumference ( angle ) NEW_LINE print ( " The ▁ angle ▁ is " , z , " degrees " ) NEW_LINE
def countSubarraysof1and0 ( a , n ) : NEW_LINE INDENT count1 , count0 = 0 , 0 NEW_LINE number1 , number0 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) // 2 NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) // 2 NEW_LINE count0 = 0 NEW_LINE DEDENT DEDENT if ( count1 > 0 ) : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) // 2 NEW_LINE DEDENT if ( count0 > 0 ) : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) // 2 NEW_LINE DEDENT print ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : ▁ " , number0 ) NEW_LINE print ( " \n Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : ▁ " , number1 ) NEW_LINE DEDENT a = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countSubarraysof1and0 ( a , n ) NEW_LINE
def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT
def printPermutation ( n , k ) : NEW_LINE INDENT mx = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = " ▁ " ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE K = 3 NEW_LINE if ( K >= N - 1 ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for j in l : NEW_LINE INDENT summ += j NEW_LINE DEDENT if summ == summ : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def check ( s1 , s2 ) : NEW_LINE INDENT mp = { s1 : 0 } NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( mp [ s2 [ i ] ] > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = " geeksforgeeks " NEW_LINE s2 = " geeks " NEW_LINE yes_or_no = check ( s1 , s2 ) NEW_LINE if ( yes_or_no == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k1 , k2 , k3 , k5 , k6 = map ( int , input ( ) . split ( ) ) NEW_LINE sum1 = k1 + k2 NEW_LINE sum2 = k3 + k6 NEW_LINE if sum1 < sum2 and n * k1 - sum2 < k3 + k6 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE
N = 3 NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( maxPathSum ( tri , 2 , 2 ) ) NEW_LINE
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( ( n - 2 ) // 2 + 1 ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isHeap ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if ( i > ( n - 2 ) // 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] ; NEW_LINE n = len ( arr ) - 1 ; NEW_LINE if ( isHeap ( arr , 0 , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE from bisect import bisect , bisect_left NEW_LINE from fractions import gcd NEW_LINE from heapq import heappush , heappop NEW_LINE from functools import reduce NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE a , b , c , d = MAP ( ) NEW_LINE c -= a NEW_LINE ans = 0 NEW_LINE if a + b == c : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif a + c == b : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a - c == b - c : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( c - a ) // ( b - c ) NEW_LINE y = ( d - b ) // ( d - c ) NEW_LINE if x * y == a + b * c : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT if ans == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDel ( arr , n ) ) ; NEW_LINE DEDENT
def count ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = dict ( ) NEW_LINE while ( x % y != 0 ) : NEW_LINE INDENT x = x % y NEW_LINE ans += 1 NEW_LINE if x in m . keys ( ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x = x * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT res = count ( 1 , 2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT res = count ( 5 , 3 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT res = count ( 3 , 5 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 ; NEW_LINE DEDENT return ( remainder == 0 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 40 , 50 , 90 ] ; NEW_LINE n = 3 ; NEW_LINE if ( isPossibleToMakeDivisible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
import sys NEW_LINE from collections import deque NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ A [ i ] - 1 ] = i NEW_LINE DEDENT if 0 in B : NEW_LINE INDENT print ( B . index ( 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT q = deque ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if B [ i ] == 0 : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE ans = max ( ans , t - q . popleft ( ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j * j * j == i ) : NEW_LINE INDENT print ( j * j * j , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : " ) NEW_LINE printCubes ( 1 , 100 ) NEW_LINE
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( n , " ▁ moduo " , d , " is " , getModulo ( n , d ) ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE mx = max ( x ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] - d <= 0 : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT x [ i ] = max ( 0 , x [ i ] - d ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = ( n - 1 ) // 2 NEW_LINE b = ( n - 1 ) % 4 NEW_LINE if a == 0 : NEW_LINE INDENT print ( 7 ) NEW_LINE DEDENT elif a == 1 or a == 2 : NEW_LINE INDENT print ( 16 ) NEW_LINE DEDENT elif b == 3 : NEW_LINE INDENT print ( 10 ) NEW_LINE DEDENT elif a == 4 : NEW_LINE INDENT print ( 15 ) NEW_LINE DEDENT elif a == 5 : NEW_LINE INDENT print ( 16 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 7 ) NEW_LINE DEDENT
def isPerfectCube ( x ) : NEW_LINE INDENT x = abs ( x ) NEW_LINE return ( cr * cr * cr == x ) NEW_LINE DEDENT def canBePerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 NEW_LINE K = 1 NEW_LINE canPerfectCube ( N , K ) NEW_LINE N = 5 NEW_LINE K = 4 NEW_LINE canPerfectCube ( N , K ) NEW_LINE N = 7 NEW_LINE K = 2 NEW_LINE canPerfectCube ( N , K ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s , t = input ( ) , input ( ) NEW_LINE a = 2 * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i : i + 2 ] == t : NEW_LINE INDENT a = 2 * n NEW_LINE break NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE
class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFSUtil ( self , v , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( v , end = " ▁ " ) NEW_LINE i = self . adj [ v ] NEW_LINE while i != [ ] : NEW_LINE INDENT v = self . adj [ v ] NEW_LINE i . remove ( v ) NEW_LINE DEDENT for v in i : NEW_LINE INDENT if not visited [ v ] : NEW_LINE INDENT DFSUtil ( v , visited ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE DFSUtil ( self . V , visited ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . DFS ( 2 ) NEW_LINE DEDENT
import math NEW_LINE def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ int ( digit ) ] += 1 NEW_LINE val = int ( val / 10 ) NEW_LINE DEDENT return NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq_count = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = math . pow ( x , i ) NEW_LINE countDigits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if ( a [ n - 1 ] * 2 ) < a [ n - 2 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT b = 0 NEW_LINE DEDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n - 2 NEW_LINE print ( b ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( " I ▁ become ▁ the ▁ guy . " ) NEW_LINE if len ( a ) == n : NEW_LINE INDENT print ( " Oh , ▁ my ▁ keyboard ! " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " I ▁ become ▁ the ▁ guy . " ) NEW_LINE DEDENT
m = 6 NEW_LINE n = 4 NEW_LINE def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT matched = True NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] NEW_LINE row = [ 10 , 9 , 22 , 23 ] NEW_LINE print ( linearCheck ( mat , row ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( w ) % n == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT t = 0 NEW_LINE for i in w : NEW_LINE INDENT if i > t : NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if t // n < 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT DEDENT
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 998244353 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE while True : NEW_LINE INDENT n = I ( ) NEW_LINE a = LI ( ) NEW_LINE b = LI ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while l < n : NEW_LINE INDENT tr = b // 2 NEW_LINE c = b % 2 NEW_LINE if c > r : NEW_LINE INDENT r = c NEW_LINE DEDENT for i in range ( l + 1 , min ( l + 1 , r + 1 ) ) : NEW_LINE INDENT tr = b NEW_LINE DEDENT if r == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( l + 1 , min ( r + 1 , c + 1 ) ) : NEW_LINE INDENT tr = b NEW_LINE DEDENT DEDENT rr . append ( ' { :0.9f } ' . format ( r ) ) NEW_LINE break NEW_LINE DEDENT return ' \n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return n ** 2 + 2 * n + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return n ** 2 - 2 * n + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT c = abs ( a ) + abs ( b ) NEW_LINE print ( c , ' ▁ - ' , c , ' ▁ ' , c ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT d = abs ( a ) + abs ( b ) NEW_LINE print ( d , ' ▁ - ' , d , ' ▁ ' , d ) NEW_LINE DEDENT else : NEW_LINE INDENT e = abs ( a ) + abs ( b ) NEW_LINE print ( e , ' ▁ ' , e , ' ▁ ' , d ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE k = int ( input ( ) ) NEW_LINE s += ' ? ' * k NEW_LINE N = len ( s ) NEW_LINE res = ' ' NEW_LINE for i in range ( N ) : NEW_LINE INDENT if s [ i : i + K ] not in res : NEW_LINE INDENT res = s [ i : i + K ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def fib ( self , N ) : NEW_LINE INDENT if N < len ( memo ) : NEW_LINE INDENT return memo [ N ] NEW_LINE DEDENT for i in range ( N + 1 , N + 1 ) : NEW_LINE INDENT memo . append ( memo [ i - 1 ] + memo [ i - 2 ] ) NEW_LINE DEDENT return memo [ N ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE N = 2 NEW_LINE out = sObj . fib ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = input ( ) , input ( ) NEW_LINE n = len ( a ) NEW_LINE lst = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == " a " : NEW_LINE INDENT lst . append ( i ) NEW_LINE DEDENT elif a [ i ] == " b " : NEW_LINE INDENT lst . append ( i ) NEW_LINE DEDENT elif a [ i ] == " c " : NEW_LINE INDENT lst . append ( i ) NEW_LINE DEDENT DEDENT if len ( lst ) == 2 : NEW_LINE INDENT if lst [ 0 ] > lst [ 1 ] : NEW_LINE INDENT print ( lst [ 0 ] * 26 + lst [ 1 ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( lst [ 0 ] * 26 + lst [ 1 ] * 26 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if lst [ i ] > lst [ i - 1 ] : NEW_LINE INDENT ans += chr ( ord ( lst [ i - 1 ] ) + lst [ i ] ) NEW_LINE lst [ i ] -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( lst ) - 1 ) : NEW_LINE INDENT if lst [ i ] > lst [ i + 1 ] : NEW_LINE INDENT ans += chr ( ord ( lst [ i ] ) - lst [ i - 1 ] ) NEW_LINE lst [ i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT ans = ans [ : : - 1 ] NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
import math NEW_LINE PI = 3.142 NEW_LINE def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 50 NEW_LINE n = 5 NEW_LINE print ( round ( cosXSertiesSum ( x , 5 ) * 1000000 ) / 1000000.00 ) NEW_LINE DEDENT
def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( float ( N ) * ( N + 1 ) ) / 4 ) - ( float ( S + 1 ) / 2 ) ) NEW_LINE return i NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) NEW_LINE integerI = int ( i ) NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( " Yes : " , integerI , " , " , ( integerI + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE S = 3 NEW_LINE check ( N , S ) NEW_LINE N = 5 NEW_LINE S = 3 NEW_LINE check ( N , S ) NEW_LINE DEDENT
def multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE sum = dig0 + dig1 NEW_LINE if ( K == 2 ) : NEW_LINE INDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum += temp NEW_LINE numberofGroups = ( K - 3 ) // 4 NEW_LINE remNumberofDigits = ( K - 3 ) % 4 NEW_LINE sum += ( numberofGroups * 20 ) NEW_LINE for i in range ( remNumberofDigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 5 NEW_LINE dig0 = 3 NEW_LINE dig1 = 4 NEW_LINE if ( multipleOfThree ( K , dig0 , dig1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_val = max ( a ) NEW_LINE min_val = min ( b ) NEW_LINE if sum ( a ) < sum_val + min_val : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif sum ( b ) > sum_val and min_val - max_val < min_val : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
def countOcc ( s ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT c = 0 ; l = 0 ; a = 0 ; p = 0 ; NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT if ( s [ j ] == ' c ' ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT if ( s [ j ] == ' l ' ) : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT if ( s [ j ] == ' a ' ) : NEW_LINE INDENT a += 1 ; NEW_LINE DEDENT if ( s [ j ] == ' p ' ) : NEW_LINE INDENT p += 1 ; NEW_LINE DEDENT DEDENT if ( c == 1 and l == 1 and a == 1 and p == 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " clapc " ; NEW_LINE print ( countOcc ( s . lower ( ) ) ) ; NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return x // y NEW_LINE DEDENT return x // y + countSteps ( y , x % y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y = 100 , 19 NEW_LINE print ( countSteps ( x , y ) ) NEW_LINE DEDENT
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSunnyNum ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE if ( isSunnyNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = 3 NEW_LINE B = 4 NEW_LINE H = 5 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT alphabets = { } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s , t = input ( ) . split ( ) NEW_LINE alphabets [ s ] = t NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT t = input ( ) NEW_LINE print ( alphabets [ t ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def getCount ( v , n ) : NEW_LINE INDENT v . sort ( ) ; NEW_LINE cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - bisect ( v , n , v [ i ] - 1 ) ; NEW_LINE if ( tmp == v [ i ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def upperBound ( array , length , value ) : NEW_LINE INDENT low = 0 ; NEW_LINE high = length ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) ; NEW_LINE if ( value >= array [ mid ] ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return low ; NEW_LINE DEDENT n = 4 ; NEW_LINE v = [ 1 , 2 , 3 , 4 ] ; NEW_LINE print ( getCount ( v , n ) ) ; NEW_LINE
def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two , count_of_five = 0 , 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i ; NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val = int ( val / 2 ) ; NEW_LINE count_of_two += i ; NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val = int ( val / 5 ) ; NEW_LINE count_of_five += i ; NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 ; NEW_LINE print ( trailing_zeros ( N ) ) ; NEW_LINE DEDENT
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 106 NEW_LINE if ( isEqual ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , name , val ) : NEW_LINE INDENT self . name = name NEW_LINE self . val = val NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class V : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE self . next = None NEW_LINE DEDENT def __lt__ ( self , value ) : NEW_LINE INDENT return self . value < value . next NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return self . value > value . next NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE V = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT s = input ( ) . strip ( ) NEW_LINE V . append ( Node ( s ) ) NEW_LINE DEDENT V . sort ( ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE data = [ ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT p , c = V [ i + 1 ] . split ( ) NEW_LINE data . append ( Node ( c ) ) NEW_LINE DEDENT def dfs ( node , now ) : NEW_LINE INDENT if node == N : NEW_LINE INDENT return now NEW_LINE DEDENT if node . next is None : NEW_LINE INDENT return 1 NEW_LINE DEDENT data [ node . name ] . next = now NEW_LINE data [ node . next ] . next = dfs ( node , now + 1 ) NEW_LINE if node . next is None : NEW_LINE INDENT data [ node . name ] = data [ node . next ] NEW_LINE DEDENT return data [ node . value ] NEW_LINE DEDENT next = V [ N - 1 ] . next NEW_LINE data = [ V [ N - 2 ] for n in range ( N - 1 ) ] NEW_LINE now = defaultdict ( list ) NEW_LINE for l , r in data : NEW_LINE INDENT if ' A ' == l : NEW_LINE INDENT if len ( now ) == 2 : NEW_LINE INDENT next [ l - 1 ] . append ( node . value ) NEW_LINE DEDENT else : NEW_LINE INDENT next [ l - 1 ] . append ( node . next ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( now ) == 2 : NEW_LINE INDENT next [ l - 1 ] = data [ now [ 0 ] ] . next NEW_LINE data [ l - 1 ] . next = data [ now [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT next [ l - 1 ] = data [ now [ 0 ] ] . next NEW_LINE data [ l - 1 ] . next = data [ now [ 1 ]
n = input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( l [ int ( n / 2 ) - 1 ] ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT c = a - b NEW_LINE c = b - a NEW_LINE print ( c , c ) NEW_LINE DEDENT else : NEW_LINE INDENT c = a // 2 + b // 2 NEW_LINE print ( c , c ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( n // m , end = " ▁ " ) NEW_LINE for i in range ( 1 , n - m ) : NEW_LINE INDENT if i % m == 0 : NEW_LINE INDENT print ( i // m , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i // m + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 for i in range ( 7 ) ] ; NEW_LINE arr2 = [ 0 for i in range ( 7 ) ] ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( s1 [ i ] ) . count ( '1' ) ; NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( s2 [ i ] ) . count ( '1' ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeks " ; NEW_LINE s2 = " forgeeks " ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT
def countSubSeq ( i , sum , cnt , a , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 and cnt > 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE ans += countSubSeq ( i + 1 , sum , cnt , a , n ) ; NEW_LINE ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 1 , 2 , - 2 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( countSubSeq ( 0 , 0 , 0 , a , n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s1 = " " NEW_LINE i = 0 NEW_LINE n = n >> 1 NEW_LINE ans = " " NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT ans = s1 [ n - i - 1 ] + ans NEW_LINE n -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = s1 [ n - i ] + ans NEW_LINE n -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
a , n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i , n + 1 ) : NEW_LINE INDENT if i ** j >= m : NEW_LINE INDENT cnt += i ** j NEW_LINE DEDENT DEDENT if cnt == n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivotedBinarySearch ( arr , 0 , n - 1 ) NEW_LINE if ( pivot == - 1 ) : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if ( arr [ pivot ] == key ) : NEW_LINE INDENT return pivot NEW_LINE DEDENT if ( arr [ 0 ] <= key ) : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low ; NEW_LINE DEDENT mid = ( low + high ) // 2 ; NEW_LINE if ( mid < high and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return ( mid - 1 ) ; NEW_LINE DEDENT if ( arr [ low ] >= arr [ mid ] ) : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) ; NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) ; NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT mid = ( low + high ) // 2 ; NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ; NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) ; NEW_LINE key = 3 NEW_LINE print ( " Index ▁ of ▁ the ▁ element ▁ is ▁ : " , pivotedBinarySearch ( arr1 , n , key ) ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def inpl ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def mod ( x , mod = 10 ** 9 + 7 ) : NEW_LINE INDENT return pow ( x , mod - 2 , mod ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT num = inpl ( ) NEW_LINE print ( ( sum ( num ) - 1 ) * ( sum ( num [ : i ] ) + sum ( num [ i : ] ) ) % mod ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ [ i , 0 ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE ans = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == a [ j ] [ 0 ] : NEW_LINE INDENT ans . append ( j + 1 ) NEW_LINE count += 1 NEW_LINE a [ i ] [ 1 ] = a [ j ] [ 1 ] NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE for i in ans : NEW_LINE INDENT print ( * i ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE d = int ( s [ 0 ] ) NEW_LINE for i in range ( 1 , d ) : NEW_LINE INDENT n = int ( s [ i ] ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n // 2 NEW_LINE h = n % 4 NEW_LINE if h == 0 : NEW_LINE INDENT if b - 1 < 0 : NEW_LINE INDENT b = 0 NEW_LINE DEDENT if h == 1 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT h -= 1 NEW_LINE DEDENT if h == 2 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT if h == 3 : NEW_LINE INDENT print ( ' ▁ ' * b ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = [ ] NEW_LINE for _ in range ( 4 ) : NEW_LINE INDENT c = 0 NEW_LINE for _ in range ( 4 ) : NEW_LINE INDENT b . append ( s - c ) NEW_LINE DEDENT if int ( b ) != 1 : NEW_LINE INDENT a . append ( int ( b ) ) NEW_LINE DEDENT DEDENT print ( ' ▁ ' * a + ' # ' + ' ▁ ' * b + ' # ' * ( d - 2 ) + ' # ' * b ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( int ( bin ( i ) . count ( '1' ) ) for i in range ( 1 << 10 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_arrangement_valid ( a , b ) : NEW_LINE INDENT if ( testBit ( a , 6 ) or testBit ( a , 9 ) ) : NEW_LINE INDENT a |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT if ( testBit ( b , 6 ) or testBit ( b , 9 ) ) : NEW_LINE INDENT b |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT for sqr in SQUARES : NEW_LINE INDENT if ( not ( testBit ( a , sqr [ 0 ] ) and testBit ( b , sqr [ 1 ] ) or testBit ( a , sqr [ 0 ] ) and testBit ( b , sqr [ 1 ] ) and testBit ( b , sqr [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE graph = { } NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE v = t [ 0 ] NEW_LINE k = t [ 1 ] NEW_LINE graph [ v ] = [ t [ i + 2 ] for i in range ( k ) ] NEW_LINE DEDENT for node in range ( 1 , n ) : NEW_LINE INDENT for ans in graph [ node ] : NEW_LINE INDENT ans . append ( node ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT l = [ ] NEW_LINE if ' a ' not in s : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( m - 1 ) : NEW_LINE INDENT left = [ ] NEW_LINE right = [ ] NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT temp = s [ i + k ] [ j ] NEW_LINE if temp == ' a ' : NEW_LINE INDENT left . append ( i ) NEW_LINE DEDENT elif temp == ' c ' : NEW_LINE INDENT right . append ( j ) NEW_LINE DEDENT DEDENT if len ( left ) == 0 or len ( right ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( m - 1 ) : NEW_LINE INDENT tmp = left [ k ] NEW_LINE if tmp == ' a ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif tmp == ' c ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == 4 : NEW_LINE INDENT print ( count ) NEW_LINE break NEW_LINE DEDENT DEDENT if count == 5 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT
s = input ( ) NEW_LINE stk = [ ] NEW_LINE cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if stk and c == stk [ - 1 ] : NEW_LINE INDENT stk . pop ( ) NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( c ) NEW_LINE DEDENT DEDENT print ( ' Yes ' if cnt == len ( stk ) else ' No ' ) NEW_LINE
from collections import defaultdict NEW_LINE import queue NEW_LINE N , M , E = map ( int , input ( ) . split ( ) ) NEW_LINE ab = [ ] NEW_LINE d = defaultdict ( list ) NEW_LINE for i in range ( E ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ab . append ( ( a , b ) ) NEW_LINE d [ a ] . append ( b ) NEW_LINE d [ b ] . append ( a ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT d [ i ] . sort ( ) NEW_LINE v = set ( ) NEW_LINE for j in ab : NEW_LINE INDENT if not d [ j ] : NEW_LINE INDENT d [ j ] = i NEW_LINE v . add ( j ) NEW_LINE DEDENT DEDENT if i in v : NEW_LINE INDENT ans += 1 NEW_LINE d [ i ] = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
MAX = 100 NEW_LINE def countMountains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for i in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( ( i == 0 ) or ( j == 0 ) or ( i == n + 1 ) or ( j == n + 1 ) ) : NEW_LINE INDENT A [ i ] [ j ] = float ( " - inf " ) NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE n = 3 NEW_LINE print ( countMountains ( a , n ) ) NEW_LINE
N = 100005 NEW_LINE d = [ 0 ] * N ; NEW_LINE pre = [ 0 ] * N ; NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT j = 1 ; NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 ; NEW_LINE DEDENT DEDENT j += 1 ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT pre [ i ] = ans ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Positive_Divisors ( ) ; NEW_LINE n = 15 ; NEW_LINE print ( pre [ n ] ) ; NEW_LINE DEDENT
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE hands = [ 0 ] * m NEW_LINE for _ in range ( n ) : NEW_LINE INDENT hands [ _ ] = int ( input ( ) ) NEW_LINE DEDENT left = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT if hands [ _ ] == " a " : NEW_LINE INDENT left += 1 NEW_LINE DEDENT elif hands [ _ ] == " e " : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = 0 NEW_LINE DEDENT if left + n <= 0 : NEW_LINE INDENT print ( " ILLEGAL _ ERASE _ ARGUMENT " ) NEW_LINE DEDENT elif hands [ _ ] == " defragment " : NEW_LINE INDENT hands [ left ] = 0 NEW_LINE for _ in range ( left + n ) : NEW_LINE INDENT hands [ _ ] = hands [ _ ] + hands [ _ + n ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " ILLEGAL _ ERASE _ ARGUMENT " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
from math import tan NEW_LINE def area_of_regular_polygon ( n , Len ) : NEW_LINE INDENT P = ( Len * n ) NEW_LINE A = Len / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , Len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , Len ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) NEW_LINE return ins_tri NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE Len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , Len ) , 3 ) ) NEW_LINE DEDENT
MAX = 256 NEW_LINE def lastNonRepeating ( str , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( freq [ ch ] == 1 ) : NEW_LINE INDENT return ( " " + str [ ch ] ) NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE n = len ( str ) NEW_LINE print ( lastNonRepeating ( str , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == b [ i ] [ 0 ] and a [ i ] [ 1 ] == b [ i ] [ 1 ] : NEW_LINE INDENT c = i + 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT def BooleRule ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = ( b - a ) / n NEW_LINE sum = 0 NEW_LINE bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " f ( x ) ▁ = ▁ { 0 : . 4f } " . format ( BooleRule ( 0 , 4 ) ) ) NEW_LINE DEDENT
maxN = 300 NEW_LINE maxM = 300 NEW_LINE dp = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE v = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] * [ maxN ] ; NEW_LINE v = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] ; NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 3 ; NEW_LINE ans = findLen ( arr , 0 , 0 , n , m ) ; NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : break NEW_LINE to = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( n - 1 ) : NEW_LINE INDENT x , y , z = line [ 2 * j : 2 * j + 2 ] NEW_LINE to . append ( ( x , y , z ) ) NEW_LINE DEDENT DEDENT order = [ ] NEW_LINE used = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT order . append ( False ) NEW_LINE DEDENT for group in to : NEW_LINE INDENT if group [ i ] : used [ group ] = True NEW_LINE elif group [ i ] : used [ group [ i ] ] = True NEW_LINE DEDENT order . reverse ( ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT global used NEW_LINE if used [ v ] : return False NEW_LINE used [ v ] = True NEW_LINE for inds in group : NEW_LINE INDENT dfs ( inds ) NEW_LINE DEDENT DEDENT order . reverse ( ) NEW_LINE def dfs2 ( ind ) : NEW_LINE INDENT if used [ v ] : return False NEW_LINE if x in group : return True NEW_LINE group [ v ] = True NEW_LINE return dfs2 ( ind + 1 ) NEW_LINE DEDENT used = [ False ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in order : NEW_LINE INDENT group = [ ] NEW_LINE if not used [ i ] : NEW_LINE INDENT if dfs2 ( i ) : ans += 1 NEW_LINE DEDENT for g in group : used [ g ] = True NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ - 1 * int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def main ( ) : NEW_LINE INDENT S = II ( ) NEW_LINE ans = 0 NEW_LINE from collections import defaultdict NEW_LINE posd = defaultdict ( lambda : 0 ) NEW_LINE for i , c in enumerate ( S ) : NEW_LINE INDENT posd [ c ] += 1 NEW_LINE DEDENT def posd2 ( x ) : NEW_LINE INDENT if posd [ x ] > 0 : NEW_LINE INDENT posd [ x ] -= 1 NEW_LINE DEDENT return posd [ x ] + 1 NEW_LINE DEDENT def posd3 ( x ) : NEW_LINE INDENT posd = [ 0 ] * len ( S ) NEW_LINE for i , j in enumerate ( S ) : NEW_LINE INDENT posd [ i + 1 ] += posd [ j ] NEW_LINE DEDENT return posd NEW_LINE DEDENT def posd2 ( x ) : NEW_LINE INDENT if posd [ x ] > 0 : NEW_LINE INDENT return posd2 ( x ) NEW_LINE DEDENT if posd [ x ] > 0 : NEW_LINE INDENT return posd2 ( x ) NEW_LINE DEDENT DEDENT def posd7 ( x ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( S ) : NEW_LINE INDENT pos += 1 NEW_LINE x = S [ posd ] NEW_LINE if x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif x == 2 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif x == 3 : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif x == 4 : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif x == 5 : NEW_LINE INDENT return 5 NEW_LINE DEDENT elif x == 7 : NEW_LINE INDENT return 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 7 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = II ( ) NEW_LINE print ( main ( ) ) NEW_LINE DEDENT
import sys NEW_LINE def minDiff ( arr , n , k ) : NEW_LINE INDENT result = sys . maxsize ; NEW_LINE arr . sort ( ) ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE print ( minDiff ( arr , n , k ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = a [ 0 ] NEW_LINE d = a [ 1 ] NEW_LINE e = a [ 2 ] NEW_LINE f = a [ 3 ] NEW_LINE g = a [ 4 ] NEW_LINE h = a [ 5 ] NEW_LINE i = a [ 6 ] NEW_LINE j = a [ 7 ] NEW_LINE k = a [ 8 ] NEW_LINE if k >= d and k <= e : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( ( n - 1 ) // 2 + 1 ) NEW_LINE DEDENT
def Mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum / n NEW_LINE DEDENT def meanAbsDevtion ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsDevtion ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = count ( 0 , 1 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT primes = eulerlib . list_primes ( 100 ) NEW_LINE def count ( primeIndex , product ) : NEW_LINE INDENT if primeIndex == len ( primes ) : NEW_LINE INDENT return 1 if product <= LIMIT else 0 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE while product <= LIMIT : NEW_LINE INDENT count += count ( primeIndex + 1 , product ) NEW_LINE product *= primes [ primeIndex ] NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( int ( math . log ( r ) / math . log ( 2 ) ) , - 1 , - 1 ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( ( x > r ) or ( x + ( 1 << i ) - 1 < l ) ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( x ^ ( 1 << i ) ) <= r ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT n = 7 NEW_LINE l = 2 NEW_LINE r = 23 NEW_LINE print ( " The ▁ output ▁ is " , maximumXOR ( n , l , r ) ) NEW_LINE
from math import sqrt NEW_LINE def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ False ] * ( N + 5 ) NEW_LINE i = 3 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( not arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = True NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT prime = [ ] NEW_LINE prime . append ( 2 ) NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( not arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE ans = 1 NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT
def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = int ( n ) ; NEW_LINE bit1 = " " . join ( bin ( n ) ) ; NEW_LINE bit1 = bit1 [ : : - 1 ] ; NEW_LINE zero = 0 ; NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if ( bit1 [ i ] == '0' ) : NEW_LINE INDENT zero += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return zero ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; NEW_LINE ans = CountTrailingZeros ( n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT
a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if a [ 0 ] > a [ 1 ] : NEW_LINE INDENT print ( a [ 0 ] * 2 + a [ 1 ] * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 1 ] * 2 + a [ 0 ] * 2 ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] < a [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def distinctSubString ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE sum += ord ( Q [ pos ] ) - ord ( '0' ) NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT P = " abcde " NEW_LINE Q = "12345678912345678912345678" NEW_LINE K = 5 NEW_LINE N = len ( P ) NEW_LINE print ( distinctSubString ( P , Q , K , N ) ) NEW_LINE DEDENT
def makeEven ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE n = len ( string ) NEW_LINE even = 10 ** 9 NEW_LINE index = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( ord ( string [ i ] ) - ord ( '0' ) ) % 2 == 0 ) : NEW_LINE INDENT even = ( ord ( string [ i ] ) - ord ( '0' ) ) NEW_LINE index = i NEW_LINE DEDENT if ( even <= ( ord ( string [ n - 1 ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( even == 10 ** 9 ) : NEW_LINE INDENT return string NEW_LINE DEDENT if ( index == n ** 9 ) : NEW_LINE INDENT return string NEW_LINE DEDENT ( string [ index ] , string [ n - 1 ] ) = ( string [ n - 1 ] , string [ index ] ) NEW_LINE return string NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = "1356425" NEW_LINE print ( makeEven ( string ) ) NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i * j ) <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE findDivisors ( n ) NEW_LINE
s = input ( ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE mm = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE for i in range ( 1 , len ( b ) ) : NEW_LINE INDENT mm [ i ] = mm [ i - 1 ] + int ( b [ i - 1 ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT x = 0 NEW_LINE if b [ i ] == '1' : NEW_LINE INDENT x = ( mm [ i ] - 1 ) + int ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( mm [ i ] - 1 ) + int ( s [ i ] ) NEW_LINE DEDENT ans += x NEW_LINE DEDENT print ( ans ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def printDistinct ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 and x != ' ▁ ' ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE for i in range ( MAX_CHAR and index [ i ] != n ) : NEW_LINE INDENT print ( str [ index [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE printDistinct ( str ) NEW_LINE DEDENT
import math NEW_LINE def calculate ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k = k - 1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT result = math . pow ( result , x ) NEW_LINE if ( result > m ) : NEW_LINE INDENT result %= m NEW_LINE DEDENT k = k - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT x = 5 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE
def conver thenumber ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT n = 18720 NEW_LINE conver thenumber ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE d = input ( ) NEW_LINE lst = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT c = chr ( ord ( ' a ' ) + i ) NEW_LINE lst . append ( c ) NEW_LINE DEDENT for i in lst : NEW_LINE INDENT if i not in d : NEW_LINE INDENT d . append ( i ) NEW_LINE DEDENT DEDENT d = [ ] NEW_LINE for i in d : NEW_LINE INDENT for j in lst : NEW_LINE INDENT if ( i in d ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] != a [ i - 1 ] : NEW_LINE INDENT count = 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) NEW_LINE rowmajorSum = sn ( n , an ) NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE colmajorSum = sn ( n , an ) NEW_LINE return rowmajorSum + colmajorSum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE print ( trace ( N , M ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE INF = float ( " inf " ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def main ( ) : NEW_LINE INDENT H , W = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ [ 0 for _ in range ( W ) ] for _ in range ( H ) ] NEW_LINE for _ in range ( H ) : NEW_LINE INDENT s = input ( ) NEW_LINE for i in range ( H ) : NEW_LINE INDENT if s [ i ] == " J " : NEW_LINE INDENT g [ i ] [ 0 ] = 1 NEW_LINE DEDENT if s [ i ] == " O " : NEW_LINE INDENT g [ i ] [ 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , H ) : NEW_LINE INDENT for j in range ( 1 , W ) : NEW_LINE INDENT if g [ i ] [ j ] == " I " : NEW_LINE INDENT if g [ i - 1 ] [ j ] == " J " : NEW_LINE INDENT a = g [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT a = g [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT g [ i ] [ j ] = a * g [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT print ( sum ( g ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( n // i ) % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( ( i * i == n ) and ( i % k == 0 ) ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + chr ( X + 48 ) NEW_LINE DEDENT res = int ( temp ) % M NEW_LINE return res NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N // 2 , M ) + half ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N // 2 + 1 , M ) + half * 10 + X ) % M NEW_LINE return res NEW_LINE DEDENT DEDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE m , y = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( ( sum ( a ) + sum ( m ) ) * ( ( n - sum ( a ) ) * ( m - y ) ) ) NEW_LINE DEDENT
import sys NEW_LINE def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT min_val = sys . maxsize NEW_LINE max_val = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] - i ) > max_val ) : NEW_LINE INDENT max_val = arr [ i ] - i NEW_LINE DEDENT if ( ( arr [ i ] - i ) < min_val ) : NEW_LINE INDENT min_val = arr [ i ] - i NEW_LINE DEDENT DEDENT return ( max_val - min_val ) NEW_LINE DEDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . append ( list ( input ( ) ) ) NEW_LINE DEDENT for k in range ( n ) : NEW_LINE INDENT if ' # ' in s [ k ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] [ k ] == ' # ' : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT elif k == n - 2 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if s [ i ] [ l ] == ' . ' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] [ l ] == ' . ' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE print ( " YNeos ▁ " [ s % n : ( s % n ) : : 2 ] ) NEW_LINE DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) | n ) ; NEW_LINE DEDENT def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) ; NEW_LINE return allBitsAreSet ( num ) ; NEW_LINE DEDENT def bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT num , left_shift = 0 , 0 ; NEW_LINE if ( isKthBitSet ( n , r ) ) : NEW_LINE INDENT num = n ; NEW_LINE left_shift = r ; NEW_LINE DEDENT else : NEW_LINE INDENT num = setKthBit ( n , ( r + 1 ) ) ; NEW_LINE left_shift = r + 1 ; NEW_LINE DEDENT num = num & ( ( 1 << left_shift ) - 1 ) ; NEW_LINE num = num >> ( l - 1 ) ; NEW_LINE return bitsAreInAltOrder ( num ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 18 ; NEW_LINE l = 1 ; r = 3 ; NEW_LINE if ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) ) NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return ( nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ) NEW_LINE DEDENT n = 5 ; x = 4 ; y = 2 NEW_LINE print ( NumberOfWays ( n , x , y ) ) NEW_LINE
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = " " ; NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geek " , " geezer " ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE a = LI ( ) NEW_LINE a . sort ( reverse = True ) NEW_LINE print ( sum ( a [ : n ] ) ) NEW_LINE DEDENT main ( ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE temp = 0 NEW_LINE cons = False NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ i - 1 ] == 1 ) : NEW_LINE INDENT temp = i - 1 NEW_LINE cons = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( temp == 1 ) : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT ans = temp + 1 NEW_LINE DEDENT DEDENT if ( a [ 0 ] == 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ i - 1 ] == 1 ) : NEW_LINE INDENT temp = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT if ( temp == 1 ) : NEW_LINE INDENT ans = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT if ( a [ - 1 ] == 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ i + 1 ] == 1 ) : NEW_LINE INDENT temp = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT if ( temp == 0 ) : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT c = a + b NEW_LINE a , b = b , c NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 ] * ( arr [ n - 1 ] + 1 ) NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( arr [ n - 1 ] + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( " Element " , i , " ▁ occurs ▁ " , freq [ i ] , " times " , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 7 ) NEW_LINE ans = min ( range ( 2 , len ( totients ) ) , key = ( lambda i : totients [ i ] , i ) ) NEW_LINE def has_same_digits ( x , y ) : NEW_LINE INDENT return sorted ( str ( x ) ) == sorted ( str ( y ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def intersection ( a , b , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE DEDENT
import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) NEW_LINE DEDENT x = int ( math . exp ( sum / n ) ) NEW_LINE return x + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectSq = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT minPerfectSq *= 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT minPerfectSq *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectSq NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectSquare ( arr , n ) ) NEW_LINE
def subarrayCount ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE fast = 0 ; slow = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT fast += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT len = fast - slow + 1 ; NEW_LINE result += len * ( len - 1 ) / 2 ; NEW_LINE fast = i ; NEW_LINE slow = i ; NEW_LINE DEDENT DEDENT if ( fast != slow ) : NEW_LINE INDENT len = fast - slow + 1 ; NEW_LINE result += len * ( len - 1 ) / 2 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( subarrayCount ( arr , n ) ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT if n / 2 % 4 == 0 : NEW_LINE INDENT val1 = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT val1 = n // 2 NEW_LINE DEDENT n = val1 * 2 NEW_LINE DEDENT else : NEW_LINE INDENT val = n // 2 NEW_LINE DEDENT DEDENT ans += val1 NEW_LINE print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ a [ 0 ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] > b [ i - 1 ] : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT if a [ i ] < b [ i - 1 ] : NEW_LINE INDENT a [ i ] = b [ i - 1 ] NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE
MAX_CHARS = 256 NEW_LINE def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False for i in range ( MAX_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ str [ i ] ] == False ) : NEW_LINE INDENT visited [ str [ i ] ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = 10 ** 9 NEW_LINE count = 0 NEW_LINE curr_count = [ 0 for i in range ( MAX_CHARS ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ j ] ) ] += 1 NEW_LINE if ( curr_count [ ord ( str [ j ] ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == dist_count ) : NEW_LINE INDENT while ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT if ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT curr_count [ ord ( str [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aabcbcdbca " NEW_LINE print ( " Smallest ▁ window ▁ containing ▁ all ▁ distinct ▁ characters ▁ is : ▁ " , findSubString ( str ) ) NEW_LINE DEDENT
import math NEW_LINE A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) NEW_LINE a = math . ceil ( A * ( 100 + E ) / ( 100 + E ) ) NEW_LINE b = math . ceil ( B * ( 100 + C ) / ( 100 + D ) ) NEW_LINE c = math . floor ( A * ( 100 + B ) / ( 100 + E ) ) NEW_LINE d = math . ceil ( B * ( 100 + D ) / ( 100 + E ) ) NEW_LINE print ( " { 0 : . 10f } ▁ { 1 : . 10f } " . format ( c , d ) ) NEW_LINE
import sys NEW_LINE def solve ( numbers ) : NEW_LINE INDENT max = - sys . maxsize NEW_LINE for i in range ( 0 , len ( numbers ) ) : NEW_LINE INDENT for j in range ( i , len ( numbers ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT x = numbers [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT x = numbers [ i ] NEW_LINE if x + y < max : NEW_LINE INDENT max = x + y NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT for line in sys . stdin : NEW_LINE INDENT numbers = [ int ( x ) for x in line . strip ( ) . split ( " , " ) ] NEW_LINE print ( solve ( numbers ) ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT print ( ( even ) * ( n - 1 ) ) ; NEW_LINE print ( ( odd ) * ( n - 1 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE countPairs ( arr , n ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT x1 , p1 , x2 , p2 = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT a = str ( x1 ) NEW_LINE b = str ( x2 ) NEW_LINE c = int ( a [ 0 ] ) NEW_LINE d = int ( a [ 1 ] ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT c *= 10 NEW_LINE d += 1 NEW_LINE DEDENT if c > p1 : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif c < p2 : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if a > b : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT N , M = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT name = input ( ) NEW_LINE arr . append ( name ) NEW_LINE DEDENT a = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] == " G " and arr [ i ] == " S " : NEW_LINE INDENT a = max ( a , len ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 NEW_LINE back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def MinCostTree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ ] NEW_LINE st . append ( sys . maxsize ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( st [ len ( st ) - 1 ] <= arr [ i ] ) : NEW_LINE INDENT x = st [ len ( st ) - 1 ] NEW_LINE st . pop ( ) NEW_LINE ans += x * min ( st [ len ( st ) - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCostTree ( arr , n ) ) NEW_LINE DEDENT
from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT c = Counter ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != c [ t [ i ] ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT j = 0 NEW_LINE while j < len ( a ) and a [ j ] == t [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == len ( a ) - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( j , i + 1 ) : NEW_LINE INDENT if a [ i ] != t [ j ] : NEW_LINE INDENT a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE print ( * a ) NEW_LINE
def findEquation ( a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ^ 2 ▁ - ▁ ( " , sum , " x ) ▁ + ▁ ( " , product , " ) ▁ = ▁ 0" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE findEquation ( a , b ) NEW_LINE
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) NEW_LINE print ( " x ^ 2 ▁ + ▁ ( " , a , " ▁ x ) ▁ + ▁ " ) NEW_LINE print ( " y ^ 2 ▁ + ▁ ( " , b , " ▁ y ) ▁ = ▁ " ) NEW_LINE print ( c , " . " ) NEW_LINE DEDENT x1 = 2 NEW_LINE y1 = - 3 NEW_LINE r = 8 NEW_LINE circle_equation ( x1 , y1 , r ) NEW_LINE
def unique_combination ( l , sum , K , local , A ) : NEW_LINE INDENT if ( sum == K ) : NEW_LINE INDENT print ( " { " , end = " ▁ " ) NEW_LINE for i in range ( 0 , len ( local ) ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( local [ i ] , end = " " ) NEW_LINE if ( i != len ( local ) - 1 ) : NEW_LINE INDENT print ( " , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " } " , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) ) : NEW_LINE INDENT if ( sum + A [ i ] > K ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 1 and A [ i ] == A [ i - 1 ] and i > l ) : NEW_LINE INDENT continue NEW_LINE DEDENT local . append ( A [ i ] ) NEW_LINE unique_combination ( i + 1 , sum + A [ i ] , K , local , A ) NEW_LINE local . pop ( ) NEW_LINE DEDENT DEDENT def Combination ( A , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE local = [ ] NEW_LINE unique_combination ( 0 , 0 , K , local , A ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] NEW_LINE K = 8 NEW_LINE combination ( A , K ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE q = int ( input ( ) ) NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE print ( max ( 0 , bisect . bisect_left ( a , k ) + 1 ) NEW_LINE DEDENT
import string NEW_LINE import sys NEW_LINE def check_exists ( word_set , rotate_dict , search ) : NEW_LINE INDENT for word in word_set : NEW_LINE INDENT rotated_word = ' ' . join ( rotate_dict [ s ] for s in word ) NEW_LINE if rotated_word == search : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT word = input ( ) NEW_LINE print ( word ) NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) == 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) == 1 NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 3 != 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return ( ( n - 1 ) % 3 != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) % 3 != 0 ) NEW_LINE DEDENT DEDENT DEDENT a = 2 NEW_LINE b = 4 NEW_LINE n = 3 NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT
import math NEW_LINE while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE ans = math . sqrt ( a ** 2 + b ** 2 ) NEW_LINE for x in range ( 0 , a // 2 + 1 , 2 ) : NEW_LINE INDENT y = b - math . sqrt ( a ** 2 - x ** 2 ) NEW_LINE ans = min ( ans , abs ( x - y ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) NEW_LINE DEDENT elif ( n >= 3 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) NEW_LINE dp [ 2 ] = max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) NEW_LINE i = 3 NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , - 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_sum ( arr , n ) ) NEW_LINE
s = input ( ) NEW_LINE vowels = { ' A ' , ' E ' , ' I ' , ' O ' , ' U ' , ' Y ' } NEW_LINE x = s [ 0 : - 1 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] in vowels : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if s [ i ] in vowels : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print ( ' YES ' ) NEW_LINE
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i ; NEW_LINE sec = n // i ; NEW_LINE num1 = fir * k + sec ; NEW_LINE res = ( num1 // k ) * ( num1 % k ) ; NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) ; NEW_LINE DEDENT num2 = sec * k + fir ; NEW_LINE res = ( num2 // k ) * ( num2 % k ) ; NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) ; NEW_LINE DEDENT DEDENT DEDENT return mini ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE n = 5 ; NEW_LINE k = 5 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += 1 NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ int ( y ) for y in sys . stdin . readline ( ) . split ( ) ] NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d . get ( s [ i ] , None ) is None : NEW_LINE INDENT d [ s [ i ] ] = i NEW_LINE DEDENT elif d [ s [ i ] ] == i : NEW_LINE INDENT d [ s [ i ] ] = i NEW_LINE DEDENT DEDENT ans = solve ( n , s ) NEW_LINE print ( " Case ▁ # % d : ▁ % d " % ( test_case , ans ) ) NEW_LINE DEDENT
def SellingPrice ( CP , PP ) : NEW_LINE INDENT P_decimal = 1 + ( PP / 100 ) NEW_LINE res = P_decimal * CP NEW_LINE return res NEW_LINE DEDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ 0 ] * n NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] not in d : NEW_LINE INDENT d [ p [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT d [ p [ i ] ] += 1 NEW_LINE DEDENT DEDENT ans = " " NEW_LINE for i in d : NEW_LINE INDENT ans += str ( d [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE s = int ( input ( ) ) NEW_LINE def f ( b , n ) : NEW_LINE INDENT if n < b : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return f ( b , n // b ) + ( n % b ) NEW_LINE DEDENT DEDENT def abc ( N , S ) : NEW_LINE INDENT if N == S : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT else : NEW_LINE INDENT for b in range ( 2 , int ( math . sqrt ( N ) ) + 2 ) : NEW_LINE INDENT if f ( b , N ) == S : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT tmp = - 1 NEW_LINE for p in range ( 1 , int ( math . sqrt ( N ) ) + 2 ) : NEW_LINE INDENT if ( N - S ) % p != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT b = ( N - S ) // p + 1 NEW_LINE if b <= 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if f ( b , N ) == S : NEW_LINE INDENT tmp = b NEW_LINE DEDENT DEDENT return tmp NEW_LINE DEDENT DEDENT ans = abc ( n , s ) NEW_LINE print ( ans ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE m , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE l = 0 NEW_LINE while l < m : NEW_LINE INDENT s = ( l + r ) / 2 NEW_LINE v = ( s - 1 ) ** 2 / m NEW_LINE ans = max ( ans , v * ( v + 1 ) * ( v + 1 ) // 2 + v * ( v - 1 ) // 2 ) NEW_LINE l = s + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " , end = " " ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE m = 10 ; NEW_LINE check ( n , m ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE if i == n - 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a , b ) - min ( a , b ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE k = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE k [ a ] = b [ 0 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE k [ b ] = a [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if k [ i ] not in k : NEW_LINE INDENT k [ k [ i ] ] = b [ i ] NEW_LINE DEDENT DEDENT print ( ' ' . join ( k ) ) NEW_LINE
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = " geeks " NEW_LINE ch = ' e ' NEW_LINE N = 2 NEW_LINE print ( findNthOccur ( string , ch , N ) ) NEW_LINE DEDENT
n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( n ) NEW_LINE if n [ 0 ] == 4 or n [ 0 ] == 6 or n [ 0 ] == 4 or n [ 1 ] == 6 or n [ 2 ] == 4 or n [ 2 ] == 6 : NEW_LINE INDENT if s in ( 4 , 3 , 5 , 7 , 8 , 9 ) : NEW_LINE INDENT print ( ' Alien ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Elephant ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' Bear ' ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 1000000000000000 NEW_LINE MOD = 10 ** 9 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max ( LIMIT // 3 , 1 ) + 1 ) : NEW_LINE INDENT count = eulerlib . sqrt ( LIMIT // ( i + 1 ) ) NEW_LINE ans = ( ans + term * count ) % MOD NEW_LINE DEDENT for i in range ( 1 , splitCount + 1 ) : NEW_LINE INDENT start = LIMIT // ( i + 1 ) NEW_LINE end = LIMIT // ( i + 1 ) NEW_LINE ans = ( ans + term * ( start - start ) ) % MOD NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k , z = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for x in range ( z ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if x * 2 + i > n : NEW_LINE INDENT break NEW_LINE DEDENT ans = max ( ans , sum ( lst [ 0 : x * 2 + i ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE summa = 0 NEW_LINE summi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != i + 1 : NEW_LINE INDENT if summa == a [ i ] : NEW_LINE INDENT summa = a [ i ] NEW_LINE summi = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE summi = a [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if summa == a [ i ] : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if summi == a [ i + 1 ] : NEW_LINE INDENT print ( i , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , i + 1 ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if summi == a [ i + 1 ] : NEW_LINE INDENT print ( i , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
import itertools NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT c = list ( itertools . accumulate ( a [ i ] ) ) NEW_LINE tmp = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if i [ 0 ] <= tmp [ i ] and tmp [ 1 ] <= a [ i [ 1 ] ] [ 1 ] and i [ 2 ] <= a [ i [ 2 ] ] [ 1 ] : NEW_LINE INDENT tmp += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , tmp ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while 1 : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ 0 ] * 101 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i % n ] += 1 NEW_LINE if a [ i ] == p : print ( i ) ; break NEW_LINE DEDENT DEDENT
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import queue NEW_LINE def itertools_input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A_minus = list ( itertools . accumulate ( A ) ) NEW_LINE A_bef , A_aft , A_minus = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) NEW_LINE for A_bef in A : NEW_LINE INDENT A_bef [ A_bef [ A_bef [ A_bef [ A_bef [ A_bef ] ] + A_aft [ A_bef ] NEW_LINE DEDENT ans = [ sum ( A_bef ) ] NEW_LINE for aft in A_minus : NEW_LINE INDENT ans . append ( aft ) NEW_LINE DEDENT print ( ' \n ' . join ( ans ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = a - b NEW_LINE n = str ( c ) NEW_LINE print ( n // 10 ) NEW_LINE DEDENT
maxSize = 10 ** 5 + 5 NEW_LINE isFib = [ 0 ] * maxSize NEW_LINE prefix = [ 0 ] * maxSize NEW_LINE def digitSum ( num ) : NEW_LINE INDENT s = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT s = s + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def generateFibonacci ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr < maxSize ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp < maxSize ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def precompute ( k ) : NEW_LINE INDENT generateFibonacci ( ) NEW_LINE for i in range ( 1 , maxSize ) : NEW_LINE INDENT sum = digitSum ( i ) NEW_LINE if ( isFib [ sum ] == True and sum % k == 0 ) : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , maxSize ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def performQueries ( k , q , query ) : NEW_LINE INDENT precompute ( k ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE cnt = prefix [ r ] - prefix [ l - 1 ] NEW_LINE print ( cnt ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT query = [ [ 1 , 11 ] , [ 5 , 15 ] , [ 2 , 24 ] ] NEW_LINE k = 2 NEW_LINE q = len ( query ) NEW_LINE performQueries ( k , q , query ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if p [ i ] > p [ i + 1 ] : NEW_LINE INDENT a += p [ i ] - p [ i + 1 ] NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ l - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT res_str = " " NEW_LINE sum = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = int ( N % 10 ) NEW_LINE sum += digit NEW_LINE N = int ( N / 10 ) NEW_LINE DEDENT while ( len ( res_str ) < sum ) : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ : sum ] NEW_LINE DEDENT if ( isPalindrome ( res_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT N = 10101 NEW_LINE if ( createStringAndCheckPalindrome ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ [ 0 , 0 ] for i in range ( 100 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , a [ i ] = map ( str , input ( ) . split ( ) ) NEW_LINE a [ i ] [ 1 ] = int ( a [ i ] [ 1 ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT if a [ i ] [ j ] == 1 : NEW_LINE INDENT print ( " S " , j ) NEW_LINE DEDENT DEDENT if a [ i ] [ j ] == 2 : NEW_LINE INDENT print ( " C " , j ) NEW_LINE DEDENT if a [ i ] [ j ] == 3 : NEW_LINE INDENT print ( " D " , j ) NEW_LINE DEDENT DEDENT
def sum_even_and_even_index ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n , 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 5 , 6 , 12 , 1 , 18 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ of ▁ even ▁ numbers " , " at ▁ even ▁ indices ▁ is " , sum_even_and_even_index ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE cnt = [ 0 ] * 26 NEW_LINE ok = 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if cnt [ ord ( s [ i ] ) - 65 ] == 1 : NEW_LINE INDENT ok = 0 NEW_LINE break NEW_LINE DEDENT if s [ i ] != s [ i - 1 ] : NEW_LINE INDENT cnt [ ord ( s [ i - 1 ] ) - 65 ] = 1 NEW_LINE DEDENT DEDENT if ok == 1 : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) ; NEW_LINE fl = 1 ; NEW_LINE DEDENT DEDENT arr [ arr [ arr [ i ] % n ] += n ; NEW_LINE DEDENT if ( fl == 0 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] ; NEW_LINE arr_size = len ( arr ) ; NEW_LINE printDuplicates ( arr , arr_size ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE print ( ( n + 1 ) / n ** 2 ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( n + 2 ) / 3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE DEDENT
def maxHandshake ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT n = 10 NEW_LINE print ( maxHandshake ( n ) ) NEW_LINE
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE DEDENT
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE
def possibleways ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT return n // 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 20 NEW_LINE print ( int ( possibleways ( n ) ) ) NEW_LINE DEDENT
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 21 NEW_LINE print ( CountSetBits ( n ) ) NEW_LINE DEDENT
def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m , n = 3 , 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT
def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( " SUM ( " , n , " , " , m , " ) : ▁ " , SUM ( n , m ) ) NEW_LINE DEDENT
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE print ( maxLCM ( n ) ) ; NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def cntWays ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 18 ; NEW_LINE print ( cntWays ( n ) ) ; NEW_LINE DEDENT
def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE find_composite_nos ( n ) NEW_LINE DEDENT
def findThirdDigit ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 if ( n & 1 ) else 6 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( findThirdDigit ( n ) ) NEW_LINE
def countMaxIntersect ( n ) : NEW_LINE INDENT return ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT n = 48 NEW_LINE print ( highestPowerOf2 ( n ) ) NEW_LINE
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE alpha = " abcdefghijklmnopqrstuvwxyz " NEW_LINE alphabetical = True NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if alpha . find ( s [ i ] ) == - 1 : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE alphabetical = False NEW_LINE break NEW_LINE DEDENT DEDENT if alphabetical : NEW_LINE INDENT print ( " None " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] % a [ j ] == 0 : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ans == - 1 : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE def input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = int ( input ( ) ) NEW_LINE if r < 1200 : NEW_LINE INDENT print ( " ABC " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ARC " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE rl = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( rl ( ) ) NEW_LINE A = list ( map ( int , rl ( ) . split ( ) ) ) NEW_LINE left = [ 0 ] * ( N + 1 ) NEW_LINE right = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == 0 : NEW_LINE INDENT left [ i ] = left [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = right [ i + 1 ] NEW_LINE DEDENT DEDENT right [ N - 1 ] = right [ N - 2 ] + 1 NEW_LINE left = [ i for i in range ( N - 1 , - 1 , - 1 ) ] NEW_LINE right = [ i for i in range ( N + 1 ) if i == 0 ] NEW_LINE left [ 0 ] = left [ 1 ] NEW_LINE right [ 1 ] = right [ N - 1 ] + 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if left [ i ] > right [ i - 1 ] : NEW_LINE INDENT right [ i ] = left [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = right [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT right [ i ] = right [ i ] NEW_LINE DEDENT ans = [ left [ i - 1 ] , right [ i ] ] NEW_LINE ans . reverse ( ) NEW_LINE print ( * ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x != 0 and y != 0 and z != 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE print ( " Minimum ▁ of ▁ 3 ▁ numbers ▁ is " , smallest ( x , y , z ) ) NEW_LINE
a = [ int ( input ( ) ) for _ in [ 0 ] * 4 ] NEW_LINE print ( ( 1 , 5 ) [ sum ( a ) // 5 ] ) NEW_LINE
import math NEW_LINE n , r = map ( int , input ( ) . split ( ) ) NEW_LINE if n < 2 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT val = ( n + 1 ) / 2 NEW_LINE print ( val * ( val - 1 ) + ( val ** 2 ) * ( 2 / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT val = ( n + 1 ) / 2 NEW_LINE print ( val * ( 2 / 2 ) + ( 2 / 2 ) * ( m ** 2 + val ** 2 ) ) NEW_LINE DEDENT
from math import ceil NEW_LINE def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( ceil ( cbrt ( b ) ) ) - ceil ( cbrt ( a ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE print ( " Count ▁ of ▁ cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE DEDENT
from heapq import heappush , heappop NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT d , n = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 : break NEW_LINE ma = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE pq = [ [ 0 ] * 1001 for _ in range ( d + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ma [ i ] [ 0 ] = i NEW_LINE DEDENT for i in ma [ i ] : NEW_LINE INDENT for j in range ( i + 1 , d + 1 ) : NEW_LINE INDENT if ma [ j ] [ i ] > pq [ i ] [ j ] : NEW_LINE INDENT heappush ( pq , [ p [ i ] [ j ] , i ] ) NEW_LINE DEDENT DEDENT DEDENT ans = ' NA ' NEW_LINE for i in range ( d ) : NEW_LINE INDENT if ma [ i ] [ 0 ] > ans : NEW_LINE INDENT ans = ma [ i ] [ 0 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT triangle = 0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT if abs ( triangle - i ) > 500 : NEW_LINE INDENT raise ArithmeticException ( " Overflow " ) NEW_LINE DEDENT triangle += i NEW_LINE if count_divisors ( triangle ) > 500 : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT DEDENT DEDENT def count_divisors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT if i > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT if end * end == n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findDelta ( a , b , c , d ) : NEW_LINE INDENT return ( b * c - a * d ) // ( d - c ) NEW_LINE DEDENT a , b , c , d = 3 , 9 , 3 , 5 NEW_LINE print ( " \ u0394 X ▁ = ▁ " , findDelta ( a , b , c , d ) ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * p ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ False ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( n , isPrime ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , n - i ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 74 ; NEW_LINE findPrimePair ( n ) ; NEW_LINE DEDENT
def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 ; NEW_LINE multiply = 1 ; NEW_LINE while ( x % 10 > 0 ) : NEW_LINE INDENT remainder = x % 10 ; NEW_LINE if ( remainder == d1 ) : NEW_LINE INDENT result = result + d2 * multiply ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * multiply ; NEW_LINE DEDENT multiply *= 10 ; NEW_LINE x = x // 10 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT x = 645 ; NEW_LINE d1 = 6 ; NEW_LINE d2 = 5 ; NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) ; NEW_LINE
def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( " / " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \ \ " , end = " " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) ; NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT print ( ) ; NEW_LINE return printPattern ( i + 1 , 0 , n ) ; NEW_LINE DEDENT N = 9 ; NEW_LINE printPattern ( 0 , 0 , N ) ; NEW_LINE
def getPairsCount ( n , sum ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT twos_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum - arr [ i ] ) in mp . keys ( ) : NEW_LINE INDENT twos_count += mp [ sum - arr [ i ] ] NEW_LINE DEDENT if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT twos_count -= 1 NEW_LINE DEDENT DEDENT return int ( twice_count / 2 ) NEW_LINE DEDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is ▁ " , getPairsCount ( n , sum ) ) NEW_LINE
def Count_subarray ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE remaining_sum = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] ; NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = n // min ( a , b ) NEW_LINE d = n - c + min ( a , b ) - 1 NEW_LINE if ( c > x ) : NEW_LINE INDENT d -= c NEW_LINE DEDENT print ( d ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE nin = 10 ** 7 NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = int ( input ( ) ) NEW_LINE if temp % 10 != 0 : NEW_LINE INDENT nin = min ( nin , temp ) NEW_LINE DEDENT s . append ( temp ) NEW_LINE DEDENT ans = sum ( s ) NEW_LINE if ans % 10 == 0 : NEW_LINE INDENT ans -= nin NEW_LINE print ( max ( ans , 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mn = 10000000000000 NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = l [ i ] NEW_LINE ind = i NEW_LINE while ind < n and l [ ind ] == l [ ind - 1 ] : NEW_LINE INDENT ind += k NEW_LINE DEDENT mn = min ( mn , ind ) NEW_LINE DEDENT print ( mn ) NEW_LINE DEDENT
import math as mt NEW_LINE def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = mt . sqrt ( n ) NEW_LINE range1 = ( n // sq ) + 1 NEW_LINE count = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) // sq ] += 1 NEW_LINE DEDENT selected_block = range1 NEW_LINE for i in range ( 0 , range1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = dict ( ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE if ( m [ arr [ i ] ] == 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 , 5 , 4 ] NEW_LINE n = 5 NEW_LINE print ( " One ▁ of ▁ the ▁ numbers ▁ repeated ▁ in ▁ the ▁ array ▁ is : " , findRepeatingNumber ( arr , n ) ) NEW_LINE
from math import sqrt , ceil NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT p = int ( sqrt ( n ) + 1 ) NEW_LINE for i in range ( 3 , p , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i ; NEW_LINE n = n // i ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n ; NEW_LINE DEDENT return maxPrime ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 ; NEW_LINE print ( maxPrimeFactors ( n ) ) ; NEW_LINE n = 25698751364526 ; NEW_LINE print ( maxPrimeFactors ( n ) ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , a = int ( input ( ) ) , ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT res += min ( res , n - res ) NEW_LINE print ( res ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE s = input ( ) . strip ( ) NEW_LINE l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT x = i NEW_LINE y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE y = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT y = i NEW_LINE DEDENT else : NEW_LINE INDENT x = i NEW_LINE y += 1 NEW_LINE DEDENT DEDENT DEDENT print ( 2 * ( x + y ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 3 + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n // 2 + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , " , ▁ " , j , " , ▁ " , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ Triplet " ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 ; NEW_LINE pythagoreanTriplet ( n ) ; NEW_LINE DEDENT
import math NEW_LINE def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
def indexOfFirstOne ( arr , low , high ) : NEW_LINE INDENT mid = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( arr [ mid ] == 1 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return mid NEW_LINE DEDENT def posOfFirstOne ( arr ) : NEW_LINE INDENT l , h = 0 , 1 NEW_LINE while ( arr [ h ] == 0 ) : NEW_LINE INDENT l = h NEW_LINE h = 2 * h NEW_LINE DEDENT return indexOfFirstOne ( arr , l , h ) NEW_LINE DEDENT arr = [ 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE print ( " Index ▁ = " , posOfFirstOne ( arr ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT k = ( n + 1 ) / 2 NEW_LINE print ( int ( k ** 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k = n / 2 NEW_LINE print ( int ( k * ( k + 1 ) ) ) NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if N >= 64 : NEW_LINE INDENT write ( " NA \n " ) NEW_LINE return True NEW_LINE DEDENT * p , = range ( 2 , 32 ) NEW_LINE def solve ( v ) : NEW_LINE INDENT L = 1 NEW_LINE R = 4 NEW_LINE while R <= v : NEW_LINE INDENT K = ( L * r ) // 2 NEW_LINE R %= 2 NEW_LINE DEDENT if K == v : NEW_LINE INDENT return " NA " NEW_LINE DEDENT L += 1 NEW_LINE R -= 1 NEW_LINE DEDENT write ( " % .16f \n " % R ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 ; rem = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE sum += rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT n = 43 ; NEW_LINE print ( " x ▁ = " , findX ( n ) ) ; NEW_LINE
def check ( p , A ) : NEW_LINE INDENT cnt = 0 NEW_LINE for a in p : NEW_LINE INDENT if a >= A : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt >= A NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for A in range ( 100 , - 1 , - 1 ) : NEW_LINE INDENT if check ( p , A ) : NEW_LINE INDENT print ( A ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
list_1 = [ int ( input ( ) ) for i in range ( 7 ) ] NEW_LINE list_1 . sort ( ) NEW_LINE list_2 = [ ] NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT list_2 . append ( int ( input ( ) ) ) NEW_LINE DEDENT print ( list_2 [ 0 ] - list_2 [ 1 ] ) NEW_LINE
from collections import defaultdict NEW_LINE def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = defaultdict ( int ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L , R = i [ 0 ] , i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT L = R NEW_LINE R = temp NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ ( 1 , 5 ) , ( 1 , 4 ) , ( 3 , 4 ) ] NEW_LINE performQueries ( Arr , q ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE i = 0 NEW_LINE k = 1 NEW_LINE ans = 0 NEW_LINE while i < n : NEW_LINE INDENT while i < n and arr [ i ] < k : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT k += 1 NEW_LINE i += 1 NEW_LINE DEDENT print ( k - 1 ) NEW_LINE
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_r = max ( r ) NEW_LINE min_p = min ( p ) NEW_LINE max_r = max ( r ) NEW_LINE a_max = a [ 0 ] NEW_LINE b_min = b [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT max_r = max ( max_r , r [ i ] ) NEW_LINE a_max = a [ i ] NEW_LINE DEDENT b_min = b [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT b_min = b [ i ] NEW_LINE DEDENT cost = math . sqrt ( max_r * max_r / ( a * b_min + b * b_max ) ) NEW_LINE return round ( cost , 12 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT
def trapeziumPattern ( num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfSpaces = 0 NEW_LINE for numOfLines in range ( num , 0 , - 1 ) : NEW_LINE INDENT for numOfSpacesCounter in range ( numOfSpaces , 0 , - 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT for firstHalfCounter in range ( 1 , numOfNumberOfLines + 1 ) : NEW_LINE INDENT if ( firstHalfCounter == numOfLines ) : NEW_LINE INDENT print ( firsthalf ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( firsthalf , end = " * " ) NEW_LINE firsthalf += 1 NEW_LINE DEDENT DEDENT for secondHalfCounter in range ( 1 , numOfLines + 1 ) : NEW_LINE INDENT print ( " * " + ( secondhalf ) , end = " " ) NEW_LINE secondhalf += 1 NEW_LINE DEDENT print ( " " ) NEW_LINE numOfSpaces += 2 NEW_LINE secondhalf = ( secondhalf - 1 ) - ( ( numOfLines - 1 ) * 2 ) NEW_LINE DEDENT DEDENT  trapeziumPattern ( 3 ) NEW_LINE
def findPerm ( n , **= **= **= **= **= **= **= **= 0 NEW_LINE ans = [ ] NEW_LINE ans . append ( 0 ) NEW_LINE x = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = differences [ i ] NEW_LINE x = x + diff NEW_LINE ans . append ( x ) NEW_LINE DEDENT anss = [ ] NEW_LINE for obj in ans : NEW_LINE INDENT anss . append ( obj ) NEW_LINE DEDENT ans . sort ( ) NEW_LINE flag = - 1 NEW_LINE for i in range ( 1 , n - 1 + 1 ) : NEW_LINE INDENT res = ans [ i ] - ans [ i - 1 ] NEW_LINE if ( res != 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT mpp = { } NEW_LINE j = 1 NEW_LINE value_at_index = [ ] NEW_LINE for x1 in ans : NEW_LINE INDENT mpp [ x1 ] = j NEW_LINE j += 1 NEW_LINE DEDENT for x2 in anss : NEW_LINE INDENT value_at_index . append ( mpp [ x2 ] ) NEW_LINE DEDENT for x3 in value_at_index : NEW_LINE INDENT print ( x3 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT **= **= 0 NEW_LINE findPerm ( n , **= 0 ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE count = count + 1 NEW_LINE DEDENT i = 3 NEW_LINE while i <= sqrt ( n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE count = count + 1 NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT def printKAlmostPrimes ( k , n ) : NEW_LINE INDENT i = 1 NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( " First " , n , k , " - almost ▁ prime ▁ numbers : ▁ " ) NEW_LINE printKAlmostPrimes ( k , n ) NEW_LINE DEDENT
def solve ( N , K ) : NEW_LINE INDENT  combo = [ 0 for i in range ( 50 ) ] NEW_LINE  combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if ( j >= i ) : NEW_LINE INDENT  combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE solve ( N , K ) NEW_LINE
def solve ( n ) : NEW_LINE INDENT x = n NEW_LINE res = [ ] NEW_LINE while x != 0 : NEW_LINE INDENT res . append ( x % 10 ) NEW_LINE x = x // 10 NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT if res [ i ] == 0 : NEW_LINE INDENT return s + '0' NEW_LINE DEDENT x = ( x - 1 ) // 10 NEW_LINE res [ i ] = str ( abs ( x ) - res [ i ] ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def normal ( m , n ) : NEW_LINE INDENT N = ( abs ( m ) * abs ( n ) ) / sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = - 5 ; NEW_LINE n = 3 ; NEW_LINE print ( " { 0 : . 3 } " . format ( normal ( m , n ) ) ) ; NEW_LINE DEDENT
import math NEW_LINE n , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( ( i / n ) * h , end = ' ▁ ' ) NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT i = 65 ; NEW_LINE print ( countBits ( i ) ) ; NEW_LINE
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( H // a ) * ( W // b ) - ( H // a ) * ( W // b ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , round ( max ( A ) + 1 ) ) : NEW_LINE INDENT if A [ i ] % ( round ( A [ i ] / ( round ( A [ i ] ) ) ) == 0 ) : NEW_LINE INDENT ans += A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT arr2 = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] % k NEW_LINE DEDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_length = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr2 [ j ] == arr2 [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if m <= n // 2 : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m - 1 ) NEW_LINE DEDENT DEDENT
def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; NEW_LINE n = len ( s ) ; NEW_LINE if ( isHeterogram ( s , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT array = list ( range ( 10 ) ) NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT array [ i ] = i NEW_LINE DEDENT for i in range ( 999999 ) : NEW_LINE INDENT if not eulerlib . next_permutation ( array ) : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT ans = " " . join ( array ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x1 , y1 , x2 , y2 = 0 , 10 , 8 NEW_LINE x , y = 1 , 5 NEW_LINE if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
MAX = 10000000 NEW_LINE MIN = 1000 NEW_LINE class point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def countPoints ( n , points ) : NEW_LINE INDENT minx = [ MAX for i in range ( MX ) ] NEW_LINE miny = [ MAX for i in range ( MX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT minx [ i ] = MAX_MAX NEW_LINE miny [ i ] = MAX_MAX NEW_LINE DEDENT maxx = [ 0 for i in range ( MX ) ] NEW_LINE maxy = [ 0 for i in range ( MX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT points [ i ] [ 0 ] += OFF NEW_LINE points [ i ] [ 1 ] += OFF NEW_LINE x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE minx [ y ] = min ( minx [ y ] , x ) NEW_LINE maxx [ y ] = max ( maxx [ y ] , y ) NEW_LINE miny [ x ] = min ( miny [ x ] , y ) NEW_LINE maxy [ x ] = max ( maxy [ x ] , y ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE if ( x > minx [ y ] and x < maxx [ y ] ) : NEW_LINE INDENT if ( y > miny [ x ] and y < maxy [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT points = [ [ 0 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] NEW_LINE n = len ( points ) NEW_LINE print ( countPoints ( n , points ) ) NEW_LINE DEDENT
import math NEW_LINE from decimal import Decimal NEW_LINE def inp ( ) : NEW_LINE INDENT return ( int ( input ( ) ) ) NEW_LINE DEDENT def inlist ( ) : NEW_LINE INDENT return ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT def instr ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE return ( list ( s [ : len ( s ) ] ) ) NEW_LINE DEDENT def invr ( ) : NEW_LINE INDENT return ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT x , y = invr ( ) NEW_LINE count = 0 NEW_LINE while x <= y : NEW_LINE INDENT x *= 2 NEW_LINE count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE
sticks = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ; NEW_LINE def countSticks ( string , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ ord ( string [ i ] ) - ord ( '0' ) ] ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "56" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countSticks ( string , n ) ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , a = int ( input ( ) ) , [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE res , prev = [ ] , 0 NEW_LINE for i , e in enumerate ( a ) : NEW_LINE INDENT if i != 0 and e == 0 : NEW_LINE INDENT if a [ i - 1 ] > a [ i ] > a [ i + 1 ] : NEW_LINE INDENT prev = i NEW_LINE DEDENT DEDENT elif i != 0 : NEW_LINE INDENT if a [ i - 1 ] > a [ i ] : NEW_LINE INDENT prev = i NEW_LINE DEDENT DEDENT res . append ( a [ - 1 ] ) NEW_LINE res . append ( a [ 0 ] ) NEW_LINE DEDENT print ( len ( res ) ) NEW_LINE print ( * res ) NEW_LINE DEDENT
def command ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= True NEW_LINE arr [ b + 1 ] ^= True NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ k ] == True ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ False ] * ( n + 2 ) NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE
MAX = 26 ; NEW_LINE def maxLength ( str , len ) : NEW_LINE INDENT res = 0 ; NEW_LINE lastPos = [ - 1 ] * MAX ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT lastPos [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT C = ord ( str [ i ] ) - ord ( ' a ' ) ; NEW_LINE if ( lastPos [ C ] != - 1 ) : NEW_LINE INDENT res = max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; NEW_LINE DEDENT lastPos [ C ] = i ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " ; NEW_LINE len = len ( str ) ; NEW_LINE print ( maxLength ( str , len ) ) ; NEW_LINE DEDENT
MAX = 1000000 ; NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 ; NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k != 1 ) : NEW_LINE INDENT return j ; NEW_LINE DEDENT DEDENT return INT_MAX ; NEW_LINE DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT N = 2795 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT N = 59173 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT N = 1922 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT N = 5041 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def Odd_Sum ( n ) : NEW_LINE INDENT total = ( n + 1 ) // 2 NEW_LINE odd = total * total NEW_LINE return odd NEW_LINE DEDENT def Even_Sum ( n ) : NEW_LINE INDENT total = ( n ) // 2 NEW_LINE even = total * ( total + 1 ) NEW_LINE return even NEW_LINE DEDENT def sumLtoR ( L , R ) : NEW_LINE INDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) NEW_LINE even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 1 NEW_LINE R = 5 NEW_LINE print ( sumLtoR ( L , R ) ) NEW_LINE DEDENT
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 NEW_LINE upCost = 30 NEW_LINE lowQuant = 5 NEW_LINE upQuant = 12 NEW_LINE r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( math . ceil ( ( math . log ( n ) ) / math . log ( 2 ) ) ) == int ( math . floor ( ( math . log ( n ) ) / math . log ( 2 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE sums = set ( ) NEW_LINE sums . add ( 0 ) NEW_LINE for i in range ( 2 , 4 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in eulerlib . prime_generator ( LIMIT ) : NEW_LINE INDENT q = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT q *= p NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT r = q NEW_LINE for x in sums : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT newsums . add ( x + r ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if ( arr [ i ] - 1 ) in um : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 ) in um : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if ( longLen < um [ arr [ i ] ] ) : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Longest ▁ length ▁ subsequence ▁ = " , longLenSub ( arr , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE sum = 1 << n ; NEW_LINE return ( sum - 1 ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) ; NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if curr_sum > 0 : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE limit = 100000 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE lpow = [ False ] * ( limit + 1 ) NEW_LINE lpow [ 0 ] = 1 NEW_LINE def pow ( n , p ) : NEW_LINE INDENT if p < 0 : return 0 NEW_LINE if lpow [ p ] : NEW_LINE INDENT return lpow [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT if p % 2 == 0 : NEW_LINE INDENT ret = ( pow ( n , p // 2 ) ** 2 ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT ret = ( ( pow ( n , p // 2 ) ** 2 ) * n ) % mod NEW_LINE DEDENT lpow [ p ] = ret NEW_LINE return ret NEW_LINE DEDENT DEDENT def solve ( s ) : NEW_LINE INDENT res = 0 NEW_LINE ca = 0 NEW_LINE cc = s [ 0 ] NEW_LINE for c in s : NEW_LINE INDENT if c == ' # ' : NEW_LINE INDENT ca += 1 NEW_LINE DEDENT elif c == '8' : NEW_LINE INDENT cc -= 1 NEW_LINE DEDENT elif c == '5' : NEW_LINE INDENT cc -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT DEDENT res = pow ( 3 , ca , mod ) NEW_LINE ca = 0 NEW_LINE cc = 0 NEW_LINE for c in s [ 1 : ] : NEW_LINE INDENT if c == '8' : NEW_LINE INDENT ca += 1 NEW_LINE DEDENT elif c == '5' : NEW_LINE INDENT cc -= 1 NEW_LINE DEDENT elif c == '3' : NEW_LINE INDENT cc -= 1 NEW_LINE DEDENT elif c == '4' : NEW_LINE INDENT cc -= 1 NEW_LINE DEDENT res += ca * cc * pow ( 3 , ca , mod ) NEW_LINE ca = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( s ) ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
def idx ( row ) : NEW_LINE INDENT color_length = [ ] NEW_LINE i = 0 NEW_LINE while i < len ( row ) : NEW_LINE INDENT color , length = row [ i ] , 1 NEW_LINE while i < len ( row ) - 1 : NEW_LINE INDENT if row [ i + 1 ] == color : NEW_LINE INDENT length += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT color_length . append ( color ) NEW_LINE i += 1 NEW_LINE DEDENT return color_length NEW_LINE DEDENT def is_empty ( r , l , p ) : NEW_LINE INDENT while p - l > 0 : NEW_LINE INDENT lenght = p - l NEW_LINE if lenght == 1 : NEW_LINE INDENT if r == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if lenght == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if lenght > 2 : NEW_LINE INDENT if r == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if p < lenght : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if lenght == 3 : NEW_LINE INDENT if r == 1 : NEW_LINE INDENT return p NEW_LINE DEDENT else : NEW_LINE INDENT return r NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = input ( ) . split ( ) NEW_LINE for _ in range ( int ( r [ 0 ] ) ) : NEW_LINE INDENT l , r = map ( int , r [ 1 ] . split ( ) ) NEW_LINE print ( is_empty ( l , r , p ) ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE f = [ 0 ] * ( n + 1 ) NEW_LINE for _ in [ 0 ] * ( n + 1 ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE f [ a ] += 1 NEW_LINE f [ b ] -= 1 NEW_LINE DEDENT ans = ( f [ 0 ] - 1 ) * ( f [ 1 ] - 1 ) + ( f [ 0 ] - 1 ) * ( f [ 1 ] - 1 ) NEW_LINE if ans < m : ans = m NEW_LINE print ( ans ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE def print_string ( g1 , a , g2 , b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT print ( g1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " and ▁ " , end = " ▁ " ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( g2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def checksum ( g1 , a , g2 , b ) : NEW_LINE INDENT i , x = 0 , 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT x += g1 [ i ] NEW_LINE DEDENT for i in range ( b ) : NEW_LINE INDENT x -= g2 [ i ] NEW_LINE DEDENT return ( x == 0 ) NEW_LINE DEDENT def formgroups ( arr , x , g1 , a , g2 , b , n ) : NEW_LINE INDENT if ( x == n ) : NEW_LINE INDENT if ( checksum ( g1 , a , g2 , b ) ) : NEW_LINE INDENT print_string ( g1 , a , g2 , b ) NEW_LINE DEDENT return NEW_LINE DEDENT g1 [ a ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) NEW_LINE g2 [ b ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 9 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE g1 = [ 0 ] * MAX NEW_LINE g2 = [ 0 ] * MAX NEW_LINE formgroups ( arr , 0 , g1 , 0 , g2 , 0 , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT x = i NEW_LINE for j in range ( 1 , 4 ) : NEW_LINE INDENT if a == j : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT DEDENT DEDENT print ( n - max ( s ) ) NEW_LINE
def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( vec [ i ] == 1 ) : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vec [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input_list = [ 0 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE n = len ( input_list ) NEW_LINE print ( maxSubseq ( input_list , n ) ) NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , - 1 , 0 , 0 ] , [ - 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( countPaths ( maze ) ) NEW_LINE
from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True ; NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] ; NEW_LINE if ( N < 2 ) : NEW_LINE INDENT isPrime = False ; NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False ; NEW_LINE DEDENT for i in range ( sqrt ( N ) , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if ( c > sqrt ( N ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( not isPrime ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT print ( " Prime ▁ Number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Prime ▁ Number " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 121 ; NEW_LINE isPrime ( N ) ; NEW_LINE DEDENT
x1 , y1 , x2 , y2 = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE x3 , y3 = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE x4 , y4 = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE vec = ( x1 + y2 - x2 ) / 2 NEW_LINE v = ( y1 + y2 - y1 ) / 2 NEW_LINE print ( vec , v , t , u ) NEW_LINE
def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 ; NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT seq = " GEEKSFORGEEKS " ; NEW_LINE n = len ( seq ) ; NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is " , lps ( seq , 0 , n - 1 ) ) ; NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 0 , n - 2 + 1 ) : NEW_LINE INDENT l = i ; NEW_LINE r = i + 1 ; NEW_LINE lsum = 0 ; NEW_LINE rsum = 0 ; NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += ord ( string [ l ] ) - ord ( '0' ) ; NEW_LINE rsum += ord ( string [ r ] ) - ord ( '0' ) ; NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) ; NEW_LINE DEDENT l -= 1 ; NEW_LINE r += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "123123" ; NEW_LINE print ( " Length ▁ of ▁ the ▁ substring ▁ is " , findLength ( string , len ( string ) ) ) ; NEW_LINE DEDENT
def print ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = 6 NEW_LINE print ( a , n , 3 ) NEW_LINE
def print ( a , n , ind ) : NEW_LINE INDENT b = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( b [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = len ( a ) NEW_LINE print ( a , n , 3 ) NEW_LINE
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE x , y = b , a - 1 NEW_LINE for i in s : NEW_LINE INDENT if ( i == ' * ' ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT x = 1 NEW_LINE DEDENT elif ( x != y ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT y = 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT if ( x == y ) : NEW_LINE INDENT print ( x + y ) NEW_LINE DEDENT elif ( x < y ) : NEW_LINE INDENT print ( x - ( y - x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x + y - ( x - y ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , id , parent , child ) : NEW_LINE INDENT self . id = id NEW_LINE self . parent = parent NEW_LINE self . child = child NEW_LINE DEDENT DEDENT class BST : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = None NEW_LINE DEDENT def find ( self , id ) : NEW_LINE INDENT if id == self . root : NEW_LINE INDENT return self . id NEW_LINE DEDENT self . parent = self . find ( id ) NEW_LINE return self . parent NEW_LINE DEDENT def link ( self , id , child ) : NEW_LINE INDENT if self . child == child : NEW_LINE INDENT self . parent = parent NEW_LINE self . child = child NEW_LINE DEDENT else : NEW_LINE INDENT self . parent = parent NEW_LINE self . child = child NEW_LINE if self . child == self . parent : NEW_LINE INDENT self . parent = parent NEW_LINE DEDENT DEDENT DEDENT def link2 ( self , id , child ) : NEW_LINE INDENT if id == self . id : NEW_LINE INDENT self . parent = parent NEW_LINE self . child = child NEW_LINE DEDENT elif id == self . parent : NEW_LINE INDENT self . parent = parent NEW_LINE self . child = child NEW_LINE DEDENT else : NEW_LINE INDENT self . parent = parent NEW_LINE self . child = child NEW_LINE self . child = parent NEW_LINE DEDENT DEDENT DEDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE BST = BST ( ) NEW_LINE tree = BST ( ) NEW_LINE tree . link ( ) NEW_LINE for l , r in tree . link2 ( N , K ) : NEW_LINE INDENT tree . link ( l , R + 1 ) NEW_LINE DEDENT tree . sort ( ) NEW_LINE tree . reverse ( ) NEW_LINE for i in range ( K - 1 ) : NEW_LINE INDENT print ( " . " if tree . find ( i ) == None else " # " + tree . find ( i + 1 ) ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import collections NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlst ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def words ( ) : return [ i for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE def chars ( ) : return list ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT v1 , v2 = values ( ) NEW_LINE t , d = values ( ) NEW_LINE dp = [ [ 0 ] * ( t + 1 ) for _ in range ( d + 1 ) ] NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT if ( i - 1 ) % 2 == 0 : NEW_LINE INDENT for j in range ( 0 , d + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] [ j ] > j + i : NEW_LINE INDENT dp [ i ] [ j ] = j + i NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for j in range ( d + 1 , t + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] [ j ] > j + i : NEW_LINE INDENT dp [ i ] [ j ] = j + i NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , t + 1 ) : NEW_LINE INDENT if j - i <= d : NEW_LINE INDENT ans = max ( ans , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans + v1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE sort_s1 = sorted ( s1 ) NEW_LINE sort_s2 = sorted ( s2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n - 1 and s1 [ i ] < sort_s2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( j ) NEW_LINE
import math NEW_LINE import sys NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c = _input ( ) NEW_LINE m = max ( a , b , c ) NEW_LINE print ( m + ( m - ( m - m ) ) // 2 ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( "1" ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( * a [ i ] ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT bin ( 131 ) NEW_LINE print ( " " ) NEW_LINE bin ( 3 ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000 ) if i % 3 == 0 or i % 5 == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( s [ : n ] + ' ▁ ' . join ( s [ n : ] ) ) NEW_LINE
import sys NEW_LINE def solve ( X : int , Y : int ) : NEW_LINE INDENT print ( 2 * Y - X ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE X = int ( next ( tokens ) ) NEW_LINE Y = int ( next ( tokens ) ) NEW_LINE solve ( X , Y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while ( n ) : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE
def productDiagonals ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] NEW_LINE product = product * arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT product = product // arr [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT return product NEW_LINE DEDENT arr1 = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 7 , 4 , 2 ] , [ 2 , 2 , 2 , 1 ] ] NEW_LINE print ( productDiagonals ( arr1 , 4 ) ) NEW_LINE arr2 = [ [ 2 , 1 , 2 , 1 , 2 ] , [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 , 2 ] , [ 2 , 1 , 2 , 1 , 2 ] ] NEW_LINE print ( productDiagonals ( arr2 , 5 ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT line = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT counter [ line [ i ] ] += 1 NEW_LINE DEDENT counter [ 0 ] = 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT print ( " - " , end = " " ) NEW_LINE if counter [ i ] == 1 : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( " - " , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def getSecondMostFreq ( str ) : NEW_LINE INDENT count = [ 0 ] * ( NO_OF_CHARS ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return chr ( second ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE res = getSecondMostFreq ( str ) NEW_LINE if ( res != ' \ 0' ) : NEW_LINE INDENT print ( " Second ▁ most ▁ frequent ▁ char ▁ is " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ second ▁ most ▁ frequent " + " character " ) NEW_LINE DEDENT DEDENT
from __future__ import ( division , absolute_import , print_function , unicode_literals ) NEW_LINE from sys import stdin NEW_LINE L = [ 0 ] * 4001 NEW_LINE for i in range ( 0 , L [ 0 ] + 1 ) : NEW_LINE INDENT L [ i + 1 ] += L [ i ] NEW_LINE DEDENT for line in stdin : NEW_LINE INDENT n = int ( line ) NEW_LINE print ( L [ n ] ) NEW_LINE DEDENT
def mySort ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE arr1 = arr [ : n // 2 ] ; NEW_LINE arr2 = arr [ n // 2 : ] ; NEW_LINE arr1 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE arr2 . reverse ( ) ; NEW_LINE return arr1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] ; NEW_LINE arr1 = mySort ( arr ) ; NEW_LINE print ( " Modified ▁ array ▁ : " , arr ) ; NEW_LINE DEDENT
def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] > 0 ^ arr2 [ i ] > 0 != arr3 [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT if ( flip <= p + q ) : NEW_LINE INDENT return flip NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p = 2 NEW_LINE q = 4 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , sum ( n ) ) NEW_LINE
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE oddArr . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count , right , left = 0 , 0 , 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while right < n : NEW_LINE INDENT while right < n and not visited [ arr [ right ] ] : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while left < right and ( right != n and visited [ arr [ right ] ] ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def isSubtree ( self , s , t ) : NEW_LINE INDENT tree1 = self . preorder ( s , True ) NEW_LINE tree2 = self . preorder ( t , True ) NEW_LINE return tree1 . find ( tree2 ) >= 0 NEW_LINE DEDENT def preorder ( self , t , left ) : NEW_LINE INDENT if t == None : NEW_LINE INDENT return " lNone " NEW_LINE DEDENT if self . left : NEW_LINE INDENT return " rNone " NEW_LINE DEDENT return " # % d ▁ % d ▁ % d " % ( self . val , self . preorder ( t . left , True ) , self . preorder ( t . right , False ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 5 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 2 ) NEW_LINE subRoot = TreeNode ( 4 ) NEW_LINE subRoot . left = TreeNode ( 1 ) NEW_LINE subRoot . right = TreeNode ( 2 ) NEW_LINE out = sObj . isSubtree ( root , subRoot ) NEW_LINE print ( out ) NEW_LINE DEDENT
M = 1001 NEW_LINE MOD = 998244353 NEW_LINE dp = [ [ - 1 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE dp [ idx ] [ diff ] = ans % MOD NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M , K = 3 , 3 , 0 NEW_LINE print ( ( M * solve ( 2 , 0 , N , M , K ) ) ) NEW_LINE DEDENT
import math NEW_LINE def compute ( ) : NEW_LINE INDENT loserRadii = [ ( i + 30 ) * 1000 for i in range ( 21 ) ] NEW_LINE minLength = [ [ 0 ] * ( 2 ** 30 ) for i in range ( 21 ) ] NEW_LINE for i in range ( 0 , len ( sphereRadii ) ) : NEW_LINE INDENT minLength [ i ] [ ( 1 << 30 ) * 1000 ] = min ( findMinimumLength ( i , ( 1 << 30 ) - 1 ) + sphereRadii [ i ] , minLength [ i ] ) NEW_LINE DEDENT return min ( minValue [ 0 ] [ ( 1 << currentSphereIndex ) ] for ( currentSphereIndex , setOfSpheres ) in enumerate ( minLength [ currentSphereIndex ] ) if ( setOfSpheres & ( 1 << currentSphereIndex ) ) ) NEW_LINE DEDENT def findMinimumLength ( currentSphereIndex , setOfSpheres ) : NEW_LINE INDENT if ( ( setOfSpheres & ( 1 << currentSphereIndex ) ) == 0 ) : NEW_LINE INDENT return sphereRadii [ currentSphereIndex ] NEW_LINE DEDENT else : NEW_LINE INDENT newSetOfSpheres = setOfSpheres ^ ( 1 << currentSphereIndex ) NEW_LINE for i in range ( 0 , len ( sphereRadii ) ) : NEW_LINE INDENT if ( ( newSetOfSpheres & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = math . sqrt ( ( sphereRadii [ i ] + sphereRadii [ currentSphereIndex ] - 50000 ) * 200000 ) + findMinimumLength ( i , newSetOfSpheres ) NEW_LINE result = min ( temp , result ) NEW_LINE DEDENT DEDENT minLength [ currentSphereIndex ] [ setOfSpheres ] = result NEW_LINE return minLength [ currentSphereIndex ] [ setOfSpheres ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = x [ 0 ] * x [ 1 ] + x [ 2 ] * x [ 3 ] NEW_LINE f = False NEW_LINE for i in range ( 1 , len ( x ) ) : NEW_LINE INDENT if x [ i ] == a : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( N , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
import sys NEW_LINE def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def main ( ) : NEW_LINE INDENT l , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( l * p ) / ( p + q ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE print ( a [ n - 1 ] - a [ n - 0 ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from collections import defaultdict NEW_LINE d = defaultdict ( int ) NEW_LINE for i in a : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in d . keys ( ) : NEW_LINE INDENT res += d [ i ] * ( d [ i ] - 1 ) // 2 NEW_LINE DEDENT print ( res ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE c = input ( ) NEW_LINE m = len ( s1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if s1 [ i ] . isupper ( ) : NEW_LINE INDENT if s1 [ i ] == s2 [ i ] or s1 [ i ] == s2 [ i ] : NEW_LINE INDENT c = s1 [ : i ] + chr ( ord ( ' a ' ) + int ( s1 [ i ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s1 [ i ] . islower ( ) : NEW_LINE INDENT s1 [ i ] = chr ( ord ( ' a ' ) + int ( s1 [ i ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( s1 ) NEW_LINE
def getPaintCount ( string , color ) : NEW_LINE INDENT return len ( string ) - string . count ( color ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE S = input ( ) . strip ( ) NEW_LINE print ( getPaintCount ( S , ' W ' ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE t = 0 NEW_LINE for b in l : NEW_LINE INDENT if b % 2 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE from bisect import bisect_right NEW_LINE input = stdin . readline NEW_LINE def create_prime_list ( limit ) : NEW_LINE INDENT x = limit ** 0.5 NEW_LINE primes = [ ] NEW_LINE nums = [ x for x in range ( 2 , limit + 1 ) ] NEW_LINE while nums [ 0 ] <= x : NEW_LINE INDENT primes . append ( nums [ 0 ] ) NEW_LINE current_prime = nums [ 0 ] NEW_LINE nums = [ x for x in nums if x % current_prime != 0 ] NEW_LINE DEDENT primes . extend ( nums ) NEW_LINE return primes NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT primes = create_prime_list ( 10000 ) NEW_LINE twin_primes = [ ] NEW_LINE prev = primes [ 0 ] NEW_LINE for p in primes [ 1 : ] : NEW_LINE INDENT if p == prev + 2 : NEW_LINE INDENT twin_primes . append ( p ) NEW_LINE DEDENT prev = p NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT r = bisect_right ( twin_primes , n ) NEW_LINE print ( twin_primes [ r - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT
def powerOfTwo ( n ) : NEW_LINE INDENT return ( ( n & n - 1 ) == 0 ) NEW_LINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = int ( "9" ) NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT m = 6 NEW_LINE n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( ( p % a == 0 ) and gcd ( a , p // a ) == G ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD " , G ) NEW_LINE print ( " & ▁ LCM " , L ) NEW_LINE print ( " ▁ = ▁ " , countPairs ( G , L ) ) NEW_LINE
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for i in range ( 3 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT power ( F , n // 2 ) NEW_LINE multiply ( F , F ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT def findNthTerm ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE return power ( F , n - 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( " F ( 5 ) ▁ is " , findNthTerm ( n ) ) NEW_LINE
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT brokenPoint = 0 NEW_LINE for i in range ( 0 , len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT brokenPoint += 1 NEW_LINE if brokenPoint >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossibility ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( array [ i ] > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if ( sum > mid ) : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if ( count <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += array [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( check ( mid , array , n , K ) ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( array ) NEW_LINE K = 3 NEW_LINE print ( solve ( array , n , K ) ) NEW_LINE DEDENT
def solve ( m , n , lst ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return lst [ 0 ] NEW_LINE DEDENT p = [ 0 ] * ( m + 1 ) NEW_LINE for s in lst : NEW_LINE INDENT if not ( s >> m ) & p [ m ] : NEW_LINE INDENT p [ s ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT q = [ s ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT if not ( s >> i ) & p [ i ] : NEW_LINE INDENT q . append ( s >> i ) NEW_LINE DEDENT DEDENT DEDENT q . sort ( ) NEW_LINE p = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT if p [ i ] < q [ i - 1 ] : NEW_LINE INDENT p [ i ] = q [ i - 1 ] NEW_LINE DEDENT q [ i ] = max ( p [ i ] , q [ i - 1 ] ) NEW_LINE DEDENT DEDENT return p [ - 1 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT lst = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = solve ( m , n , lst ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a + b , a + b , a * b ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if max ( a ) - min ( b ) < 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT d = [ a [ 0 ] - b [ 0 ] for a in a ] NEW_LINE d . sort ( ) NEW_LINE if sum ( d ) != b [ 0 ] : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT N = "735" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE
from sys import stdin NEW_LINE class QueueNode ( object ) : NEW_LINE INDENT def __init__ ( self , data , next = None ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT class LinkList ( object ) : NEW_LINE INDENT def __init__ ( self , head = None ) : NEW_LINE INDENT self . head = head NEW_LINE self . tail = head NEW_LINE DEDENT def insert_q ( self , data ) : NEW_LINE INDENT node = QueueNode ( data ) NEW_LINE if self . head is None : NEW_LINE INDENT self . head = node NEW_LINE self . tail = node NEW_LINE return NEW_LINE DEDENT currentNode = self . tail NEW_LINE while True : NEW_LINE INDENT if currentNode . next is None : NEW_LINE INDENT currentNode . next = node NEW_LINE self . tail = node NEW_LINE break NEW_LINE DEDENT currentNode = currentNode . next NEW_LINE DEDENT DEDENT def delete_q ( self ) : NEW_LINE INDENT if self . head is not None : NEW_LINE INDENT currentNode = self . head NEW_LINE self . head = currentNode . next NEW_LINE DEDENT DEDENT def print_q ( self ) : NEW_LINE INDENT if self . head is not None : NEW_LINE INDENT print ( self . head . data ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT qnum , loopnum = map ( int , input ( ) . split ( " ▁ " ) ) NEW_LINE q = [ LinkList ( ) for i in range ( qnum ) ] NEW_LINE for i in range ( loopnum ) : NEW_LINE INDENT cmd = stdin . readline ( ) . strip ( ) . split ( ) NEW_LINE t , data = map ( int , cmd . split ( " ▁ " ) ) NEW_LINE if cmd [ 0 ] == "0" : NEW_LINE INDENT q . insert_q ( data = int ( data [ 1 ] ) ) NEW_LINE DEDENT elif cmd [ 0 ] == "1" : NEW_LINE INDENT q . print_q ( data [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT q . delete_q ( data [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a0 = a [ 0 ] % 2 NEW_LINE a1 = a [ 1 ] % 2 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a0 [ i ] % 2 == 0 : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 ; NEW_LINE X = " abcd " ; Y = " bcde " ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . extend ( a ) NEW_LINE b = gcd ( N , a ) NEW_LINE if b == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 0 ] % b == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return ( True ) if ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n , 2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
def isPrime ( x ) : NEW_LINE INDENT for i in range ( 2 , x ** 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( minimumCost ( n ) ) NEW_LINE DEDENT
def snoob ( x ) : NEW_LINE INDENT nextHigherOneBit , rightOnesPattern = 0 , 0 NEW_LINE if ( x > 0 ) : NEW_LINE INDENT rightOne = x & - x NEW_LINE nextHigherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE rightOnesPattern = ( rightOnesPattern ) // rightOne NEW_LINE rightOnesPattern >>= 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT x = 156 NEW_LINE print ( " Next ▁ higher ▁ number ▁ with ▁ same ▁ number ▁ of ▁ set ▁ bits ▁ is " , snoob ( x ) ) NEW_LINE
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i // j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE
import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinLength ( arr , n ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def getLevenstein ( input ) : NEW_LINE INDENT revInput = input [ : : - 1 ] NEW_LINE n = len ( input ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( input [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = sys . maxsize NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if ( i < n ) : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = " myfirstgeekarticle " NEW_LINE print ( getLevenstein ( input ) ) NEW_LINE DEDENT
import itertools NEW_LINE LIMIT = 12000 NEW_LINE minSumProduct = [ INF ] * ( LIMIT + 1 ) NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( n for n in minSumProduct ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorize ( n , remain , maxFactor , sum , terms ) : NEW_LINE INDENT if remain == 1 : NEW_LINE INDENT if sum > n : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT terms += n - sum NEW_LINE if terms <= LIMIT and n < minSumProduct [ terms ] : NEW_LINE INDENT minSumProduct [ terms ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in itertools . count ( 2 ) : NEW_LINE INDENT if remain % i == 0 : NEW_LINE INDENT factorize ( n , int ( remain / i ) , min ( factor , maxFactor ) , sum + factor , terms + 1 ) NEW_LINE DEDENT DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE from collections import Counter , deque NEW_LINE from collections import defaultdict NEW_LINE from itertools import combinations , permutations , accumulate , groupby , product NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heapify , heappop , heappush NEW_LINE from math import floor , ceil , pi , factorial NEW_LINE from operator import itemgetter NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def MI ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LI2 ( ) : return [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE def MXI ( ) : return [ [ LI ( ) ] for i in range ( n ) ] NEW_LINE def SI ( ) : return input ( ) . rstrip ( ) NEW_LINE def printns ( x ) : print ( ' \n ' . join ( x ) ) NEW_LINE def printni ( x ) : print ( ' \n ' . join ( list ( map ( str , x ) ) ) ) NEW_LINE inf = 10 ** 17 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE n = I ( ) NEW_LINE a = LI ( ) NEW_LINE ans = 0 NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT m = 1 NEW_LINE p = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = ( a [ i - 1 ] + i ) % m NEW_LINE DEDENT a [ i ] = 1 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] * ( n - i - 1 ) * p [ i ] NEW_LINE ans %= m NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import deque NEW_LINE class Queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = deque ( ) NEW_LINE DEDENT def Print ( self ) : NEW_LINE INDENT while ( len ( self . queue ) != 0 ) : NEW_LINE INDENT print ( self . queue . pop ( ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT def reverseQueue ( self ) : NEW_LINE INDENT if ( len ( self . queue ) != 0 ) : NEW_LINE INDENT return self . queue . popleft ( ) NEW_LINE DEDENT data = self . queue . pop ( ) NEW_LINE self . queue . append ( data ) NEW_LINE return self . queue NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queue = Queue ( ) NEW_LINE queue . Print ( ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min = MAX + 2 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( max == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( max - min ) NEW_LINE DEDENT DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( arr , n ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Difference ▁ is " , res ) NEW_LINE DEDENT
from heapq import heappush , heappop NEW_LINE def get_par ( x , par_lst ) : NEW_LINE INDENT if x == par_lst [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT p = get_par ( par_lst [ x ] , par_lst ) NEW_LINE par_lst [ x ] = p NEW_LINE return p NEW_LINE DEDENT while True : NEW_LINE INDENT v = int ( input ( ) ) NEW_LINE if v == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE que = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE heappush ( que , ( c , a , b ) ) NEW_LINE DEDENT par_lst = [ i for i in range ( v ) ] NEW_LINE ans = 0 NEW_LINE while que : NEW_LINE INDENT c , a , b = heappop ( que ) NEW_LINE pa , pb = get_par ( a , par_lst ) , get_par ( b , par_lst ) NEW_LINE if pa != pb : NEW_LINE INDENT par_lst [ pa ] = pb NEW_LINE ans += c NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = str ( n ) [ : : - 1 ] NEW_LINE print ( s [ 0 ] + s [ - 1 ] ) NEW_LINE
def distinctSubString ( P , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE if ( freq [ pos ] == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = 1 NEW_LINE s += P [ j ] NEW_LINE S . add ( s ) NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubString ( S , N ) ) NEW_LINE DEDENT
import math NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Ain = A . index ( 1 ) NEW_LINE if N == K : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( math . ceil ( Ain / ( K - 1 ) ) + math . ceil ( ( len ( A ) - ( K - 1 ) * ( math . ceil ( Ain / ( K - 1 ) ) ) - 1 ) / ( K - 1 ) ) ) NEW_LINE DEDENT
import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = INT_MAX ; NEW_LINE for i in range ( ( 1 << n ) ) : NEW_LINE INDENT cnt = ( int ) ( i . bit_length ( ) ) ; NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT temp . append ( a [ j ] ) ; NEW_LINE DEDENT DEDENT maxDiff = INT_MIN ; NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT DEDENT return minDiff ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE k = 2 ; NEW_LINE a = [ 3 , 7 , 8 , 10 , 14 ] ; NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) ; NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 5 , 9 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE difference ( arr , n ) NEW_LINE DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) // 2 NEW_LINE for i in range ( 1 , K // 2 + 1 , 1 ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K - i ] NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) // 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE
def solve ( a , b , c ) : NEW_LINE INDENT if a == '0' and b == '0' and c == '0' : NEW_LINE INDENT return ' NA ' NEW_LINE DEDENT if a == b == '1' and c == '1' : NEW_LINE INDENT return ' + ' NEW_LINE DEDENT elif a == b == '2' and c == '2' : NEW_LINE INDENT return ' NA ' NEW_LINE DEDENT if b == '0' and c == '1' : NEW_LINE INDENT return ' NA ' NEW_LINE DEDENT if a == b == '1' and c == '2' : NEW_LINE INDENT return ' NA ' NEW_LINE DEDENT return str ( a ) + b + c NEW_LINE DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == '0' : NEW_LINE INDENT break NEW_LINE DEDENT a , b , c = map ( str , s . split ( ) ) NEW_LINE print ( solve ( a , b , c ) ) NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " , maxOnesIndex ( arr , n ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for rem in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( n % rem == 0 ) : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a %= mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE b >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT a = 10123465234878998 ; NEW_LINE b = 65746311545646431 ; NEW_LINE m = 10005412336548794 ; NEW_LINE print ( moduloMultiplication ( a , b , m ) ) ; NEW_LINE
import sys NEW_LINE from operator import itemgetter NEW_LINE inf = 1 << 30 NEW_LINE def solve ( ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT * p , = range ( n ) NEW_LINE def root ( x ) : NEW_LINE INDENT r = x NEW_LINE while not p [ r ] < 0 : NEW_LINE INDENT r = p [ r ] NEW_LINE DEDENT t = x NEW_LINE while t != r : NEW_LINE INDENT x = t NEW_LINE DEDENT r = t NEW_LINE DEDENT return x NEW_LINE DEDENT def search ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while True : NEW_LINE INDENT if abs ( x [ i ] - y [ i ] ) > inf : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def unite ( x , y ) : NEW_LINE INDENT rx , ry = root ( x ) , root ( y ) NEW_LINE if rx == ry : NEW_LINE INDENT return NEW_LINE DEDENT if _ in [ rx , ry ] : NEW_LINE INDENT a = search ( x ) NEW_LINE if a : NEW_LINE INDENT r = find ( y ) NEW_LINE if r != a : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT b = search ( x ) NEW_LINE if b != a : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if a [ r ] < b : NEW_LINE INDENT r = find ( y ) NEW_LINE a [ r ] = b NEW_LINE DEDENT else : NEW_LINE INDENT g = find ( x ) NEW_LINE b [ g ] = a NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import sys NEW_LINE import numpy as np NEW_LINE sr = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ir = lambda : int ( sr ( ) ) NEW_LINE lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) NEW_LINE N = ir ( ) NEW_LINE A = np . array ( [ 0 ] + lr ( ) + [ 0 ] ) NEW_LINE diff = np . diff ( A ) NEW_LINE if diff < 0 : NEW_LINE INDENT answer = np . arange ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT answer = answer [ : i ] + np . where ( diff < 0 ) [ 0 ] [ 1 ] + ( A [ i ] == 0 ) NEW_LINE print ( * answer ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( answer [ i ] [ 0 ] + 1 , answer [ i + 1 ] [ 1 ] + 1 ) NEW_LINE DEDENT DEDENT
def checkPalindrome ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE l -= 1 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ l ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printSolution ( partitions ) : NEW_LINE INDENT for i in range ( len ( partitions ) ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def addStrings ( v , s , temp , index ) : NEW_LINE INDENT l = len ( s ) NEW_LINE str = " " NEW_LINE current = [ ] NEW_LINE if ( index == 0 ) : NEW_LINE INDENT temp . clear ( ) NEW_LINE DEDENT for i in range ( index , l ) : NEW_LINE INDENT str = str + s [ i ] NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT temp . append ( str ) NEW_LINE if ( i + 1 < l ) : NEW_LINE INDENT v = addStrings ( v , s , temp , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( temp ) NEW_LINE DEDENT temp = [ ] NEW_LINE current = [ ] NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT def partition ( s , v ) : NEW_LINE INDENT temp = [ ] NEW_LINE v = addStrings ( v , s , temp , 0 ) NEW_LINE printSolution ( v ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " NEW_LINE partitions = [ ] NEW_LINE partition ( s , partitions ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE R , C = map ( int , input ( ) . split ( ) ) NEW_LINE A1 , A2 = map ( int , input ( ) . split ( ) ) NEW_LINE B1 , B2 = map ( int , input ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def cumprod ( L , mod = 10 ** 9 + 7 ) : NEW_LINE INDENT L = L + 1 NEW_LINE A = [ 0 ] * L NEW_LINE for i in range ( L ) : NEW_LINE INDENT A [ i ] = l // i NEW_LINE A [ i ] %= MOD NEW_LINE DEDENT return A NEW_LINE DEDENT def nCr ( n , r , mod ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT num *= nCr ( n + i - 1 , r - i , mod ) NEW_LINE DEDENT return num NEW_LINE DEDENT def fermat_cmb ( n , r , mod ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT num *= nCr ( n + i - 1 , r - i , mod ) NEW_LINE DEDENT return num NEW_LINE DEDENT fermat_cmb ( R + C , R , mod ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT fermat_cmb ( R + C , i , mod ) NEW_LINE DEDENT max_ans = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT max_ans = max ( max_ans , fermat_cmb ( R + C , i , mod ) ) NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT max_ans = max ( max_ans , fermat_cmb ( R + C , i , mod ) ) NEW_LINE DEDENT print ( max_ans ) NEW_LINE
from collections import defaultdict NEW_LINE def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT numCount = [ 0 for i in range ( k + 1 ) ] NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT numCount [ i ] = 0 NEW_LINE DEDENT numCount = [ 0 for i in range ( k + 1 ) ] NEW_LINE for itr in sorted ( M ) : NEW_LINE INDENT if ( itr <= k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT numCount [ itr ] += M [ itr ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm = 0 NEW_LINE length = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( numCount [ i ] > length ) : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if ( lcm == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM ▁ = " , lcm , " , ▁ Length ▁ = " , length ) NEW_LINE print ( " Indexes ▁ = ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( lcm % arr [ i ] == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT k = 14 NEW_LINE arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findSubsequence ( arr , n , k ) NEW_LINE
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 , even1 = 0 , 0 NEW_LINE odd2 , even2 = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 80 , 100 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , size ) ) NEW_LINE DEDENT
import math NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 , 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n / 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE DEDENT
MAX = 26 NEW_LINE def minimumAddition ( str , length ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( length ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE length = len ( str ) NEW_LINE print ( minimumAddition ( str , length ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if abs ( s1 [ i ] - s2 [ i ] ) <= 5 : NEW_LINE INDENT sum += 10 NEW_LINE DEDENT else : NEW_LINE INDENT sum += abs ( s1 [ i ] - s2 [ i ] ) NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE
MAX = 32 NEW_LINE pow2 = [ 0 ] * MAX NEW_LINE visited = [ 0 ] * MAX NEW_LINE def power_2 ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pow2 [ i ] = ans NEW_LINE ans *= 2 NEW_LINE DEDENT DEDENT def countSetBits ( x ) : NEW_LINE INDENT setBits = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE setBits += 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT point = 0 NEW_LINE value = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( visited [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( num % 2 == 1 ) : NEW_LINE INDENT value += ( 1 << i ) NEW_LINE DEDENT num //= 2 NEW_LINE DEDENT DEDENT ans . append ( value ) NEW_LINE DEDENT def solve ( n , k ) : NEW_LINE INDENT ans = [ ] NEW_LINE countk = countSetBits ( k ) NEW_LINE if ( pow2 [ countk ] < n ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( pow2 [ countk ] - 1 ) : NEW_LINE INDENT add ( i ) NEW_LINE count += 1 NEW_LINE if ( count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE k = 5 NEW_LINE power_2 ( ) NEW_LINE solve ( n , k ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( range ( - 1000 , 1001 ) , key = numberOf_consecutive_primes_generating ) NEW_LINE return str ( ans * ans ) NEW_LINE DEDENT def numberOf_consecutive_primes_generating ( a , b ) : NEW_LINE INDENT for i in itertools . count ( ) : NEW_LINE INDENT n = i ** 2 + i ** a + b NEW_LINE if n < 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE res = ( k * ( k + 1 ) ) // 2 NEW_LINE print ( res ) NEW_LINE DEDENT
MAX = 100001 ; NEW_LINE isPrime = [ 0 ] * MAX ; NEW_LINE def sieve ( ) : NEW_LINE INDENT k = int ( MAX ** ( 0.5 ) ) ; NEW_LINE for p in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT return - 1 ; NEW_LINE DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT cnt1 += 1 ; NEW_LINE DEDENT DEDENT if ( cnt1 > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 ) and ( isPrime [ a [ i ] + 1 ] == 0 ) ) : NEW_LINE INDENT print ( cnt1 + 1 ) ; NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) ; NEW_LINE DEDENT print ( a [ i ] ) ; NEW_LINE return 0 ; NEW_LINE DEDENT DEDENT DEDENT if ( cnt1 >= 2 ) : NEW_LINE INDENT print ( cnt1 ) ; NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return 0 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) : NEW_LINE INDENT print ( 2 ) ; NEW_LINE print ( a [ i ] , a [ j ] , end = " ▁ " ) ; NEW_LINE return 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT sieve ( ) ; NEW_LINE A = [ 2 , 1 , 1 ] ; NEW_LINE n = len ( A ) ; NEW_LINE findSubset ( A , n ) ; NEW_LINE
n , r , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = dict ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i * r + j ) % t in d : NEW_LINE INDENT d [ ( i * r + j ) % r ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ ( i * r + j ) % r ] = 1 NEW_LINE DEDENT DEDENT ans += d [ ( i * r ) % r ] NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( len ( s ) - 4 ) : NEW_LINE INDENT if s [ i ] == " H " and s [ i + 1 ] == " o " and s [ i + 2 ] == " s " and s [ i + 3 ] == " n " and s [ i + 4 ] == " a " : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT if s [ len ( s ) - 4 ] == " H " and s [ len ( s ) - 5 ] == " n " and s [ len ( s ) - 6 ] == " a " : NEW_LINE INDENT ans += s [ len ( s ) - 5 ] NEW_LINE DEDENT ans += s [ len ( s ) - 6 ] NEW_LINE print ( ans ) NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , 0 , n - 1 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = ( k + 1 ) // n NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d = ( d + 1 ) // n NEW_LINE res = max ( res , d ) NEW_LINE DEDENT print ( res ) NEW_LINE
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ 0 ] * m NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( ( j + arr [ i ] ) % m ) == False : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT DEDENT return DP [ 0 ] NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE if ( modularSum ( arr , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , k = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for j in range ( e - b ) : NEW_LINE INDENT if a [ j ] == k : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( w ) NEW_LINE d = [ 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] = min ( w [ i ] , d [ i - 1 ] ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] < w [ i - 1 ] : NEW_LINE INDENT c += w [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT c += d [ i ] NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
while True : NEW_LINE INDENT d , w = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT c = 9 NEW_LINE min_v = min ( p ) NEW_LINE for i in range ( d - 1 ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if p [ i ] [ j ] > c : NEW_LINE INDENT c = p [ i ] [ j ] NEW_LINE min_v = p [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if c < min_v : NEW_LINE INDENT if d > max_v : NEW_LINE INDENT max_v = d NEW_LINE DEDENT min_v = c NEW_LINE DEDENT for i in range ( d - 1 ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if p [ i ] [ j ] > c : NEW_LINE INDENT d = p [ i ] [ j ] NEW_LINE min_v = p [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return max_v NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT while True : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE c = 0 NEW_LINE for i in l : NEW_LINE INDENT if i <= k * l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
from math import pow NEW_LINE def sum ( k , n ) : NEW_LINE INDENT sum = pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE DEDENT
import numpy as np ; NEW_LINE dp = np . zeros ( ( 18 , 2 ) ) * - 1 ; NEW_LINE def solve ( i , tight , sum_so_far , Sum , number , len1 ) : NEW_LINE INDENT if ( i == len1 ) : NEW_LINE INDENT if ( sum_so_far == Sum ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = dp [ i ] [ 1 ] [ sum_so_far ] ; NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT ans = 0 ; NEW_LINE ntight ; NEW_LINE nsum_so_far = 0 ; NEW_LINE for currdigit in range ( ord ( '0' ) , ord ( '9' ) + 1 ) : NEW_LINE INDENT if ( currdigit < ord ( number [ i ] ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ntight = tight or currdigit < ord ( number [ i ] ) ; NEW_LINE nsum_so_far = sum_so_far + ( currdigit - ord ( '0' ) ) ; NEW_LINE ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , len1 ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT count = 0 ; NEW_LINE sum = 4 ; NEW_LINE number = "100" ; NEW_LINE print ( solve ( 0 , 0 , 0 , sum , number , len ( number ) ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT students = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in students : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > 1 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenOddLevelDifference ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while ( size ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . left . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 7 ) NEW_LINE print ( " Difference ▁ between ▁ sums ▁ is " , evenOddLevelDifference ( root ) ) NEW_LINE DEDENT
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT number += ( count ) * ( count + 1 ) // 2 NEW_LINE DEDENT return number NEW_LINE DEDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 ; NEW_LINE count_odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 1 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minCost ( arr , n ) ) ; NEW_LINE DEDENT
def printLastOccurrence ( a , n ) : NEW_LINE INDENT map = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] == i ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE printLastOccurrence ( a , n ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = 0 NEW_LINE f = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 0 : NEW_LINE INDENT if a [ i ] == 0 : p += 1 NEW_LINE else : f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if f : print ( " NA " ) NEW_LINE else : print ( p ) NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 20 ; NEW_LINE a = 2.5 ; NEW_LINE d = 1.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 0 , 3 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT
def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT index = 0 NEW_LINE mp = { } NEW_LINE for itr in s : NEW_LINE INDENT index += 1 NEW_LINE mp [ itr ] = index NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT def query ( BIT , index , n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( index ) : NEW_LINE INDENT ans = max ( ans , BIT [ index ] ) NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def update ( BIT , index , n ) : NEW_LINE INDENT x = query ( BIT , index - 1 , n ) NEW_LINE value = x + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def findLISLength ( arr , n ) : NEW_LINE INDENT coordinateCompression ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT update ( BIT , arr [ i ] , n ) NEW_LINE DEDENT ans = query ( BIT , n , n ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ans = findLISLength ( arr , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a = 0 NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if l [ i ] == 1 : NEW_LINE INDENT a += l [ i ] [ 0 ] NEW_LINE DEDENT elif l [ i ] == 0 : NEW_LINE INDENT a -= l [ i - 1 ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT a += l [ i - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT ans = False NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT if a > 0 : NEW_LINE INDENT ans = True NEW_LINE DEDENT p = l [ i ] NEW_LINE check = 0 NEW_LINE for j in range ( len ( p ) ) : NEW_LINE INDENT z = p [ j ] NEW_LINE if z == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if p [ 0 ] [ j ] == 0 and p [ 1 ] [ j ] == 0 : NEW_LINE INDENT z = 1 NEW_LINE DEDENT if z == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if p [ 0 ] [ j ] == 0 and p [ 1 ] [ j ] == 0 : NEW_LINE INDENT check = True NEW_LINE DEDENT DEDENT DEDENT if check == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE ways = [ [ 0 ] * ( DIGITS + CONSECUTIVE + 1 ) for i in range ( 1 , len ( ways ) ) ] NEW_LINE def digit_sum ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT s += n % 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def sum_digit ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT s += n % 10 NEW_LINE DEDENT return s NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT for prefix in range ( len ( ways ) ) : NEW_LINE INDENT if sum_digit ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextDigit in range ( BASE ) : NEW_LINE INDENT ans . append ( ways [ digits - 1 ] [ prefix % ( BASE ** CONSECUTIVE - 1 ) * BASE + nextDigit ] ) NEW_LINE DEDENT DEDENT ways . append ( ways [ digits ] [ prefix ] - sum_digit ( ways [ digits ] [ prefix ] ) ) NEW_LINE DEDENT DEDENT return str ( ans [ DIGITS + CONSECUTIVE ] [ 0 ] - ways [ DIGITS + CONSECUTIVE - 1 ] [ 0 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT l1 = list ( input ( ) . strip ( ) ) NEW_LINE l2 = list ( input ( ) . strip ( ) ) NEW_LINE l3 = list ( input ( ) . strip ( ) ) NEW_LINE l4 = list ( map ( int , l1 ) ) NEW_LINE if l2 [ 0 ] == l3 [ 0 ] or l2 [ 0 ] == l3 [ 0 ] or l3 [ 0 ] == l1 [ 1 ] or l2 [ 1 ] == l3 [ 1 ] or l3 [ 1 ] == l1 [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( 1 , len ( matrix ) ) : NEW_LINE INDENT for c in range ( 1 , len ( matrix [ 0 ] ) ) : NEW_LINE INDENT if matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 2 , 3 ] , [ 9 , 5 , 1 , 2 ] ] NEW_LINE out = sObj . isToeplitzMatrix ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = sum ( range ( 1 , eulerlib . sqrt ( LIMIT + 1 ) // 3 * 2 ) for s in range ( 1 , eulerlib . sqrt ( LIMIT + 1 ) , 2 ) ) NEW_LINE for s in range ( 1 , eulerlib . sqrt ( LIMIT + 1 ) , 2 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , t , l , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE f = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( t + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for k in range ( 1 , 7 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if f [ i ] [ k ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if i + k - 1 <= n and f [ i + k - 1 ] == 1 : NEW_LINE INDENT dp [ i + k ] [ k ] += dp [ i ] [ k ] / 6 NEW_LINE continue NEW_LINE DEDENT if j + k - 1 <= t and f [ i ] [ j + k - 1 ] == 1 : NEW_LINE INDENT dp [ i + k ] [ j + k ] += dp [ i ] [ j ] / 6 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + k ] [ j + k ] += dp [ i ] [ j ] / 6 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if dp [ n ] [ i ] <= 1.0 : ans += dp [ n ] [ i ] NEW_LINE DEDENT print ( ' { : . 12f } ' . format ( ans ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE od_sum = 0 NEW_LINE ev_sum = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT od_sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ev_sum += 1 NEW_LINE DEDENT DEDENT if od_sum % 2 == 0 and ev_sum > 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from math import ceil NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += ceil ( diff // K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H = [ 2 , 4 , 8 , 16 ] NEW_LINE K = 3 NEW_LINE n = len ( H ) NEW_LINE print ( mininsertions ( H , n , K ) ) NEW_LINE DEDENT
def countWords ( str , length ) : NEW_LINE INDENT count = 1 NEW_LINE if length == 1 : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , length - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ length - 1 ] == str [ length - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT str = " abc " NEW_LINE length = len ( str ) NEW_LINE print ( countWords ( str , length ) ) NEW_LINE
n = input ( ) NEW_LINE n = int ( n ) NEW_LINE numbers = input ( ) NEW_LINE numbers = numbers . split ( ) NEW_LINE numbers = [ int ( i ) for i in numbers ] NEW_LINE even = [ ] NEW_LINE odd = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if numbers [ i ] % 2 == 0 : NEW_LINE INDENT even . append ( numbers [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( numbers [ i ] ) NEW_LINE DEDENT DEDENT even . sort ( ) NEW_LINE odd . sort ( ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( sum ( even [ : n ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( odd [ n // 2 : ] ) ) NEW_LINE DEDENT
def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE i += 1 NEW_LINE current = i ** 2 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE secondMax = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] NEW_LINE secondMax = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return ( max + secondMax ) NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE max = maxPairSum ( arr ) NEW_LINE perfectSquares = getPerfectSquares ( max ) NEW_LINE nums = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums [ arr [ i ] ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] NEW_LINE print ( countPairs ( arr ) ) NEW_LINE DEDENT
import math NEW_LINE def findHypotenuse ( side1 , side2 ) : NEW_LINE INDENT h = math . sqrt ( ( side1 * side1 ) + ( side2 * side2 ) ) NEW_LINE return round ( h , 2 ) NEW_LINE DEDENT side1 = 3 NEW_LINE side2 = 4 NEW_LINE print ( findHypotenuse ( side1 , side2 ) ) NEW_LINE
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " & " , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pos = 0 NEW_LINE while pos != n - 1 : NEW_LINE INDENT nxt = pos NEW_LINE mn = l [ pos ] NEW_LINE for i in range ( pos + 1 , n ) : NEW_LINE INDENT if l [ i ] < mn : NEW_LINE INDENT mn = l [ i ] NEW_LINE pos = i NEW_LINE DEDENT DEDENT q = nxt NEW_LINE while q != pos : NEW_LINE INDENT q -= 1 NEW_LINE DEDENT if q == pos : NEW_LINE INDENT p = nxt NEW_LINE DEDENT else : NEW_LINE INDENT p = nxt NEW_LINE DEDENT DEDENT print ( abs ( pos - p ) + abs ( pos - q ) ) NEW_LINE DEDENT
import datetime NEW_LINE import locale NEW_LINE d = int ( input ( ) ) NEW_LINE dt = datetime . datetime ( 2004 , a , d ) NEW_LINE print ( dt . strftime ( " % a " ) . lower ( ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . count ( " O " ) == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( s ) NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE for i in l : NEW_LINE INDENT if i [ 0 ] == " O " : NEW_LINE INDENT if l [ 1 ] == " + " : NEW_LINE INDENT print ( l [ 0 ] + " + " + l [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l [ 0 ] + " + " + l [ 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE while ( temp != head ) : NEW_LINE INDENT print ( temp . data , end = " - > " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( head . data ) NEW_LINE DEDENT def deleteK ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while ( True ) : NEW_LINE INDENT if ( curr . next == head and curr == head ) : NEW_LINE INDENT break NEW_LINE DEDENT printList ( head ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if ( curr == head ) : NEW_LINE INDENT prev = head NEW_LINE while ( prev . next != head ) : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif ( curr . next == head ) : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT def insertNode ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = Node ( x ) NEW_LINE if ( head == None ) : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while ( temp1 . next != head ) : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertNode ( head , 1 ) NEW_LINE head = insertNode ( head , 2 ) NEW_LINE head = insertNode ( head , 3 ) NEW_LINE head = insertNode ( head , 4 ) NEW_LINE head = insertNode ( head , 5 ) NEW_LINE head = insertNode ( head , 6 ) NEW_LINE head = insertNode ( head , 7 ) NEW_LINE head = insertNode ( head , 8 ) NEW_LINE head = insertNode ( head , 9 ) NEW_LINE k = 4 NEW_LINE head = deleteK ( head , k ) NEW_LINE DEDENT
import sys NEW_LINE def steps ( cur , x , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) // x ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE print ( abs ( x1 - x2 ) + abs ( y1 - y2 ) + abs ( x2 - x1 ) ) NEW_LINE
from math import gcd as __gcd NEW_LINE def cntSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; NEW_LINE if ( curr_gcd == 1 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += 0 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubArr ( arr , n ) ) ; NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) == False and prime [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE if ( isVowelPrime ( str , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = np . zeros ( ( N + 1 , N + 1 ) ) ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT DEDENT for length in range ( 1 , N + 1 ) : NEW_LINE INDENT for i in range ( length - 1 , N ) : NEW_LINE INDENT if ( length == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ N - 1 ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "2553432" ; NEW_LINE print ( minStepToDeleteString ( str ) ) ; NEW_LINE DEDENT
limit = 10000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT position [ i ] = pos + 1 NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT sieve ( ) NEW_LINE n = 11 NEW_LINE print ( position [ n ] ) NEW_LINE
DP_s = 9 NEW_LINE def getNumMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for i in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( ln ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = ( DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
DP_s = 9 NEW_LINE def getNumMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for i in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( ln ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = ( DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( mx + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 for i in range ( mx + 1 ) ] NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] == " R " : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for j in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
import math NEW_LINE def findArea ( r ) : NEW_LINE INDENT return PI * pow ( r , 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Area ▁ is ▁ " , findArea ( 5 ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = { i : 0 for i in range ( 1 , 2 * k + 1 ) } NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] - 1 ] += 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x != y : NEW_LINE INDENT d [ x ] += d [ y ] NEW_LINE d [ y ] = d [ x ] + min ( d [ y ] , 2 * k - d [ x ] ) NEW_LINE DEDENT DEDENT print ( sum ( d ) ) NEW_LINE
def nthTerm ( N ) : NEW_LINE INDENT return abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE DEDENT
V = 4 NEW_LINE def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT graph = [ [ 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE u = 0 NEW_LINE v = 3 NEW_LINE k = 2 NEW_LINE print ( countwalks ( graph , u , v , k ) ) NEW_LINE
import math NEW_LINE def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * math . log10 ( n / M_E ) + math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( math . log10 ( b ) ) NEW_LINE return int ( math . floor ( x ) + 1 ) NEW_LINE DEDENT print ( findDigits ( 4 , 16 ) ) NEW_LINE print ( findDigits ( 5 , 8 ) ) NEW_LINE print ( findDigits ( 12 , 16 ) ) NEW_LINE print ( findDigits ( 19 , 13 ) ) NEW_LINE
class SegmentTree : NEW_LINE INDENT seg_len = 1 NEW_LINE node = [ ] NEW_LINE def __init__ ( self , n ) : NEW_LINE INDENT while self . seg_len < n : NEW_LINE INDENT self . seg_len <<= 1 NEW_LINE DEDENT self . node = [ 0 for _ in range ( self . seg_len * 2 ) ] NEW_LINE DEDENT def add ( self , a , x ) : NEW_LINE INDENT x += self . seg_len NEW_LINE self . node [ a ] += x NEW_LINE while x <= self . seg_len : NEW_LINE INDENT self . node [ x ] += self . node [ x ] NEW_LINE x += x & - x NEW_LINE DEDENT DEDENT def get ( self , idx ) : NEW_LINE INDENT idx += self . seg_len NEW_LINE while idx > 0 : NEW_LINE INDENT idx = ( idx << 1 ) + self . node [ idx ] NEW_LINE DEDENT return idx NEW_LINE DEDENT def sum ( self , r ) : NEW_LINE INDENT r = self . sum_r ( r ) NEW_LINE return r NEW_LINE DEDENT def add_node ( self , a , x ) : NEW_LINE INDENT node_idx = ( a + self . seg_len ) // 2 NEW_LINE if r & 1 : NEW_LINE INDENT node_idx += 1 NEW_LINE DEDENT r = ( r + self . seg_len ) // 2 NEW_LINE add_node ( self . seg_len , a , x ) NEW_LINE DEDENT DEDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE seg_tree = SegmentTree ( n ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT query = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE if len ( query ) == 2 : NEW_LINE INDENT _ , x , y = query NEW_LINE node = int ( v ) NEW_LINE num = seg_tree . sum ( num ) NEW_LINE print ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT _ , x , y = query NEW_LINE node = int ( v ) NEW_LINE add_node ( node , x ) NEW_LINE DEDENT DEDENT
import math NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def f ( x , s ) : NEW_LINE INDENT if min ( x , s ) < 0 : return 0 NEW_LINE if max ( x , s ) < 2 : NEW_LINE INDENT if x and s : return 2 NEW_LINE else : return 1 NEW_LINE DEDENT if ( x , s ) in memo : return memo [ x , s ] NEW_LINE res = f ( x >> 1 , s >> 1 ) + f ( x - 1 >> 1 , s - 1 >> 1 ) + f ( x >> 1 , s - 2 >> 1 ) NEW_LINE res = memo [ x , s ] = res % md NEW_LINE return res NEW_LINE DEDENT memo = { } NEW_LINE md = 10 ** 9 + 7 NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE print ( f ( n , n ) ) NEW_LINE DEDENT main ( ) NEW_LINE
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) [ : - 1 ] NEW_LINE def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( a , b , c , d ) : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( a ) NEW_LINE return NEW_LINE DEDENT x = a * c NEW_LINE y = b // d NEW_LINE if x >= 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT for i in range ( 2 , int ( x ** 0.5 ) + 1 ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT y = x NEW_LINE if y > c : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT while 1 : NEW_LINE INDENT a , b , c , d = LI ( ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT break NEW_LINE DEDENT solve ( a , b , c , d ) NEW_LINE DEDENT DEDENT
def ReverseString ( s ) : NEW_LINE INDENT arr = list ( s ) NEW_LINE for i in range ( int ( len ( arr ) / 2 ) ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ len ( arr ) - i - 1 ] NEW_LINE arr [ len ( arr ) - i - 1 ] = temp NEW_LINE DEDENT return arr NEW_LINE DEDENT def binary_conversion ( m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT tmp = m % 2 NEW_LINE s += str ( tmp ) NEW_LINE m = int ( m // 2 ) NEW_LINE DEDENT s = ReverseString ( s ) NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT binary_conversion ( m ) NEW_LINE s1 = " " NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ y ] == '1' ) : NEW_LINE INDENT s1 += "10" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += "01" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = " " NEW_LINE DEDENT return ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT m = 5 NEW_LINE n = 2 NEW_LINE i = 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE
import math NEW_LINE def countSubsets ( arr , n ) : NEW_LINE INDENT us = dict ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT us [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT even_count = len ( us ) NEW_LINE return ( int ) ( math . pow ( 2 , even_count ) - 1 ) NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ subsets ▁ = ▁ " , countSubsets ( arr , n ) ) NEW_LINE
MAX = 1000 NEW_LINE f = [ 0 for i in range ( MAX ) ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = 0 NEW_LINE if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT k = ( n + 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n / 2 NEW_LINE DEDENT if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) ) NEW_LINE DEDENT a , b = 3 , 12 NEW_LINE print ( int ( findLCMFibonacci ( a , b ) ) ) NEW_LINE
import math NEW_LINE def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 ; NEW_LINE sum = 0 ; NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w ; NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w ; NEW_LINE DEDENT sum = int ( math . pow ( 10 , n - 2 ) ) ; NEW_LINE sum = ( x * sum ) ; NEW_LINE return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE w = 4 ; NEW_LINE print ( findNumbers ( n , w ) ) ; NEW_LINE DEDENT
def findKthChar ( s , k ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE i = 0 ; NEW_LINE total_len = 0 ; NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT total_len += 1 ; NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 ; NEW_LINE while ( i < l and ( s [ i ] >= '0' and s [ i ] <= '9' ) ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT next_total_len = total_len * n ; NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len ; NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len ; NEW_LINE DEDENT return findKthChar ( s , pos ) ; NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len ; NEW_LINE DEDENT DEDENT DEDENT return ' ▁ ' ; NEW_LINE DEDENT s = " ab2c3" ; NEW_LINE k = 5 ; NEW_LINE print ( findKthChar ( s , k ) ) ; NEW_LINE
def countNonEmptySubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT s = " abcde " NEW_LINE print ( countNonEmptySubstr ( s ) ) NEW_LINE