import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrimeNumberGenerator pg = new PrimeNumberGenerator ( ) ; while ( true ) { int n = Integer . parseInt ( br . readLine ( ) ) ; if ( n == 0 ) { break ; } if ( pg . isPrime ( n ) ) { System . out . println ( 0 ) ; continue ; } int begin = - 1 ; int end = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( pg . isPrime ( i ) ) { begin = i ; break ; } } for ( int i = n + 1 ; i < 2000000 ; i ++ ) { if ( pg . isPrime ( i ) ) { end = i ; break ; } } System . out . println ( end - begin ) ; } } } class PrimeNumberGenerator { private final int N = 2000000 ; private boolean [ ] isPrime = new boolean [ N + 1 ] ; public PrimeNumberGenerator ( ) { Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; int limit = ( int ) Math . sqrt ( N ) ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( isPrime [ i ] == false ) { continue ; } for ( int j = i * 2 ; j <= N ; j += i ) { isPrime [ j ] = false ; } } } public boolean isPrime ( int index ) { return isPrime [ index ] ; } }
public class GFG { static char MAX_CHAR = 26 ; static void countFreq ( String str , int freq [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } } static boolean canMakePalindrome ( int freq [ ] , int len ) { int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { count_odd ++ ; } } if ( len % 2 == 0 ) { if ( count_odd > 0 ) { return false ; } else { return true ; } } if ( count_odd != 1 ) { return false ; } return true ; } static String findOddAndRemoveItsFreq ( int freq [ ] ) { String odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str = odd_str + ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; } static String findPalindromicString ( String str ) { int len = str . length ( ) ; int freq [ ] = new int [ MAX_CHAR ] ; countFreq ( str , freq , len ) ; if ( ! canMakePalindrome ( freq , len ) ) { return " No ▁ Palindromic ▁ String " ; } String odd_str = findOddAndRemoveItsFreq ( freq ) ; String front_str = " " , rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) { temp = temp + ch ; } front_str = front_str + temp ; rear_str = temp + rear_str ; } } return ( front_str + odd_str + rear_str ) ; } public static void main ( String [ ] args ) { String str = " malayalam " ; System . out . println ( findPalindromicString ( str ) ) ; } }
import java . awt . geom . Line2D ; import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { int q = in . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) new CGL_2B ( ) . doIt ( ) ; } class CGL_2B { double segSegDist ( Line2D l1 , Line2D l2 ) { return l1 . intersectsLine ( l2 ) ? 0 : Math . min ( Math . min ( l1 . ptSegDist ( l2 . getP1 ( ) ) , l1 . ptSegDist ( l2 . getP2 ( ) ) ) , Math . min ( l2 . ptSegDist ( l1 . getP1 ( ) ) , l2 . ptSegDist ( l1 . getP2 ( ) ) ) ) ; } void doIt ( ) { Line2D l1 = new Line2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) ) ; ; Line2D l2 = new Line2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) ) ; ; System . out . printf ( " % .10f \n " , segSegDist ( l1 , l2 ) ) ; } } }
public class GFG { static int count9s ( char number [ ] ) { int n = number . length ; int d [ ] = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( number [ i ] - '0' ) == 0 ) { continuous_zero ++ ; } else { continuous_zero = 0 ; } mod_sum += ( number [ i ] - '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( count9s ( "01809" . toCharArray ( ) ) ) ; System . out . println ( count9s ( "1809" . toCharArray ( ) ) ) ; System . out . println ( count9s ( "4189" . toCharArray ( ) ) ) ; } }
import java . io . * ; public class GFG { static int fastPow ( int N , int K ) { if ( K == 0 ) return 1 ; int temp = fastPow ( N , K / 2 ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } static int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 , K = 3 ; System . out . println ( countWays ( N , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] s = { { 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 0 , 0 , 0 , 0 , 1 , 1 , 0 } , { 1 , 0 , 1 , 1 , 0 , 1 , 1 } , { 1 , 0 , 0 , 1 , 1 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 1 , 0 } , { 1 , 1 , 0 , 1 , 1 , 0 , 1 } , { 1 , 1 , 1 , 1 , 1 , 0 , 1 } , { 0 , 1 , 0 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 0 , 1 , 1 , 1 , 1 } } ; for ( ; ; ) { int n = sc . nextInt ( ) ; int [ ] a = new int [ 7 ] ; if ( n == - 1 ) { break ; } while ( n -- > 0 ) { int m = sc . nextInt ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { System . out . print ( ( a [ i ] ^ s [ m ] [ i ] ) + ( i == 6 ? " \n " : " " ) ) ; } a = s [ m ] . clone ( ) ; } } } }
import java . util . * ; public class GFG { static final int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class GFG { static final int MAX = 1000000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static boolean [ ] prime = new boolean [ MAX ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isPrimorialPrime ( int n ) { if ( ! prime [ n ] ) return false ; long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n || product - 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isPrimorialPrime ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static void mul_table ( int N , int i ) { if ( i > 10 ) return ; System . out . println ( N + " ▁ * ▁ " + i + " ▁ = ▁ " + N * i ) ; mul_table ( N , i + 1 ) ; } public static void main ( String [ ] args ) { int N = 8 ; mul_table ( N , 1 ) ; } }
public class close_to_n_divisible_m { static int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; } public static void main ( String args [ ] ) { int n = 13 , m = 4 ; System . out . println ( closestNumber ( n , m ) ) ; n = - 15 ; m = 6 ; System . out . println ( closestNumber ( n , m ) ) ; n = 0 ; m = 8 ; System . out . println ( closestNumber ( n , m ) ) ; n = 18 ; m = - 7 ; System . out . println ( closestNumber ( n , m ) ) ; } }
public class GFG { static int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; } public static void main ( String [ ] args ) { int ang = 90 , n = 4 ; System . out . println ( solve ( ang , n ) ) ; } }
public class GFG { static int [ ] compute_lps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } static void Longestsubstring ( String s ) { int [ ] lps = compute_lps ( s ) ; int n = s . length ( ) ; if ( lps [ n - 1 ] == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) System . out . println ( - 1 ) ; else System . out . println ( s . substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; } public static void main ( String [ ] args ) { String s = " fixprefixsuffix " ; Longestsubstring ( s ) ; } }
import java . io . * ; public class GFG { static void checkIfSortRotated ( int arr [ ] , int n ) { int minEle = Integer . MAX_VALUE ; int maxEle = Integer . MIN_VALUE ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } boolean flag1 = true ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = false ; break ; } } boolean flag2 = true ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = false ; break ; } } if ( minIndex == 0 ) { System . out . print ( " NO " ) ; return ; } if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) System . out . println ( " YES " ) ; else System . out . print ( " NO " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . length ; checkIfSortRotated ( arr , n ) ; } }
import java . util . Scanner ; public class IS { public static void main ( String [ ] args ) { new IS ( ) . runapp ( ) ; } void runapp ( ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int d = scan . nextInt ( ) ; int [ ] sequence = new int [ n ] ; int step = 0 ; int store ; for ( int x = 0 ; x < n ; x ++ ) { sequence [ x ] = scan . nextInt ( ) ; } for ( int y = 0 ; y < n - 1 ; y ++ ) { while ( sequence [ y + 1 ] <= sequence [ y ] ) { int diff = sequence [ y + 1 ] - sequence [ y ] ; if ( sequence [ y + 1 ] == sequence [ y ] ) { sequence [ y + 1 ] = sequence [ y + 1 ] + d ; step = step + 1 ; } else { diff = - diff ; store = ( diff / d ) + 1 ; step = step + store ; sequence [ y + 1 ] = sequence [ y + 1 ] + ( d * store ) ; } } } System . out . printf ( " % d " , step ) ; } }
public class GFG { static void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int [ ] factor = new int [ num + 1 ] ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) System . out . print ( " Power - isolated ▁ Integer \n " ) ; else System . out . print ( " Not ▁ a ▁ Power - isolated ▁ Integer \n " ) ; } public static void main ( String [ ] args ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char [ ] s = sc . next ( ) . toCharArray ( ) ; int len = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( len % 2 == 0 && s [ i ] == ' A ' || len % 2 == 1 && s [ i ] == ' Z ' ) { len ++ ; } } len /= 2 ; if ( len == 0 ) { System . out . println ( - 1 ) ; } else { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i ++ ) { sb . append ( " AZ " ) ; } System . out . println ( sb . toString ( ) ) ; } } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . HashMap ; import java . util . Map ; import java . util . StringTokenizer ; public class R765A { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int t = Integer . parseInt ( st . nextToken ( ) ) ; while ( t -- > 0 ) { st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] arr = new int [ n ] ; st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } solve ( arr ) ; } } static class Diff { int prev ; } private static void solve ( int [ ] arr ) { int max = - 1 ; Map < Integer , Diff > map = new HashMap < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { Diff diff = map . get ( arr [ i ] ) ; int prev = diff . prev ; int count = prev + arr . length - i ; if ( count > max ) { max = count ; } diff . prev = i ; } else { Diff diff = new Diff ( ) ; diff . prev = i ; map . put ( arr [ i ] , diff ) ; } } System . out . println ( max ) ; } }
public class GFG { static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; int result [ ] = new int [ len1 + len2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 . charAt ( i ) - '0' ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 . charAt ( j ) - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += ( result [ i -- ] ) ; return s ; } public static void main ( String [ ] args ) { String str1 = "1235421415454545454545454544" ; String str2 = "1714546546546545454544548544544545" ; if ( ( str1 . charAt ( 0 ) == ' - ' || str2 . charAt ( 0 ) == ' - ' ) && ( str1 . charAt ( 0 ) != ' - ' || str2 . charAt ( 0 ) != ' - ' ) ) System . out . print ( " - " ) ; if ( str1 . charAt ( 0 ) == ' - ' && str2 . charAt ( 0 ) != ' - ' ) { str1 = str1 . substring ( 1 ) ; } else if ( str1 . charAt ( 0 ) != ' - ' && str2 . charAt ( 0 ) == ' - ' ) { str2 = str2 . substring ( 1 ) ; } else if ( str1 . charAt ( 0 ) == ' - ' && str2 . charAt ( 0 ) == ' - ' ) { str1 = str1 . substring ( 1 ) ; str2 = str2 . substring ( 1 ) ; } System . out . println ( multiply ( str1 , str2 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int [ ] arr = new int [ n ] ; int sum = 0 ; int sum1 = 0 ; int arr1 [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . nextInt ( ) ; sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { arr1 [ i ] = in . nextInt ( ) ; sum1 += arr1 [ i ] ; } if ( sum >= sum1 ) { System . out . println ( " YES " ) ; } else System . out . println ( " NO " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , k = sc . nextInt ( ) ; String a = sc . next ( ) ; if ( k > n / 2 ) { while ( k < n ) { System . out . println ( " RIGHT " ) ; k ++ ; } } else { while ( k > 1 ) { System . out . println ( " LEFT " ) ; k -- ; } } if ( k == 1 ) { for ( int i = 0 ; i < a . length ( ) ; i ++ ) { System . out . println ( " PRINT ▁ " + a . charAt ( i ) ) ; if ( ( i + 1 ) < a . length ( ) ) { System . out . println ( " RIGHT " ) ; } } } else { for ( int i = a . length ( ) - 1 ; i >= 0 ; i -- ) { System . out . println ( " PRINT ▁ " + a . charAt ( i ) ) ; if ( ( i - 1 ) >= 0 ) { System . out . println ( " LEFT " ) ; } } } } }
import java . io . * ; import java . util . * ; public class GFG { static void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; printDistSum ( arr , n ) ; } }
public class GFG { static int Subtract ( int a , int b ) { int c ; c = a + ( ~ b + 1 ) ; return c ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 ; System . out . println ( Subtract ( a , b ) ) ; a = 9 ; b = 7 ; System . out . println ( Subtract ( a , b ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class InfiniteSequence { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; long n1 = Long . parseLong ( br . readLine ( ) ) ; long n = ( long ) ( ( Math . sqrt ( 1 + ( 8 * n1 ) ) - 1 ) / 2 ) ; long ans = n1 - ( ( ( n + 1 ) * n ) / 2 ) ; System . out . print ( ( ans != 0 ) ? ans : n ) ; } }
import java . util . * ; public class Codeforces { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; arr [ i ] = arr [ i ] - 1 ; } boolean lt = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == arr [ arr [ arr [ i ] ] ] ) { lt = true ; break ; } } if ( lt ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static int nextZero ( int i , int occurrences [ ] ) { while ( i < occurrences . length ) { if ( occurrences [ i ] == 0 ) return i ; i ++ ; } return - 1 ; } static String getModifiedString ( String str ) { int n = str . length ( ) ; if ( n > 26 ) return " - 1" ; char ch [ ] = str . toCharArray ( ) ; int i , occurrences [ ] = new int [ 26 ] ; for ( i = 0 ; i < n ; i ++ ) occurrences [ ch [ i ] - ' a ' ] ++ ; int index = nextZero ( 0 , occurrences ) ; for ( i = 0 ; i < n ; i ++ ) { if ( occurrences [ ch [ i ] - ' a ' ] > 1 ) { occurrences [ ch [ i ] - ' a ' ] -- ; ch [ i ] = ( char ) ( ' a ' + index ) ; occurrences [ index ] = 1 ; index = nextZero ( index + 1 , occurrences ) ; } } return String . valueOf ( ch ) ; } public static void main ( String arr [ ] ) { String str = " geeksforgeeks " ; System . out . println ( getModifiedString ( str ) ) ; } }
import java . util . * ; public class planet { public static int [ ] FLIP = { 0 , 1 , 5 , - 1 , - 1 , 2 , - 1 , - 1 , 8 , - 1 } ; public static void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; int nC = stdin . nextInt ( ) ; for ( int loop = 0 ; loop < nC ; loop ++ ) { int hr = stdin . nextInt ( ) ; int min = stdin . nextInt ( ) ; StringTokenizer tok = new StringTokenizer ( stdin . next ( ) , " : " ) ; int sHr = Integer . parseInt ( tok . nextToken ( ) ) ; int sMin = Integer . parseInt ( tok . nextToken ( ) ) ; int [ ] res = null ; for ( int i = sHr * min + sMin ; i < hr * min ; i ++ ) { res = flip ( i , hr , min ) ; if ( res != null ) break ; } if ( res == null ) res = new int [ ] { 0 , 0 , 0 , 0 } ; System . out . printf ( " % d % d : % d % d \n " , res [ 0 ] , res [ 1 ] , res [ 2 ] , res [ 3 ] ) ; } } public static int [ ] flip ( int val , int hr , int min ) { int thisHr = val / min ; int thisMin = val % min ; int [ ] disp = { thisMin % 10 , thisMin / 10 , thisHr % 10 , thisHr / 10 } ; for ( int i = 0 ; i < disp . length ; i ++ ) { if ( FLIP [ disp [ i ] ] == - 1 ) return null ; disp [ i ] = FLIP [ disp [ i ] ] ; } int newHr = 10 * ( disp [ 0 ] ) + disp [ 1 ] ; int newMin = 10 * ( disp [ 2 ] ) + disp [ 3 ] ; if ( newHr >= hr || newMin >= min ) return null ; return new int [ ] { thisHr / 10 , thisHr % 10 , thisMin / 10 , thisMin % 10 } ; } }
import java . io . * ; import java . util . * ; public class A { static FastReader sc = null ; public static void main ( String [ ] args ) { sc = new FastReader ( ) ; int n = sc . nextInt ( ) , nax = 105 ; int a [ ] = sc . readArray ( n ) ; int cnts [ ] = new int [ nax ] ; for ( int e : a ) cnts [ e + 1 ] ++ ; int ans = 0 ; int pre [ ] = new int [ nax ] ; for ( int i = 1 ; i < nax ; i ++ ) { pre [ i ] = pre [ i - 1 ] + cnts [ i ] ; int val = ( pre [ i ] + i - 1 ) / i ; ans = Math . max ( ans , val ) ; } System . out . println ( ans ) ; } static int [ ] ruffleSort ( int a [ ] ) { ArrayList < Integer > al = new ArrayList < > ( ) ; for ( int i : a ) al . add ( i ) ; Collections . sort ( al ) ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = al . get ( i ) ; return a ; } static void print ( int a [ ] ) { for ( int e : a ) { System . out . print ( e + " ▁ " ) ; } System . out . println ( ) ; } static class FastReader { StringTokenizer st = new StringTokenizer ( " " ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } int [ ] readArray ( int n ) { int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; return a ; } } }
import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int n = sc . nextInt ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( n == 1 ) { System . out . println ( 3 ) ; } else { while ( n > 0 ) { int ans = n & 1 ; n = n >> 1 ; if ( ans == 1 ) { sb . insert ( 0 , 1 ) ; break ; } else { sb . insert ( 0 , 0 ) ; } } if ( n == 0 ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; sb . append ( 1 ) ; } int val = Integer . parseInt ( sb . toString ( ) , 2 ) ; System . out . println ( val ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; boolean [ ] arr = new boolean [ n + 3 ] ; arr [ 0 ] = true ; arr [ 1 ] = true ; int count = 0 ; for ( int i = 2 ; i < arr . length ; i ++ ) { if ( ! arr [ i ] ) { for ( int j = 2 ; j * i < arr . length ; j ++ ) { arr [ i * j ] = true ; } if ( ! arr [ i ] && ! arr [ i - 2 ] ) { count ++ ; } } } System . out . println ( count * 2 ) ; } }
import java . io . * ; import java . util . Scanner ; public class league { void solve ( Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; int num = 0 ; int a [ ] = new int [ 1000001 ] ; int start = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { num += in . nextInt ( ) ; for ( int j = start ; j < num ; j ++ ) { a [ j ] = i ; } start = num ; } int m = in . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) { System . out . print ( a [ in . nextInt ( ) - 1 ] ) ; System . out . println ( ) ; } } void run ( ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ) { solve ( in , out ) ; } } public static void main ( String [ ] args ) { new league ( ) . run ( ) ; } }
import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Ada { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int dp [ ] = new int [ n + 1 ] ; int pre [ ] = new int [ n + 1 ] ; int prevSum = dp [ 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i != 1 ) { pre [ i ] = ( pre [ i - 1 ] + pre [ i ] ) % m ; dp [ i ] = ( prevSum + pre [ i ] ) % m ; prevSum = ( prevSum + dp [ i ] ) % m ; } for ( int p = 2 , j = 2 * i ; j <= n ; p ++ , j = p * i ) { int r = j + p ; pre [ j ] = ( pre [ j ] + dp [ i ] ) % m ; if ( r <= n ) pre [ r ] = ( ( pre [ r ] - dp [ i ] ) % m + m ) % m ; } } System . out . println ( dp [ n ] ) ; } }
import java . util . Deque ; import java . util . LinkedList ; public class SlidingWindow { static void printMax ( int arr [ ] , int n , int k ) { Deque < Integer > Qi = new LinkedList < Integer > ( ) ; int i ; for ( i = 0 ; i < k ; ++ i ) { while ( ! Qi . isEmpty ( ) && arr [ i ] >= arr [ Qi . peekLast ( ) ] ) Qi . removeLast ( ) ; Qi . addLast ( i ) ; } for ( ; i < n ; ++ i ) { System . out . print ( arr [ Qi . peek ( ) ] + " ▁ " ) ; while ( ( ! Qi . isEmpty ( ) ) && Qi . peek ( ) <= i - k ) Qi . removeFirst ( ) ; while ( ( ! Qi . isEmpty ( ) ) && arr [ i ] >= arr [ Qi . peekLast ( ) ] ) Qi . removeLast ( ) ; Qi . addLast ( i ) ; } System . out . println ( arr [ Qi . peek ( ) ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 1 , 78 , 90 , 57 , 89 , 56 } ; int k = 3 ; printMax ( arr , arr . length , k ) ; } }
import java . io . * ; public class GFG { static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( ( b & 1 ) != 0 ) res = res + a ; a = a << 1 ; b = b >> 1 ; } return res ; } public static void main ( String [ ] args ) { System . out . println ( russianPeasant ( 18 , 1 ) ) ; System . out . println ( russianPeasant ( 20 , 12 ) ) ; } }
public class GFG { static boolean isValid ( String str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) return false ; } return true ; } public static void main ( String [ ] args ) { String str = "0110" ; int len = str . length ( ) ; if ( isValid ( str , len ) ) System . out . println ( " Valid " ) ; else System . out . println ( " Invalid " ) ; } }
import java . util . Random ; public class GFG { static int lehmann ( int n , int t ) { Random rand = new Random ( ) ; int a = rand . nextInt ( n - 3 ) + 2 ; float e = ( n - 1 ) / 2 ; while ( t > 0 ) { int result = ( ( int ) ( Math . pow ( a , e ) ) ) % n ; if ( ( result % n ) == 1 || ( result % n ) == ( n - 1 ) ) { a = rand . nextInt ( n - 3 ) + 2 ; t -= 1 ; } else return - 1 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 13 ; int t = 10 ; if ( n == 2 ) System . out . println ( " ▁ 2 ▁ is ▁ Prime . " ) ; if ( n % 2 == 0 ) System . out . println ( n + " ▁ is ▁ Composite " ) ; else { long flag = lehmann ( n , t ) ; if ( flag == 1 ) System . out . println ( n + " ▁ may ▁ be ▁ Prime . " ) ; else System . out . println ( n + " ▁ is ▁ Composite . " ) ; } } }
import java . util . Scanner ; public class sub { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int num = in . nextInt ( ) ; while ( num -- > 0 ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int res = 0 ; while ( a != 0 && b != 0 ) { if ( a >= b ) { res += a / b ; a %= b ; } else { res += b / a ; b %= a ; } } System . out . println ( res ) ; } } }
import java . util . * ; import java . io . * ; public class CP { public static class Scanner { StringTokenizer st ; BufferedReader br ; public Scanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Scanner ( String s ) throws FileNotFoundException { br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( s ) ) ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } } static private long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static private void printArrayList ( ArrayList < Object > al ) { for ( Object i : al ) { System . out . print ( i + " ▁ " ) ; } System . out . println ( ) ; } static private int digitSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; } public static void main ( String [ ] args ) { try { Scanner s = new Scanner ( System . in ) ; StringBuffer sb = new StringBuffer ( ) ; String st = s . next ( ) ; int k = s . nextInt ( ) ; Set < Character > hs = new HashSet < > ( ) ; for ( char x : st . toCharArray ( ) ) { hs . add ( x ) ; } if ( st . length ( ) < k ) { sb . append ( " impossible " ) ; } else { if ( k <= hs . size ( ) ) { sb . append ( "0 \n " ) ; } else sb . append ( k - hs . size ( ) ) ; } System . out . println ( sb ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } }
public class GFG { static int N = 3 ; static int MaxTraceSub ( int mat [ ] [ ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 2 , 5 } , { 6 , 10 , 4 } , { 2 , 7 , - 10 } } ; System . out . println ( MaxTraceSub ( mat ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { double xa1 = sc . nextDouble ( ) , ya1 = sc . nextDouble ( ) , xa2 = sc . nextDouble ( ) , ya2 = sc . nextDouble ( ) , xb1 = sc . nextDouble ( ) , yb1 = sc . nextDouble ( ) , xb2 = sc . nextDouble ( ) , yb2 = sc . nextDouble ( ) ; double xaMin = Math . min ( xa1 , xa2 ) , xaMax = Math . max ( xa1 , xa2 ) , xbMin = Math . min ( xb1 , xb2 ) , xbMax = Math . max ( xb1 , xb2 ) , yaMin = Math . min ( ya1 , ya2 ) , yaMax = Math . max ( ya1 , ya2 ) , ybMin = Math . min ( yb1 , yb2 ) , ybMax = Math . max ( yb1 , yb2 ) ; if ( xaMax < xbMin || xbMax < xaMin || yaMax < ybMin || ybMax < yaMin ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } } }
import java . util . Scanner ; public class ArrayElimination { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t = scan . nextInt ( ) ; for ( int tt = 0 ; tt < t ; tt ++ ) { int n = scan . nextInt ( ) ; int [ ] bit = new int [ 32 ] ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { int temp = ( 1 << ( j - 1 ) ) ; int bitwiseAnd = arr [ i ] & temp ; if ( bitwiseAnd > 0 ) bit [ j ] ++ ; } } for ( int i = 1 ; i <= n ; i ++ ) { boolean possible = true ; for ( int j = 0 ; j < 32 ; j ++ ) { if ( bit [ j ] % i != 0 ) { possible = false ; break ; } } if ( possible ) System . out . print ( i + " ▁ " ) ; } System . out . println ( ) ; } } }
import java . io . * ; public class GFG { static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; } public static void main ( String [ ] args ) { int a = 1 , b = 10 ; System . out . println ( OddDivCount ( a , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; double M = ( double ) ( m ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; int max = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) ( Math . ceil ( arr [ i ] / M ) ) ; if ( x >= max ) { max = x ; ans = i ; } } System . out . print ( ans + 1 ) ; } }
public class GFG { static void printArray ( int N , int arr [ ] ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static void replacedArray ( int N , int arr [ ] ) { int pos_sum , neg_sum , i , j , diff ; pos_sum = 0 ; neg_sum = 0 ; for ( i = N - 1 ; i >= 0 ; i -- ) { diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; else neg_sum += arr [ i ] ; arr [ i ] = Math . abs ( diff ) ; } } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , - 1 , 2 , 3 , - 2 } ; replacedArray ( N , arr ) ; printArray ( N , arr ) ; N = 6 ; int arr1 [ ] = { - 3 , - 4 , - 2 , 5 , 1 , - 2 } ; replacedArray ( N , arr1 ) ; printArray ( N , arr1 ) ; } }
public class GFG { static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static void replacedArray ( int N , int [ ] arr ) { int pos_sum , neg_sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_sum = 0 ; neg_sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; arr [ i ] = Math . abs ( diff ) ; } } public static void main ( String args [ ] ) { int N = 5 ; int [ ] arr = { 1 , - 1 , 2 , 3 , - 2 } ; replacedArray ( N , arr ) ; printArray ( N , arr ) ; N = 6 ; int [ ] arr1 = { - 3 , - 4 , - 2 , 5 , 1 , - 2 } ; replacedArray ( N , arr1 ) ; printArray ( N , arr1 ) ; } }
import java . io . * ; public class GFG { static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++ ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; } public static void main ( String [ ] args ) { String s = "124" ; System . out . println ( countDivisbleby4 ( s ) ) ; } }
import java . util . * ; public class cf1535A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int [ ] a = new int [ 4 ] ; for ( int k = 0 ; k < 4 ; k ++ ) a [ k ] = input . nextInt ( ) ; if ( Math . max ( a [ 0 ] , a [ 1 ] ) > Math . min ( a [ 2 ] , a [ 3 ] ) && Math . max ( a [ 2 ] , a [ 3 ] ) > Math . min ( a [ 0 ] , a [ 1 ] ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . util . Scanner ; public class _96B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long number = in . nextLong ( ) ; long ans = - 1 , value = 0 ; int mask = 2 ; while ( value < number ) { String s = Integer . toBinaryString ( mask ++ ) . substring ( 1 ) ; int zeros = 0 ; for ( char c : s . toCharArray ( ) ) if ( c == '0' ) zeros ++ ; if ( zeros != s . length ( ) - zeros ) continue ; s = s . replace ( '0' , '4' ) ; s = s . replace ( '1' , '7' ) ; value = Long . parseLong ( s ) ; } System . out . println ( value ) ; } }
import java . io . * ; import java . util . * ; public class OracAndMedians_641B { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int cases = Integer . parseInt ( br . readLine ( ) ) ; while ( cases -- > 0 ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int target = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] nums = new int [ n ] ; st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { nums [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } helper ( nums , target ) ; } } private static void helper ( int [ ] nums , int target ) { boolean isTargetFound = false , canPrintYes = false ; int score = 0 , prev = - 1 ; for ( int num : nums ) { if ( num == target ) { isTargetFound = true ; } if ( num < target ) { score -- ; } else { score ++ ; } if ( score > 0 && prev > - 1 ) { canPrintYes = true ; } prev = score ; score = Math . max ( score , 0 ) ; } if ( ( nums . length == 1 || canPrintYes ) && isTargetFound ) { System . out . println ( " yes " ) ; } else { System . out . println ( " no " ) ; } } }
import java . util . * ; public class Smooth { static Scanner sc = new Scanner ( System . in ) ; static int [ ] [ ] memo = new int [ 100 ] [ 257 ] ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { System . out . print ( " Case ▁ # " + i + " : ▁ " ) ; solveCase ( ) ; } } static final int SPC = 256 ; static void solveCase ( ) { del = sc . nextInt ( ) ; ins = sc . nextInt ( ) ; maxDist = sc . nextInt ( ) ; n = sc . nextInt ( ) ; arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; for ( int [ ] arr : memo ) Arrays . fill ( arr , - 1 ) ; System . out . println ( solve ( 0 , SPC ) ) ; } static int del , ins , maxDist , n ; static int [ ] arr ; static int solve ( int index , int prev ) { if ( index >= n ) return 0 ; if ( memo [ index ] [ prev ] == - 1 ) { int res = del + solve ( index + 1 , prev ) ; for ( int val = 0 ; val < SPC ; val ++ ) { res = Math . min ( res , Math . abs ( arr [ index ] - val ) + insCost ( val , prev ) + solve ( index + 1 , val ) ) ; } memo [ index ] [ prev ] = res ; } return memo [ index ] [ prev ] ; } static int insCost ( int cur , int prev ) { if ( prev == SPC || cur == prev ) return 0 ; if ( maxDist == 0 ) return 100000000 ; return ins * ( ( Math . abs ( cur - prev ) + maxDist - 1 ) / maxDist - 1 ) ; } }
import java . util . Scanner ; public class Main { final int N = 12 ; final int [ ] [ ] ofs = { { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } , { 0 , 1 } } ; void del ( boolean [ ] [ ] map , int y , int x ) { map [ y ] [ x ] = false ; for ( int i = 0 ; i < 4 ; ++ i ) { int nx = x + ofs [ i ] [ 0 ] ; int ny = y + ofs [ i ] [ 1 ] ; if ( 0 <= ny && ny < N && 0 <= nx && nx < N ) { if ( map [ ny ] [ nx ] ) { del ( map , ny , nx ) ; } } } } int solve ( boolean map [ ] [ ] ) { int c = 0 ; for ( int y = 0 ; y < N ; ++ y ) { for ( int x = 0 ; x < N ; ++ x ) { if ( map [ y ] [ x ] ) { c ++ ; del ( map , y , x ) ; } } } return c ; } void io ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { char [ ] [ ] str = new char [ N ] [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { str [ i ] = sc . nextLine ( ) . toCharArray ( ) ; } boolean [ ] [ ] map = new boolean [ N ] [ N ] ; for ( int y = 0 ; y < N ; ++ y ) { for ( int x = 0 ; x < N ; ++ x ) { map [ y ] [ x ] = str [ y ] [ x ] == '1' ; } } System . out . println ( solve ( map ) ) ; if ( sc . hasNext ( ) ) { sc . nextLine ( ) ; } } } public static void main ( String [ ] args ) { new Main ( ) . io ( ) ; } }
public class GFG { static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . length ; if ( arraySortedOrNot ( arr , n ) ) System . out . print ( " Yes \n " ) ; else System . out . print ( " No \n " ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class candies { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int a = in . nextInt ( ) ; int x [ ] = new int [ a ] ; for ( int i = 0 ; i < a ; i ++ ) { x [ i ] = in . nextInt ( ) ; } Arrays . sort ( x ) ; int s = 0 ; for ( int i = 0 ; i < a ; i ++ ) { s += Math . abs ( x [ i ] - x [ 0 ] ) ; } System . out . println ( s ) ; } } }
import java . util . * ; public class GFG { static int printKDistinct ( int arr [ ] , int n , int k ) { Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ; else h . put ( arr [ i ] , 1 ) ; } if ( h . size ( ) < k ) return - 1 ; int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . get ( arr [ i ] ) == 1 ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = ar . length ; System . out . println ( printKDistinct ( ar , n , 2 ) ) ; } }
public class GFG { void fib ( int f [ ] ) { f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i <= 59 ; i ++ ) f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; } int findLastDigit ( long n ) { int f [ ] = new int [ 60 ] ; fib ( f ) ; int index = ( int ) ( n % 60L ) ; return f [ index ] ; } public static void main ( String [ ] args ) { long n ; GFG ob = new GFG ( ) ; n = 1 ; System . out . println ( ob . findLastDigit ( n ) ) ; n = 61 ; System . out . println ( ob . findLastDigit ( n ) ) ; n = 7 ; System . out . println ( ob . findLastDigit ( n ) ) ; n = 67 ; System . out . println ( ob . findLastDigit ( n ) ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String str = scan . next ( ) ; int num_1 = Integer . parseInt ( str ) ; str = scan . next ( ) ; int num_2 = Integer . parseInt ( str ) ; str = scan . next ( ) ; int num_3 = Integer . parseInt ( str ) ; if ( num_1 == 7 ) { if ( num_2 == 5 && num_3 == 5 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else if ( num_2 == 7 ) { if ( num_1 == 5 && num_3 == 5 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else if ( num_3 == 7 ) { if ( num_2 == 5 && num_1 == 5 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int z = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; List < Integer > a = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( sc . nextInt ( ) ) ; } if ( n == 1 ) { System . out . println ( Math . abs ( w - a . get ( 0 ) ) ) ; return ; } int ans1 = Math . abs ( a . get ( n - 2 ) - a . get ( n - 1 ) ) ; int ans2 = Math . abs ( w - a . get ( n - 1 ) ) ; System . out . println ( Math . max ( ans1 , ans2 ) ) ; } }
import java . util . Arrays ; public class GFG { static int countEleLessThanOrEqual ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr2 [ j ] <= arr1 [ i ] ) count ++ ; System . out . print ( count + " ▁ " ) ; } return m ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 2 , 3 , 4 , 7 , 9 } ; int arr2 [ ] = { 0 , 1 , 2 , 1 , 1 , 4 } ; countEleLessThanOrEqual ( arr1 , arr2 , arr1 . length , arr2 . length ) ; } }
import java . io . * ; import java . util . * ; public class MaximumOfMaximumsOfMinimums { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) , k = in . nextInt ( ) ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = in . nextLong ( ) ; pw . println ( solve ( n , a , k ) ) ; pw . close ( ) ; } static long solve ( int n , long [ ] a , int k ) { if ( k == 1 ) { long res = Long . MAX_VALUE ; for ( long x : a ) res = Math . min ( x , res ) ; return res ; } if ( k == 2 ) { if ( n == 1 ) return a [ 0 ] ; ArrayDeque < Long > dq = new ArrayDeque < > ( ) ; for ( long x : a ) dq . add ( x ) ; long lMin = Long . MAX_VALUE , rMin = Long . MAX_VALUE ; long ans = a [ 0 ] ; while ( ! dq . isEmpty ( ) ) { lMin = Math . min ( dq . pollFirst ( ) , lMin ) ; if ( rMin == Long . MAX_VALUE && dq . isEmpty ( ) ) { rMin = Long . MIN_VALUE ; break ; } if ( dq . isEmpty ( ) ) break ; rMin = Long . min ( dq . getLast ( ) , rMin ) ; ans = Math . max ( ans , Math . max ( rMin , lMin ) ) ; } ans = Math . max ( ans , Math . max ( rMin , lMin ) ) ; return ans ; } long ans = Long . MIN_VALUE ; for ( long x : a ) ans = Math . max ( ans , x ) ; return ans ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . util . Scanner ; public class NewClass { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; String name1 = in . next ( ) , name2 = in . next ( ) ; System . out . println ( name1 + " ▁ " + name2 ) ; int n = in . nextInt ( ) ; while ( true ) { String s1 = in . next ( ) , s2 = in . next ( ) ; if ( s1 . equals ( name1 ) ) { name1 = s2 ; } if ( s1 . equals ( name2 ) ) { name2 = s2 ; } System . out . println ( name1 + " ▁ " + name2 ) ; n -- ; if ( n == 0 ) break ; } } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . * ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; import java . util . jar . Attributes ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; Integer [ ] s = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = in . nextInt ( ) ; } Arrays . sort ( s ) ; if ( n % 2 == 0 ) out . println ( s [ n / 2 - 1 ] ) ; else out . println ( s [ ( n + 1 ) / 2 - 1 ] ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . * ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int k = in . nextInt ( ) ; int p = in . nextInt ( ) ; double sum = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int a = i ; double b = i ; while ( a != 0 ) { b = b * 10 + a % 10 ; a /= 10 ; } b = b % p ; sum = ( sum + b ) % p ; } out . printf ( " % .0f " , sum ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
import java . util . Scanner ; import java . util . TreeSet ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; int p [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) - 1 ; p [ a [ i ] ] = i ; } TreeSet < Integer > x = new TreeSet < Integer > ( ) ; int l [ ] = new int [ n ] ; int r [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x . add ( p [ i ] ) ; if ( x . first ( ) == p [ i ] ) { l [ i ] = p [ i ] + 1 ; } else { int lower = x . lower ( p [ i ] ) ; l [ i ] = p [ i ] - lower ; } if ( x . last ( ) == p [ i ] ) { r [ i ] = n - p [ i ] ; } else { int high = x . higher ( p [ i ] ) ; r [ i ] = high - p [ i ] ; } } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( long ) l [ i ] * r [ i ] * ( i + 1 ) ; } System . out . println ( ans ) ; } }
class LPS { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( String seq ) { int n = seq . length ( ) ; int i , j , cl ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + lps ( seq ) ) ; } }
public class GFG { static void printConsecutive ( int last , int first ) { System . out . print ( first ++ ) ; for ( int x = first ; x <= last ; x ++ ) System . out . print ( " ▁ + ▁ " + x ) ; } static void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { System . out . printf ( N + " ▁ = ▁ " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 12 ; findConsecutive ( n ) ; } }
import java . io . * ; import java . util . * ; public class CF { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int even = in . nextInt ( ) , odd = in . nextInt ( ) ; if ( even == 0 && odd == 0 ) { pw . println ( " NO " ) ; } else { int sub = Math . abs ( even - odd ) ; if ( sub <= 1 ) { pw . println ( " YES " ) ; } else { pw . println ( " NO " ) ; } } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int NumberOfSquares ( int x , int y ) { int s = __gcd ( x , y ) ; int ans = ( x * y ) / ( s * s ) ; return ans ; } public static void main ( String [ ] args ) { int m = 385 , n = 60 ; System . out . println ( NumberOfSquares ( m , n ) ) ; } }
import java . util . Arrays ; public class GFG { static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char c [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s . charAt ( i ) ) return false ; return true ; } public static void main ( String args [ ] ) { String s = " aabbbcc " ; if ( isAlphabaticOrder ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static void printKMax ( int arr [ ] , int n , int k ) { int j , max ; for ( int i = 0 ; i <= n - k ; i ++ ) { max = arr [ i ] ; for ( j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] > max ) max = arr [ i + j ] ; } System . out . print ( max + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int k = 3 ; printKMax ( arr , arr . length , k ) ; } }
import java . util . * ; class Main implements Runnable { ArrayList < Integer > [ ] graph ; boolean [ ] visited ; int [ ] color ; long one ; long bipartite ; long count ; boolean mujun ; int dfs ( int a , int c ) { if ( visited [ a ] ) { if ( color [ a ] >= 0 && color [ a ] != c ) mujun = true ; return 0 ; } visited [ a ] = true ; color [ a ] = c ; int total = 1 ; for ( int b : graph [ a ] ) { total += dfs ( b , 1 - c ) ; } return total ; } public void run ( ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; this . graph = new ArrayList [ n ] ; for ( int i = 0 ; i < n ; ++ i ) this . graph [ i ] = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { int u = scan . nextInt ( ) - 1 ; int v = scan . nextInt ( ) - 1 ; this . graph [ u ] . add ( v ) ; this . graph [ v ] . add ( u ) ; } visited = new boolean [ n ] ; color = new int [ n ] ; Arrays . fill ( color , - 1 ) ; one = 0 ; bipartite = 0 ; count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( visited [ i ] ) continue ; count ++ ; mujun = false ; int kind = dfs ( i , 0 ) ; if ( kind == 1 ) one ++ ; else if ( ! mujun ) bipartite ++ ; } long total = one * ( 2 * n - one ) ; total += ( count - one ) * ( count - one ) ; total += bipartite * bipartite ; System . out . println ( total ) ; } public static void main ( String [ ] args ) { new Thread ( null , new Main ( ) , " " , 128 * 1024 * 1024 ) . start ( ) ; } }
import org . w3c . dom . ls . LSInput ; import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . * ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; import java . util . jar . Attributes ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int k = in . nextInt ( ) ; int c = 1 ; int s = m - n ; int l = k ; int r = k ; while ( s >= r - l + 1 ) { s -= r - l + 1 ; c ++ ; if ( l > 1 ) { l -- ; } if ( r < n ) { r ++ ; } } System . out . println ( c ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . run ( ) ; } class P implements Comparable < P > { long x ; long y ; P ( long x , long y ) { this . x = x ; this . y = y ; } @ Override public int compareTo ( P arg0 ) { return Long . compare ( this . x , arg0 . x ) ; } } public void run ( ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; long x [ ] = new long [ N ] ; long y [ ] = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { x [ i ] = sc . nextLong ( ) ; y [ i ] = sc . nextLong ( ) ; } long ans = Long . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { long x1 = x [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { long x2 = x [ j ] ; if ( x1 >= x2 ) continue ; for ( int k = 0 ; k < N ; k ++ ) { long y1 = y [ k ] ; for ( int l = 0 ; l < N ; l ++ ) { long y2 = y [ l ] ; if ( y1 >= y2 ) continue ; int cnt = 0 ; for ( int m = 0 ; m < N ; m ++ ) { if ( x1 <= x [ m ] && x [ m ] <= x2 && y1 <= y [ m ] && y [ m ] <= y2 ) { cnt ++ ; } } if ( cnt == K ) { ans = Math . min ( ans , ( x2 - x1 ) * ( y2 - y1 ) ) ; } } } } } System . out . println ( ans ) ; sc . close ( ) ; } }
import java . util . * ; public class Main { static Comparator < String > comp = new Comparator < String > ( ) { public int compare ( String a , String b ) { for ( int i = 0 ; i < a . length ( ) ; i ++ ) { if ( a . charAt ( i ) < b . charAt ( i ) ) return - 1 + ( i % 2 ) * 2 ; else if ( a . charAt ( i ) > b . charAt ( i ) ) return 1 - ( i % 2 ) * 2 ; } return 0 ; } } ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; String [ ] a = new String [ n ] ; HashMap < String , Integer > ids = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . next ( ) ; ids . put ( a [ i ] , i + 1 ) ; } Arrays . sort ( a , comp ) ; for ( String x : a ) { System . out . print ( ids . get ( x ) + " ▁ " ) ; } System . out . println ( ) ; } }
import java . util . * ; public class GFG { static void pre_process ( String substrings [ ] , String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String dup = " " ; for ( int j = i ; j < n ; j ++ ) { dup += s . charAt ( j ) ; substrings [ count ++ ] = dup ; } } int size = substrings . length ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < substrings . length ; j ++ ) { if ( substrings [ i ] . compareTo ( substrings [ j ] ) > 0 ) { String temp = substrings [ i ] ; substrings [ i ] = substrings [ j ] ; substrings [ j ] = temp ; } } } } public static void main ( String args [ ] ) { String s = " geek " ; String substrings [ ] = new String [ 10 ] ; pre_process ( substrings , s ) ; int queries [ ] = { 1 , 5 , 10 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( substrings [ queries [ i ] - 1 ] ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int w = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; if ( w == 0 && h == 0 ) break ; String s ; int t ; int d = 0 ; int x = 0 ; int y = 0 ; char c ; while ( true ) { s = sc . next ( ) ; c = s . charAt ( 0 ) ; if ( c == ' S ' ) { System . out . println ( ( x + 1 ) + " ▁ " + ( y + 1 ) ) ; break ; } else if ( c == ' R ' ) { d ++ ; if ( d == 4 ) d = 0 ; } else if ( c == ' L ' ) { d -- ; if ( d == - 1 ) d = 3 ; } else if ( ( c == ' F ' && d == 0 ) || ( c == ' B ' && d == 2 ) ) { t = sc . nextInt ( ) ; y += t ; if ( y > h - 1 ) y = h - 1 ; } else if ( ( c == ' F ' && d == 1 ) || ( c == ' B ' && d == 3 ) ) { t = sc . nextInt ( ) ; x += t ; if ( x > w - 1 ) x = w - 1 ; } else if ( ( c == ' F ' && d == 2 ) || ( c == ' B ' && d == 0 ) ) { t = sc . nextInt ( ) ; y -= t ; if ( y < 0 ) y = 0 ; } else if ( ( c == ' F ' && d == 3 ) || ( c == ' B ' && d == 1 ) ) { t = sc . nextInt ( ) ; x -= t ; if ( x < 0 ) x = 0 ; } } } } }
import java . util . Scanner ; public class FileName { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String str = sc . next ( ) ; int count = 0 ; int total = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' x ' ) { count ++ ; continue ; } else { if ( count >= 3 ) { total += count - 2 ; count = 0 ; } count = 0 ; } } if ( count >= 3 ) { total += count - 2 ; count = 0 ; } System . out . println ( total ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; while ( true ) { String a = in . next ( ) ; char [ ] num = a . toCharArray ( ) ; if ( num [ 0 ] == '0' ) break ; int A = 0 , B = 0 ; for ( int i = 1 ; i < num . length ; i ++ ) { if ( num [ i ] == ' A ' ) { A ++ ; } else { B ++ ; } } if ( A > B ) A ++ ; else B ++ ; System . out . println ( A + " ▁ " + B ) ; } } }
import java . io . * ; public class GFG { public static int fact ( int N ) { int i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; } public static int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
public class GFG { static int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 0 , 1 , 2 , 0 } ; int n = arr . length ; System . out . println ( longestSubArray ( arr , n ) ) ; } }
import java . util . * ; public class AA { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { long k = sc . nextLong ( ) ; int x = sc . nextInt ( ) ; long f = k * 9 ; for ( int y = x ; y < 9 ; y ++ ) { f -- ; } System . out . println ( f ) ; } } }
import java . util . * ; public class GFG { static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . println ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; } public static void main ( String [ ] args ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( L , B , X , Y ) ; } }
public class GFG { final static int NO_OF_CHARS = 256 ; static int max_distinct_char ( String str , int n ) { int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } static int smallesteSubstr_maxDistictChar ( String str ) { int n = str . length ( ) ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = null ; if ( i < j ) subs = str . substring ( i , j ) ; else subs = str . substring ( j , i ) ; int subs_lenght = subs . length ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; } static public void main ( String [ ] args ) { String str = " AABBBCBB " ; int len = smallesteSubstr_maxDistictChar ( str ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : ▁ " + len ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static double aver ( int [ ] arr ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum = sum + arr [ i ] ; } return sum / arr . length ; } public static int fac ( int x ) { int sum = 1 ; while ( x > 0 ) { sum = sum * x ; x = x - 1 ; } return sum ; } public static int comb ( int x , int y ) { int sum = 0 ; sum = fac ( x ) ; int temp = ( fac ( y ) * fac ( x - y ) ) ; return sum / temp ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n > 0 ) { sc . nextInt ( ) ; sc . nextLine ( ) ; String [ ] f = sc . nextLine ( ) . split ( " " ) ; String [ ] s = sc . nextLine ( ) . split ( " " ) ; boolean flag = true ; for ( int i = 0 ; i < f . length ; i ++ ) { if ( f [ i ] . equals ( " R " ) ) { if ( s [ i ] . equals ( " B " ) || s [ i ] . equals ( " G " ) ) flag = false ; } if ( s [ i ] . equals ( " R " ) ) { if ( f [ i ] . equals ( " B " ) || f [ i ] . equals ( " G " ) ) flag = false ; } } if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = n - 1 ; } } }
public class GFG { static int findNumberOfEvenCells ( int n , int q [ ] [ ] , int size ) { int row [ ] = new int [ n ] ; int col [ ] = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; } public static void main ( String [ ] args ) { int n = 2 ; int q [ ] [ ] = { { 1 , 1 } , { 1 , 2 } , { 2 , 1 } } ; int size = q . length ; System . out . println ( findNumberOfEvenCells ( n , q , size ) ) ; } }
import java . math . * ; public class GFG { public static void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( " Increasing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Decreasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; else System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 } ; int n = arr . length ; checkType ( arr , n ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class BinaryStr { public static void main ( String [ ] args ) throws IOException { BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . valueOf ( bf . readLine ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . valueOf ( bf . readLine ( ) ) ; char [ ] arr = bf . readLine ( ) . toCharArray ( ) ; char [ ] arr2 = new char [ n ] ; for ( int j = 0 ; j <= n - 1 ; j ++ ) { arr2 [ j ] = arr [ j ] ; } for ( int j = 0 ; j <= n - 1 ; j ++ ) { if ( j % 2 == 0 ) { arr2 [ j ] = '0' ; } else { arr2 [ j ] = '1' ; } } int cur = 0 ; int k ; for ( int j = 0 ; j <= n - 1 ; j ++ ) { if ( arr [ j ] == arr2 [ j ] ) continue ; for ( k = j ; k <= n - 1 ; k ++ ) { if ( arr [ k ] == arr2 [ k ] ) break ; } cur ++ ; j = k - 1 ; } int ans = Integer . MAX_VALUE ; ans = Math . min ( ans , cur ) ; for ( int j = 0 ; j <= n - 1 ; j ++ ) { if ( j % 2 == 1 ) { arr2 [ j ] = '0' ; } else { arr2 [ j ] = '1' ; } } cur = 0 ; for ( int j = 0 ; j <= n - 1 ; j ++ ) { if ( arr [ j ] == arr2 [ j ] ) continue ; for ( k = j ; k <= n - 1 ; k ++ ) { if ( arr [ k ] == arr2 [ k ] ) break ; } cur ++ ; j = k - 1 ; } ans = Math . min ( ans , cur ) ; System . out . println ( ans ) ; } } }
import java . util . * ; import java . io . * ; public class CodeForces { public static void main ( String [ ] args ) throws FileNotFoundException { FastScanner fs = new FastScanner ( ) ; int a = fs . nextInt ( ) , b = fs . nextInt ( ) , c = fs . nextInt ( ) , d = fs . nextInt ( ) ; int p , q ; if ( a * d >= b * c ) { p = a * d - b * c ; q = a * d ; } else { p = b * c - a * d ; q = b * c ; } int k = gcd ( p , q ) ; p /= k ; q /= k ; System . out . println ( p + " / " + q ) ; } static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static void sort ( int [ ] a ) { ArrayList < Integer > l = new ArrayList < > ( ) ; for ( int i : a ) l . add ( i ) ; Collections . sort ( l ) ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = l . get ( i ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }
import java . io . * ; public class GFG { static int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
import java . util . * ; import java . io . * ; public class GFG { static void rearrange ( int arr [ ] , int n ) { int j = 0 , temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } } } public static void main ( String args [ ] ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 } ; int n = arr . length ; rearrange ( arr , n ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
import java . io . * ; public class GFG { static int centered_square_num ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( n + " th ▁ Centered " + " ▁ square ▁ number : ▁ " + centered_square_num ( n ) ) ; } }
import java . io . IOException ; import java . io . PrintWriter ; import java . util . * ; public class teest extends PrintWriter { teest ( ) { super ( System . out ) ; } public static void main ( String [ ] $ ) throws IOException { teest o = new teest ( ) ; o . main ( ) ; o . flush ( ) ; } void main ( ) throws IOException { Scanner a = new Scanner ( System . in ) ; int t = a . nextInt ( ) ; while ( t > 0 ) { int n = a . nextInt ( ) , k = a . nextInt ( ) ; if ( n % 2 != k % 2 || n / k < k ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; t -- ; } } }
import java . util . Arrays ; import java . util . Scanner ; public class GrowTheTree { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] nums = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { nums [ i ] = sc . nextInt ( ) ; } Arrays . sort ( nums ) ; long firstHalf = 0 ; long secondHalf = 0 ; int length = n / 2 ; for ( int i = 0 ; i < length ; i ++ ) { firstHalf += nums [ i ] ; } for ( int i = length ; i < n ; i ++ ) { secondHalf += nums [ i ] ; } long result = ( firstHalf * firstHalf ) + ( secondHalf * secondHalf ) ; System . out . println ( result ) ; } }
import java . util . * ; public class GFG { static int maxSubArraySum ( int arr [ ] , int size ) { int max_so_far = arr [ 0 ] ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( arr [ i ] , curr_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } static int lenOfLongSubarrWithGivenSum ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == k ) maxLen = i + 1 ; if ( um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - k ) ) { if ( maxLen < ( i - um . get ( sum - k ) ) ) maxLen = i - um . get ( sum - k ) ; } } return maxLen ; } static int lenLongSubarrWithMaxSum ( int arr [ ] , int n ) { int maxSum = maxSubArraySum ( arr , n ) ; return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , - 2 , - 1 , 3 , - 4 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ longest ▁ subarray ▁ " + " having ▁ maximum ▁ sum ▁ = ▁ " + lenLongSubarrWithMaxSum ( arr , n ) ) ; } }
import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static void solve ( ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { String s = String . valueOf ( a [ i ] * a [ j ] ) ; boolean f = true ; for ( int k = 0 ; k < s . length ( ) - 1 ; k ++ ) { if ( s . charAt ( k ) + 1 != s . charAt ( k + 1 ) ) f = false ; } if ( f ) { ans = Math . max ( ans , a [ i ] * a [ j ] ) ; } } } out . println ( ans ) ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; solve ( ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + " ▁ ms " ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }
public class GFG { static int [ ] find ( int dividend , int divisor , int start , int end ) { if ( start > end ) return new int [ ] { 0 , dividend } ; int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( n > divisor ) start = mid + 1 ; else if ( n < 0 ) end = mid - 1 ; else { if ( n == divisor ) { ++ mid ; n = 0 ; } return new int [ ] { mid , n } ; } return find ( dividend , divisor , start , end ) ; } static int [ ] divide ( int dividend , int divisor ) { return find ( dividend , divisor , 1 , dividend ) ; } public static void main ( String [ ] args ) { int dividend = 10 , divisor = 3 ; int [ ] ans = divide ( dividend , divisor ) ; System . out . print ( ans [ 0 ] + " , ▁ " ) ; System . out . print ( ans [ 1 ] + " \n " ) ; } }
import java . util . * ; import java . util . function . IntPredicate ; import static java . lang . Math . abs ; import java . math . BigInteger ; public class omar { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int size = input . nextInt ( ) ; int min = 0 , max = 0 ; int [ ] arr = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = input . nextInt ( ) ; } for ( int i = 0 ; i < size ; i ++ ) { if ( i == 0 ) { min = abs ( arr [ i ] - arr [ i + 1 ] ) ; max = abs ( arr [ i ] - arr [ size - 1 ] ) ; } else if ( i == size - 1 ) { min = abs ( arr [ i ] - arr [ i - 1 ] ) ; max = abs ( arr [ i ] - arr [ 0 ] ) ; } else if ( i != 0 && i != size - 1 ) { min = Math . min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; max = Math . max ( abs ( arr [ i ] - arr [ size - 1 ] ) , abs ( arr [ i ] - arr [ 0 ] ) ) ; } System . out . println ( min + " ▁ " + max ) ; } } }
import java . util . Arrays ; import java . util . Scanner ; public class MP3 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int diskSize = in . nextInt ( ) * 8 ; Integer [ ] sounds = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { sounds [ i ] = in . nextInt ( ) ; } Arrays . sort ( sounds ) ; int [ ] distinctVals = new int [ n ] ; int [ ] distinctAmt = new int [ n ] ; int k = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 || sounds [ i ] > sounds [ i - 1 ] ) { distinctVals [ ++ k ] = sounds [ i ] ; distinctAmt [ k ] = 1 ; } else { distinctAmt [ k ] ++ ; } } k ++ ; int answer = n ; int currAmt = distinctAmt [ 0 ] ; for ( int i = 0 , j = 0 ; i < k ; currAmt -= distinctAmt [ i ] , i ++ ) { while ( j < i || ( j < k - 1 && n * lg ( j + 1 - i + 1 ) <= diskSize ) ) { j ++ ; currAmt += distinctAmt [ j ] ; } answer = Math . min ( answer , n - currAmt ) ; } System . out . println ( answer ) ; } static int lg ( int n ) { int res = 0 ; while ( n > ( 1 << res ) ) { res ++ ; } return res ; } }
public class GFG { static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod1 , char aux_rod2 ) { if ( n == 0 ) return ; if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + aux_rod2 ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + aux_rod2 + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; towerOfHanoi ( n , ' A ' , ' D ' , ' B ' , ' C ' ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import static java . lang . Integer . parseInt ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String n = r . readLine ( ) ; String res = " " ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) { case ' > ' : res += "1000" ; break ; case ' < ' : res += "1001" ; break ; case ' + ' : res += "1010" ; break ; case ' - ' : res += "1011" ; break ; case ' . ' : res += "1100" ; break ; case ' , ' : res += "1101" ; break ; case ' [ ' : res += "1110" ; break ; case ' ] ' : res += "1111" ; break ; } } int k = 0 ; long m = 0 ; for ( int i = res . length ( ) - 1 ; i >= 0 ; i -- ) { int y = parseInt ( res . charAt ( i ) + " " ) ; m += ( long ) ( ( Math . pow ( 2 , k ) % 1000003 ) * y ) % 1000003 ; k ++ ; } System . out . println ( m % 1000003 ) ; } }
import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; Map < String , Integer > dic = new HashMap < > ( ) ; int count = stdIn . nextInt ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int command = stdIn . nextInt ( ) ; switch ( command ) { case 0 : dic . put ( stdIn . next ( ) , stdIn . nextInt ( ) ) ; break ; case 1 : String key = stdIn . next ( ) ; if ( dic . get ( key ) != null ) { System . out . println ( dic . get ( key ) ) ; } else { System . out . println ( 0 ) ; } break ; case 2 : dic . remove ( stdIn . next ( ) ) ; break ; } } stdIn . close ( ) ; } }
import java . io . * ; public class GFG { static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( minSum ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; } public static void main ( String [ ] args ) { int k = 7 ; int res = findN ( k ) ; if ( res == - 1 ) System . out . println ( " Not ▁ possible " ) ; else System . out . println ( res ) ; } }
import java . util . * ; public class GFG { static int subsetXOR ( int arr [ ] , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 ) ) - 1 ; int [ ] [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i ] [ j ] [ k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int k = 1 ; int n = arr . length ; System . out . println ( subsetXOR ( arr , n , k ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int D = sc . nextInt ( ) ; int G = sc . nextInt ( ) ; int [ ] p = new int [ D ] ; int [ ] c = new int [ D ] ; for ( int i = 0 ; i < D ; i ++ ) { p [ i ] = sc . nextInt ( ) ; c [ i ] = sc . nextInt ( ) ; } int min = 1001 ; int count = 0 ; int ans = 0 ; int a = 4 ; for ( int i = 0 ; i < Math . pow ( 2 , D ) ; i ++ ) { String bit = String . format ( " % " + D + " s " , Integer . toBinaryString ( i ) ) . replace ( ' ▁ ' , '0' ) ; int N = bit . length ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( bit . charAt ( j ) == '1' ) { count += p [ j ] * ( j + 1 ) * 100 + c [ j ] ; ans += p [ j ] ; } } if ( count < G ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( bit . charAt ( j ) == '0' ) { int l = p [ j ] ; while ( count < G && l > 0 ) { count += ( j + 1 ) * 100 ; ans ++ ; l -- ; } } } } if ( count >= G ) { min = Math . min ( ans , min ) ; } count = 0 ; ans = 0 ; } System . out . println ( min ) ; } }
import java . util . Scanner ; public class Application { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = 0 ; int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; for ( int j = 0 ; j < a ; j ++ ) { k += scan . nextInt ( ) ; } if ( b == k ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . util . * ; import java . util . function . IntPredicate ; import static java . lang . Math . abs ; import java . math . BigInteger ; public class omar { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int size = input . nextInt ( ) ; int count = 0 ; int [ ] arr = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = input . nextInt ( ) ; } Arrays . sort ( arr ) ; for ( int i = 1 ; i < size - 1 ; i ++ ) { if ( arr [ i ] > arr [ 0 ] && arr [ i ] < arr [ size - 1 ] ) { count ++ ; } } System . out . println ( count ) ; } }
import java . util . * ; public class GFG { static int minAbsDiff ( int n ) { int left = ( int ) Math . pow ( 2 , ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( minAbsDiff ( n ) ) ; } }
import java . io . * ; public class GFG { static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = arr1 . length ; int m = arr2 . length ; System . out . println ( " Length ▁ of ▁ LCIS ▁ is ▁ " + LCIS ( arr1 , n , arr2 , m ) ) ; } }
public class GFG { static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; } static int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " ) ; System . out . println ( countSetBits ( n ) ) ; } }
import java . io . * ; public class GFG { static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 , j = high + 1 ; while ( true ) { do { i ++ ; } while ( arr [ i ] < pivot ) ; do { j -- ; } while ( arr [ j ] > pivot ) ; if ( i >= j ) return j ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } static void quickSort ( int [ ] arr , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi ) ; quickSort ( arr , pi + 1 , high ) ; } } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 7 , 8 , 9 , 1 , 5 } ; int n = arr . length ; quickSort ( arr , 0 , n - 1 ) ; System . out . println ( " Sorted ▁ array : " ) ; printArray ( arr , n ) ; } }
import java . io . * ; public class GFG { static void Swap ( int [ ] array , int position1 , int position2 ) { int temp = array [ position1 ] ; array [ position1 ] = array [ position2 ] ; array [ position2 ] = temp ; } static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; Swap ( arr , i , j ) ; } } Swap ( arr , i + 1 , high ) ; return ( i + 1 ) ; } static void quickSort ( int [ ] arr , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } } static void printArray ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 7 , 8 , 9 , 1 , 5 } ; int n = arr . length ; quickSort ( arr , 0 , n - 1 ) ; System . out . println ( " Sorted ▁ array : " ) ; printArray ( arr , n ) ; } }
public class GFG { static double maxSubArraySum ( double a [ ] , int size ) { double max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static void minPossibleSum ( double a [ ] , int n , double x ) { double mxSum = maxSubArraySum ( a , n ) ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } sum = sum - mxSum + mxSum / x ; System . out . print ( sum + " \n " ) ; } public static void main ( String [ ] args ) { int N = 3 ; double X = 2 ; double A [ ] = { 1 , - 2 , 3 } ; minPossibleSum ( A , N , X ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { FastScanner sc = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int t ; t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n ; n = sc . nextInt ( ) ; int [ ] arr = new int [ n + 1 ] ; int [ ] indexOf = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; indexOf [ arr [ i ] ] = i ; } int least = n + 1 ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; for ( int e = n ; e >= 1 ; e -- ) { int ind = indexOf [ e ] ; if ( ind >= least ) continue ; for ( int j = ind ; j < least ; j ++ ) ans . add ( arr [ j ] ) ; least = ind ; } for ( int e : ans ) out . print ( e + " ▁ " ) ; out . println ( ) ; } out . close ( ) ; } static class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . io . * ; public class GFG { static void printArray ( int N , int SUM , int K ) { int minSum = ( N * ( N + 1 ) ) / 2 ; int maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 ; if ( minSum > SUM || maxSum < SUM ) { System . out . println ( " Not ▁ Possible " ) ; return ; } int arr [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i ] = i ; int sum = minSum ; for ( int i = N ; i >= 1 ; i -- ) { int x = sum + ( K - i ) ; if ( x < SUM ) { sum = sum + ( K - i ) ; arr [ i ] = K ; K -- ; } else { arr [ i ] += ( SUM - sum ) ; sum = SUM ; break ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 3 , SUM = 15 , K = 8 ; printArray ( N , SUM , K ) ; } }
import java . io . * ; public class GFG { static int COST = 3 ; static int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; } public static void main ( String [ ] args ) { int x = 4 , y = 5 , z = 6 ; System . out . println ( maxItems ( x , y , z ) ) ; } }
import java . util . * ; public class GFG { static int run_tasks ( Queue < Integer > A , Queue < Integer > B ) { int total_time = 0 ; while ( ! A . isEmpty ( ) ) { int x = A . peek ( ) ; int y = B . peek ( ) ; if ( x == y ) { A . remove ( ) ; B . remove ( ) ; total_time ++ ; } else { A . remove ( ) ; A . add ( x ) ; total_time += 2 ; } } return total_time ; } public static void main ( String [ ] args ) { Queue < Integer > A = new LinkedList < Integer > ( ) ; A . add ( 3 ) ; A . add ( 2 ) ; A . add ( 1 ) ; A . add ( 4 ) ; Queue < Integer > B = new LinkedList < Integer > ( ) ; B . add ( 4 ) ; B . add ( 1 ) ; B . add ( 3 ) ; B . add ( 2 ) ; System . out . println ( run_tasks ( A , B ) ) ; } }
public class GFG { static void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; System . out . println ( String . format ( " % . 1 f " , y0 ) + " x " + " ▁ + ▁ " + String . format ( " % . 1 f " , x0 ) + " y ▁ = ▁ " + String . format ( " % . 1 f " , c ) ) ; } public static void main ( String [ ] args ) { double x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] agrs ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; Set < String > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StringBuilder s = new StringBuilder ( in . next ( ) ) ; int l = s . length ( ) ; int [ ] x = new int [ 26 ] ; String s1 = " " ; for ( int j = 0 ; j < l ; j ++ ) { int c = s . charAt ( j ) - ' a ' ; x [ c ] ++ ; } for ( int j = 0 ; j < 26 ; j ++ ) { if ( x [ j ] > 0 ) s1 += ( ( char ) ( ' a ' + j ) ) ; } set . add ( s1 ) ; } System . out . println ( set . size ( ) ) ; } }
import java . awt . geom . Line2D ; import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { int q = in . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) new CGL_2B ( ) . doIt ( ) ; } class CGL_2B { void doIt ( ) { Line2D l1 = new Line2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) ) ; ; Line2D l2 = new Line2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) ) ; ; if ( l1 . intersectsLine ( l2 ) ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; } } }
import java . util . * ; public class GFG { static boolean isAnyNotPalindrome ( String s ) { Set < Character > unique = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . add ( s . charAt ( i ) ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; } public static void main ( String [ ] args ) { String s = " aaaaab " ; if ( isAnyNotPalindrome ( s ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class Test { public static int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; System . out . println ( findMajority ( arr , n ) ) ; } }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . PriorityQueue ; import java . util . Stack ; public class Solution { static int [ ] nodeColors ; static boolean [ ] visited ; static String [ ] [ ] neighborstring ; static List < Integer > [ ] startIndices ; static int [ ] edgesToPrint ; static int mod = 998244353 ; static int [ ] parents ; static HashSet < Integer > cycleSet ; static PriorityQueue < Integer > [ ] neighborPriority ; static int [ ] minPointsToEnterRoom ; static int [ ] maxPointsToEnterRoom ; static int [ ] pointOfEachRoom ; static List < Integer > [ ] neighbors ; static int [ ] [ ] memo ; public static void main ( String [ ] args ) throws IOException { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int count = Integer . parseInt ( bufferedReader . readLine ( ) ) ; int pos = 0 ; for ( int i = 0 ; i < count ; i ++ ) { String [ ] s = bufferedReader . readLine ( ) . split ( " ▁ " ) ; int no = Integer . parseInt ( s [ 0 ] ) ; if ( s [ 1 ] . equals ( " South " ) ) { pos += no ; if ( pos > 20000 ) { break ; } } else if ( s [ 1 ] . equals ( " North " ) ) { pos -= no ; if ( pos < 0 ) { break ; } } else { if ( pos == 0 || pos == 20000 ) { pos = 1 ; break ; } } } if ( pos == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; class solution { static int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 4 , 5 } ; int n = arr . length ; int k = 6 ; System . out . println ( countSubArrays ( arr , n , k ) ) ; } }
import java . util . * ; public class GFG { static boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 || k % 3 != 0 ) return false ; return true ; } public static void main ( String [ ] args ) { int a1 = 6 , b1 = 3 , c1 = 2 , k1 = 7 ; if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static Vector < Vector < Integer > > adjacency = new Vector < Vector < Integer > > ( ) ; static void insert ( int x , int y ) { adjacency . get ( x ) . add ( y ) ; } static void dfs ( int node , int leaf [ ] , int vis [ ] ) { leaf [ node ] = 0 ; vis [ node ] = 1 ; for ( int i = 0 ; i < adjacency . get ( node ) . size ( ) ; i ++ ) { int it = adjacency . get ( node ) . get ( i ) ; if ( vis [ it ] == 0 ) { dfs ( it , leaf , vis ) ; leaf [ node ] += leaf [ it ] ; } } if ( adjacency . get ( node ) . size ( ) == 0 ) leaf [ node ] = 1 ; } static void printLeaf ( int n , int leaf [ ] ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( " The ▁ node ▁ " + i + " ▁ has ▁ " + leaf [ i ] + " ▁ leaf ▁ nodes \n " ) ; } } public static void main ( String args [ ] ) { int N = 6 ; for ( int i = 0 ; i <= N ; i ++ ) adjacency . add ( new Vector < Integer > ( ) ) ; insert ( 1 , 2 ) ; insert ( 1 , 3 ) ; insert ( 3 , 4 ) ; insert ( 3 , 5 ) ; insert ( 3 , 6 ) ; int leaf [ ] = new int [ N + 1 ] ; int vis [ ] = new int [ N + 1 ] ; dfs ( 1 , leaf , vis ) ; printLeaf ( N , leaf ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] $ ) { Scanner s = new Scanner ( System . in ) ; String v = s . next ( ) ; long n = s . nextLong ( ) ; for ( int i = 0 , e = ( int ) Math . min ( v . length ( ) , n ) ; i < e ; ++ i ) { if ( v . charAt ( i ) != '1' ) { System . out . println ( v . charAt ( i ) ) ; return ; } } System . out . println ( '1' ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class Garland { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; String s1 = s . next ( ) ; String s2 = s . next ( ) ; if ( isValid ( s1 , s2 ) == false ) { System . out . println ( - 1 ) ; } else { HashMap < Character , Integer > m1 = new HashMap < > ( ) ; HashMap < Character , Integer > m2 = new HashMap < > ( ) ; for ( char c : s1 . toCharArray ( ) ) { if ( m1 . containsKey ( c ) ) { m1 . put ( c , m1 . get ( c ) + 1 ) ; } else { m1 . put ( c , 1 ) ; } } for ( char c : s2 . toCharArray ( ) ) { if ( m2 . containsKey ( c ) ) { m2 . put ( c , m2 . get ( c ) + 1 ) ; } else { m2 . put ( c , 1 ) ; } } int ans = 0 ; HashSet < Character > hs = new HashSet < > ( ) ; for ( char c : s2 . toCharArray ( ) ) { if ( ! hs . contains ( c ) ) { hs . add ( c ) ; int x1 = m1 . get ( c ) ; int x2 = m2 . get ( c ) ; x1 = Math . min ( x1 , x2 ) ; ans += x1 ; } } System . out . println ( ans ) ; } } public static boolean isValid ( String s1 , String s2 ) { int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; HashMap < Character , Boolean > map = new HashMap < > ( ) ; for ( char c : s1 . toCharArray ( ) ) { map . put ( c , true ) ; } for ( char c : s2 . toCharArray ( ) ) { if ( ! map . containsKey ( c ) ) return false ; } return true ; } }
public class LCS_3Strings { static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; } public static void main ( String args [ ] ) { String X = " AGGT12" ; String Y = "12TXAYB " ; String Z = "12XBA " ; int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; System . out . println ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcsOf3 ( X , Y , Z , m , n , o ) ) ; } }
import java . util . * ; public class cf596B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; long [ ] arr = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = scan . nextInt ( ) ; } long answer = Math . abs ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { answer += Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; } System . out . println ( answer ) ; } }
public class GFG { static boolean isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 3 ; int a [ ] = { 1 , 1 , 2 } ; if ( isSpiltPossible ( n , a ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int [ ] dp = new int [ 5 ] ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ 1 ] = dp [ 1 ] + ( arr [ i ] == 1 ? 1 : 0 ) ; dp [ 2 ] = Math . max ( dp [ 1 ] , dp [ 2 ] + ( arr [ i ] == 2 ? 1 : 0 ) ) ; dp [ 3 ] = Math . max ( dp [ 2 ] , dp [ 3 ] + ( arr [ i ] == 1 ? 1 : 0 ) ) ; dp [ 4 ] = Math . max ( dp [ 3 ] , dp [ 4 ] + ( arr [ i ] == 2 ? 1 : 0 ) ) ; } System . out . println ( dp [ 4 ] ) ; } }
import java . io . * ; public class GFG { static void count_even_odd ( int min , int max , int steps [ ] [ ] ) { int a , b , even , odd ; boolean beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] ; b = steps [ i ] [ 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; System . out . println ( " even ▁ = ▁ " + even + " , ▁ odd ▁ = ▁ " + odd ) ; } public static void main ( String [ ] args ) { int min = 1 , max = 4 ; int steps [ ] [ ] = { { 1 , 2 } , { 3 , 4 } } ; count_even_odd ( min , max , steps ) ; } }
public class JohnyLikesNumbers { public static void main ( String [ ] args ) { java . util . Scanner input = new java . util . Scanner ( System . in ) ; int n = input . nextInt ( ) , k = input . nextInt ( ) ; ; System . out . println ( ( n / k + 1 ) * k ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void printKPFNums ( int A , int B , int K ) { boolean prime [ ] = new boolean [ B + 1 ] ; Arrays . fill ( prime , true ) ; int p_factors [ ] = new int [ B + 1 ] ; Arrays . fill ( p_factors , 0 ) ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) System . out . print ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { int A = 14 , B = 18 , K = 2 ; printKPFNums ( A , B , K ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void reverseWords ( String str ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( str . charAt ( i ) != ' ▁ ' ) st . push ( str . charAt ( i ) ) ; else { while ( st . empty ( ) == false ) { System . out . print ( st . pop ( ) ) ; } System . out . print ( " ▁ " ) ; } } while ( st . empty ( ) == false ) { System . out . print ( st . pop ( ) ) ; } } public static void main ( String [ ] args ) { String str = " Geeks ▁ for ▁ Geeks " ; reverseWords ( str ) ; } }
import java . util . Scanner ; public class Task { static Scanner scanner = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = scanner . nextInt ( ) ; int [ ] p = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = scanner . nextInt ( ) ; } int onlyFistSolve = 0 ; int onlySecondSolve = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = scanner . nextInt ( ) ; if ( p [ i ] == 1 && r == 0 ) { onlyFistSolve ++ ; } else if ( p [ i ] == 0 && r == 1 ) { onlySecondSolve ++ ; } } if ( onlyFistSolve == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( ( onlySecondSolve + onlyFistSolve ) / onlyFistSolve ) ; } } }
import java . util . * ; import java . io . * ; public class Main { static int N = ( int ) 1e7 ; static boolean [ ] IsPrime ; public static void main ( String [ ] args ) { IRead input = new IRead ( ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int n = input . nextInt ( ) ; Is_prime ( ) ; int x = ( n <= 2 ) ? 1 : 2 ; n ++ ; out . println ( x ) ; for ( int i = 2 ; i <= n ; i ++ ) { if ( IsPrime [ i ] ) { out . print ( 1 + " ▁ " ) ; } else { out . print ( 2 + " ▁ " ) ; } } out . close ( ) ; } public static void Is_prime ( ) { IsPrime = new boolean [ N ] ; Arrays . fill ( IsPrime , true ) ; IsPrime [ 0 ] = IsPrime [ 1 ] = false ; for ( int i = 2 ; i * i < N ; i ++ ) { if ( IsPrime [ i ] ) { for ( int j = i * i ; j < N ; j += i ) { IsPrime [ j ] = false ; } } } } } class IRead { BufferedReader Br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; public String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( Br . readLine ( ) ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } }
import java . util . Scanner ; import java . util . Stack ; public class Main { static int h ; static int w ; static int c ; static int ans ; static int count ; static int [ ] color_order ; static int [ ] [ ] map ; static int [ ] [ ] tmp ; public static void main ( String [ ] args ) throws java . io . IOException { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { String ns [ ] = sc . nextLine ( ) . split ( " ▁ " ) ; Stack < Double > stack = new Stack < Double > ( ) ; for ( int i = 0 ; i < ns . length ; i ++ ) { if ( ns [ i ] . length ( ) > 1 ) { stack . push ( Double . parseDouble ( ns [ i ] ) ) ; } else { char sw = ns [ i ] . charAt ( 0 ) ; switch ( sw ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : stack . push ( Double . parseDouble ( ns [ i ] ) ) ; break ; case ' + ' : { double x = stack . pop ( ) ; double y = stack . pop ( ) ; stack . push ( x + y ) ; } break ; case ' - ' : { double x = stack . pop ( ) ; double y = stack . pop ( ) ; stack . push ( y - x ) ; } break ; case ' * ' : { double x = stack . pop ( ) ; double y = stack . pop ( ) ; stack . push ( y * x ) ; } break ; case ' / ' : double x = stack . pop ( ) ; double y = stack . pop ( ) ; stack . push ( y / x ) ; break ; } } } double ans = stack . pop ( ) ; System . out . printf ( " % .6f \n " , ans ) ; } } }
import java . util . * ; public class FunctionHeight { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long k = sc . nextLong ( ) ; System . out . println ( n >= k ? 1 : ( k % n == 0 ? k / n : ( k / n + 1 ) ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class GFG { static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n = n / 2 ; System . out . print ( ( int ) Math . pow ( 3 , n - 1 ) + " \n " ) ; } else { n = ( n / 2 ) + 1 ; System . out . print ( ( int ) Math . pow ( 2 , n - 1 ) + " \n " ) ; } } public static void main ( String [ ] args ) { int N = 4 ; findNthTerm ( N ) ; N = 11 ; findNthTerm ( N ) ; } }
public class GFG { static int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] >= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 7 , 1 , 1 } ; int n = arr . length ; System . out . println ( countNonIncreasing ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int maximize ( int A1 [ ] , int A2 [ ] , int n , int x , int y ) { int [ ] c = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = A2 [ i ] - A1 [ i ] ; sum += A1 [ i ] ; } int temp ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( c [ i ] < c [ i + 1 ] ) { temp = c [ i ] ; c [ i ] = c [ i + 1 ] ; c [ i + 1 ] = temp ; } } int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += c [ i ] ; if ( i + 1 >= ( n - x ) ) maxi = Math . max ( sum , maxi ) ; } return maxi ; } public static void main ( String args [ ] ) { int A1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int A2 [ ] = { 5 , 4 , 3 , 2 , 1 } ; int n = 5 ; int x = 3 , y = 3 ; System . out . println ( maximize ( A1 , A2 , n , x , y ) ) ; } }
import java . util . * ; import java . io . * ; public class MainClass { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int t = Integer . parseInt ( st . nextToken ( ) ) ; while ( t -- > 0 ) { st = new StringTokenizer ( br . readLine ( ) ) ; int x = Integer . parseInt ( st . nextToken ( ) ) ; String s = Integer . toString ( x ) ; int extra = s . length ( ) ; int temp = Character . getNumericValue ( s . charAt ( 0 ) ) ; int ans = 0 ; for ( int i = 1 ; i < temp ; i ++ ) { ans += 10 ; } ans += ( extra ) * ( extra + 1 ) / 2 ; System . out . println ( ans ) ; } } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; class Main { private static final int INFINITY = Integer . MAX_VALUE / 2 ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; int K [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { K [ i ] [ j ] = INFINITY ; } } int m = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) { String str [ ] = br . readLine ( ) . trim ( ) . split ( " , " ) ; int a = Integer . parseInt ( str [ 0 ] ) - 1 ; int b = Integer . parseInt ( str [ 1 ] ) - 1 ; K [ a ] [ b ] = Integer . parseInt ( str [ 2 ] ) ; K [ b ] [ a ] = Integer . parseInt ( str [ 3 ] ) ; } String str [ ] = br . readLine ( ) . split ( " , " ) ; int start = Integer . parseInt ( str [ 0 ] ) - 1 ; int goal = Integer . parseInt ( str [ 1 ] ) - 1 ; int V = Integer . parseInt ( str [ 2 ] ) ; int P = Integer . parseInt ( str [ 3 ] ) ; for ( int k = 0 ; k < N ; k ++ ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( K [ i ] [ j ] > K [ i ] [ k ] + K [ k ] [ j ] ) { K [ i ] [ j ] = K [ i ] [ k ] + K [ k ] [ j ] ; } } } } System . out . println ( V - P - K [ start ] [ goal ] - K [ goal ] [ start ] ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int r1 = input . nextInt ( ) , r2 = input . nextInt ( ) , c1 = input . nextInt ( ) , c2 = input . nextInt ( ) , d1 = input . nextInt ( ) , d2 = input . nextInt ( ) ; if ( ( c1 + c2 - r1 - r2 ) != 0 || ( d1 + d2 - r1 - r2 ) != 0 ) System . out . print ( - 1 ) ; else { boolean flag = true ; int t = ( r2 - d2 + c2 ) / 2 , z = d2 - c2 + t , y = c2 - t , x = r1 + r2 - y - z - t ; int [ ] box = { x , y , z , t } ; for ( int gem : box ) { if ( gem > 9 || gem < 1 ) { flag = false ; break ; } } if ( ( x == y ) || ( x == z ) || ( x == t ) || ( y == z ) || ( y == t ) || ( z == t ) ) flag = false ; if ( flag ) System . out . printf ( " % d ▁ % d % n % d ▁ % d " , x , y , z , t ) ; else System . out . print ( - 1 ) ; } } }
import java . util . Scanner ; import java . util . SortedSet ; import java . util . TreeSet ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; for ( ; ; ) { int n = Integer . parseInt ( scan . next ( ) ) ; int m = Integer . parseInt ( scan . next ( ) ) ; if ( n == 0 && m == 0 ) break ; int a [ ] = new int [ n ] ; int w [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( scan . next ( ) ) ; } for ( int j = 0 ; j < m ; j ++ ) { w [ j ] = Integer . parseInt ( scan . next ( ) ) ; } SortedSet < Integer > commonAdditions = null ; for ( int i = 0 ; i < n ; i ++ ) { SortedSet < Integer > additions = new TreeSet < Integer > ( ) ; boolean bJust = calcNearestWeight ( a [ i ] , w , 0 , 0 , additions ) ; if ( ! bJust ) { if ( commonAdditions == null ) { commonAdditions = additions ; } else { commonAdditions . retainAll ( additions ) ; } } } if ( commonAdditions == null ) { System . out . println ( 0 ) ; } else { if ( commonAdditions . size ( ) > 0 ) { System . out . println ( commonAdditions . first ( ) ) ; } else { System . out . println ( - 1 ) ; } } } scan . close ( ) ; } private static boolean calcNearestWeight ( int x , int w [ ] , int i , int sum , SortedSet < Integer > additions ) { if ( x == sum ) return true ; if ( i == w . length ) { additions . add ( Math . abs ( x - sum ) ) ; return false ; } if ( calcNearestWeight ( x , w , i + 1 , sum , additions ) ) return true ; if ( calcNearestWeight ( x , w , i + 1 , sum + w [ i ] , additions ) ) return true ; return calcNearestWeight ( x , w , i + 1 , sum - w [ i ] , additions ) ; } }
import java . io . * ; import java . util . * ; public class DP { static int mod = ( int ) 1e9 + 7 ; public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int N = in . nextInt ( ) ; int dp [ ] = new int [ 1 << 3 ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int price = in . nextInt ( ) ; String s = in . next ( ) ; int mask = 0 ; if ( s . contains ( " A " ) ) mask |= 1 ; if ( s . contains ( " B " ) ) mask |= 2 ; if ( s . contains ( " C " ) ) mask |= 4 ; for ( int k = 0 ; k < ( 1 << 3 ) ; k ++ ) { if ( dp [ k ] != Integer . MAX_VALUE ) { int t = k | mask ; dp [ t ] = Math . min ( dp [ t ] , dp [ k ] + price ) ; } } } out . println ( dp [ 7 ] == Integer . MAX_VALUE ? - 1 : dp [ 7 ] ) ; out . close ( ) ; } static class Scanner { StringTokenizer st ; BufferedReader br ; public Scanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Scanner ( String s ) throws FileNotFoundException { br = new BufferedReader ( new FileReader ( s ) ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public String nextLine ( ) throws IOException { return br . readLine ( ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } } }
import java . util . * ; public class GFG { static boolean startsWith ( String str , String pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 , j = 0 ; while ( i < strLen && j < preLen ) { if ( str . charAt ( i ) != pre . charAt ( j ) ) return false ; i ++ ; j ++ ; } return true ; } static boolean endsWith ( String str , String suff ) { int i = str . length ( ) - 1 ; int j = suff . length ( ) - 1 ; while ( i >= 0 && j >= 0 ) { if ( str . charAt ( i ) != suff . charAt ( j ) ) return false ; i -- ; j -- ; } return true ; } static boolean checkString ( String str , String a , String b ) { if ( str . length ( ) != a . length ( ) + b . length ( ) ) return false ; if ( startsWith ( str , a ) ) { if ( endsWith ( str , b ) ) return true ; } if ( startsWith ( str , b ) ) { if ( endsWith ( str , a ) ) return true ; } return false ; } public static void main ( String args [ ] ) { String str = " GeeksforGeeks " ; String a = " Geeksfo " ; String b = " rGeeks " ; if ( checkString ( str , a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . out . println ( i + " ▁ " + j + " ▁ " + k ) ; return ; } } } } } } } public static void main ( String [ ] args ) { int n = 233 ; printCombination ( n ) ; } }
import java . io . * ; public class GFG { static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntegralSolutions ( n ) ) ; } }
public class GFG { final static int TEN = 10 ; static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % TEN ; n /= TEN ; } return sum ; } static int getNthTerm ( int n ) { int sum = digitSum ( n ) ; if ( sum % TEN == 0 ) return ( n * TEN ) ; int extra = TEN - ( sum % TEN ) ; return ( ( n * TEN ) + extra ) ; } static void firstNTerms ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( getNthTerm ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 10 ; firstNTerms ( n ) ; } }
public class GFG { static int power ( int x , int a ) { int res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; } static int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct = - 1 ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; } public static void main ( String [ ] args ) { int maxProduct = breakInteger ( 10 ) ; System . out . println ( maxProduct ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { int [ ] eulerPhiTable ( int n ) { int [ ] res = new int [ n + 1 ] ; boolean [ ] p = new boolean [ n + 1 ] ; Arrays . fill ( p , true ) ; p [ 0 ] = p [ 1 ] = false ; for ( int i = 0 ; i <= n ; i ++ ) res [ i ] = i ; for ( int i = 2 ; i <= n ; i ++ ) if ( p [ i ] ) { res [ i ] -= res [ i ] / i ; for ( int j = i + i ; j <= n ; j += i ) { p [ j ] = false ; res [ j ] -= res [ j ] / i ; } } return res ; } void run ( ) { int N = 1000000 ; int [ ] f = eulerPhiTable ( N ) ; long [ ] res = new long [ N + 1 ] ; res [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) res [ i ] = res [ i - 1 ] + f [ i ] ; Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; while ( T -- != 0 ) System . out . println ( res [ sc . nextInt ( ) ] ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; StringBuilder sb = new StringBuilder ( s ) ; s = s . replace ( "2017" , "2018" ) ; System . out . println ( s ) ; } }
import java . util . LinkedList ; import java . util . Queue ; public class NonReapatingCQueue { final static int MAX_CHAR = 26 ; static void firstNonRepeating ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; Queue < Character > q = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; q . add ( ch ) ; charCount [ ch - ' a ' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( charCount [ q . peek ( ) - ' a ' ] > 1 ) q . remove ( ) ; else { System . out . print ( q . peek ( ) + " ▁ " ) ; break ; } } if ( q . isEmpty ( ) ) System . out . print ( - 1 + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { String str = " aabc " ; firstNonRepeating ( str ) ; } }
import java . util . ArrayList ; import java . util . Scanner ; public class CF862B { static Node [ ] arr ; static long totalFalse ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; arr = new Node [ n ] ; totalFalse = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = new Node ( i ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; arr [ a ] . neighbors . add ( b ) ; arr [ b ] . neighbors . add ( a ) ; } dfs ( 0 , true ) ; long total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] . parity ) { total += ( totalFalse - arr [ i ] . neighbors . size ( ) ) ; } } System . out . println ( total ) ; } static void dfs ( Integer currNode , boolean parity ) { arr [ currNode ] . parity = parity ; if ( ! parity ) totalFalse ++ ; for ( Integer nextNode : arr [ currNode ] . neighbors ) { if ( arr [ nextNode ] . parity != null ) continue ; dfs ( nextNode , ! parity ) ; } } static class Node { int index ; ArrayList < Integer > neighbors ; Boolean parity ; public Node ( int index ) { this . index = index ; neighbors = new ArrayList < > ( ) ; parity = null ; } } }
import java . util . * ; public class GFG { static int solve ( int n , int m , int obstacles , double range [ ] ) { double val = Math . min ( n , m ) ; Arrays . sort ( range ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } return 0 ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 , obstacles = 3 ; double range [ ] = { 1.0 , 1.25 , 1.15 } ; System . out . print ( solve ( n , m , obstacles , range ) + " \n " ) ; } }
import java . util . Scanner ; import java . util . ArrayList ; public class Main { Scanner sc = new Scanner ( System . in ) ; public void run ( ) { String exp = sc . next ( ) ; calc ( exp ) ; } public void calc ( String exp ) { int ans1 = 0 ; int ans2 = Integer . parseInt ( exp . substring ( 0 , 1 ) ) ; int temp = ans2 ; for ( int i = 0 ; i < exp . length ( ) / 2 ; i ++ ) { String e = exp . substring ( 2 * i + 1 , 2 * i + 2 ) ; int k = Integer . parseInt ( exp . substring ( 2 * i + 2 , 2 * i + 3 ) ) ; if ( e . equals ( " + " ) ) { ans2 += k ; ans1 += temp ; temp = k ; } else { ans2 *= k ; temp *= k ; } } ans1 += temp ; int bob_ans = sc . nextInt ( ) ; String output = " " ; if ( bob_ans == ans1 ) { if ( bob_ans == ans2 ) output = " U " ; else output = " M " ; } else if ( bob_ans == ans2 ) output = " L " ; else output = " I " ; System . out . println ( output ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class MinStack { private Stack < Integer > stack ; private Stack < Integer > minStack ; public MinStack ( ) { stack = new Stack < > ( ) ; minStack = new Stack < > ( ) ; } public void push ( int x ) { stack . push ( x ) ; if ( minStack . size ( ) == 0 || x <= minStack . peek ( ) ) minStack . push ( x ) ; else minStack . push ( minStack . peek ( ) ) ; } public void pop ( ) { stack . pop ( ) ; minStack . pop ( ) ; } public int top ( ) { return stack . peek ( ) ; } public int getMin ( ) { return minStack . peek ( ) ; } public static void main ( String [ ] args ) { MinStack m = new MinStack ( ) ; m . push ( - 2 ) ; m . push ( 0 ) ; m . push ( - 3 ) ; System . out . println ( m . getMin ( ) ) ; m . pop ( ) ; System . out . println ( m . top ( ) ) ; System . out . println ( m . getMin ( ) ) ; } }
public class GFG { static String one [ ] = { " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " } ; static String ten [ ] = { " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " } ; static String numToWords ( int n , String s ) { String str = " " ; if ( n > 19 ) { str += ten [ n / 10 ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; } static String convertToWords ( long n ) { String out = " " ; out += numToWords ( ( int ) ( n / 10000000 ) , " crore ▁ " ) ; out += numToWords ( ( int ) ( ( n / 100000 ) % 100 ) , " lakh ▁ " ) ; out += numToWords ( ( int ) ( ( n / 1000 ) % 100 ) , " thousand ▁ " ) ; out += numToWords ( ( int ) ( ( n / 100 ) % 10 ) , " hundred ▁ " ) ; if ( n > 100 && n % 100 > 0 ) { out += " and ▁ " ; } out += numToWords ( ( int ) ( n % 100 ) , " " ) ; return out ; } public static void main ( String [ ] args ) { long n = 438237764 ; System . out . println ( convertToWords ( n ) ) ; } }
public class GFG { static int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; } static boolean areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; } static int sub ( int a , int b ) { return a + flipSign ( b ) ; } static int mul ( int a , int b ) { if ( a < b ) return mul ( b , a ) ; int sum = 0 ; for ( int i = Math . abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; } static int division ( int a , int b ) { if ( b == 0 ) throw new ArithmeticException ( ) ; int quotient = 0 , dividend ; int divisor = flipSign ( Math . abs ( b ) ) ; for ( dividend = Math . abs ( a ) ; dividend >= Math . abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; } public static void main ( String [ ] args ) { System . out . println ( " Subtraction ▁ is ▁ " + sub ( 4 , - 2 ) ) ; System . out . println ( " Product ▁ is ▁ " + mul ( - 9 , 6 ) ) ; try { System . out . println ( " Division ▁ is ▁ " + division ( 8 , 2 ) ) ; } catch ( ArithmeticException e ) { System . out . println ( " Exception ▁ : - ▁ Divide ▁ by ▁ 0" ) ; } } }
class Test { static int factorial ( int n ) { int i = n , fact = 1 ; while ( n / i != n ) { fact = fact * i ; i -- ; } return fact ; } public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( " Factorial ▁ of ▁ " + num + " ▁ is ▁ " + factorial ( 5 ) ) ; } }
public class GFG { static int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = arr . length ; int x = 2 ; System . out . println ( CntDivbyX ( arr , n , x ) ) ; } }
import java . util . Scanner ; public class B272 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; long [ ] stat = new long [ 30 ] ; for ( int n = 0 ; n < N ; n ++ ) { int a = in . nextInt ( ) ; stat [ Integer . bitCount ( a ) ] ++ ; } long answer = 0 ; for ( long count : stat ) { answer += count * ( count - 1 ) ; } answer /= 2 ; System . out . println ( answer ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; } public static void main ( String argc [ ] ) { int arr[] = { 1 , 1 , 2 , 3 } ; int N = 4 ; int k = 5 ; System . out . println ( min_noOf_operation ( arr , N , k ) ) ; } }
public class GFG { static int CountSubSet ( int arr [ ] , int n , int X ) { int N = ( int ) Math . pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 , 7 } ; int X = 5 ; int n = arr . length ; System . out . println ( CountSubSet ( arr , n , X ) ) ; } }
public class GFG { static final int n = 5 ; static int FindMaxProduct ( int arr [ ] [ ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } } ; System . out . println ( FindMaxProduct ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 50002 ; static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; public static void sieve ( ) { boolean isPrime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( isPrime [ p ] == true ) primes . add ( p ) ; } public static int power ( int x , int y ) { int count = 0 ; int z = y ; while ( x >= z ) { count += ( x / z ) ; z *= y ; } return count ; } public static int modMult ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } public static int countWays ( int n , int m ) { int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { int powers = power ( n , primes . get ( i ) ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; } public static void main ( String [ ] args ) { sieve ( ) ; int n = 4 , m = 7 ; System . out . println ( countWays ( n , m ) ) ; } }
public class GFG { static int smallestIndexsum ( int arr [ ] , int n ) { int i = n - 1 ; while ( i >= 0 && arr [ i ] % 2 == 1 ) i -- ; int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) sum += arr [ j ] ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 6 , 3 , 3 } ; int n = arr . length ; System . out . println ( smallestIndexsum ( arr , n ) ) ; } }
import java . math . BigInteger ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . * ; public class Main { static Scanner input = new Scanner ( System . in ) ; public static void main ( String [ ] args ) throws ParseException { String t1 = input . next ( ) ; String t2 = input . next ( ) ; DateFormat date = new SimpleDateFormat ( " yyyy : MM : dd " ) ; date . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; System . out . println ( Math . abs ( date . parse ( t1 ) . getTime ( ) - date . parse ( t2 ) . getTime ( ) ) / ( 1000 * 60 * 60 * 24 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { ArrayList < Character > al = new ArrayList < > ( ) ; char c = s . charAt ( i ) ; if ( c == ' Q ' ) { al . add ( c ) ; } for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { char a = s . charAt ( j ) ; if ( al . size ( ) > 0 ) { if ( al . get ( al . size ( ) - 1 ) == ' Q ' && a == ' A ' ) { al . add ( a ) ; } if ( al . get ( al . size ( ) - 1 ) == ' A ' && a == ' Q ' ) { al . add ( a ) ; } if ( al . get ( al . size ( ) - 1 ) == ' A ' && a == ' A ' ) { al . add ( a ) ; } } if ( al . size ( ) >= 3 && al . get ( 0 ) == ' Q ' && al . get ( al . size ( ) - 1 ) == ' Q ' ) { count = count + al . size ( ) - 3 ; al . remove ( al . size ( ) - 1 ) ; } } } System . out . println ( count ) ; } }
import java . util . Arrays ; import java . util . Scanner ; import java . util . stream . IntStream ; public class Main { public static void main ( String [ ] args ) { try ( Scanner scanner = new Scanner ( System . in ) ) { int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; IntStream . range ( 0 , n ) . forEach ( i -> a [ i ] = scanner . nextInt ( ) ) ; if ( 1 == n ) { System . out . println ( ( k > a [ 0 ] ) ? 1 : 0 ) ; return ; } Arrays . sort ( a ) ; int ng = 0 , ok = n + 1 ; while ( ok - ng > 1 ) { int mid = ( ok + ng ) / 2 ; if ( isNeeded ( mid , n , k , a ) ) { ok = mid ; } else { ng = mid ; } } System . out . println ( ng ) ; } } private static boolean isNeeded ( int now , final int n , final int k , final int [ ] a ) { boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ; IntStream . range ( 0 , n + 1 ) . forEach ( i -> Arrays . fill ( dp [ i ] , false ) ) ; dp [ 0 ] [ 0 ] = true ; IntStream . rangeClosed ( 1 , n ) . forEach ( i -> IntStream . rangeClosed ( 0 , k ) . forEach ( j -> { if ( i == now ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { if ( dp [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = true ; if ( j + a [ i - 1 ] <= k ) { dp [ i ] [ j + a [ i - 1 ] ] = true ; } } } } ) ) ; for ( int i = k - 1 ; i >= Math . max ( k - a [ now - 1 ] , 0 ) ; i -- ) { if ( dp [ n ] [ i ] ) { return true ; } } return false ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int k ; int count = 0 ; for ( int i = n ; i > 0 ; i -- ) { k = s / i ; count += k ; s -= k * i ; } System . out . println ( count ) ; } }
import java . util . * ; public class GFG { static ArrayList < Integer > v = new ArrayList < Integer > ( ) ; static void multiply ( int x ) { int carry = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + v . get ( i ) * x ; v . set ( i , res % 10 ) ; carry = res / 10 ; } while ( carry != 0 ) { v . add ( carry % 10 ) ; carry /= 10 ; } } static int findSumOfDigits ( int n ) { v . add ( 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) multiply ( i ) ; int sum = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) sum += v . get ( i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 1000 ; System . out . println ( findSumOfDigits ( n ) ) ; } }
import java . util . Scanner ; public class B436 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; in . nextInt ( ) ; int [ ] answer = new int [ M ] ; for ( int n = 0 ; n < N ; n ++ ) { char [ ] S = in . next ( ) . toCharArray ( ) ; for ( int m = 0 ; m < M ; m ++ ) { char c = S [ m ] ; if ( c == ' L ' ) { int hit = m - n ; if ( hit >= 0 ) { answer [ hit ] ++ ; } } else if ( c == ' R ' ) { int hit = m + n ; if ( hit < M ) { answer [ hit ] ++ ; } } else if ( c == ' U ' ) { if ( n % 2 == 0 ) { answer [ m ] ++ ; } } } } StringBuilder output = new StringBuilder ( ) ; for ( int a : answer ) { output . append ( a ) . append ( ' ▁ ' ) ; } System . out . println ( output ) ; } }
import java . util . * ; import java . io . * ; public class codeforces356A { public static void main ( String [ ] args ) throws Exception { FastReader in = new FastReader ( ) ; int n = in . nextInt ( ) ; TreeSet < Integer > left = new TreeSet < > ( ) ; int [ ] answer = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left . add ( i ) ; } int q = in . nextInt ( ) ; while ( q -- > 0 ) { int l = in . nextInt ( ) - 1 ; int r = in . nextInt ( ) - 1 ; int win = in . nextInt ( ) ; while ( left . ceiling ( l ) != null && left . ceiling ( l ) <= r ) { int curr = left . ceiling ( l ) ; answer [ curr ] = win ; left . remove ( curr ) ; } answer [ win - 1 ] = 0 ; left . add ( win - 1 ) ; } StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ans . append ( answer [ i ] + " ▁ " ) ; } System . out . println ( ans ) ; } static class FastReader { StringTokenizer st ; BufferedReader br ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String s = " " ; while ( st == null || st . hasMoreElements ( ) ) { try { s = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return s ; } } }
import java . util . * ; import java . io . * ; public class B { static TreeSet < Long > set ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = in . nextLong ( ) ; long [ ] dp = new long [ n + 1 ] ; Arrays . fill ( dp , - 1 ) ; dp [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { dp [ i ] = Math . max ( dp [ i + 1 ] , a [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > dp [ i + 1 ] ) pw . print ( 0 + " ▁ " ) ; else pw . print ( ( dp [ i + 1 ] - a [ i ] + 1 ) + " ▁ " ) ; } pw . println ( ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
class PellNumber { public static int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( pell ( n ) ) ; } }
import java . io . * ; import java . util . * ; public class Hello { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; int square = n * n ; ArrayList < Integer > odd = new ArrayList < > ( ) ; ArrayList < Integer > even = new ArrayList < > ( ) ; for ( int i = 1 ; i <= square ; i ++ ) { if ( i % 2 == 0 ) { even . add ( i ) ; } else { odd . add ( i ) ; } } int loop = square / n ; int div = loop / 2 ; debug ( div ) ; for ( int i = 1 ; i <= loop ; i ++ ) { for ( int j = 0 ; j < div ; j ++ ) { if ( i % 2 == 1 ) { pw . print ( odd . remove ( 0 ) + " ▁ " + ( even . remove ( even . size ( ) - 1 ) ) + " ▁ " ) ; } else { pw . print ( even . remove ( 0 ) + " ▁ " + ( odd . remove ( odd . size ( ) - 1 ) ) + " ▁ " ) ; } } pw . println ( ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . util . * ; public class GFG { static void printSmall ( int arr [ ] , int asize , int n ) { int [ ] copy_arr = Arrays . copyOf ( arr , asize ) ; Arrays . sort ( copy_arr ) ; for ( int i = 0 ; i < asize ; ++ i ) { if ( Arrays . binarySearch ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . length ; int n = 5 ; printSmall ( arr , asize , n ) ; } }
import java . lang . * ; public class GFG { static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( countNumbers ( n ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) , m = in . nextInt ( ) , money = in . nextInt ( ) ; int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { min = Math . min ( in . nextInt ( ) , min ) ; } for ( int i = 0 ; i < m ; i ++ ) { max = Math . max ( in . nextInt ( ) , max ) ; } if ( money % min == 0 ) { int div = money / min ; div = div * max ; pw . print ( Math . max ( div , money ) ) ; } else { int div = money / min ; div = ( div * max ) + ( money % min ) ; pw . print ( Math . max ( div , money ) ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . util . * ; public class GFG { static int maximum = Integer . MIN_VALUE , x , ans = Integer . MAX_VALUE ; static Vector < Vector < Integer > > graph = new Vector < Vector < Integer > > ( ) ; static Vector < Integer > weight = new Vector < Integer > ( ) ; static int __builtin_popcount ( int x ) { int c = 0 ; for ( int i = 0 ; i < 60 ; i ++ ) if ( ( ( x >> i ) & 1 ) != 0 ) c ++ ; return c ; } static void dfs ( int node , int parent ) { int a = __builtin_popcount ( weight . get ( node ) + x ) ; if ( maximum < a ) { maximum = a ; ans = node ; } else if ( maximum == a ) ans = Math . min ( ans , node ) ; for ( int i = 0 ; i < graph . get ( node ) . size ( ) ; i ++ ) { if ( graph . get ( node ) . get ( i ) == parent ) continue ; dfs ( graph . get ( node ) . get ( i ) , node ) ; } } public static void main ( String args [ ] ) { x = 15 ; weight . add ( 0 ) ; weight . add ( 5 ) ; weight . add ( 10 ) ; ; weight . add ( 11 ) ; ; weight . add ( 8 ) ; weight . add ( 6 ) ; for ( int i = 0 ; i < 100 ; i ++ ) graph . add ( new Vector < Integer > ( ) ) ; graph . get ( 1 ) . add ( 2 ) ; graph . get ( 2 ) . add ( 3 ) ; graph . get ( 2 ) . add ( 4 ) ; graph . get ( 1 ) . add ( 5 ) ; dfs ( 1 , 1 ) ; System . out . println ( ans ) ; } }
public class GFG { static int MAX = 26 ; static void updateFreq ( String str , int freq [ ] ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } } static int maxCount ( String str , String patt ) { int [ ] strFreq = new int [ MAX ] ; updateFreq ( str , strFreq ) ; int [ ] pattFreq = new int [ MAX ] ; updateFreq ( patt , pattFreq ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( pattFreq [ i ] == 0 ) continue ; ans = Math . min ( ans , strFreq [ i ] / pattFreq [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; String patt = " geeks " ; System . out . println ( maxCount ( str , patt ) ) ; } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int a [ ] = new int [ n + 1 ] ; int b [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] = in . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) b [ i ] = in . nextInt ( ) ; long a1 = 0 , b1 = 0 , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { a1 = a1 | a [ i ] ; b1 = b1 | b [ i ] ; if ( a1 + b1 > ans ) ans = a1 + b1 ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class A354 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int L = in . nextInt ( ) ; int R = in . nextInt ( ) ; int QL = in . nextInt ( ) ; int QR = in . nextInt ( ) ; int [ ] W = new int [ N ] ; int [ ] sum = new int [ N + 1 ] ; for ( int n = 0 ; n < N ; n ++ ) { W [ n ] = in . nextInt ( ) ; sum [ n + 1 ] = sum [ n ] + W [ n ] ; } long min = Long . MAX_VALUE ; for ( int firstR = 0 ; firstR <= N ; firstR ++ ) { int lCount = firstR ; int rCount = N - lCount ; long cand = sum [ lCount ] * L + ( sum [ N ] - sum [ lCount ] ) * R ; int llCount = Math . max ( 0 , lCount - rCount - 1 ) ; int rrCount = Math . max ( 0 , rCount - lCount - 1 ) ; cand += llCount * QL ; cand += rrCount * QR ; min = Math . min ( cand , min ) ; } System . out . println ( min ) ; } }
public class GFG { static double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; } public static void main ( String [ ] args ) { double V , M , N ; V = 700 ; M = 10 ; N = 3 ; System . out . println ( wastedWater ( V , M , N ) ) ; V = 1000 ; M = 100 ; N = 50 ; System . out . println ( wastedWater ( V , M , N ) ) ; } }
public class GFG { static int maxSubStr ( String str , int n ) { int count0 = 0 , count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( count0 != count1 ) { return - 1 ; } return cnt ; } public static void main ( String [ ] args ) { String str = "0100110101" ; int n = str . length ( ) ; System . out . println ( maxSubStr ( str , n ) ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] abc = new int [ 3 ] ; abc [ 0 ] = sc . nextInt ( ) ; abc [ 1 ] = sc . nextInt ( ) ; abc [ 2 ] = sc . nextInt ( ) ; int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( max < abc [ i ] ) max = abc [ i ] ; if ( min > abc [ i ] ) min = abc [ i ] ; } System . out . println ( min + " ▁ " + max ) ; } }
public class GFG { static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; } public static void main ( String [ ] args ) { int s = 15 ; int n = findS ( s ) ; if ( n == - 1 ) System . out . println ( " - 1" ) ; else System . out . println ( n ) ; } }
import java . util . * ; public class GFG { static int maximumAbsolute ( int arr [ ] , int n ) { int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < n - 1 && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int common_integer = ( mn + mx ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == - 1 ) arr [ i ] = common_integer ; } int max_diff = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; if ( diff > max_diff ) max_diff = diff ; } return max_diff ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , - 1 , 11 , - 1 , 3 , - 1 } ; int n = arr . length ; System . out . println ( maximumAbsolute ( arr , n ) ) ; } }
public class GFG { final static int MOD = 1000000007 ; static long countStrings ( int N ) { int i , j ; int dp [ ] [ ] = new int [ N + 1 ] [ 3 ] ; for ( i = 0 ; i < N + 1 ; i ++ ) { for ( j = 9 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( countStrings ( N ) ) ; } }
public class GFG { static int longest_subseq ( int n , int k , String s ) { int [ ] dp = new int [ n ] ; int [ ] max_length = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s . charAt ( i ) - ' a ' ; int lower = Math . max ( 0 , curr - k ) ; int upper = Math . min ( 25 , curr + k ) ; for ( int j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = Math . max ( dp [ i ] , max_length [ curr ] ) ; } int ans = 0 ; for ( int i : dp ) ans = Math . max ( i , ans ) ; return ans ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int n = s . length ( ) ; int k = 3 ; System . out . println ( longest_subseq ( n , k , s ) ) ; } }
public class GFG { static int longestFibonacciSubarray ( int n , int a [ ] ) { if ( n <= 2 ) return n ; int len = 2 ; int mx = Integer . MIN_VALUE ; for ( int i = 2 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) len ++ ; else len = 2 ; mx = Math . max ( mx , len ) ; } return mx ; } public static void main ( String [ ] args ) { int n = 5 ; int a [ ] = { 2 , 4 , 6 , 10 , 2 } ; System . out . println ( longestFibonacciSubarray ( n , a ) ) ; } }
import java . util . * ; public class GFG { static int minimumSubarrays ( int ar [ ] , int n ) { Vector se = new Vector ( ) ; int cnt = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( se . contains ( ar [ i ] ) == false ) { se . add ( ar [ i ] ) ; } else { cnt ++ ; se . clear ( ) ; se . add ( ar [ i ] ) ; } } return cnt ; } public static void main ( String [ ] args ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 } ; int n = ar . length ; System . out . println ( minimumSubarrays ( ar , n ) ) ; } }
public class GFG { static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; } public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Scanner ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . nio . charset . MalformedInputException ; import java . util . StringTokenizer ; import java . util . Arrays ; public class Cv { public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; Scanner sc = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int g = m ; int f = 0 ; int sum = 0 ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( m <= sum ) { f += sum / m ; sum %= m ; } out . print ( f + " ▁ " ) ; f -= f ; } out . close ( ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; public String next ( ) { while ( ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } byte nextByte ( ) { return Byte . parseByte ( next ( ) ) ; } short nextShort ( ) { return Short . parseShort ( next ( ) ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return java . lang . Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }
public class GFG { static final int MAXN = 1000005 ; static int even [ ] = new int [ MAXN ] ; static int odd [ ] = new int [ MAXN ] ; static void precompute ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } } static boolean isOdd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; } static void performQueries ( int a [ ] , int n , int q [ ] [ ] , int m ) { precompute ( a , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] [ 0 ] , R = q [ i ] [ 1 ] ; if ( isOdd ( L , R ) ) System . out . println ( " Odd " ) ; else System . out . println ( " Even " ) ; } } public static void main ( String args [ ] ) { int [ ] a = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int n = a . length ; int q [ ] [ ] = { { 0 , 2 } , { 1 , 2 } , { 2 , 3 } , { 3 , 6 } } ; int m = q . length ; performQueries ( a , n , q , m ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class pre422 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; String s [ ] = new String [ 1000 ] ; for ( int n = 1 ; n <= 1000 ; n ++ ) { boolean flag = true ; for ( int i = 0 ; i <= 1000 ; i ++ ) { for ( int j = 0 ; j <= 1000 ; j ++ ) { if ( ( n - i * 3 - j * 5 ) % 7 == 0 && ( n - i * 3 - j * 5 ) / 7 >= 0 ) { s [ n - 1 ] = ( i + " ▁ " + j + " ▁ " + ( n - i * 3 - j * 5 ) / 7 ) ; flag = false ; break ; } } if ( ! flag ) break ; } if ( flag ) s [ n - 1 ] = " - 1" ; } int tc = obj . nextInt ( ) ; while ( tc -- != 0 ) { int n = obj . nextInt ( ) ; System . out . println ( s [ n - 1 ] ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class BusesBetweenCities { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int a = Integer . parseInt ( st . nextToken ( ) ) ; int tA = Integer . parseInt ( st . nextToken ( ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; int b = Integer . parseInt ( st . nextToken ( ) ) ; int tB = Integer . parseInt ( st . nextToken ( ) ) ; String timing = br . readLine ( ) ; int hrs = Integer . parseInt ( timing . substring ( 0 , 2 ) ) ; int mins = Integer . parseInt ( timing . substring ( 3 ) ) ; int simDeparture = hrs * 60 + mins ; int simArrival = simDeparture + tA ; int counter = 0 ; for ( int i = 300 ; i < 1440 ; i += b ) { int busDeparture = i ; int busArrival = i + tB ; if ( busDeparture >= simArrival || simDeparture >= busArrival ) continue ; counter ++ ; } pw . println ( counter ) ; pw . flush ( ) ; pw . close ( ) ; } }
import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int out = 3 ; boolean good = true ; ArrayList < Integer > playing = new ArrayList < Integer > ( ) ; playing . add ( 1 ) ; playing . add ( 2 ) ; for ( int i = 0 ; i < n ; i ++ ) { int win = input . nextInt ( ) ; if ( win == out ) { good = false ; break ; } else { int replace = 0 ; for ( int j = 1 ; j <= 3 ; j ++ ) { if ( win != j && out != j ) { replace = j ; break ; } } int index = 0 ; for ( int j = 0 ; j < playing . size ( ) ; j ++ ) { if ( playing . get ( j ) == replace ) { index = j ; break ; } } playing . remove ( index ) ; playing . add ( out ) ; out = replace ; } } if ( good ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static int times ( int [ ] steps , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int steps [ ] = { 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 } ; int n = steps . length ; System . out . println ( times ( steps , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; Holiday [ ] holidays = new Holiday [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { holidays [ i ] = new Holiday ( sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) ) ; } int min = Integer . MAX_VALUE ; for ( int i = 1 ; i <= 360 ; i ++ ) { int max = 0 ; for ( int j = 0 ; j < n ; j ++ ) { max = Math . max ( max , holidays [ j ] . getCrowded ( i ) ) ; } min = Math . min ( min , max ) ; } System . out . println ( min ) ; } static class Holiday { int start ; int end ; int value ; public Holiday ( int month , int day , int time , int value ) { start = ( month - 1 ) * 30 + day ; end = start + time - 1 ; if ( end > 360 ) { end -= 360 ; } this . value = value ; } public int getCrowded ( int target ) { if ( start > end ) { if ( target <= end || target >= start ) { return value ; } } else { if ( start <= target && target <= end ) { return value ; } } int v1 ; if ( target < start ) { v1 = Math . max ( 0 , value - ( start - target ) ) ; } else { v1 = Math . max ( 0 , value - ( 360 + start - target ) ) ; } int v2 ; if ( end < target ) { v2 = Math . max ( 0 , value - ( target - end ) ) ; } else { v2 = Math . max ( 0 , value - ( 360 + target - end ) ) ; } return Math . max ( v1 , v2 ) ; } } }
import java . util . * ; import java . io . * ; public class PetrPermutations { public static void main ( String [ ] args ) { FastScanner scanner = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int N = scanner . nextInt ( ) ; int [ ] perm = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) perm [ i ] = scanner . nextInt ( ) ; int swaps = 0 ; boolean [ ] vis = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int j = i , cycle = 0 ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = perm [ j ] - 1 ; cycle ++ ; } if ( cycle > 0 ) swaps += cycle - 1 ; } if ( swaps % 2 != N % 2 ) out . println ( " Um _ nik " ) ; else out . println ( " Petr " ) ; out . flush ( ) ; } public static class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( Reader in ) { br = new BufferedReader ( in ) ; } public FastScanner ( ) { this ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String readNextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } int [ ] readIntArray ( int n ) { int [ ] a = new int [ n ] ; for ( int idx = 0 ; idx < n ; idx ++ ) { a [ idx ] = nextInt ( ) ; } return a ; } } }
public class GFG { static String smallest ( String s ) { int l = s . length ( ) ; String ans = " " ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s . charAt ( j ) ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; } public static void main ( String [ ] args ) { String s = " abcda " ; System . out . println ( smallest ( s ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int [ ] g = { 0 , 0 , 2 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 } ; if ( g [ a ] == g [ b ] ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
public class GFG { static int FindMinNumber ( int arr [ ] , int n , int k ) { int i = 0 ; int j = 0 ; int min_num = Integer . MAX_VALUE ; boolean found = false ; int sum = 0 ; while ( i < n ) { sum = sum + arr [ i ] ; if ( sum == k ) { min_num = Math . min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } else if ( sum > k ) { while ( sum > k ) { sum = sum - arr [ j ] ; j ++ ; } if ( sum == k ) { min_num = Math . min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } } i ++ ; } if ( found ) return min_num ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 5 , 6 } ; int n = arr . length ; int k = 5 ; System . out . println ( FindMinNumber ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { private static Scanner sc ; private static Printer pr ; private static void solve ( ) { char [ ] s = sc . next ( ) . toCharArray ( ) ; int cnt = 0 ; for ( char c : s ) { if ( c == '1' ) { cnt ++ ; } } pr . println ( cnt ) ; } public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; pr = new Printer ( System . out ) ; solve ( ) ; pr . close ( ) ; sc . close ( ) ; } private static class Printer extends PrintWriter { Printer ( PrintStream out ) { super ( out ) ; } } }
public class GFG { static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int n = 6 , k = 5 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; n = 10 ; k = 6 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; } }
import java . util . * ; public class Main { int INF = Integer . MAX_VALUE ; public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long X = sc . nextLong ( ) ; long [ ] x = new long [ N ] ; long [ ] xsum = new long [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { x [ i ] = sc . nextInt ( ) ; xsum [ i + 1 ] = xsum [ i ] + x [ i ] ; } long ans = X * N + 5 * xsum [ N ] ; for ( int i = 1 ; i < N ; i ++ ) { long cost = X * i + 5 * ( xsum [ N ] - xsum [ N - i ] ) ; for ( int j = 5 , k = N - i ; k >= 0 ; j += 2 , k -= i ) { if ( cost > ans ) { break ; } cost += j * ( xsum [ k ] - xsum [ Math . max ( k - i , 0 ) ] ) ; } ans = Math . min ( ans , cost ) ; } System . out . println ( ans + N * X ) ; } }
import java . util . * ; class Solution { static final int MAX = 10000 ; static int hashTable [ ] = new int [ MAX ] ; static int minOperations ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] != 0 ) { for ( int j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int p1 = input . nextInt ( ) ; int p2 = input . nextInt ( ) ; int p3 = input . nextInt ( ) ; int p4 = input . nextInt ( ) ; int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int i ; int min = Math . min ( Math . min ( p1 , p2 ) , Math . min ( p3 , p4 ) ) ; int c = 0 ; for ( i = a ; i <= b ; i ++ ) { if ( i < min ) { c ++ ; } } System . out . println ( c ) ; } }
public final class p033 { public static void main ( String [ ] args ) { System . out . println ( new p033 ( ) . run ( ) ) ; } public String run ( ) { int numer = 1 ; int denom = 1 ; for ( int d = 10 ; d < 100 ; d ++ ) { for ( int n = 10 ; n < d ; n ++ ) { int n0 = n % 10 , n1 = n / 10 ; int d0 = d % 10 , d1 = d / 10 ; if ( n1 == d0 && n0 * d == n * d1 || n0 == d1 && n1 * d == n * d0 ) { numer *= n ; denom *= d ; } } } return Integer . toString ( denom / Library . gcd ( numer , denom ) ) ; } }
import java . io . * ; public class GFG { static int countSetBits ( int n ) { long count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return ( int ) count ; } static int countOfOddsPascal ( int n ) { int c = countSetBits ( n ) ; return ( int ) Math . pow ( 2 , c ) ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( countOfOddsPascal ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int ans = Math . max ( Math . max ( x , a - 1 - x ) * b , a * Math . max ( y , b - 1 - y ) ) ; System . out . println ( ans ) ; } } catch ( Exception e ) { } } }
import java . util . * ; import java . util . ArrayList ; class GfG { public static int minSwaps ( int [ ] arr ) { int n = arr . length ; ArrayList < Pair < Integer , Integer > > arrpos = new ArrayList < Pair < Integer , Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) arrpos . add ( new Pair < Integer , Integer > ( arr [ i ] , i ) ) ; arrpos . sort ( new Comparator < Pair < Integer , Integer > > ( ) { public int compare ( Pair < Integer , Integer > o1 , Pair < Integer , Integer > o2 ) { if ( o1 . getKey ( ) > o2 . getKey ( ) ) return 1 ; else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) ) ) return 0 ; else return - 1 ; } } ) ; Boolean [ ] vis = new Boolean [ n ] ; Arrays . fill ( vis , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos . get ( i ) . getValue ( ) == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos . get ( j ) . getValue ( ) ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; } } public class MinSwaps { public static void main ( String [ ] args ) { int [ ] a = { 1 , 5 , 4 , 3 , 2 } ; GfG g = new GfG ( ) ; System . out . println ( g . minSwaps ( a ) ) ; } }
import java . util . * ; public class GFG { static final int N = 1000005 ; static boolean prime [ ] = new boolean [ N ] ; static void sieve ( ) { Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } } static int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; boolean flag = true ; while ( num > 0 ) { if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power > 0 ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int n = 25 ; sieve ( ) ; System . out . println ( sumTruncatablePrimes ( n ) ) ; } }
import java . util . * ; public class GFG { static void findWeights ( int X ) { int sum = 0 ; int power = 0 ; int number = 3 ; while ( sum < X ) { sum = number - 1 ; sum /= 2 ; power ++ ; number *= 3 ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { System . out . print ( ans + " ▁ " ) ; ans = ans * 3 ; } } public static void main ( String [ ] args ) { int X = 2 ; findWeights ( X ) ; } }
import java . util . * ; public class GFG { static ArrayList < Integer > addToArrayForm ( ArrayList < Integer > A , int K ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; int rem = 0 ; int i = 0 ; for ( i = A . size ( ) - 1 ; i >= 0 ; i -- ) { int my = A . get ( i ) + K % 10 + rem ; if ( my > 9 ) { rem = 1 ; v . add ( my % 10 ) ; } else { v . add ( my ) ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { int my = K % 10 + rem ; v . add ( my % 10 ) ; if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v . add ( rem ) ; for ( int j = v . size ( ) - 1 ; j >= 0 ; j -- ) ans . add ( v . get ( j ) ) ; return ans ; } public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; A . add ( 2 ) ; A . add ( 7 ) ; A . add ( 4 ) ; int K = 181 ; ArrayList < Integer > ans = addToArrayForm ( A , K ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) ) ; } }
public class GFG { private static void printPaths ( char [ ] [ ] input , int R , int C ) { for ( int i = 0 ; i < C ; i ++ ) { dfs ( input , " " , 0 , i , R , C ) ; System . out . println ( ) ; } } private static void dfs ( char [ ] [ ] input , String res , int i , int j , int R , int C ) { if ( i == R ) { System . out . print ( res + " ▁ " ) ; return ; } res = res + input [ i ] [ j ] ; for ( int k = 0 ; k < C ; k ++ ) { dfs ( input , res , i + 1 , k , R , C ) ; if ( i + 1 == R ) { break ; } } } public static void main ( String [ ] args ) { char [ ] [ ] input = { { ' a ' , ' b ' } , { ' d ' , ' e ' } } ; int R = input . length ; int C = input [ 0 ] . length ; printPaths ( input , R , C ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int num = Integer . parseInt ( sc . nextLine ( ) ) ; String line = sc . nextLine ( ) ; int [ ] hotel = new int [ 10 ] ; for ( int i = 0 ; i < num ; i ++ ) { char actual = line . charAt ( i ) ; if ( actual == ' L ' ) { boolean bb = true ; for ( int pos = 0 ; pos < 10 && bb == true ; pos ++ ) { if ( hotel [ pos ] == 0 ) { hotel [ pos ] = 1 ; bb = false ; } } } else { if ( actual == ' R ' ) { boolean bb = true ; for ( int pos = 9 ; pos >= 0 && bb == true ; pos -- ) { if ( hotel [ pos ] == 0 ) { hotel [ pos ] = 1 ; bb = false ; } } } else { int pos = Integer . parseInt ( actual + " " ) ; hotel [ pos ] = 0 ; } } } StringBuilder res = new StringBuilder ( ) ; for ( int x : hotel ) { res . append ( x ) ; } System . out . println ( res . toString ( ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; public class B_Square { public static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( " \n " ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader reader = new FastReader ( ) ; int T = reader . nextInt ( ) ; while ( T != 0 ) { T -- ; int a1 = reader . nextInt ( ) ; int b1 = reader . nextInt ( ) ; int a2 = reader . nextInt ( ) ; int b2 = reader . nextInt ( ) ; int [ ] r1 = new int [ ] { Math . min ( a1 , b1 ) , Math . max ( a1 , b1 ) } ; int [ ] r2 = new int [ ] { Math . min ( a2 , b2 ) , Math . max ( a2 , b2 ) } ; if ( r1 [ 0 ] == r2 [ 0 ] && r1 [ 1 ] + r2 [ 1 ] == r1 [ 0 ] ) { System . out . println ( " Yes " ) ; } else if ( r1 [ 1 ] == r2 [ 1 ] && r1 [ 0 ] + r2 [ 0 ] == r1 [ 1 ] ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } } }
import java . util . * ; class Eulerian { public static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { System . out . print ( " Infinite " ) ; return ; } if ( x == 0 ) { System . out . print ( "0" ) ; return ; } if ( n <= 0 ) { System . out . print ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { System . out . print ( " - " ) ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } int d = x / y ; for ( int i = 0 ; i <= n ; i ++ ) { System . out . print ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) System . out . print ( " . " ) ; } } public static void main ( String [ ] args ) { int x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ; System . out . println ( ) ; } }
import java . util . * ; public class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } static int minPerfectCube ( int arr [ ] , int n ) { int minPerfectCube ; int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . length ; System . out . println ( minPerfectCube ( arr , n ) ) ; } }
import java . util . * ; class Node { int data ; Node left , right ; public Node ( int data ) { this . data = data ; left = right = null ; } } public class BinaryTree { Node root ; void printSpecificLevelOrderUtil ( Node root , Stack < Node > s ) { if ( root == null ) return ; Queue < Node > q = new LinkedList < Node > ( ) ; q . add ( root . left ) ; q . add ( root . right ) ; Node first = null , second = null ; while ( ! q . isEmpty ( ) ) { first = q . peek ( ) ; q . poll ( ) ; second = q . peek ( ) ; q . poll ( ) ; s . push ( second . left ) ; s . push ( first . right ) ; s . push ( second . right ) ; s . push ( first . left ) ; if ( first . left . left != null ) { q . add ( first . right ) ; q . add ( second . left ) ; q . add ( first . left ) ; q . add ( second . right ) ; } } } void printSpecificLevelOrder ( Node root ) { Stack < Node > s = new Stack < Node > ( ) ; s . push ( root ) ; if ( root . left != null ) { s . push ( root . right ) ; s . push ( root . left ) ; } if ( root . left . left != null ) printSpecificLevelOrderUtil ( root , s ) ; while ( ! s . empty ( ) ) { System . out . print ( s . peek ( ) . data + " ▁ " ) ; s . pop ( ) ; } } public static void main ( String [ ] args ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 1 ) ; tree . root . left = new Node ( 2 ) ; tree . root . right = new Node ( 3 ) ; System . out . println ( " Specific ▁ Level ▁ Order ▁ Traversal ▁ of ▁ Binary ▁ Tree ▁ is " ) ; tree . printSpecificLevelOrder ( tree . root ) ; } }
public class GFG { static void hollowSquare ( int rows ) { int i , j ; for ( i = 1 ; i <= rows ; i ++ ) { if ( i == 1 || i == rows ) for ( j = 1 ; j <= rows ; j ++ ) System . out . print ( " * " ) ; else for ( j = 1 ; j <= rows ; j ++ ) if ( j == 1 || j == rows ) System . out . print ( " * " ) ; else System . out . print ( " ▁ " ) ; System . out . print ( " \n " ) ; } } static void solidSquare ( int rows ) { int i , j ; for ( i = 1 ; i <= rows ; i ++ ) { for ( j = 1 ; j <= rows ; j ++ ) System . out . print ( " * " ) ; System . out . print ( " \n " ) ; } } static void printPattern ( int rows ) { System . out . print ( " Solid ▁ Square : \n " ) ; solidSquare ( rows ) ; System . out . print ( " \n Hollow ▁ Square : \n " ) ; hollowSquare ( rows ) ; } public static void main ( String [ ] args ) { int rows = 5 ; printPattern ( rows ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; if ( n == 1 ) { System . out . println ( ' a ' ) ; } else if ( n == 2 ) { System . out . println ( " ab " ) ; } else if ( n == 3 ) { System . out . println ( " abc " ) ; } else { for ( int i = 0 ; i < n / 4 ; i ++ ) { System . out . print ( " abcd " ) ; } int t = n % 4 ; if ( t == 1 ) { System . out . println ( ' a ' ) ; } else if ( t == 2 ) { System . out . println ( " ab " ) ; } else if ( t == 3 ) { System . out . println ( " abc " ) ; } } } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int [ ] [ ] data = new int [ n + 1 ] [ 2 ] ; int maxLen = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { data [ i ] [ 0 ] = in . nextInt ( ) ; data [ i ] [ 1 ] = in . nextInt ( ) ; maxLen += data [ i ] [ 0 ] ; } in . close ( ) ; int [ ] dp = new int [ maxLen + 1 ] ; Arrays . fill ( dp , 10000 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = maxLen ; j >= data [ i ] [ 0 ] ; j -- ) { dp [ j ] = Math . min ( dp [ j ] , dp [ j - data [ i ] [ 0 ] ] + data [ i ] [ 1 ] ) ; } } for ( int i = maxLen ; i >= 0 ; i -- ) { if ( maxLen - i >= dp [ i ] ) { System . out . println ( maxLen - i ) ; return ; } } } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; if ( ( x < a ) || ( ( a + b ) < x ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } }
public class GFG { static int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 9 } ; int n = arr . length ; System . out . println ( findLargest ( arr , n ) ) ; } }
public class GFG { static void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; } else { System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } } public static void main ( String [ ] args ) { int n = 7 ; findWinner ( n ) ; } }
import java . io . * ; import java . util . * ; class Graph { private int V ; private LinkedList < Integer > adj [ ] ; Graph ( int v ) { V = v ; adj = new LinkedList [ v ] ; for ( int i = 0 ; i < v ; ++ i ) adj [ i ] = new LinkedList ( ) ; } void addEdge ( int v , int w ) { adj [ v ] . add ( w ) ; } void BFS ( int s ) { boolean visited [ ] = new boolean [ V ] ; LinkedList < Integer > queue = new LinkedList < Integer > ( ) ; visited [ s ] = true ; queue . add ( s ) ; while ( queue . size ( ) != 0 ) { s = queue . poll ( ) ; System . out . print ( s + " ▁ " ) ; Iterator < Integer > i = adj [ s ] . listIterator ( ) ; while ( i . hasNext ( ) ) { int n = i . next ( ) ; if ( ! visited [ n ] ) { visited [ n ] = true ; queue . add ( n ) ; } } } } public static void main ( String args [ ] ) { Graph g = new Graph ( 4 ) ; g . addEdge ( 0 , 1 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 1 , 2 ) ; g . addEdge ( 2 , 0 ) ; g . addEdge ( 2 , 3 ) ; g . addEdge ( 3 , 3 ) ; System . out . println ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ " + " ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; g . BFS ( 2 ) ; } }
import java . io . * ; import java . util . * ; class Graph { private int V ; private LinkedList < Integer > adj [ ] ; Graph ( int v ) { V = v ; adj = new LinkedList [ v ] ; for ( int i = 0 ; i < v ; ++ i ) adj [ i ] = new LinkedList ( ) ; } void addEdge ( int v , int w ) { adj [ v ] . add ( w ) ; } void BFS ( int s ) { boolean visited [ ] = new boolean [ V ] ; LinkedList < Integer > queue = new LinkedList < Integer > ( ) ; visited [ s ] = true ; queue . add ( s ) ; while ( queue . size ( ) != 0 ) { s = queue . poll ( ) ; System . out . print ( s + " ▁ " ) ; Iterator < Integer > i = adj [ s ] . listIterator ( ) ; while ( i . hasNext ( ) ) { int n = i . next ( ) ; if ( ! visited [ n ] ) { visited [ n ] = true ; queue . add ( n ) ; } } } } public static void main ( String args [ ] ) { Graph g = new Graph ( 4 ) ; g . addEdge ( 0 , 1 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 1 , 2 ) ; g . addEdge ( 2 , 0 ) ; g . addEdge ( 2 , 3 ) ; g . addEdge ( 3 , 3 ) ; System . out . println ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ " + " ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; g . BFS ( 2 ) ; } }
import java . io . * ; public class GFG { static void getElements ( int a , int arr [ ] , int n ) { int elements [ ] = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) System . out . print ( elements [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 2 , 6 , 1 } ; int n = arr . length ; int a = 5 ; getElements ( a , arr , n ) ; } }
import java . util . Scanner ; public class A { static Scanner sc = new Scanner ( System . in ) ; static char [ ] cs = { ' P ' , ' R ' , ' S ' } ; static String [ ] [ ] dp = new String [ 3 ] [ 13 ] ; public static void main ( String [ ] args ) { dp [ 0 ] [ 0 ] = " P " ; dp [ 1 ] [ 0 ] = " R " ; dp [ 2 ] [ 0 ] = " S " ; for ( int i = 1 ; i < dp [ 0 ] . length ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { dp [ j ] [ i ] = dp [ j ] [ i - 1 ] + dp [ ( j + 1 ) % 3 ] [ i - 1 ] ; String o = dp [ ( j + 1 ) % 3 ] [ i - 1 ] + dp [ j ] [ i - 1 ] ; if ( o . compareTo ( dp [ j ] [ i ] ) < 0 ) dp [ j ] [ i ] = o ; } } int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( " Case ▁ # " + i + " : ▁ " ) ; System . out . println ( solve ( ) ) ; } } static String solve ( ) { int N = sc . nextInt ( ) ; int R = sc . nextInt ( ) ; int P = sc . nextInt ( ) ; int S = sc . nextInt ( ) ; String ret = null ; for ( int i = 0 ; i < 3 ; ++ i ) { int [ ] c = new int [ 3 ] ; for ( char ch : dp [ i ] [ N ] . toCharArray ( ) ) { if ( ch == ' P ' ) c [ 0 ] ++ ; if ( ch == ' R ' ) c [ 1 ] ++ ; if ( ch == ' S ' ) c [ 2 ] ++ ; } if ( c [ 0 ] == P && c [ 1 ] == R && c [ 2 ] == S ) { ret = dp [ i ] [ N ] ; } } return ret == null ? " IMPOSSIBLE " : ret ; } }
import java . util . Scanner ; public class _30_Chips { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int n = scn . nextInt ( ) ; int k = scn . nextInt ( ) ; boolean [ ] row = new boolean [ n ] ; boolean [ ] col = new boolean [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { int val = scn . nextInt ( ) ; int val2 = scn . nextInt ( ) ; row [ val - 1 ] = true ; col [ val2 - 1 ] = true ; } long ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( n % 2 == 1 && i == n / 2 ) { if ( ! row [ i ] || ! col [ i ] ) { ans ++ ; } } else if ( ! row [ i ] || ! col [ i ] ) { ans = ans + ( ( ! row [ i ] && ! col [ i ] ) ? 2 : 1 ) ; } } System . out . println ( ans ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; System . out . print ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) ; System . out . print ( x + " ▁ & ▁ " + y ) ; System . out . println ( ) ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
import java . util . * ; public class Main { static int count = 1 ; static boolean [ ] isPrime = new boolean [ 10001 ] ; static int [ ] primes = new int [ 100000 ] ; static int [ ] sum = new int [ 100000 ] ; static { Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 0 ; i * i <= isPrime . length ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i + i ; j < isPrime . length ; j += i ) { isPrime [ j ] = false ; } } } for ( int i = 0 ; i < isPrime . length ; i ++ ) { if ( isPrime [ i ] ) { primes [ count ] = i ; sum [ count ] = sum [ count - 1 ] + primes [ count ] ; count ++ ; } } } public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; while ( true ) { int n = cin . nextInt ( ) ; int cnt = 0 ; if ( n == 0 ) { break ; } for ( int i = 0 ; i < count ; i ++ ) { for ( int j = i + 1 ; j < count ; j ++ ) { if ( sum [ j ] - sum [ i ] == n ) { cnt ++ ; } } } System . out . println ( cnt ) ; } } }
import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; double [ ] x = new double [ n ] ; double [ ] y = new double [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { x [ i ] = sc . nextDouble ( ) ; y [ i ] = sc . nextDouble ( ) ; } for ( int i = 0 ; i < n ; ++ i ) { double [ ] deg = new double [ n - 1 ] ; int cnt = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( i == j ) continue ; deg [ cnt ++ ] = ( Math . atan2 ( y [ j ] - y [ i ] , x [ j ] - x [ i ] ) ) ; } Arrays . sort ( deg ) ; double ans = 0 ; for ( int j = 0 ; j < n - 2 ; ++ j ) { ans = Math . max ( ans , deg [ ( j + 1 ) % ( n - 1 ) ] - deg [ j ] ) ; } ans = Math . max ( ans , Math . PI * 2 + deg [ 0 ] - deg [ n - 2 ] ) ; ans = ans - Math . PI ; if ( ans <= 0 ) System . out . println ( 0 ) ; else System . out . println ( String . format ( " % .20f " , ans / ( 2 * Math . PI ) ) ) ; } } void tr ( Object ... objects ) { System . out . println ( Arrays . deepToString ( objects ) ) ; } }
import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) { BufferedReader sc = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String st ; try { while ( true ) { st = sc . readLine ( ) ; if ( st . equals ( " # " ) ) break ; char [ ] c = st . toCharArray ( ) ; int count = 0 , t = check ( c [ 0 ] ) ; for ( int i = 1 ; i < c . length ; i ++ ) if ( t != check ( c [ i ] ) ) { count ++ ; t = check ( c [ i ] ) ; } System . out . println ( count ) ; } } catch ( Exception e ) { System . out . println ( " Error " ) ; } } private static int check ( char c ) { if ( c == ' q ' || c == ' w ' || c == ' e ' || c == ' r ' || c == ' t ' || c == ' a ' || c == ' s ' || c == ' d ' || c == ' f ' || c == ' g ' || c == ' z ' || c == ' x ' || c == ' c ' || c == ' v ' || c == ' b ' ) return 1 ; else return 2 ; } }
import java . util . * ; public class Solution { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String str = sc . next ( ) ; int S = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) == ' S ' && str . charAt ( i + 1 ) == ' F ' ) S ++ ; else if ( str . charAt ( i ) == ' F ' && str . charAt ( i + 1 ) == ' S ' ) S -- ; } if ( S > 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Scanner ; public class test247 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int n = in . nextInt ( ) ; long a [ ] = new long [ n ] ; long max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextLong ( ) ; } if ( n == 2 ) { max = a [ 0 ] * a [ 1 ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { if ( a [ i ] * a [ i - 1 ] > max ) { max = a [ i ] * a [ i - 1 ] ; } } else { if ( a [ i ] * a [ i + 1 ] > max ) { max = a [ i ] * a [ i + 1 ] ; } } } System . out . println ( max ) ; } in . close ( ) ; } }
import java . math . BigInteger ; class Test { static int FindLCM ( int a , int b ) { return ( a * b ) / new BigInteger ( a + " " ) . gcd ( new BigInteger ( b + " " ) ) . intValue ( ) ; } static int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ; int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; } public static void main ( String args [ ] ) { int m = 3 , n = 11 , a = 2 , b = 3 ; System . out . println ( rangeDivisor ( m , n , a , b ) ) ; m = 11 ; n = 1000000 ; a = 6 ; b = 35 ; System . out . println ( rangeDivisor ( m , n , a , b ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; public class Punctuation { public static boolean isLatinLetter ( char c ) { return c >= ' a ' && c <= ' z ' ; } public static boolean isPunctuation ( char c ) { if ( c == ' . ' ) return true ; if ( c == ' , ' ) return true ; if ( c == ' ! ' ) return true ; if ( c == ' ? ' ) return true ; return false ; } public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; String s = br . readLine ( ) ; StringBuilder sb = new StringBuilder ( ) ; int n = s . length ( ) ; sb . append ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { char c = s . charAt ( i ) ; if ( isLatinLetter ( c ) ) { if ( ! isLatinLetter ( s . charAt ( i - 1 ) ) ) { sb . append ( ' ▁ ' ) ; } sb . append ( c ) ; } else if ( isPunctuation ( c ) ) { sb . append ( c ) ; } } pw . println ( sb ) ; pw . flush ( ) ; pw . close ( ) ; } }
import java . util . * ; public class GFG { public static int smallestKFreq ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ; else m . put ( a [ i ] , 1 ) ; int res = Integer . MAX_VALUE ; Set < Integer > s = m . keySet ( ) ; for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ; return ( res != Integer . MAX_VALUE ) ? res : - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; System . out . println ( smallestKFreq ( arr , arr . length , k ) ) ; } }
import java . io . * ; public class GFG { static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' || s . charAt ( i ) == ' e ' || s . charAt ( i ) == ' i ' || s . charAt ( i ) == ' o ' || s . charAt ( i ) == ' u ' ) { if ( s . charAt ( i ) < c ) return false ; else { c = s . charAt ( i ) ; } } } return true ; } public static void main ( String [ ] args ) { String s = " aabbbddeecc " ; if ( areVowelsInOrder ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { static int N , min , cnt ; static int [ ] a = new int [ 180 ] ; static int [ ] b = new int [ 45 ] ; static int [ ] alreadyA ; static int [ ] alreadyB ; static { int cnt = 0 ; for ( int i = 1 ; tetrahedral ( i ) <= 1000000 ; i ++ ) { int t = tetrahedral ( i ) ; a [ cnt ++ ] = t ; } for ( int i = 0 ; i < a . length ; i ++ ) { } alreadyA = new int [ 1000000 ] ; alreadyB = new int [ 1000000 ] ; cnt = 0 ; for ( int i = 1 ; tetrahedral ( i ) <= 1000000 ; i ++ ) { int t = tetrahedral ( i ) ; if ( t % 2 == 1 ) { b [ cnt ++ ] = t ; } } } public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; Arrays . fill ( alreadyA , 0 ) ; Arrays . fill ( alreadyB , 0 ) ; a ( ) ; while ( true ) { N = cin . nextInt ( ) ; if ( N == 0 ) { break ; } cnt = 0 ; min = Integer . MAX_VALUE ; System . out . print ( alreadyA [ N ] ) ; System . out . println ( " ▁ " + alreadyB [ N ] ) ; } } static void a ( ) { for ( int i = 1 ; i < 1000000 ; i ++ ) { int mina = Integer . MAX_VALUE ; int minb = Integer . MAX_VALUE ; int x = 0 , y = 0 ; for ( int j = 0 ; j < 180 && a [ j ] <= i ; j ++ ) { mina = Math . min ( 1 + alreadyA [ i - a [ j ] ] , mina ) ; if ( a [ j ] % 2 == 1 ) { minb = Math . min ( 1 + alreadyB [ i - a [ j ] ] , minb ) ; } } alreadyA [ i ] = mina ; alreadyB [ i ] = minb ; } } static int tetrahedral ( int a ) { return ( a * ( a + 1 ) * ( a + 2 ) ) / 6 ; } }
public class GFG { static int countOfLetters ( String str ) { int letter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) letter ++ ; } return letter ; } static int countOfNumbers ( String str ) { int number = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) number ++ ; } return number ; } static void check ( String str ) { if ( countOfLetters ( str ) == countOfNumbers ( str ) ) System . out . print ( " Yes \n " ) ; else System . out . print ( " No \n " ) ; } public static void main ( String [ ] args ) { String str = " GeeKs01324" ; check ( str ) ; } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int [ ] box = new int [ 10 ] ; int i = 0 ; while ( scan . hasNext ( ) ) { int n = scan . nextInt ( ) ; if ( n == 0 ) { i -- ; System . out . println ( box [ i ] ) ; } else { box [ i ] = n ; i ++ ; } } } }
import java . util . ArrayDeque ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { int N = sc . nextInt ( ) , x = sc . nextInt ( ) ; if ( x == 1 || x == 2 * N - 1 ) { System . out . println ( " No " ) ; break ; } System . out . println ( " Yes " ) ; int low = x - 1 , high = x + 1 ; ArrayDeque < Integer > deq = new ArrayDeque < Integer > ( ) ; deq . add ( x ) ; while ( low != 0 || high != 2 * N ) { if ( low == 0 ) { deq . push ( high ) ; deq . add ( high + 1 ) ; high += 2 ; } else if ( high == 2 * N ) { deq . add ( low ) ; deq . push ( low - 1 ) ; low -= 2 ; } else { deq . push ( low ) ; low -- ; deq . add ( high ) ; high ++ ; } } for ( int s : deq ) System . out . println ( s ) ; } } }
public class GFG { static int MAX = 100001 ; static int [ ] perfectDiv = new int [ MAX ] ; static void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } } static int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; } public static void main ( String [ ] args ) { precomputeCounts ( ) ; int n = 16 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; n = 12 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; long nn = 0 ; for ( int i = 0 ; i < n ; i ++ ) { nn += sc . nextInt ( ) ; } long mm = 0 ; for ( int i = 0 ; i < m ; i ++ ) { mm += sc . nextInt ( ) ; } System . out . println ( nn * mm ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { int check = x [ i ] * ( ( t + e ) / x [ i ] ) ; if ( check <= t + e && check >= t - e ) { System . out . println ( ( i + 1 ) ) ; return ; } } System . out . println ( - 1 ) ; } }
import java . math . * ; public class GFG { public static void cal_IST ( int h , double r ) { double IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ( int ) Math . ceil ( ( int ) ( ( IST - int_IST ) * 60 ) ) ; System . out . println ( int_IST + " : " + float_IST ) ; } public static void main ( String [ ] args ) { int h = 20 ; double r = 150 ; cal_IST ( h , r ) ; } }
import java . io . * ; public class GFG { static void printRoots ( int n ) { double theta = Math . PI * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . print ( String . format ( " % . 3 f " , real ) ) ; if ( img >= 0 ) System . out . print ( " ▁ + ▁ i ▁ " ) ; else System . out . print ( " ▁ - ▁ i ▁ " ) ; System . out . println ( String . format ( " % . 3 f " , Math . abs ( img ) ) ) ; } } public static void main ( String [ ] args ) { printRoots ( 1 ) ; printRoots ( 2 ) ; printRoots ( 3 ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void findCart ( int arr1 [ ] , int arr2 [ ] , int n , int n1 ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n1 ; j ++ ) System . out . print ( " { " + arr1 [ i ] + " , ▁ " + arr2 [ j ] + " } , ▁ " ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 4 , 5 , 6 } ; int n1 = arr1 . length ; int n2 = arr2 . length ; findCart ( arr1 , arr2 , n1 , n2 ) ; } }
import java . util . * ; class solution { static int no_of_ways ( String s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s . charAt ( i ) == s . charAt ( 0 ) ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == s . charAt ( n - 1 ) ) { ++ count_right ; } else break ; } if ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } public static void main ( String args [ ] ) { String s = " geeksforgeeks " ; System . out . println ( no_of_ways ( s ) ) ; } }
public class GFG { static int MAX = 1000000 ; static boolean prime [ ] = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } } } static void SumOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; int n = arr . length ; int k = 2 ; SumOfKthPrimes ( arr , n , k ) ; } }
public class GFG { static final int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static void solve ( int [ ] arr , int n , int k ) { int c = 0 ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 5 , k = 2 ; int [ ] arr = { 2 , 3 , 5 , 7 , 11 } ; solve ( arr , n , k ) ; } }
public class GFG { static int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { prime [ 1 ] = true ; prime [ 0 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } } static void productOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { product *= arr [ i ] ; c = 0 ; } } } System . out . println ( product ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 5 , k = 2 ; int [ ] arr = new int [ ] { 2 , 3 , 5 , 7 , 11 } ; productOfKthPrimes ( arr , n , k ) ; } }
import java . io . * ; import java . util . * ; class MinSwaps { static void findAllSequences ( int diff , char out [ ] , int start , int end ) { if ( Math . abs ( diff ) > ( end - start + 1 ) / 2 ) return ; if ( start > end ) { if ( diff == 0 ) { System . out . print ( new String ( out , 0 , out . length - 1 ) ) ; System . out . print ( " ▁ " ) ; } return ; } out [ start ] = '0' ; out [ end ] = '1' ; findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '1' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = '1' ; out [ end ] = '0' ; findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; char [ ] out = new char [ 2 * n + 1 ] ; out [ 2 * n ] = ' \0 ' ; findAllSequences ( 0 , out , 0 , 2 * n - 1 ) ; System . out . println ( " " ) ; } }
import java . util . * ; public class NarrowFridge { private static Scanner s = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = s . nextInt ( ) , h = s . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = s . nextInt ( ) ; PriorityQueue < Integer > overAllPq = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { overAllPq . add ( arr [ i ] ) ; PriorityQueue < Integer > pq = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; pq . addAll ( overAllPq ) ; int c1 = h , c2 = h ; boolean flag = true ; while ( ! pq . isEmpty ( ) ) { if ( flag ) { if ( c1 >= pq . peek ( ) ) { c1 -= pq . poll ( ) ; } else { break ; } flag = false ; } else { if ( c2 >= pq . peek ( ) ) { c2 -= pq . poll ( ) ; } else { break ; } flag = true ; } } if ( pq . isEmpty ( ) ) { ans = i + 1 ; } else { break ; } } System . out . println ( ans ) ; s . close ( ) ; } }
public class GFG { static class Node { int data ; Node next ; Node ( int data ) { this . data = data ; this . next = null ; } } static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ - > ▁ " ) ; node = node . next ; } System . out . println ( " NULL " ) ; } static int cntNodes ( Node node ) { if ( node == null ) return 0 ; return ( 1 + cntNodes ( node . next ) ) ; } static void updateList ( Node head , int m ) { int cnt = cntNodes ( head ) ; if ( cnt != m && m < cnt ) { int skip = cnt - m ; Node prev = null ; Node curr = head ; while ( skip > 0 ) { prev = curr ; curr = curr . next ; skip -- ; } prev . next = null ; Node tempHead = head ; head = curr ; while ( curr . next != null ) curr = curr . next ; curr . next = tempHead ; } printList ( head ) ; } public static void main ( String [ ] args ) { Node head = new Node ( 4 ) ; head . next = new Node ( 5 ) ; head . next . next = new Node ( 6 ) ; head . next . next . next = new Node ( 1 ) ; head . next . next . next . next = new Node ( 2 ) ; head . next . next . next . next . next = new Node ( 3 ) ; int m = 3 ; updateList ( head , m ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; } public static void main ( String [ ] args ) { String s = " aaacaabbaa " ; int k = 2 ; System . out . println ( maxSubStrings ( s , k ) ) ; } }
import java . util . * ; public class GFG { static void ansQueries ( int prefeven [ ] , int prefodd [ ] , int l , int r ) { if ( ( r - l + 1 ) % 2 == 0 ) System . out . println ( "0" ) ; else { if ( l % 2 == 0 ) System . out . println ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; else System . out . println ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } } static void wrapper ( int arr [ ] , int n , int l [ ] , int r [ ] , int q ) { int prefodd [ ] = new int [ 100 ] ; int prefeven [ ] = new int [ 100 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int i = 0 ; while ( i != q ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int l [ ] = { 1 , 1 , 2 } ; int r [ ] = { 2 , 3 , 4 } ; int q = l . length ; wrapper ( arr , n , l , r , q ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; Long [ ] ans = new Long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = in . nextLong ( ) ; } Arrays . sort ( ans ) ; Long count = ans [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( ans [ i ] < ans [ i + 1 ] ) { count += ans [ i ] ; } else { while ( ans [ i ] >= ans [ i + 1 ] ) { ans [ i ] -- ; } if ( ans [ i ] > 0 ) { count += ans [ i ] ; } } } System . out . println ( count ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader reader = new FastReader ( ) ; int num = reader . nextInt ( ) ; while ( num -- > 0 ) { int n = reader . nextInt ( ) ; int k = reader . nextInt ( ) ; long arr [ ] = new long [ n * k ] ; for ( int i = 0 ; i < n * k ; i ++ ) { arr [ i ] = reader . nextLong ( ) ; } long sum = 0 ; int skip = 0 ; int start = k * n ; if ( n % 2 == 0 ) { skip = n / 2 ; for ( int i = 1 ; i <= k ; i ++ ) { sum += arr [ start - skip - 1 ] ; start = start - skip - 1 ; } } else { skip = n / 2 + 1 ; for ( int i = 1 ; i <= k ; i ++ ) { sum += arr [ start - skip ] ; start = start - skip ; } } System . out . println ( sum ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; Map < Integer , Deque < Long > > Stack = new HashMap < > ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Deque < Long > L = new ArrayDeque < > ( ) ; Stack . put ( i , L ) ; } for ( int i = 0 ; i < q ; i ++ ) { int cmd = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; if ( cmd == 0 ) Stack . get ( t ) . push ( sc . nextLong ( ) ) ; else if ( cmd == 1 && Stack . get ( t ) . size ( ) != 0 ) sb . append ( Stack . get ( t ) . getFirst ( ) + " \n " ) ; else if ( cmd == 2 && Stack . get ( t ) . size ( ) != 0 ) Stack . get ( t ) . pop ( ) ; } System . out . print ( sb ) ; } }
public class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void removeMin ( int arr [ ] , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; } static void removeFromMax ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } static void modifyArray ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; int k = 2 ; modifyArray ( arr , n , k ) ; } }
public class GFG { static double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; } public static void main ( String [ ] args ) { double vp [ ] [ ] = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; double [ ] ans = find_Centroid ( vp ) ; System . out . println ( String . format ( " % . 3 f " , ans [ 0 ] ) + " ▁ " + String . format ( " % . 3 f " , ans [ 1 ] ) ) ; } }
import java . util . Scanner ; public class App { public static void main ( String [ ] args ) { String color = " blue " ; boolean locked = false ; Scanner in = new Scanner ( System . in ) ; final int lines = in . nextInt ( ) ; for ( int i = 0 ; i < lines ; i ++ ) { final String next = in . next ( ) ; if ( " lock " == next . intern ( ) ) { locked = true ; continue ; } if ( " unlock " == next . intern ( ) ) { locked = false ; continue ; } if ( locked ) { continue ; } color = next ; } System . out . println ( color ) ; } }
import java . util . Arrays ; class geeksforgeeks { static int minOperations ( int ar [ ] , int k ) { Arrays . sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 9 , 100 } ; int n = arr . length ; int k = 3 ; System . out . println ( minOperations ( arr , k ) ) ; } }
import java . io . * ; public class GFG { static void charCheck ( char input_char ) { if ( ( input_char >= 65 && input_char <= 90 ) || ( input_char >= 97 && input_char <= 122 ) ) System . out . println ( " ▁ Alphabet ▁ " ) ; else if ( input_char >= 48 && input_char <= 57 ) System . out . println ( " ▁ Digit ▁ " ) ; else System . out . println ( " ▁ Special ▁ Character ▁ " ) ; } public static void main ( String [ ] args ) { char input_char = ' $ ' ; charCheck ( input_char ) ; } }
import java . util . * ; public class Practice2 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) list . add ( sc . nextInt ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; map . put ( i + 1 , 1 ) ; int flag = 0 ; int j = i ; while ( flag == 0 ) { if ( ! map . containsKey ( list . get ( j ) ) ) map . put ( list . get ( j ) , 1 ) ; else { flag = 1 ; System . out . print ( list . get ( j ) + " ▁ " ) ; } j = list . get ( j ) ; j -- ; } } } }
import java . util . * ; public class zer { static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int [ ] p = new int [ n ] ; List < Set < Integer > > tab = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = in . nextInt ( ) ; tab . add ( new HashSet < > ( ) ) ; } int ans = 3000003 ; for ( int i = 0 ; i < m ; i ++ ) { int a = in . nextInt ( ) - 1 ; int b = in . nextInt ( ) - 1 ; for ( int x : tab . get ( a ) ) { if ( tab . get ( b ) . contains ( x ) ) { ans = Math . min ( p [ a ] + p [ b ] + p [ x ] , ans ) ; } } tab . get ( a ) . add ( b ) ; tab . get ( b ) . add ( a ) ; } if ( ans == 3000003 ) System . out . println ( - 1 ) ; else System . out . println ( ans ) ; } }
import java . io . * ; import java . util . * ; public class CF67B extends PrintWriter { CF67B ( ) { super ( System . out , true ) ; } Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] $ ) { CF67B o = new CF67B ( ) ; o . main ( ) ; o . flush ( ) ; } void main ( ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] bb = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) bb [ i ] = sc . nextInt ( ) ; int [ ] aa = new int [ n ] ; int m = 0 ; for ( int a = n - 1 ; a >= 0 ; a -- ) { int j = 0 ; while ( bb [ a ] > 0 ) { if ( aa [ j ] >= a + k ) bb [ a ] -- ; j ++ ; } for ( int j_ = m ++ ; j_ > j ; j_ -- ) aa [ j_ ] = aa [ j_ - 1 ] ; aa [ j ] = a ; } for ( int i = 0 ; i < n ; i ++ ) print ( aa [ i ] + 1 + " ▁ " ) ; println ( ) ; } }
import java . util . * ; import java . util . stream . Collectors ; public class B147 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] c = new int [ n ] ; int [ ] [ ] table = new int [ 50 ] [ 50 ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = scanner . nextInt ( ) ; } Map < Integer , Point > map = new HashMap < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= c [ i - 1 ] ; j ++ ) { int cell = scanner . nextInt ( ) ; map . put ( cell , new Point ( i , j ) ) ; table [ i - 1 ] [ j - 1 ] = cell ; } } int cnt = 0 ; int m = 0 ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < c [ i ] ; j ++ ) { cnt ++ ; if ( table [ i ] [ j ] == cnt ) continue ; sb . append ( i + 1 ) . append ( " ▁ " ) ; sb . append ( j + 1 ) . append ( " ▁ " ) ; Point point = map . get ( cnt ) ; sb . append ( point . x ) . append ( " ▁ " ) ; sb . append ( point . y ) . append ( " \n " ) ; int tmp = table [ i ] [ j ] ; table [ i ] [ j ] = table [ point . x - 1 ] [ point . y - 1 ] ; table [ point . x - 1 ] [ point . y - 1 ] = tmp ; map . put ( tmp , point ) ; m ++ ; } } System . out . println ( m ) ; String s = sb . toString ( ) ; if ( m > 0 ) System . out . println ( s ) ; } } class Point { int x ; int y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } }
import java . util . * ; class solution { static int sameOccurrence ( int arr [ ] , int n , int x , int y ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int ctX = 0 , ctY = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { if ( arr [ j ] == x ) ctX += 1 ; else if ( arr [ j ] == y ) ctY += 1 ; if ( ctX == ctY ) result += 1 ; } } return ( result ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = arr . length ; int x = 2 , y = 3 ; System . out . println ( sameOccurrence ( arr , n , x , y ) ) ; } }
import java . util . Scanner ; public class test251 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { char [ ] a = in . next ( ) . toCharArray ( ) ; if ( a . length >= 3 ) { int z = 0 , o = 0 ; for ( int j = 0 ; j < a . length ; j ++ ) { if ( a [ j ] == '1' ) { o ++ ; } else { z ++ ; } } if ( z > o ) { System . out . println ( o ) ; } else if ( o > z ) { System . out . println ( z ) ; } else { System . out . println ( z - 1 ) ; } } else { System . out . println ( 0 ) ; } } in . close ( ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ; public class Coder { static StringBuffer str = new StringBuffer ( ) ; static int n ; static int a [ ] ; static String solve ( ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( a [ i ] , mx ) ; Map < Integer , Integer > cnt = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cnt . put ( a [ i ] , cnt . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } if ( cnt . get ( mx ) % 2 != 0 ) return " Conan \n " ; else if ( cnt . get ( mx ) == n ) return " Agasa \n " ; else { for ( Map . Entry < Integer , Integer > me : cnt . entrySet ( ) ) { if ( me . getValue ( ) % 2 != 0 ) return " Conan \n " ; } return " Agasa \n " ; } } public static void main ( String [ ] args ) throws java . lang . Exception { BufferedReader bf ; PrintWriter pw ; boolean lenv = false ; if ( lenv ) { bf = new BufferedReader ( new FileReader ( " input . txt " ) ) ; pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( " output . txt " ) ) ) ; } else { bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; pw = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; } String s [ ] = bf . readLine ( ) . trim ( ) . split ( " \\ s + " ) ; n = Integer . parseInt ( s [ 0 ] ) ; a = new int [ n ] ; s = bf . readLine ( ) . trim ( ) . split ( " \\ s + " ) ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Integer . parseInt ( s [ i ] ) ; str . append ( solve ( ) ) . append ( " \n " ) ; pw . print ( str ) ; pw . flush ( ) ; } }
import java . util . * ; public class GFG { public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int i ; for ( i = 0 ; i < 5 ; i ++ ) System . out . printf ( " % d ▁ " , a [ i ] ) ; } }
public class GFG { public static void main ( String [ ] args ) { int target = 93 ; int [ ] arr = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = arr . length ; int totalCount = 0 ; for ( int i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { int toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( int k = j + 1 ; k < length ; k ++ ) { if ( arr [ k ] == toFind ) { totalCount ++ ; } } } } } } System . out . println ( " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " + totalCount ) ; } }
import java . util . * ; import java . io . * ; public class Multiples_Of_Length { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader t = new FastReader ( ) ; PrintWriter o = new PrintWriter ( System . out ) ; int n = t . nextInt ( ) ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; ++ i ) a [ i ] = t . nextLong ( ) ; if ( n == 1 ) { o . println ( "1 ▁ 1" ) ; o . println ( - a [ 0 ] ) ; o . println ( "1 ▁ 1" ) ; o . println ( "0" ) ; o . println ( "1 ▁ 1" ) ; o . println ( "0" ) ; } else { o . println ( "1 ▁ 1" ) ; o . println ( - a [ 0 ] ) ; o . println ( "1 ▁ " + n ) ; a [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) o . print ( - n * a [ i ] + " ▁ " ) ; o . println ( " \n 2 ▁ " + n ) ; for ( int i = 1 ; i < n ; ++ i ) o . print ( ( n - 1 ) * a [ i ] + " ▁ " ) ; } o . flush ( ) ; o . close ( ) ; } }
public class GFG { static int finalNum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 9 , 6 , 36 } ; int n = arr . length ; System . out . println ( finalNum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int N = 1000 ; static int lastElement ( int a [ ] , int n ) { int steps = 1 ; Vector < Integer > [ ] v = new Vector [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . add ( a [ i ] | a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . add ( v [ steps - 1 ] . get ( i ) | v [ steps - 1 ] . get ( i + 1 ) ) ; else v [ steps ] . add ( v [ steps - 1 ] . get ( i ) ^ v [ steps - 1 ] . get ( i + 1 ) ) ; } } return v [ steps ] . get ( 0 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 5 , 6 } ; int n = a . length ; int index = 0 ; int value = 2 ; a [ 0 ] = 2 ; System . out . println ( lastElement ( a , n ) ) ; index = 3 ; value = 5 ; a [ index ] = value ; System . out . println ( lastElement ( a , n ) ) ; } }
import java . io . * ; public class GFG { static int number_cake ( int n ) { return ( n * n * n + 5 * n + 6 ) / 6 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( number_cake ( n ) ) ; n = 8 ; System . out . println ( number_cake ( n ) ) ; n = 25 ; System . out . println ( number_cake ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char [ ] input = sc . next ( ) . toCharArray ( ) ; int result = 0 ; int p = 0 ; int g = 1 ; for ( int i = 1 ; i < input . length ; i ++ ) { if ( input [ i ] == ' g ' ) { if ( p + 1 <= g ) { result ++ ; p ++ ; } else { g ++ ; } } else { if ( p + 1 <= g ) { p ++ ; } else { g ++ ; result -- ; } } } System . out . println ( result ) ; } }
import java . util . * ; class solution { static void pattern ( int N ) { int i , j , k = 0 , space = 1 , rows = N ; for ( i = rows ; i >= 1 ; i -- ) { for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( " * " ) ; } if ( i != rows ) { for ( k = 1 ; k <= space ; k ++ ) { System . out . print ( " ▁ " ) ; } space = space + 2 ; } for ( j = i ; j >= 1 ; j -- ) { if ( j != rows ) System . out . print ( " * " ) ; } System . out . print ( " \n " ) ; } System . out . print ( " \n " ) ; } public static void main ( String args [ ] ) { int N = 6 ; pattern ( N ) ; } }
import java . util . * ; public class GFG { static int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; } public static void main ( String args [ ] ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr ) ) ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr1 ) ) ; } }
import java . util . * ; class TreeNode { public int val ; public TreeNode left ; public TreeNode right ; public TreeNode ( int rootData ) { this . val = rootData ; this . left = null ; this . right = null ; } } public class Solution { private int result ; private HashMap < Integer , Integer > cache ; public int pathSum ( TreeNode root , int sum ) { result = 0 ; cache = new HashMap < Integer , Integer > ( ) ; cache . put ( 0 , 1 ) ; pathSumHelper ( root , sum , 0 ) ; return result ; } private void pathSumHelper ( TreeNode root , int target , int soFar ) { if ( root != null ) { int complement = soFar + root . val - target ; if ( cache . containsKey ( complement ) ) result += cache . get ( complement ) ; cache . put ( soFar + root . val , cache . getOrDefault ( soFar + root . val , 0 ) + 1 ) ; pathSumHelper ( root . left , target , soFar + root . val ) ; pathSumHelper ( root . right , target , soFar + root . val ) ; cache . put ( soFar + root . val , cache . get ( soFar + root . val ) - 1 ) ; } } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; TreeNode tree = new TreeNode ( 10 ) ; tree . left = new TreeNode ( 5 ) ; tree . right = new TreeNode ( - 3 ) ; tree . left . left = new TreeNode ( 3 ) ; tree . left . right = new TreeNode ( 2 ) ; tree . right . right = new TreeNode ( 11 ) ; tree . left . left . left = new TreeNode ( 3 ) ; tree . left . left . right = new TreeNode ( - 2 ) ; tree . left . right . right = new TreeNode ( 1 ) ; int sum = 8 ; int out = sObj . pathSum ( tree , sum ) ; System . out . println ( out ) ; } }
import java . util . * ; public class GFG { static void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . println ( Math . min ( s , x ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = arr . length ; getmax ( arr , arr_size , x ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . println ( " Case ▁ " + i + " : " ) ; msm ( scan . nextInt ( ) , 1 ) ; } } public static void msm ( int n , int c ) { if ( c == 11 ) return ; String str = Integer . toString ( n * n ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < 8 - str . length ( ) ; i ++ ) sb . append ( 0 ) ; sb . append ( str ) ; str = sb . toString ( ) . substring ( 2 , 6 ) ; int out = Integer . parseInt ( str ) ; System . out . println ( out ) ; msm ( out , c + 1 ) ; return ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; boolean [ ] sosu = new boolean [ 123456 * 2 + 1 ] ; Arrays . fill ( sosu , true ) ; sosu [ 0 ] = false ; sosu [ 1 ] = false ; for ( int i = 2 ; i < 123456 * 2 ; i ++ ) { if ( sosu [ i ] ) { for ( int j = 2 ; i * j < 123456 * 2 + 1 ; j ++ ) { sosu [ i * j ] = false ; } } } while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int count = 0 ; for ( int i = n + 1 ; i < n * 2 + 1 ; i ++ ) { if ( sosu [ i ] ) { count ++ ; } else { continue ; } } System . out . println ( count ) ; } } }
public class GFG { static int maxOR ( int arr [ ] , int n ) { int maxVal = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { maxVal = Math . max ( maxVal , arr [ i ] | arr [ j ] ) ; } return maxVal ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; System . out . println ( maxOR ( arr , n ) ) ; } }
import java . util . HashSet ; class Solution { public int numJewelsInStones ( String J , String S ) { int result = 0 ; HashSet jHash = new HashSet < > ( ) ; for ( int j = 0 ; j < J . length ( ) ; j ++ ) { jHash . add ( J . charAt ( j ) ) ; } for ( int s = 0 ; s < S . length ( ) ; s ++ ) { if ( jHash . contains ( S . charAt ( s ) ) ) { result ++ ; } } return result ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String J = " aA " ; String S = " aAAbbbb " ; int out = sObj . numJewelsInStones ( J , S ) ; System . out . println ( out ) ; } }
import java . util . * ; public class GFG { static int MAX = 100 , n ; static int [ ] store = new int [ MAX ] ; static int [ ] [ ] graph = new int [ MAX ] [ MAX ] ; static int [ ] d = new int [ MAX ] ; static boolean is_clique ( int b ) { for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) return false ; } return true ; } static int maxCliques ( int i , int l ) { int max_ = 0 ; for ( int j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { max_ = Math . max ( max_ , l ) ; max_ = Math . max ( max_ , maxCliques ( j , l + 1 ) ) ; } } return max_ ; } public static void main ( String [ ] args ) { int [ ] [ ] edges = { { 1 , 2 } , { 2 , 3 } , { 3 , 1 } , { 4 , 3 } , { 4 , 1 } , { 4 , 2 } } ; int size = edges . length ; n = 4 ; for ( int i = 0 ; i < size ; i ++ ) { graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; d [ edges [ i ] [ 0 ] ] ++ ; d [ edges [ i ] [ 1 ] ] ++ ; } System . out . println ( maxCliques ( 0 , 1 ) ) ; } }
public class GFG { static int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) ( Math . pow ( 2 , k ) ) ; } public static void main ( String arg [ ] ) { int n = 273 ; System . out . println ( setBitNumber ( n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . HashMap ; public class XeniaAndSpies { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String input [ ] = reader . readLine ( ) . split ( " ▁ " ) ; int m = Integer . parseInt ( input [ 1 ] ) ; int s = Integer . parseInt ( input [ 2 ] ) ; int f = Integer . parseInt ( input [ 3 ] ) ; int maxT = - 1 ; HashMap < Integer , ArrayList < Integer > > map = new HashMap < > ( ) ; while ( m > 0 ) { String mth [ ] = reader . readLine ( ) . split ( " ▁ " ) ; int k = Integer . parseInt ( mth [ 0 ] ) ; map . put ( k , new ArrayList < > ( ) ) ; map . get ( k ) . add ( Integer . parseInt ( mth [ 1 ] ) ) ; map . get ( k ) . add ( Integer . parseInt ( mth [ 2 ] ) ) ; maxT = Math . max ( maxT , k ) ; m -- ; } StringBuilder actions = new StringBuilder ( ) ; final char M = ( s < f ) ? ' R ' : ' L ' ; int d = ( s < f ) ? + 1 : - 1 ; int cur = s ; int a = - 1 ; int b = - 1 ; for ( int t = 1 ; t <= maxT ; t ++ ) { if ( map . containsKey ( t ) ) { a = map . get ( t ) . get ( 0 ) . intValue ( ) ; b = map . get ( t ) . get ( 1 ) . intValue ( ) ; } if ( map . containsKey ( t ) && ( ( cur >= a && cur <= b ) || ( cur + d >= a && cur + d <= b ) ) ) { actions . append ( ' X ' ) ; } else { actions . append ( M ) ; cur += d ; } if ( cur == f ) break ; } while ( cur != f ) { actions . append ( M ) ; cur += d ; } System . out . println ( actions ) ; } }
import java . util . Arrays ; class Test { static int subsetPairNotDivisibleByK ( int arr [ ] , int N , int K ) { int f [ ] = new int [ K ] ; Arrays . fill ( f , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) f [ arr [ i ] % K ] ++ ; if ( K % 2 == 0 ) f [ K / 2 ] = Math . min ( f [ K / 2 ] , 1 ) ; int res = Math . min ( f [ 0 ] , 1 ) ; for ( int i = 1 ; i <= K / 2 ; i ++ ) res += Math . max ( f [ i ] , f [ K - i ] ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 7 , 2 , 9 , 1 } ; int N = arr . length ; int K = 3 ; System . out . println ( subsetPairNotDivisibleByK ( arr , N , K ) ) ; } }
import java . util . * ; import java . io . * ; import java . util . Collections ; public class Main { public static long ans = 0 ; public static long get ( long a ) { long ret = 0 ; long now = 1 ; long t = 1 ; for ( ; ; ) { if ( now * 10 > a ) { ret += ( a - now + 1 ) * t ; break ; } ret += now * 9 * t ; now *= 10 ; t ++ ; } return ret ; } public static long binarySearch ( long k , long l , long r , long x ) { if ( r >= l ) { long mid = l + ( r - l ) / 2 ; if ( mid > ans && mid * k <= x ) ans = mid ; if ( k * mid == x ) return mid ; if ( k * mid > x ) return binarySearch ( k , l , mid - 1 , x ) ; return binarySearch ( k , mid + 1 , r , x ) ; } return - 1 ; } public static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; public static PrintWriter pw = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) throws IOException { Scanner S = new Scanner ( System . in ) ; long gen , st , tim ; gen = S . nextLong ( ) ; st = S . nextLong ( ) ; tim = S . nextLong ( ) ; gen /= tim ; long beg = st - 1 , end = ( long ) Math . pow ( 10 , 18 ) ; while ( true ) { long med = ( beg + end ) / 2 + 1 ; if ( get ( med ) - get ( st - 1 ) > gen ) { end = med - 1 ; } else { beg = med ; } if ( beg == end ) { System . out . println ( beg - st + 1 ) ; break ; } } } }
public class GFG { static void printRoots ( long a , long b , long c ) { System . out . println ( 1 + " , ▁ " + c / ( a * 1.0 ) ) ; } public static void main ( String [ ] args ) { long a = 2 ; long b = 3 ; long c = - 5 ; printRoots ( a , b , c ) ; } }
public class GFG { static int [ ] [ ] [ ] memo = new int [ 32 ] [ 2 ] [ 2 ] ; static int dp ( int pos , int fl , int pr , String bin ) { if ( pos == bin . length ( ) ) return 1 ; if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) return memo [ pos ] [ fl ] [ pr ] ; int val = 0 ; if ( bin . charAt ( pos ) == '0' ) val = val + dp ( pos + 1 , fl , 0 , bin ) ; else if ( bin . charAt ( pos ) == '1' ) val = val + dp ( pos + 1 , 1 , 0 , bin ) ; if ( pr == 0 ) { if ( fl == 1 ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } else if ( bin . charAt ( pos ) == '1' ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } } return memo [ pos ] [ fl ] [ pr ] = val ; } static int findIntegers ( int num ) { String bin = " " ; while ( num > 0 ) { if ( num % 2 == 1 ) bin += "1" ; else bin += "0" ; num /= 2 ; } bin = reverse ( bin ) ; for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) memo [ i ] [ j ] [ l ] = - 1 ; } } return dp ( 0 , 0 , 0 , bin ) ; } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( findIntegers ( N ) ) ; } }
public class GFG { final static int N = 4 ; static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; System . out . println ( MaximumDecimalValue ( mat , 4 ) ) ; } }
import java . util . * ; public class GFG { static void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr < maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static void findFibonacciPair ( int n ) { HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . contains ( i ) && hash . contains ( n - i ) ) { System . out . print ( i + " , ▁ " + ( n - i ) + " \n " ) ; return ; } } System . out . print ( " - 1 \n " ) ; } public static void main ( String [ ] args ) { int N = 90 ; findFibonacciPair ( N ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; System . out . println ( countgroup ( a , n ) ) ; } }
import java . util . * ; public class GFG { static int maxLength ( String s , int n ) { int ans = Integer . MIN_VALUE ; Vector < Integer > A = new Vector < Integer > ( ) ; Vector < Integer > L = new Vector < Integer > ( ) ; Vector < Integer > R = new Vector < Integer > ( ) ; int [ ] freq = new int [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) - ' a ' == i ) count ++ ; freq [ j ] = count ; } for ( int j = 1 ; j < n ; j ++ ) { L . add ( ( 2 * freq [ j - 1 ] ) - j ) ; R . add ( ( 2 * freq [ j ] ) - j ) ; } int max_len = Integer . MIN_VALUE ; int min_val = Integer . MAX_VALUE ; for ( int j = 0 ; j < L . size ( ) ; j ++ ) { min_val = Math . min ( min_val , L . get ( j ) ) ; A . add ( min_val ) ; int l = 0 , r = j ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( A . get ( mid ) <= R . get ( j ) ) { max_len = Math . max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . max ( ans , max_len ) ; A . clear ( ) ; R . clear ( ) ; L . clear ( ) ; } return ans ; } public static void main ( String [ ] args ) { String s = " ababbbacbcbcca " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
import java . util . * ; public class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int N = 100005 ; static Vector < Integer > [ ] gr = new Vector [ N ] ; static int [ ] colour = new int [ N ] ; static Vector < pair > edges = new Vector < > ( ) ; static boolean bip ; static void add_edge ( int x , int y ) { gr [ x ] . add ( y ) ; gr [ y ] . add ( x ) ; edges . add ( new pair ( x , y ) ) ; } static void dfs ( int x , int col ) { colour [ x ] = col ; for ( Integer i : gr [ x ] ) { if ( colour [ i ] == - 1 ) dfs ( i , col ^ 1 ) ; else if ( colour [ i ] == col ) bip = false ; } } static void Directed_Graph ( int n , int m ) { for ( int i = 0 ; i < N ; i ++ ) colour [ i ] = - 1 ; bip = true ; dfs ( 1 , 1 ) ; if ( ! bip ) { System . out . print ( - 1 ) ; return ; } for ( int i = 0 ; i < m ; i ++ ) { if ( colour [ edges . get ( i ) . first ] == 0 ) { Collections . swap ( edges , edges . get ( i ) . first , edges . get ( i ) . second ) ; } System . out . println ( edges . get ( i ) . first + " ▁ " + edges . get ( i ) . second ) ; } } public static void main ( String [ ] args ) { int n = 4 , m = 3 ; for ( int i = 0 ; i < N ; i ++ ) gr [ i ] = new Vector < > ( ) ; add_edge ( 1 , 2 ) ; add_edge ( 1 , 3 ) ; add_edge ( 1 , 4 ) ; Directed_Graph ( n , m ) ; } }
import java . io . * ; import java . util . * ; public class EhabOddPerson { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; String line1 [ ] = br . readLine ( ) . trim ( ) . split ( " ▁ " ) ; long arr [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Long . parseLong ( line1 [ i ] ) ; } boolean odd = false , even = false ; ArrayList < Long > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even = true ; } else { odd = true ; } ans . add ( arr [ i ] ) ; } if ( odd && even ) { Collections . sort ( ans ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( ans . get ( i ) ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int o , g , x = 0 ; long n , borrow = 0 ; o = sc . nextInt ( ) ; n = sc . nextLong ( ) ; g = sc . nextInt ( ) ; for ( int i = 1 ; i <= g ; i ++ ) { x = x + i * o ; } borrow = x - n ; if ( borrow <= 0 ) System . out . println ( 0 ) ; else System . out . println ( borrow ) ; } }
public class GFG { static boolean isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; } static int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; } static int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; } public static void main ( String args [ ] ) { int a = 2020 , b = 6300 , k = 29 ; System . out . println ( findCount ( a , b , k ) ) ; } }
import java . io . * ; import java . security . spec . ECField ; import java . util . HashMap ; import java . util . StringTokenizer ; public class Main { static int a [ ] ; static int l [ ] ; static int ans [ ] ; static HashMap < Integer , Boolean > map = new HashMap < > ( ) ; public static void main ( String [ ] args ) throws Exception { InputReader reader = new InputReader ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n , k ; n = reader . nextInt ( ) ; k = reader . nextInt ( ) ; int [ ] str = new int [ n ] ; if ( n < k ) { out . println ( " - 1" ) ; out . flush ( ) ; return ; } if ( k == 1 ) { if ( n > 1 ) out . println ( " - 1" ) ; else out . println ( " a " ) ; out . flush ( ) ; return ; } for ( int i = 0 ; i < ( n - k + 2 ) ; i ++ ) { if ( i < n ) { if ( i % 2 == 0 ) str [ i ] = 0 ; else str [ i ] = 1 ; } } int j = 2 ; for ( int i = n - k + 2 ; i < n ; i ++ ) { str [ i ] = j ++ ; } for ( int i = 0 ; i < n ; i ++ ) { out . print ( ( char ) ( str [ i ] + 97 ) ) ; } out . flush ( ) ; } static class InputReader { BufferedReader reader ; StringTokenizer tokenizer ; InputReader ( ) { reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; tokenizer = null ; } String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return tokenizer . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
public class GFG { static int maxn = 16 ; static int [ ] precompute ( ) { int dp [ ] = new int [ maxn ] , arr [ ] = { 4 , 6 , 9 } ; for ( int i = 0 ; i < maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < maxn ; ++ i ) { for ( int k = 0 ; k < 3 ; k ++ ) { int j = arr [ k ] ; if ( i >= j && dp [ i - j ] != - 1 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } return dp ; } static int Maximum_Summands ( int [ ] dp , int n ) { if ( n < maxn ) return dp [ n ] ; else { int t = ( n - maxn ) / 4 + 1 ; return t + dp [ n - 4 * t ] ; } } public static void main ( String args [ ] ) { int n = 12 ; int [ ] dp = precompute ( ) ; System . out . println ( Maximum_Summands ( dp , n ) ) ; } }
public class GFG { static int countSquares ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( " Count ▁ of ▁ squares ▁ is ▁ " + countSquares ( n ) ) ; } }
import java . util . HashMap ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } long [ ] sum = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = a [ i ] + sum [ i - 1 ] ; } HashMap < Long , Integer > map = new HashMap < Long , Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { map . put ( sum [ i ] % m , 0 ) ; } for ( int i = 1 ; i <= n ; i ++ ) { int x = map . get ( sum [ i ] % m ) ; map . put ( sum [ i ] % m , x + 1 ) ; } long ans = 0 ; if ( map . containsKey ( 0l ) ) { ans = map . get ( 0l ) ; } for ( long i : map . keySet ( ) ) { if ( map . get ( i ) >= 2 ) { for ( int j = map . get ( i ) ; j > 1 ; j -- ) { ans += j - 1 ; } } } System . out . println ( ans ) ; } } class Pair implements Comparable { int from ; int end ; int num ; int bango ; @ Override public int compareTo ( Object other ) { Pair otherpair = ( Pair ) other ; return from - otherpair . from ; } }
public class GFG { static int FindSubarray ( int arr [ ] , int n , int k ) { int [ ] count_one = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { count_one [ i ] = Integer . bitCount ( arr [ i ] ) ; } int sum = count_one [ 0 ] ; if ( n == 1 ) { if ( count_one [ 0 ] >= k ) return 1 ; else return - 1 ; } int ans = Integer . MAX_VALUE ; int i = 1 ; int j = 0 ; while ( i < n ) { if ( k == count_one [ j ] ) { ans = 1 ; break ; } else if ( k == count_one [ i ] ) { ans = 1 ; break ; } else if ( sum + count_one [ i ] < k ) { sum += count_one [ i ] ; i ++ ; } else if ( sum + count_one [ i ] > k ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum -= count_one [ j ] ; j ++ ; } else if ( sum + count_one [ i ] == k ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum += count_one [ i ] ; i ++ ; } } if ( ans != Integer . MAX_VALUE ) return ans ; else return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int n = arr . length ; int k = 2 ; System . out . println ( FindSubarray ( arr , n , k ) ) ; } }
public class GFG { static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( " Loss ▁ = ▁ " + String . format ( " % . 3 f " , loss ) ) ; } public static void main ( String [ ] args ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) , m = in . nextInt ( ) , x = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ in . nextInt ( ) ] = 1 ; } int ans1 = 0 , ans2 = 0 ; for ( int i = x ; i > 0 ; i -- ) { ans1 += a [ i ] ; } for ( int i = x ; i < n ; i ++ ) { ans2 += a [ i ] ; } System . out . println ( Math . min ( ans1 , ans2 ) ) ; } }
import java . util . Scanner ; public class A1138_SushiForTwo { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int len = 1 , prev = 0 , oneSeq = 0 , twoSeq = 0 ; while ( n -- > 0 ) { byte x = scanner . nextByte ( ) ; if ( x == 1 ) { if ( prev == 1 ) { oneSeq ++ ; } else { oneSeq = 1 ; } prev = 1 ; } else { if ( prev == 2 ) { twoSeq ++ ; } else { twoSeq = 1 ; } prev = 2 ; } if ( Math . min ( oneSeq , twoSeq ) > len ) len = Math . min ( oneSeq , twoSeq ) ; } System . out . println ( len * 2 ) ; } }
public final class p092 { public static void main ( String [ ] args ) { System . out . println ( new p092 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 7 ) ; public String run ( ) { int count = 0 ; for ( int i = 1 ; i < LIMIT ; i ++ ) { if ( isClass89 ( i ) ) count ++ ; } return Integer . toString ( count ) ; } private static boolean isClass89 ( int x ) { while ( true ) { switch ( x ) { case 1 : return false ; case 89 : return true ; default : x = nextNumber ( x ) ; } } } private static int nextNumber ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += ( x % 10 ) * ( x % 10 ) ; x /= 10 ; } return sum ; } }
import java . util . * ; public class GFG { static int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; } static int countStrings ( String str , int n ) { Set < Character > distinct_char = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { distinct_char . add ( str . charAt ( i ) ) ; } return fact ( distinct_char . size ( ) ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; System . out . println ( countStrings ( str , n ) ) ; } }
import java . util . * ; public class GFG { static int M = 4 ; static int N = 5 ; static void printCommonElements ( int mat [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( mat [ i ] [ j ] ) == i ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } } } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 1 , 4 , 8 } , { 3 , 7 , 8 , 5 , 1 } , { 8 , 7 , 7 , 3 , 1 } , { 8 , 1 , 2 , 7 , 9 } , } ; printCommonElements ( mat ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . StringTokenizer ; public class AntonAndLines { static double eps = 10e-9 ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; double start = Double . parseDouble ( st . nextToken ( ) ) ; double end = Double . parseDouble ( st . nextToken ( ) ) ; ArrayList < Pair > first = new ArrayList < Pair > ( ) ; ArrayList < Pair > second = new ArrayList < Pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; double a = Double . parseDouble ( st . nextToken ( ) ) ; double b = Double . parseDouble ( st . nextToken ( ) ) ; double y1 = a * ( start + eps ) + b ; double y2 = a * ( end - eps ) + b ; first . add ( new Pair ( i + 1 , y1 , y2 ) ) ; second . add ( new Pair ( i + 1 , y2 , y1 ) ) ; } Collections . sort ( first ) ; Collections . sort ( second ) ; for ( int i = 0 ; i < first . size ( ) ; i ++ ) { if ( first . get ( i ) . id != second . get ( i ) . id ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } static class Pair implements Comparable < Pair > { double x1 , x2 ; int id ; public Pair ( int i , double a , double b ) { x1 = a ; x2 = b ; id = i ; } @ Override public int compareTo ( Pair o ) { return ( ( Double ) this . x1 ) . compareTo ( o . x1 ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int [ ] s = new int [ n ] ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = sc . nextInt ( ) ; d [ i ] = sc . nextInt ( ) ; } System . out . println ( solve ( s , d , t ) ) ; sc . close ( ) ; } static int solve ( int [ ] s , int [ ] d , int t ) { int minTime = Integer . MAX_VALUE ; int result = - 1 ; for ( int i = 0 ; i < s . length ; i ++ ) { int time = divideToCeil ( t - s [ i ] , d [ i ] ) * d [ i ] + s [ i ] ; if ( time < minTime ) { minTime = time ; result = i + 1 ; } } return result ; } static int divideToCeil ( int x , int y ) { if ( x < 0 ) { return 0 ; } return x / y + ( x % y == 0 ? 0 : 1 ) ; } }
public class GFG { static float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; } public static void main ( String args [ ] ) { int n = 20 ; float a = 2.5f , d = 1.5f ; System . out . println ( sumOfAP ( a , d , n ) ) ; } }
public class GFG { static void find3Numbers ( int arr [ ] , int n ) { int small = + 2147483647 , large = + 2147483647 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= small ) small = arr [ i ] ; else if ( arr [ i ] <= large ) large = arr [ i ] ; else break ; } if ( i == n ) { System . out . println ( " No ▁ such ▁ triplet ▁ found " ) ; return ; } for ( int j = 0 ; j <= i ; j ++ ) { if ( arr [ j ] < large ) { small = arr [ j ] ; break ; } } System . out . println ( small + " ▁ " + large + " ▁ " + arr [ i ] ) ; return ; } public static void main ( String arg [ ] ) { int arr [ ] = { 5 , 7 , 4 , 8 } ; int n = arr . length ; find3Numbers ( arr , n ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } System . out . println ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) System . out . print ( i * i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 96 ; numbersWith3Divisors ( n ) ; } }
public class GFG { static int findPairCount ( int N , int K ) { int count = 0 ; int rem [ ] = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; } public static void main ( String [ ] args ) { int N = 10 , K = 4 ; System . out . println ( findPairCount ( N , K ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n , m ; List < Integer > array = new ArrayList < Integer > ( 20000 ) ; n = sc . nextInt ( ) ; m = sc . nextInt ( ) ; while ( ! ( n == 0 && m == 0 ) ) { array . clear ( ) ; for ( int i = 0 ; i < n + m ; i ++ ) { array . add ( sc . nextInt ( ) ) ; } Collections . sort ( array , Comparator . naturalOrder ( ) ) ; int interval = 0 ; int nt = 0 ; for ( int time : array ) { if ( time - nt > interval ) { interval = time - nt ; } nt = time ; } System . out . println ( interval ) ; n = sc . nextInt ( ) ; m = sc . nextInt ( ) ; } } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } System . out . println ( solve ( a ) ? " YES " : " NO " ) ; sc . close ( ) ; } static boolean solve ( int [ ] a ) { long sum = Arrays . stream ( a ) . asLongStream ( ) . sum ( ) ; int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; return sum % 2 == 0 && max * 2 <= sum ; } }
public class GFG { static double PHI = 1.6180339 ; static int f [ ] = { 0 , 1 , 1 , 2 , 3 , 5 } ; static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( n + " th ▁ Fibonacci ▁ Number ▁ = ▁ " + fib ( n ) ) ; } }
public class GFG { static int kthSmallest ( int n , int k ) { return ( 2 * k ) ; } public static void main ( String args [ ] ) { int n = 8 , k = 4 ; System . out . print ( kthSmallest ( n , k ) ) ; } }
import java . io . * ; public class GFG { static int n = 5 ; static void printSumTricky ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int stripSum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + " ▁ " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; } }
import java . math . BigInteger ; import java . util . Scanner ; public class A30 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int A = in . nextInt ( ) ; int B = in . nextInt ( ) ; int N = in . nextInt ( ) ; BigInteger bigA = BigInteger . valueOf ( A ) ; BigInteger bigB = BigInteger . valueOf ( B ) ; for ( int x = - 1000 ; x <= 1000 ; x ++ ) { if ( BigInteger . valueOf ( x ) . pow ( N ) . multiply ( bigA ) . equals ( bigB ) ) { System . out . println ( x ) ; return ; } } System . out . println ( " No ▁ solution " ) ; } }
import java . io . * ; public class GFG { static int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } static int totalWays ( int X , int Y , int M , int W ) { return ( ncr ( M , X ) * ncr ( W , Y ) ) ; } public static void main ( String [ ] args ) { int X = 4 , Y = 3 , M = 6 , W = 5 ; System . out . println ( totalWays ( X , Y , M , W ) ) ; } }
public class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n != 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } static int removeElement ( int n ) { if ( n == 1 || n == 2 ) return 0 ; int a = nextPowerOf2 ( n ) ; if ( n == a || n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( removeElement ( n ) ) ; } }
import java . util . Scanner ; class NumTh { static long Choose ( long n , long k ) { long res = 1 ; for ( long i = n ; i >= n - k + 1 ; i -- ) { res *= i ; res /= k - n + i ; } return res ; } } public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) , P = sc . nextInt ( ) ; long Even = 0 , Odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int A = sc . nextInt ( ) ; if ( A % 2 == 0 ) Even ++ ; else Odd ++ ; } if ( Odd == 0 ) { if ( P == 0 ) System . out . println ( ( long ) 1 << Even ) ; else System . out . println ( 0 ) ; } else System . out . println ( ( long ) 1 << ( long ) ( N - 1 ) ) ; } }
import java . io . * ; public class GFG { static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; } public static void main ( String args [ ] ) { int a = 3 , m = 11 ; System . out . println ( modInverse ( a , m ) ) ; } }
public class GFG { static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } static int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int l = 1000 , r = 6000 ; System . out . println ( countNumbers ( l , r ) ) ; } }
public class GFG { static void findGreater ( int a , int b ) { double x = ( double ) a * ( double ) ( Math . log ( ( double ) ( b ) ) ) ; double y = ( double ) b * ( double ) ( Math . log ( ( double ) ( a ) ) ) ; if ( y > x ) { System . out . println ( " a ^ b ▁ is ▁ greater " ) ; } else if ( y < x ) { System . out . println ( " b ^ a ▁ is ▁ greater " ) ; } else { System . out . println ( " Both ▁ are ▁ equal " ) ; } } public static void main ( String [ ] args ) { int a = 3 , b = 5 , c = 2 , d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ; } }
import java . util . * ; public class GFG { static int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) { ans -- ; break ; } } return ans ; } } public static void main ( String args [ ] ) { String str1 = " toy " , str2 = " try " ; int n = str1 . length ( ) ; System . out . println ( findAnswer ( str1 , str2 , n ) ) ; } }
import java . util . * ; public class Solution10 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; StringBuilder str = new StringBuilder ( ) ; for ( int z = 0 ; z < t ; z ++ ) { int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ m ] [ 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { arr [ i ] [ 0 ] = sc . nextInt ( ) ; arr [ i ] [ 1 ] = sc . nextInt ( ) ; } int si = x ; int ei = x ; for ( int i = 0 ; i < m ; i ++ ) { int l = arr [ i ] [ 0 ] ; int r = arr [ i ] [ 1 ] ; if ( ( l <= si && si <= r ) || ( l <= ei && ei <= r ) ) { si = Math . min ( l , si ) ; ei = Math . max ( r , ei ) ; } } str . append ( ei - si + 1 ) ; str . append ( " \n " ) ; } System . out . println ( str . toString ( ) ) ; } }
public class GFG { static boolean bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num , prev , curr ; num = n >> ( l - 1 ) ; prev = num & 1 ; num = num >> 1 ; for ( int i = 1 ; i <= ( r - l ) ; i ++ ) { curr = num & 1 ; if ( curr == prev ) return false ; prev = curr ; num = num >> 1 ; } return true ; } public static void main ( String [ ] args ) { int n = 18 ; int l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . IOException ; import java . util . Scanner ; public class eugene { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; StringBuffer res = new StringBuffer ( ) ; int o = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == 1 ) ++ o ; else ++ e ; for ( int i = 0 ; i < k ; i ++ ) { int l = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; if ( ( r - l + 1 ) % 2 == 1 ) res . append ( "0 \n " ) ; else { if ( ( r - l + 1 ) / 2 <= o && ( r - l + 1 ) / 2 <= e ) res . append ( "1 \n " ) ; else res . append ( "0 \n " ) ; } } System . out . print ( res ) ; sc . close ( ) ; } }
import java . util . * ; public class GFG { static int nth_group ( int n ) { return n * ( 2 * ( int ) Math . pow ( n , 2 ) + 1 ) ; } public static void main ( String arr [ ] ) { int N = 5 ; System . out . println ( nth_group ( N ) ) ; } }
import java . util . * ; public class Ex711B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; long [ ] [ ] magic_square = new long [ n ] [ n ] ; int row = - 1 , column = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { magic_square [ i ] [ j ] = in . nextInt ( ) ; if ( magic_square [ i ] [ j ] == 0 ) { row = i ; column = j ; } } } if ( n == 1 ) { System . out . println ( 1 ) ; return ; } long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row != 0 ) { sum += magic_square [ 0 ] [ i ] ; } else { sum += magic_square [ 1 ] [ i ] ; } } long answer = sum ; for ( int i = 0 ; i < n ; i ++ ) { answer -= magic_square [ row ] [ i ] ; } magic_square [ row ] [ column ] = answer ; int m = 0 ; long current_sumi = 0 , current_sumj = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { current_sumi += magic_square [ i ] [ j ] ; current_sumj += magic_square [ j ] [ i ] ; } if ( current_sumi != sum || current_sumj != sum ) { m ++ ; } current_sumi = 0 ; current_sumj = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { current_sumi += magic_square [ i ] [ i ] ; current_sumj += magic_square [ n - i - 1 ] [ i ] ; } if ( current_sumi != sum || current_sumj != sum ) { m ++ ; } if ( m == 0 && answer > 0 ) { System . out . println ( answer ) ; } else { System . out . println ( - 1 ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; sum1 = sum1 + arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { int csum = 0 ; csum = arr [ i ] + arr [ i - 1 ] ; if ( k > csum ) { arr [ i ] = arr [ i ] + k - csum ; } } for ( int i = 0 ; i < n ; i ++ ) { sum2 = sum2 + arr [ i ] ; } System . out . println ( sum2 - sum1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } static boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long lcm ( long a , long b ) { return ( a / gcd ( a , b ) ) * b ; } }
import java . io . * ; public class GFG { static int MAX = 1000000 ; static int maximumOccurredElement ( int [ ] L , int [ ] R , int n ) { int [ ] arr = new int [ MAX ] ; int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ L [ i ] ] += 1 ; arr [ R [ i ] + 1 ] -= 1 ; if ( R [ i ] > maxi ) { maxi = R [ i ] ; } } int msum = arr [ 0 ] ; int ind = 0 ; for ( int i = 1 ; i < maxi + 1 ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; if ( msum < arr [ i ] ) { msum = arr [ i ] ; ind = i ; } } return ind ; } static public void main ( String [ ] args ) { int [ ] L = { 1 , 4 , 9 , 13 , 21 } ; int [ ] R = { 15 , 8 , 12 , 20 , 30 } ; int n = L . length ; System . out . println ( maximumOccurredElement ( L , R , n ) ) ; } }
import java . util . * ; public class Rough_02 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long arr [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextLong ( ) ; } long count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { count ++ ; } } System . out . println ( count ) ; } }
import java . io . * ; import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n == 0 ) { if ( m != 0 ) System . out . println ( " Impossible " ) ; else System . out . println ( 0 + " ▁ " + 0 ) ; return ; } if ( m <= n ) { if ( m == 0 ) { m = 1 ; } System . out . print ( n + " ▁ " + ( m + n - 1 ) ) ; return ; } System . out . print ( m + " ▁ " + ( m + n - 1 ) ) ; } }
import java . util . * ; public class GFG { static float func ( float x ) { return ( 1 / ( 1 + x * x ) ) ; } static float calculate ( float lower_limit , float upper_limit , int interval_limit ) { float value ; float interval_size = ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ; for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; } public static void main ( String [ ] args ) { int interval_limit = 10 ; float lower_limit = 1 ; float upper_limit = 10 ; float integral_res = calculate ( lower_limit , upper_limit , interval_limit ) ; System . out . println ( String . format ( " % . 4 f " , integral_res ) ) ; } }
import java . util . Scanner ; public class Main { void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; long x = sc . nextLong ( ) ; long y = sc . nextLong ( ) ; long sum = 0 ; if ( n > k ) { sum += x * k ; sum += y * ( n - k ) ; } else { sum += x * n ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { double x = sc . nextDouble ( ) ; double h = sc . nextDouble ( ) ; if ( x == 0 && h == 0 ) break ; double c = Math . sqrt ( h * h + ( x / 2 ) * ( x / 2 ) ) ; double ans = x * x + x * c / 2 * 4 ; System . out . println ( ans ) ; } } }
import java . util . Scanner ; public class main { public static int count ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += num % 10 ; num = num / 10 ; } return sum ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int k , i = 1 , mo = 19 ; k = in . nextInt ( ) ; while ( i != k ) { mo ++ ; if ( 10 == count ( mo ) ) { i ++ ; } } System . out . println ( mo ) ; } }
import java . util . Arrays ; import java . util . Collections ; public class GFG { static final int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX ] ; public static void sieve ( ) { Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } } static void printPrimeQuad ( int n ) { for ( int i = 0 ; i < n - 7 ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] && prime [ i + 6 ] && prime [ i + 8 ] ) { System . out . println ( i + " ▁ " + ( i + 2 ) + " ▁ " + ( i + 6 ) + " ▁ " + ( i + 8 ) ) ; } } } public static void main ( String [ ] args ) { int n = 20 ; sieve ( ) ; printPrimeQuad ( n ) ; } }
public class GFG { static final int MAX = 1000 ; static int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; } public static void main ( String [ ] args ) { char x [ ] = " ABCD " . toCharArray ( ) ; char y [ ] = " BACDBDCD " . toCharArray ( ) ; int n = x . length , m = y . length ; System . out . println ( maxSubsequenceSubstring ( x , y , n , m ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 || i % b == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 , a = 3 , b = 5 ; System . out . println ( findSum ( n , a , b ) ) ; } }
import java . util . * ; public class tanyaandpostcard { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; String s1 = in . nextLine ( ) ; String s2 = in . nextLine ( ) ; int a [ ] = new int [ 123 ] ; int b [ ] = new int [ s1 . length ( ) ] ; int i , y = 0 , w = 0 ; char ch ; for ( i = 0 ; i < s2 . length ( ) ; i ++ ) a [ s2 . charAt ( i ) ] += 1 ; for ( i = 0 ; i < s1 . length ( ) ; i ++ ) { ch = s1 . charAt ( i ) ; if ( a [ ch ] >= 1 ) { a [ ch ] -- ; b [ i ] = 1 ; y ++ ; } } for ( i = 0 ; i < s1 . length ( ) ; i ++ ) { ch = s1 . charAt ( i ) ; if ( b [ i ] == 0 ) { if ( ch <= 90 ) ch = ( char ) ( ( int ) ch + 32 ) ; else ch = ( char ) ( ( int ) ch - 32 ) ; if ( a [ ch ] >= 1 ) { a [ ch ] -- ; w ++ ; } } } System . out . println ( y + " ▁ " + w ) ; } }
public class GFG { static int MAX = 1000 ; static int sequence [ ] = new int [ MAX ] ; static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX - 1 ; i ++ ) { sequence [ i ] = 0 ; } for ( int i = 0 ; i < MAX - 1 ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( sequence [ j ] == sequence [ i ] ) { sequence [ i + 1 ] = i - j ; break ; } } } } static int getNthTerm ( int n ) { return sequence [ n ] ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 6 ; System . out . println ( getNthTerm ( n ) ) ; n = 100 ; System . out . println ( getNthTerm ( n ) ) ; } }
public class GFG { static int MAX = 100000 ; static int sequence [ ] = new int [ MAX + 1 ] ; static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { sequence [ i ] = 0 ; } for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( sequence [ j ] == sequence [ i ] ) { sequence [ i + 1 ] = i - j ; break ; } } } } static int getCount ( int n ) { int count = 1 ; int i = n - 1 ; while ( sequence [ i + 1 ] != 0 ) { count ++ ; i = i - sequence [ i + 1 ] ; } return count ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 5 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } }
public class GFG { static int MAX = 100000 ; static int sequence [ ] = new int [ MAX + 1 ] ; static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { sequence [ i ] = 0 ; } for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( sequence [ j ] == sequence [ i ] ) { sequence [ i + 1 ] = i - j ; break ; } } } } static int getCount ( int n ) { int nthTerm = sequence [ n - 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sequence [ i ] == nthTerm ) count ++ ; } return count ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 5 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int nthElement ( int a , int b , int n ) { int lcm = ( a * b ) / __gcd ( a , b ) ; int l = 1 , r = Math . min ( a , b ) * n ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; int val = mid / a + mid / b - mid / lcm ; if ( val == n ) return Math . max ( ( mid / a ) * a , ( mid / b ) * b ) ; if ( val < n ) l = mid + 1 ; else r = mid - 1 ; } return 0 ; } static public void main ( String [ ] args ) { int a = 5 , b = 3 , n = 5 ; System . out . println ( nthElement ( a , b , n ) ) ; } }
import java . sql . Timestamp ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int y = in . nextInt ( ) ; boolean leap = check_leap ( y ) ; int sum = 0 ; int mod = 0 ; for ( int i = y + 1 ; ; i ++ ) { if ( check_leap ( i ) ) { sum += 366 ; } else { sum += 365 ; } if ( sum % 7 == 0 ) { if ( ( check_leap ( i ) && leap ) || ( ! check_leap ( i ) && ! leap ) ) { System . out . println ( i ) ; return ; } else { continue ; } } } } static boolean check_leap ( int y ) { return y % 400 == 0 || ( y % 4 == 0 && y % 100 != 0 ) ; } }
import java . util . * ; import static java . lang . Math . * ; public class Main { static int n ; static Scanner sc = new Scanner ( System . in ) ; static Queue < String > events ; static boolean read ( ) { int cnt = 0 ; String event ; events = new LinkedList < String > ( ) ; do { event = sc . next ( ) ; if ( event . equals ( " OUT " ) ) { cnt ++ ; } else { events . offer ( event ) ; } } while ( cnt < 3 ) ; return true ; } static int solve ( ) { int ans = 0 , s = 0 ; while ( ! events . isEmpty ( ) ) { String e = events . poll ( ) ; s = ( s << 1 ) + 1 ; if ( e . equals ( " HIT " ) ) { if ( ( s & 8 ) > 1 ) { ans ++ ; } s = ( s & 7 ) ; } else { for ( int i = 1 ; i < 16 ; i = ( i << 1 ) ) { if ( ( s & i ) >= 1 ) { ans ++ ; } } s = 0 ; } } return ans ; } public static void main ( String [ ] args ) { n = sc . nextInt ( ) ; while ( n -- > 0 && read ( ) ) { System . out . println ( solve ( ) ) ; } } }
public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int findValue ( int x , int y , int z ) { int g = __gcd ( y , z ) ; return ( x * g ) / __gcd ( x , g ) ; } public static void main ( String [ ] args ) { int x = 30 , y = 40 , z = 400 ; System . out . print ( findValue ( x , y , z ) ) ; } }
import java . util . * ; import java . text . * ; class solution { static void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; System . out . print ( " x2 ▁ = ▁ " + String . format ( " % . 1 f " , x2 ) ) ; System . out . print ( " ▁ y2 ▁ = ▁ " + String . format ( " % . 1 f " , y2 ) ) ; System . out . print ( " ▁ z2 ▁ = ▁ " + String . format ( " % . 1 f " , z2 ) ) ; } public static void main ( String arr [ ] ) { float a = 1 ; float b = - 2 ; float c = 0 ; float d = 0 ; float x1 = - 1 ; float y1 = 3 ; float z1 = 4 ; foot ( a , b , c , d , x1 , y1 , z1 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; String c1 = sc . next ( ) ; String c2 = sc . next ( ) ; if ( c1 . charAt ( 0 ) == c2 . charAt ( c2 . length ( ) - 1 ) && c2 . charAt ( 0 ) == c1 . charAt ( c1 . length ( ) - 1 ) && c1 . charAt ( 1 ) == c2 . charAt ( 1 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; sc . close ( ) ; } }
import java . util . * ; public class GFG { static int getMinimumOps ( Vector < Integer > ar ) { int n = ar . size ( ) ; int small = Collections . min ( ar ) ; int large = Collections . max ( ar ) ; int [ ] [ ] dp = new int [ n ] [ large + 1 ] ; for ( int j = small ; j <= large ; j ++ ) { dp [ 0 ] [ j ] = Math . abs ( ar . get ( 0 ) - j ) ; } for ( int i = 1 ; i < n ; i ++ ) { int minimum = Integer . MAX_VALUE ; for ( int j = small ; j <= large ; j ++ ) { minimum = Math . min ( minimum , dp [ i - 1 ] [ j ] ) ; dp [ i ] [ j ] = minimum + Math . abs ( ar . get ( i ) - j ) ; } } int ans = Integer . MAX_VALUE ; for ( int j = small ; j <= large ; j ++ ) { ans = Math . min ( ans , dp [ n - 1 ] [ j ] ) ; } return ans ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 1 , 2 , 1 , 4 , 3 } ; Vector < Integer > ar = new Vector < > ( Arrays . asList ( arr ) ) ; System . out . println ( getMinimumOps ( ar ) ) ; } }
import java . lang . * ; public class GFG { static double PI = 3.14159265 ; public static double area_leaf ( double a ) { return ( a * a * ( PI / 2 - 1 ) ) ; } public static void main ( String [ ] args ) { double a = 7 ; System . out . println ( area_leaf ( a ) ) ; } }
import java . util . * ; class Circular { public static int removeAlternate ( int n ) { if ( n == 1 ) return 1 ; if ( n % 2 == 0 ) return 2 * removeAlternate ( n / 2 ) - 1 ; else return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( removeAlternate ( n ) ) ; n = 10 ; System . out . print ( " \n " + removeAlternate ( n ) ) ; } }
import java . io . * ; public class GFG { static void check ( int n , int m ) { if ( n == 2 || m == 2 || n % m == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int m = 3 , n = 9 ; check ( n , m ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . HashSet ; import java . util . Set ; public class ColorThePicture { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pr = new PrintWriter ( System . out ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; while ( t != 0 ) { solve ( br , pr ) ; t -- ; } pr . flush ( ) ; pr . close ( ) ; } public static void solve ( BufferedReader br , PrintWriter pr ) throws IOException { String [ ] temp = br . readLine ( ) . split ( " ▁ " ) ; int m = Integer . parseInt ( temp [ 0 ] ) ; int n = Integer . parseInt ( temp [ 1 ] ) ; int k = Integer . parseInt ( temp [ 2 ] ) ; long sum = 0 ; int [ ] colors = new int [ k ] ; temp = br . readLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < k ; i ++ ) { colors [ i ] = Integer . parseInt ( temp [ i ] ) ; sum += colors [ i ] ; } boolean flag = check ( m , n , colors ) || check ( n , m , colors ) ; pr . println ( flag ? " Yes " : " No " ) ; } public static boolean check ( int m , int n , int [ ] colors ) { long count = 0 ; Set < Integer > set = new HashSet < > ( ) ; for ( int i : colors ) { int max = i / m ; if ( max >= 2 ) { count += max ; set . add ( max ) ; } } if ( count < n ) { return false ; } if ( set . size ( ) >= 2 ) { return true ; } if ( set . size ( ) == 1 ) { if ( set . contains ( 2 ) ) { return n % 2 == 0 ? true : false ; } else { return true ; } } return true ; } }
public class GFG { static int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 4 , - 3 , 2 , - 5 } ; int n = arr . length ; System . out . println ( negProdSubArr ( arr , n ) ) ; } }
public class GFG { static int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } static int posProdSubArr ( int arr [ ] , int n ) { int total = ( n * ( n + 1 ) ) / 2 ; int cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 4 , - 3 , 2 , - 5 } ; int n = arr . length ; System . out . println ( posProdSubArr ( arr , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; public class CF3 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) throws java . lang . Exception { FastReader in = new FastReader ( ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { long n = in . nextLong ( ) ; long k = in . nextLong ( ) ; long sum = 0 , cur = 1 ; while ( cur < k ) { cur *= 2 ; ++ sum ; } if ( cur < n ) sum += ( n - cur + k - 1 ) / k ; System . out . println ( sum ) ; } } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; String [ ] z = br . readLine ( ) . split ( " ▁ " ) ; int x = Integer . parseInt ( z [ 0 ] ) ; int y = Integer . parseInt ( z [ 1 ] ) ; int a = Integer . parseInt ( z [ 2 ] ) ; int b = Integer . parseInt ( z [ 3 ] ) ; int c = 0 , i , j ; int lcm = x * y / gcd ( x , y ) ; for ( i = a ; i <= b ; i ++ ) { if ( i % lcm == 0 ) { break ; } } for ( j = b ; j >= a ; j -- ) { if ( j % lcm == 0 ) { break ; } } if ( j % lcm == 0 && i % lcm == 0 ) { c = ( j - i ) / lcm + 1 ; } pw . println ( c ) ; pw . close ( ) ; } public static int gcd ( int a , int b ) { int temp = a ; if ( a < b ) { a = b ; b = temp ; } if ( a % b == 0 ) { return b ; } else { return gcd ( b , a % b ) ; } } }
public class Main { static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 6 , 5 , 4 } ; int n = arr . length ; System . out . println ( minRemove ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static void print_max ( int a [ ] , int n , int k ) { int [ ] max_upto = new int [ n ] ; Stack < Integer > s = new Stack < > ( ) ; s . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && a [ s . peek ( ) ] < a [ i ] ) { max_upto [ s . peek ( ) ] = i - 1 ; s . pop ( ) ; } s . push ( i ) ; } while ( ! s . empty ( ) ) { max_upto [ s . peek ( ) ] = n - 1 ; s . pop ( ) ; } int j = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { while ( j < i || max_upto [ j ] < i + k - 1 ) { j ++ ; } System . out . print ( a [ j ] + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 } ; int n = a . length ; int k = 3 ; print_max ( a , n , k ) ; } }
import java . math . BigInteger ; public final class p056 { public static void main ( String [ ] args ) { System . out . println ( new p056 ( ) . run ( ) ) ; } public String run ( ) { int max = 0 ; for ( int a = 1 ; a < 100 ; a ++ ) { for ( int b = 1 ; b < 100 ; b ++ ) { BigInteger pow = BigInteger . valueOf ( a ) . pow ( b ) ; max = Math . max ( digitSum ( pow ) , max ) ; } } return Integer . toString ( max ) ; } private static int digitSum ( BigInteger n ) { int sum = 0 ; String s = n . toString ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) sum += s . charAt ( i ) - '0' ; return sum ; } }
import java . util . Arrays ; class Test { static int countWindowDistinct ( int win [ ] , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( win [ i ] == win [ j ] ) break ; if ( j == i ) dist_count ++ ; } return dist_count ; } static void countDistinct ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) System . out . println ( countWindowDistinct ( Arrays . copyOfRange ( arr , i , arr . length ) , k ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 1 , 3 , 4 , 2 , 3 } , k = 4 ; countDistinct ( arr , arr . length , k ) ; } }
public class GFG { static int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } public static void main ( String args [ ] ) { String str = "1234" ; System . out . println ( evenNumSubstring ( str ) ) ; } }
class solution { static final int max = 4 ; static int countWays ( int index , int cnt , int dp [ ] [ ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } public static void main ( String args [ ] ) { int n = 3 , m = 3 , k = 2 ; int dp [ ] [ ] = new int [ n + 1 ] [ max ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) for ( int j = 0 ; j < max ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . println ( m * countWays ( 1 , 0 , dp , n , m , k ) ) ; } }
import java . util . * ; public class GFG { static int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum - n ; } static void printAliquot ( int n ) { System . out . printf ( " % d ▁ " , n ) ; TreeSet < Integer > s = new TreeSet < > ( ) ; s . add ( n ) ; int next = 0 ; while ( n > 0 ) { n = getSum ( n ) ; if ( s . contains ( n ) && n != s . last ( ) ) { System . out . print ( " \n Repeats ▁ with ▁ " + n ) ; break ; } System . out . print ( n + " ▁ " ) ; s . add ( n ) ; } } public static void main ( String [ ] args ) { printAliquot ( 12 ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class PashaAndHamsters { public static void main ( String [ ] args ) throws IOException { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; String dims [ ] = br . readLine ( ) . split ( " ▁ " ) ; int total = Integer . parseInt ( dims [ 0 ] ) ; int at = Integer . parseInt ( dims [ 1 ] ) ; int pt = Integer . parseInt ( dims [ 2 ] ) ; boolean [ ] vals = new boolean [ total ] ; String as [ ] = br . readLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < as . length ; i ++ ) { int x = Integer . parseInt ( as [ i ] ) ; vals [ x - 1 ] = true ; } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < total ; i ++ ) { sb . append ( ( vals [ i ] ? "1" : "2" ) + " ▁ " ) ; } System . out . println ( sb ) ; } }
import java . util . Arrays ; public class GFG { static void reverseArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = arr . length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
public class GFG { static void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag == true ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int N = 8 ; printSeriesSum ( N ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String line ; int T = sc . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { long h = sc . nextLong ( ) ; long w = sc . nextLong ( ) ; long gcd = gcd ( h , w ) ; h /= gcd ; w /= gcd ; if ( h == w ) { System . out . println ( "1 ▁ 0" ) ; } else if ( h % 2 == 0 || w % 2 == 0 ) { System . out . println ( "1 ▁ 1" ) ; } else { long a , b ; a = ( h * w ) / 2 + 1 ; b = ( h * w ) / 2 ; System . out . println ( a + " ▁ " + b ) ; } } } static long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } }
import java . util . * ; public class GFG { static int sz = ( int ) 1e5 ; static boolean [ ] isPrime = new boolean [ sz + 1 ] ; static void sieve ( ) { Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } static int minDifference ( int L , int R ) { int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { snd = i ; break ; } } if ( snd == 0 ) return - 1 ; int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { if ( i - snd <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; } public static void main ( String [ ] args ) { sieve ( ) ; int L = 21 , R = 50 ; System . out . println ( minDifference ( L , R ) ) ; } }
public class GFG { static int getMaxLength ( int arr [ ] , int n ) { int start = 0 ; int preCnt = 0 ; while ( start < n && arr [ start ] == 1 ) { preCnt ++ ; start ++ ; } int end = n - 1 ; int suffCnt = 0 ; while ( end >= 0 && arr [ end ] == 1 ) { suffCnt ++ ; end -- ; } if ( start > end ) return n ; int midCnt = 0 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( arr [ i ] == 1 ) { midCnt ++ ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } } return Math . max ( result , preCnt + suffCnt ) ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( getMaxLength ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner s = new Scanner ( System . in ) ; int d = s . nextInt ( ) ; int n = s . nextInt ( ) ; int [ ] temp = new int [ d ] ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int [ ] c = new int [ n ] ; for ( int i = 0 ; i < d ; i ++ ) { temp [ i ] = s . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . nextInt ( ) ; b [ i ] = s . nextInt ( ) ; c [ i ] = s . nextInt ( ) ; } int [ ] [ ] dp = new int [ d ] [ n ] ; for ( int i = 0 ; i < d ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= temp [ 0 ] && b [ i ] >= temp [ 0 ] ) dp [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i < d ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] <= temp [ i ] && b [ j ] >= temp [ i ] ) { for ( int k = 0 ; k < n ; k ++ ) { if ( dp [ i - 1 ] [ k ] < 0 ) continue ; dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( c [ j ] - c [ k ] ) ) ; } } } } int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { ans = Math . max ( ans , dp [ d - 1 ] [ i ] ) ; } System . out . println ( ans ) ; } }
import java . io . * ; import java . util . * ; public class Main { static long mod = ( long ) ( 1e9 + 7 ) ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; int i1 = 0 , i2 = 0 ; String s = in . next ( ) ; boolean flag = true ; char ch [ ] = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( ch [ i ] > ch [ i + 1 ] ) { i1 = i + 1 ; i2 = i + 2 ; flag = false ; break ; } } if ( flag ) { pw . println ( " NO " ) ; } else { pw . println ( " YES " ) ; pw . println ( i1 + " ▁ " + i2 ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
public class GFG { static float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; } public static void main ( String [ ] args ) { float num = 9.2345f ; float sqroot_of_num = sqroot ( num ) ; System . out . println ( " Square ▁ root ▁ of ▁ " + num + " ▁ = ▁ " + Math . round ( sqroot_of_num * 100000.0 ) / 100000.0 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; while ( in . hasNext ( ) ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int s = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; b [ i ] = 0 ; } int tem = 1 ; int q = 0 ; while ( q != n ) { s ++ ; if ( tem == 1 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= q && b [ i ] == 0 ) { b [ i ] = 1 ; q ++ ; } } tem = 0 ; } else { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] <= q && b [ i ] == 0 ) { b [ i ] = 1 ; q ++ ; } } tem = 1 ; } } System . out . println ( s ) ; } } }
import java . util . Scanner ; public class Main { public static double INF = 100.0 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int r = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; if ( r == 0 ) { break ; } int [ ] field = new int [ 40 ] ; for ( int i = 0 ; i < n ; i ++ ) { int xl = sc . nextInt ( ) ; int xr = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; for ( int j = xl + 20 ; j < xr + 20 ; j ++ ) { field [ j ] = Math . max ( field [ j ] , h ) ; } } double minTime = INF ; for ( int i = 0 ; i < field . length ; i ++ ) { minTime = Math . min ( minTime , crossTime ( i - 20 , field [ i ] , r ) ) ; minTime = Math . min ( minTime , crossTime ( i + 1 - 20 , field [ i ] , r ) ) ; } System . out . println ( minTime ) ; } } public static double crossTime ( int x , int y , int r ) { int d = ( int ) Math . pow ( - 2 * ( y + r ) , 2 ) - 4 * ( x * x + y * y + 2 * y * r ) ; if ( d <= 0 ) { return INF ; } else { double ans = ( 2 * ( y + r ) - Math . sqrt ( d ) ) / 2 ; return ans ; } } public static void printHeight ( int [ ] field ) { for ( int i = 0 ; i < field . length ; i ++ ) { System . out . println ( ( i - 20 ) + " - " + ( ( i - 20 ) + 1 ) + " : ▁ " + field [ i ] ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = in . nextInt ( ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { list . add ( in . nextInt ( ) ) ; } find ( list ) ; } } public static void find ( ArrayList < Integer > list ) { Collections . sort ( list ) ; int n = list . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( list . get ( i ) <= i + 1 ) { System . out . println ( i + 2 ) ; return ; } } System . out . println ( 1 ) ; } }
import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int num ; public static void main ( String [ ] args ) { while ( read ( ) ) { solve ( ) ; } } static boolean read ( ) { if ( sc . hasNextInt ( ) ) num = sc . nextInt ( ) ; if ( num == 0 ) return false ; return true ; } static void solve ( ) { int table [ ] = { 0 , 1 , 2 , 3 , 5 , 7 , 8 , 9 } ; String s = Integer . toOctalString ( num ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int num2 = Integer . parseInt ( " " + s . charAt ( i ) , 8 ) ; System . out . print ( table [ num2 ] ) ; } System . out . println ( ) ; } }
public class GFG { static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 2 , 3 , 5 , 7 , 9 , 10 } ; System . out . println ( " Maximum ▁ sum ▁ = ▁ " + maxAlternateSum ( arr , arr . length ) ) ; } }
import java . io . * ; public class GFG { static void generateArr ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev & arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev & arr [ n - 1 ] ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; generateArr ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; public class GFG { static void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; public class GFG { static void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) { return ; } int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev + arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev + arr [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . util . * ; public class GFG { static long countTriplets ( int A , int B , int C ) { long ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; } public static void main ( String [ ] args ) { int A = 3 , B = 2 , C = 2 ; System . out . println ( countTriplets ( A , B , C ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 100000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int smallestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return - 1 ; } static int largestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int queries [ ] = { 2 , 5 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( smallestPrime ( queries [ i ] ) + " ▁ " + largestPrime ( queries [ i ] ) ) ; } } }
import java . io . * ; import java . util . StringTokenizer ; import java . util . Arrays ; class Main { static final PrintWriter out = new PrintWriter ( System . out ) ; static final int INF = Integer . MAX_VALUE / 2 ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = " " ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { StringTokenizer st = new StringTokenizer ( line ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int m = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] [ ] tir = new int [ m + 1 ] [ n + 1 ] ; Arrays . fill ( tir [ m ] , INF ) ; tir [ m ] [ n ] = 0 ; int [ ] d = new int [ n ] ; int [ ] c = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) d [ i ] = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { tir [ i ] [ j ] = Math . min ( tir [ i + 1 ] [ j ] , tir [ i + 1 ] [ j + 1 ] + d [ j ] * c [ i ] ) ; } } out . println ( tir [ 0 ] [ 0 ] ) ; out . flush ( ) ; } } }
import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int k = input . nextInt ( ) ; int x = input . nextInt ( ) ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr . add ( input . nextInt ( ) ) ; } for ( int i = arr . size ( ) - k ; i < arr . size ( ) ; i ++ ) { arr . set ( i , x ) ; } int sum = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { sum += arr . get ( i ) ; } System . out . println ( sum ) ; } }
import java . util . * ; public class AutomaticDoor { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; long n = scan . nextLong ( ) ; int m = scan . nextInt ( ) ; long a = scan . nextLong ( ) ; long d = scan . nextLong ( ) ; long [ ] arr = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) arr [ i ] = scan . nextLong ( ) ; int count = 0 ; long time = 0 ; long x = d / a + 1 ; long y = d - ( x - 1 ) * a ; if ( y < 0 ) y = 0 ; long last = 0 ; for ( int i = 0 ; i < m ; ) { long b = Math . max ( Math . min ( ( arr [ i ] - 1 ) / a , n ) , 0 ) ; long c = b - time ; long k = c / x ; count += k ; time += k * x ; if ( k != 0 ) { while ( i < m && arr [ i ] <= time * a + y ) { i ++ ; } } if ( i >= m ) break ; count ++ ; last = arr [ i ] + d ; if ( time < n ) last = Math . min ( last , ( time + 1 ) * a + d ) ; while ( i < m && arr [ i ] <= last ) i ++ ; time = Math . max ( time , Math . min ( n , last / a ) ) ; } if ( time < n ) { count += ( n - time + x - 1 ) / x ; } System . out . println ( count ) ; } }
import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; public class PA_TrickySum { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; int t = Integer . parseInt ( reader . readLine ( ) ) ; long sum = 0 , valu = 0 , result = 0 ; for ( int p = 0 ; p < t ; p ++ ) { long n1 = Long . parseLong ( reader . readLine ( ) ) ; sum = n1 * ( n1 + 1 ) / 2 ; for ( long i = 1 ; i < n1 + 1 ; i = ( long ) i * 2 ) { valu += i ; } result = sum - ( valu * 2 ) ; writer . write ( " " + result ) ; writer . newLine ( ) ; valu = 0 ; } writer . newLine ( ) ; writer . flush ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String s = in . next ( ) ; char ar [ ] = new char [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; ar [ ch - 97 ] ++ ; } int cntod = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( ar [ i ] % 2 ) != 0 ) cntod ++ ; } if ( cntod == 0 ) System . out . println ( " First " ) ; else { if ( cntod % 2 == 0 ) { System . out . println ( " Second " ) ; } else { System . out . println ( " First " ) ; } } } }
import java . util . * ; public class GFG { static int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; } static void getSum ( int n ) { n = reverse ( n ) ; int sumOdd = 0 , sumEven = 0 , c = 1 ; while ( n != 0 ) { if ( c % 2 == 0 ) sumEven += n % 10 ; else sumOdd += n % 10 ; n /= 10 ; c ++ ; } System . out . println ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; System . out . println ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; } public static void main ( String args [ ] ) { int n = 457892 ; getSum ( n ) ; } }
import java . util . * ; public class GFG { static void disp ( int row_no , int block ) { System . out . print ( row_no * block ) ; } static int row ( int ht , int h ) { return ht / h ; } static void calculate ( int l , int w , int h , int a , int ht ) { int no_block = ( 4 * a ) / l ; int row_no ; if ( h < w ) row_no = row ( ht , w ) ; else row_no = row ( ht , h ) ; disp ( row_no , no_block ) ; } public static void main ( String [ ] args ) { int l = 50 , w = 20 , h = 35 ; int a = 700 ; int ht = 140 ; calculate ( l , w , h , a , ht ) ; } }
public class GFG { static String bin [ ] = { "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" } ; static int maxFreq ( String s ) { String binary = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s . charAt ( i ) - '0' ] ; } binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary . charAt ( i ) == '1' ) { count = Math . max ( count , j - prev ) ; prev = j ; } return count ; } public static void main ( String [ ] args ) { String octal = "13" ; System . out . println ( maxFreq ( octal ) ) ; } }
public class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } static String encryptString ( char [ ] s , int n , int k ) { int [ ] cv = new int [ n ] ; int [ ] cc = new int [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 1 : 0 ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 0 : 1 ) ; } String ans = " " ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += String . valueOf ( prod ) ; for ( int i = k ; i < s . length ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += String . valueOf ( prod ) ; } return ans ; } public static void main ( String [ ] args ) { String s = " hello " ; int n = s . length ( ) ; int k = 2 ; System . out . print ( encryptString ( s . toCharArray ( ) , n , k ) + " \n " ) ; } }
public class GFG { static float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; } public static void main ( String args [ ] ) { int num [ ] = { 13 , 14 , 15 , 16 , 17 } ; int freq [ ] = { 2 , 5 , 13 , 7 , 3 } ; int n = num . length ; System . out . println ( String . format ( " % . 4 f " , harmonicMean ( num , freq , n ) ) ) ; } }
import java . io . * ; public class GFG { static float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float A = ( a * a * n ) / ( float ) ( 4 * Math . tan ( ( 180 / n ) * Math . PI / 180 ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 9 , n = 6 ; System . out . println ( String . format ( " % . 3 f " , polyarea ( n , a ) ) ) ; } }
class Solution { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int lcm ( int a , int b ) { return ( a / __gcd ( a , b ) * b ) ; } static int getMinValue ( int c ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= Math . sqrt ( c ) ; i ++ ) { if ( c % i == 0 && lcm ( i , c / i ) == c ) { ans = Math . min ( ans , Math . max ( i , c / i ) ) ; } } return ans ; } public static void main ( String args [ ] ) { int c = 6 ; System . out . println ( getMinValue ( c ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { while ( sc . hasNext ( ) ) { int m = sc . nextInt ( ) ; int nmin = sc . nextInt ( ) ; int nmax = sc . nextInt ( ) ; if ( m + nmin + nmax == 0 ) break ; int [ ] p = new int [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { p [ i ] = sc . nextInt ( ) ; } int gap = 0 ; int n = 0 ; for ( int i = nmin ; i <= nmax ; i ++ ) { if ( gap <= p [ i ] - p [ i + 1 ] && n < i ) { gap = p [ i ] - p [ i + 1 ] ; n = i ; } } System . out . println ( n ) ; } } } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; long start = sc . nextLong ( ) ; long ratio = sc . nextLong ( ) ; long max = sc . nextLong ( ) ; int m = sc . nextInt ( ) ; ArrayList < Long > bad = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { bad . add ( sc . nextLong ( ) ) ; } if ( Math . abs ( start ) > max ) { System . out . println ( "0" ) ; return ; } if ( start == 0 ) { if ( bad . contains ( start ) ) { System . out . println ( "0" ) ; return ; } else { System . out . println ( " inf " ) ; return ; } } if ( ratio == 1 ) { if ( bad . contains ( start ) ) { System . out . println ( "0" ) ; return ; } else { System . out . println ( " inf " ) ; return ; } } if ( ratio == - 1 ) { if ( bad . contains ( start ) && bad . contains ( start * ( - 1 ) ) ) { System . out . println ( "0" ) ; return ; } else { System . out . println ( " inf " ) ; return ; } } if ( ratio == 0 ) { if ( bad . contains ( ratio ) == false ) { System . out . println ( " inf " ) ; return ; } else if ( bad . contains ( start ) ) { System . out . println ( "0" ) ; return ; } else { System . out . println ( "1" ) ; return ; } } int cnt = 0 ; while ( Math . abs ( start ) <= max ) { if ( bad . contains ( start ) == false ) { cnt ++ ; } start *= ratio ; } System . out . println ( cnt ) ; } }
import java . io . * ; import java . util . * ; public class Main { static PrintWriter out = new PrintWriter ( System . out ) ; static Scanner in = new Scanner ( System . in ) ; static BufferedReader re = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter wr = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; public static void main ( String [ ] args ) throws IOException { PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int T = in . nextInt ( ) ; while ( T > 0 ) { int n = in . nextInt ( ) ; int arr [ ] [ ] = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ 0 ] = in . nextInt ( ) ; arr [ i ] [ 1 ] = i + 1 ; } Arrays . sort ( arr , ( o1 , o2 ) -> o1 [ 0 ] - o2 [ 0 ] ) ; if ( n >= 2 ) System . out . println ( arr [ 0 ] [ 1 ] + " ▁ " + arr [ n - 1 ] [ 1 ] ) ; else System . out . println ( 1 + " ▁ " + 1 ) ; T -- ; } out . flush ( ) ; } }
public class Fibonacci { static int findIndex ( int n ) { float fibo = 2.078087F * ( float ) Math . log ( n ) + 1.672276F ; return Math . round ( fibo ) ; } public static void main ( String [ ] args ) { int n = 21 ; System . out . println ( findIndex ( n ) ) ; } }
import java . util . * ; public class GFG { static boolean isSmaller ( String str1 , String str2 ) { int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 . charAt ( i ) < str2 . charAt ( i ) ) return true ; else if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) return false ; return false ; } static String findDiff ( String str1 , String str2 ) { if ( isSmaller ( str1 , str2 ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ; str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ; int carry = 0 ; for ( int i = 0 ; i < n2 ; i ++ ) { int sub = ( ( int ) ( str1 . charAt ( i ) - '0' ) - ( int ) ( str2 . charAt ( i ) - '0' ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str += ( char ) ( sub + '0' ) ; } for ( int i = n2 ; i < n1 ; i ++ ) { int sub = ( ( int ) ( str1 . charAt ( i ) - '0' ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str += ( char ) ( sub + '0' ) ; } return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; } public static void main ( String [ ] args ) { String str1 = "978" ; String str2 = "12977" ; System . out . println ( findDiff ( str1 , str2 ) ) ; String s1 = "100" ; String s2 = "1000000" ; System . out . println ( findDiff ( s1 , s2 ) ) ; } }
public class GFG { static int minSwaps ( String s1 , String s2 ) { int c0 = 0 , c1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) { c0 ++ ; } else if ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) { c1 ++ ; } } int ans = c0 / 2 + c1 / 2 ; if ( c0 % 2 == 0 && c1 % 2 == 0 ) { return ans ; } else if ( ( c0 + c1 ) % 2 == 0 ) { return ans + 2 ; } else { return - 1 ; } } public static void main ( String [ ] args ) { String s1 = "0011" , s2 = "1111" ; int ans = minSwaps ( s1 , s2 ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) x [ i ] = sc . nextInt ( ) ; long all = 0 ; for ( int i = 0 ; i < n ; ++ i ) all += x [ i ] ; SegmentTree seg = new SegmentTree ( n + 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { long pre = seg . query ( 0 , x [ i ] ) ; seg . set ( x [ i ] , pre + x [ i ] ) ; } long fix = seg . query ( 0 , n + 1 ) ; System . out . println ( all - fix ) ; } static class SegmentTree { int n = 1 ; long [ ] val ; public SegmentTree ( int n ) { while ( this . n < n ) this . n *= 2 ; val = new long [ 2 * this . n - 1 ] ; } void set ( int k , long l ) { k += n - 1 ; val [ k ] = l ; while ( k > 0 ) { k = ( k - 1 ) / 2 ; val [ k ] = Math . max ( val [ 2 * k + 1 ] , val [ 2 * k + 2 ] ) ; } } long query ( int a , int b ) { return query ( a , b , 0 , n , 0 ) ; } long query ( int a , int b , int l , int r , int k ) { if ( r <= a || b <= l ) return 0 ; else if ( a <= l && r <= b ) { return val [ k ] ; } else { long vl = query ( a , b , l , ( l + r ) / 2 , 2 * k + 1 ) ; long vr = query ( a , b , ( l + r ) / 2 , r , 2 * k + 2 ) ; return Math . max ( vl , vr ) ; } } } }
import java . util . Scanner ; public class A376_Lever_Round221 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s ; s = sc . nextLine ( ) ; sc . close ( ) ; int part = s . indexOf ( " ^ " ) ; long left = 0 ; long right = 0 ; for ( int i = 0 ; i < part ; i ++ ) { if ( s . charAt ( i ) <= '9' && s . charAt ( i ) >= '1' ) { left += ( part - i ) * ( s . charAt ( i ) - '0' ) ; } } for ( int j = part + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) <= '9' && s . charAt ( j ) >= '1' ) { right += ( j - part ) * ( s . charAt ( j ) - '0' ) ; } } if ( left == right ) { System . out . println ( " balance " ) ; } else if ( left < right ) { System . out . println ( " right " ) ; } else if ( right < left ) { System . out . println ( " left " ) ; } } }
import java . util . Arrays ; public class GFG { static void normalSieve ( int n ) { boolean prime [ ] = new boolean [ n / 2 ] ; Arrays . fill ( prime , false ) ; for ( int i = 3 ; i * i < n ; i += 2 ) { if ( prime [ i / 2 ] == false ) for ( int j = i * i ; j < n ; j += i * 2 ) prime [ j / 2 ] = true ; } System . out . print ( "2 ▁ " ) ; for ( int i = 3 ; i < n ; i += 2 ) if ( prime [ i / 2 ] == false ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 100 ; normalSieve ( n ) ; } }
import java . util . Scanner ; public class Word { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String word = in . next ( ) ; int uppercase = 0 ; int lowercase = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { char ch = word . charAt ( i ) ; if ( Character . isUpperCase ( ch ) ) { uppercase ++ ; } else { lowercase ++ ; } } if ( uppercase > lowercase ) System . out . println ( word . toUpperCase ( ) ) ; else if ( lowercase > uppercase ) System . out . println ( word . toLowerCase ( ) ) ; else System . out . println ( word . toLowerCase ( ) ) ; } }
import java . io . * ; public class GFG { static int frequencyOfSmallest ( int n , int arr [ ] ) { int mn = arr [ 0 ] , freq = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < mn ) { mn = arr [ i ] ; freq = 1 ; } else if ( arr [ i ] == mn ) freq ++ ; } return freq ; } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 3 , 2 , 3 , 4 , 4 } ; System . out . println ( frequencyOfSmallest ( N , arr ) ) ; } }
public class GFG { static boolean isSubArray ( int A [ ] , int B [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( A [ i ] == B [ j ] ) { i ++ ; j ++ ; if ( j == m ) return true ; } else { i = i - j + 1 ; j = 0 ; } } return false ; } public static void main ( String arr [ ] ) { int A [ ] = { 2 , 3 , 0 , 5 , 1 , 1 , 2 } ; int n = A . length ; int B [ ] = { 3 , 0 , 5 , 1 } ; int m = B . length ; if ( isSubArray ( A , B , n , m ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; import java . util . * ; public class ProblemB { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int n = scn . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = scn . nextInt ( ) ; } int ans = arr [ 0 ] + 1 ; for ( int i = 1 ; i < arr . length ; i ++ ) { ans += Math . abs ( arr [ i ] - arr [ i - 1 ] ) + 2 ; } System . out . println ( ans ) ; } }
public class GFG { static long calculateSum ( int n , int k ) { long res = 1 ; long MOD = 1000000007 ; for ( int i = 0 ; i < k ; i ++ ) { res = ( res * n ) % MOD ; } return res ; } public static void main ( String [ ] args ) { int n = 4 ; int k = 3 ; System . out . print ( calculateSum ( n , k ) ) ; } } ;
import java . util . * ; import java . io . * ; public class Main { int N ; long MOD = 1000000007L ; String [ ] TOKENS = { " A " , " C " , " G " , " T " } ; Map < String , Long > [ ] memo ; Main ( ) { Scanner in = new Scanner ( System . in ) ; N = in . nextInt ( ) ; in . close ( ) ; this . memo = new Map [ N + 1 ] ; for ( int i = 0 ; i < this . memo . length ; ++ i ) { this . memo [ i ] = new HashMap < String , Long > ( ) ; } } long calc ( ) { return dfs ( 0 , " TTT " ) ; } boolean isOK ( String last4 ) { if ( last4 . contains ( " AGC " ) ) { return false ; } for ( int i = 0 ; i < 3 ; ++ i ) { char [ ] vals = last4 . toCharArray ( ) ; vals [ i ] = last4 . charAt ( i + 1 ) ; vals [ i + 1 ] = last4 . charAt ( i ) ; String s = new String ( vals ) ; if ( s . contains ( " AGC " ) ) { return false ; } } return true ; } long dfs ( int current , String last3 ) { if ( this . memo [ current ] . containsKey ( last3 ) ) { return ( Long ) ( this . memo [ current ] . get ( last3 ) ) ; } if ( current == N ) { return 1 ; } long result = 0 ; for ( String c : TOKENS ) { if ( isOK ( last3 + c ) ) { result = ( result + dfs ( current + 1 , last3 . substring ( 1 , last3 . length ( ) ) + c ) ) % MOD ; } } memo [ current ] . put ( last3 , result ) ; return result ; } public static void main ( String [ ] args ) { Main ins = new Main ( ) ; System . out . println ( ins . calc ( ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) . useDelimiter ( " [ , \n ] " ) ; int sum = 0 ; int n = 0 ; int total = 0 ; while ( true ) { try { int value = sc . nextInt ( ) ; int amount = sc . nextInt ( ) ; sum += value * amount ; total += amount ; n ++ ; } catch ( Exception e ) { break ; } } System . out . println ( sum ) ; System . out . println ( Math . round ( ( double ) total / n ) ) ; } }
import java . io . * ; public class GFG { static int MAX = 100 ; static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( sumOfproduct ( n ) ) ; } }
import java . util . * ; public class GFG { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String string1 = in . nextLine ( ) ; System . out . println ( " Enter ▁ the ▁ first ▁ string : ▁ " + string1 ) ; String string2 = in . nextLine ( ) ; System . out . println ( " Enter ▁ the ▁ second ▁ string : ▁ " + string2 ) ; System . out . print ( " Are ▁ both ▁ strings ▁ same : ▁ " ) ; if ( string1 . equals ( string2 ) == true ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; public class GFG { static int pairCount ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) { prime . add ( true ) ; } prime . add ( 0 , Boolean . FALSE ) ; prime . add ( 1 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime . add ( i , Boolean . FALSE ) ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . get ( arr [ i ] ) ) { count ++ ; } } return ( count * ( count - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( pairCount ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int getPrime ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . add ( i , Boolean . TRUE ) ; prime . add ( 1 , Boolean . FALSE ) ; prime . add ( 2 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime . add ( i , Boolean . FALSE ) ; } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . get ( arr [ i ] ) ) { maximum = Math . max ( maximum , arr [ i ] ) ; } } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 10 , 15 , 7 , 6 , 8 , 13 } ; int n = arr . length ; System . out . println ( getPrime ( arr , n ) ) ; } }
import java . math . BigInteger ; public final class p013 { public static void main ( String [ ] args ) { System . out . println ( new p013 ( ) . run ( ) ) ; } public String run ( ) { BigInteger sum = BigInteger . ZERO ; for ( String num : NUMBERS ) sum = sum . add ( new BigInteger ( num ) ) ; return sum . toString ( ) . substring ( 0 , 10 ) ; } private static String [ ] NUMBERS = { "37107287533902102798797998220837590246510135740250" , "46376937677490009712648124896970078050417018260538" , "74324986199524741059474233309513058123726617309629" , "91942213363574161572522430563301811072406154908250" , "23067588207539346171171980310421047513778063246676" , "89261670696623633820136378418383684178734361726757" , "28112879812849979408065481931592621691275889832738" , "44274228917432520321923589422876796487670272189318" , "47451445736001306439091167216856844588711603153276" , "70386486105843025439939619828917593665686757934951" , "62176457141856560629502157223196586755079324193331" , "64906352462741904929101432445813822663347944758178" , "92575867718337217661963751590579239728245598838407" , "58203565325359399008402633568948830189458628227828" , "80181199384826282014278194139940567587151170094390" , "35398664372827112653829987240784473053190104293586" , "86515506006295864861532075273371959191420517255829" , "71693888707715466499115593487603532921714970056938" , "54370070576826684624621495650076471787294438377604" , "53282654108756828443191190634694037855217779295145" , "36123272525000296071075082563815656710885258350721" , "45876576172410976447339110607218265236877223636045" , "17423706905851860660448207621209813287860733969412" , "81142660418086830619328460811191061556940512689692" , "51934325451728388641918047049293215058642563049483" , "62467221648435076201727918039944693004732956340691" , "15732444386908125794514089057706229429197107928209" , "55037687525678773091862540744969844508330393682126" , "18336384825330154686196124348767681297534375946515" , "80386287592878490201521685554828717201219257766954" , "78182833757993103614740356856449095527097864797581" , "16726320100436897842553539920931837441497806860984" , "48403098129077791799088218795327364475675590848030" , "87086987551392711854517078544161852424320693150332" , "59959406895756536782107074926966537676326235447210" , "69793950679652694742597709739166693763042633987085" , "41052684708299085211399427365734116182760315001271" , "65378607361501080857009149939512557028198746004375" , "35829035317434717326932123578154982629742552737307" , "94953759765105305946966067683156574377167401875275" , "88902802571733229619176668713819931811048770190271" , "25267680276078003013678680992525463401061632866526" , "36270218540497705585629946580636237993140746255962" , "24074486908231174977792365466257246923322810917141" , "91430288197103288597806669760892938638285025333403" , "34413065578016127815921815005561868836468420090470" , "23053081172816430487623791969842487255036638784583" , "11487696932154902810424020138335124462181441773470" , "63783299490636259666498587618221225225512486764533" , "67720186971698544312419572409913959008952310058822" , "95548255300263520781532296796249481641953868218774" , "76085327132285723110424803456124867697064507995236" , "37774242535411291684276865538926205024910326572967" , "23701913275725675285653248258265463092207058596522" , "29798860272258331913126375147341994889534765745501" , "18495701454879288984856827726077713721403798879715" , "38298203783031473527721580348144513491373226651381" , "34829543829199918180278916522431027392251122869539" , "40957953066405232632538044100059654939159879593635" , "29746152185502371307642255121183693803580388584903" , "41698116222072977186158236678424689157993532961922" , "62467957194401269043877107275048102390895523597457" , "23189706772547915061505504953922979530901129967519" , "86188088225875314529584099251203829009407770775672" , "11306739708304724483816533873502340845647058077308" , "82959174767140363198008187129011875491310547126581" , "97623331044818386269515456334926366572897563400500" , "42846280183517070527831839425882145521227251250327" , "55121603546981200581762165212827652751691296897789" , "32238195734329339946437501907836945765883352399886" , "75506164965184775180738168837861091527357929701337" , "62177842752192623401942399639168044983993173312731" , "32924185707147349566916674687634660915035914677504" , "99518671430235219628894890102423325116913619626622" , "73267460800591547471830798392868535206946944540724" , "76841822524674417161514036427982273348055556214818" , "97142617910342598647204516893989422179826088076852" , "87783646182799346313767754307809363333018982642090" , "10848802521674670883215120185883543223812876952786" , "71329612474782464538636993009049310363619763878039" , "62184073572399794223406235393808339651327408011116" , "66627891981488087797941876876144230030984490851411" , "60661826293682836764744779239180335110989069790714" , "85786944089552990653640447425576083659976645795096" , "66024396409905389607120198219976047599490197230297" , "64913982680032973156037120041377903785566085089252" , "16730939319872750275468906903707539413042652315011" , "94809377245048795150954100921645863754710598436791" , "78639167021187492431995700641917969777599028300699" , "15368713711936614952811305876380278410754449733078" , "40789923115535562561142322423255033685442488917353" , "44889911501440648020369068063960672322193204149535" , "41503128880339536053299340368006977710650566631954" , "81234880673210146739058568557934581403627822703280" , "82616570773948327592232845941706525094512325230608" , "22918802058777319719839450180888072429661980811197" , "77158542502016545090413245809786882778948721859617" , "72107838435069186155435662884062257473692284509516" , "20849603980134001723930671666823555245252804609722" , "53503534226472524250874054075591789781264330331690" , } ; }
import java . util . * ; import java . io . * ; public class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; int n = arr . length ; printDistinct ( arr , n ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . math . BigInteger ; public class Main { public static final int BIG_NUM = 2000000000 ; public static final int MOD = 1000000007 ; public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String input [ ] = br . readLine ( ) . split ( " \\ s + " ) ; BigInteger A = new BigInteger ( input [ 0 ] ) ; BigInteger B = new BigInteger ( input [ 1 ] ) ; BigInteger ans = A . multiply ( B ) ; System . out . println ( ans ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
public class GFG { static int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; } public static void main ( String [ ] args ) { int a = 10 , b = 17 , n = 3 ; System . out . println ( nth_term ( a , b , n ) ) ; } }
import java . io . * ; public class GFG { static int findSubSequence ( String s , int num ) { int res = 0 ; int i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s . charAt ( i ) - '0' ; i ++ ; num = num >> 1 ; } return res ; } static int combinedSum ( String s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } public static void main ( String [ ] args ) { String s = "123" ; System . out . println ( combinedSum ( s ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; } public static void main ( String args [ ] ) { int a [ ] = { 2 , 5 , 3 , 1 , 7 , 3 , 4 } ; int n = a . length ; System . out . print ( minimumCost ( a , n ) ) ; } }
import java . io . * ; public class GFG { static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; } public static void main ( String args [ ] ) { System . out . println ( " Count ▁ = ▁ " + countMultiples ( 25 ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public final static int SIZE = 26 ; public static int longSubstring ( String str1 , int k ) { int [ ] freq = new int [ SIZE ] ; char [ ] str = str1 . toCharArray ( ) ; int start = 0 ; int maxLen = 0 ; char ch ; int n = str1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ch = str [ i ] ; freq [ ch - ' a ' ] ++ ; if ( freq [ ch - ' a ' ] > k ) { if ( maxLen < ( i - start ) ) maxLen = i - start ; while ( freq [ ch - ' a ' ] > k ) { freq [ str [ start ] - ' a ' ] -- ; start ++ ; } } } if ( maxLen < ( n - start ) ) maxLen = n - start ; return maxLen ; } public static void main ( String argc [ ] ) { String str = " babcaag " ; int k = 1 ; System . out . println ( " Length ▁ = ▁ " + longSubstring ( str , k ) ) ; } }
import java . util . * ; public class class6 { public static void main ( String arg [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char ch [ ] = new char [ n ] ; int s1 = 0 , s2 = 0 ; int i , j = 0 , flag = 0 , dif = 0 ; for ( i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int temp1 = s1 + x ; int temp2 = s2 + y ; if ( Math . abs ( temp1 - s2 ) <= 500 ) { s1 += x ; ch [ j ++ ] = ' A ' ; continue ; } if ( Math . abs ( temp2 - s1 ) <= 500 ) { s2 += y ; ch [ j ++ ] = ' G ' ; continue ; } flag = 1 ; break ; } if ( flag == 1 ) System . out . println ( - 1 ) ; else { String ans = " " ; ans = ans . valueOf ( ch ) ; System . out . println ( ans ) ; } } }
class Solution { public String toHex ( int num ) { String hex_map = "0123456789abcdef " ; if ( num == 0 ) return "0" ; String res = " " ; while ( num != 0 && res . length ( ) < 8 ) { res = hex_map . charAt ( num & 15 ) + res ; num = num >> 4 ; } return res ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int n = 26 ; String out = sObj . toHex ( n ) ; System . out . println ( out ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int count = scan . nextInt ( ) ; printIsland ( n , count ) ; } public static void printIsland ( int n , int count ) { int a = ( n + 1 ) / 2 ; int b = n / 2 ; int max = a * a + b * b ; if ( count > max ) { System . out . println ( " NO " ) ; return ; } System . out . println ( " YES " ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i + j ) % 2 == 0 && count > 0 ) { sb . append ( ' L ' ) ; count -- ; } else { sb . append ( ' S ' ) ; } } sb . append ( " \n " ) ; } System . out . println ( sb ) ; } }
public class GFG { static void longestString ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; } String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( ' a ' + i ) ; } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { String str1 = " geeks " , str2 = " cake " ; longestString ( str1 , str2 ) ; } }
public class GFG { static int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; } static int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } int odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c != 0 ) ans += mul ; mul *= 2 ; } int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; } public static void main ( String args [ ] ) { int l = 1 , r = 4 ; System . out . print ( xorRange ( l , r ) ) ; } }
public class GFG { static void q1 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " Yes " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q2 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q3 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " Yes " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } static void q4 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } static void q0 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } public static void main ( String [ ] args ) { String s = " abbaabb " ; q0 ( s , 0 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] m = new int [ 10000 ] ; int [ ] t = new int [ 1 ] ; int a , b ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( m , 0 ) ; t [ 0 ] = 1 ; a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; for ( int j = 0 ; j <= a * b ; j += a ) { for ( int k = 0 ; k <= max ; k ++ ) { if ( t [ k ] > 0 ) m [ j + k ] += t [ k ] ; } } max += a * b ; t = m . clone ( ) ; } int s = sc . nextInt ( ) ; for ( int i = 0 ; i < s ; i ++ ) System . out . println ( m [ sc . nextInt ( ) ] ) ; } } }
public class GFG { static void findTime ( String T , int K ) { int minutes = ( ( T . charAt ( 0 ) - '0' ) * 10 + T . charAt ( 1 ) - '0' ) * 60 + ( ( T . charAt ( 3 ) - '0' ) * 10 + T . charAt ( 4 ) - '0' ) ; minutes += K ; int hour = ( minutes / 60 ) % 24 ; int min = minutes % 60 ; if ( hour < 10 ) { System . out . print ( "0" + hour + " : " ) ; } else { System . out . print ( hour + " : " ) ; } if ( min < 10 ) { System . out . println ( "0" + min ) ; } else { System . out . println ( min ) ; } } public static void main ( String [ ] args ) { String T = "21:39" ; int K = 43 ; findTime ( T , K ) ; } }
import java . io . * ; public class GFG { static void maxProductSum ( String str , int m ) { int n = str . length ( ) ; int maxProd = Integer . MIN_VALUE , maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str . charAt ( j ) - '0' ) ; sum = sum + ( str . charAt ( j ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( " Maximum ▁ Product ▁ = ▁ " + maxProd ) ; System . out . println ( " Maximum ▁ Sum ▁ = ▁ " + maxSum ) ; } public static void main ( String [ ] args ) { String str = " 3675356291 " ; int m = 5 ; maxProductSum ( str , m ) ; } }
public class GFG { static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } static int minCost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 || m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . print ( minCost ( cost , 2 , 2 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int x [ ] = new int [ n + 1 ] ; int ji [ ] = new int [ n + 1 ] ; int shu [ ] = new int [ n / 2 ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { shu [ i ] = in . nextInt ( ) ; } Arrays . sort ( shu ) ; int l1 = 0 ; int l2 = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { int s1 = i * 2 + 1 ; int s2 = i * 2 + 2 ; int id = shu [ i ] ; if ( id != s1 ) { l1 = l1 + Math . abs ( s1 - id ) ; } if ( id != s2 ) { l2 = l2 + Math . abs ( s2 - id ) ; } } int min = Math . min ( l1 , l2 ) ; System . out . println ( min ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class Main { static int [ ] parents ; static int [ ] weight ; static int [ ] rank ; public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int q = scanner . nextInt ( ) ; parents = new int [ n ] ; weight = new int [ n ] ; rank = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { parents [ i ] = i ; } int type , x , y , z ; for ( int i = 0 ; i < q ; i ++ ) { type = scanner . nextInt ( ) ; x = scanner . nextInt ( ) ; y = scanner . nextInt ( ) ; if ( type == 0 ) { z = scanner . nextInt ( ) ; relate ( x , y , z ) ; } else { diff ( x , y ) ; } } } static int find ( int x ) { if ( x == parents [ x ] ) return x ; else { int r = find ( parents [ x ] ) ; weight [ x ] += weight [ parents [ x ] ] ; return parents [ x ] = r ; } } static int weight ( int x ) { find ( x ) ; return weight [ x ] ; } static void relate ( int x , int y , int z ) { z += weight ( x ) ; z -= weight ( y ) ; x = find ( x ) ; y = find ( y ) ; if ( x == y ) return ; if ( rank [ x ] < rank [ y ] ) { int tmp = x ; x = y ; y = tmp ; z = - z ; } if ( rank [ x ] == rank [ y ] ) { rank [ x ] ++ ; } parents [ y ] = x ; weight [ y ] = z ; } static void diff ( int x , int y ) { if ( find ( x ) == find ( y ) ) { System . out . println ( weight ( y ) - weight ( x ) ) ; } else { System . out . println ( " ? " ) ; } } }
import java . util . * ; public class GFG { static int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int A = 6 , B = 15 , M = 3 ; System . out . print ( sumDivisibles ( A , B , M ) + " \n " ) ; } }
public class GFG { static int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; } public static void main ( String [ ] args ) { int n = 328 ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + n + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ " + countNumbersWith4 ( n ) ) ; } }
import java . io . PrintWriter ; import java . util . * ; public class vfe { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; list . add ( x ) ; list . add ( y ) ; list . add ( y - x ) ; int i = 2 ; while ( ! ( list . get ( i ) == y && list . get ( i - 1 ) == x || list . get ( i ) == 0 && list . get ( i - 1 ) == 0 ) ) { list . add ( list . get ( i ) - list . get ( i - 1 ) ) ; i ++ ; } int k = in . nextInt ( ) ; i -= 1 ; k = k % i ; if ( k == 0 ) { k = i ; } System . out . println ( ( ( list . get ( k - 1 ) % 1000000007 ) + 1000000007 ) % 1000000007 ) ; } }
import java . util . * ; public class Solution { static class INT { int data ; INT ( int d ) { data = d ; } } static void findPostOrderUtil ( int pre [ ] , int n , int minval , int maxval , INT preIndex ) { if ( preIndex . data == n ) return ; if ( pre [ preIndex . data ] < minval || pre [ preIndex . data ] > maxval ) { return ; } int val = pre [ preIndex . data ] ; preIndex . data ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; System . out . print ( val + " ▁ " ) ; } static void findPostOrder ( int pre [ ] , int n ) { INT preIndex = new INT ( 0 ) ; findPostOrderUtil ( pre , n , Integer . MIN_VALUE , Integer . MAX_VALUE , preIndex ) ; } public static void main ( String args [ ] ) { int pre [ ] = { 40 , 30 , 35 , 80 , 100 } ; int n = pre . length ; findPostOrder ( pre , n ) ; } }
import java . util . * ; public class GFG { static int countWays ( int n , int arr [ ] , int k ) { if ( k <= 0 || k >= n ) return 0 ; Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; if ( s . size ( ) <= k ) return 0 ; return s . size ( ) - k ; } public static void main ( String args [ ] ) { int arr [ ] = { 100 , 200 , 400 , 50 } ; int k = 3 ; int n = arr . length ; System . out . println ( countWays ( n , arr , k ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class _250B implements Runnable { private BufferedReader in ; private Object solve ( ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 , n = nextInt ( ) ; i < n ; i ++ ) { String [ ] s = nextToken ( ) . split ( " : " , - 1 ) ; int k = 0 , m = s . length - 1 ; if ( s [ k ] . isEmpty ( ) ) { k ++ ; } if ( s [ m ] . isEmpty ( ) ) { m -- ; } for ( int j = k ; j <= m ; j ++ ) { if ( s [ j ] . isEmpty ( ) ) { for ( int l = 1 , lim = 8 - m + k ; l <= lim ; l ++ ) { sb . append ( "0000" ) ; if ( l < lim ) { sb . append ( ' : ' ) ; } } } else { for ( int l = s [ j ] . length ( ) ; l < 4 ; l ++ ) { sb . append ( '0' ) ; } sb . append ( s [ j ] ) ; } if ( j < m ) { sb . append ( ' : ' ) ; } } sb . append ( ' \n ' ) ; } return sb ; } public static void main ( String [ ] args ) { new _250B ( ) . run ( ) ; } @ Override public void run ( ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( solve ( ) ) ; in . close ( ) ; } catch ( IOException e ) { System . exit ( 0 ) ; } } private String nextToken ( ) throws IOException { return in . readLine ( ) ; } private int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } }
public class GFG { static boolean isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; } static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countInterestingPrimes ( N ) ) ; } }
import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int N = scan . nextInt ( ) ; String previous = scan . next ( ) ; String next ; Set < String > used_words = new HashSet < String > ( ) ; used_words . add ( previous ) ; while ( N > 1 ) { next = scan . next ( ) ; if ( ! ( ( previous . charAt ( previous . length ( ) - 1 ) == next . charAt ( 0 ) ) && used_words . add ( next ) ) ) { System . out . println ( " No " ) ; scan . close ( ) ; return ; } previous = next ; N -- ; } scan . close ( ) ; System . out . println ( " Yes " ) ; } }
public class GFG { static int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; } public static void main ( String [ ] args ) { int div [ ] = { 8 , 3 } ; int rem [ ] = { 2 , 2 } ; int N = div . length ; System . out . println ( findNum ( div , rem , N ) ) ; } }
import java . util . * ; public class GFG { static void segregate0and1 ( int arr [ ] ) { int type0 = 0 ; int type1 = arr . length - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else { type0 ++ ; } } } public static void main ( String [ ] args ) { int [ ] array = { 0 , 1 , 0 , 1 , 1 , 1 } ; segregate0and1 ( array ) ; System . out . print ( " Array ▁ after ▁ segregation ▁ is ▁ " ) ; for ( int a : array ) { System . out . print ( a + " ▁ " ) ; } } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) d [ i ] = sc . nextInt ( ) ; Arrays . sort ( d ) ; int ans = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( d [ i ] != d [ i + 1 ] ) ans ++ ; } System . out . println ( ans ) ; sc . close ( ) ; } }
import java . util . Scanner ; public class ShortestKingPath { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String s = in . next ( ) ; String s1 = in . next ( ) ; char c [ ] = s . toCharArray ( ) ; char c1 [ ] = s1 . toCharArray ( ) ; int diff = c1 [ 0 ] - c [ 0 ] ; int dif = c1 [ 1 ] - c [ 1 ] ; int n = Math . abs ( diff ) ; int m = Math . abs ( dif ) ; String ans = " " ; while ( diff != 0 || dif != 0 ) { if ( diff > 0 ) { ans += " R " ; diff -- ; } if ( diff < 0 ) { ans += " L " ; diff ++ ; } if ( dif > 0 ) { ans += " U " ; dif -- ; } if ( dif < 0 ) { ans += " D " ; dif ++ ; } ans += " \n " ; } System . out . println ( Math . max ( n , m ) ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; long total = 0 ; for ( long i = 0 ; i < h ; i ++ ) { for ( long j = 0 ; j < w ; j ++ ) { long x = sc . nextInt ( ) ; total += x * ( i + 1 ) * ( h - i ) * ( j + 1 ) * ( w - j ) ; } } System . out . println ( total ) ; } }
import java . util . * ; import java . io . * ; public class okabeandfuturegadgetlaboratory { public static void main ( String [ ] args ) throws IOException { BufferedReader fin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( fin . readLine ( ) ) ; int [ ] [ ] lab = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { StringTokenizer st = new StringTokenizer ( fin . readLine ( ) ) ; for ( int j = 0 ; j < n ; j ++ ) { lab [ i ] [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } } boolean ans = true ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < n ; y ++ ) { if ( lab [ x ] [ y ] != 1 ) { int cur = lab [ x ] [ y ] ; boolean isValid = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( lab [ x ] [ i ] + lab [ j ] [ y ] == cur ) { isValid = true ; break ; } } if ( isValid ) { break ; } } if ( ! isValid ) { ans = false ; break ; } } } if ( ! ans ) { break ; } } System . out . println ( ans ? " Yes " : " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long x = in . nextLong ( ) , y = in . nextLong ( ) ; printBin ( fillZero ( Long . toBinaryString ( x & y ) ) ) ; printBin ( fillZero ( Long . toBinaryString ( x | y ) ) ) ; printBin ( fillZero ( Long . toBinaryString ( x ^ y ) ) ) ; } static void printBin ( String str ) { for ( int i = str . length ( ) - 32 ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; System . out . println ( ) ; } static String fillZero ( String str ) { String zero = " " ; if ( str . length ( ) < 32 ) { for ( int i = 0 ; i < 32 - str . length ( ) ; i ++ ) zero += "0" ; } return zero . concat ( str ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long x = in . nextLong ( ) ; printBin ( fillZero ( Long . toBinaryString ( x ) ) ) ; printBin ( fillZero ( Long . toBinaryString ( ~ x ) ) ) ; printBin ( fillZero ( Long . toBinaryString ( x << 1 ) ) ) ; printBin ( fillZero ( Long . toBinaryString ( x >> 1 ) ) ) ; } static void printBin ( String str ) { for ( int i = str . length ( ) - 32 ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; System . out . println ( ) ; } static String fillZero ( String str ) { String zero = " " ; if ( str . length ( ) < 32 ) { for ( int i = 0 ; i < 32 - str . length ( ) ; i ++ ) zero += "0" ; } return zero . concat ( str ) ; } }
import java . util . * ; import static java . lang . Integer . * ; import static java . lang . Long . * ; import static java . lang . Math . * ; import static java . lang . System . * ; public class Main { public static int M = 5 ; public static void main ( String [ ] args ) { int i , j , k ; Scanner sc = new Scanner ( in ) ; int n = parseInt ( sc . next ( ) ) ; char [ ] s = null ; long [ ] ma = new long [ M ] ; for ( i = 0 ; i < n ; i ++ ) { s = sc . next ( ) . toCharArray ( ) ; switch ( s [ 0 ] ) { case ' M ' : ma [ 0 ] ++ ; break ; case ' A ' : ma [ 1 ] ++ ; break ; case ' R ' : ma [ 2 ] ++ ; break ; case ' C ' : ma [ 3 ] ++ ; break ; case ' H ' : ma [ 4 ] ++ ; break ; } } sc . close ( ) ; long ans = 0L ; for ( i = 0 ; i < M - 2 ; i ++ ) { for ( j = i + 1 ; j < M - 1 ; j ++ ) { for ( k = j + 1 ; k < M ; k ++ ) { ans += ma [ i ] * ma [ j ] * ma [ k ] ; } } } out . println ( ans ) ; } }
import java . util . Scanner ; public class InterceptedMessage { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int totalFirstFiles = scanner . nextInt ( ) ; int totalSecondFiles = scanner . nextInt ( ) ; int [ ] firstFiles = new int [ totalFirstFiles ] ; int [ ] secondFiles = new int [ totalSecondFiles ] ; for ( int i = 0 ; i < totalFirstFiles ; i ++ ) { firstFiles [ i ] = scanner . nextInt ( ) ; } for ( int i = 0 ; i < totalSecondFiles ; i ++ ) { secondFiles [ i ] = scanner . nextInt ( ) ; } System . out . println ( interceptedMessage ( firstFiles , secondFiles ) ) ; } private static int interceptedMessage ( int [ ] firstFiles , int [ ] secondFiles ) { int maxFiles = 0 ; int firstPointer = 0 ; int secondPointer = 0 ; boolean hasFinished = false ; int tempFirstNumber = 0 ; int tempSecondNumber = 0 ; while ( ! hasFinished ) { if ( firstPointer == 0 && secondPointer == 0 ) { tempFirstNumber += firstFiles [ firstPointer ] ; tempSecondNumber += secondFiles [ secondPointer ] ; } if ( tempFirstNumber == tempSecondNumber ) { maxFiles ++ ; firstPointer ++ ; secondPointer ++ ; if ( firstPointer > firstFiles . length - 1 && secondPointer > secondFiles . length - 1 ) { break ; } tempFirstNumber = firstFiles [ firstPointer ] ; tempSecondNumber = secondFiles [ secondPointer ] ; } else if ( tempFirstNumber < tempSecondNumber ) { firstPointer ++ ; tempFirstNumber += firstFiles [ firstPointer ] ; } else { secondPointer ++ ; tempSecondNumber += secondFiles [ secondPointer ] ; } } return maxFiles ; } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int a = Integer . parseInt ( sc . next ( ) ) ; String op = sc . next ( ) ; int b = Integer . parseInt ( sc . next ( ) ) ; if ( op . equals ( " ? " ) ) break ; if ( op . equals ( " + " ) ) System . out . println ( a + b ) ; if ( op . equals ( " - " ) ) System . out . println ( a - b ) ; if ( op . equals ( " * " ) ) System . out . println ( a * b ) ; if ( op . equals ( " / " ) ) System . out . println ( a / b ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int N = stdIn . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = stdIn . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == N - 1 ) count ++ ; else if ( A [ i ] == A [ i + 1 ] ) ; else if ( A [ i ] < A [ i + 1 ] ) { while ( A [ i ] <= A [ i + 1 ] ) { i ++ ; if ( i == N - 1 ) break ; } count ++ ; } else { while ( A [ i ] >= A [ i + 1 ] ) { i ++ ; if ( i == N - 1 ) break ; } count ++ ; } } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static int MAX = 256 ; static int countPairs ( String s ) { int cnt [ ] = new int [ MAX ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s . charAt ( i ) ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( countPairs ( s ) ) ; } }
import java . util . * ; class solution { static boolean prime [ ] = new boolean [ 100006 ] ; static void SieveOfEratosthenes ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } static void sortedArray ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == false ) v . add ( arr [ i ] ) ; } Collections . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == true ) System . out . print ( arr [ i ] + " ▁ " ) ; else { System . out . print ( v . get ( j ) + " ▁ " ) ; j ++ ; } } } public static void main ( String args [ ] ) { int n = 6 ; int arr [ ] = { 100 , 11 , 500 , 2 , 17 , 1 } ; sortedArray ( arr , n ) ; } }
import java . util . * ; public class GFG { static void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static int gcdFibonacciFreq ( int arr [ ] , int n ) { HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ) ; int i ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } int gcd = 0 ; for ( Map . Entry < Integer , Integer > it : m . entrySet ( ) ) { if ( hash . contains ( it . getValue ( ) ) ) { gcd = __gcd ( gcd , it . getKey ( ) ) ; } } return gcd ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 } ; int n = arr . length ; System . out . print ( gcdFibonacciFreq ( arr , n ) ) ; } }
public class GFG { static float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; } public static void main ( String [ ] args ) { float a = 4 ; System . out . println ( " ▁ Area ▁ of ▁ semicircle ▁ = ▁ " + String . format ( " % . 4 f " , find_Area ( a ) ) ) ; } }
public class GFG { static int findQuadruples ( int a [ ] , int b [ ] , int c [ ] , int d [ ] , int x , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) for ( int l = 0 ; l < n ; l ++ ) if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) count ++ ; return count ; } public static void main ( String [ ] args ) { int x = 3 ; int a [ ] = { 0 , 1 } ; int b [ ] = { 2 , 0 } ; int c [ ] = { 0 , 1 } ; int d [ ] = { 0 , 1 } ; int n = a . length ; System . out . println ( findQuadruples ( a , b , c , d , x , n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { public static class Query { public int l , r , n ; public Query ( int l , int r , int n ) { this . l = l ; this . r = r ; this . n = n ; } } public static void printSmallest ( String s , Query [ ] q ) { int N = s . length ( ) ; int [ ] [ ] H = new int [ N + 1 ] [ 26 ] ; for ( int i = 1 ; i <= N ; i ++ ) { ++ H [ i ] [ s . charAt ( i - 1 ) - ' a ' ] ; for ( int j = 0 ; j < 26 ; j ++ ) { H [ i ] [ j ] += H [ i - 1 ] [ j ] ; } } int m = q . length ; for ( int j = 0 ; j < m ; j ++ ) { int l = q [ j ] . l , r = q [ j ] . r , n = q [ j ] . n ; int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] ; if ( sum >= n ) { System . out . println ( ( char ) ( ' a ' + i ) ) ; break ; } } } } public static void main ( String args [ ] ) { String s = " afbccdeb " ; Query [ ] q = { new Query ( 2 , 4 , 1 ) , new Query ( 1 , 6 , 4 ) , new Query ( 1 , 8 , 7 ) } ; printSmallest ( s , q ) ; } }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . nio . Buffer ; import java . util . * ; public class Main2 { public static void main ( String [ ] args ) throws IOException , InterruptedException { Scanner sc = new Scanner ( System . in ) ; int testCases = sc . nextInt ( ) ; while ( testCases -- > 0 ) { int activating = sc . nextInt ( ) ; int placing = sc . nextInt ( ) ; String input = sc . next ( ) ; long res = 0 ; if ( placing >= activating ) { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { if ( input . charAt ( i ) == '0' ) continue ; else { res += activating ; while ( i < input . length ( ) && input . charAt ( i ) == '1' ) i ++ ; } } System . out . println ( res ) ; } else { int diff = activating / placing ; int firstOne = - 1 ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { if ( input . charAt ( i ) == '1' ) { firstOne = i ; break ; } } if ( firstOne == - 1 ) System . out . println ( 0 ) ; else { ArrayList < Integer > array = new ArrayList < > ( ) ; int lastOne = firstOne ; for ( int i = firstOne + 1 ; i < input . length ( ) ; i ++ ) { if ( input . charAt ( i ) == '1' ) { array . add ( i - lastOne - 1 ) ; lastOne = i ; } } long res1 = 0 ; for ( int i = 0 ; i < array . size ( ) ; i ++ ) { int first = array . get ( i ) ; if ( first <= diff ) { res1 += ( first ) * placing ; } else { res1 += activating ; } } res1 += activating ; System . out . println ( res1 ) ; } } } } }
import java . util . Scanner ; public class test223 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int x = in . nextInt ( ) ; if ( x == 1 ) { System . out . println ( "2" ) ; } else if ( x == 2 ) { System . out . println ( "1" ) ; } else if ( x % 3 == 0 ) { System . out . println ( x / 3 ) ; } else { System . out . println ( x / 3 + 1 ) ; } } in . close ( ) ; } }
import java . util . * ; import java . io . * ; public class B999 { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; String str = br . readLine ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { if ( t % i == 0 ) { str = reverse ( str , i - 1 ) ; } } System . out . println ( str ) ; } public static String reverse ( String str , int last ) { ArrayList < Character > arr = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { arr . add ( str . charAt ( i ) ) ; } int counterUp = 0 , counterDown = last ; for ( int i = 0 ; i <= last / 2 ; i ++ ) { Collections . swap ( arr , counterUp , counterDown ) ; counterUp ++ ; counterDown -- ; } String result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result += arr . get ( i ) ; } return result ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 } ; int n = arr . length ; printPairs ( arr , n ) ; } }
import java . io . * ; public class GFG { static long doublefactorial ( long n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; } static public void main ( String [ ] args ) { System . out . println ( " Double ▁ factorial " + " ▁ is ▁ " + doublefactorial ( 5 ) ) ; } }
import java . io . * ; public class GFG { static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; } static int minRemovals ( String str ) { if ( str . charAt ( 0 ) == 0)  return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } public static void main ( String [ ] args ) { System . out . println ( minRemovals ( "010010" ) ) ; System . out . println ( minRemovals ( "0100101" ) ) ; } }
import java . util . Arrays ; public class GFG { public static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) - '0' ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; } public static void main ( String [ ] args ) { String num = "1234" ; System . out . println ( sumOfSubstrings ( num ) ) ; } }
import java . io . * ; public class GFG { static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; } public static void main ( String [ ] args ) { int a = 5 , b = 13 , n = 3 ; System . out . println ( findCountOfPairs ( a , b , n ) ) ; } }
public final class p071 { public static void main ( String [ ] args ) { System . out . println ( new p071 ( ) . run ( ) ) ; } private static final int LIMIT = 1000000 ; public String run ( ) { int maxN = 0 ; int maxD = 1 ; for ( int d = 1 ; d <= LIMIT ; d ++ ) { int n = d * 3 / 7 ; if ( d % 7 == 0 ) n -- ; if ( ( long ) n * maxD > ( long ) maxN * d ) { maxN = n ; maxD = d ; } } return Integer . toString ( maxN ) ; } }
public class GFG { static long c [ ] = new long [ 100 ] ; static void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } } static boolean isPrime ( int n ) { coef ( n ) ; c [ 0 ] ++ ; c [ n ] -- ; int i = n ; while ( ( i -- ) > 0 && c [ i ] % n == 0 ) ; return i < 0 ; } public static void main ( String [ ] args ) { int n = 37 ; if ( isPrime ( n ) ) System . out . println ( " Prime " ) ; else System . out . println ( " Not ▁ Prime " ) ; } }
public class GFG { static int count_greater ( int arr [ ] , int n ) { int min = Integer . MAX_VALUE ; int counter = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > min ) { counter ++ ; } if ( arr [ i ] <= min ) { min = arr [ i ] ; } } return counter ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( count_greater ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long x = sc . nextInt ( ) ; List < Long > sweet = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { long a = sc . nextInt ( ) ; sweet . add ( a ) ; } Collections . sort ( sweet ) ; int num = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( x - sweet . get ( num ) >= 0 ) { x = x - sweet . get ( num ) ; num ++ ; } else { break ; } } if ( ( num == N ) && ( x > 0 ) ) { num -= 1 ; } System . out . println ( num ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner leer = new Scanner ( System . in ) ; int casos , x , y , conta = 0 , cont = 0 ; casos = leer . nextInt ( ) ; for ( int i = 0 ; i < casos ; i ++ ) { x = leer . nextInt ( ) ; y = leer . nextInt ( ) ; if ( x > 0 ) { conta ++ ; } else { cont ++ ; } } if ( conta > 1 && cont > 1 ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { while ( true ) { int T = sc . nextInt ( ) , D = sc . nextInt ( ) , L = sc . nextInt ( ) ; if ( T == 0 && D == 0 && L == 0 ) { break ; } int ans = 0 , time = 0 ; for ( int i = 0 ; i < T - 1 ; i ++ ) { int x = sc . nextInt ( ) ; if ( x >= L ) { time = D - 1 ; ans ++ ; } else if ( time != 0 ) { time -- ; ans ++ ; } } sc . nextInt ( ) ; System . out . println ( ans ) ; } } } }
import java . io . * ; import java . util . * ; public class GFG { static int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ; System . out . println ( minimumSwaps ( arr ) ) ; } }
import java . util . PriorityQueue ; import java . util . Queue ; public final class p500 { public static void main ( String [ ] args ) { System . out . println ( new p500 ( ) . run ( ) ) ; } private static final int TARGET = 500500 ; private static final long MODULUS = 500500507 ; public String run ( ) { Queue < Long > queue = new PriorityQueue < > ( ) ; int nextPrime = 2 ; queue . add ( ( long ) nextPrime ) ; long product = 1 ; for ( int i = 0 ; i < TARGET ; i ++ ) { long item = queue . remove ( ) ; product *= item % MODULUS ; product %= MODULUS ; queue . add ( item * item ) ; if ( item == nextPrime ) { do nextPrime ++ ; while ( ! Library . isPrime ( nextPrime ) ) ; queue . add ( ( long ) nextPrime ) ; } } return Long . toString ( product ) ; } }
public class GFG { static void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " ) ; } public static void main ( String [ ] args ) { int [ ] a = { 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 } ; int n = a . length ; findUniquePair ( a , n ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class ValeraX { public static void main ( String [ ] args ) { CustomScanner cs = new CustomScanner ( ) ; int n = cs . nextInt ( ) ; char xch = ' \ u0000' , nxch = ' \ u0000' ; for ( int i = 0 ; i < n ; i ++ ) { String line = cs . next ( ) ; if ( i == 0 ) { xch = line . charAt ( 0 ) ; nxch = line . charAt ( 1 ) ; } if ( xch == nxch ) { System . out . println ( " NO " ) ; return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( j == i || j == n - i - 1 ) { if ( line . charAt ( j ) != xch ) { System . out . println ( " NO " ) ; return ; } } else { if ( line . charAt ( j ) != nxch ) { System . out . println ( " NO " ) ; return ; } } } } System . out . println ( " YES " ) ; } static class CustomScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; public String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextInt ( ) ; } return a ; } } }
import java . util . * ; public class Main { public void doIt ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextLine ( ) ) { String str = sc . nextLine ( ) ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char now = str . charAt ( i ) ; if ( now != ' @ ' ) { System . out . print ( now ) ; } else { i ++ ; int num = str . charAt ( i ) - '0' ; i ++ ; if ( 0 <= num && num <= 9 ) { now = str . charAt ( i ) ; for ( int j = 0 ; j < num ; j ++ ) { System . out . print ( now ) ; } } } } System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { Main obj = new Main ( ) ; obj . doIt ( ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static boolean isMajority ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; else mp . put ( a [ i ] , 1 ) ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ; return false ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 9 , 2 , 2 } ; int n = a . length ; if ( isMajority ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Main { static int [ ] [ ] dp ; static Knap [ ] knaps ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; knaps = new Knap [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { knaps [ i ] = new Knap ( sc . nextInt ( ) , sc . nextInt ( ) ) ; } Arrays . sort ( knaps ) ; dp = new int [ n ] [ w + 1 ] ; System . out . println ( dfw ( n - 1 , w ) ) ; } static int dfw ( int idx , int weight ) { if ( weight < 0 ) { return Integer . MIN_VALUE ; } if ( idx < 0 ) { return 0 ; } if ( dp [ idx ] [ weight ] != 0 ) { return dp [ idx ] [ weight ] ; } if ( weight % knaps [ idx ] . weight == 0 ) { return dp [ idx ] [ weight ] = weight / knaps [ idx ] . weight * knaps [ idx ] . value ; } int max = 0 ; for ( int i = 0 ; i * knaps [ idx ] . weight <= weight ; i ++ ) { max = Math . max ( max , dfw ( idx - 1 , weight - knaps [ idx ] . weight * i ) + knaps [ idx ] . value * i ) ; } return dp [ idx ] [ weight ] = max ; } static class Knap implements Comparable < Knap > { int value ; int weight ; public Knap ( int value , int weight ) { this . value = value ; this . weight = weight ; } public int compareTo ( Knap another ) { return value * another . weight - another . value * weight ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { doIt ( ) ; } public static void doIt ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n != - 1 ) { double rad = 0 ; double hyp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { rad += Math . atan ( 1 / hyp ) ; hyp = Math . sqrt ( hyp * hyp + 1 ) ; } System . out . println ( hyp * Math . cos ( rad ) ) ; System . out . println ( hyp * Math . sin ( rad ) ) ; n = sc . nextInt ( ) ; } } }
import java . util . Arrays ; public class GFG { static void printKMissing ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { System . out . print ( curr + " ▁ " ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { System . out . print ( curr + " ▁ " ) ; curr ++ ; count ++ ; } } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 } ; int n = arr . length ; int k = 3 ; printKMissing ( arr , n , k ) ; } }
import java . util . * ; public class GFG { static void printNumbers ( int a [ ] , int n ) { Map < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; for ( int j = 1 ; j * j <= num ; j ++ ) { if ( num % j == 0 ) { if ( j != 1 ) { if ( mpp . containsKey ( j ) ) { mpp . put ( j , mpp . get ( j ) + 1 ) ; } else { mpp . put ( j , 1 ) ; } } if ( ( num / j ) != j ) { if ( mpp . containsKey ( num / j ) ) { mpp . put ( num / j , mpp . get ( num / j ) + 1 ) ; } else { mpp . put ( num / j , 1 ) ; } } } } } int maxi = 0 ; for ( Map . Entry < Integer , Integer > it : mpp . entrySet ( ) ) { maxi = Math . max ( it . getValue ( ) , maxi ) ; } for ( Map . Entry < Integer , Integer > it : mpp . entrySet ( ) ) { if ( it . getValue ( ) == maxi ) System . out . print ( it . getKey ( ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 12 , 15 , 27 , 20 , 40 } ; int n = a . length ; printNumbers ( a , n ) ; } }
import java . util . * ; public class cf1146B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; StringBuilder str = new StringBuilder ( scan . next ( ) ) ; int index = str . indexOf ( " a " ) ; int aCnt = 0 ; while ( index != - 1 ) { aCnt ++ ; index = str . indexOf ( " a " , index + 1 ) ; } int sLength = ( str . length ( ) - aCnt ) / 2 ; String s = str . substring ( 0 , str . length ( ) - sLength ) ; String s2 = s ; String r = str . substring ( str . length ( ) - sLength ) ; s = s . replaceAll ( " a " , " " ) ; if ( s . equals ( r ) ) { System . out . println ( s2 ) ; } else { System . out . println ( " : ( " ) ; } } }
import java . io . * ; import java . util . * ; public class voting { public static void main ( String args [ ] ) { FScanner in = new FScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; int ans = 0 , max = 0 ; int a [ ] = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int b = in . nextInt ( ) ; a [ b ] ++ ; if ( a [ b ] > max ) { max = a [ b ] ; ans = b ; } } out . print ( ans ) ; out . close ( ) ; } static class FScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer sb = new StringTokenizer ( " " ) ; String next ( ) { while ( ! sb . hasMoreTokens ( ) ) { try { sb = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { } } return sb . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
public class GFG { static int checkIfStartsWithCapital ( String str ) { if ( str . charAt ( 0 ) >= ' A ' && str . charAt ( 0 ) <= ' Z ' ) return 1 ; else return 0 ; } static void check ( String str ) { if ( checkIfStartsWithCapital ( str ) == 1 ) System . out . println ( " Accepted " ) ; else System . out . println ( " Not ▁ Accepted " ) ; } public static void main ( String [ ] args ) { String str = " GeeksforGeeks " ; check ( str ) ; str = " geeksforgeeks " ; check ( str ) ; } }
public class GFG { static float getAvg ( float prev_avg , float x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; } static void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; System . out . println ( " Average ▁ of ▁ " + ( i + 1) + " ▁ numbers ▁ is ▁ " + String . format ( " % . 1 f " , avg ) ) ; } return ; } public static void main ( String [ ] args ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }
public final class p050 { public static void main ( String [ ] args ) { System . out . println ( new p050 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT ) ; int [ ] primes = Library . listPrimes ( LIMIT ) ; long maxSum = 0 ; int maxRun = - 1 ; for ( int i = 0 ; i < primes . length ; i ++ ) { int sum = 0 ; for ( int j = i ; j < primes . length ; j ++ ) { sum += primes [ j ] ; if ( sum > LIMIT ) break ; else if ( j - i > maxRun && sum > maxSum && isPrime [ sum ] ) { maxSum = sum ; maxRun = j - i ; } } } return Long . toString ( maxSum ) ; } }
import java . util . * ; public class GFG { static int lis ( int [ ] arr , int n ) { int max = 0 ; int [ ] lst = new int [ n ] ; Arrays . fill ( lst , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lst [ i ] < lst [ j ] + 1 ) lst [ i ] = lst [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( max < lst [ i ] ) max = lst [ i ] ; return max ; } public static void main ( String [ ] args ) { int [ ] arr = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ lst ▁ is ▁ " + lis ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int k = ( int ) Math . log10 ( b ) + 1 ; a = ( int ) ( a * Math . pow ( 10 , k ) + b ) ; double yono = Math . sqrt ( a ) ; if ( yono - Math . ceil ( yono ) == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; import java . lang . * ; public class GFG { public static int [ ] fix ( int [ ] A ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { s . add ( A [ i ] ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( s . contains ( i ) ) A [ i ] = i ; else A [ i ] = - 1 ; } return A ; } public static void main ( String [ ] args ) { int A [ ] = { - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 } ; System . out . println ( Arrays . toString ( fix ( A ) ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { boolean main ( ) throws IOException { Scanner sc = new Scanner ( systemin ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int sum = a + b + c + d ; int s1 = Math . abs ( sum - ( a + b ) * 2 ) ; int s2 = Math . abs ( sum - ( a + c ) * 2 ) ; int s3 = Math . abs ( sum - ( a + d ) * 2 ) ; int min = Math . min ( s1 , Math . min ( s2 , s3 ) ) ; System . out . printf ( " % d \n " , min ) ; sc . close ( ) ; return false ; } PrintStream log ; PrintStream result = System . out ; BufferedReader systemin ; static Main instance = new Main ( ) ; Main ( ) { systemin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; log = new PrintStream ( new OutputStream ( ) { public void write ( int b ) { } } ) ; } public static void main ( String [ ] args ) throws IOException { instance . main ( ) ; instance . systemin . close ( ) ; } }
public class GFG { static class Node { int data ; Node prev , next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . prev = null ; new_node . next = ( head_ref ) ; if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ; ( head_ref ) = new_node ; return head_ref ; } static Node makeOddNode ( Node head_ref , int A [ ] , int n ) { Node ptr = head_ref ; Node next ; int i = 0 ; while ( ptr != null ) { next = ptr . next ; if ( ptr . data % 2 == 0 ) { ptr . data = A [ i ] ; i ++ ; } ptr = next ; } return head_ref ; } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = null ; int Arr [ ] = { 3 , 5 , 23 , 17 , 1 } ; head = push ( head , 4 ) ; head = push ( head , 7 ) ; head = push ( head , 8 ) ; head = push ( head , 9 ) ; head = push ( head , 6 ) ; int n = Arr . length ; System . out . print ( " Original ▁ List : ▁ " ) ; printList ( head ) ; System . out . println ( ) ; head = makeOddNode ( head , Arr , n ) ; System . out . print ( " New ▁ odd ▁ List : ▁ " ) ; printList ( head ) ; } }
import java . io . * ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = " " ; int [ ] [ ] dp = new int [ 11 ] [ 331 ] ; boolean [ ] use = new boolean [ 10 ] ; dfs ( 1 , 0 , dp , use ) ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] values = line . split ( " ▁ " ) ; int n = Integer . parseInt ( values [ 0 ] ) ; int s = Integer . parseInt ( values [ 1 ] ) ; if ( n > 10 || s > 330 ) { System . out . println ( "0" ) ; continue ; } System . out . println ( dp [ n ] [ s ] ) ; } } private static void dfs ( int depth , int sum , int [ ] [ ] dp , boolean [ ] use ) { dp [ depth - 1 ] [ sum ] ++ ; for ( int i = 0 ; i <= 9 ; i ++ ) { if ( ! use [ i ] ) { use [ i ] = true ; dfs ( depth + 1 , sum + depth * i , dp , use ) ; use [ i ] = false ; } } } }
import java . util . * ; public class GFG { static long mod = 1000000007 ; static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static long powmod ( long a , long n ) { if ( n == 0 ) return 1 ; long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) return ( pt * a ) % mod ; else return pt ; } static long CountSubset ( int [ ] arr , int n ) { long ans = powmod ( 2 , n - 1 ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( CountSubset ( arr , n ) ) ; } }
public class GFG { static final int MAX = 1000001 ; static int primeUpto [ ] = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { int isPrime [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = 1 ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) primeUpto [ i ] ++ ; } } static int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } ans = ans != 0 ? N - ans + 1 : 0 ; return ans ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; System . out . println ( countOfNumbers ( N , K ) ) ; } }
public class GFG { static int countOperations ( int n ) { int i = 2 ; while ( ( i * i ) < n && ( n % i ) > 0 ) i += 1 ; if ( ( i * i ) > n ) i = n ; return ( 1 + ( n - i ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countOperations ( n ) ) ; } }
import java . io . PrintWriter ; import java . util . Scanner ; public class Main { static void exec ( Scanner in , PrintWriter out ) { in . nextInt ( ) ; int Q = in . nextInt ( ) ; String S = in . next ( ) ; int [ ] t = new int [ S . length ( ) ] ; for ( int i = 0 ; i < t . length - 1 ; i += 1 ) { if ( S . charAt ( i ) == ' A ' && S . charAt ( i + 1 ) == ' C ' ) { t [ i + 1 ] = t [ i ] + 1 ; } else { t [ i + 1 ] = t [ i ] ; } } for ( int i = 0 ; i < Q ; i += 1 ) { int l = in . nextInt ( ) ; int r = in . nextInt ( ) ; out . println ( t [ r - 1 ] - t [ l - 1 ] ) ; } } public static void main ( String [ ] args ) { PrintWriter w = new PrintWriter ( System . out ) ; exec ( new Scanner ( System . in ) , w ) ; w . flush ( ) ; } }
import java . util . Scanner ; public class A_FindDivisible { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String f ; int t ; String l , r ; t = scanner . nextInt ( ) ; while ( t > 0 ) { try { l = scanner . next ( ) ; r = scanner . next ( ) ; System . out . println ( l + " ▁ " + Integer . parseInt ( l ) * 2 ) ; t -- ; } catch ( Exception e ) { System . exit ( 0 ) ; } } System . exit ( 0 ) ; } }
public final class p249 { public static void main ( String [ ] args ) { System . out . println ( new p249 ( ) . run ( ) ) ; } private static final int LIMIT = 5000 ; private static final long MODULUS = 10000000000000000L ; public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT * LIMIT / 2 ) ; long [ ] numSubsets = new long [ LIMIT * LIMIT / 2 ] ; numSubsets [ 0 ] = 1 ; int maxSum = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( ! isPrime [ i ] ) continue ; maxSum += i ; for ( int j = maxSum ; j >= i ; j -- ) { long temp = numSubsets [ j ] + numSubsets [ j - i ] ; if ( temp < MODULUS ) numSubsets [ j ] = temp ; else numSubsets [ j ] = temp - MODULUS ; } } long sum = 0 ; for ( int i = 0 ; i < numSubsets . length ; i ++ ) { if ( isPrime [ i ] ) sum = ( sum + numSubsets [ i ] ) % MODULUS ; } return Long . toString ( sum ) ; } }
public class GFG { static int countOddNumber ( int row_num ) { int count = 0 ; while ( row_num > 0 ) { count += row_num & 1 ; row_num >>= 1 ; } return ( 1 << count ) ; } static void gouldSequence ( int n ) { for ( int row_num = 0 ; row_num < n ; row_num ++ ) { System . out . print ( countOddNumber ( row_num ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 16 ; gouldSequence ( n ) ; } }
import java . util . Vector ; public class GFG { static int deno [ ] = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; static int n = deno . length ; static void findMin ( int V ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . elementAt ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 93 ; System . out . print ( " Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ for ▁ " + n + " ▁ : ▁ " ) ; findMin ( n ) ; } }
import java . util . Arrays ; public final class p052 { public static void main ( String [ ] args ) { System . out . println ( new p052 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 1 ; ; i ++ ) { if ( i > Integer . MAX_VALUE / 6 ) throw new ArithmeticException ( " Overflow " ) ; if ( multiplesHaveSameDigits ( i ) ) return Integer . toString ( i ) ; } } private static boolean multiplesHaveSameDigits ( int x ) { for ( int i = 2 ; i <= 6 ; i ++ ) { if ( ! Arrays . equals ( toSortedDigits ( x ) , toSortedDigits ( i * x ) ) ) return false ; } return true ; } private static char [ ] toSortedDigits ( int x ) { char [ ] result = Integer . toString ( x ) . toCharArray ( ) ; Arrays . sort ( result ) ; return result ; } }
import java . util . * ; class solution { static long count ( int arr [ ] , int n , int x ) { if ( x == 1 ) { long ans = ( long ) Math . pow ( 2 , n ) - 1 ; return ans ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) count ++ ; } long ans = ( long ) Math . pow ( 2 , count ) - 1 ; return ans ; } public static void main ( String args [ ] ) { int [ ] arr = { 2 , 4 , 3 , 5 } ; int n = arr . length ; int x = 1 ; System . out . println ( count ( arr , n , x ) ) ; } }
import java . io . * ; public class GFG { static int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 6 } ; int n = arr . length ; System . out . print ( findEle ( arr , n ) ) ; } }
public class GFG { static char findExtraCharcter ( char [ ] strA , char [ ] strB ) { int [ ] m1 = new int [ 256 ] ; for ( int i = 0 ; i < strB . length ; i ++ ) m1 [ strB [ i ] ] ++ ; for ( int i = 0 ; i < strA . length ; i ++ ) m1 [ strA [ i ] ] -- ; for ( int i = 0 ; i < m1 . length ; i ++ ) { if ( m1 [ i ] == 1 ) return ( char ) i ; } return Character . MIN_VALUE ; } public static void main ( String [ ] args ) { String strA = " abcd " ; String strB = " cbdad " ; System . out . println ( findExtraCharcter ( strA . toCharArray ( ) , strB . toCharArray ( ) ) ) ; } }
import java . awt . geom . Line2D ; import java . awt . geom . Point2D ; import java . awt . geom . Point2D . Double ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . PriorityQueue ; import java . util . Scanner ; import java . util . TreeSet ; import java . lang . Object ; public class Main { Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new aoj1216 ( ) . doIt ( ) ; } class aoj1216 { int a [ ] = new int [ 101 ] ; int b [ ] = new int [ 101 ] ; void doIt ( ) { for ( int i = 0 ; i < 101 ; i ++ ) a [ i ] = i * i * i ; for ( int i = 0 ; i < 101 ; i ++ ) b [ i ] = i * ( i + 1 ) * ( i + 2 ) / 6 ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int num = 0 ; for ( int i = 0 ; i < 101 ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { if ( a [ i ] + b [ j ] <= n ) num = Math . max ( num , a [ i ] + b [ j ] ) ; } } System . out . println ( num ) ; } } } }
import java . util . ArrayDeque ; import java . util . Deque ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) { sc . close ( ) ; break ; } String [ ] [ ] conv = new String [ n ] [ 2 ] ; for ( int i = 0 ; i < conv . length ; i ++ ) { conv [ i ] [ 0 ] = sc . next ( ) ; conv [ i ] [ 1 ] = sc . next ( ) ; } String before = sc . next ( ) ; String after = sc . next ( ) ; Deque < String > deque = new ArrayDeque < String > ( ) ; deque . addLast ( before ) ; int depth = 0 ; boolean convertable = false ; bfs : while ( ! deque . isEmpty ( ) ) { depth ++ ; int size = deque . size ( ) ; for ( int q = 0 ; q < size ; q ++ ) { String poll = deque . pollFirst ( ) ; for ( int i = 0 ; i < conv . length ; i ++ ) { String test = poll . replaceAll ( conv [ i ] [ 0 ] , conv [ i ] [ 1 ] ) ; if ( test . equals ( poll ) ) { continue ; } else if ( test . equals ( after ) ) { convertable = true ; break bfs ; } else if ( test . length ( ) <= after . length ( ) ) { deque . addLast ( test ) ; } } } } if ( convertable ) { System . out . println ( depth ) ; } else { System . out . println ( - 1 ) ; } } } }
import java . util . * ; import java . io . * ; import static java . lang . Math . min ; import static java . lang . Math . max ; import static java . lang . Math . abs ; public class Practice { static Scanner scn = new Scanner ( System . in ) ; static StringBuilder sb = new StringBuilder ( ) ; static PrintWriter out = new PrintWriter ( System . out ) ; public static void main ( String [ ] HastaLaVistaLa ) { int t = 1 ; for ( int tests = 0 ; tests < t ; tests ++ ) solve ( ) ; out . println ( sb ) ; out . close ( ) ; } public static void solve ( ) { int n = scn . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = scn . nextInt ( ) ; int [ ] freq = new int [ 1010 ] ; int can = ( n + 1 ) ; for ( int i : a ) { freq [ i ] ++ ; if ( freq [ i ] > can / 2 ) { sb . append ( " NO " ) ; return ; } } sb . append ( " YES " ) ; } }
public class AAB { static int maxSumPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 ) { int max1 = Integer . MIN_VALUE ; int max2 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( arr1 [ i ] > max1 ) max1 = arr1 [ i ] ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( arr2 [ i ] > max2 ) max2 = arr2 [ i ] ; } return max1 + max2 ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 10 , 2 , 3 } ; int arr2 [ ] = { 3 , 4 , 7 } ; int n1 = arr1 . length ; int n2 = arr2 . length ; System . out . println ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) ; } }
public class GFG { static int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int min = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . abs ( min ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; } public static void main ( String [ ] args ) { int op [ ] = { - 60 , 65 , - 1 , 14 , - 25 } ; int n = op . length ; int k = 100000 ; System . out . print ( operations ( op , n , k ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { public static int [ ] pref = new int [ 100010 ] ; static int isPerfectCube ( int x ) { double cr = Math . round ( Math . cbrt ( x ) ) ; if ( cr * cr * cr == ( double ) x ) return x ; return 0 ; } static void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; } } static void printSum ( int L , int R ) { long sum = pref [ R ] - pref [ L - 1 ] ; System . out . print ( sum + " ▁ " ) ; } public static void main ( String [ ] args ) { compute ( ) ; int Q = 4 ; int [ ] [ ] arr = { { 1 , 10 } , { 1 , 100 } , { 2 , 25 } , { 4 , 50 } } ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; int N = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int R = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int L = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int [ ] po = new int [ N ] ; int [ ] c = new int [ N ] ; int now = 0 ; int index = 0 ; for ( int i = 0 ; i < R ; i ++ ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; int d = Integer . parseInt ( tokenizer . nextToken ( ) ) - 1 ; int t = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int x = Integer . parseInt ( tokenizer . nextToken ( ) ) ; c [ index ] += t - now ; po [ d ] += x ; now = t ; if ( x > 0 ) { if ( d == index ) continue ; if ( po [ index ] < po [ d ] ) index = d ; else if ( po [ index ] == po [ d ] && index > d ) index = d ; } else { if ( d != index ) continue ; int maxp = Integer . MIN_VALUE ; for ( int j = 0 ; j < N ; j ++ ) { if ( maxp < po [ j ] ) { maxp = po [ j ] ; index = j ; } } } } c [ index ] += L - now ; int ans = 0 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( c [ i ] > max ) { max = c [ i ] ; ans = i ; } } System . out . println ( ans + 1 ) ; } }
import java . io . * ; public class GFG { static int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( n + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " ) ; System . out . println ( centered_cube ( n ) ) ; n = 10 ; System . out . print ( n + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " ) ; System . out . println ( centered_cube ( n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; import java . util . * ; import static java . lang . System . out ; import static java . lang . Math . * ; public class pre132 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; int tc = obj . nextInt ( ) ; while ( tc -- != 0 ) { int n = obj . nextInt ( ) ; char arr [ ] = obj . next ( ) . toCharArray ( ) ; int r = n - 1 , l = - 1 ; while ( r >= 0 && arr [ r ] == '1' ) r -- ; while ( l + 1 < n && arr [ 0 ] == '0' && arr [ l + 1 ] == '0' ) l ++ ; boolean flag [ ] = new boolean [ n ] ; for ( int i = 0 ; i <= l ; i ++ ) flag [ i ] = true ; for ( int i = n - 1 ; i >= r && i >= 0 ; i -- ) flag [ i ] = true ; for ( int i = 0 ; i < n ; i ++ ) if ( flag [ i ] ) out . print ( arr [ i ] ) ; out . println ( ) ; } } }
import java . lang . Math ; public class GFG { public static int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } }
public class Test { public static void main ( String [ ] args ) { System . out . println ( isPower ( 10 , 1 ) ? " True " : " False " ) ; System . out . println ( isPower ( 1 , 20 ) ? " True " : " False " ) ; System . out . println ( isPower ( 2 , 128 ) ? " True " : " False " ) ; System . out . println ( isPower ( 2 , 30 ) ? " True " : " False " ) ; } public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; } }
public class Test { public static void main ( String [ ] args ) { System . out . println ( isPower ( 10 , 1 ) ? 1 : 0 ) ; System . out . println ( isPower ( 1 , 20 ) ? 1 : 0 ) ; System . out . println ( isPower ( 2 , 128 ) ? 1 : 0 ) ; System . out . println ( isPower ( 2 , 30 ) ? 1 : 0 ) ; } public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; } }
import java . util . * ; public class GFG { static int minimumValue ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 21 , 5 , 3 , 8 } , k = 3 ; int n = arr . length ; System . out . print ( minimumValue ( arr , n , k ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N ; N = sc . nextInt ( ) ; Set < String > vs = new HashSet < > ( ) ; Map < String , Set < String > > indeg = new HashMap < > ( ) ; Map < String , Set < String > > outdeg = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { String u , d , rel ; u = ' u ' + sc . next ( ) ; rel = sc . next ( ) ; d = ' d ' + sc . next ( ) ; vs . add ( u ) ; vs . add ( d ) ; indeg . putIfAbsent ( u , new HashSet < > ( ) ) ; indeg . putIfAbsent ( d , new HashSet < > ( ) ) ; outdeg . putIfAbsent ( u , new HashSet < > ( ) ) ; outdeg . putIfAbsent ( d , new HashSet < > ( ) ) ; if ( rel . equals ( " lock " ) ) { indeg . get ( u ) . add ( d ) ; outdeg . get ( d ) . add ( u ) ; } else { indeg . get ( d ) . add ( u ) ; outdeg . get ( u ) . add ( d ) ; } } Queue < String > que = new ArrayDeque < > ( ) ; for ( String v : indeg . keySet ( ) ) { if ( indeg . get ( v ) . size ( ) == 0 ) { que . offer ( v ) ; } } while ( ! que . isEmpty ( ) ) { String u = que . poll ( ) ; for ( String v : outdeg . get ( u ) ) { indeg . get ( v ) . remove ( u ) ; if ( indeg . get ( v ) . size ( ) == 0 ) { que . offer ( v ) ; } } vs . remove ( u ) ; } System . out . println ( vs . size ( ) == 0 ? 0 : 1 ) ; } }
public class GFG { static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }
public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int findLCM ( int arr [ ] , int n ) { int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { lcm = ( lcm * arr [ i ] ) / __gcd ( arr [ i ] , lcm ) ; } return lcm ; } static int countNumbers ( int arr [ ] , int n , int l , int r ) { int lcm = findLCM ( arr , n ) ; int count = ( r / lcm ) - ( ( l - 1 ) / lcm ) ; return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 2 } ; int n = arr . length ; int l = 1 , r = 10 ; System . out . println ( countNumbers ( arr , n , l , r ) ) ; } }
import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int a = Math . min ( n , 4 ) ; int [ ] num = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) num [ i ] = scanner . nextInt ( ) ; Arrays . sort ( num ) ; List < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < a ; i ++ ) for ( int j = 0 ; j < a ; j ++ ) { if ( i == j ) continue ; ans . add ( Integer . valueOf ( String . valueOf ( num [ i ] ) + String . valueOf ( num [ j ] ) ) ) ; } Collections . sort ( ans ) ; System . out . println ( ans . get ( 2 ) ) ; } }
import java . io . * ; import java . util . * ; public class Run { public static void main ( String [ ] Z ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder op = new StringBuilder ( ) ; StringTokenizer stz ; int T = Integer . parseInt ( br . readLine ( ) ) ; while ( T -- > 0 ) { int n = Integer . parseInt ( br . readLine ( ) ) ; stz = new StringTokenizer ( br . readLine ( ) ) ; int [ ] a = new int [ 4 * n ] ; for ( int i = 0 ; i < n << 2 ; i ++ ) { a [ i ] = Integer . parseInt ( stz . nextToken ( ) ) ; } boolean yes = true ; Arrays . sort ( a ) ; int area = a [ 0 ] * a [ a . length - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { int lf = i * 2 , rg = 4 * n - ( i * 2 ) - 1 ; if ( ( a [ lf ] != a [ lf + 1 ] ) || ( a [ rg ] != a [ rg - 1 ] ) || ( a [ lf ] * a [ rg ] != area ) ) { yes = false ; break ; } } if ( yes ) op . append ( " YES \n " ) ; else op . append ( " NO \n " ) ; } System . out . println ( op ) ; } }
import java . util . * ; public class GFG { static int MinDeletion ( int a [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int x = i . getKey ( ) ; int frequency = i . getValue ( ) ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = a . length ; System . out . println ( MinDeletion ( a , n ) ) ; } }
public class DeleteN { public static void main ( String args [ ] ) { int in = 1234 ; String inp = Integer . toString ( in ) ; int del = 3 ; System . out . println ( " num _ after _ deleting _ from _ starting ▁ " + fromStart ( inp , del ) ) ; System . out . println ( " num _ after _ deleting _ from _ ending ▁ " + fromEnd ( inp , del ) ) ; } static String fromStart ( String inp , int del ) { try { String inp1 = inp . substring ( 0 , del - 1 ) ; String inp2 = inp . substring ( del , inp . length ( ) ) ; return inp1 + inp2 ; } catch ( Exception e ) { return " Check ▁ Input " ; } } static String fromEnd ( String inp , int del ) { try { String inp1 = inp . substring ( 0 , inp . length ( ) - del ) ; String inp2 = inp . substring ( inp . length ( ) - del + 1 , inp . length ( ) ) ; return inp1 + inp2 ; } catch ( Exception e ) { return " Check ▁ Input " ; } } }
import java . io . * ; public class GFG { static int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; boolean flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; } public static void main ( String [ ] args ) { int n = 200 ; System . out . println ( nondecdigits ( n ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int x1 = in . nextInt ( ) , y1 = in . nextInt ( ) , x2 = in . nextInt ( ) , y2 = in . nextInt ( ) ; if ( x1 == x2 ) { int dif = Math . abs ( y1 - y2 ) ; pw . println ( ( x1 + dif ) + " ▁ " + y1 + " ▁ " + ( x1 + dif ) + " ▁ " + y2 ) ; } else if ( y1 == y2 ) { int dif = Math . abs ( x1 - x2 ) ; pw . println ( ( x1 ) + " ▁ " + ( y1 + dif ) + " ▁ " + ( x2 ) + " ▁ " + ( y2 + dif ) ) ; } else if ( Math . abs ( x1 - x2 ) == Math . abs ( y1 - y2 ) ) { pw . println ( x1 + " ▁ " + y2 + " ▁ " + x2 + " ▁ " + y1 ) ; } else { pw . println ( - 1 ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class BusGame { public static boolean canTake ( int xNeeded , int xAvailable , int yNeeded , int yAvailable ) { if ( xNeeded > xAvailable ) return false ; if ( yNeeded > yAvailable ) return false ; return true ; } public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int x = Integer . parseInt ( st . nextToken ( ) ) ; int y = Integer . parseInt ( st . nextToken ( ) ) ; int turn = 0 ; while ( true ) { if ( turn % 2 == 0 ) { if ( canTake ( 2 , x , 2 , y ) ) { x -= 2 ; y -= 2 ; } else if ( canTake ( 1 , x , 12 , y ) ) { x -= 1 ; y -= 12 ; } else if ( canTake ( 0 , x , 22 , y ) ) { y -= 22 ; } else { System . out . println ( " Hanako " ) ; return ; } } else { if ( canTake ( 0 , x , 22 , y ) ) { y -= 22 ; } else if ( canTake ( 1 , x , 12 , y ) ) { x -= 1 ; y -= 12 ; } else if ( canTake ( 2 , x , 2 , y ) ) { x -= 2 ; y -= 2 ; } else { System . out . println ( " Ciel " ) ; return ; } } turn ++ ; } } }
import java . io . * ; import java . util . StringTokenizer ; public class DZYLovesChessboard { public static void main ( String [ ] args ) throws FileNotFoundException { FastReader in = new FastReader ( ) ; PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; char [ ] [ ] arr = new char [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . nextLine ( ) . toCharArray ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { boolean w = i % 2 == 0 ; for ( int j = 0 ; j < m ; j ++ ) { w = ! w ; if ( arr [ i ] [ j ] == ' . ' ) out . print ( w ? ' W ' : ' B ' ) ; else out . print ( ' - ' ) ; } out . println ( ) ; } out . close ( ) ; } private static class FastReader { BufferedReader br ; StringTokenizer st ; FastReader ( ) throws FileNotFoundException { br = new BufferedReader ( new InputStreamReader ( System . getProperty ( " ONLINE _ JUDGE " ) == null ? new FileInputStream ( " input . txt " ) : System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . util . Scanner ; public class FlippingGame { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; if ( scanner . hasNext ( ) ) { int n = scanner . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = scanner . nextInt ( ) ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int x = 0 ; int brr [ ] = new int [ n ] ; for ( int k : arr ) brr [ x ++ ] = k ; for ( int k = i ; k <= j ; k ++ ) { if ( brr [ k ] == 0 ) brr [ k ] = 1 ; else brr [ k ] = 0 ; } int count = checKNo ( brr ) ; if ( count > max ) max = count ; } } if ( n == 1 ) { if ( arr [ 0 ] == 1 ) System . out . println ( 0 ) ; else System . out . println ( 1 ) ; } else { System . out . println ( max ) ; } } } private static int checKNo ( int [ ] brr ) { int val = 0 ; for ( int i : brr ) if ( i == 1 ) ++ val ; return val ; } }
import java . util . HashMap ; public class Test { static int countDistictSubarray ( int arr [ ] , int n ) { HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) { public Integer get ( Object key ) { if ( ! containsKey ( key ) ) return 0 ; return super . get ( key ) ; } } ; for ( int i = 0 ; i < n ; ++ i ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) ; if ( vis . get ( arr [ right ] ) == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) ; if ( vis . get ( arr [ left ] ) == 0 ) -- window ; } return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 1 , 3 , 2 , 3 } ; System . out . println ( countDistictSubarray ( arr , arr . length ) ) ; } }
import java . util . Scanner ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . nio . charset . MalformedInputException ; import java . util . StringTokenizer ; import java . util . Arrays ; import java . util . HashSet ; public class Cv { public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; Scanner sc = new Scanner ( System . in ) ; PrintWriter o = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int max = 0 ; while ( n -- > 0 ) { int f = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; if ( max < f + t ) { max = f + t ; } } o . println ( Math . max ( max , s ) ) ; o . close ( ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; public String next ( ) { while ( ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } byte nextByte ( ) { return Byte . parseByte ( next ( ) ) ; } short nextShort ( ) { return Short . parseShort ( next ( ) ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return java . lang . Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }
import java . lang . * ; public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int primeBitsInRange ( int l , int r ) { int tot_bit , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { tot_bit = Integer . bitCount ( i ) ; if ( isPrime ( tot_bit ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int l = 6 , r = 10 ; System . out . println ( primeBitsInRange ( l , r ) ) ; } }
public class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; if ( sum == k ) count ++ ; } } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 4 ; System . out . println ( pairs ( arr , n , k ) ) ; } }
import java . util . LinkedList ; import java . util . Queue ; import java . util . Stack ; public class Reverse_k_element_queue { static Queue < Integer > queue ; static void reverseQueueFirstKElements ( int k ) { if ( queue . isEmpty ( ) == true || k > queue . size ( ) ) return ; if ( k <= 0 ) return ; Stack < Integer > stack = new Stack < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { stack . push ( queue . peek ( ) ) ; queue . remove ( ) ; } while ( ! stack . empty ( ) ) { queue . add ( stack . peek ( ) ) ; stack . pop ( ) ; } for ( int i = 0 ; i < queue . size ( ) - k ; i ++ ) { queue . add ( queue . peek ( ) ) ; queue . remove ( ) ; } } static void Print ( ) { while ( ! queue . isEmpty ( ) ) { System . out . print ( queue . peek ( ) + " ▁ " ) ; queue . remove ( ) ; } } public static void main ( String args [ ] ) { queue = new LinkedList < Integer > ( ) ; queue . add ( 10 ) ; queue . add ( 20 ) ; queue . add ( 30 ) ; queue . add ( 40 ) ; queue . add ( 50 ) ; queue . add ( 60 ) ; queue . add ( 70 ) ; queue . add ( 80 ) ; queue . add ( 90 ) ; queue . add ( 100 ) ; int k = 5 ; reverseQueueFirstKElements ( k ) ; Print ( ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public final class Ideone { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = - Integer . parseInt ( sc . nextLine ( ) ) ; for ( String x : sc . nextLine ( ) . trim ( ) . split ( " ▁ " ) ) { sum += Integer . parseInt ( x ) ; } if ( sum % 2 == 0 ) { System . out . println ( " maomao90" ) ; } else { System . out . println ( " errorgorn " ) ; } } } }
public class GFG { static int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; } public static void main ( String [ ] args ) { int k = 31 ; System . out . println ( xorCalc ( k ) ) ; } }
class Solution { public boolean isPerfectSquare ( int num ) { int low = 1 ; int high = num ; while ( low <= high ) { long mid = ( low + high ) >>> 1 ; if ( mid * mid == num ) { return true ; } else if ( mid * mid < num ) { low = ( int ) mid + 1 ; } else { high = ( int ) mid - 1 ; } } return false ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int n = 16 ; boolean out = sObj . isPerfectSquare ( n ) ; System . out . println ( out ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; String result = " No " ; if ( max ( a , max ( b , c ) ) * 2 == a + b + c ) result = " Yes " ; System . out . println ( result ) ; } public static class Scanner { private BufferedReader br ; private StringTokenizer tok ; public Scanner ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } private void getLine ( ) throws IOException { while ( ! hasNext ( ) ) tok = new StringTokenizer ( br . readLine ( ) ) ; } private boolean hasNext ( ) { return tok != null && tok . hasMoreTokens ( ) ; } public String next ( ) throws IOException { getLine ( ) ; return tok . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } } }
import java . util . * ; public class Problem5 { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n1 = input . nextInt ( ) ; float [ ] arr = new float [ n1 ] ; int sum = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int n2 = input . nextInt ( ) ; arr [ i ] = n2 ; sum += ( double ) arr [ i ] ; } float summ = sum ; summ /= ( double ) n1 ; int nos = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == summ ) { nos ++ ; } } System . out . println ( nos ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ( double ) arr [ i ] == summ ) { System . out . print ( ( i + 1 ) + " ▁ " ) ; } } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int size = Integer . parseInt ( scanner . next ( ) ) ; int quantum = Integer . parseInt ( scanner . next ( ) ) ; int sum = 0 ; Queue queue = new Queue ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String name = scanner . next ( ) ; int time = Integer . parseInt ( scanner . next ( ) ) ; if ( time <= quantum ) { sum += time ; System . out . println ( name + " ▁ " + sum ) ; } else { sum += quantum ; queue . enqueue ( new Process ( name , time - quantum ) ) ; } } while ( ! queue . isEmpty ( ) ) { Process process = queue . dequeue ( ) ; if ( process . quantum <= quantum ) { sum += process . quantum ; System . out . println ( process . name + " ▁ " + sum ) ; } else { sum += quantum ; queue . enqueue ( new Process ( process . name , process . quantum - quantum ) ) ; } } } static class Queue { static final int SIZE = 100000 ; Process [ ] array = new Process [ SIZE ] ; int head = 0 ; int tail = 0 ; Process dequeue ( ) { if ( isEmpty ( ) ) { throw new IllegalStateException ( " You ▁ dequeued ▁ from ▁ empty ▁ " + " queue . " ) ; } Process value = array [ tail ] ; tail += 1 ; if ( tail == SIZE ) { tail -= SIZE ; } return value ; } void enqueue ( Process process ) { if ( isFull ( ) ) { throw new IllegalStateException ( " You ▁ enqueued ▁ to ▁ full ▁ queue . " ) ; } array [ head ] = process ; head += 1 ; if ( head == SIZE ) { head -= SIZE ; } } boolean isFull ( ) { return head + 1 == ( tail % SIZE ) ; } boolean isEmpty ( ) { return head == tail ; } } static class Process { String name ; int quantum ; Process ( String name , int quantum ) { this . name = name ; this . quantum = quantum ; } } }
import java . util . * ; public class GFG { static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int rotations = 2 ; int [ ] [ ] ranges = { { 0 , 2 } , { 0 , 3 } } ; int index = 1 ; System . out . println ( findElement ( arr , ranges , rotations , index ) ) ; } }
public class GFG { static int MAXN = 1000001 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] hash1 = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } static boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } static boolean hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class Solution { static boolean isExists ( int a [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( a [ i ] , freq . get ( a [ i ] ) == null ? 0 : freq . get ( a [ i ] ) + 1 ) ; sum += a [ i ] ; } if ( sum % 2 == 0 ) { if ( freq . get ( sum / 2 ) != null ) return true ; } return false ; } public static void main ( String args [ ] ) { int a [ ] = { 5 , 1 , 2 , 2 } ; int n = a . length ; if ( isExists ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; } public static void main ( String [ ] args ) { int d1 = 4 , d2 = 6 ; System . out . println ( " Area ▁ of ▁ Kite ▁ = ▁ " + areaOfKite ( d1 , d2 ) ) ; } }
import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; boolean [ ] [ ] a = new boolean [ 4 ] [ 11 ] ; for ( int i = 0 , j = 0 ; n > 0 ; n -- , j += i / 3 , i = ( i + 1 ) % 4 ) { if ( i == 2 && j != 0 ) i ++ ; a [ i ] [ j ] = true ; } System . out . println ( " + - - - - - - - - - - - - - - - - - - - - - - - - + " ) ; for ( int i = 0 ; i < 4 ; i ++ ) { System . out . print ( " | " ) ; for ( int j = 0 ; j < 11 ; j ++ ) System . out . print ( a [ i ] [ j ] ? " O . " : ( i == 2 ? ( j == 0 ? " # . " : " . . " ) : " # . " ) ) ; if ( i == 0 ) System . out . println ( " | D | ) " ) ; else System . out . println ( ( i == 2 ? " . . | " : " | . | " ) + ( i == 3 ? " ) " : " " ) ) ; } System . out . println ( " + - - - - - - - - - - - - - - - - - - - - - - - - + " ) ; } }
import java . util . * ; public class codeforces { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; if ( ( n & ( n - 1 ) ) == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static boolean productEqual ( int n ) { if ( n < 10 ) return false ; int prodOdd = 1 , prodEven = 1 ; while ( n > 0 ) { int digit = n % 10 ; prodOdd *= digit ; n /= 10 ; if ( n == 0 ) break ; digit = n % 10 ; prodEven *= digit ; n /= 10 ; } if ( prodEven == prodOdd ) return true ; return false ; } public static void main ( String args [ ] ) { int n = 4324 ; if ( productEqual ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Collections ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { int n = Integer . parseInt ( br . readLine ( ) ) ; if ( n == 0 ) break ; int key [ ] = new int [ n ] ; String str [ ] = br . readLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { key [ i ] = Integer . parseInt ( str [ i ] ) ; } char c [ ] = br . readLine ( ) . toCharArray ( ) ; int keyCount = 0 ; for ( int i = 0 ; i < c . length ; i ++ ) { for ( int j = 0 ; j < key [ keyCount ] ; j ++ ) { if ( c [ i ] == 97 ) c [ i ] = 90 ; else if ( c [ i ] == 65 ) c [ i ] = 122 ; else c [ i ] -= 1 ; } if ( keyCount == key . length - 1 ) { keyCount = 0 ; } else { keyCount ++ ; } } for ( int i = 0 ; i < c . length ; i ++ ) System . out . print ( c [ i ] ) ; System . out . print ( " \n " ) ; } } }
import java . io . * ; public class GFG { static void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) System . out . println ( " odd " ) ; else System . out . println ( " even " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 1 } ; int n = arr . length ; checkEVENodd ( arr , n , 1 , 3 ) ; } }
import java . io . * ; public class Main { public static void main ( String [ ] args ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String str = br . readLine ( ) ; String [ ] split = str . split ( " ▁ " , 0 ) ; int w = Integer . parseInt ( split [ 0 ] ) ; int h = Integer . parseInt ( split [ 1 ] ) ; int x = Integer . parseInt ( split [ 2 ] ) ; int y = Integer . parseInt ( split [ 3 ] ) ; int r = Integer . parseInt ( split [ 4 ] ) ; if ( ( x - r >= 0 ) && ( x + r <= w ) && ( y - r >= 0 ) && ( y + r <= h ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } catch ( Exception e ) { System . out . println ( " ? ? ¨ ? ? ? ? ? ? " ) ; } } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime ( sum ) ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int compositeProduct ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } } return product ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( compositeProduct ( arr , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { int intx = 0 ; int inty = 0 ; int intWork = 0 ; try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String strLine = br . readLine ( ) ; if ( strLine != null ) { String [ ] strNumList = strLine . split ( " ▁ " , 0 ) ; intx = Integer . parseInt ( strNumList [ 0 ] ) ; inty = Integer . parseInt ( strNumList [ 1 ] ) ; if ( intx != 0 || inty != 0 ) { if ( intx > inty ) { intWork = intx ; intx = inty ; inty = intWork ; } System . out . println ( intx + " ▁ " + inty ) ; } else { break ; } } else { break ; } } } catch ( IOException e1 ) { System . out . println ( e1 ) ; } catch ( NumberFormatException e2 ) { System . out . println ( e2 ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { String [ ] strarr = new String [ ] { " FILIPINO " , " JAPANESE " , " KOREAN " } ; Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; int indexWord = 0 ; for ( int i = 0 ; i < t ; i ++ ) { String s1 = s . next ( ) ; if ( s1 . endsWith ( " po " ) ) { indexWord = 0 ; } else if ( s1 . endsWith ( " mnida " ) ) { indexWord = 2 ; } else { indexWord = 1 ; } System . out . println ( strarr [ indexWord ] ) ; } } }
public class GFG { static int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 } ; int queries = 3 ; int q [ ] [ ] = { { 2 , 4 } , { 2 , 6 } , { 5 , 6 } } ; int n = arr . length ; for ( int i = 0 ; i < queries ; i ++ ) System . out . print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) + " \n " ) ; } }
import java . util . * ; public class GFG { static int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; } public static void main ( String args [ ] ) { int n = 10 , a = 5 , b = 3 , c = 4 ; System . out . println ( maxResult ( n , a , b , c ) ) ; } }
import java . io . * ; class Main { private static void sort ( int [ ] a ) { for ( int i = 0 ; i < a . length - 1 ; i ++ ) { for ( int j = a . length - 1 ; j > i ; j -- ) { if ( a [ j ] > a [ j - 1 ] ) { int t = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = t ; } } } } private static void print_hill ( int [ ] a ) { for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( a [ i ] ) ; } } public static void main ( String args [ ] ) throws IOException { int hills [ ] = new int [ 10 ] ; InputStreamReader inp = new InputStreamReader ( System . in ) ; BufferedReader bre = new BufferedReader ( inp ) ; int n ; for ( int i = 0 ; i < 10 ; i ++ ) { String num = bre . readLine ( ) ; n = Integer . parseInt ( num ) ; hills [ i ] = n ; } sort ( hills ) ; print_hill ( hills ) ; } }
import java . util . * ; public class GFG { static int fact ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; } static int numberOfPossiblePallindrome ( String str , int n ) { Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( str . charAt ( i ) , mp . get ( str . charAt ( i ) ) == null ? 1 : mp . get ( str . charAt ( i ) ) + 1 ) ; int k = 0 ; int num = 0 ; int den = 1 ; int fi ; for ( Map . Entry < Character , Integer > it : mp . entrySet ( ) ) { if ( it . getValue ( ) % 2 == 0 ) fi = it . getValue ( ) / 2 ; else { fi = ( it . getValue ( ) - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fact ( fi ) ; } if ( num != 0 ) num = fact ( num ) ; int ans = num / den ; if ( k != 0 ) { ans = ans * k ; } return ( ans ) ; } public static void main ( String [ ] args ) { String str = " ababab " ; int n = str . length ( ) ; System . out . println ( numberOfPossiblePallindrome ( str , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int size = sc . nextInt ( ) ; int arr [ ] = new int [ size + 1 ] ; for ( int i = 1 ; i <= size ; i ++ ) arr [ i ] = sc . nextInt ( ) ; System . out . println ( split ( arr , 1 , size ) ) ; } public static int split ( int arr [ ] , int s , int m ) { if ( s == m ) return 1 ; int half = ( m - s + 1 ) >> 1 ; int mid = half + s ; int ans1 = split ( arr , s , mid - 1 ) ; int ans2 = split ( arr , mid , m ) ; if ( arr [ mid ] >= arr [ mid - 1 ] && ans1 == ans2 && ans1 == half ) return ans1 + ans2 ; else if ( ans1 > ans2 ) return ans1 ; else return ans2 ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } public static void main ( String argc [ ] ) { int n = 107 ; int m = 4 ; n = toggleLastMBits ( n , m ) ; System . out . println ( n ) ; } }
import java . util . * ; public class cf1672b { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String s = sc . next ( ) ; int a = 0 , b = 0 ; boolean f = true ; for ( char ch : s . toCharArray ( ) ) { if ( ch == ' A ' ) { a ++ ; } else { b ++ ; if ( a < b ) { System . out . println ( " NO " ) ; f = false ; break ; } } } if ( f ) { if ( b != 0 && s . charAt ( s . length ( ) - 1 ) == ' B ' ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } }
import java . util . * ; public class GFG { static String first_subString ( String s ) { int n = s . length ( ) , c = 0 ; String s1 , s2 ; HashMap < String , Integer > mpp = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' || s . charAt ( i ) == ' # ' ) { s1 = s . substring ( c , i ) ; mpp . put ( s1 , 1 ) ; c = i + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' ) { continue ; } for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( i ) == ' ▁ ' ) { break ; } s1 = s . substring ( i , j - i + 1 ) ; s2 = s1 ; s1 = reverse ( s1 ) ; if ( mpp . containsKey ( s1 ) ) { return s2 ; } } } return " - 1" ; } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String s , s1 ; s = " mango ▁ is ▁ sweet ▁ when ▁ nam ▁ en ▁ tastes ▁ it # " ; s1 = first_subString ( s ) ; System . out . print ( s1 + " \n " ) ; } }
import java . lang . * ; import java . util . * ; public class GFG { static int countConsecutive ( int n ) { String s = Integer . toString ( n ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) count ++ ; return count ; } public static void main ( String args [ ] ) { int n = 44522255 ; System . out . println ( countConsecutive ( n ) ) ; } }
import java . io . * ; public class GFG { static void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; System . out . println ( " Interior ▁ angle : ▁ " + interiorAngle ) ; System . out . println ( " Exterior ▁ angle : ▁ " + exteriorAngle ) ; } public static void main ( String [ ] args ) { int n = 10 ; findAngle ( n ) ; } }
public class GFG { static void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) ; System . out . print ( smallest + " ▁ " ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ; System . out . print ( largest ) ; } public static void main ( String args [ ] ) { int n = 4 ; nDigitPerfectSquares ( n ) ; } }
import java . util . * ; public class A { public static void main ( String [ ] args ) { new A ( ) . solve ( ) ; } Scanner in ; private void solve ( ) { in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; List < String > message = new ArrayList < > ( Arrays . asList ( in . next ( ) . split ( " " ) ) ) ; identifyMessage ( message , n ) ; } } private void identifyMessage ( List < String > list , int n ) { Collections . reverse ( list ) ; int leftSymbols = 0 ; for ( String character : list ) { if ( character . equals ( " ) " ) ) { ++ leftSymbols ; } else { break ; } } System . out . println ( leftSymbols > ( n - leftSymbols ) ? " Yes " : " No " ) ; } }
import java . util . * ; import java . io . * ; import java . util . * ; public class akarshanand2810 { public static void main ( String [ ] args ) throws IOException { solve ( ) ; } public static void solve ( ) throws IOException { Reader sc = new Reader ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; char [ ] arr = sc . next ( ) . toCharArray ( ) ; int cnt = 0 ; List < Integer > idx = new ArrayList < > ( ) ; for ( int i = 0 ; i < n - 1 ; i = i + 2 ) { if ( arr [ i ] == arr [ i + 1 ] ) { cnt ++ ; idx . add ( i ) ; } } System . out . println ( cnt ) ; for ( int index : idx ) { if ( arr [ index ] == ' a ' ) arr [ index ] = ' b ' ; else arr [ index ] = ' a ' ; } out . println ( new String ( arr ) ) ; out . flush ( ) ; } static class Reader { BufferedReader br ; StringTokenizer st ; public Reader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { if ( st . hasMoreTokens ( ) ) str = st . nextToken ( " \n " ) ; else str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
public class GFG { static long discard_count = 0 ; static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; } static void solve ( int i , int n , float sum , float k , float [ ] a , float [ ] prefix ) { if ( sum > k ) { discard_count += power ( 2 , n - i ) ; return ; } if ( i == n ) return ; float rem = prefix [ n - 1 ] - prefix [ i ] ; if ( sum + a [ i ] + rem > k ) solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) ; if ( sum + rem > k ) solve ( i + 1 , n , sum , k , a , prefix ) ; } static int countSubsequences ( int [ ] arr , int n , long K ) { float sum = 0.0f ; float k = ( float ) Math . log ( K ) ; float [ ] prefix = new float [ n ] ; float [ ] a = new float [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( float ) Math . log ( arr [ i ] ) ; sum += a [ i ] ; } prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } long total = power ( 2 , n ) - 1 ; if ( sum <= k ) { return ( int ) total ; } solve ( 0 , n , 0.0f , k , a , prefix ) ; return ( int ) ( total - discard_count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 7 , 2 } ; int n = arr . length ; long k = 50 ; System . out . print ( countSubsequences ( arr , n , k ) ) ; } }
public class GFG { static class Node { int data ; Node left ; Node right ; } ; static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = null ; node . right = null ; return node ; } static void inorder ( Node root ) { if ( root == null ) return ; inorder ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; inorder ( root . right ) ; } static int isIdentical ( Node root1 , Node root2 ) { if ( root1 == null && root2 == null ) return 1 ; else if ( root1 != null && root2 == null ) return 0 ; else if ( root1 == null && root2 != null ) return 0 ; else { if ( root1 . data == root2 . data && isIdentical ( root1 . left , root2 . left ) == 1 && isIdentical ( root1 . right , root2 . right ) == 1 ) return 1 ; else return 0 ; } } public static void main ( String [ ] args ) { Node root1 = newNode ( 5 ) ; Node root2 = newNode ( 5 ) ; root1 . left = newNode ( 3 ) ; root1 . right = newNode ( 8 ) ; root1 . left . left = newNode ( 2 ) ; root1 . left . right = newNode ( 4 ) ; root2 . left = newNode ( 3 ) ; root2 . right = newNode ( 8 ) ; root2 . left . left = newNode ( 2 ) ; root2 . left . right = newNode ( 4 ) ; if ( isIdentical ( root1 , root2 ) == 1 ) System . out . print ( " Both ▁ BSTs ▁ are ▁ identical " ) ; else System . out . print ( " BSTs ▁ are ▁ not ▁ identical " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] arr = sc . next ( ) . toCharArray ( ) ; int [ ] leftJ = new int [ n + 2 ] ; int [ ] rightI = new int [ n + 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) { leftJ [ i ] = leftJ [ i - 1 ] ; if ( arr [ i - 1 ] == ' J ' ) { leftJ [ i ] ++ ; } rightI [ n - i + 1 ] = rightI [ n - i + 2 ] ; if ( arr [ n - i ] == ' I ' ) { rightI [ n - i + 1 ] ++ ; } } long sumI = 0 ; long sumJ = 0 ; long maxO = 0 ; long total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { long tmp ; if ( arr [ i - 1 ] == ' O ' ) { tmp = leftJ [ i - 1 ] * rightI [ i + 1 ] ; total += tmp ; sumJ += ( leftJ [ i - 1 ] + 1 ) * rightI [ i + 1 ] ; sumI += leftJ [ i - 1 ] * ( rightI [ i + 1 ] + 1 ) ; } else { tmp = leftJ [ i - 1 ] * rightI [ i ] ; } maxO = Math . max ( maxO , tmp ) ; } total += maxO ; total = Math . max ( total , sumJ ) ; total = Math . max ( total , sumI ) ; System . out . println ( total ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] surface = br . readLine ( ) . split ( " ▁ " ) ; String [ ] order = br . readLine ( ) . split ( " " ) ; Dise dice1 = new Dise ( ) ; dice1 . setSurface ( surface ) ; dice1 . SetDice ( 1 , 2 , 3 ) ; dice1 . RollDice ( order ) ; } } class Dise { int [ ] surface = new int [ 6 ] ; int Top , Bottom , Right , Left , Front , Back ; void setSurface ( String [ ] SurfaceString ) { for ( int i = 0 ; i < 6 ; i ++ ) { surface [ i ] = Integer . parseInt ( SurfaceString [ i ] ) ; } } void SetDice ( int top , int front , int right ) { Top = top - 1 ; Front = front - 1 ; Right = right - 1 ; Bottom = 5 - ( top - 1 ) ; Back = 5 - ( front - 1 ) ; Left = 5 - ( right - 1 ) ; } void RollDice ( String [ ] RollString ) { for ( int i = 0 ; i < RollString . length ; i ++ ) { if ( RollString [ i ] . equals ( " W " ) ) { Bottom = Left ; Left = Top ; Top = 5 - Bottom ; Right = 5 - Left ; } else if ( RollString [ i ] . equals ( " S " ) ) { Bottom = Front ; Front = Top ; Top = 5 - Bottom ; Back = 5 - Front ; } else if ( RollString [ i ] . equals ( " E " ) ) { Bottom = Right ; Right = Top ; Top = 5 - Bottom ; Left = 5 - Right ; } else { Bottom = Back ; Back = Top ; Top = 5 - Bottom ; Front = 5 - Back ; } } System . out . println ( surface [ Top ] ) ; } }
public class GFG { static class node { int data ; node next ; } static node add ( int data ) { node newnode = new node ( ) ; newnode . data = data ; newnode . next = null ; return newnode ; } static void printArr ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } static int findlength ( node head ) { node curr = head ; int cnt = 0 ; while ( curr != null ) { cnt ++ ; curr = curr . next ; } return cnt ; } static void convertArr ( node head ) { int len = findlength ( head ) ; int [ ] arr = new int [ len ] ; int index = 0 ; node curr = head ; while ( curr != null ) { arr [ index ++ ] = curr . data ; curr = curr . next ; } printArr ( arr , len ) ; } public static void main ( String [ ] args ) { node head = new node ( ) ; head = add ( 1 ) ; head . next = add ( 2 ) ; head . next . next = add ( 3 ) ; head . next . next . next = add ( 4 ) ; head . next . next . next . next = add ( 5 ) ; convertArr ( head ) ; } }
import java . io . * ; public class GFG { static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( " Non - decreasing ▁ digits ▁ = ▁ " + nonDecNums ( n ) ) ; } }
import java . util . * ; public class class29 { public static void main ( String arg [ ] ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; HashSet < Long > st = new HashSet < > ( ) ; int i , flag = 0 ; long a [ ] = new long [ n ] ; int vis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; long val = ( i + a [ i ] ) % n ; if ( val < 0 ) { val += n ; } vis [ ( int ) val ] = 1 ; } for ( i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . util . Arrays ; import java . util . Collections ; class Solution { public int minMoves ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; Arrays . sort ( nums ) ; int min_num = nums [ 0 ] ; int ans = 0 ; for ( int num : nums ) { ans += num - min_num ; } return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 1 , 2 , 3 } ; int out = sObj . minMoves ( nums ) ; System . out . println ( out ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; if ( a <= 0 && b >= 0 || a <= 0 && b >= 0 ) { System . out . println ( " Zero " ) ; } else if ( a < 0 && b < 0 ) { System . out . println ( ( ( b - a + 1 ) % 2 == 0 ) ? " Positive " : " Negative " ) ; } else if ( a > 0 && b > 0 ) { System . out . println ( " Positive " ) ; } } }
class geeks { public static int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( firstSetBit ( n ) ) ; } }
import java . io . * ; public class GFG { static int MAX_CHAR = 256 ; static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; } static public void main ( String [ ] args ) { String str = " abba " ; System . out . println ( maximumChars ( str ) ) ; } }
import java . io . * ; import java . util . * ; public class KefaAndCompany { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str [ ] = br . readLine ( ) . trim ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int k = Integer . parseInt ( str [ 1 ] ) ; long pf [ ] = new long [ n ] ; ArrayList < Kefa > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String input [ ] = br . readLine ( ) . trim ( ) . split ( " ▁ " ) ; int money = Integer . parseInt ( input [ 0 ] ) ; int friend = Integer . parseInt ( input [ 1 ] ) ; list . add ( new Kefa ( money , friend ) ) ; } Collections . sort ( list , new KefaCmp ( ) ) ; long ans = 0 ; int s = 0 , e = 0 ; long sum = 0 ; while ( e < n ) { if ( list . get ( e ) . money - list . get ( s ) . money < k ) { sum += list . get ( e ) . friend ; e ++ ; } else { sum -= list . get ( s ) . friend ; s ++ ; } ans = Math . max ( ans , sum ) ; } System . out . println ( ans ) ; } } class Kefa { int money ; int friend ; Kefa ( int money , int friend ) { this . money = money ; this . friend = friend ; } } class KefaCmp implements Comparator < Kefa > { @ Override public int compare ( Kefa o1 , Kefa o2 ) { return o1 . money - o2 . money ; } }
import java . io . * ; public class GFG { static float findArea ( float a ) { float area ; area = ( float ) ( 5 * Math . sqrt ( 3 ) * a * a ) ; return area ; } static float findVolume ( float a ) { float volume ; volume = ( float ) ( ( ( float ) 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a * a ) ; return volume ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( " Area : ▁ " + String . format ( " % . 2 f " , findArea ( a ) ) ) ; System . out . println ( " Volume : ▁ " + String . format ( " % . 2 f " , findVolume ( a ) ) ) ; } }
public final class p205 { public static void main ( String [ ] args ) { System . out . println ( new p205 ( ) . run ( ) ) ; } private static final int [ ] PYRAMIDAL_DIE_PDF = { 0 , 1 , 1 , 1 , 1 } ; private static final int [ ] CUBIC_DIE_PDF = { 0 , 1 , 1 , 1 , 1 , 1 , 1 } ; public String run ( ) { int [ ] ninePyramidalPdf = { 1 } ; for ( int i = 0 ; i < 9 ; i ++ ) ninePyramidalPdf = convolve ( ninePyramidalPdf , PYRAMIDAL_DIE_PDF ) ; int [ ] sixCubicPdf = { 1 } ; for ( int i = 0 ; i < 6 ; i ++ ) sixCubicPdf = convolve ( sixCubicPdf , CUBIC_DIE_PDF ) ; long numer = 0 ; for ( int i = 0 ; i < ninePyramidalPdf . length ; i ++ ) numer += ( long ) ninePyramidalPdf [ i ] * sum ( sixCubicPdf , 0 , i ) ; long denom = ( long ) sum ( ninePyramidalPdf , 0 , ninePyramidalPdf . length ) * sum ( sixCubicPdf , 0 , sixCubicPdf . length ) ; return String . format ( " % .7f " , ( double ) numer / denom ) ; } private static int [ ] convolve ( int [ ] a , int [ ] b ) { int [ ] c = new int [ a . length + b . length - 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < b . length ; j ++ ) c [ i + j ] += a [ i ] * b [ j ] ; } return c ; } private static int sum ( int [ ] array , int start , int end ) { int sum = 0 ; for ( int i = start ; i < end ; i ++ ) sum += array [ i ] ; return sum ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { public static void main ( String args [ ] ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; } public static void main ( String args [ ] ) { int N = 12 , M = 13 , s = 4 ; System . out . println ( solve ( M , N , s ) ) ; } }
import java . util . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . print ( countPairs ( arr , n ) ) ; } }
import java . util . Scanner ; import java . util . ArrayList ; import java . lang . Math ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; int sum = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { int _l = input . nextInt ( ) ; list . add ( _l ) ; sum += _l ; } int i , j , k ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = i + 1 ; j < 5 ; j ++ ) { for ( k = j + 1 ; k < 6 ; k ++ ) { int sum1 = list . get ( i ) + list . get ( j ) + list . get ( k ) ; if ( sum1 == sum - sum1 ) { System . out . println ( " YES " ) ; return ; } } } } System . out . println ( " NO " ) ; } }
import java . io . * ; public class GFG { private static int _popcnt32 ( long number ) { int counter = 0 ; while ( number > 0 ) { if ( number % 2 == 1 ) { counter ++ ; } number = number / 2 ; } return counter ; } static long maximize ( long a ) { int n = _popcnt32 ( a ) ; long res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res = ( int ) res | ( 1 << ( 32 - i ) ) ; return Math . abs ( res ) ; } public static void main ( String args [ ] ) { long a = 1 ; System . out . print ( maximize ( a ) ) ; } }
import java . util . Scanner ; public class CF_1712_A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int counter = 0 ; for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] <= k ) counter ++ ; } System . out . println ( counter ) ; } } }
import java . util . Scanner ; public class JavaApplication38 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num1 = sc . nextInt ( ) ; int num2 = sc . nextInt ( ) ; int counter = 0 ; while ( num1 != 0 && num2 != 0 ) { if ( num1 == 1 && num2 == 1 ) { break ; } if ( num1 <= num2 ) { num1 ++ ; num2 -= 2 ; } else { num1 -= 2 ; num2 ++ ; } counter ++ ; } System . out . println ( counter ) ; } }
import java . util . * ; class Solution { public int [ ] xorQueries ( int [ ] arr , int [ ] [ ] queries ) { int [ ] res = new int [ queries . length ] , q ; for ( int i = 1 ; i < arr . length ; i ++ ) arr [ i ] ^= arr [ i - 1 ] ; for ( int i = 0 ; i < queries . length ; i ++ ) { q = queries [ i ] ; res [ i ] = q [ 0 ] > 0 ? arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] : arr [ q [ 1 ] ] ; } return res ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] arr = { 1 , 3 , 4 , 8 } ; int [ ] [ ] queries = { { 0 , 1 } , { 1 , 2 } , { 0 , 3 } , { 3 , 3 } } ; int [ ] out = sObj . xorQueries ( arr , queries ) ; System . out . println ( Arrays . toString ( out ) ) ; } }
public class GFG { static char encodedChar ( String str , int k ) { String expand = " " ; String temp = " " ; int freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; ) { temp = " " ; freq = 0 ; while ( i < str . length ( ) && str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand . charAt ( k - 1 ) ; } public static void main ( String args [ ] ) { String str = " ab4c12ed3" ; int k = 21 ; System . out . println ( encodedChar ( str , k ) ) ; } }
import java . io . * ; public class GFG { static void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 || a + b < c ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ; } }
public class GFG { static int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . println ( summation ( N ) ) ; } }
import java . util . * ; import java . io . * ; public class GFG { public static void sortSquares ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; Arrays . sort ( arr ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 6 , - 3 , - 1 , 2 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Before ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; sortSquares ( arr ) ; System . out . println ( " " ) ; System . out . println ( " After ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . * ; public class CP19 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , t = sc . nextInt ( ) , k = 0 , pos = 1 ; sc . nextLine ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } while ( pos < t ) { k = pos + arr [ pos - 1 ] ; pos = k ; } if ( pos == t ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int N = parseInt ( br . readLine ( ) ) ; int [ ] a = new int [ N ] ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = parseInt ( st . nextToken ( ) ) ; } int [ ] indeg = new int [ N ] ; boolean [ ] used = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { indeg [ ( i + a [ i ] ) % N ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { int j = i ; while ( ! used [ j ] && indeg [ j ] == 0 ) { used [ j ] = true ; j = ( j + a [ j ] ) % N ; indeg [ j ] -- ; } } System . out . println ( Arrays . stream ( indeg ) . filter ( x -> x != 0 ) . count ( ) ) ; } }
import java . io . * ; public class GFG { static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; } public static void main ( String [ ] args ) { int num = 55 ; if ( isTriangular ( num ) ) System . out . println ( " The ▁ number ▁ is " + " ▁ a ▁ triangular ▁ number " ) ; else System . out . println ( " The ▁ number ▁ " + " is ▁ NOT ▁ a ▁ triangular ▁ number " ) ; } }
import java . io . * ; public class GFG { static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( " - 1" ) ; else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) System . out . print ( "0" ) ; } } public static void main ( String [ ] args ) { int k = 4 , d = 4 ; printNumberWithDR ( k , d ) ; } }
import java . util . * ; public class GFG { static int N = 3 ; static void rotateMatrix ( int mat [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j >= 0 ; j -- ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; rotateMatrix ( mat ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int p = sc . nextInt ( ) ; System . out . println ( p / 500 * 500 ) ; } }
import java . io . * ; public class GFG { static int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } public static void main ( String [ ] args ) { int n = 4513 ; System . out . println ( getProduct ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sn = new Scanner ( System . in ) ; while ( true ) { Slot slot = new Slot ( sn . nextInt ( ) , sn . nextInt ( ) , sn . nextInt ( ) , sn . nextInt ( ) , sn . nextInt ( ) , sn . nextInt ( ) ) ; if ( slot . isEnd ( ) ) break ; System . out . println ( 100 + slot . getBenefit ( ) - slot . getLost ( ) ) ; } } } class Slot { int b , r , g , c , s , t ; Slot ( int b , int r , int g , int c , int s , int t ) { this . b = b ; this . r = r ; this . g = g ; this . c = c ; this . s = s ; this . t = t ; } int getLost ( ) { return ( t - 5 * b - 3 * r - s ) * 3 + ( 5 * b + 3 * r ) * 2 ; } int getBenefit ( ) { return b * 15 + r * 15 + g * 7 + c * 2 + ( b * 5 + r * 3 ) * 15 ; } boolean isEnd ( ) { return b + r + g + c + s + t == 0 ; } }
import java . io . * ; import java . util . * ; public class ColoredBalls { public static int mod = 1000000007 ; public static int MAXN = 1010 ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out , true ) ; long [ ] [ ] comb = new long [ MAXN ] [ MAXN ] ; comb [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < MAXN ; i ++ ) { comb [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { comb [ i ] [ j ] = ( comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] ) % mod ; } } int K = in . nextInt ( ) ; int [ ] color = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) color [ i ] = in . nextInt ( ) ; long res = 1 ; int total = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod ; total += color [ i ] ; } out . println ( res ) ; out . close ( ) ; System . exit ( 0 ) ; } }
import java . lang . * ; public class GFG { static double PI = 3.14159265 ; public static double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } public static void main ( String [ ] args ) { double r = 7 ; System . out . println ( length_rope ( r ) ) ; } }
public class GFG { static int reverseDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int isPalindrome ( int n ) { int rev_n = reverseDigits ( n ) ; if ( rev_n == n ) return 1 ; else return 0 ; } public static void main ( String [ ] args ) { int n = 4562 ; System . out . println ( " Is ▁ " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ " + ( isPalindrome ( n ) == 1 ? " True " : " False " ) ) ; n = 2002 ; System . out . println ( " Is ▁ " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ " + ( isPalindrome ( n ) == 1 ? " True " : " False " ) ) ; } }
public class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder sb = new StringBuilder ( ) ; int carry = 0 ; for ( int i = num1 . length ( ) - 1 , j = num2 . length ( ) - 1 ; i >= 0 || j >= 0 || carry == 1 ; i -- , j -- ) { int x = i < 0 ? 0 : num1 . charAt ( i ) - '0' ; int y = j < 0 ? 0 : num2 . charAt ( j ) - '0' ; sb . append ( ( x + y + carry ) % 10 ) ; carry = ( x + y + carry ) / 10 ; } return sb . reverse ( ) . toString ( ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String num1 = "11" ; String num2 = "123" ; String out = sObj . addStrings ( num1 , num2 ) ; System . out . println ( out ) ; } }
public class GFG { static boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; } public static void main ( String [ ] args ) { System . out . println ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) ; for ( int n = 2 ; n < 10000 ; n ++ ) if ( isPerfect ( n ) ) System . out . println ( n + " ▁ is ▁ a ▁ perfect ▁ number " ) ; } }
public class GFG { static boolean isPower ( int n ) { for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int p = x ; while ( p <= n ) { p = p * x ; if ( p == n ) return true ; } } return false ; } public static void main ( String [ ] args ) { for ( int i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) System . out . print ( i + " ▁ " ) ; } }
public class GFG { static boolean isPower ( int n ) { for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int y = 2 ; double p = Math . pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) return true ; y ++ ; p = Math . pow ( x , y ) ; } } return false ; } public static void main ( String [ ] args ) { for ( int i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) System . out . print ( i + " ▁ " ) ; } }
import java . util . * ; class Solution { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static void findTwoNumbers ( int sum , int gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) System . out . println ( " a ▁ = ▁ " + Math . min ( gcd , sum - gcd ) + " , ▁ b ▁ = ▁ " + ( int ) ( sum - Math . min ( gcd , sum - gcd ) ) ) ; else System . out . println ( - 1 ) ; } public static void main ( String args [ ] ) { int sum = 8 ; int gcd = 2 ; findTwoNumbers ( sum , gcd ) ; } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; public class RobotCleaner { public static int time ( int m , int n , int rb , int cb , int rd , int cd ) { int t = 0 ; int dr = 1 ; int dc = 1 ; while ( true ) { if ( rb == rd || cb == cd ) return t ; t ++ ; if ( ( rb + dr ) <= 0 || ( rb + dr > m ) ) dr *= - 1 ; if ( ( cb + dc ) <= 0 || ( cb + dc > n ) ) dc *= - 1 ; rb += dr ; cb += dc ; } } public static void main ( String [ ] args ) throws Exception { InputStreamReader streamReader = new InputStreamReader ( System . in ) ; BufferedReader reader = new BufferedReader ( streamReader ) ; int testCases = Integer . parseInt ( reader . readLine ( ) ) ; while ( testCases -- > 0 ) { String input [ ] = reader . readLine ( ) . split ( " ▁ " ) ; int t = time ( Integer . parseInt ( input [ 0 ] ) , Integer . parseInt ( input [ 1 ] ) , Integer . parseInt ( input [ 2 ] ) , Integer . parseInt ( input [ 3 ] ) , Integer . parseInt ( input [ 4 ] ) , Integer . parseInt ( input [ 5 ] ) ) ; System . out . println ( t ) ; } } }
import java . util . Scanner ; class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int ans1 = 100000 , ans2 = 1000000 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a * i >= n ) { ans1 = i * b ; break ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( c * i >= n ) { ans2 = i * d ; break ; } } System . out . println ( Math . min ( ans2 , ans1 ) ) ; } }
import java . util . * ; public class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int totalPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = countSetBits ( arr [ i ] ) ; if ( m . containsKey ( count ) ) m . put ( count , m . get ( count ) + 1 ) ; else m . put ( count , 1 ) ; } int result = 0 ; for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) { int value = entry . getValue ( ) ; result += ( ( value * ( value - 1 ) ) / 2 ) ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 5 , 3 , 9 , 1 , 2 } ; int n = arr . length ; System . out . println ( totalPairs ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; n = 12 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; } }
import java . util . * ; import static java . lang . System . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long Q = sc . nextLong ( ) ; long H = sc . nextLong ( ) ; long S = sc . nextLong ( ) ; long D = sc . nextLong ( ) ; long N = sc . nextLong ( ) ; long onePrice = Math . min ( Math . min ( Q * 4 , H * 2 ) , S ) ; if ( ( double ) onePrice <= ( double ) D / 2 ) { out . println ( N * onePrice ) ; } else { out . println ( ( N / 2 ) * D + ( N % 2 ) * onePrice ) ; } } }
public class GFG { static int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int L = 10 ; int R = 22 ; int K = 3 ; System . out . println ( countNumbers ( L , R , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; while ( in . hasNext ( ) ) { long a = in . nextLong ( ) ; long b = in . nextLong ( ) ; long c = in . nextLong ( ) ; long d = in . nextLong ( ) ; long e = in . nextLong ( ) ; long f = in . nextLong ( ) ; long y = Math . min ( c , b ) ; long x = a ; if ( y + x <= d ) { System . out . println ( y * f + x * e ) ; } else if ( f >= e ) { System . out . println ( Math . min ( y , d ) * f + ( d - Math . min ( y , d ) ) * e ) ; } else if ( e >= f ) { System . out . println ( Math . min ( x , d ) * e + ( d - Math . min ( x , d ) ) * f ) ; } } } }
import java . util . * ; public class GFG { static int Solution ( int [ ] A ) { int ans = 2 ; int n = A . length ; if ( n <= 2 ) return n ; int [ ] llap = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) llap [ i ] = 2 ; Arrays . sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . max ( llap [ k ] + 1 , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] a = { 9 , 4 , 7 , 2 , 10 } ; System . out . print ( Solution ( a ) + " \n " ) ; } }
import java . util . * ; public class GFG { static int minimumChanges ( int arr [ ] , int n , int d ) { int maxFreq = - 1 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int a0 = arr [ i ] - ( i ) * d ; if ( freq . containsKey ( a0 ) ) { freq . put ( a0 , freq . get ( a0 ) + 1 ) ; } else freq . put ( a0 , 1 ) ; if ( freq . get ( a0 ) > maxFreq ) maxFreq = freq . get ( a0 ) ; } return ( n - maxFreq ) ; } public static void main ( String args [ ] ) { int n = 5 , d = 1 ; int arr [ ] = { 1 , 3 , 3 , 4 , 6 } ; System . out . println ( minimumChanges ( arr , n , d ) ) ; } }
import java . util . Arrays ; import java . util . * ; import java . io . PrintWriter ; import java . util . Scanner ; public class main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = input . nextInt ( ) ; int [ ] [ ] vec = new int [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { vec [ i ] [ 0 ] = input . nextInt ( ) ; vec [ i ] [ 1 ] = input . nextInt ( ) ; vec [ i ] [ 2 ] = input . nextInt ( ) ; vec [ i ] [ 3 ] = input . nextInt ( ) ; } int ans = 500 ; int ansprice = 20000 ; for ( int i = 0 ; i < n ; i ++ ) { int fl = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( vec [ i ] [ 0 ] < vec [ j ] [ 0 ] && vec [ i ] [ 1 ] < vec [ j ] [ 1 ] && vec [ i ] [ 2 ] < vec [ j ] [ 2 ] ) { fl = 0 ; } } if ( fl == 1 ) { if ( vec [ i ] [ 3 ] < ansprice ) { ansprice = vec [ i ] [ 3 ] ; ans = i + 1 ; } } } System . out . println ( ans ) ; out . close ( ) ; } }
import java . util . * ; public class GFG { static int countPoints ( int n , int m , int a [ ] , int [ ] b , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; } public static void main ( String args [ ] ) { int x = 1 , y = 4 ; int [ ] a = { 1 , 5 } ; int n = a . length ; int [ ] b = { 1 , 1 , 2 } ; int m = a . length ; System . out . println ( countPoints ( n , m , a , b , x , y ) ) ; } }
public class GFG { static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; } public static void main ( String [ ] args ) { int x = 4 ; System . out . println ( multiplyWith3Point5 ( x ) ) ; } }
import java . util . * ; import java . io . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; long s = in . nextLong ( ) ; long [ ] a = new long [ n ] ; Arrays . setAll ( a , i -> in . nextLong ( ) ) ; pw . println ( solve ( n , a , s ) ) ; pw . close ( ) ; } static long solve ( int n , long [ ] a , long s ) { long ans = - 1 ; long sum = 0 ; long r = Long . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; r = Math . min ( a [ i ] , r ) ; } if ( sum < s ) return - 1 ; long l = 0 ; while ( l <= r ) { long mid = ( l + r ) / 2 ; if ( possible ( n , a , s , mid ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } return ans ; } static boolean possible ( int n , long [ ] a , long s , long least ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( a [ i ] - least ) ; if ( s <= sum ) return true ; return false ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . lang . Math ; public class GFG { static int longestSubstring ( String s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; } public static void main ( String [ ] args ) { String s = " ccccdeededff " ; System . out . println ( longestSubstring ( s ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . run ( ) ; } public void run ( ) { Scanner sc = new Scanner ( System . in ) ; long k = sc . nextLong ( ) ; int n = 50 ; long sum = k / n ; long amari = k % n ; long a [ ] = new long [ 50 ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = i + sum ; } for ( int i = 0 ; i < amari ; i ++ ) { a [ n - 1 - i ] ++ ; } System . out . println ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + ( i == n - 1 ? " \n " : " ▁ " ) ) ; } sc . close ( ) ; } }
public class GFG { static int zeroUpto ( int digits ) { int first = ( int ) ( ( Math . pow ( 10 , digits ) - 1 ) / 9 ) ; int second = ( int ) ( ( Math . pow ( 9 , digits ) - 1 ) / 8 ) ; return 9 * ( first - second ) ; } static int toInt ( char c ) { return ( int ) ( c ) - 48 ; } static int countZero ( String num ) { int k = num . length ( ) ; int total = zeroUpto ( k - 1 ) ; int non_zero = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { if ( num . charAt ( i ) == '0' ) { non_zero -- ; break ; } non_zero += ( toInt ( num . charAt ( i ) ) - 1 ) * ( Math . pow ( 9 , k - 1 - i ) ) ; } int no = 0 , remaining = 0 , calculatedUpto = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { no = no * 10 + ( toInt ( num . charAt ( i ) ) ) ; if ( i != 0 ) calculatedUpto = calculatedUpto * 10 + 9 ; } remaining = no - calculatedUpto ; int ans = zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) ; return ans ; } static public void main ( String [ ] args ) { String num = "107" ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + countZero ( num ) ) ; num = "1264" ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + countZero ( num ) ) ; } }
import java . io . * ; public class GFG { static float cone ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( String . format ( " % . 4 f " , cone ( a ) ) ) ; } }
import java . util . * ; public class GFG { static boolean Prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static boolean checkSumPrime ( String str ) { int summ = 0 ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) summ += Math . abs ( str . charAt ( i - 1 ) - str . charAt ( i ) ) ; if ( Prime ( summ ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int num = 142 ; String str = "142" ; if ( checkSumPrime ( str ) ) System . out . println ( " Prime " ) ; else System . out . println ( " Not ▁ Prime " ) ; } }
import java . io . * ; public class GFG { float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; } public static void main ( String args [ ] ) { GFG g = new GFG ( ) ; System . out . println ( String . format ( " % . 3 f " , g . sum ( 8 ) ) ) ; System . out . print ( String . format ( " % . 3 f " , g . sum ( 10 ) ) ) ; } }
public class GFG { static int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int p [ ] = { 2 , 5 , 1 , 3 , 4 } ; int n = p . length ; System . out . println ( countElements ( p , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char a = sc . next ( ) . toCharArray ( ) [ 0 ] ; char b = sc . next ( ) . toCharArray ( ) [ 0 ] ; if ( a > b ) { System . out . println ( ' > ' ) ; } else if ( a == b ) { System . out . println ( ' = ' ) ; } else { System . out . println ( ' < ' ) ; } } }
import java . io . * ; public class GFG { static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } public static void main ( String [ ] args ) { float l = 18 , b = 12 , h = 9 ; System . out . println ( " Volume ▁ of ▁ triangular ▁ prism : ▁ " + findVolume ( l , b , h ) ) ; } }
import java . io . * ; import java . util . * ; public class practice462b { public static void main ( String [ ] args ) throws Exception { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int k = Integer . parseInt ( st . nextToken ( ) ) ; c462b [ ] cards = new c462b [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { cards [ i ] = new c462b ( ) ; } String s = f . readLine ( ) ; for ( int t = 0 ; t < n ; t ++ ) { cards [ s . charAt ( t ) - ' A ' ] . left ++ ; } long ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { Arrays . sort ( cards ) ; long change = Math . min ( cards [ 25 ] . left , k - i ) ; ans += change * change ; cards [ 25 ] . left -= change ; i += change - 1 ; } out . println ( ans ) ; out . close ( ) ; } } class c462b implements Comparable { int left = 0 ; @ Override public int compareTo ( Object o ) { return left - ( ( c462b ) o ) . left ; } }
public final class p045 { public static void main ( String [ ] args ) { System . out . println ( new p045 ( ) . run ( ) ) ; } public String run ( ) { int i = 286 ; int j = 166 ; int k = 144 ; while ( true ) { long triangle = ( long ) i * ( i + 1 ) / 2 ; long pentagon = ( long ) j * ( j * 3 - 1 ) / 2 ; long hexagon = ( long ) k * ( k * 2 - 1 ) ; long min = Math . min ( Math . min ( triangle , pentagon ) , hexagon ) ; if ( min == triangle && min == pentagon && min == hexagon ) return Long . toString ( min ) ; if ( min == triangle ) i ++ ; if ( min == pentagon ) j ++ ; if ( min == hexagon ) k ++ ; } } }
public class GFG { static int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; boolean [ ] arr = new boolean [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; } public static void main ( String [ ] args ) { int N = 500 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }
import java . util . * ; public class GFG { static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; } static boolean checkDivisors ( int a [ ] , int n ) { int X = max_element ( a ) ; Vector < Integer > b = new Vector < Integer > ( ) ; for ( int i = 1 ; i * i <= X ; i ++ ) { if ( X % i == 0 ) { b . add ( i ) ; if ( X / i != i ) b . add ( X / i ) ; } } if ( b . size ( ) != n ) return false ; Arrays . sort ( a ) ; Collections . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( b . get ( i ) != a [ i ] ) return false ; } return true ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 } ; int N = arr . length ; if ( checkDivisors ( arr , N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; static void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { System . out . println ( " All ▁ Non - empty ▁ Subarrays " ) ; subArray ( arr . length ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int tc = input . nextInt ( ) ; work : while ( tc -- > 0 ) { long n = input . nextLong ( ) ; long x = Long . MAX_VALUE ; long y = Long . MIN_VALUE ; if ( n % 6 == 0 ) { x = Math . min ( x , n / 6 ) ; y = Math . max ( y , n / 6 ) ; } if ( n % 6 == 2 && n != 2 ) { x = Math . min ( x , ( ( n / 6 ) - 1 ) + 2 ) ; y = Math . max ( y , ( ( n / 6 ) - 1 ) + 2 ) ; } if ( n % 6 == 4 && n != 4 ) { x = Math . min ( x , n / 6 + 1 ) ; y = Math . max ( y , n / 6 + 1 ) ; } if ( n % 4 == 0 ) { x = Math . min ( x , n / 4 ) ; y = Math . max ( y , n / 4 ) ; } if ( n % 4 == 2 && n != 2 ) { x = Math . min ( x , ( n / 4 ) - 1 + 1 ) ; y = Math . max ( y , ( n / 4 ) - 1 + 1 ) ; } if ( x != Long . MAX_VALUE && y != Long . MIN_VALUE ) System . out . println ( x + " ▁ " + y ) ; else { System . out . println ( " - 1" ) ; } } } }
import java . util . * ; public class GFG { static int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 6 , 1 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . util . Arrays ; public class GFG { static int maxSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 1 , 4 , 5 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int findAnswer ( int n , int [ ] arr ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 53 , 28 , 143 , 5 } ; int n = arr . length ; System . out . println ( findAnswer ( n , arr ) ) ; } }
import java . util . Arrays ; public class GFG { static int findSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { sum = sum + arr [ i + 1 ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( findSum ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static class Node { int data ; Node left , right ; } ; static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static Node getDeepestLeftLeafNode ( Node root ) { if ( root == null ) return null ; Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; Node result = null ; while ( ! q . isEmpty ( ) ) { Node temp = q . peek ( ) ; q . remove ( ) ; if ( temp . left != null ) { q . add ( temp . left ) ; if ( temp . left . left == null && temp . left . right == null ) result = temp . left ; } if ( temp . right != null ) q . add ( temp . right ) ; } return result ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 6 ) ; root . right . left . right = newNode ( 7 ) ; root . right . right . right = newNode ( 8 ) ; root . right . left . right . left = newNode ( 9 ) ; root . right . right . right . right = newNode ( 10 ) ; Node result = getDeepestLeftLeafNode ( root ) ; if ( result != null ) System . out . println ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : ▁ " + result . data ) ; else System . out . println ( " No ▁ result , ▁ " + " left ▁ leaf ▁ not ▁ found " ) ; } }
import java . util . * ; public class GFG { static class Node { int data ; Node left , right ; } ; static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static Node getDeepestRightLeafNode ( Node root ) { if ( root == null ) return null ; Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; Node result = null ; while ( ! q . isEmpty ( ) ) { Node temp = q . peek ( ) ; q . poll ( ) ; if ( temp . left != null ) { q . add ( temp . left ) ; } if ( temp . right != null ) { q . add ( temp . right ) ; if ( temp . right . left == null && temp . right . right == null ) result = temp . right ; } } return result ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . right = newNode ( 4 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 6 ) ; root . right . left . right = newNode ( 7 ) ; root . right . right . right = newNode ( 8 ) ; root . right . left . right . left = newNode ( 9 ) ; root . right . right . right . right = newNode ( 10 ) ; Node result = getDeepestRightLeafNode ( root ) ; if ( result != null ) System . out . println ( " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : : ▁ " + result . data ) ; else System . out . println ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found \n " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; long [ ] arr = new long [ n + 1 ] ; arr [ 0 ] = 2 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i < arr . length ; i ++ ) arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; System . out . println ( arr [ n ] ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static void printRatio ( int a , int b , int c , int d ) { if ( b * c > a * d ) { int temp = c ; c = d ; d = c ; temp = a ; a = b ; b = temp ; } int lcm = ( a * c ) / __gcd ( a , c ) ; int x = lcm / a ; b *= x ; int y = lcm / c ; d *= y ; int k = __gcd ( b , d ) ; b /= k ; d /= k ; System . out . print ( b + " : " + d ) ; } public static void main ( String [ ] args ) { int a = 4 , b = 3 , c = 2 , d = 2 ; printRatio ( a , b , c , d ) ; } }
public class GFG { static int maxsum_SIS ( int arr [ ] , int n ) { int max_sum = 0 ; int current_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] ) { current_sum = current_sum + arr [ i ] ; } else { max_sum = Math . max ( max_sum , current_sum ) ; current_sum = arr [ i ] ; } } return Math . max ( max_sum , current_sum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 4 } ; int n = arr . length ; System . out . println ( " Maximum ▁ sum ▁ : ▁ " + maxsum_SIS ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static int findMaxSumUtil ( int arr [ ] , int n ) { int finalGCD = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) finalGCD = GCD ( arr [ i ] , finalGCD ) ; return finalGCD ; } static int findMaxSum ( int arr [ ] , int n ) { int maxElement = findMaxSumUtil ( arr , n ) ; return ( maxElement * n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 20 , 12 , 36 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } static int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; } public static void main ( String [ ] args ) { int a = 20 , b = 52 , x = 5 , y = 7 ; System . out . println ( findMinDiff ( a , b , x , y ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int a = stdIn . nextInt ( ) ; while ( a -- != 0 ) { int X = stdIn . nextInt ( ) ; int Y = stdIn . nextInt ( ) ; int W = stdIn . nextInt ( ) ; int H = stdIn . nextInt ( ) ; int N = stdIn . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int x = stdIn . nextInt ( ) ; int y = stdIn . nextInt ( ) ; if ( ( X <= x && x <= X + W ) && ( Y <= y && y <= Y + H ) ) { ++ count ; } } System . out . println ( count ) ; } } }
public class GFG { static int divisibleby37 ( String n1 ) { int l = n1 . length ( ) ; if ( n1 == "0" ) return 0 ; if ( l % 3 == 1 ) { n1 = "00" + n1 ; l += 2 ; } else if ( l % 3 == 2 ) { n1 = "0" + n1 ; l += 1 ; } char [ ] n = n1 . toCharArray ( ) ; int gSum = 0 ; while ( l != 0 ) { int gvalue ; if ( l == 2 ) gvalue = ( ( int ) n [ ( l - 2 ) ] - 48 ) * 100 + ( ( int ) n [ ( l - 1 ) ] - 48 ) * 10 ; else if ( l == 1 ) gvalue = ( ( int ) n [ ( l - 1 ) ] - 48 ) * 100 ; else gvalue = ( ( int ) n [ ( l - 3 ) ] - 48 ) * 100 + ( ( int ) n [ ( l - 2 ) ] - 48 ) * 10 + ( ( int ) n [ ( l - 1 ) ] - 48 ) * 1 ; l = l - 3 ; gSum = gSum + gvalue ; } if ( gSum >= 1000 ) return ( divisibleby37 ( String . valueOf ( gSum ) ) ) ; else return ( gSum % 37 == 0 ) ? 1 : 0 ; } public static void main ( String [ ] args ) { String s = "8955795758" ; if ( divisibleby37 ( s ) == 1 ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; } }
import java . util . * ; import java . io . * ; public class A111 { static FastScanner fs = null ; public static void main ( String [ ] args ) { fs = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; long n = fs . nextLong ( ) ; long x = fs . nextLong ( ) ; long y = fs . nextLong ( ) ; long p = y - n + ( long ) 1 ; long pow = p * p + n - ( long ) 1 ; if ( pow < x || p <= 0 ) { out . println ( " - 1" ) ; } else { for ( long i = 1 ; i < n ; i ++ ) { out . println ( "1" ) ; } out . println ( p ) ; } out . println ( ) ; out . close ( ) ; } static void sort ( int [ ] a ) { ArrayList < Integer > l = new ArrayList < > ( ) ; for ( int i : a ) l . add ( i ) ; Collections . sort ( l ) ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = l . get ( i ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
import java . io . * ; public class GFG { static int lcs ( String X , String Y , int m , int n ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } static int findMinCost ( String X , String Y , int costX , int costY ) { int m = X . length ( ) ; int n = Y . length ( ) ; int len_LCS ; len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; } public static void main ( String [ ] args ) { String X = " ef " ; String Y = " gh " ; System . out . println ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ " + " ▁ identical ▁ is ▁ = ▁ " + findMinCost ( X , Y , 10 , 20 ) ) ; } }
class Squares { public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; } public static void main ( String args [ ] ) { int base = 8 ; System . out . println ( numberOfSquares ( base ) ) ; } }
public class GFG { static float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . sqrt ( mean ) ; return root ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 4 , 6 , 8 } ; int n = arr . length ; System . out . println ( String . format ( " % . 4 f " , rmsValue ( arr , n ) ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int M = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int [ ] P = new int [ M ] ; for ( int i = 0 ; i < M ; ++ i ) { P [ i ] = sc . nextInt ( ) ; } Arrays . sort ( P ) ; int [ ] dp = new int [ M + 10001 ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int C = sc . nextInt ( ) ; int E = sc . nextInt ( ) ; for ( int j = dp . length - 1 ; j - C >= 0 ; -- j ) { if ( dp [ j - C ] == Integer . MAX_VALUE ) continue ; dp [ j ] = Math . min ( dp [ j ] , dp [ j - C ] + E ) ; } } int [ ] sum = new int [ dp . length ] ; for ( int i = 0 ; i < M ; ++ i ) { sum [ i + 1 ] = sum [ i ] + P [ M - 1 - i ] ; } for ( int i = M + 1 ; i < sum . length ; ++ i ) { sum [ i ] = sum [ M ] ; } int ans = 0 ; for ( int i = 0 ; i < sum . length ; ++ i ) { if ( dp [ i ] == Integer . MAX_VALUE ) continue ; ans = Math . max ( ans , sum [ i ] - dp [ i ] ) ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] array = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { array [ i ] = scanner . nextInt ( ) ; } for ( int i = 1 ; i <= n ; i ++ ) { System . out . printf ( " node ▁ % d : ▁ key ▁ = ▁ % d , ▁ " , i , array [ i ] ) ; if ( i / 2 > 0 ) System . out . printf ( " parent ▁ key ▁ = ▁ % d , ▁ " , array [ i / 2 ] ) ; if ( 2 * i <= n ) System . out . printf ( " left ▁ key ▁ = ▁ % d , ▁ " , array [ 2 * i ] ) ; if ( ( 2 * i + 1 ) <= n ) System . out . printf ( " right ▁ key ▁ = ▁ % d , ▁ " , array [ 2 * i + 1 ] ) ; System . out . print ( " \n " ) ; } } }
public class GFG { static int n = 6 , m = 6 ; static void maxSum ( long arr [ ] [ ] ) { long [ ] [ ] dp = new long [ n + 1 ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( j / ( m / 3 ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } System . out . print ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) + " \n " ) ; } public static void main ( String [ ] args ) { long arr [ ] [ ] = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; } }
public class GFG { static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 || y5 > y6 ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; } public static void main ( String args [ ] ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } }
import java . util . * ; public class _424A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; sc . nextLine ( ) ; String s = sc . nextLine ( ) ; int sittingToStanding = 0 ; int sitting = 0 , standing = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' x ' ) { sitting ++ ; } else { standing ++ ; } } sittingToStanding = ( sitting - standing ) / 2 ; System . out . println ( Math . abs ( sittingToStanding ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' x ' && sittingToStanding > 0 ) { System . out . print ( ' X ' ) ; sittingToStanding -- ; } else if ( s . charAt ( i ) == ' X ' && sittingToStanding < 0 ) { System . out . print ( ' x ' ) ; sittingToStanding ++ ; } else { System . out . print ( s . charAt ( i ) ) ; } } } }
import java . util . * ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class class1 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String arg [ ] ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int d = input . nextInt ( ) ; int e = input . nextInt ( ) ; int ans = n ; for ( int i = 0 ; i * 5 * e <= n ; ++ i ) { ans = Math . min ( ans , ( n - i * 5 * e ) % d ) ; } System . out . println ( ans ) ; } }
public class GFG { static float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = Integer . MIN_VALUE ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; } public static void main ( String [ ] args ) { float val [ ] = { 14 , 27 , 44 , 19 } ; float wt [ ] = { 6 , 7 , 9 , 8 } ; int n = val . length ; int W = 50 ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
import java . util . * ; public class GFG { static void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; Vector v1 = new Vector ( ) ; Vector v2 = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . add ( arr [ i ] ) ; else v2 . add ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; boolean flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 . get ( i ) ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 . get ( j ) ; j += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 8 , 13 , 2 , 19 , 14 } ; int n = arr . length ; AlternateRearrange ( arr , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int A = scan . nextInt ( ) ; int B = scan . nextInt ( ) ; int C = scan . nextInt ( ) ; if ( A <= C && B >= C ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; public class GFG { static String decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } String binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binary += String . valueOf ( binaryNum [ j ] ) ; } return binary ; } static int countFreq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } static void findOccurrence ( int arr [ ] , int n , String pattern ) { for ( int i = 0 ; i < n ; i ++ ) { String binary = decToBinary ( arr [ i ] ) ; System . out . print ( countFreq ( pattern , binary ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 106 , 7 , 8 } ; String pattern = "10" ; int n = arr . length ; findOccurrence ( arr , n , pattern ) ; } }
public class GFG { static void makearrayequal ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += ( arr [ i ] & 1 ) ; } System . out . println ( Math . min ( x , n - x ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 2 , 1 } ; int n = arr . length ; makearrayequal ( arr , n ) ; } }
import java . util . * ; class Solution { public int findKthLargest ( int [ ] nums , int k ) { shuffle ( nums ) ; k = nums . length - k ; int lo = 0 ; int hi = nums . length - 1 ; while ( lo < hi ) { final int j = partition ( nums , lo , hi ) ; if ( j < k ) { lo = j + 1 ; } else if ( j > k ) { hi = j - 1 ; } else { break ; } } return nums [ k ] ; } private int partition ( int [ ] a , int lo , int hi ) { int i = lo ; int j = hi + 1 ; while ( true ) { while ( i < hi && less ( a [ ++ i ] , a [ lo ] ) ) ; while ( j > lo && less ( a [ lo ] , a [ -- j ] ) ) ; if ( i >= j ) { break ; } exch ( a , i , j ) ; } exch ( a , lo , j ) ; return j ; } private void exch ( int [ ] a , int i , int j ) { final int tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } private boolean less ( int v , int w ) { return v < w ; } private void shuffle ( int a [ ] ) { final Random random = new Random ( ) ; for ( int ind = 1 ; ind < a . length ; ind ++ ) { final int r = random . nextInt ( ind + 1 ) ; exch ( a , ind , r ) ; } } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 3 , 2 , 1 , 5 , 6 , 4 } ; int k = 2 ; int out = sObj . findKthLargest ( nums , k ) ; System . out . println ( out ) ; } }
public class GFG { static String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; } public static void main ( String [ ] args ) { int n = 9876543 ; System . out . println ( isDivisible ( n ) ) ; } }
public class GFG { static String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; } public static void main ( String [ ] args ) { long n = 123 ; System . out . println ( isDivisible ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; String a = s . next ( ) ; String b = s . next ( ) ; String answer = " " ; int naa = a . length ( ) ; int nab = b . length ( ) ; int i = 0 ; if ( naa == nab ) { if ( a . equals ( b ) ) { answer = " EQUAL " ; } else { for ( i = 0 ; i < naa ; i ++ ) { int q = a . charAt ( i ) + 0 ; int l = b . charAt ( i ) - 0 ; if ( q > l ) { answer = " GREATER " ; break ; } else if ( q < l ) { answer = " LESS " ; break ; } } } } else if ( naa > nab ) { answer = " GREATER " ; } else if ( naa < nab ) { answer = " LESS " ; } System . out . println ( answer ) ; } }
public class GFG { static int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } public static void main ( String [ ] args ) { int l = 4 , b = 3 ; System . out . println ( calculateAreaSum ( l , b ) ) ; } }
public class GFG { static void arrange ( int N ) { if ( N == 1 ) { System . out . println ( "1" ) ; return ; } if ( N == 2 || N == 3 ) { System . out . println ( " - 1" ) ; return ; } int even = - 1 , odd = - 1 ; if ( N % 2 == 0 ) { even = N ; odd = N - 1 ; } else { odd = N ; even = N - 1 ; } while ( odd >= 1 ) { System . out . print ( odd ) ; System . out . print ( " ▁ " ) ; odd = odd - 2 ; } while ( even >= 2 ) { System . out . print ( even ) ; System . out . print ( " ▁ " ) ; even = even - 2 ; } } public static void main ( String [ ] args ) { int N = 5 ; arrange ( N ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) { min = Math . abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; } public static void main ( String args [ ] ) { int [ ] a = { 3 , 2 , 1 , 5 , 7 , 8 } ; int N = a . length ; System . out . println ( findMinEqualSums ( a , N ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) ; StringBuilder builder = new StringBuilder ( ) ; int mod = n % 3 ; if ( mod == 1 ) { for ( int j = 0 ; j < n / 3 ; j ++ ) { builder . append ( 12 ) ; } builder . append ( 1 ) ; } else { for ( int j = 0 ; j < n / 3 ; j ++ ) { builder . append ( 21 ) ; } if ( mod == 2 ) { builder . append ( 2 ) ; } } System . out . println ( builder ) ; } scanner . close ( ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; } public static void main ( String args [ ] ) { int [ ] a = { 1 , 4 , 2 , 3 , 9 } ; int N = a . length ; System . out . println ( findOptimalSolution ( a , N ) ) ; } }
import java . io . * ; import java . util . * ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . stream . Collectors ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedInputStream in = new BufferedInputStream ( new DataInputStream ( System . in ) ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; int [ ] tasks = Arrays . stream ( reader . readLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; Queue < Integer > taskList = new LinkedBlockingQueue < > ( ) ; Queue < Long > events = new PriorityQueue < > ( tasks [ 0 ] ) ; long [ ] taskDur = new long [ tasks [ 0 ] ] ; for ( int i = 0 ; i < tasks [ 0 ] ; i ++ ) { long [ ] taskInput = Arrays . stream ( reader . readLine ( ) . split ( " ▁ " ) ) . mapToLong ( Long :: parseLong ) . toArray ( ) ; taskDur [ i ] = taskInput [ 1 ] ; events . add ( taskInput [ 0 ] * 2 + 1 ) ; } long [ ] sol = new long [ tasks [ 0 ] ] ; int nextTask = 0 ; while ( events . size ( ) > 0 ) { long event = events . poll ( ) ; long time = event / 2 ; if ( event % 2 == 0 ) { int taskId = taskList . poll ( ) ; sol [ taskId ] = time ; if ( ! taskList . isEmpty ( ) ) { events . add ( ( time + taskDur [ taskList . peek ( ) ] ) * 2 ) ; } } else { int task = nextTask ++ ; if ( taskList . size ( ) <= tasks [ 1 ] ) { taskList . add ( task ) ; if ( taskList . size ( ) == 1 ) { events . add ( ( time + taskDur [ task ] ) * 2 ) ; } } else { sol [ task ] = - 1 ; } } } System . out . println ( Arrays . stream ( sol ) . boxed ( ) . map ( Object :: toString ) . collect ( Collectors . joining ( " ▁ " ) ) ) ; } }
import java . util . Arrays ; import java . util . HashSet ; import java . util . Scanner ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; if ( n > m ) { System . out . println ( " NO " ) ; continue ; } Arrays . sort ( a ) ; long ans = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { ans ++ ; if ( i > 0 ) ans += a [ i ] ; } if ( ans <= m ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
public class GFG { static int getPairs ( int a [ ] ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 4 , 3 , 1 } ; System . out . println ( getPairs ( a ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . StringTokenizer ; import java . util . TreeSet ; import java . util . * ; import static java . lang . System . * ; import static java . lang . Math . * ; public class pre5 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; int n = obj . nextInt ( ) , k = obj . nextInt ( ) ; char num [ ] = obj . next ( ) . toCharArray ( ) ; if ( n == 1 && k > 0 ) { out . println ( 0 ) ; return ; } for ( int i = 0 ; i < n && k > 0 ; i ++ ) { if ( i == 0 ) { if ( num [ i ] == '1' ) continue ; num [ i ] = '1' ; k -- ; } else { if ( num [ i ] == '0' ) continue ; num [ i ] = '0' ; k -- ; } } for ( int i = 0 ; i < n ; i ++ ) out . print ( num [ i ] ) ; } }
import java . util . Scanner ; public class main1 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int arr [ ] [ ] = new int [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { arr [ i ] [ j ] = sc . nextInt ( ) ; } } if ( arr [ 0 ] [ 3 ] == 1 ) { if ( arr [ 0 ] [ 1 ] == 1 || arr [ 0 ] [ 2 ] == 1 || arr [ 0 ] [ 0 ] == 1 || arr [ 1 ] [ 0 ] == 1 || arr [ 2 ] [ 1 ] == 1 || arr [ 3 ] [ 2 ] == 1 ) { System . out . println ( " YES " ) ; return ; } } if ( arr [ 1 ] [ 3 ] == 1 ) { if ( arr [ 1 ] [ 1 ] == 1 || arr [ 1 ] [ 2 ] == 1 || arr [ 1 ] [ 0 ] == 1 || arr [ 2 ] [ 0 ] == 1 || arr [ 3 ] [ 1 ] == 1 || arr [ 0 ] [ 2 ] == 1 ) { System . out . println ( " YES " ) ; return ; } } if ( arr [ 2 ] [ 3 ] == 1 ) { if ( arr [ 2 ] [ 1 ] == 1 || arr [ 2 ] [ 2 ] == 1 || arr [ 2 ] [ 0 ] == 1 || arr [ 3 ] [ 0 ] == 1 || arr [ 0 ] [ 1 ] == 1 || arr [ 1 ] [ 2 ] == 1 ) { System . out . println ( " YES " ) ; return ; } } if ( arr [ 3 ] [ 3 ] == 1 ) { if ( arr [ 3 ] [ 1 ] == 1 || arr [ 3 ] [ 2 ] == 1 || arr [ 3 ] [ 0 ] == 1 || arr [ 0 ] [ 0 ] == 1 || arr [ 1 ] [ 1 ] == 1 || arr [ 2 ] [ 2 ] == 1 ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } }
public class GFG { static int N = 10000 ; static int MOD = 1000000007 ; static int [ ] F = new int [ N ] ; static void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; } public static void main ( String [ ] args ) { int n = 8 ; precompute ( ) ; System . out . println ( F [ n ] ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] z ) { int i , j , k , c , t , b ; Scanner s = new Scanner ( System . in ) ; for ( ; ( t = s . nextInt ( ) ) > 0 ; System . out . println ( b ) ) for ( b = i = 0 ; i ++ < t ; ) for ( j = i + 1 ; j ++ < t ; b += c == t ? 1 : 0 ) for ( c = 0 , k = i ; k < j ; k ++ ) c += k ; } }
import java . io . * ; import java . util . * ; import java . lang . Math ; class LIS { static int CeilIndex ( int A [ ] , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( A [ m ] >= key ) r = m ; else l = m ; } return r ; } static int LongestIncreasingSubsequenceLength ( int A [ ] , int size ) { int [ ] tailTable = new int [ size ] ; int len ; tailTable [ 0 ] = A [ 0 ] ; len = 1 ; for ( int i = 1 ; i < size ; i ++ ) { if ( A [ i ] < tailTable [ 0 ] ) tailTable [ 0 ] = A [ i ] ; else if ( A [ i ] > tailTable [ len - 1 ] ) tailTable [ len ++ ] = A [ i ] ; else tailTable [ CeilIndex ( tailTable , - 1 , len - 1 , A [ i ] ) ] = A [ i ] ; } return len ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 } ; int n = A . length ; System . out . println ( " Length ▁ of ▁ Longest ▁ Increasing ▁ Subsequence ▁ is ▁ " + LongestIncreasingSubsequenceLength ( A , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int N = s . nextInt ( ) ; int [ ] ban = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ban [ i ] = s . nextInt ( ) ; Arrays . sort ( ban ) ; System . out . println ( ( ban [ N - 1 ] - ban [ 0 ] + 1 ) / 2 ) ; } }
import java . util . HashSet ; import java . util . Set ; public final class p074 { public static void main ( String [ ] args ) { System . out . println ( new p074 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { int count = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( getChainLength ( i ) == 60 ) count ++ ; } return Integer . toString ( count ) ; } private static int getChainLength ( int n ) { Set < Integer > seen = new HashSet < > ( ) ; while ( true ) { if ( ! seen . add ( n ) ) return seen . size ( ) ; n = factorialize ( n ) ; } } private static int [ ] FACTORIAL = { 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 } ; private static int factorialize ( int n ) { int sum = 0 ; for ( ; n != 0 ; n /= 10 ) sum += FACTORIAL [ n % 10 ] ; return sum ; } }
import java . io . * ; public class GFG { static int colourVisible ( int height [ ] , int colour [ ] , int K ) { int arr [ ] = new int [ K + 1 ] ; int visible = 0 ; int max = height [ K - 1 ] ; arr [ colour [ K - 1 ] ] = 1 ; for ( int i = K - 2 ; i >= 0 ; i -- ) { if ( height [ i ] > max ) { max = height [ i ] ; arr [ colour [ i ] ] = 1 ; } } for ( int i = 1 ; i <= K ; i ++ ) { if ( arr [ i ] == 1 ) visible ++ ; } return visible ; } public static void main ( String [ ] args ) { int height [ ] = { 3 , 5 , 1 , 2 , 3 } ; int colour [ ] = { 1 , 2 , 3 , 4 , 3 } ; int K = colour . length ; System . out . println ( colourVisible ( height , colour , K ) ) ; } }
public class GFG { static boolean checkPowerof8 ( int n ) { double i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; } public static void main ( String args [ ] ) { int n = 65 ; if ( checkPowerof8 ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; for ( int t = in . nextInt ( ) ; t > 0 ; t -- ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int res = Math . min ( ( a + b ) / 4 , Math . min ( a , b ) ) ; System . out . println ( res ) ; } } }
import java . util . ArrayList ; import java . util . Scanner ; public class Main { public ArrayList < Integer > maxes ; public static void main ( String [ ] args ) { ( new Main ( ) ) . go ( ) ; } public void go ( ) { this . maxes = new ArrayList < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n == 0 && m == 0 ) { break ; } int [ ] points = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { points [ j ] += sc . nextInt ( ) ; if ( i == m - 1 && max < points [ j ] ) { max = points [ j ] ; } } } this . maxes . add ( max ) ; } for ( Integer max : maxes ) { System . out . println ( max ) ; } sc . close ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; int [ ] l = new int [ n ] ; int [ ] r = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { l [ i ] = in . nextInt ( ) ; r [ i ] = in . nextInt ( ) ; } int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s < r [ i ] ) { if ( l [ i ] > s ) s = l [ i ] ; else { s ++ ; } System . out . print ( s + " ▁ " ) ; } else { System . out . print ( 0 + " ▁ " ) ; } } System . out . println ( ) ; } } }
import java . io . * ; public class GFG { static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; } public static void main ( String [ ] args ) { int n = 7 ; int m = 4 ; System . out . println ( " Number ▁ of ▁ ways ▁ = ▁ " + countWays ( n , m ) ) ; } }
public class GFG { static void print ( int n ) { System . out . println ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 3 ; print ( n ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { BufferedReader bfr = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = " " ; try { str = bfr . readLine ( ) ; long res = 0 ; long han = 0 ; long ni_beki = 1 ; int ruijyo = 0 ; if ( str == " " ) { System . exit ( 0 ) ; } else { res = Long . parseLong ( str ) ; for ( int i = 0 ; i < 1 ; ) { han = ( res >> ruijyo ) % 2 ; if ( han == 0 ) { res = ( res % ni_beki ) + 1 ; i = 1 ; break ; } else { ni_beki = ni_beki * 2 ; ruijyo ++ ; } } System . out . println ( res ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; while ( s . contains ( "0B " ) || s . contains ( "1B " ) ) { s = s . replaceAll ( "0B " , " " ) ; s = s . replaceAll ( "1B " , " " ) ; } s = s . replaceAll ( " B " , " " ) ; System . out . println ( s ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Scanner ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . stream . Collectors ; import java . util . stream . IntStream ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; while ( true ) { Integer a = scanner . nextInt ( ) ; Integer b = scanner . nextInt ( ) ; if ( a == 0 && b == 0 ) { break ; } AtomicInteger count = new AtomicInteger ( 0 ) ; List < String > used = new ArrayList < > ( ) ; IntStream . range ( 1 , a + 1 ) . forEach ( x -> { IntStream . range ( 1 , a + 1 ) . filter ( y -> y != x ) . forEach ( y -> { IntStream . range ( 1 , a + 1 ) . filter ( z -> z != x && z != y ) . filter ( z -> x + y + z == b ) . forEach ( z -> { String sorted = Arrays . asList ( x , y , z ) . stream ( ) . sorted ( ) . collect ( Collectors . toList ( ) ) . toString ( ) ; if ( used . contains ( sorted ) ) { return ; } used . add ( sorted ) ; count . getAndAdd ( 1 ) ; } ) ; } ) ; } ) ; System . out . println ( count . get ( ) ) ; } } }
import java . util . * ; public class GFG { static int MAX = 100 ; static int recur ( int ind , int cnt , int last , int a [ ] , int n , int k , int dp [ ] [ ] ) { if ( cnt == k ) return 0 ; if ( ind == n ) return ( int ) - 1e9 ; if ( dp [ ind ] [ cnt ] != - 1 ) return dp [ ind ] [ cnt ] ; int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( cnt % 2 == 0 ) ans = Math . max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = Math . max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } return dp [ ind ] [ cnt ] = ans ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 } ; int n = a . length ; int k = 4 ; int [ ] [ ] dp = new int [ n ] [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . println ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) ; } }
import java . io . * ; import java . util . * ; final public class A { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; Double [ ] arr = new Double [ 2 * n ] ; int non_int = 0 ; double sum_before = 0 , sum = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { double num = Double . parseDouble ( st . nextToken ( ) ) ; sum_before += num ; if ( num != Math . floor ( num ) ) non_int ++ ; sum += Math . floor ( num ) ; arr [ i ] = num ; } double max_sum = Math . min ( n , non_int ) + sum ; double min_sum = Math . max ( 0 , non_int - n ) + sum ; double ans ; if ( min_sum > sum_before ) ans = ( min_sum - sum_before ) ; else if ( max_sum < sum_before ) ans = ( sum_before - max_sum ) ; else { double x = sum_before - Math . floor ( sum_before ) ; ans = Math . min ( 1 - x , x ) ; } System . out . printf ( " % .3f " , ans ) ; } }
public class GFG { static int equivalentBase4 ( String bin ) { if ( bin . compareTo ( "00" ) == 0 ) return 0 ; if ( bin . compareTo ( "01" ) == 0 ) return 1 ; if ( bin . compareTo ( "10" ) == 0 ) return 2 ; return 3 ; } static String isDivisibleBy5 ( String bin ) { int l = bin . length ( ) ; if ( l % 2 != 0 ) bin = '0' + bin ; int odd_sum = 0 , even_sum = 0 ; int isOddDigit = 1 ; for ( int i = 0 ; i < bin . length ( ) ; i += 2 ) { if ( isOddDigit != 0 ) odd_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; else even_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; isOddDigit ^= 1 ; } if ( Math . abs ( odd_sum - even_sum ) % 5 == 0 ) return " Yes " ; return " No " ; } public static void main ( String [ ] args ) { String bin = "10000101001" ; System . out . println ( isDivisibleBy5 ( bin ) ) ; } }
import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Queue ; import java . util . Scanner ; public class Main { static Queue < String > queue = new LinkedList < > ( ) ; static Map < String , Integer > map = new HashMap < > ( ) ; static String str ; static int [ ] [ ] d = { { 0 , 1 , 4 } , { - 1 , 1 , 4 } , { - 1 , 1 , 4 } , { - 1 , 0 , 4 } , { 0 , 1 , - 4 } , { - 1 , 1 , - 4 } , { - 1 , 1 , - 4 } , { - 1 , 0 , - 4 } } ; static void bfs ( ) { while ( ! queue . isEmpty ( ) ) { String str1 = queue . remove ( ) ; int point = map . get ( str1 ) ; String str2 = " " ; for ( int i = 0 ; i < 8 ; i ++ ) { if ( str1 . charAt ( i ) == '0' ) { for ( int j = 0 ; j < 3 ; j ++ ) { char change = str1 . charAt ( i + d [ i ] [ j ] ) ; str2 = str1 . replace ( '0' , '9' ) ; str2 = str2 . replace ( change , '0' ) ; str2 = str2 . replace ( '9' , change ) ; if ( map . get ( str2 ) == null ) { map . put ( str2 , point + 1 ) ; queue . add ( str2 ) ; } } break ; } } } } public static void main ( String args [ ] ) { try ( Scanner sc = new Scanner ( System . in ) ) { queue . add ( "01234567" ) ; map . put ( "01234567" , 0 ) ; bfs ( ) ; while ( sc . hasNext ( ) ) { String s = sc . nextLine ( ) ; String [ ] token = s . split ( " ▁ " ) ; str = " " ; for ( String t : token ) { str += t ; } System . out . println ( map . get ( str ) ) ; } } } }
import java . util . * ; public class SmallestNumber { static long min ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; min = Long . MAX_VALUE ; ArrayList < Long > arr = new ArrayList < > ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { arr . add ( sc . nextLong ( ) ) ; } String [ ] ops = new String [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { ops [ i ] = sc . next ( ) ; } util ( arr , ops , 0 ) ; System . out . println ( min ) ; } public static void util ( ArrayList < Long > arr , String [ ] ops , int idx ) { if ( idx == 3 ) { min = Math . min ( min , arr . get ( 0 ) ) ; return ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < arr . size ( ) ; j ++ ) { ArrayList < Long > a = new ArrayList < > ( ) ; for ( int k = 0 ; k < arr . size ( ) ; k ++ ) { if ( k != j && k != i ) { a . add ( arr . get ( k ) ) ; } } long res ; if ( idx < 3 && ops [ idx ] . equals ( " + " ) ) { res = arr . get ( i ) + arr . get ( j ) ; } else { res = arr . get ( i ) * arr . get ( j ) ; } a . add ( res ) ; util ( a , ops , idx + 1 ) ; } } } }
import java . util . Vector ; public class GFG { static final int MAX = 1005 ; static void SieveOfEratosthenes ( Vector < Integer > primes ) { boolean prime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { primes . add ( primes . size ( ) , p ) ; } } } static int minimumSquareFreeDivisors ( int N ) { Vector < Integer > primes = new Vector < > ( ) ; SieveOfEratosthenes ( primes ) ; int max_count = 0 ; for ( int i = 0 ; i < primes . size ( ) && primes . get ( i ) * primes . get ( i ) <= N ; i ++ ) { if ( N % primes . get ( i ) == 0 ) { int tmp = 0 ; while ( N % primes . get ( i ) == 0 ) { tmp ++ ; N /= primes . get ( i ) ; } max_count = Math . max ( max_count , tmp ) ; } } if ( max_count == 0 ) { max_count = 1 ; } return max_count ; } public static void main ( String [ ] args ) { int N = 24 ; System . out . println ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ " + minimumSquareFreeDivisors ( N ) ) ; N = 6 ; System . out . println ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ " + minimumSquareFreeDivisors ( N ) ) ; } }
import java . util . * ; import java . lang . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( ( x - a ) % b ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int idx = k - 1 ; boolean flag = true ; while ( idx < n ) { if ( arr [ idx ] != arr [ k - 1 ] ) { flag = false ; break ; } idx ++ ; } if ( ! flag ) { System . out . print ( - 1 ) ; } else { int i = k - 1 ; while ( i >= 0 ) { if ( arr [ i ] != arr [ k - 1 ] ) break ; i -- ; } System . out . println ( i + 1 ) ; } } }
public class GFG { static int fun ( int n ) { return n & ( n - 1 ) ; } public static void main ( String arg [ ] ) { int n = 7 ; System . out . print ( " The ▁ number ▁ after ▁ unsetting ▁ " + " the ▁ rightmost ▁ set ▁ bit ▁ " + fun ( n ) ) ; } }
import java . util . * ; public class GFG { static int LongestFibSubseq ( int A [ ] , int n ) { TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . contains ( y ) && ( y != S . last ( ) ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . length ; System . out . print ( LongestFibSubseq ( A , n ) ) ; } }
import java . util . * ; public class GFG { static int countPairs ( int a [ ] , int b [ ] , int n , int m ) { int cnt = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int sum = a [ i ] + b [ j ] ; if ( s . contains ( sum ) == false ) { cnt ++ ; s . add ( sum ) ; } } } return cnt ; } static public void main ( String args [ ] ) { int a [ ] = { 12 , 2 , 7 } ; int n = a . length ; int b [ ] = { 4 , 3 , 8 } ; int m = b . length ; System . out . println ( countPairs ( a , b , n , m ) ) ; } }
public class GFG { static boolean check ( int arr [ ] , int x , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 9 , 10 } ; int n = arr . length ; int x = 13 ; if ( check ( arr , x , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . ArrayList ; import java . util . Comparator ; import java . util . PriorityQueue ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; ArrayList < PriorityQueue < Integer > > pque = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { pque . add ( new PriorityQueue < Integer > ( Comparator . reverseOrder ( ) ) ) ; } int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int command = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; switch ( command ) { case 0 : int x = sc . nextInt ( ) ; pque . get ( t ) . offer ( x ) ; break ; case 1 : if ( ! pque . get ( t ) . isEmpty ( ) ) { System . out . println ( pque . get ( t ) . peek ( ) ) ; } break ; case 2 : if ( ! pque . get ( t ) . isEmpty ( ) ) { pque . get ( t ) . poll ( ) ; } break ; } } } }
import java . util . Arrays ; public class GFG { static int calculate_min_sum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int min_sum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { min_sum += Math . abs ( a [ i ] - a [ i - 1 ] ) ; } return min_sum ; } static int calculate_max_sum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int max_sum = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { max_sum += Math . abs ( a [ n - 1 - i ] - a [ i ] ) ; } return max_sum ; } public static void main ( String [ ] args ) { int [ ] a = { 10 , - 10 , 20 , - 40 } ; int n = a . length ; System . out . println ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + calculate_min_sum ( a , n ) ) ; System . out . println ( " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + calculate_max_sum ( a , n ) ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int m = sc . nextInt ( ) ; int [ ] b = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } int i = 0 ; while ( true ) { if ( i >= b . length ) { System . out . println ( "0" ) ; break ; } if ( i >= a . length ) { System . out . println ( "1" ) ; break ; } if ( a [ i ] > b [ i ] ) { System . out . println ( "0" ) ; break ; } if ( a [ i ] < b [ i ] ) { System . out . println ( "1" ) ; break ; } i ++ ; } } }
import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int sum ; Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; ArrayList < Integer > stateList = new ArrayList < Integer > ( ) ; int cnt4 = 0 ; int cnt2 = 0 ; int work = 0 ; for ( int i = 0 ; i < a ; i ++ ) { stateList . add ( sc . nextInt ( ) ) ; work = stateList . get ( i ) % 4 ; if ( work == 0 ) { cnt4 ++ ; } else { work = stateList . get ( i ) % 2 ; if ( work == 0 ) { cnt2 ++ ; } } } work = a / 2 ; if ( work <= cnt4 ) { System . out . println ( " Yes " ) ; return ; } work = a - ( cnt4 * 2 ) ; if ( ( work == 0 ) | ( cnt2 == 0 ) ) { System . out . println ( " No " ) ; return ; } if ( work == cnt2 ) { System . out . println ( " Yes " ) ; return ; } System . out . println ( " No " ) ; } }
import java . util . Arrays ; public class GFG { static boolean isPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) { return false ; } } return true ; } static boolean ans ( String s ) { String s2 = s ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { s2 = s2 . charAt ( s2 . length ( ) - 1 ) + s2 ; s2 = s2 . substring ( 0 , s2 . length ( ) - 1 ) ; if ( ( s == null ? s2 != null : ! s . equals ( s2 ) ) && isPalindrome ( s2 ) ) { return true ; } } return false ; } static int solve ( String s ) { if ( s . length ( ) <= 3 ) { return - 1 ; } int cnt [ ] = new int [ 25 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s . charAt ( i ) - ' a ' ] ++ ; } if ( Arrays . stream ( cnt ) . max ( ) . getAsInt ( ) >= ( s . length ( ) - 1 ) ) { return - 1 ; } else { return ( ans ( s ) ? 1 : 2 ) ; } } public static void main ( String [ ] args ) { String s = " nolon " ; System . out . println ( solve ( s ) ) ; } }
import java . util . * ; public class GFG { static int count_numbers ( int k , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; } public static void main ( String [ ] args ) { int k = 10 ; int n = 3 ; System . out . println ( count_numbers ( k , n ) ) ; } }
public class GfG { static int minCost ( int n , int arr [ ] , int cost ) { int sum = 0 , totalCost = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += arr [ i ] ; totalCost += cost * sum ; arr [ n - 1 ] += sum ; totalCost += ( 2 * cost * arr [ n - 1 ] ) ; return totalCost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = arr . length ; int cost = 1 ; System . out . println ( minCost ( n , arr , cost ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . LinkedList ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . teamFormationMake ( ) ; return ; } private void teamFormationMake ( ) { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String inputStr = bufferedReader . readLine ( ) ; int yearNum = Integer . parseInt ( inputStr ) ; LinkedList < LinkedList < Integer > > programmerList = new LinkedList < LinkedList < Integer > > ( ) ; int teamNum = 0 ; for ( int i = 0 ; i < yearNum ; i ++ ) { String teamStr = bufferedReader . readLine ( ) ; String [ ] teamStrs = teamStr . split ( " ▁ " ) ; programmerList . add ( new LinkedList < Integer > ( ) ) ; for ( int j = 0 ; j < teamStrs . length ; j ++ ) { programmerList . get ( i ) . add ( Integer . parseInt ( teamStrs [ j ] ) ) ; } } for ( int i = 0 ; i < yearNum ; i ++ ) { int c = programmerList . get ( i ) . get ( 0 ) ; int a = programmerList . get ( i ) . get ( 1 ) ; int n = programmerList . get ( i ) . get ( 2 ) ; while ( true ) { if ( c >= 1 && a >= 1 && n >= 1 ) { teamNum ++ ; c -- ; a -- ; n -- ; } else if ( c >= 2 && a >= 1 ) { teamNum ++ ; c = c - 2 ; a -- ; } else if ( c >= 3 ) { teamNum ++ ; c = c - 3 ; } else { break ; } } System . out . println ( teamNum ) ; teamNum = 0 ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; while ( scan . hasNext ( ) ) { int n = scan . nextInt ( ) ; if ( n == 0 ) { break ; } int m = scan . nextInt ( ) - ( n << 1 ) ; char [ ] ch = ( scan . next ( ) ) . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ch [ i ] == ' I ' ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ch [ i + 1 + ( j << 1 ) ] != ' O ' || ch [ i + ( ( j + 1 ) << 1 ) ] != ' I ' ) { break ; } else if ( j == n - 1 ) { count ++ ; i ++ ; } } } } System . out . println ( count ) ; } } }
import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; public class B1593 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; while ( t -- > 0 ) { String s = scanner . next ( ) ; int ans = 0 ; List < String > list = new LinkedList < > ( ) ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { char ch = s . charAt ( i ) ; if ( list . size ( ) == 0 ) { if ( ch == '0' || ch == '5' ) { list . add ( ch + " " ) ; } else { ans ++ ; } } else { boolean found = false ; for ( String str : list ) { if ( Integer . valueOf ( ch + str ) % 25 == 0 ) { found = true ; ans += list . size ( ) - 1 ; break ; } } if ( found ) { break ; } if ( ch == '0' || ch == '5' ) { list . add ( ch + " " ) ; } else { ans ++ ; } } } System . out . println ( ans ) ; } scanner . close ( ) ; } }
import java . util . Scanner ; class Node { int data ; public Node left ; public Node right ; Node ( int data ) { this . data = data ; left = right = null ; } } public class GFG { public static Node insert ( Node root , int data ) { if ( root == null ) return new Node ( data ) ; if ( data < root . data ) root . left = insert ( root . left , data ) ; if ( data > root . data ) root . right = insert ( root . right , data ) ; return root ; } public static void inOrder ( Node root ) { if ( root == null ) return ; inOrder ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; inOrder ( root . right ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 2 , 5 , 4 , 4 } ; int n = arr . length ; Node root = null ; for ( int i = 0 ; i < n ; i ++ ) { root = insert ( root , arr [ i ] ) ; } inOrder ( root ) ; } }
public class GFG { final static int MAX_CHAR = 26 ; static String removeChars ( String str , int k ) { int hash [ ] = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; ++ i ) { hash [ str . charAt ( i ) - ' a ' ] ++ ; } String res = " " ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ str . charAt ( i ) - ' a ' ] >= k ) { res += str . charAt ( i ) ; } } return res ; } static public void main ( String [ ] args ) { String str = " geeksforgeeks " ; int k = 2 ; System . out . println ( removeChars ( str , k ) ) ; } }
public class LongestCommonSubSequence { static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; } public static void main ( String [ ] args ) { String X = " OldSite : GeeksforGeeks . org " ; String Y = " NewSite : GeeksQuiz . com " ; int m = X . length ( ) ; int n = Y . length ( ) ; System . out . println ( " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ▁ " + LCSubStr ( X . toCharArray ( ) , Y . toCharArray ( ) , m , n ) ) ; } }
import java . io . * ; public class GFG { static int countOccurrences ( int x , int d ) { int count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x = x / 10 ; } return count ; } static int maxOccurring ( int x ) { if ( x < 0 ) x = - x ; int result = 0 ; int max_count = 1 ; for ( int d = 0 ; d <= 9 ; d ++ ) { int count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; } public static void main ( String [ ] args ) { int x = 1223355 ; System . out . println ( " Max ▁ occurring ▁ digit ▁ is ▁ " + maxOccurring ( x ) ) ; } }
import java . util . * ; public class GFG { public static void printLogestIncSubArr ( int arr [ ] , int n ) { int max = 1 , len = 1 , maxIndex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) len ++ ; else { if ( max < len ) { max = len ; maxIndex = i - max ; } len = 1 ; } } if ( max < len ) { max = len ; maxIndex = n - max ; } for ( int i = maxIndex ; i < max + maxIndex ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 } ; int n = arr . length ; printLogestIncSubArr ( arr , n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; System . out . println ( n + " ▁ " ) ; int m = n ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( m % i == 0 ) { System . out . println ( i + " ▁ " ) ; m = i ; } } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class program { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sf = new Scanner ( System . in ) ; int t = 1 ; for ( int t1 = 0 ; t1 < t ; t1 ++ ) { int n = sf . nextInt ( ) ; int m = sf . nextInt ( ) ; int [ ] p = new int [ n ] ; int [ ] hash = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = sf . nextInt ( ) ; hash [ i ] = p [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { int l = sf . nextInt ( ) ; int r = sf . nextInt ( ) ; int x = sf . nextInt ( ) ; l -- ; r -- ; x -- ; int ind = x ; if ( ind < l || ind > r ) { System . out . println ( " Yes " ) ; } else { int [ ] hash1 = new int [ n + 1 ] ; for ( int j = 0 ; j < l ; j ++ ) hash1 [ p [ j ] ] ++ ; for ( int j = r + 1 ; j < n ; j ++ ) hash1 [ p [ j ] ] ++ ; int cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( hash1 [ j ] == 0 ) { cnt ++ ; } if ( j == hash [ x ] ) break ; } int dif1 = ind - l + 1 ; if ( dif1 != cnt ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } } } } } }
import java . util . * ; public class GFG { static int Max_Sum ( int a [ ] , int n ) { int [ ] b = new int [ n ] ; int S = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { g -= a [ i ] ; ans = Math . max ( ans , g + b [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { - 6 , 10 , - 3 , 10 , - 2 } ; int n = a . length ; System . out . println ( " Maximum ▁ sum ▁ is : ▁ " + Max_Sum ( a , n ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class A1452 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; while ( t -- > 0 ) { int [ ] a = new int [ 2 ] ; a [ 0 ] = scanner . nextInt ( ) ; a [ 1 ] = scanner . nextInt ( ) ; Arrays . sort ( a ) ; if ( a [ 0 ] == a [ 1 ] ) { System . out . println ( 2 * a [ 0 ] ) ; } else { System . out . println ( 2 * a [ 1 ] - 1 ) ; } } scanner . close ( ) ; } }
public class GFG { static void reverse ( String str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int x = 3 ; reverse ( str , x ) ; } }
public class GFG { static int lps ( String str ) { int n = str . length ( ) ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Integer . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } static int minimumNumberOfDeletions ( String str ) { int n = str . length ( ) ; int len = lps ( str ) ; return ( n - len ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( " Minimum ▁ number ▁ " + " of ▁ deletions ▁ = ▁ " + minimumNumberOfDeletions ( str ) ) ; } }
public class GFG { static boolean bit_check ( int n ) { if ( ( n & ( n - 1 ) ) == 0 ) return true ; return false ; } public static void main ( String args [ ] ) { int n = 14 ; if ( bit_check ( n ) ) System . out . println ( '1' ) ; else System . out . println ( '0' ) ; } }
import java . util . * ; public final class Test { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; int curr = arr [ n - 1 ] ; int c = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] <= curr ) { curr = arr [ i ] ; } else c ++ ; } System . out . println ( c ) ; } } }
import java . util . Arrays ; public final class p187 { public static void main ( String [ ] args ) { System . out . println ( new p187 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 8 ) - 1 ; public String run ( ) { int count = 0 ; int [ ] primes = Library . listPrimes ( LIMIT / 2 ) ; for ( int i = 0 , sqrt = Library . sqrt ( LIMIT ) ; i < primes . length && primes [ i ] <= sqrt ; i ++ ) { int end = Arrays . binarySearch ( primes , LIMIT / primes [ i ] ) ; if ( end >= 0 ) end ++ ; else end = - end - 1 ; count += end - i ; } return Integer . toString ( count ) ; } }
import java . util . * ; class Solution { static final int M = 20 ; static int dp [ ] [ ] [ ] [ ] = new int [ M ] [ M ] [ 2 ] [ 2 ] ; static int d , K ; static int count ( int pos , int cnt , int tight , int nonz , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 ) return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; int ans = 0 ; int limit = ( ( tight != 0 ) ? 9 : num . get ( pos ) ) ; for ( int dig = 0 ; dig <= limit ; dig ++ ) { int currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ( d == 0 && nonz != 0 ) ) currCnt ++ ; } int currTight = tight ; if ( dig < num . get ( pos ) ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , ( dig != 0 ? 1 : 0 ) , num ) ; } return dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; } static int solve ( int x ) { Vector < Integer > num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; } public static void main ( String args [ ] ) { int L = 11 , R = 100 ; d = 2 ; K = 1 ; System . out . print ( solve ( R ) - solve ( L - 1 ) ) ; } }
import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Test1 { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; List < Long > list = new ArrayList < > ( ) ; long x = sc . nextLong ( ) ; while ( x > 0 ) { long r = x % 10 ; if ( 9 - r < r ) { if ( x / 10 == 0 && 9 - r == 0 ) list . add ( r ) ; else list . add ( 9 - r ) ; } else list . add ( r ) ; x = x / 10 ; } int pow = 0 ; long newNumber = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { newNumber = newNumber + list . get ( i ) * ( long ) Math . pow ( 10 , pow ) ; pow ++ ; } System . out . println ( newNumber ) ; } }
import java . util . * ; public class GFG { static boolean isPeak ( int arr [ ] , int n , int num , int i , int j ) { if ( i >= 0 && arr [ i ] > num ) { return false ; } if ( j < n && arr [ j ] > num ) { return false ; } return true ; } static boolean isTrough ( int arr [ ] , int n , int num , int i , int j ) { if ( i >= 0 && arr [ i ] < num ) { return false ; } if ( j < n && arr [ j ] < num ) { return false ; } return true ; } static void printPeaksTroughs ( int arr [ ] , int n ) { System . out . print ( " Peaks ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPeak ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } System . out . println ( " " ) ; System . out . print ( " Troughs ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isTrough ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 10 , 5 , 7 , 4 , 3 , 5 } ; int n = arr . length ; printPeaksTroughs ( arr , n ) ; } }
public class GFG { static int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; } static void check ( int n ) { String s [ ] = { " negative " , " zero " , " positive " } ; int val = index ( n ) ; System . out . println ( n + " ▁ is ▁ " + s [ val ] ) ; } public static void main ( String [ ] args ) { check ( 30 ) ; check ( - 20 ) ; check ( 0 ) ; } }
import java . io . * ; public class GFG { static int frequency ( int a [ ] , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == x ) count ++ ; return count ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , 5 , 5 , 5 , 4 } ; int x = 5 ; int n = a . length ; System . out . println ( frequency ( a , n , x ) ) ; } }
import java . util . * ; public class Main { public static boolean isNumBalanced ( int num ) { num = Math . abs ( num ) ; String str = num + " " ; char [ ] ch_arr = str . toCharArray ( ) ; HashSet < Character > hs = new HashSet < Character > ( ) ; for ( char ch : ch_arr ) { hs . add ( ch ) ; } int str_len = str . length ( ) ; int hs_len = hs . size ( ) ; if ( hs_len <= str_len / 2 || hs_len == str_len ) { return true ; } return false ; } public static void main ( String [ ] args ) { int N = 1234567890 ; boolean flag = isNumBalanced ( N ) ; if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isThreeDisctFactors ( long n ) { int sq = ( int ) Math . sqrt ( n ) ; if ( 1L * sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; } public static void main ( String [ ] args ) { long num = 9 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 15 ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 12397923568441L ; if ( isThreeDisctFactors ( num ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . math . BigInteger ; public final class p065 { public static void main ( String [ ] args ) { System . out . println ( new p065 ( ) . run ( ) ) ; } public String run ( ) { BigInteger n = BigInteger . ONE ; BigInteger d = BigInteger . ZERO ; for ( int i = 99 ; i >= 0 ; i -- ) { BigInteger temp = BigInteger . valueOf ( continuedFractionTerm ( i ) ) . multiply ( n ) . add ( d ) ; d = n ; n = temp ; } int sum = 0 ; while ( ! n . equals ( BigInteger . ZERO ) ) { BigInteger [ ] divrem = n . divideAndRemainder ( BigInteger . TEN ) ; sum += divrem [ 1 ] . intValue ( ) ; n = divrem [ 0 ] ; } return Integer . toString ( sum ) ; } private static int continuedFractionTerm ( int i ) { if ( i == 0 ) return 2 ; else if ( i % 3 == 2 ) return i / 3 * 2 + 2 ; else return 1 ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } else { return __gcd ( b , a % b ) ; } } static int LCM ( int x , int y , int z ) { int ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; } static int findDivisible ( int n , int x , int y , int z ) { int lcm = LCM ( x , y , z ) ; int ndigitnumber = ( int ) Math . pow ( 10 , n - 1 ) ; int reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; } static public void main ( String [ ] args ) { int n = 4 , x = 2 , y = 3 , z = 5 ; int res = findDivisible ( n , x , y , z ) ; if ( res != 0 ) System . out . println ( res ) ; else System . out . println ( " Not ▁ possible " ) ; } }
public class GFG { static final int MAXN = 100001 ; static boolean prime [ ] = new boolean [ MAXN ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAXN ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < MAXN ; i += p ) prime [ i ] = false ; } } } static void common_prime ( int a , int b ) { int gcd = ( int ) __gcd ( a , b ) ; for ( int i = 2 ; i <= ( gcd ) ; i ++ ) { if ( prime [ i ] && gcd % i == 0 ) { System . out . print ( i + " ▁ " ) ; } } } static long __gcd ( long a , long b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int a = 6 , b = 12 ; common_prime ( a , b ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int len = 393 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int s [ ] = new int [ n ] , l [ ] = new int [ n ] , p [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = sc . nextInt ( ) ; l [ i ] = sc . nextInt ( ) ; p [ i ] = sc . nextInt ( ) ; } int [ ] dp = new int [ len + 1 ] ; fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int j = 0 ; j <= len ; j ++ ) for ( int i = 0 ; i < n ; i ++ ) if ( dp [ j ] >= 0 ) { for ( int k = s [ i ] ; k <= l [ i ] ; k ++ ) if ( j + k <= len ) dp [ j + k ] = max ( dp [ j + k ] , dp [ j ] + p [ i ] ) ; } int m = sc . nextInt ( ) ; int [ ] ans = new int [ m ] ; boolean flg = true ; for ( int i = 0 ; i < m ; i ++ ) { int r = sc . nextInt ( ) ; ans [ i ] = dp [ r ] ; if ( ans [ i ] == - 1 ) flg = false ; } if ( ! flg ) System . out . println ( - 1 ) ; else { for ( int i : ans ) System . out . println ( i ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . io . * ; import java . util . * ; public class Main { static ArrayList < Integer > [ ] g ; static int maxMatching ( int v , int p ) { int a = 0 ; int o = 0 ; for ( int w : g [ v ] ) { if ( w == p ) continue ; int r = maxMatching ( w , v ) ; a += r / 2 ; o += r % 2 ; } return 2 * a + Math . min ( 1 , o ) + 1 ; } public static void main ( String [ ] args ) { MyScanner sc = new MyScanner ( ) ; out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; int n = sc . nextInt ( ) ; g = new ArrayList [ n ] ; Arrays . setAll ( g , x -> new ArrayList < Integer > ( ) ) ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; g [ a ] . add ( b ) ; g [ b ] . add ( a ) ; } int m = maxMatching ( 0 , - 1 ) / 2 ; out . println ( 2 * m == n ? " Second " : " First " ) ; out . close ( ) ; } public static PrintWriter out ; public static class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . util . Scanner ; public class Main { static int N = 205 , M = 205 ; static int [ ] [ ] grid = new int [ N ] [ M ] ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { solve ( sc ) ; } } static void solve ( Scanner sc ) { int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String line = sc . next ( ) ; for ( int j = 0 ; j < m ; j ++ ) { grid [ i ] [ j ] = line . charAt ( j ) - '0' ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { int sum = grid [ i ] [ j ] + grid [ i + 1 ] [ j ] + grid [ i ] [ j + 1 ] + grid [ i + 1 ] [ j + 1 ] ; if ( sum == 3 ) { System . out . println ( " NO " ) ; return ; } } } System . out . println ( " YES " ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int tc = 1 ; while ( tc -- > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int len [ ] = new int [ n ] ; String s ; int min = 0 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = sc . next ( ) ; len [ i ] = s . length ( ) ; } String p = sc . next ( ) ; int plen = p . length ( ) ; int kk = k ; Arrays . sort ( len ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( len [ i ] == plen ) { min ++ ; break ; } if ( k > 0 ) { k -- ; min ++ ; } if ( k == 0 ) { k = kk ; min += 5 ; } } k = kk ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( len [ i ] == plen && len [ i + 1 ] > plen ) ) { max ++ ; break ; } if ( k > 0 ) { k -- ; max ++ ; } if ( k == 0 ) { k = kk ; max += 5 ; } } if ( len [ n - 1 ] == plen ) max ++ ; System . out . println ( min + " ▁ " + max ) ; } sc . close ( ) ; } }
import java . util . * ; public class Test { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String word1 = in . nextLine ( ) . replaceAll ( " [ ^ a - zA - Z ] " , " " ) . toLowerCase ( ) ; String word2 = in . nextLine ( ) . replaceAll ( " [ ^ a - zA - Z ] " , " " ) . toLowerCase ( ) ; String word3 = in . nextLine ( ) . replaceAll ( " [ ^ a - zA - Z ] " , " " ) . toLowerCase ( ) ; String perm1 = word1 + word2 + word3 ; String perm2 = word1 + word3 + word2 ; String perm3 = word2 + word1 + word3 ; String perm4 = word2 + word3 + word1 ; String perm5 = word3 + word2 + word1 ; String perm6 = word3 + word1 + word2 ; int students = in . nextInt ( ) ; in . nextLine ( ) ; for ( int i = 0 ; i < students ; i ++ ) { String testCase = in . nextLine ( ) . replaceAll ( " [ ^ a - zA - Z ] " , " " ) . toLowerCase ( ) ; if ( testCase . equals ( perm1 ) || testCase . equals ( perm2 ) || testCase . equals ( perm3 ) || testCase . equals ( perm4 ) || testCase . equals ( perm5 ) || testCase . equals ( perm6 ) ) { System . out . println ( " ACC " ) ; } else { System . out . println ( " WA " ) ; } } } }
import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; public class A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; Set < Long > need = new HashSet < Long > ( ) , have = new HashSet < Long > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { String tmp = sc . next ( ) ; long tmp2 = 0 ; for ( int j = 0 ; j < L ; j ++ ) if ( tmp . charAt ( j ) == '1' ) tmp2 |= ( 1L << j ) ; have . add ( tmp2 ) ; } long lastNeeded = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String tmp = sc . next ( ) ; long tmp2 = 0 ; for ( int j = 0 ; j < L ; j ++ ) if ( tmp . charAt ( j ) == '1' ) tmp2 |= ( 1L << j ) ; need . add ( tmp2 ) ; lastNeeded = tmp2 ; } int ans = L + 1 ; for ( Long elem : have ) { long flip = lastNeeded ^ elem ; Set < Long > got = new HashSet < Long > ( ) ; for ( Long e : need ) { got . add ( e ^ flip ) ; } if ( got . equals ( have ) ) { ans = Math . min ( ans , Long . bitCount ( flip ) ) ; } } System . out . println ( " Case ▁ # " + caze + " : ▁ " + ( ans > L ? " NOT ▁ POSSIBLE " : ans ) ) ; } } }
import java . util . Stack ; class Solution { public int maxAreaOfIsland ( int [ ] [ ] grid ) { int [ ] dr = new int [ ] { 1 , - 1 , 0 , 0 } ; int [ ] dc = new int [ ] { 0 , 0 , 1 , - 1 } ; int ans = 0 ; for ( int r0 = 0 ; r0 < grid . length ; r0 ++ ) { for ( int c0 = 0 ; c0 < grid [ 0 ] . length ; c0 ++ ) { if ( grid [ r0 ] [ c0 ] == 1 ) { int shape = 0 ; Stack < int [ ] > stack = new Stack ( ) ; stack . push ( new int [ ] { r0 , c0 } ) ; grid [ r0 ] [ c0 ] = 0 ; while ( ! stack . empty ( ) ) { int [ ] node = stack . pop ( ) ; int r = node [ 0 ] , c = node [ 1 ] ; shape ++ ; for ( int k = 0 ; k < 4 ; k ++ ) { int nr = r + dr [ k ] ; int nc = c + dc [ k ] ; if ( 0 <= nr && nr < grid . length && 0 <= nc && nc < grid [ 0 ] . length && grid [ nr ] [ nc ] == 1 ) { stack . push ( new int [ ] { nr , nc } ) ; grid [ nr ] [ nc ] = 0 ; } } } ans = Math . max ( ans , shape ) ; } } } return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] [ ] grid = { { 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 } , { 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 } , { 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 } } ; int out = sObj . maxAreaOfIsland ( grid ) ; System . out . println ( out ) ; } }
public class GFG { static int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; } public static void main ( String args [ ] ) { int x = 2 , y = 2 , n = 2 ; System . out . println ( sum ( x , y , n ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; } static public void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } public static void main ( String [ ] args ) { int n = 687 ; System . out . println ( getSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int getSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 687 ; System . out . println ( getSum ( n ) ) ; } }
public class GFG { static class Node { int data ; Node next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; ( head_ref ) = new_node ; return head_ref ; } static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static Node deleteNonPrimeNodes ( Node head_ref ) { Node ptr = head_ref ; while ( ptr != null && ! isPrime ( ptr . data ) ) { Node temp = ptr ; ptr = ptr . next ; } head_ref = ptr ; if ( ptr == null ) return null ; Node curr = ptr . next ; while ( curr != null ) { if ( ! isPrime ( curr . data ) ) { ptr . next = curr . next ; curr = ptr . next ; } else { ptr = curr ; curr = curr . next ; } } return head_ref ; } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 17 ) ; head = push ( head , 7 ) ; head = push ( head , 6 ) ; head = push ( head , 16 ) ; head = push ( head , 15 ) ; System . out . print ( " Original ▁ List : ▁ " ) ; printList ( head ) ; head = deleteNonPrimeNodes ( head ) ; System . out . print ( " \n Modified ▁ List : ▁ " ) ; printList ( head ) ; } }
import java . util . ArrayList ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; ArrayList < ArrayList < Integer > > cs = new ArrayList < > ( ) ; for ( int i = 0 ; i < N * M ; ++ i ) { cs . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < M ; ++ i ) { int D = sc . nextInt ( ) ; int A = sc . nextInt ( ) - 1 ; int K = sc . nextInt ( ) ; int T = sc . nextInt ( ) ; int start = D * N + A ; cs . get ( start ) . add ( ( K << 16 ) | T ) ; } int [ ] [ ] dp = new int [ L + 1 ] [ N * M + 1 ] ; for ( int i = 0 ; i < N * M ; ++ i ) { for ( int j = 0 ; j < L ; ++ j ) { for ( int c : cs . get ( i ) ) { int len = c >> 16 ; int t = c & 0xFFFF ; dp [ j + 1 ] [ i + len ] = Math . max ( dp [ j + 1 ] [ i + len ] , dp [ j ] [ i ] + t ) ; } } for ( int j = 0 ; j <= L ; ++ j ) { dp [ j ] [ i + 1 ] = Math . max ( dp [ j ] [ i + 1 ] , dp [ j ] [ i ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= L ; ++ i ) { ans = Math . max ( ans , dp [ i ] [ N * M ] ) ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { private class Box { int bolls ; boolean isRed ; public Box ( ) { bolls = 1 ; isRed = false ; } public void add ( Box src ) { this . isRed |= src . isRed ; this . bolls += 1 ; src . bolls -= 1 ; if ( src . bolls == 0 ) { src . isRed = false ; } } } public void main ( Scanner sc ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; Box boxs [ ] = new Box [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { boxs [ i ] = new Box ( ) ; } boxs [ 0 ] . isRed = true ; for ( int i = 0 ; i < m ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; boxs [ y - 1 ] . add ( boxs [ x - 1 ] ) ; } System . out . println ( Arrays . stream ( boxs ) . mapToInt ( box -> box . isRed ? 1 : 0 ) . sum ( ) ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; new Main ( ) . main ( sc ) ; sc . close ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; int max = 0 ; for ( int i = 0 ; i < h ; i ++ ) { char [ ] arr = sc . next ( ) . toCharArray ( ) ; for ( int j = 0 ; j < w ; j ++ ) { if ( arr [ j ] == ' . ' ) { continue ; } for ( int x : list ) { int hh = x / w ; int ww = x % w ; max = Math . max ( max , Math . abs ( i - hh ) + Math . abs ( j - ww ) ) ; } list . add ( i * w + j ) ; } } System . out . println ( max ) ; } }
public class GFG { static void minReplacement ( String str ) { if ( str . length ( ) > 26 ) { System . out . println ( " IMPOSSIBLE " ) ; } else { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash [ str . charAt ( i ) - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( hash [ str . charAt ( i ) - ' a ' ] > 1 ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( hash [ j ] == 0 ) { hash [ str . charAt ( i ) - ' a ' ] -- ; str = str . substring ( 0 , i ) + ( char ) ( j + ' a ' ) + str . substring ( i + 1 ) ; hash [ j ] ++ ; break ; } } } } System . out . println ( str ) ; } } public static void main ( String [ ] args ) { String str = " xxxxyyyy " ; minReplacement ( str ) ; } }
public class GFG { public static int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s . charAt ( j - 1 ) == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s . charAt ( n - j ) == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n || pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; } public static void main ( String [ ] args ) { String s = "000011100000" ; System . out . println ( longestSubseq ( s ) ) ; } }
public class GFG { static void sieveOfEratosthenes ( int N , int s [ ] ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } static void generatePrimeFactors ( int N ) { int [ ] s = new int [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; System . out . println ( " Factor ▁ Power " ) ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } System . out . println ( curr + " \ t " + cnt ) ; curr = s [ N ] ; cnt = 1 ; } } public static void main ( String [ ] args ) { int N = 360 ; generatePrimeFactors ( N ) ; } }
public class GFG { static int longestSubarray ( int a [ ] , int n ) { int hash [ ] [ ] = new int [ n ] [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num != 0 ) { hash [ i ] [ num % 10 ] = 1 ; num /= 10 ; } } int longest = Integer . MIN_VALUE ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int j ; for ( j = 0 ; j < 10 ; j ++ ) { if ( hash [ i ] [ j ] == 1 & hash [ i + 1 ] [ j ] == 1 ) { count ++ ; break ; } } if ( j == 10 ) { longest = Math . max ( longest , count + 1 ) ; count = 0 ; } } longest = Math . max ( longest , count + 1 ) ; return longest ; } public static void main ( String [ ] args ) { int a [ ] = { 11 , 22 , 33 , 44 , 54 , 56 , 63 } ; int n = a . length ; System . out . println ( longestSubarray ( a , n ) ) ; } }
import java . util . * ; import static java . lang . Integer . parseInt ; public class _1196A_ThreePilesOfCandies { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int test = parseInt ( input . nextLine ( ) ) ; while ( test -- > 0 ) { long a = input . nextLong ( ) ; long b = input . nextLong ( ) ; long c = input . nextLong ( ) ; long result = ( a + b + c ) / 2 ; System . out . println ( result ) ; } } }
import java . util . Vector ; public class GFG { static Vector < Integer > Divisors ( int x ) { int c = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . add ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . add ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . add ( c ) ; v . add ( x ) ; return v ; } static int MinOperations ( int a , int b ) { Vector < Integer > va = Divisors ( a ) ; Vector < Integer > vb = Divisors ( b ) ; if ( va . get ( 3 ) != vb . get ( 3 ) ) { return - 1 ; } int minOperations = Math . abs ( va . get ( 0 ) - vb . get ( 0 ) ) + Math . abs ( va . get ( 1 ) - vb . get ( 1 ) ) + Math . abs ( va . get ( 2 ) - vb . get ( 2 ) ) ; return minOperations ; } public static void main ( String [ ] args ) { int a = 14 , b = 28 ; System . out . println ( MinOperations ( a , b ) ) ; } }
import java . util . * ; public class GFG { static int N = 1000001 ; static int c , n , m , a , b ; static void dfs ( int a , int b , Vector < Integer > v [ ] , int vis [ ] ) { vis [ a ] = 1 ; c ++ ; for ( int i : v [ a ] ) { if ( vis [ i ] == 0 && i != b ) dfs ( i , b , v , vis ) ; } } static void Calculate ( Vector < Integer > v [ ] ) { int [ ] vis = new int [ n + 1 ] ; Arrays . fill ( vis , 0 ) ; c = 0 ; dfs ( a , b , v , vis ) ; int ans1 = n - c - 1 ; Arrays . fill ( vis , 0 ) ; c = 0 ; dfs ( b , a , v , vis ) ; int ans2 = n - c - 1 ; System . out . print ( ans1 * ans2 + " \n " ) ; } public static void main ( String [ ] args ) { n = 7 ; m = 7 ; a = 3 ; b = 5 ; int edges [ ] [ ] = { { 1 , 2 } , { 2 , 3 } , { 3 , 4 } , { 4 , 5 } , { 5 , 6 } , { 6 , 7 } , { 7 , 5 } } ; Vector < Integer > [ ] v = new Vector [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { v [ i ] = new Vector < Integer > ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { v [ edges [ i ] [ 0 ] ] . add ( edges [ i ] [ 1 ] ) ; v [ edges [ i ] [ 1 ] ] . add ( edges [ i ] [ 0 ] ) ; } Calculate ( v ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; public class B_Nirvana { public static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( " \n " ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader reader = new FastReader ( ) ; int num = reader . nextInt ( ) ; long prod = 1L ; long ans = prodOfDigits ( num ) ; while ( num > 9 ) { prod *= 9 ; int digit = num % 10 ; num = num / 10 ; if ( digit == 9 ) { ans = Math . max ( ans , prodOfDigits ( ( long ) ( num ) ) * prod ) ; } else { ans = Math . max ( ans , prodOfDigits ( ( long ) ( num - 1 ) ) * prod ) ; num = num - 1 ; } } System . out . println ( ans ) ; } public static long prodOfDigits ( long N ) { long prod = 1L ; while ( N != 0 ) { int digit = ( int ) ( N % 10 ) ; if ( digit == 0 ) { return 0 ; } else { prod *= digit ; N /= 10 ; } } return prod ; } }
import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int res = a ; while ( a >= b ) { res += ( a / b ) ; a = ( a / b ) + ( a % b ) ; } System . out . println ( res ) ; } }
import java . io . * ; import java . math . * ; public class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static int largestDigitSumdivisior ( int n ) { int res = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { res = Math . max ( res , getSum ( i ) ) ; res = Math . max ( res , getSum ( n / i ) ) ; } } return res ; } public static void main ( String args [ ] ) { int n = 14 ; System . out . println ( largestDigitSumdivisior ( n ) ) ; } }
import java . util . Scanner ; import java . util . Arrays ; public class A { public static int power ( Long a ) { int res = 0 ; while ( a > 0 ) { res ++ ; a = a / 10 ; } return res ; } public static long mult ( Long a ) { int pow = power ( a ) ; long max = 0 ; for ( int j = 0 ; j < pow ; ++ j ) { max = max * 10 + 9 ; } return a * ( max - a ) ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long l = in . nextLong ( ) ; long r = in . nextLong ( ) ; long res = 0 ; long [ ] maxxes = new long [ 10 ] ; long temp = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { temp = temp * 10 + 9 ; maxxes [ i ] = temp / 2 * ( temp - temp / 2 ) ; } res = Math . max ( mult ( l ) , res ) ; res = Math . max ( mult ( r ) , res ) ; temp = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { temp = temp * 10 + 9 ; if ( l <= temp / 2 && temp / 2 <= r ) res = Math . max ( maxxes [ i ] , res ) ; } System . out . println ( res ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String ... args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } printArray ( a ) ; for ( int i = 1 ; i < n ; i ++ ) { int key = a [ i ] ; int j = i - 1 ; while ( j >= 0 && a [ j ] > key ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = key ; printArray ( a ) ; } } public static void printArray ( int [ ] a ) { for ( int i = 0 ; i < a . length - 1 ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } System . out . println ( a [ a . length - 1 ] ) ; } }
import java . util . * ; public class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } static void findNumbers ( int N ) { Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . add ( i ) ; } } Iterator < Integer > itr = vec . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . print ( itr . next ( ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 30 ; findNumbers ( N ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Test { public static void main ( String [ ] args ) { String s = "111111101010101111100101001111111 ▁ 100000100000000001010110001000001 ▁ 101110100110110000011010001011101 ▁ 101110101011001001111101001011101 ▁ 101110101100011000111100101011101 ▁ 100000101010101011010000101000001 ▁ 111111101010101010101010101111111 ▁ 000000001111101111100111100000000 ▁ 100010111100100001011110111111001 ▁ 110111001111111100100001000101100 ▁ 011100111010000101000111010001010 ▁ 011110000110001111110101100000011 ▁ 111111111111111000111001001011000 ▁ 111000010111010011010011010100100 ▁ 101010100010110010110101010000010 ▁ 101100000101010001111101000000000 ▁ 000010100011001101000111101011010 ▁ 101001001111101111000101010001110 ▁ 101101111111000100100001110001000 ▁ 000010011000100110000011010000010 ▁ 001101101001101110010010011011000 ▁ 011101011010001000111101010100110 ▁ 111010100110011101001101000001110 ▁ 110001010010101111000101111111000 ▁ 001000111011100001010110111110000 ▁ 000000001110010110100010100010110 ▁ 111111101000101111000110101011010 ▁ 100000100111010101111100100011011 ▁ 101110101001010000101000111111000 ▁ 101110100011010010010111111011010 ▁ 101110100100011011110110101110000 ▁ 100000100110011001111100111100000 ▁ 111111101101000101001101110010001" ; String [ ] array = s . split ( " ▁ " ) ; Scanner input = new Scanner ( System . in ) ; int x = input . nextInt ( ) ; int y = input . nextInt ( ) ; System . out . print ( array [ x ] . charAt ( y ) ) ; } }
import java . util . Scanner ; public class NewClass37 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; int p = 1 ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; int count = 0 ; int x = n ; if ( n < 10 ) { System . out . println ( n ) ; continue ; } while ( x > 0 ) { count ++ ; x /= 10 ; } int first = 0 ; while ( count > 0 ) { first = first * 10 + 1 ; count -- ; } int sum = 0 ; if ( first <= n ) { sum += n / first ; } first /= 10 ; while ( first > 0 ) { sum += 9 ; first /= 10 ; } System . out . println ( sum ) ; } } }
import java . math . * ; public class GFG { static int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; } static boolean areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } public static void main ( String [ ] args ) { int num1 = 559 ; int num2 = 703 ; if ( areEquivalent ( num1 , num2 ) ) System . out . println ( " Equivalent " ) ; else System . out . println ( " Not ▁ Equivalent " ) ; } }
import java . util . * ; public class GFG { public static int findY ( int x ) { if ( x > 2 ) return x - 2 ; return x + 2 ; } public static void main ( String [ ] args ) { int x = 5 ; System . out . println ( findY ( x ) ) ; } }
public class GFG { static final int MOD = 1000000007 ; static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( modFact ( n , m ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner a = new Scanner ( System . in ) ; int n = a . nextInt ( ) ; int A [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = a . nextInt ( ) ; } int minj ; int count = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { minj = i ; int c = 0 ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( A [ j ] < A [ minj ] ) { minj = j ; c = 1 ; } } if ( c == 1 ) { int x = A [ i ] ; A [ i ] = A [ minj ] ; A [ minj ] = x ; count ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( A [ i ] ) ; if ( i < n - 1 ) { System . out . print ( " ▁ " ) ; } } System . out . println ( ) ; System . out . println ( count ) ; } }
import java . io . IOException ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; w = scanner . nextInt ( ) ; h = scanner . nextInt ( ) ; map = new boolean [ h + 2 ] [ w + 2 ] ; v = new boolean [ h + 2 ] [ w + 2 ] ; for ( int i = 1 ; i <= h ; i ++ ) for ( int j = 1 ; j <= w ; j ++ ) map [ i ] [ j ] = scanner . nextInt ( ) == 1 ; System . out . println ( slove ( 0 , 0 ) ) ; } private int slove ( int y , int x ) { v [ y ] [ x ] = true ; int res = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { int ny = y + dy [ i ] ; int nx = x + ( y % 2 == 1 ? dx1 [ i ] : dx2 [ i ] ) ; if ( ! isOK ( ny , nx ) ) continue ; if ( map [ ny ] [ nx ] ) { res ++ ; continue ; } if ( v [ ny ] [ nx ] ) continue ; res += slove ( ny , nx ) ; } return res ; } private boolean isOK ( int ny , int nx ) { if ( 0 <= ny && ny <= h + 1 && 0 <= nx && nx <= w + 1 ) return true ; return false ; } int h , w ; boolean [ ] [ ] map ; boolean [ ] [ ] v ; int [ ] dy = { - 1 , - 1 , 0 , 0 , 1 , 1 } ; int [ ] dx1 = { 0 , 1 , - 1 , 1 , 0 , 1 } ; int [ ] dx2 = { - 1 , 0 , - 1 , 1 , - 1 , 0 } ; }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . StringTokenizer ; public class prepformerge { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; ArrayList < ArrayList < Integer > > lists = new ArrayList < ArrayList < Integer > > ( ) ; int [ ] a = new int [ n + 1 ] ; st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 1 ) { ArrayList < Integer > start = new ArrayList < Integer > ( ) ; start . add ( a [ i ] ) ; lists . add ( start ) ; } else { int lo = 0 ; int hi = lists . size ( ) - 1 ; if ( lists . get ( hi ) . get ( lists . get ( hi ) . size ( ) - 1 ) > a [ i ] ) { ArrayList < Integer > start = new ArrayList < Integer > ( ) ; start . add ( a [ i ] ) ; lists . add ( start ) ; } else { while ( lo != hi ) { int mid = ( lo + hi ) / 2 ; if ( lists . get ( mid ) . get ( lists . get ( mid ) . size ( ) - 1 ) < a [ i ] ) { hi = mid ; } else { lo = mid + 1 ; } } lists . get ( lo ) . add ( a [ i ] ) ; } } } for ( ArrayList < Integer > lis : lists ) { for ( int i = 0 ; i < lis . size ( ) ; i ++ ) { System . out . print ( lis . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; } } }
public class GFG { public static float circlearea ( double a , double b ) { if ( a < 0 || b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 8 , b = 10 ; System . out . println ( circlearea ( a , b ) ) ; } }
public class GFG { static void find ( int [ ] arr , int length , int s ) { for ( int i = 1 ; i <= ( Math . pow ( 2 , length ) ) ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < length ; j ++ ) if ( ( ( i >> j ) & 1 ) % 2 == 1 ) sum += arr [ j ] ; if ( sum == s ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int sum = 5 ; int [ ] array = { - 1 , 2 , 4 , 121 } ; int length = array . length ; find ( array , length , sum ) ; } }
public class GFG { static String K_String ( String s , int k ) { int n = s . length ( ) ; int fre [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - ' a ' ] ++ ; String str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % k == 0 ) { int x = fre [ i ] / k ; while ( x != 0 ) { str += ( char ) ( i + ' a ' ) ; x -- ; } } else { return " - 1" ; } } return str ; } public static void main ( String [ ] args ) { String s = " aabb " ; int k = 2 ; System . out . println ( K_String ( s , k ) ) ; } }
import java . math . BigInteger ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . PriorityQueue ; import java . util . Scanner ; import javax . xml . crypto . Data ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; double [ ] [ ] dp = new double [ n + 1 ] [ 25 ] ; dp [ 0 ] [ 0 ] = 1.0 ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 24 ; j ++ ) { double pp = Math . pow ( 2.0 , j ) ; dp [ i + 1 ] [ j + 1 ] += dp [ i ] [ j ] * 1.0 / pp ; dp [ i + 1 ] [ 0 ] += dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) ; sum += j * dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) ; } } for ( int j = 0 ; j < 25 ; j ++ ) { sum += j * dp [ n ] [ j ] ; } System . out . printf ( " % .20f \n " , sum ) ; } } }
import java . math . BigInteger ; import java . util . * ; import static java . util . Arrays . * ; import static java . lang . Math . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { while ( sc . hasNextInt ( ) ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) , n = sc . nextInt ( ) ; String c = new Double ( ( double ) a / b ) . toString ( ) ; int [ ] f = new int [ 200 ] ; int idx = c . indexOf ( " . " ) ; f [ 0 ] = new Integer ( c . substring ( idx - 1 , idx ) ) ; for ( int i = 1 ; i < min ( 200 , c . substring ( idx + 1 ) . length ( ) + 1 ) ; i ++ ) { f [ i ] = new Integer ( c . substring ( idx + i , idx + i + 1 ) ) ; } int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += f [ i ] ; System . out . println ( res ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } sc . close ( ) ; boolean nodec = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) nodec = false ; } if ( nodec ) { System . out . println ( 1 ) ; return ; } int m = 500 ; int l = 1 , r = 210000 ; int mid = 2 ; int [ ] dec = new int [ m ] ; out : while ( r - l > 1 ) { mid = ( l + r ) / 2 ; dec = new int [ m ] ; Arrays . fill ( dec , 1 ) ; nout : for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] && a [ i ] - 1 < m ) { if ( dec [ a [ i ] - 1 ] < mid ) { dec [ a [ i ] - 1 ] ++ ; } else { int pos = a [ i ] - 1 ; while ( pos > 0 ) { dec [ pos - 1 ] ++ ; for ( int j = pos ; j < m ; j ++ ) { dec [ j ] = 1 ; } if ( dec [ pos - 1 ] <= mid ) continue nout ; pos -- ; } l = mid ; continue out ; } } else { for ( int j = a [ i ] - 1 ; j < m ; j ++ ) { dec [ j ] = 1 ; } } } r = mid ; } System . out . println ( r ) ; } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { private static BufferedReader br = null ; public static void main ( String [ ] args ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { try { String line = null ; String [ ] lines = null ; line = br . readLine ( ) ; lines = line . split ( " ▁ " ) ; int N = Integer . parseInt ( lines [ 0 ] ) ; int K = Integer . parseInt ( lines [ 1 ] ) ; if ( N == 0 && K == 0 ) { return ; } line = br . readLine ( ) ; lines = line . split ( " ▁ " ) ; int [ ] bloodAmt = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { bloodAmt [ i ] = Integer . parseInt ( lines [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { line = br . readLine ( ) ; lines = line . split ( " ▁ " ) ; for ( int j = 0 ; j < K ; j ++ ) { bloodAmt [ j ] -= Integer . parseInt ( lines [ j ] ) ; } } for ( int i = 0 ; i < K ; i ++ ) { if ( bloodAmt [ i ] < 0 ) { System . out . println ( " No " ) ; break ; } if ( i == K - 1 ) { System . out . println ( " Yes " ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } }
import java . io . * ; public class GFG { static int maxFreq ( String s , int a , int b ) { int fre [ ] = new int [ 10 ] ; int n = s . length ( ) ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } public static void main ( String [ ] args ) { int a = 4 , b = 7 ; String s = "47744" ; System . out . print ( maxFreq ( s , a , b ) ) ; } }
public class GFG { static int maxZeros ( int n ) { if ( n == 0 || ( n & ( n - 1 ) ) == 0 ) { return - 1 ; } byte b = 4 ; int setBit = 1 , prev = 0 , i ; for ( i = 1 ; i <= b * 8 ; i ++ ) { prev ++ ; if ( ( n & setBit ) == setBit ) { setBit = setBit << 1 ; break ; } setBit = setBit << 1 ; } int max0 = Integer . MIN_VALUE , cur = prev ; for ( int j = i + 1 ; j <= b * 8 ; j ++ ) { cur ++ ; if ( ( n & setBit ) == setBit ) { if ( max0 < ( cur - prev - 1 ) ) { max0 = cur - prev - 1 ; } prev = cur ; } setBit = setBit << 1 ; } return max0 ; } static public void main ( String [ ] args ) { int n = 549 ; System . out . println ( maxZeros ( n ) ) ; } }
import java . io . * ; public class GFG { static long sumPowersK ( long n , long k ) { long sum = 0 , num = 1 ; while ( num <= n ) { sum += num ; num *= k ; } return sum ; } static long getSum ( long n , long k ) { long pwrK = sumPowersK ( n , k ) ; long sumAll = ( n * ( n + 1 ) ) / 2 ; return ( sumAll - pwrK ) ; } public static void main ( String [ ] args ) { long n = 10 , k = 3 ; System . out . println ( getSum ( n , k ) ) ; } }
import java . util . * ; public class GFG { static float [ ] XandYandZintercept ( float A , float B , float C , float D ) { float rslt [ ] = new float [ 3 ] ; float x = - D / A ; float y = - D / B ; float z = - D / C ; rslt [ 0 ] = x ; rslt [ 1 ] = y ; rslt [ 2 ] = z ; return rslt ; } public static void main ( String [ ] args ) { int A = 2 ; int B = 5 ; int C = 7 ; int D = 8 ; float rslt [ ] = XandYandZintercept ( A , B , C , D ) ; System . out . println ( Arrays . toString ( rslt ) ) ; } }
import java . util . * ; public class GFG { static void maxSum ( int [ ] a , int n ) { Vector < Integer > l = new Vector < Integer > ( ) ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . add ( i + 1 ) ; else { l . add ( i + 1 ) ; l . add ( i ) ; } } System . out . println ( s ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) System . out . print ( l . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 4 ; int a [ ] = { 1 , - 2 , - 3 , 4 } ; maxSum ( a , n ) ; } }
public class GFG { static int MAX = 1000 ; static char [ ] replaceSpaces ( char [ ] str ) { int space_count = 0 , i = 0 ; for ( i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == ' ▁ ' ) space_count ++ ; while ( str [ i - 1 ] == ' ▁ ' ) { space_count -- ; i -- ; } int new_length = i + space_count * 2 ; if ( new_length > MAX ) return str ; int index = new_length - 1 ; char [ ] new_str = str ; str = new char [ new_length ] ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( new_str [ j ] == ' ▁ ' ) { str [ index ] = '0' ; str [ index - 1 ] = '2' ; str [ index - 2 ] = ' % ' ; index = index - 3 ; } else { str [ index ] = new_str [ j ] ; index -- ; } } return str ; } public static void main ( String [ ] args ) { char [ ] str = " Mr ▁ John ▁ Smith ▁ " . toCharArray ( ) ; str = replaceSpaces ( str ) ; for ( int i = 0 ; i < str . length ; i ++ ) System . out . print ( str [ i ] ) ; } }
import java . util . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new B ( ) . doIt ( ) ; } class B { void doIt ( ) { int n = sc . nextInt ( ) ; String str = sc . next ( ) ; char ctr [ ] = str . toCharArray ( ) ; int m = sc . nextInt ( ) ; int num = n ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m == 0 ) { sb . append ( ctr [ i ] ) ; } else if ( m < num ) { if ( ctr [ i ] == '0' ) { sb . append ( 1 ) ; m -- ; } else { sb . append ( 1 ) ; } } else { if ( ctr [ i ] == '0' ) sb . append ( 1 ) ; else sb . append ( 0 ) ; } num -- ; } System . out . println ( sb ) ; } } }
import java . io . * ; public class GFG { static boolean check ( int n ) { int m = n ; while ( n != 0 ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n /= 10 ; } return true ; } static int count ( int l , int r ) { int ans = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( check ( i ) ) ans += 1 ; return ans ; } public static void main ( String args [ ] ) { int l = 10 , r = 20 ; System . out . println ( count ( 10 , 20 ) ) ; } }
import java . util . Scanner ; public class MainClass { public static void main ( String [ ] agrs ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( a == b ) { System . out . println ( a * 10 + 1 + " ▁ " + ( a * 10 + 2 ) ) ; } else if ( a + 1 == b ) { System . out . println ( a + " ▁ " + b ) ; } else if ( a + 1 == b * 10 ) System . out . println ( a + " ▁ " + b * 10 ) ; else System . out . println ( - 1 ) ; } }
import java . util . * ; public class JavaApplication115 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; ArrayList < Integer > arr = new ArrayList < > ( ) ; ArrayList < Integer > arra = new ArrayList < > ( ) ; int maxdif = 0 ; int maxAll = 1000000000 ; for ( int i = 0 ; i < num ; i ++ ) { int h = sc . nextInt ( ) ; arr . add ( h ) ; arra . add ( h ) ; } for ( int i = 1 ; i < num - 1 ; i ++ ) { for ( int j = 0 ; j < arr . size ( ) - 1 ; j ++ ) { if ( j == i ) { maxdif = Math . max ( Math . abs ( arr . get ( j - 1 ) - arr . get ( j + 1 ) ) , maxdif ) ; } else { maxdif = Math . max ( Math . abs ( arr . get ( j ) - arr . get ( j + 1 ) ) , maxdif ) ; } } maxAll = Math . min ( maxAll , maxdif ) ; maxdif = 0 ; } System . out . println ( maxAll ) ; } }
import java . io . * ; import java . util . * ; public class hw19 { public static void main ( String [ ] args ) throws IOException { Scanner scan = new Scanner ( System . in ) ; { } { String in = scan . next ( ) ; int i = Integer . parseInt ( String . valueOf ( in . charAt ( in . length ( ) - 1 ) ) ) ; if ( in . length ( ) > 1 && ( Integer . parseInt ( String . valueOf ( in . charAt ( in . length ( ) - 2 ) ) ) * 10 + i ) % 4 == 0 ) { System . out . println ( 4 ) ; } else if ( in . length ( ) == 1 && i % 4 == 0 ) { System . out . println ( 4 ) ; } else { System . out . println ( 0 ) ; } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; import static java . lang . System . * ; import static java . lang . Math . * ; public class pre5 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; int k = obj . nextInt ( ) ; char str [ ] = obj . next ( ) . toCharArray ( ) ; int n = str . length ; Arrays . sort ( str ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( str [ i ] - '0' ) ; int idx = 0 , ans = 0 ; while ( idx < n && sum < k ) { sum -= str [ idx ] - '0' ; str [ idx ] = '9' ; sum += 9 ; idx ++ ; ans ++ ; } out . println ( ans ) ; } }
import java . util . Scanner ; public class B940 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; long A = in . nextInt ( ) ; long B = in . nextInt ( ) ; long cost = 0 ; while ( N != 1 ) { if ( N < K ) { cost += ( N - 1 ) * A ; break ; } int r = N % K ; cost += r * A ; N -= r ; if ( B >= ( N - N / K ) * A ) { cost += ( N - 1 ) * A ; break ; } cost += B ; N /= K ; } System . out . println ( cost ) ; } }
import java . util . * ; public class GfG { static int digSum ( int n ) { int sum = 0 ; while ( n > 0 || sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; } public static void main ( String argc [ ] ) { int n = 1234 ; System . out . println ( digSum ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; String a = sc . next ( ) , b = sc . next ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 ) ; if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) ; } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { long n = 5 ; System . out . println ( n + " th ▁ Centered ▁ " + " heptagonal ▁ number ▁ : ▁ " + centered_heptagonal_num ( n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int missingNum ( int arr [ ] , int n ) { List < Integer > list = new ArrayList < > ( arr . length ) ; for ( int i : arr ) { list . add ( Integer . valueOf ( i ) ) ; } int minvalue = Collections . min ( list ) ; ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = arr . length ; System . out . println ( missingNum ( arr , n ) ) ; } }
public class GFG { static void smallestPermute ( int n ) { char res [ ] = new char [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } res [ n - 1 ] = ( char ) ( 48 + n - 2 ) ; res [ n - 2 ] = ( char ) ( 48 + n ) ; res [ n - 3 ] = ( char ) ( 48 + n - 1 ) ; } res [ n ] = ' \ 0' ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] ) ; } } public static void main ( String [ ] args ) { int n = 7 ; smallestPermute ( n ) ; } }
import java . util . * ; class geeks { public static int minOperations ( int [ ] a , int n , int K ) { HashMap < Integer , Boolean > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { try { if ( map . get ( a [ i ] ) ) return 1 ; } catch ( Exception e ) { } try { map . put ( a [ i ] , true ) ; } catch ( Exception e ) { } } int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] & K ; map . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { try { map . put ( b [ i ] , true ) ; } catch ( Exception e ) { } } } for ( int i = 0 ; i < n ; i ++ ) { try { if ( map . get ( a [ i ] ) ) return 1 ; } catch ( Exception e ) { } } map . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { try { if ( map . get ( b [ i ] ) ) return 2 ; } catch ( Exception e ) { } try { map . put ( b [ i ] , true ) ; } catch ( Exception e ) { } } return - 1 ; } public static void main ( String [ ] args ) { int K = 3 ; int [ ] a = { 1 , 2 , 3 , 7 } ; int n = a . length ; System . out . println ( minOperations ( a , n , K ) ) ; } }
import java . util . * ; class Main { int h , w ; char [ ] [ ] grid ; Boolean B , W ; int countB , countW ; int [ ] dx = { 1 , - 1 , 0 , 0 } ; int [ ] dy = { 0 , 0 , 1 , - 1 } ; char from , to ; int countGrid ; void solve ( ) { Scanner sc = new Scanner ( System . in ) ; w = sc . nextInt ( ) ; while ( w != 0 ) { h = sc . nextInt ( ) ; grid = new char [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { String line = sc . next ( ) ; grid [ i ] = line . toCharArray ( ) ; } countB = 0 ; countW = 0 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( grid [ i ] [ j ] == ' . ' ) { B = false ; W = false ; countGrid = 0 ; dfs ( j , i ) ; if ( B && ! W ) countB += countGrid ; if ( ! B && W ) countW += countGrid ; } } } System . out . println ( countB + " ▁ " + countW ) ; w = sc . nextInt ( ) ; } } void dfs ( int x , int y ) { grid [ y ] [ x ] = ' x ' ; countGrid ++ ; for ( int i = 0 ; i < 4 ; i ++ ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( nx < w && nx >= 0 && ny < h && ny >= 0 ) { if ( grid [ ny ] [ nx ] == ' B ' ) B = true ; else if ( grid [ ny ] [ nx ] == ' W ' ) W = true ; else if ( grid [ ny ] [ nx ] == ' . ' ) { dfs ( nx , ny ) ; } } } } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } }
import java . util . * ; public class vfe { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; if ( 360 % ( 180 - n ) == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . RoundingMode ; import java . util . Stack ; public final class p493 { public static void main ( String [ ] args ) { System . out . println ( new p493 ( ) . run ( ) ) ; } private static final int NUM_COLORS = 7 ; private static final int BALLS_PER_COLOR = 10 ; private static final int NUM_PICKED = 20 ; private BigInteger numerator = BigInteger . ZERO ; public String run ( ) { explore ( NUM_PICKED , BALLS_PER_COLOR , new Stack < Integer > ( ) ) ; BigInteger denominator = Library . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) ; BigDecimal num = new BigDecimal ( numerator ) ; BigDecimal den = new BigDecimal ( denominator ) ; return num . divide ( den , 9 , RoundingMode . HALF_EVEN ) . toString ( ) ; } private void explore ( int remain , int limit , Stack < Integer > history ) { if ( remain == 0 ) { int [ ] hist = new int [ NUM_COLORS ] ; for ( int i = 0 ; i < history . size ( ) ; i ++ ) hist [ i ] = history . get ( i ) ; int [ ] histogram = new int [ BALLS_PER_COLOR + 1 ] ; for ( int x : hist ) histogram [ x ] ++ ; BigInteger count = Library . factorial ( NUM_COLORS ) ; for ( int x : histogram ) count = divideExactly ( count , Library . factorial ( x ) ) ; for ( int x : hist ) count = count . multiply ( Library . binomial ( BALLS_PER_COLOR , x ) ) ; int distinctColors = history . size ( ) ; numerator = numerator . add ( count . multiply ( BigInteger . valueOf ( distinctColors ) ) ) ; } else if ( history . size ( ) < NUM_COLORS ) { for ( int i = Math . min ( limit , remain ) ; i > 0 ; i -- ) { history . push ( i ) ; explore ( remain - i , i , history ) ; history . pop ( ) ; } } } private static BigInteger divideExactly ( BigInteger x , BigInteger y ) { BigInteger [ ] temp = x . divideAndRemainder ( y ) ; if ( temp [ 1 ] . signum ( ) != 0 ) throw new IllegalArgumentException ( " Not ▁ divisible " ) ; return temp [ 0 ] ; } }
import java . util . * ; import static java . lang . Math . * ; import java . awt . Point ; import java . io . * ; public class Exercise { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int landings = sc . nextInt ( ) ; int time = sc . nextInt ( ) ; int minutes [ ] = new int [ landings ] ; for ( int i = 0 ; i < landings ; i ++ ) { int hours = sc . nextInt ( ) * 60 ; int minute = sc . nextInt ( ) ; minutes [ i ] = minute + hours ; } if ( time + 1 <= minutes [ 0 ] ) { System . out . println ( 0 + " ▁ " + 0 ) ; return ; } for ( int i = 0 ; i < landings - 1 ; i ++ ) { if ( minutes [ i + 1 ] - minutes [ i ] >= 2 * time + 2 ) { int flight = minutes [ i ] + time + 1 ; int h = flight / 60 ; int m = flight % 60 ; System . out . println ( h + " ▁ " + m ) ; return ; } } int flight = minutes [ landings - 1 ] + time + 1 ; int h = flight / 60 ; int m = flight % 60 ; System . out . println ( h + " ▁ " + m ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int k = in . nextInt ( ) ; for ( int i = 0 ; i < k ; i ++ ) { long A = in . nextLong ( ) ; long B = in . nextLong ( ) ; if ( B == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; System . out . println ( A + " ▁ " + A * B + " ▁ " + ( B + 1 ) * A ) ; } } } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; int INF = 1 << 28 ; double EPS = 1e-9 ; void run ( ) { for ( ; ; ) { String s = sc . next ( ) ; String t = sc . next ( ) ; if ( s . equals ( "0" ) ) { break ; } int hit = 0 , blow = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { if ( t . charAt ( j ) == s . charAt ( j ) ) { hit ++ ; } for ( int i = 0 ; i < 4 ; i ++ ) { if ( t . charAt ( j ) == s . charAt ( i ) ) { blow ++ ; } } } blow -= hit ; println ( hit + " ▁ " + blow ) ; } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } void print ( String s ) { System . out . print ( s ) ; } void println ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . Arrays ; public class GFG { static int findMaxValue ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have " + " ▁ atleast ▁ 4 ▁ elements " ) ; } int table1 [ ] = new int [ n + 1 ] ; int table2 [ ] = new int [ n ] ; int table3 [ ] = new int [ n - 1 ] ; int table4 [ ] = new int [ n - 2 ] ; Arrays . fill ( table1 , Integer . MIN_VALUE ) ; Arrays . fill ( table2 , Integer . MIN_VALUE ) ; Arrays . fill ( table3 , Integer . MIN_VALUE ) ; Arrays . fill ( table4 , Integer . MIN_VALUE ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; for ( int i = n - 4 ; i >= 0 ; i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; return table4 [ 0 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 9 , 2 , 20 } ; int n = arr . length ; System . out . println ( findMaxValue ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static void centeredHexagonalSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( 3 * i * ( i - 1 ) + 1 + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; centeredHexagonalSeries ( n ) ; } }
import java . util . * ; public class Main { static String [ ] ABC = { " A " , " B " , " C " } ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String S = sc . next ( ) ; if ( dfs ( S ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } static boolean dfs ( String S ) { if ( S . equals ( " ABC " ) ) { return true ; } int cnt = 0 ; boolean f = false ; boolean [ ] pos = new boolean [ S . length ( ) ] ; for ( int j = 0 ; j + 3 <= S . length ( ) ; ++ j ) { if ( S . substring ( j , j + 3 ) . equals ( " ABC " ) ) { pos [ j ] = true ; ++ cnt ; } } if ( cnt < 1 ) return false ; out : for ( int i = 0 ; i < 3 ; ++ i ) { for ( int j = 0 ; j < S . length ( ) ; ++ j ) { if ( S . charAt ( j ) == ' A ' + i ) { if ( j - i < 0 || ! pos [ j - i ] ) continue out ; } } String next = S . replaceAll ( " ABC " , ABC [ i ] ) ; f |= dfs ( next . toString ( ) ) ; } return f ; } static void tr ( Object ... objects ) { System . out . println ( Arrays . deepToString ( objects ) ) ; } }
import java . util . * ; import java . io . * ; public class codeNinetySeven { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int m = input . nextInt ( ) ; int n = input . nextInt ( ) ; char [ ] [ ] arrayOne = new char [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { String data = " " ; if ( input . hasNext ( ) ) { data = input . next ( ) ; } else { break ; } for ( int j = 0 ; j < n ; j ++ ) { arrayOne [ i ] [ j ] = data . charAt ( j ) ; } } int sumr = 0 ; int sumc = 0 ; int count1 = 0 ; int count2 = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arrayOne [ i ] [ j ] == 66 ) { sumr += i + 1 ; count1 ++ ; } } } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arrayOne [ i ] [ j ] == 66 ) { sumc += j + 1 ; count2 ++ ; } } } System . out . println ( sumr / count1 + " ▁ " + sumc / count2 ) ; } }
public class GFG { static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( n == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( i == j ) { if ( mat [ i ] [ j ] < principalMin ) { principalMin = mat [ i ] [ j ] ; } if ( mat [ i ] [ j ] > principalMax ) { principalMax = mat [ i ] [ j ] ; } } if ( ( i + j ) == ( n - 1 ) ) { if ( mat [ i ] [ j ] < secondaryMin ) { secondaryMin = mat [ i ] [ j ] ; } if ( mat [ i ] [ j ] > secondaryMax ) { secondaryMax = mat [ i ] [ j ] ; } } } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; } static public void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( matrix ) ; } }
public class GFG { static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( n == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] < principalMin ) { principalMin = mat [ i ] [ i ] ; } if ( mat [ i ] [ i ] > principalMax ) { principalMax = mat [ i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) { secondaryMin = mat [ n - 1 - i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) { secondaryMax = mat [ n - 1 - i ] [ i ] ; } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; } static public void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( matrix ) ; } }
import java . io . * ; public class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }
import java . io . * ; public class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 1 ) / 2 ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static Boolean areElementsContiguous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ( ) ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static int getLeftMostZero ( Queue < Integer > zero ) { if ( zero . isEmpty ( ) ) return - 1 ; zero . remove ( ) ; return 0 ; } static int getLeftMostOne ( Queue < Integer > one ) { if ( one . isEmpty ( ) ) return - 1 ; one . remove ( ) ; return 1 ; } static int getLeftMostElement ( Queue < Integer > zero , Queue < Integer > one ) { if ( zero . isEmpty ( ) && one . isEmpty ( ) ) return - 1 ; else if ( zero . isEmpty ( ) ) { one . remove ( ) ; return 1 ; } else if ( one . isEmpty ( ) ) { zero . remove ( ) ; return 0 ; } int res = ( zero . peek ( ) < one . peek ( ) ) ? 0 : 1 ; if ( res == 0 ) zero . remove ( ) ; else one . remove ( ) ; return res ; } static void performQueries ( int arr [ ] , int n , int queries [ ] , int q ) { Queue < Integer > zero = new LinkedList < > ( ) ; Queue < Integer > one = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) zero . add ( i ) ; else one . add ( i ) ; } for ( int i = 0 ; i < q ; i ++ ) { int type = queries [ i ] ; switch ( type ) { case 1 : System . out . println ( getLeftMostZero ( zero ) ) ; break ; case 2 : System . out . println ( getLeftMostOne ( one ) ) ; break ; case 3 : System . out . println ( getLeftMostElement ( zero , one ) ) ; break ; } } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 1 , 1 , 1 } ; int n = arr . length ; int queries [ ] = { 1 , 3 , 1 } ; int q = queries . length ; performQueries ( arr , n , queries , q ) ; } }
public class GFG { static void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; System . out . print ( val * ( x < 0 ? - 1 : 1 ) + " ▁ 0 ▁ " ) ; System . out . print ( "0 ▁ " + val * ( y < 0 ? - 1 : 1 ) ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 3 ; Vertices ( x , y ) ; } }
import java . util . HashMap ; import java . util . HashSet ; public class GFG { public static void getSum ( int [ ] a , int n ) { int [ ] P = new int [ n ] ; P [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) P [ i ] = a [ i ] + P [ i - 1 ] ; int S = P [ n - 1 ] ; HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . put ( P [ i ] , 1 ) ; HashSet < Integer > res = new HashSet < > ( ) ; for ( int i = 1 ; i * i <= S ; i ++ ) { if ( S % i == 0 ) { boolean pres = true ; int div1 = i , div2 = S / i ; for ( int j = div1 ; j <= S ; j += div1 ) { if ( hash . get ( j ) == null || hash . get ( j ) != 1 ) { pres = false ; break ; } } if ( pres && div1 != S ) res . add ( div1 ) ; pres = true ; for ( int j = S / i ; j <= S ; j += S / i ) { if ( hash . get ( j ) == null || hash . get ( j ) != 1 ) { pres = false ; break ; } } if ( pres && div2 != S ) res . add ( div2 ) ; } } if ( res . size ( ) == 0 ) { System . out . println ( " - 1" ) ; return ; } for ( int i : res ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 } ; int n = a . length ; getSum ( a , n ) ; } }
import java . util . Vector ; public class GFG { static void originalArray ( int greater [ ] , int n ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) temp . add ( i ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = n - greater [ i ] - i ; arr [ i ] = temp . get ( k ) ; temp . remove ( k ) ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int Arr [ ] = { 6 , 3 , 2 , 1 , 0 , 1 , 0 } ; int n = Arr . length ; originalArray ( Arr , n ) ; } }
import java . util . * ; public class practice { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; String s = scn . next ( ) , p ; int k = scn . nextInt ( ) , x = 0 , y = 0 , ans = 0 ; char a , b ; for ( int i = 0 ; i < k ; i ++ ) { p = scn . next ( ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == p . charAt ( 0 ) ) { x ++ ; } else if ( s . charAt ( j ) == p . charAt ( 1 ) ) { y ++ ; } else { ans += Math . min ( x , y ) ; x = 0 ; y = 0 ; } } ans += Math . min ( x , y ) ; x = 0 ; y = 0 ; } System . out . println ( ans ) ; } }
import java . util . Arrays ; public class Solution { public int findRadius ( int [ ] houses , int [ ] heaters ) { Arrays . sort ( heaters ) ; int result = Integer . MIN_VALUE ; for ( int house : houses ) { int index = Arrays . binarySearch ( heaters , house ) ; if ( index < 0 ) index = - ( index + 1 ) ; int dist1 = index - 1 >= 0 ? house - heaters [ index - 1 ] : Integer . MAX_VALUE ; int dist2 = index < heaters . length ? heaters [ index ] - house : Integer . MAX_VALUE ; result = Math . max ( result , Math . min ( dist1 , dist2 ) ) ; } return result ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] houses = { 1 , 2 , 3 } ; int [ ] heaters = { 2 } ; int out = sObj . findRadius ( houses , heaters ) ; System . out . println ( out ) ; } }
public final class p130 { public static void main ( String [ ] args ) { System . out . println ( new p130 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; int found = 0 ; for ( int i = 7 ; found < 25 ; i += 2 ) { if ( i % 5 != 0 && ! Library . isPrime ( i ) && ( i - 1 ) % findLeastDivisibleRepunit ( i ) == 0 ) { sum += i ; found ++ ; } } return Integer . toString ( sum ) ; } private static int findLeastDivisibleRepunit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; if ( n > Integer . MAX_VALUE / 10 ) throw new IllegalArgumentException ( " Arithmetic ▁ overflow " ) ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; } }
import java . io . * ; import java . util . * ; public class Solution { static int res = 0 ; static int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) Math . floor ( Math . pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) Math . pow ( i , n ) , i , n ) ; } return res ; } static int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; } public static void main ( String [ ] args ) { System . out . println ( check ( 10 , 2 ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { static String oper ; public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; String s = sc . nextLine ( ) ; char [ ] chs = s . toCharArray ( ) ; String oper = dfs ( chs , 1 , chs [ 0 ] - '0' , " " ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { sb . append ( chs [ i ] ) ; if ( i < chs . length - 1 ) sb . append ( oper . charAt ( i ) ) ; } System . out . println ( sb . toString ( ) + " = 7" ) ; } private static String dfs ( char [ ] chs , int idx , int cur , String opers ) { if ( idx == chs . length ) { if ( cur == 7 ) return opers ; else return null ; } String plus = dfs ( chs , idx + 1 , cur + ( chs [ idx ] - '0' ) , opers + " + " ) ; if ( plus != null ) return plus ; String nega = dfs ( chs , idx + 1 , cur - ( chs [ idx ] - '0' ) , opers + " - " ) ; if ( nega != null ) return nega ; return null ; } }
import java . util . * ; import java . io . * ; public class Solution { public static void main ( String [ ] agrs ) { Scanner sc = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; float [ ] b = new float [ n ] ; float total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextFloat ( ) ; total += b [ i ] / 2.0 ; } float [ ] [ ] dp = new float [ n + 1 ] [ 10001 ] ; for ( int i = 0 ; i <= n ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; dp [ 0 ] [ 0 ] = total ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < 10001 ; j ++ ) { if ( dp [ k ] [ j ] == - 1 ) continue ; dp [ k + 1 ] [ j + a [ i ] ] = ( float ) Math . max ( dp [ k + 1 ] [ j + a [ i ] ] , dp [ k ] [ j ] + b [ i ] / 2.0 ) ; } } } float max = 0 ; for ( int k = 1 ; k <= n ; k ++ ) { max = 0 ; for ( int j = 0 ; j < 10001 ; j ++ ) { max = ( float ) Math . max ( max , Math . min ( dp [ k ] [ j ] , j ) ) ; } out . print ( max + " ▁ " ) ; } out . flush ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner rand = new Scanner ( System . in ) ; long n = rand . nextLong ( ) ; System . out . println ( solve ( n ) ) ; } static int solve ( long n ) { int [ ] sum = String . valueOf ( n ) . chars ( ) . map ( ch -> ch - '0' ) . toArray ( ) ; for ( int i = 0 ; i < sum . length - 1 ; i ++ ) { sum [ i ] -- ; sum [ i + 1 ] += 10 ; } for ( int i = sum . length - 1 ; i >= 1 ; i -- ) { if ( sum [ i ] == 19 ) { sum [ i ] -= 10 ; sum [ i - 1 ] ++ ; } } return Arrays . stream ( sum ) . sum ( ) ; } }
import java . util . * ; public class GFG { static boolean prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void thirdNumber ( int a , int b ) { int sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( sum == 0 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } System . out . print ( temp ) ; } static public void main ( String [ ] arr ) { int a = 3 , b = 5 ; thirdNumber ( a , b ) ; } }
import java . util . * ; class solution { static int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; } public static void main ( String arr [ ] ) { int n = 6 , m = 6 , a = 4 ; System . out . println ( Squares ( n , m , a ) ) ; } }
import java . util . * ; public class TwoRegularPolygons { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; System . out . println ( ( n % m ) == 0 ? " YES " : " NO " ) ; } } }
public class GFG { static int countCubes ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; } public static void main ( String [ ] args ) { int a = 7 , b = 30 ; System . out . print ( " Count ▁ of ▁ Cubes ▁ is ▁ " + countCubes ( a , b ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] oddList = new int [ 100001 ] ; int [ ] evenList = new int [ 100001 ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { int v = sc . nextInt ( ) ; if ( i % 2 == 1 ) oddList [ v ] ++ ; if ( i % 2 == 0 ) evenList [ v ] ++ ; } int maxOdd = 0 , maxEven = 0 , secondmaxOdd = 0 , secondmaxEven = 0 , countOdd = 0 , countEven = 0 ; for ( int i = 1 ; i < 100001 ; i ++ ) { maxOdd = Math . max ( oddList [ i ] , maxOdd ) ; maxEven = Math . max ( evenList [ i ] , maxEven ) ; } int oddnum = 0 , evennum = 0 ; for ( int i = 1 ; i < 100001 ; i ++ ) { if ( oddList [ i ] == maxOdd ) { oddnum = i ; countOdd ++ ; } if ( evenList [ i ] == maxEven ) { evennum = i ; countEven ++ ; } } for ( int i = 1 ; i < 100001 ; i ++ ) { if ( oddList [ i ] != maxOdd ) { secondmaxOdd = Math . max ( oddList [ i ] , secondmaxOdd ) ; } if ( evenList [ i ] != maxEven ) { secondmaxEven = Math . max ( evenList [ i ] , secondmaxEven ) ; } } if ( countOdd >= 2 ) secondmaxOdd = maxOdd ; if ( countEven >= 2 ) secondmaxEven = maxEven ; for ( int i = 1 ; i < 100001 ; i ++ ) { if ( oddList [ i ] == maxOdd ) oddnum = i ; if ( evenList [ i ] == maxEven ) evennum = i ; } if ( oddnum == evennum ) { if ( maxOdd > maxEven ) { maxEven = secondmaxEven ; } else if ( maxOdd < maxEven ) { maxOdd = secondmaxOdd ; } else { maxEven = Math . max ( secondmaxOdd , secondmaxEven ) ; } } int ans = n - maxOdd - maxEven ; System . out . println ( ans ) ; } }
public class GFG { public static void SubString ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) System . out . println ( str . substring ( i , j ) ) ; } public static void main ( String [ ] args ) { String str = " abcd " ; SubString ( str , str . length ( ) ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void countPrimePosition ( int arr [ ] ) { int c0 = 0 , c1 = 0 ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 && isPrime ( i ) ) c0 ++ ; if ( arr [ i ] == 1 && isPrime ( i ) ) c1 ++ ; } System . out . println ( " Number ▁ of ▁ 0s ▁ = ▁ " + c0 ) ; System . out . println ( " Number ▁ of ▁ 1s ▁ = ▁ " + c1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 } ; countPrimePosition ( arr ) ; } }
import java . io . * ; public class GFG { static void angleextcycquad ( int z ) { System . out . print ( " The ▁ exterior ▁ angle ▁ of ▁ the " + " ▁ cyclic ▁ quadrilateral ▁ is ▁ " + z + " ▁ degrees " ) ; } public static void main ( String [ ] args ) { int z = 48 ; angleextcycquad ( z ) ; } }
public class GFG { static void printMinIndexChar ( String str , String patt ) { int minIndex = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != Integer . MAX_VALUE ) System . out . println ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str . charAt ( minIndex ) ) ; else System . out . println ( " No ▁ character ▁ present " ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; String patt = " set " ; printMinIndexChar ( str , patt ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; if ( b < a ) { System . out . println ( " Happy ▁ Alex " ) ; return ; } } System . out . println ( " Poor ▁ Alex " ) ; } }
import java . util . * ; import java . math . * ; public class GFG { static int maxnumber ( int n , int k ) { for ( int j = 0 ; j < k ; j ++ ) { int ans = 0 ; int i = 1 ; while ( n / i > 0 ) { int temp = ( n / ( i * 10 ) ) * i + ( n % i ) ; i *= 10 ; ans = Math . max ( ans , temp ) ; } n = ans ; } return n ; } public static void main ( String [ ] args ) { int n = 6358 ; int k = 1 ; System . out . println ( maxnumber ( n , k ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { PrintStream log = new PrintStream ( new OutputStream ( ) { public void write ( int b ) { } } ) ; PrintStream result = System . out ; Scanner sc = new Scanner ( System . in ) ; void main ( ) throws IOException { int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int [ ] w = new int [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { int a = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; for ( int j = 0 ; j < L ; j ++ ) { w [ ( a + j ) % N ] = 1 ; } } int [ ] t = new int [ N + 1 ] ; int s = 0 ; int f = 0 ; int s0 = 0 ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( f == 0 && w [ i ] == 1 ) { s = i ; f = 1 ; } else if ( f == 1 && w [ i ] == 0 ) { f = 0 ; if ( s == 0 ) { s0 = i ; } else { t [ i - s ] ++ ; } } } if ( f == 1 ) { t [ i - s + s0 ] ++ ; } else if ( s0 != 0 ) { t [ s0 ] ++ ; } for ( i = N ; i > 0 ; i -- ) { if ( t [ i ] > 0 ) { result . println ( i + " ▁ " + t [ i ] ) ; } } } public static void main ( String [ ] args ) throws IOException { new Main ( ) . main ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner io = new Scanner ( System . in ) ; int n = io . nextInt ( ) ; int [ ] a = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = io . nextInt ( ) ; } long sum = 0 ; long now = 0 ; long border = 1 ; long end = 0 ; long ans_p = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += a [ i ] ; end = border - sum ; if ( border > 0 ) { if ( now < end ) { ans_p += Math . abs ( now - end ) ; now = end ; } } else { if ( now > end ) { ans_p += Math . abs ( now - end ) ; now = end ; } } border = - border ; } sum = 0 ; now = 0 ; border = - 1 ; end = 0 ; long ans_m = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += a [ i ] ; end = border - sum ; if ( border > 0 ) { if ( now < end ) { ans_m += Math . abs ( now - end ) ; now = end ; } } else { if ( now > end ) { ans_m += Math . abs ( now - end ) ; now = end ; } } border = - border ; } System . out . println ( Math . min ( ans_p , ans_m ) ) ; } }
public class AAA { static int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } else return 13 ; } public static void main ( String [ ] args ) { long N = 1 ; for ( N = 1 ; N <= 10 ; N ++ ) System . out . println ( " For ▁ N ▁ = ▁ " + N + " ▁ : ▁ " + get_last_two_digit ( N ) ) ; } }
public class GFG { public static void main ( String args [ ] ) { String binaryNumber = "1001" ; System . out . println ( Integer . parseInt ( binaryNumber , 2 ) ) ; } }
import java . util . * ; public class GFG { static boolean isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; } public static void main ( String args [ ] ) { float l = 0.70710678f , m = 0.5f , n = 0.5f ; if ( isPossible ( l , m , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ; static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } static void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; } public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }
import java . util . * ; public class D { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; while ( T -- > 0 ) { int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; long mini = 0 ; long ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { long diff = a [ i ] - a [ i - 1 ] ; mini = mini + ( - 1 ) * diff * i ; ans += mini ; } System . out . println ( ans + a [ n - 1 ] ) ; } } }
import java . util . * ; class Main { static int segregate ( int arr [ ] , int size ) { int j = 0 , i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= 0 ) { int temp ; temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j ++ ; } } return j ; } static int findMissingPositive ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { int x = Math . abs ( arr [ i ] ) ; if ( x - 1 < size && arr [ x - 1 ] > 0 ) arr [ x - 1 ] = - arr [ x - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; } static int findMissing ( int arr [ ] , int size ) { int shift = segregate ( arr , size ) ; int arr2 [ ] = new int [ size - shift ] ; int j = 0 ; for ( int i = shift ; i < size ; i ++ ) { arr2 [ j ] = arr [ i ] ; j ++ ; } return findMissingPositive ( arr2 , j ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 10 , 2 , - 10 , - 20 } ; int arr_size = arr . length ; int missing = findMissing ( arr , arr_size ) ; System . out . println ( " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " + missing ) ; } }
import java . lang . * ; public class GFG { static final int mod = 1000000007 ; static int digitNumber ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } public static void main ( String [ ] args ) { int d = 9 ; int n = 3 ; System . out . println ( countExcluding ( n , d ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . Math ; import java . util . Scanner ; import java . io . * ; import java . util . * ; import java . util . StringTokenizer ; public class Main { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) throws Exception { FastReader sc = new FastReader ( ) ; BufferedWriter ou = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; int t = sc . nextInt ( ) ; for ( int o = 0 ; o < t ; o ++ ) { int n = sc . nextInt ( ) ; int [ ] ar = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = sc . nextInt ( ) ; } if ( ar [ 0 ] + ar [ 1 ] > ar [ n - 1 ] ) { ou . write ( - 1 + " \n " ) ; } else { ou . write ( 1 + " ▁ " + 2 + " ▁ " + n + " \n " ) ; } } ou . flush ( ) ; } }
import java . util . * ; public class GFG { static void convert12 ( String str ) { int h1 = ( int ) str . charAt ( 0 ) - '0' ; int h2 = ( int ) str . charAt ( 1 ) - '0' ; int hh = h1 * 10 + h2 ; String Meridien ; if ( hh < 12 ) { Meridien = " AM " ; } else Meridien = " PM " ; hh %= 12 ; if ( hh == 0 ) { System . out . print ( "12" ) ; for ( int i = 2 ; i < 8 ; ++ i ) { System . out . print ( str . charAt ( i ) ) ; } } else { System . out . print ( hh ) ; for ( int i = 2 ; i < 8 ; ++ i ) { System . out . print ( str . charAt ( i ) ) ; } } System . out . println ( " ▁ " + Meridien ) ; } public static void main ( String ar [ ] ) { String str = "17:35:20" ; convert12 ( str ) ; } }
public class GFG { static boolean check ( String s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i % k ) ) { return false ; } } return true ; } static int countCommonDivisors ( String a , String b ) { int ct = 0 ; int n = a . length ( ) , m = b . length ( ) ; for ( int i = 1 ; i <= Math . min ( n , m ) ; i ++ ) { if ( n % i == 0 && m % i == 0 ) { if ( a . substring ( 0 , i ) . equals ( b . substring ( 0 , i ) ) ) { if ( check ( a , i ) && check ( b , i ) ) { ct ++ ; } } } } return ct ; } public static void main ( String [ ] args ) { String a = " xaxa " , b = " xaxaxaxa " ; System . out . println ( countCommonDivisors ( a , b ) ) ; } }
public class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + " ▁ " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } public static void main ( String arg [ ] ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; printknapSack ( W , wt , val , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int z = n * 2 ; int c = 0 ; int arr [ ] = new int [ z ] ; ArrayList < Integer > ff = new ArrayList < > ( ) ; ArrayList < Integer > ss = new ArrayList < > ( ) ; while ( n -- > 0 ) { ff . add ( sc . nextInt ( ) ) ; ss . add ( sc . nextInt ( ) ) ; } int pp = ff . size ( ) ; for ( int i = 0 ; i < pp ; i ++ ) { for ( int j = 0 ; j < pp ; j ++ ) { if ( ff . get ( i ) == ss . get ( j ) ) { c ++ ; } else { continue ; } } } System . out . print ( c ) ; } }
import java . io . * ; public class GFG { static void indexedSequentialSearch ( int arr [ ] , int n , int k ) { int elements [ ] = new int [ 20 ] ; int indices [ ] = new int [ 20 ] ; int temp , i ; int j = 0 , ind = 0 , start = 0 , end = 0 ; for ( i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { System . out . println ( " Not ▁ found " ) ; return ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k < elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; break ; } } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) System . out . println ( " Found ▁ at ▁ index ▁ " + i ) ; else System . out . println ( " Not ▁ found " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 8 , 9 , 10 } ; int n = arr . length ; int k = 8 ; indexedSequentialSearch ( arr , n , k ) ; } }
public class GFG { static int larrgestPalindrome ( int n ) { int upper_limit = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { upper_limit *= 10 ; upper_limit += 9 ; } int lower_limit = 1 + upper_limit / 10 ; int max_product = 0 ; for ( int i = upper_limit ; i >= lower_limit ; i -- ) { for ( int j = i ; j >= lower_limit ; j -- ) { int product = i * j ; if ( product < max_product ) break ; int number = product ; int reverse = 0 ; while ( number != 0 ) { reverse = reverse * 10 + number % 10 ; number /= 10 ; } if ( product == reverse && product > max_product ) max_product = product ; } } return max_product ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . print ( larrgestPalindrome ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static int check ( long dp [ ] , long a ) { int start = 0 ; int end = dp . length - 1 ; while ( true ) { if ( dp [ start ] >= a ) return start ; else if ( dp [ end ] <= a ) return end ; else { if ( start + 1 == end ) return end ; else { int mid = ( start + end ) / 2 ; if ( dp [ mid ] == a ) return mid ; else if ( dp [ mid ] > a ) end = mid ; else start = mid ; } } } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long a [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextLong ( ) ; long dp [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1000000001 ; } dp [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ check ( dp , a [ i ] ) ] = a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] > 1000000000 ) { System . out . println ( i ) ; break ; } if ( i == n - 1 ) System . out . println ( n ) ; } } }
import java . util . Scanner ; public class FastFoodRestaurant { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int test = sc . nextInt ( ) ; while ( test -- > 0 ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a == 0 && b == 0 && c == 0 ) { System . out . println ( 0 ) ; } else { if ( b > c && b > a ) { int k = a ; a = b ; b = k ; } if ( c > b && c > a ) { int k = a ; a = c ; c = k ; } int res = 0 ; if ( a >= 1 ) { a -- ; res ++ ; } if ( b >= 1 ) { b -- ; res ++ ; } if ( c >= 1 ) { c -- ; res ++ ; } if ( a >= 1 && b >= 1 ) { a -- ; b -- ; res ++ ; } if ( a >= 1 && c >= 1 ) { a -- ; c -- ; res ++ ; } if ( c >= 1 && b >= 1 ) { c -- ; b -- ; res ++ ; } if ( a >= 1 && b >= 1 && c >= 1 ) res ++ ; System . out . println ( res ) ; } } } }
import java . io . * ; import java . util . * ; public class Solution788A { public static int [ ] arr = new int [ 100001 ] ; public static int [ ] dist = new int [ 100001 ] ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) , " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } long finalMax = 0 ; for ( int start = 1 ; start < 3 ; start ++ ) { long max = 0 ; long sum = 0 ; boolean add = true ; for ( int i = start ; i < n ; i ++ ) { dist [ i ] = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; if ( add ) { sum += dist [ i ] ; max = sum > max ? sum : max ; add = false ; } else { sum -= dist [ i ] ; add = true ; } if ( sum < 0 ) { sum = 0 ; add = true ; } } finalMax = max > finalMax ? max : finalMax ; } System . out . println ( finalMax ) ; } }
import java . util . * ; public class GFG { static int maximumXor ( int arr [ ] , int n ) { Stack < Integer > sForward = new Stack < Integer > ( ) , sBackward = new Stack < Integer > ( ) ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! sForward . isEmpty ( ) && arr [ i ] < arr [ sForward . peek ( ) ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward . peek ( ) ] ) ; sForward . pop ( ) ; } sForward . add ( i ) ; while ( ! sBackward . isEmpty ( ) && arr [ n - i - 1 ] < arr [ sBackward . peek ( ) ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward . peek ( ) ] ) ; sBackward . pop ( ) ; } sBackward . add ( n - i - 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 1 , 2 } ; int n = arr . length ; System . out . print ( maximumXor ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; } public static void main ( String [ ] args ) { int n = 2545 ; decToHexa ( n ) ; } }
import java . util . HashMap ; import java . util . Scanner ; public class Main { int n ; HashMap < Integer , Integer > map ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Main m = new Main ( sc ) ; m . solve ( ) ; sc . close ( ) ; } Main ( Scanner sc ) { n = sc . nextInt ( ) ; map = new HashMap < Integer , Integer > ( ) { { for ( int i = - 1 ; i <= 1.0e+5 + 2 ; i ++ ) put ( i , 0 ) ; } } ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; map . replace ( a , map . get ( a ) + 1 ) ; } } void solve ( ) { int max = Integer . MIN_VALUE ; for ( int x = 0 ; x <= 1.0e+5 + 1 ; x ++ ) { max = Math . max ( max , map . get ( x - 1 ) + map . get ( x ) + map . get ( x + 1 ) ) ; } System . out . println ( max ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; while ( in . hasNextLine ( ) ) { int R = in . nextInt ( ) ; int C = in . nextInt ( ) ; if ( R == 0 && C == 0 ) break ; HashMap < Character , Loc > hm = new HashMap < Character , Loc > ( ) ; for ( int i = 0 ; i < R ; i ++ ) { String str = in . next ( ) ; for ( int j = 0 ; j < C ; j ++ ) { char c = str . charAt ( j ) ; if ( c == ' _ ' ) continue ; hm . put ( c , new Loc ( i , j ) ) ; } } String str = in . next ( ) ; int iPos = 0 ; int jPos = 0 ; int count = str . length ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { Loc loc = hm . get ( str . charAt ( i ) ) ; count += Math . abs ( iPos - loc . i ) + Math . abs ( jPos - loc . j ) ; iPos = loc . i ; jPos = loc . j ; } System . out . println ( count ) ; } } public static class Loc { int i ; int j ; public Loc ( int i , int j ) { this . i = i ; this . j = j ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main m = new Main ( ) ; m . run ( ) ; } Scanner sc = new Scanner ( System . in ) ; void run ( ) { int n = sc . nextInt ( ) ; if ( n == 1 ) { System . out . println ( " Hello ▁ World " ) ; } else { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a + b ) ; } } }
public class GFG { static int extractMaximum ( String str ) { int num = 0 , res = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) num = num * 10 + ( str . charAt ( i ) - '0' ) ; else { res = Math . max ( res , num ) ; num = 0 ; } } return Math . max ( res , num ) ; } public static void main ( String [ ] args ) { String str = "100klh564abc365bg " ; System . out . println ( extractMaximum ( str ) ) ; } }
public class GFG { static final int max = 50009 ; static void find_Indices ( int arr [ ] , int n ) { int sum [ ] = new int [ max ] ; int index_1 , index_2 , index_3 , index ; int k , i ; for ( i = 1 , k = 0 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ k ++ ] ; double ans = - ( 1e15 ) ; index_1 = index_2 = index_3 = - 1 ; for ( int l = 0 ; l <= n ; l ++ ) { index = 0 ; double vmin = ( 1e15 ) ; for ( int r = l ; r <= n ; r ++ ) { if ( sum [ r ] < vmin ) { vmin = sum [ r ] ; index = r ; } if ( sum [ l ] + sum [ r ] - vmin > ans ) { ans = sum [ l ] + sum [ r ] - vmin ; index_1 = l ; index_2 = index ; index_3 = r ; } } } System . out . print ( index_1 + " ▁ " + index_2 + " ▁ " + index_3 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , 3 } ; int n = arr . length ; find_Indices ( arr , n ) ; } }
public class GFG { static void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; int n = arr . length ; printElements ( arr , n ) ; } }
public class GFG { static int valueofX ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return sum / n ; } else { int A = sum / n , B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } } public static void main ( String args [ ] ) { int n = 7 ; int arr [ ] = { 6 , 9 , 1 , 6 , 1 , 3 , 7 } ; System . out . println ( valueofX ( arr , n ) ) ; } }
import java . util . * ; public final class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int l = sc . nextInt ( ) ; String s = " " ; int [ ] arr = new int [ l ] ; for ( int j = 0 ; j < n ; j ++ ) { String temp = Integer . toBinaryString ( sc . nextInt ( ) ) ; while ( temp . length ( ) < l ) temp = '0' + temp ; for ( int k = 0 ; k < l ; k ++ ) { if ( k < temp . length ( ) && temp . charAt ( k ) == '1' ) arr [ k ] += 1 ; } } for ( int j = 0 ; j < l ; j ++ ) { if ( n - arr [ j ] >= arr [ j ] ) s += 0 ; else s += 1 ; } System . out . println ( Integer . parseInt ( s , 2 ) ) ; } } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int sL = s . length ( ) ; String sT = s ; for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { sL -= 2 ; sT = sT . substring ( 0 , sL ) ; if ( sT . substring ( 0 , sL / 2 ) . equals ( sT . substring ( sL / 2 ) ) ) { System . out . println ( sL ) ; break ; } } } }
import java . util . * ; import java . lang . * ; public class GFG { public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } } public static void main ( String [ ] args ) { System . out . print ( findNth ( 5 ) ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static int findNth ( int n ) { int count = 0 ; for ( int curr = 1 ; ; curr ++ ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } } public static void main ( String [ ] args ) { System . out . print ( findNth ( 5 ) ) ; } }
public class GFG { static int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; } public static void main ( String [ ] args ) { int N , S ; N = 5 ; S = 11 ; int count = countNumber ( N , S ) ; System . out . println ( count ) ; } }
import java . util . Arrays ; public class GFG { static boolean strmatch ( String str , String pattern , int n , int m ) { if ( m == 0 ) return ( n == 0 ) ; boolean [ ] [ ] lookup = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) Arrays . fill ( lookup [ i ] , false ) ; lookup [ 0 ] [ 0 ] = true ; for ( int j = 1 ; j <= m ; j ++ ) if ( pattern . charAt ( j - 1 ) == ' * ' ) lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( pattern . charAt ( j - 1 ) == ' * ' ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] || lookup [ i - 1 ] [ j ] ; else if ( pattern . charAt ( j - 1 ) == ' ? ' || str . charAt ( i - 1 ) == pattern . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] ; else lookup [ i ] [ j ] = false ; } } return lookup [ n ] [ m ] ; } public static void main ( String args [ ] ) { String str = " baaabab " ; String pattern = " * * * * * ba * * * * * ab " ; if ( strmatch ( str , pattern , str . length ( ) , pattern . length ( ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; import java . util . Scanner ; import java . util . SortedSet ; import java . util . TreeSet ; public class Main { void run ( ) { Scanner sc = new Scanner ( System . in ) ; int N = 1000001 ; boolean [ ] p = new boolean [ N ] ; Arrays . fill ( p , true ) ; p [ 0 ] = p [ 1 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( p [ i ] ) for ( int j = i + i ; j < N ; j += i ) p [ j ] = false ; } while ( true ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( ( a | b ) == 0 ) break ; SortedSet < Integer > sa = new TreeSet < Integer > ( ) ; SortedSet < Integer > sb = new TreeSet < Integer > ( ) ; int k = 2 ; while ( a > 1 ) { if ( p [ k ] && a % k == 0 ) { a /= k ; sa . add ( k ) ; } else k ++ ; } k = 2 ; while ( b > 1 ) { if ( p [ k ] && b % k == 0 ) { b /= k ; sb . add ( k ) ; } else k ++ ; } int pa = sa . last ( ) ; sa . remove ( pa ) ; int pb = sb . last ( ) ; sb . remove ( pb ) ; for ( int x : sa ) pa -= x ; for ( int x : sb ) pb -= x ; System . out . println ( pa > pb ? " a " : " b " ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . io . * ; public class GFG { static int nCr ( int n , int r ) { int fac [ ] = new int [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) fac [ i ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { fac [ i ] = fac [ i - 1 ] * i ; } int ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) ; return ans ; } public static void main ( String [ ] args ) { int n = 3 ; int k = 3 ; int ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) ; System . out . println ( ans ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int min = Integer . MAX_VALUE ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int sa = Math . abs ( a [ n - 1 ] - a [ i ] * 2 ) ; if ( sa < min ) { min = sa ; ans = a [ i ] ; } } System . out . print ( a [ n - 1 ] + " ▁ " ) ; System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long powGCD ( long a , long n , long b ) { for ( int i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; } public static void main ( String [ ] args ) { long a = 10 , b = 5 , n = 2 ; System . out . println ( powGCD ( a , n , b ) ) ; } }
import java . io . IOException ; import java . util . Scanner ; public class Main { public static int n ; public static int A [ ] ; public static int B [ ] ; public static int C [ ] = new int [ 10000 ] ; public static StringBuilder sb = new StringBuilder ( ) ; public static void main ( String [ ] args ) throws NumberFormatException , IOException { Scanner scan = new Scanner ( System . in ) ; n = scan . nextInt ( ) ; A = new int [ n ] ; B = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = scan . nextInt ( ) ; C [ A [ i ] ] ++ ; } for ( int i = 1 ; i < 10000 ; i ++ ) { C [ i ] = C [ i - 1 ] + C [ i ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { B [ C [ A [ i ] ] - 1 ] = A [ i ] ; C [ A [ i ] ] -- ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { sb . append ( B [ i ] ) ; sb . append ( " ▁ " ) ; } System . out . println ( sb . toString ( ) + B [ n - 1 ] ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '8' ) count ++ ; } System . out . println ( Math . min ( count , n / 11 ) ) ; } }
public class GFG { static int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; } public static void main ( String [ ] args ) { int n = 50 ; int b = 2 ; System . out . print ( sumOfDigit ( n , b ) ) ; } }
import java . io . * ; public class GFG { static void printLargestDivisible ( int n , int a [ ] ) { int i , c0 = 0 , c5 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) c0 ++ ; else c5 ++ ; } c5 = ( int ) Math . floor ( c5 / 9 ) * 9 ; if ( c0 == 0 ) System . out . print ( - 1 ) ; else if ( c5 == 0 ) System . out . println ( 0 ) ; else { for ( i = 0 ; i < c5 ; i ++ ) System . out . print ( 5 ) ; for ( i = 0 ; i < c0 ; i ++ ) System . out . print ( 0 ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 } ; int n = a . length ; printLargestDivisible ( n , a ) ; } }
import java . io . * ; public class GFG { static int countWays ( int n ) { int counter = 0 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countWays ( n ) ) ; } }
import java . util . * ; public class GFG { static int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( int ) ( ( ( S - S1 ) / Math . floor ( S ) ) * 60 ) ; return Min ; } public static void main ( String [ ] args ) { int S = 30 , S1 = 10 ; System . out . println ( numberOfMinutes ( S , S1 ) + " ▁ min " ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class codechef_submission { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] b = new int [ n ] ; if ( n < k ) { System . out . println ( n ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } int [ ] d = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { d [ i ] = b [ i + 1 ] - b [ i ] - 1 ; } Arrays . sort ( d ) ; int sum = b [ b . length - 1 ] - b [ 0 ] + 1 ; for ( int i = d . length - 1 ; i > d . length - 1 - ( k - 1 ) ; i -- ) { sum -= d [ i ] ; } System . out . println ( sum ) ; } }
public class GFG { static int onesComplement ( int n ) { int number_of_bits = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) + 1 ; return ( ( 1 << number_of_bits ) - 1 ) ^ n ; } public static void main ( String [ ] args ) { int n = 22 ; System . out . print ( onesComplement ( n ) ) ; } }
import java . util . Scanner ; public class NewClass27 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int w = in . nextInt ( ) ; int h = in . nextInt ( ) ; int n = in . nextInt ( ) ; int sheet = 1 ; while ( w % 2 == 0 ) { w /= 2 ; sheet *= 2 ; } while ( h % 2 == 0 ) { h /= 2 ; sheet *= 2 ; } if ( sheet >= n ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public class GFG { static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( " ( " + ( int ) ( 2 * x2 - x1 ) + " , " + ( int ) ( 2 * y2 - y1 ) + " ▁ ) " ) ; } public static void main ( String args [ ] ) { int x1 = 0 , y1 = 0 , x2 = 1 , y2 = 1 ; findPoint ( x1 , y1 , x2 , y2 ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] z ) { Scanner s = new Scanner ( System . in ) ; for ( int n = s . nextInt ( ) + 1 , m = n / 2 , a , b , i = s . nextInt ( ) ; i -- > 0 ; ) System . out . println ( ( m - 1 - Math . max ( Math . abs ( ( a = s . nextInt ( ) - m ) > 0 && n % 2 > 0 ? a - 1 : a ) , Math . abs ( ( b = s . nextInt ( ) - m ) > 0 && n % 2 > 0 ? b - 1 : b ) ) ) % 3 + 1 ) ; } }
import java . io . * ; public class GFG { static void alter ( long x , long y ) { while ( true ) { if ( x == 0 || y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; } public static void main ( String [ ] args ) { long x = 12 , y = 5 ; alter ( x , y ) ; } }
import java . io . PrintWriter ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ) { int n = in . nextInt ( ) ; int [ ] v = new int [ n ] ; Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = in . nextInt ( ) ; set . add ( v [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) swap ( v , ( int ) ( Math . random ( ) * ( i - 1 ) ) , i ) ; Arrays . sort ( v ) ; int ans = 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int d = v [ j ] - v [ i ] ; if ( set . contains ( v [ i ] - d ) ) continue ; int cnt = 2 , cur = v [ j ] ; while ( set . contains ( cur + d ) ) { cur += d ; cnt ++ ; } ans = Math . max ( ans , cnt ) ; } } out . println ( ans ) ; } } private static void swap ( int [ ] a , int x , int y ) { int t = a [ x ] ; a [ x ] = a [ y ] ; a [ y ] = t ; } }
import java . util . Scanner ; public class A1569 { static boolean flag ; static int finals ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; while ( cases -- > 0 ) { flag = false ; int letters = sc . nextInt ( ) ; String ab = sc . next ( ) ; for ( int i = 1 ; i < letters ; i ++ ) { if ( ab . charAt ( i - 1 ) != ab . charAt ( i ) ) { flag = true ; System . out . println ( ( i ) + " ▁ " + ( i + 1 ) ) ; break ; } } if ( flag == false ) { System . out . println ( " - 1 ▁ " + " - 1" ) ; } } } }
import java . util . * ; public class GFG { static long mod = 1000000007 ; static long inv2 = 500000004 ; static long modulo ( String num ) { long res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( long ) num . charAt ( i ) - '0' ) % mod ; return res ; } static long findSum ( String L , String R ) { long a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod ; return ret ; } public static void main ( String [ ] args ) { String L = "88949273204" ; String R = "98429729474298592" ; System . out . println ( findSum ( L , R ) ) ; } }
public class GFG { static void unsort ( int l , int r , int a [ ] , int k ) { if ( k < 1 || l + 1 == r ) return ; k -= 2 ; int mid = ( l + r ) / 2 ; int temp = a [ mid - 1 ] ; a [ mid - 1 ] = a [ mid ] ; a [ mid ] = temp ; unsort ( l , mid , a , k ) ; unsort ( mid , r , a , k ) ; } static void arrayWithKCalls ( int n , int k ) { if ( k % 2 == 0 ) { System . out . print ( " NO ▁ SOLUTION " ) ; return ; } int a [ ] = new int [ n + 1 ] ; a [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) a [ i ] = i + 1 ; k -- ; unsort ( 0 , n , a , k ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 10 , k = 17 ; arrayWithKCalls ( n , k ) ; } }
import java . io . * ; public class GFG { static float mean ( float mid [ ] , int freq [ ] , int n ) { float sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; } static float groupedSD ( float lower_limit [ ] , float upper_limit [ ] , int freq [ ] , int n ) { float mid [ ] = new float [ n ] ; float sum = 0 , freqSum = 0 , sd ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = ( float ) Math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; } public static void main ( String [ ] args ) { float lower_limit [ ] = { 50 , 61 , 71 , 86 , 96 } ; float upper_limit [ ] = { 60 , 70 , 85 , 95 , 100 } ; int freq [ ] = { 9 , 7 , 9 , 12 , 8 } ; int n = lower_limit . length ; System . out . println ( groupedSD ( lower_limit , upper_limit , freq , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { int a = 2 ; int b = 4 ; System . out . println ( gcd ( a , b ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static float rectanglearea ( float a , float b ) { if ( a < 0 || b < 0 ) return - 1 ; return 2 * a * b ; } public static void main ( String args [ ] ) { float a = 10 , b = 8 ; System . out . println ( rectanglearea ( a , b ) ) ; } }
import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . InputMismatchException ; import java . util . PriorityQueue ; import java . util . Random ; import java . util . Scanner ; import java . util . Stack ; import java . util . TreeMap ; import java . util . TreeSet ; public class CF427_1 { static int N ; static int MOD = ( int ) ( 1e9 + 7 ) ; public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { long n = in . nextInt ( ) ; long a = in . nextInt ( ) ; long b = in . nextInt ( ) ; if ( n < a ) { out . println ( " No " ) ; continue ; } if ( a == b ) { if ( n % a == 0 ) { out . println ( " Yes " ) ; } else { out . println ( " No " ) ; } continue ; } long x = b / ( b - a ) ; if ( n > x * a ) { out . println ( " Yes " ) ; continue ; } long low = 1 ; long high = x + 1 ; long ans = 1 ; while ( low <= high ) { long mid = ( low + high ) / 2 ; if ( mid * a < n ) { low = mid + 1 ; } else { ans = mid ; high = mid - 1 ; } } if ( n > ( ans - 1 ) * b && n < ans * a ) { out . println ( " No " ) ; } else { out . println ( " Yes " ) ; } } out . close ( ) ; } }
public class GFG { static int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; } static int countJumps ( int n ) { n = Math . abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n || ( ( getsum ( ans ) - n ) & 1 ) > 0 ) ans ++ ; return ans ; } public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( countJumps ( n ) ) ; } }
public class GFG { static int MAX = 10 ; static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; } public static void main ( String [ ] args ) { int k = 1 ; int [ ] arr1 = { 1 , 2 , 3 , 4 , 5 } ; int [ ] arr2 = { 5 , 3 , 1 , 4 , 2 } ; int n = arr1 . length ; int m = arr2 . length ; int [ ] [ ] [ ] dp = new int [ MAX ] [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int l = 0 ; l < MAX ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; System . out . println ( lcs ( dp , arr1 , n , arr2 , m , k ) ) ; } }
import java . math . BigDecimal ; import java . text . DecimalFormat ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; double N = scan . nextDouble ( ) ; double d = scan . nextDouble ( ) ; double x = scan . nextDouble ( ) ; BigDecimal ans = new BigDecimal ( "0.0" ) ; while ( N > 0.5 ) { BigDecimal adnum = BigDecimal . valueOf ( d + x * ( N - 0.5 ) ) ; ans = ans . add ( adnum ) ; d = ( N + 1.0 ) * d / N + ( 5.0 * x ) / ( 2.0 * N ) ; x = ( 1.0 + ( 2.0 / N ) ) * x ; -- N ; } DecimalFormat format = new DecimalFormat ( " # . # " ) ; format . setMinimumFractionDigits ( 20 ) ; System . out . println ( format . format ( ans ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void reverseorder ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = n ; i >= 2 ; i -- ) if ( prime [ i ] == true ) System . out . print ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { int N = 25 ; System . out . println ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; if ( N == 1 ) System . out . println ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; else reverseorder ( N ) ; } }
import java . io . * ; public class GFG { static void pattern ( int min_stars , int p_height ) { int p_space ; p_space = p_height - 1 ; int i , j , k , n , x ; x = 1 ; for ( i = 0 ; i < p_height ; i ++ ) { for ( j = p_space ; j > i ; j -- ) { System . out . print ( " ▁ " ) ; } for ( k = 0 ; k < min_stars ; k ++ ) System . out . print ( " * " ) ; for ( n = ( p_height + p_height - 2 ) ; n >= x ; n -- ) System . out . print ( " ▁ " ) ; for ( k = 0 ; k < min_stars ; k ++ ) System . out . print ( " * " ) ; min_stars = min_stars + 2 ; x = x + 2 ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int min_stars = 1 ; int p_height = 5 ; pattern ( min_stars , p_height ) ; } }
import java . util . * ; public class B629 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] FfriendPerDay = new int [ 367 ] ; int [ ] MfriendPerDay = new int [ 367 ] ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char c = sc . next ( ) . charAt ( 0 ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; for ( int j = a ; j <= b ; j ++ ) { if ( c == ' M ' ) MfriendPerDay [ j ] ++ ; else FfriendPerDay [ j ] ++ ; if ( MfriendPerDay [ j ] < FfriendPerDay [ j ] ) { if ( MfriendPerDay [ j ] > answer ) answer = MfriendPerDay [ j ] ; } else { if ( FfriendPerDay [ j ] > answer ) answer = FfriendPerDay [ j ] ; } } } System . out . println ( answer * 2 ) ; } }
import java . io . * ; public class GFG { static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; } public static void main ( String [ ] args ) { int x [ ] = { - 1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = x . length ; System . out . println ( distancesum ( x , y , n ) ) ; } }
import java . util . * ; public class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } static int sumFibonacci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculateSum ( l , r - 1 ) ; return sum ; } public static void main ( String args [ ] ) { int k = 3 ; System . out . println ( sumFibonacci ( k ) ) ; } }
import java . lang . Math ; public class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; } public static void main ( String [ ] args ) { int l = 4 , r = 8 ; System . out . println ( calculateSum ( l , r ) ) ; } }
public class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } public static void main ( String [ ] args ) { int l = 4 , r = 8 ; System . out . println ( calculateSum ( l , r ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . * ; import java . util . stream . IntStream ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int q = input . nextInt ( ) ; String s = input . next ( ) ; char str [ ] = s . toCharArray ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = input . nextInt ( ) - 1 ; int r = input . nextInt ( ) - 1 ; char c1 = input . next ( ) . charAt ( 0 ) ; char c2 = input . next ( ) . charAt ( 0 ) ; int start = l ; int end = r ; while ( start <= end ) { if ( str [ start ] == c1 ) { str [ start ] = c2 ; } start ++ ; } } for ( char c : str ) { System . out . print ( c ) ; } System . out . println ( " " ) ; } }
import java . util . * ; public class GFG { static int compareStrings ( String str1 , String str2 ) { int i = 0 ; while ( i < str1 . length ( ) - 1 && str1 . charAt ( i ) == str2 . charAt ( i ) ) i ++ ; if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) return - 1 ; if ( str1 . charAt ( i ) < str2 . charAt ( i ) ) return 1 ; else return 0 ; } static int searchStr ( String [ ] arr , String str , int first , int last ) { if ( first > last ) return - 1 ; int mid = ( last + first ) / 2 ; if ( arr [ mid ] . isEmpty ( ) ) { int left = mid - 1 ; int right = mid + 1 ; while ( true ) { if ( left < right && right > last ) return - 1 ; if ( right <= last && ! arr [ right ] . isEmpty ( ) ) { mid = right ; break ; } if ( left >= right && ! arr [ left ] . isEmpty ( ) ) { mid = left ; break ; } right ++ ; left -- ; } } if ( compareStrings ( str , arr [ mid ] ) == 0 ) return mid ; if ( compareStrings ( str , arr [ mid ] ) < 0 ) return searchStr ( arr , str , mid + 1 , last ) ; return searchStr ( arr , str , first , mid - 1 ) ; } public static void main ( String [ ] args ) { String [ ] arr = { " for " , " " , " " , " " , " geeks " , " ide " , " " , " practice " , " " , " " , " quiz " , " " , " " } ; String str = " quiz " ; int n = arr . length ; System . out . println ( searchStr ( arr , str , 0 , n - 1 ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int ans = getNum ( a , b ) ; System . out . println ( ans ) ; } public static int getNum ( int a , int b ) { int reverseB = 0 ; while ( b > 0 ) { reverseB = reverseB * 10 + b % 10 ; b /= 10 ; } return a + reverseB ; } }
import java . util . * ; import java . math . * ; public class A1133 { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int x1 = sc . nextInt ( ) ; int y1 = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) ; int y2 = sc . nextInt ( ) ; int x3 = sc . nextInt ( ) ; int y3 = sc . nextInt ( ) ; System . out . println ( "3" ) ; System . out . println ( ( x1 + x2 - x3 ) + " ▁ " + ( y1 + y2 - y3 ) ) ; System . out . println ( ( x3 + x2 - x1 ) + " ▁ " + ( y3 + y2 - y1 ) ) ; System . out . println ( ( x1 + x3 - x2 ) + " ▁ " + ( y1 + y3 - y2 ) ) ; } }
import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; String s = sc . next ( ) ; StringBuilder tmp = new StringBuilder ( ) ; int [ ] freq = new int [ 26 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < freq [ i ] ; j ++ ) { tmp . append ( ( char ) ( ' a ' + i ) + " " ) ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != tmp . charAt ( i ) ) { count ++ ; } } pw . println ( count ) ; } sc . close ( ) ; pw . close ( ) ; } }
public class GFG { static long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static long sumMultiples ( long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; } public static void main ( String [ ] args ) { long n = 20 ; System . out . println ( sumMultiples ( n ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t = scan . nextInt ( ) ; while ( t > 0 ) { int n = scan . nextInt ( ) ; int s ; int f ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = scan . nextInt ( ) ; f = scan . nextInt ( ) ; sum += f - s ; } if ( t <= sum ) { System . out . println ( " OK " ) ; } else { System . out . println ( t - sum ) ; } t = scan . nextInt ( ) ; } } }
public class GFG { static int fact ( int num ) { int fact = 1 ; while ( num > 1 ) { fact *= num ; num -= 1 ; } return fact ; } static int catalan ( int n ) { return fact ( 2 * n ) / ( fact ( n ) * fact ( n + 1 ) ) ; } public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int i , k ; for ( k = 0 ; k < n ; k ++ ) { int s = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ k ] ) s += 1 ; } int catalan_leftBST = catalan ( s ) ; int catalan_rightBST = catalan ( n - s - 1 ) ; int totalBST = catalan_rightBST * catalan_leftBST ; System . out . print ( totalBST + " ▁ " ) ; } } }
import javax . naming . NamingEnumeration ; import javax . swing . plaf . IconUIResource ; import javax . swing . plaf . synth . SynthOptionPaneUI ; import java . awt . font . FontRenderContext ; import java . awt . image . ImageProducer ; import java . beans . beancontext . BeanContextServiceRevokedEvent ; import java . lang . reflect . Array ; import java . util . * ; import java . math . BigInteger ; import java . util . spi . LocaleNameProvider ; public class ques { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int j = 0 ; j < n ; j ++ ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; if ( Math . abs ( a - b ) == 1 ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; if ( a < b ) System . out . println ( b - a ) ; else { if ( a % 2 != b % 2 ) System . out . println ( 1 ) ; else System . out . println ( 0 ) ; } } } catch ( Exception e ) { } } }
public class GFG { static int countWays ( int n , int arr [ ] , int len ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 1 ; if ( n == 0 ) return 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int no_ways = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( i - arr [ j ] >= 0 ) { no_ways += count [ i - arr [ j ] ] ; } count [ i ] = no_ways ; } } return count [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 5 } ; int len = arr . length ; int n = 5 ; System . out . print ( countWays ( n , arr , len ) ) ; } }
import java . awt . geom . Line2D ; import java . awt . geom . Point2D ; import java . util . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; private void doit ( ) { while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] data = new int [ 12 ] ; for ( int i = 0 ; i < 12 ; i ++ ) { data [ i ] = sc . nextInt ( ) - sc . nextInt ( ) ; } int sum = 0 ; boolean flg = false ; int ans = - 1 ; for ( int i = 0 ; i < 12 ; i ++ ) { sum += data [ i ] ; if ( sum >= n ) { ans = i + 1 ; flg = true ; break ; } } if ( flg ) { System . out . println ( ans ) ; } else { System . out . println ( " NA " ) ; } } } private void debug ( Object ... o ) { System . out . println ( " debug ▁ = ▁ " + Arrays . deepToString ( o ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . doit ( ) ; } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( a == b && c == b ) { System . out . println ( 0 ) ; } else { int sum = Math . abs ( a - b ) + Math . abs ( b - c ) + Math . abs ( c - a ) ; sum -= 4 ; System . out . println ( Math . max ( sum , 0 ) ) ; } } } }
import java . util . Scanner ; public class CF709A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int a , sum = 0 , count = 0 ; while ( n -- > 0 ) { a = sc . nextInt ( ) ; if ( a <= b ) { sum += a ; } if ( sum > d ) { sum = 0 ; count ++ ; } } System . out . println ( count ) ; sc . close ( ) ; } }
class Main { static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = arr . length ; key = 10 ; System . out . println ( " Index : ▁ " + binarySearch ( arr , 0 , n , key ) ) ; } }
public class GFG { static void equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 3 , 7 , 10 } ; int n = arr . length ; equal_xor_sum ( arr , n ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; public class Main { static boolean [ ] x = new boolean [ 10000001 ] ; public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder out = new StringBuilder ( ) ; StringTokenizer tk = new StringTokenizer ( in . readLine ( ) ) ; int n = Int ( tk . nextToken ( ) ) , m = Int ( tk . nextToken ( ) ) , k = Int ( tk . nextToken ( ) ) ; tk = new StringTokenizer ( in . readLine ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) { x [ Int ( tk . nextToken ( ) ) ] = true ; } int pos = 1 ; while ( k -- > 0 ) { if ( x [ pos ] ) { System . out . println ( pos ) ; return ; } tk = new StringTokenizer ( in . readLine ( ) ) ; int a = Int ( tk . nextToken ( ) ) , b = Int ( tk . nextToken ( ) ) ; pos = ( pos == a ) ? b : pos == b ? a : pos ; } System . out . println ( pos ) ; } static int Int ( String s ) { return Integer . parseInt ( s ) ; } static long Lon ( String s ) { return Long . parseLong ( s ) ; } }
public class GFG { static void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; findPairs ( arr , n ) ; } }
import java . io . * ; public class GFG { private static int minBroadcastRange ( int [ ] houses , int [ ] towers ) { int n = houses . length ; int m = towers . length ; int leftTower = Integer . MIN_VALUE ; int rightTower = towers [ 0 ] ; int j = 0 , k = 0 ; int min_range = 0 ; while ( j < n ) { if ( houses [ j ] < rightTower ) { int left = houses [ j ] - leftTower ; int right = rightTower - houses [ j ] ; int local_max = left < right ? left : right ; if ( local_max > min_range ) min_range = local_max ; j ++ ; } else { leftTower = towers [ k ] ; if ( k < m - 1 ) { k ++ ; rightTower = towers [ k ] ; } else rightTower = Integer . MAX_VALUE ; } } return min_range ; } public static void main ( String [ ] args ) { int [ ] a = { 12 , 13 , 11 , 80 } ; int [ ] b = { 4 , 6 , 15 , 60 } ; int max = minBroadcastRange ( a , b ) ; System . out . println ( max ) ; } }
import java . io . * ; public class GFG { static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; } public static void main ( String [ ] args ) { System . out . println ( getRemainder ( 100 , 7 ) ) ; } }
import java . util . * ; public class tennis { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; StringBuilder sb = new StringBuilder ( ) ; int res = 0 , cnt1 = 0 , cnt2 = 0 ; int n = in . nextInt ( ) , m = in . nextInt ( ) , z = in . nextInt ( ) ; for ( int i = m ; i <= z ; i += m ) { for ( int j = n ; j <= z ; j += n ) { if ( i == j ) res ++ ; } } System . out . println ( res ) ; } }
import java . util . Scanner ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new AOJ0181 ( ) . doIt ( ) ; } class AOJ0181 { int m , n ; int [ ] books ; boolean isPossible ( int width ) { int w = 0 , cnt = 1 ; for ( int i = 0 ; i < n ; i ++ ) { w += books [ i ] ; if ( books [ i ] > width ) return false ; if ( w > width ) { cnt ++ ; w = books [ i ] ; } } return cnt > m ? false : true ; } void doIt ( ) { while ( true ) { m = in . nextInt ( ) ; n = in . nextInt ( ) ; if ( n + m == 0 ) return ; books = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) books [ i ] = in . nextInt ( ) ; int left = 1 ; int right = 1500000 ; while ( right - left != 1 ) { int next = ( left + right ) / 2 ; if ( isPossible ( next ) ) right = next ; else left = next ; } System . out . println ( right ) ; } } } }
import java . math . BigDecimal ; import java . util . PriorityQueue ; import java . util . Scanner ; class Stuff implements Comparable < Stuff > { int v ; int w ; double performance ; Stuff ( int v , int w ) { this . v = v ; this . w = w ; performance = 1.0 * v / w ; } public int compareTo ( Stuff s ) { if ( performance < s . performance ) return 1 ; if ( performance > s . performance ) return - 1 ; return 0 ; } } public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; PriorityQueue < Stuff > que = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int vi = sc . nextInt ( ) ; int wi = sc . nextInt ( ) ; que . add ( new Stuff ( vi , wi ) ) ; } double res = 0 ; while ( w > 0 && ! que . isEmpty ( ) ) { Stuff s = que . poll ( ) ; if ( w >= s . w ) { res += s . v ; w -= s . w ; } else { res += s . performance * w ; w = 0 ; } } System . out . println ( BigDecimal . valueOf ( res ) . toPlainString ( ) ) ; sc . close ( ) ; } }
public class GFG { static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int maxdiff ( int arr [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 3 , 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( maxdiff ( arr , n ) ) ; } }
import java . util . Scanner ; public class CF_1447B_NumbersBox { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int count = scanner . nextInt ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; int [ ] arr = new int [ n * m ] ; int nagiviteTimes = 0 ; int minNum = Integer . MAX_VALUE ; int sumNum = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { arr [ j ] = scanner . nextInt ( ) ; if ( arr [ j ] < 0 ) { arr [ j ] = 0 - arr [ j ] ; nagiviteTimes ++ ; sumNum += arr [ j ] ; if ( minNum > arr [ j ] ) { minNum = arr [ j ] ; } } else { sumNum += arr [ j ] ; if ( minNum > arr [ j ] ) { minNum = arr [ j ] ; } } } if ( nagiviteTimes % 2 == 0 ) { System . out . println ( sumNum ) ; } else { System . out . println ( sumNum - minNum * 2 ) ; } } } }
import java . util . Arrays ; class AP { static void makeAP ( int arr [ ] , int n ) { int initial_term , common_difference ; if ( n == 3 ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else if ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) { initial_term = arr [ 0 ] ; common_difference = arr [ 1 ] - arr [ 0 ] ; } else if ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else { common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initial_term = arr [ 0 ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( initial_term + ( i * common_difference ) + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 7 } ; int n = arr . length ; makeAP ( arr , n ) ; } }
public class GFG { static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( countPairs ( n ) ) ; } }
import java . io . * ; public class GFG { static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( countPairs ( n ) ) ; } }
class Solution { public int longestPalindrome ( String s ) { int [ ] count = new int [ 128 ] ; for ( char c : s . toCharArray ( ) ) count [ c ] ++ ; int ans = 0 ; for ( int v : count ) { ans += v / 2 * 2 ; if ( ans % 2 == 0 && v % 2 == 1 ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String s = " abccccdd " ; int out = sObj . longestPalindrome ( s ) ; System . out . println ( out ) ; } }
public class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } static long findWays ( int n ) { if ( ( n & 1 ) != 0 ) return 0 ; return catalan ( n / 2 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ " + n + " ▁ is ▁ " + findWays ( 6 ) ) ; } }
import java . util . * ; import java . io . * ; public class ex8 { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; sc . nextLine ( ) ; int count = 0 ; int flag = 0 ; String s [ ] = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = " ▁ " + sc . nextLine ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { String res = " " ; count = 0 ; for ( int q = 1 ; q <= 12 ; q ++ ) { if ( s [ i ] . charAt ( q ) == ' X ' ) { res = " ▁ 1x12" ; count ++ ; break ; } } for ( int j = 2 ; j <= 6 ; j ++ ) { flag = 0 ; if ( 12 % j == 0 ) { for ( int k = 1 ; k <= 12 / j ; k ++ ) { flag = 0 ; for ( int p = k ; p <= 12 ; p += 12 / j ) { if ( s [ i ] . charAt ( p ) == ' O ' ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; res += " ▁ " + j + " x " + 12 / j ; break ; } } } } flag = 0 ; for ( int l = 1 ; l <= 12 ; l ++ ) { if ( s [ i ] . charAt ( l ) == ' O ' ) { flag = 1 ; break ; } } if ( flag == 0 ) { res += " ▁ 12x1" ; count ++ ; } System . out . printf ( " % d % s " , count , res ) ; System . out . println ( ) ; } } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; ATwoProblems solver = new ATwoProblems ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class ATwoProblems { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int points = in . nextInt ( ) ; int t = in . nextInt ( ) ; int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int ta = in . nextInt ( ) ; int tb = in . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) { if ( points == a - i * ta + b - j * tb || ( points == 0 ) || points == a - ta * i || points == b - tb * j ) { out . println ( " YES " ) ; return ; } } } out . println ( " NO " ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }
public class GFG { static boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; } public static void main ( String args [ ] ) { int n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . Stack ; public class GFG { static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < > ( ) ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( countNumber ( n ) ) ; } }
public class GFG { public static double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 6 , 5 , 4 } , { 7 , 3 , 9 } } ; System . out . println ( maxAverageOfPath ( cost , 3 ) ) ; } }
import java . io . * ; public class GFG { static int MAX = 1000000 ; static int sieve_Prime [ ] = new int [ MAX + 4 ] ; static int sieve_count [ ] = new int [ MAX + 4 ] ; static void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } } public static void main ( String [ ] args ) { form_sieve ( ) ; int n = 2 ; System . out . println ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; n = 3 ; System . out . println ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n , k , t , u , v , l ; n = sc . nextInt ( ) ; k = sc . nextInt ( ) ; t = sc . nextInt ( ) ; u = sc . nextInt ( ) ; v = sc . nextInt ( ) ; l = sc . nextInt ( ) ; int [ ] d = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) d [ i ] = sc . nextInt ( ) ; d [ n ] = l ; int pos = 0 , c = 0 , nk = 0 ; double tm = 0 ; while ( pos < l ) { if ( pos < d [ c ] ) { if ( nk > 0 ) { nk -- ; int x = Math . min ( l , pos + t * v ) ; tm += ( x - pos ) / ( double ) v ; pos = x ; } else { tm += ( d [ c ] - pos ) / ( double ) u ; pos = d [ c ] ; } } else { if ( d [ c ] == pos ) { int x = Math . min ( l , pos + t * v ) ; tm += ( x - pos ) / ( double ) v ; pos = x ; ++ c ; } else { if ( nk < k ) { c ++ ; nk ++ ; } else { int x = Math . min ( l , d [ c ++ ] + t * v ) ; tm += ( x - pos ) / ( double ) v ; pos = x ; } } } } System . out . println ( tm ) ; } }
public class GFG { static int waysToSplit ( String s ) { int n = s . length ( ) ; int answer = 0 ; int prefix [ ] = new int [ n ] ; int suffix [ ] = new int [ n ] ; int seen [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ? prefix [ i - 1 ] : 0 ) ; if ( seen [ s . charAt ( i ) - ' a ' ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else prefix [ i ] = prev ; seen [ s . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < 26 ; i ++ ) seen [ i ] = 0 ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int prev = suffix [ i ] ; if ( seen [ s . charAt ( i ) - ' a ' ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else suffix [ i - 1 ] = prev ; seen [ s . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { String s = " ababa " ; System . out . println ( waysToSplit ( s ) ) ; } }
import java . math . BigInteger ; public final class p121 { public static void main ( String [ ] args ) { System . out . println ( new p121 ( ) . run ( ) ) ; } private static final int TURNS = 15 ; public String run ( ) { BigInteger [ ] [ ] ways = new BigInteger [ TURNS + 1 ] [ ] ; ways [ 0 ] = new BigInteger [ ] { BigInteger . ONE } ; for ( int i = 1 ; i <= TURNS ; i ++ ) { ways [ i ] = new BigInteger [ i + 1 ] ; for ( int j = 0 ; j <= i ; j ++ ) { BigInteger temp = BigInteger . ZERO ; if ( j < i ) temp = ways [ i - 1 ] [ j ] . multiply ( BigInteger . valueOf ( i ) ) ; if ( j > 0 ) temp = temp . add ( ways [ i - 1 ] [ j - 1 ] ) ; ways [ i ] [ j ] = temp ; } } BigInteger numer = BigInteger . ZERO ; for ( int i = TURNS / 2 + 1 ; i <= TURNS ; i ++ ) numer = numer . add ( ways [ TURNS ] [ i ] ) ; BigInteger denom = Library . factorial ( TURNS + 1 ) ; return denom . divide ( numer ) . toString ( ) ; } }
import java . util . * ; import java . io . * ; import java . util . * ; import java . io . * ; public class Main { static Scanner scanner = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = scanner . nextInt ( ) ; int a [ ] = new int [ n + 1 ] ; int b [ ] = new int [ n + 1 ] ; int num [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] = scanner . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) b [ i ] = scanner . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) num [ b [ i ] ] ++ ; String ss = " " ; int ans = 0 ; boolean st [ ] = new boolean [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == 1 ) { st [ i ] = true ; StringBuilder sb = new StringBuilder ( ) ; int x = b [ i ] ; StringBuilder sss = new StringBuilder ( ) ; sss . append ( i ) ; sb . append ( " ▁ " + sss . reverse ( ) ) ; int s = 1 ; while ( ! st [ x ] && num [ x ] == 1 && x != 0 && a [ x ] != 1 ) { sss = new StringBuilder ( ) ; sss . append ( x ) ; sb . append ( " ▁ " + sss . reverse ( ) ) ; st [ x ] = true ; x = b [ x ] ; s ++ ; } if ( s > ans ) { ans = s ; ss = sb . reverse ( ) . toString ( ) ; } } } System . out . println ( ans ) ; System . out . println ( ss ) ; } }
import java . util . Arrays ; class Test { static int arr1 [ ] = new int [ ] { 1 , 5 , 9 , 10 , 15 , 20 } ; static int arr2 [ ] = new int [ ] { 2 , 3 , 8 , 13 } ; static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 || last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } public static void main ( String [ ] args ) { merge ( arr1 . length , arr2 . length ) ; System . out . print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " ) ; System . out . println ( Arrays . toString ( arr1 ) ) ; System . out . print ( " Second ▁ Array : ▁ " ) ; System . out . println ( Arrays . toString ( arr2 ) ) ; } }
public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } public static void main ( String [ ] args ) { int a = 62 , b = 132 , c = 237 ; System . out . println ( sameRemainder ( a , b , c ) ) ; } }
import java . io . * ; import java . math . * ; import java . util . * ; public class Main { static final int INF = 0x3f3f3f3f ; static final long LNF = 0x3f3f3f3f3f3f3f3fL ; public static void main ( String [ ] args ) throws IOException { initReader ( ) ; long a = nextLong ( ) ; long b = nextLong ( ) ; long c = nextLong ( ) ; long d = nextLong ( ) ; long [ ] an = { a , b , c } ; Arrays . sort ( an ) ; long ans = 0 ; if ( an [ 1 ] - an [ 0 ] < d ) { ans += ( d - an [ 1 ] + an [ 0 ] ) ; } if ( an [ 2 ] - an [ 1 ] < d ) { ans += ( d - an [ 2 ] + an [ 1 ] ) ; } pw . println ( ans ) ; pw . close ( ) ; } static BufferedReader reader ; static StringTokenizer tokenizer ; static PrintWriter pw ; public static void initReader ( ) throws IOException { reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; tokenizer = new StringTokenizer ( " " ) ; pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; } public static boolean hasNext ( ) { try { while ( ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } } catch ( Exception e ) { return false ; } return true ; } public static String next ( ) throws IOException { while ( ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; } public static String nextLine ( ) { try { return reader . readLine ( ) ; } catch ( Exception e ) { return null ; } } public static int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public static long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public static double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public static char nextChar ( ) throws IOException { return next ( ) . charAt ( 0 ) ; } }
public class GFG { static int dp [ ] [ ] [ ] = new int [ 5001 ] [ 5001 ] [ 5 ] ; static int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 || parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) return dp [ n ] [ nextPart ] [ parts ] ; int ans = 0 ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; } static int countWays ( int n ) { for ( int i = 0 ; i < 5001 ; i ++ ) { for ( int j = 0 ; j < 5001 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return countWaysUtil ( n , 4 , 1 ) ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( countWays ( n ) ) ; } }
public class GFG { static int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 16 ; System . out . println ( find_k ( a , b ) ) ; } }
public class GFG { static int N = 101 ; static int mod = ( int ) 1e9 + 7 ; static int exactsum [ ] [ ] [ ] = new int [ N ] [ N ] [ N ] ; static int exactnum [ ] [ ] [ ] = new int [ N ] [ N ] [ N ] ; static int getSum ( int x , int y , int z ) { int ans = 0 ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= x ; ++ i ) { for ( int j = 0 ; j <= y ; ++ j ) { for ( int k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; } if ( j > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; } if ( k > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; ans %= mod ; } } } return ans ; } public static void main ( String [ ] args ) { int x = 1 , y = 1 , z = 1 ; System . out . println ( getSum ( x , y , z ) % mod ) ; } }
public class GFG { static int CHARS = 26 ; static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ; } else { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str = " abcbc " ; if ( isValidString ( str ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String s = sc . next ( ) ; char [ ] ch = s . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { if ( ( i + 1 ) % 2 != 0 ) { if ( ch [ i ] != ' a ' ) ch [ i ] = ' a ' ; else ch [ i ] = ' b ' ; } else if ( ( i + 1 ) % 2 == 0 ) { if ( ch [ i ] != ' z ' ) ch [ i ] = ' z ' ; else ch [ i ] = ' y ' ; } } s = String . valueOf ( ch ) ; System . out . println ( s ) ; } } catch ( Exception e ) { } } }
public class GFG { static int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . length ( ) ; int sizeOfA = A . length ( ) ; int inf = 1000000 ; int [ ] [ ] next = new int [ 26 ] [ sizeOfB ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOfB ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ B . charAt ( i ) - ' a ' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( i < sizeOfA ) { if ( pos == 0 && next [ A . charAt ( i ) - ' a ' ] [ pos ] == inf ) { numberOfSubsequences = - 1 ; break ; } else if ( pos < sizeOfB && next [ A . charAt ( i ) - ' a ' ] [ pos ] < inf ) { int nextIndex = next [ A . charAt ( i ) - ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; } public static void main ( String [ ] args ) { String A = " aacbe " ; String B = " aceab " ; System . out . print ( findMinimumSubsequences ( A , B ) ) ; } }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; public class Algorithm { static int ans = 0 ; public static void main ( String [ ] rgs ) throws IOException { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder stringBuilder = new StringBuilder ( ) ; int t = Integer . parseInt ( bufferedReader . readLine ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { String [ ] a = bufferedReader . readLine ( ) . split ( " ▁ " ) ; int row = Integer . parseInt ( a [ 0 ] ) ; int col = Integer . parseInt ( a [ 1 ] ) ; StringBuilder ans = new StringBuilder ( ) ; int [ ] ansarray = new int [ row * col ] ; int p = 0 ; int [ ] rowarray = { 0 , 0 , row - 1 , row - 1 } ; int [ ] colarray = { 0 , col - 1 , 0 , col - 1 } ; for ( int j = 0 ; j < row ; j ++ ) { for ( int k = 0 ; k < col ; k ++ ) { int dis = 0 ; for ( int l = 0 ; l < 4 ; l ++ ) { dis = Math . max ( dis , Math . abs ( rowarray [ l ] - j ) + Math . abs ( colarray [ l ] - k ) ) ; } ansarray [ p ++ ] = dis ; } } Arrays . sort ( ansarray ) ; for ( int j = 0 ; j < ansarray . length ; j ++ ) { ans . append ( ansarray [ j ] ) . append ( " ▁ " ) ; } stringBuilder . append ( ans ) . append ( " \n " ) ; } System . out . println ( stringBuilder ) ; } }
import java . util . * ; public class GFG { static void FindRank ( int arr [ ] , int length ) { System . out . print ( "1" + " ▁ " ) ; for ( int i = 1 ; i < arr . length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } System . out . print ( rank + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 88 , 14 , 69 , 30 , 29 , 89 } ; int len = arr . length ; FindRank ( arr , len ) ; } }
import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; Integer [ ] b = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( b , Comparator . reverseOrder ( ) ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i != 0 ) h -= b [ i - 1 ] ; int cnt = 0 ; if ( h > 0 ) { cnt = ( h + a [ n - 1 ] - 1 ) / a [ n - 1 ] ; } ans = Math . min ( ans , cnt + i ) ; } System . out . println ( ans ) ; } }
public class Digits { static long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; } public static void main ( String [ ] args ) { int n = 15 ; int k = 4 ; System . out . println ( firstkdigits ( n , k ) ) ; } }
import java . io . * ; public class Main { public static void main ( String [ ] args ) { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String line ; while ( ( line = r . readLine ( ) ) != null ) { int m , n ; m = Integer . parseInt ( line . split ( " ▁ " ) [ 0 ] ) ; n = Integer . parseInt ( line . split ( " ▁ " ) [ 1 ] ) ; if ( m < n ) { int t = m ; m = n ; n = t ; } while ( n != 0 ) { int t = n ; n = m % n ; m = t ; } System . out . println ( m ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int [ ] a = new int [ 26 ] ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { a [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { sum += a [ i ] % 2 ; } System . out . println ( sum / 2 ) ; } }
import java . io . * ; public class GFG { static int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . pow ( 10 , len ) - num ; return comp ; } public static void main ( String [ ] args ) { System . out . println ( complement ( 25 ) ) ; System . out . println ( complement ( 456 ) ) ; } }
public class GFG { static int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return Integer . bitCount ( x ^ n ) ; } public static void main ( String [ ] args ) { int n = 17 ; System . out . println ( countUnsetBits ( n ) ) ; } }
import java . util . Arrays ; public class GFG { static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int totalWays ( int N , int M , int X ) { int dp [ ] [ ] = new int [ N + 1 ] [ 2 ] ; if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } public static void main ( String [ ] args ) { int N = 4 , M = 3 , X = 2 ; System . out . println ( totalWays ( N , M , X ) ) ; } }
import java . io . * ; import java . math . * ; public class GFG { int getMinNum ( int a , int b , int c ) { if ( c < a || c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; } public static void main ( String args [ ] ) { int a = 2 ; int b = 4 ; int c = 4 ; GFG g = new GFG ( ) ; System . out . println ( g . getMinNum ( a , b , c ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] s = sc . next ( ) . toCharArray ( ) ; int x = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' I ' ) { x ++ ; } else { x -- ; } max = Math . max ( max , x ) ; } System . out . println ( max ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int ans = 0 ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; ArrayList < State > al = new ArrayList < State > ( ) ; if ( n == 0 && m == 0 ) break ; for ( int i = 0 ; i < n ; i ++ ) al . add ( new State ( sc . nextInt ( ) , sc . nextInt ( ) ) ) ; Collections . sort ( al ) ; while ( ! al . isEmpty ( ) ) { State st = al . remove ( 0 ) ; m -= st . d ; if ( m <= 0 ) { ans -= m * st . p ; break ; } } while ( ! al . isEmpty ( ) ) { State st = al . remove ( 0 ) ; ans += st . d * st . p ; } System . out . println ( ans ) ; } } } class State implements Comparable < State > { int d , p ; public State ( int d , int p ) { this . d = d ; this . p = p ; } public int compareTo ( State st ) { return st . p - this . p ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; PriorityQueue < Integer > front = new PriorityQueue < > ( ) ; PriorityQueue < Integer > back = new PriorityQueue < > ( ) ; int [ ] arr = new int [ n ] ; long frontSum = 0 ; long backSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; frontSum += x ; front . add ( x ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; backSum += x ; back . add ( - x ) ; } long [ ] values = new long [ n + 1 ] ; values [ 0 ] = frontSum ; values [ n ] = - backSum ; for ( int i = 0 ; i < n ; i ++ ) { frontSum += arr [ i ] ; front . add ( arr [ i ] ) ; frontSum -= front . poll ( ) ; values [ i + 1 ] += frontSum ; backSum += arr [ n - i - 1 ] ; back . add ( - arr [ n - i - 1 ] ) ; backSum += back . poll ( ) ; values [ n - i - 1 ] -= backSum ; } long max = Long . MIN_VALUE ; for ( int i = 0 ; i <= n ; i ++ ) { max = Math . max ( max , values [ i ] ) ; } System . out . println ( max ) ; } }
public class GFG { static int arr [ ] = { 1 , 5 , 6 } ; static int countWays ( int N ) { int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; } public static void main ( String [ ] args ) { int N = 7 ; System . out . println ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " + countWays ( N ) ) ; } }
import java . io . * ; public class GFG { static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
public class GFG { static void countFreq ( int a [ ] , int n ) { int hm [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { System . out . println ( a [ i ] + " - > " + cumul ) ; } hm [ a [ i ] ] = 0 ; } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 , 4 , 2 , 1 } ; int n = a . length ; countFreq ( a , n ) ; } }
import java . io . * ; public class GFG { static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { System . out . println ( " ( " + possibleA + " , ▁ " + possibleB + " , ▁ " + possibleC + " ) " + " ▁ is ▁ one ▁ such ▁ possible " + " ▁ triplet ▁ between ▁ " + L + " ▁ and ▁ " + R ) ; } else { System . out . println ( " No ▁ Such ▁ Triplet " + " ▁ exists ▁ between ▁ " + L + " ▁ and ▁ " + R ) ; } } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }
public class GFG { static char [ ] alphabets = " abcdefghijklmnopqrstuvwxyz " . toCharArray ( ) ; static String conversion ( String charSet , char [ ] str1 ) { String s2 = " " ; for ( char i : str1 ) s2 += alphabets [ charSet . indexOf ( i ) ] ; return s2 ; } public static void main ( String [ ] args ) { String charSet = " qwertyuiopasdfghjklzxcvbnm " ; String str1 = " egrt " ; System . out . print ( conversion ( charSet , str1 . toCharArray ( ) ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static TreeSet < Integer > set = new TreeSet < Integer > ( ) ; public static void generateNumber ( int count , int a [ ] , int n , int num , int k ) { if ( count == k ) { set . add ( num ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) generateNumber ( count + 1 , a , n , num + a [ i ] , k ) ; } public static void printDistinctIntegers ( int k , int a [ ] , int n ) { generateNumber ( 0 , a , n , 0 , k ) ; System . out . print ( " The " + " ▁ " + set . size ( ) + " ▁ " + " distinct ▁ integers ▁ are : ▁ " ) ; System . out . println ( ) ; Iterator < Integer > i = set . iterator ( ) ; while ( i . hasNext ( ) ) { System . out . print ( i . next ( ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 8 , 17 , 5 } ; int n = arr . length ; int k = 2 ; printDistinctIntegers ( k , arr , n ) ; } }
public class GFG { static int product ( int x ) { int prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; } static int findNumber ( int l , int r ) { String b = Integer . toString ( r ) ; int ans = r ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { if ( b . charAt ( i ) == '0' ) continue ; char [ ] curr = b . toCharArray ( ) ; curr [ i ] = ( char ) ( ( ( int ) ( curr [ i ] - ( int ) '0' ) - 1 ) + ( int ) ( '0' ) ) ; for ( int j = i + 1 ; j < curr . length ; j ++ ) curr [ j ] = '9' ; int num = 0 ; for ( int j = 0 ; j < curr . length ; j ++ ) num = num * 10 + ( curr [ j ] - '0' ) ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } public static void main ( String [ ] args ) { int l = 1 , r = 10 ; System . out . println ( findNumber ( l , r ) ) ; l = 51 ; r = 62 ; System . out . println ( findNumber ( l , r ) ) ; } }
public class GFG { static int MAX = 100005 ; static boolean [ ] isPrime = new boolean [ MAX ] ; static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }
public class GFG { static int MAX = 25 ; static int getMinSum ( int arr [ ] , int n ) { int bits_count [ ] = new int [ MAX ] , max_bit = 0 , sum = 0 , ans = 0 ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] , f = 0 ; while ( e > 0 ) { int rem = e % 2 ; e = e / 2 ; if ( rem == 1 ) { bits_count [ f ] += rem ; } f ++ ; } max_bit = Math . max ( max_bit , f ) ; } for ( int d = 0 ; d < max_bit ; d ++ ) { int temp = ( int ) Math . pow ( 2 , d ) ; if ( bits_count [ d ] > n / 2 ) ans = ans + temp ; } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 7 , 11 , 15 } ; int n = arr . length ; System . out . println ( getMinSum ( arr , n ) ) ; } }
import java . io . * ; import java . util . StringTokenizer ; public class _70B implements Runnable { private BufferedReader in ; private Object solve ( ) throws IOException { int n = nextInt ( ) , c = 0 , q = 0 ; String s = nextToken ( ) ; for ( int i = 0 , l = s . length ( ) , p = 0 ; i < l ; i ++ ) { char h = s . charAt ( i ) ; p ++ ; if ( h == ' . ' || h == ' ! ' || h == ' ? ' ) { if ( p > n ) { return " Impossible " ; } if ( q == 0 ) { q = p ; } else if ( q + 1 + p <= n ) { q += 1 + p ; } else { q = p ; c ++ ; } p = 0 ; i ++ ; } } if ( q > 0 ) { c ++ ; } return c ; } public static void main ( String [ ] args ) { new _70B ( ) . run ( ) ; } @ Override public void run ( ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintStream out = System . out ; out . print ( solve ( ) ) ; in . close ( ) ; } catch ( IOException e ) { System . exit ( 0 ) ; } } private String nextToken ( ) throws IOException { return in . readLine ( ) ; } private int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } }
import java . io . * ; import java . util . * ; import static java . lang . Integer . parseInt ; public class MikeandShortcuts { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder out = new StringBuilder ( ) ; StringTokenizer tk ; int n = parseInt ( in . readLine ( ) ) ; int [ ] a = new int [ n ] ; tk = new StringTokenizer ( in . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = parseInt ( tk . nextToken ( ) ) - 1 ; List < Integer > [ ] g = new List [ n ] ; for ( int i = 0 ; i < n ; i ++ ) g [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] != i ) g [ i ] . add ( a [ i ] ) ; g [ i ] . add ( i + 1 ) ; g [ i + 1 ] . add ( i ) ; } if ( a [ n - 1 ] != n - 1 ) g [ n - 1 ] . add ( a [ n - 1 ] ) ; int [ ] dist = new int [ n ] ; Arrays . fill ( dist , - 1 ) ; dist [ 0 ] = 0 ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int u = q . remove ( ) ; for ( int v : g [ u ] ) { if ( dist [ v ] == - 1 ) { q . add ( v ) ; dist [ v ] = dist [ u ] + 1 ; } } } out . append ( dist [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) out . append ( " ▁ " ) . append ( dist [ i ] ) ; System . out . println ( out ) ; } }
import java . util . * ; import java . io . * ; public class strange_birth_day { void helpBirthDayBoy ( int n [ ] , int m [ ] ) { Arrays . sort ( n ) ; long ans = 0 ; int j = 0 ; for ( int i = n . length - 1 ; i >= 0 ; i -- ) { int k = n [ i ] ; if ( k < m . length ) { if ( m [ k ] > m [ j ] ) { ans += m [ j ] ; j ++ ; } else { ans += m [ k ] ; } } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { FastReader in = new FastReader ( ) ; int test = in . nextInt ( ) ; while ( test -- > 0 ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int arr [ ] = new int [ n ] ; int marr [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . nextInt ( ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { marr [ i ] = in . nextInt ( ) ; } strange_birth_day strange = new strange_birth_day ( ) ; strange . helpBirthDayBoy ( arr , marr ) ; } } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) . trim ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . io . * ; public class GFG { static int findMaximumNum ( int arr [ ] , int n ) { for ( int i = n ; i >= 1 ; i -- ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i <= arr [ j ] ) count ++ ; if ( count >= i ) return i ; } return 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 8 , 10 } ; int n = arr . length ; System . out . println ( findMaximumNum ( arr , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( br . readLine ( ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; StringBuilder temp ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] splitCommand = br . readLine ( ) . split ( " ▁ " ) ; int a = Integer . parseInt ( splitCommand [ 1 ] ) ; int b = Integer . parseInt ( splitCommand [ 2 ] ) ; if ( splitCommand [ 0 ] . startsWith ( " p " ) ) { System . out . println ( sb . substring ( a , b + 1 ) ) ; } else if ( splitCommand [ 0 ] . startsWith ( " rev " ) ) { temp = new StringBuilder ( sb . substring ( a , b + 1 ) ) ; temp . reverse ( ) ; sb . replace ( a , b + 1 , new String ( temp ) ) ; } else { String p = splitCommand [ 3 ] ; sb . replace ( a , b + 1 , p ) ; } } } }
public class GFG { public static int solve ( int [ ] A , int n ) { int [ ] [ ] dp = new int [ 2000 ] [ 2000 ] ; int flag = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += A [ i ] ; for ( int i = - sum ; i <= sum ; i ++ ) { try { dp [ 0 ] [ i ] = Integer . MAX_VALUE ; } catch ( Exception e ) { } } dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { try { dp [ flag ] [ j ] = Integer . MAX_VALUE ; if ( j - A [ i - 1 ] <= sum && j - A [ i - 1 ] >= - sum ) dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] ; if ( j + A [ i - 1 ] <= sum && j + A [ i - 1 ] >= - sum && dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != Integer . MAX_VALUE ) dp [ flag ] [ j ] = Math . min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) ; } catch ( Exception e ) { } } flag = flag ^ 1 ; } for ( int i = 0 ; i <= sum ; i ++ ) { if ( dp [ flag ^ 1 ] [ i ] != Integer . MAX_VALUE ) return dp [ flag ^ 1 ] [ i ] ; } return n - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = arr . length ; System . out . println ( solve ( arr , n ) ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { final double eps = 1e-10 ; Scanner scan = new Scanner ( System . in ) ; double x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ; while ( scan . hasNextDouble ( ) ) { x1 = scan . nextDouble ( ) ; y1 = scan . nextDouble ( ) ; x2 = scan . nextDouble ( ) ; y2 = scan . nextDouble ( ) ; x3 = scan . nextDouble ( ) ; y3 = scan . nextDouble ( ) ; x4 = scan . nextDouble ( ) ; y4 = scan . nextDouble ( ) ; double vax = x2 - x1 , vay = y2 - y1 ; double vbx = x4 - x3 , vby = y4 - y3 ; if ( Math . abs ( vax * vbx + vay * vby ) < eps ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new AOJ0221 ( ) . doIt ( ) ; } class AOJ0221 { boolean [ ] person ; int m , n ; void doIt ( ) { while ( true ) { m = in . nextInt ( ) ; n = in . nextInt ( ) ; if ( m + n == 0 ) break ; person = new boolean [ m ] ; int user = 0 ; int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { String input = in . next ( ) ; String talk = getTalk ( i ) ; if ( input . equals ( talk ) == false && m - cnt > 1 ) { person [ user ] = true ; cnt ++ ; } user = getUser ( user ) ; } int i ; for ( i = 0 ; i < m ; i ++ ) if ( person [ i ] == false ) { System . out . print ( i + 1 ) ; break ; } for ( i = i + 1 ; i < m ; i ++ ) if ( person [ i ] == false ) System . out . print ( " ▁ " + ( i + 1 ) ) ; System . out . println ( ) ; } } String getTalk ( int num ) { return num % 15 == 0 ? " FizzBuzz " : num % 3 == 0 ? " Fizz " : num % 5 == 0 ? " Buzz " : Integer . toString ( num ) ; } int getUser ( int currentUser ) { for ( int i = 1 ; i <= m ; i ++ ) if ( ! person [ ( currentUser + i ) % m ] ) return ( currentUser + i ) % m ; return - 1 ; } } }
public class GFG { static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } static int nCr ( int n , int r ) { return l [ n ] [ r ] ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 8 ; int r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int [ ] array = new int [ 101 ] ; for ( int i = a ; i < b ; i ++ ) { array [ i ] ++ ; } for ( int i = c ; i < d ; i ++ ) { array [ i ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 101 ; i ++ ) { if ( array [ i ] == 2 ) { ans ++ ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . floor ( a [ i ] / mul ) ; System . out . print ( x + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 5 , 100 , 8 } ; int b [ ] = { 2 , 3 } ; int n = a . length ; int m = b . length ; calculate ( a , b , n , m ) ; } }
import java . util . Scanner ; public class problemB { public static void quickSort ( int a [ ] , int d , int c ) { int i = d ; int j = c ; int mid = a [ ( d + c ) / 2 ] ; while ( i <= j ) { while ( a [ i ] < mid ) i ++ ; while ( a [ j ] > mid ) j -- ; if ( i <= j ) { int tg = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tg ; i ++ ; j -- ; } } if ( d < j ) quickSort ( a , d , j ) ; if ( i < c ) quickSort ( a , i , c ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a [ ] = new int [ n + 5 ] ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] = sc . nextInt ( ) ; int b [ ] = new int [ n + 5 ] ; for ( int i = 1 ; i < n ; i ++ ) b [ i ] = sc . nextInt ( ) ; int c [ ] = new int [ n + 5 ] ; for ( int i = 1 ; i <= n - 2 ; i ++ ) c [ i ] = sc . nextInt ( ) ; quickSort ( a , 1 , n ) ; quickSort ( b , 1 , n - 1 ) ; quickSort ( c , 1 , n - 2 ) ; int resA = a [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { resA = a [ i ] ; break ; } } System . out . println ( resA ) ; int resB = b [ n - 1 ] ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( b [ i ] != c [ i ] ) { resB = b [ i ] ; break ; } } System . out . println ( resB ) ; sc . close ( ) ; } }
import java . lang . * ; import java . util . * ; public class TEST { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; while ( T -- > 0 ) { int n = sc . nextInt ( ) ; char c [ ] = sc . next ( ) . toCharArray ( ) ; int del = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( c [ i ] == ' > ' || c [ n - 1 - i ] == ' < ' ) { System . out . println ( i ) ; break ; } } } } }
import java . util . * ; import java . util . ArrayList ; public class codforce { public static void main ( String [ ] args ) { Scanner str = new Scanner ( System . in ) ; int n = str . nextInt ( ) ; String s = " " ; while ( n > 0 ) { int x = n % 2 ; n /= 2 ; s += x + " " ; } int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { ans ++ ; } } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class B148 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; double VP = in . nextInt ( ) ; double VD = in . nextInt ( ) ; double T = in . nextInt ( ) ; double F = in . nextInt ( ) ; double C = in . nextInt ( ) ; if ( VD <= VP ) { System . out . println ( "0" ) ; return ; } int answer = 0 ; double start = T ; while ( true ) { double x = start * VP / ( VD - VP ) ; if ( ( start + x ) * VP >= C ) { break ; } start += 2 * x + F ; answer ++ ; } System . out . println ( answer ) ; } }
import java . io . IOException ; import java . time . LocalTime ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; String [ ] s = sc . next ( ) . split ( " : " ) ; String [ ] t = sc . next ( ) . split ( " : " ) ; LocalTime x = LocalTime . of ( Integer . parseInt ( s [ 0 ] ) , Integer . parseInt ( s [ 1 ] ) ) ; LocalTime y = LocalTime . of ( Integer . parseInt ( t [ 0 ] ) , Integer . parseInt ( t [ 1 ] ) ) ; System . out . println ( x . minusHours ( y . getHour ( ) ) . minusMinutes ( y . getMinute ( ) ) ) ; } }
public class GFG { static int longestAlternatingSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] * a [ i - 1 ] < 0 ) { cnt ++ ; longest = Math . max ( longest , cnt ) ; } else cnt = 1 ; } return longest ; } public static void main ( String [ ] args ) { int a [ ] = { - 5 , - 1 , - 1 , 2 , - 2 , - 3 } ; int n = a . length ; System . out . println ( longestAlternatingSubarray ( a , n ) ) ; } }
import java . util . * ; public class GFG { static void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = ( int ) Math . pow ( a , 2 ) ; int sqb = ( int ) Math . pow ( b , 2 ) ; int sqc = ( int ) Math . pow ( c , 2 ) ; if ( sqa == sqa + sqb || sqb == sqa + sqc || sqc == sqa + sqb ) { System . out . print ( " Right - angled ▁ Triangle " ) ; } else if ( sqa > sqc + sqb || sqb > sqa + sqc || sqc > sqa + sqb ) { System . out . print ( " Obtuse - angled ▁ Triangle " ) ; } else { System . out . print ( " Acute - angled ▁ Triangle " ) ; } } public static void main ( String [ ] args ) { int a , b , c ; a = 2 ; b = 2 ; c = 2 ; checkTypeOfTriangle ( a , b , c ) ; } }
public class GFG { static int max = 100 ; static void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case ' G ' : cntG ++ ; result += C ; break ; case ' F ' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; } public static void main ( String args [ ] ) { String s = " GFGFG " ; int n = s . length ( ) ; countSubsequence ( s , n ) ; } }
import java . util . Scanner ; import java . util . stream . IntStream ; public class Main { private static final int MAX = 100 ; public static void main ( String [ ] args ) { try ( Scanner scanner = new Scanner ( System . in ) ) { int n = scanner . nextInt ( ) ; int [ ] x = new int [ n ] , y = new int [ n ] , h = new int [ n ] ; IntStream . range ( 0 , n ) . forEach ( i -> { x [ i ] = scanner . nextInt ( ) ; y [ i ] = scanner . nextInt ( ) ; h [ i ] = scanner . nextInt ( ) ; } ) ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = 0 ; j <= MAX ; j ++ ) { int ch = check ( n , x , y , h , i , j ) ; if ( ch > 0 ) { System . out . println ( i + " ▁ " + j + " ▁ " + ch ) ; } } } } } private static int check ( int n , int [ ] x , int [ ] y , int [ ] h , int cx , int cy ) { int ch = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h [ i ] > 0 ) { ch = Math . abs ( x [ i ] - cx ) + Math . abs ( y [ i ] - cy ) + h [ i ] ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( h [ i ] != Math . max ( ch - Math . abs ( x [ i ] - cx ) - Math . abs ( y [ i ] - cy ) , 0 ) ) { return - 1 ; } } return ch ; } }
public class GFG { static int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . cbrt ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; } public static void main ( String [ ] args ) { int n = 150 ; System . out . print ( countSteps ( n ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { class AOJ_0138 implements Comparable < AOJ_0138 > { Integer num ; Double time ; public int compareTo ( AOJ_0138 o ) { return time . compareTo ( o . time ) ; } } void doIt ( ) { int m = 0 ; Scanner sc = new Scanner ( System . in ) ; AOJ_0138 [ ] data = new AOJ_0138 [ 8 ] ; AOJ_0138 [ ] sub = new AOJ_0138 [ 18 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int k = 0 ; k < 8 ; k ++ ) { data [ k ] = new AOJ_0138 ( ) ; data [ k ] . num = sc . nextInt ( ) ; data [ k ] . time = sc . nextDouble ( ) ; } Arrays . sort ( data ) ; System . out . printf ( " % d ▁ % .2f \n " , data [ 0 ] . num , data [ 0 ] . time ) ; System . out . printf ( " % d ▁ % .2f \n " , data [ 1 ] . num , data [ 1 ] . time ) ; for ( int k = 2 ; k < 8 ; k ++ , m ++ ) { sub [ m ] = data [ k ] ; } } Arrays . sort ( sub ) ; System . out . printf ( " % d ▁ % .2f \n " , sub [ 0 ] . num , sub [ 0 ] . time ) ; System . out . printf ( " % d ▁ % .2f \n " , sub [ 1 ] . num , sub [ 1 ] . time ) ; } public static void main ( String [ ] args ) { new Main ( ) . doIt ( ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String args [ ] ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long arr [ ] = new long [ n ] ; long mx = Long . MIN_VALUE , mn = Long . MAX_VALUE , mxCount = 0 , mnCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; mx = Math . max ( arr [ i ] , mx ) ; mn = Math . min ( arr [ i ] , mn ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mx ) mxCount ++ ; if ( arr [ i ] == mn ) mnCount ++ ; } if ( mx != mn ) System . out . println ( mx - mn + " ▁ " + mxCount * mnCount ) ; else System . out . println ( mx - mn + " ▁ " + mxCount * ( mxCount - 1 ) / 2 ) ; } }
public class GFG { static int find_count ( int [ ] arr ) { int ans = 0 ; for ( int i : arr ) { int x = Integer . bitCount ( i ) ; if ( i % x == 0 ) ans += 1 ; } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; System . out . print ( find_count ( arr ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = sc . nextInt ( ) ; System . out . println ( check ( A ) ? " YES " : " NO " ) ; sc . close ( ) ; } static boolean check ( int [ ] A ) { int N = A . length ; long sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( sum % ( ( long ) N * ( N + 1 ) / 2 ) != 0 ) return false ; int op = ( int ) ( sum / ( ( long ) N * ( N + 1 ) / 2 ) ) ; for ( int i = 0 ; i < N ; i ++ ) { int diff = A [ ( i + 1 ) % N ] - A [ i ] ; if ( ( diff > op ) ) return false ; if ( ( op - diff ) % N != 0 ) return false ; } return true ; } }
import java . io . * ; public class GFG { static int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; } public static void main ( String [ ] args ) { int N = 390 ; System . out . println ( maxProd ( N ) ) ; } }
import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int n = sc . nextInt ( ) ; static String sugoroku = " " ; public static void main ( String [ ] args ) { inputSugoroku ( ) ; solveSugoroku ( ) ; } private static void solveSugoroku ( ) { int dice = 0 ; String [ ] safes = sugoroku . split ( "0" ) ; for ( int i = 0 ; i < safes . length ; i ++ ) { dice = Math . max ( dice , safes [ i ] . length ( ) ) ; } System . out . println ( dice + 1 ) ; } private static void inputSugoroku ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sb . append ( sc . nextInt ( ) ) ; } sugoroku = sb . toString ( ) ; } }
import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Scanner ; public class practice2 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; long [ ] x = new long [ n ] ; long [ ] y = new long [ n ] ; int t1 = 0 , t2 = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { long x1 = sc . nextInt ( ) , y1 = sc . nextInt ( ) ; if ( x1 == 0 ) y [ t2 ++ ] = y1 * y1 ; else x [ t1 ++ ] = x1 * x1 ; } Arrays . sort ( x ) ; Arrays . sort ( y ) ; double sum = 0 ; for ( int i = n - 1 ; i > - 1 ; i -- ) { sum += Math . sqrt ( x [ i ] + y [ i ] ) ; } System . out . println ( sum ) ; } } }
public class GFG { static long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( countNonDecreasing ( n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class GFG { static int reduceString ( String s , int l ) { int count = 1 , steps = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) count += 1 ; else { steps += ( count / 2 ) ; count = 1 ; } } steps += count / 2 ; return steps ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int l = s . length ( ) ; System . out . println ( reduceString ( s , l ) ) ; } }
import java . util . * ; public class Main { static public Scanner read ; static int a , b , n ; public static void main ( String [ ] args ) { read = new Scanner ( System . in ) ; a = read . nextInt ( ) ; b = read . nextInt ( ) ; n = a + b ; if ( b >= a ) System . out . print ( " Impossible " ) ; else { String ans = " " ; int honest = getHonest ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ans += q ( honest , i ) ? '1' : '0' ; } System . out . print ( " ! ▁ " + ans ) ; } } static int getHonest ( ) { int dis = b + 1 ; LinkedList < Integer > list = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( list . isEmpty ( ) ) { list . push ( i ) ; } else { if ( q ( list . peek ( ) , i ) ) { list . push ( i ) ; } else { list . pop ( ) ; dis -- ; } } if ( list . size ( ) >= dis ) return list . pop ( ) ; } return - 1 ; } static boolean q ( int a , int b ) { System . out . println ( " ? ▁ " + a + " ▁ " + b ) ; return read . next ( ) . equals ( " Y " ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int x = in . nextInt ( ) , y = in . nextInt ( ) , a = in . nextInt ( ) , b = in . nextInt ( ) ; ArrayList < String > res = new ArrayList < > ( ) ; for ( int i = a ; i <= x ; i ++ ) { for ( int j = b ; j <= y ; j ++ ) { if ( i <= j ) continue ; res . add ( i + " ▁ " + j ) ; } } pw . println ( res . size ( ) ) ; for ( String str : res ) pw . println ( str ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
public class GFG { static long mod = 1000000007L ; static long mult ( long a , long b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; } static long calculate_factors ( long n ) { long ans , cnt ; cnt = 0 ; ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( n > 2 ) { ans = mult ( ans , ( 2 ) ) ; } return ans % mod ; } public static void main ( String [ ] args ) { long n = 193748576239475639L ; mod = 17 ; System . out . print ( calculate_factors ( n ) + " \n " ) ; } }
import java . util . Scanner ; public class cf32A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; String s = input . next ( ) ; String str = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' . ' ) str += 0 ; else { if ( s . charAt ( i ) == ' - ' && s . charAt ( i + 1 ) == ' . ' ) str += 1 ; else str += 2 ; i ++ ; } } System . out . println ( str ) ; } }
public class GFG { static int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 5 , 3 } ; int n = arr . length ; System . out . print ( maxAbsDiff ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { int a , b , c , N ; Scanner sc = new Scanner ( System . in ) ; while ( true ) { a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; c = sc . nextInt ( ) ; if ( a == 0 && b == 0 && c == 0 ) { System . exit ( 0 ) ; } N = sc . nextInt ( ) ; int [ ] checking = new int [ a + b + c ] ; LinkedList < Integer > temp = new LinkedList < Integer > ( ) ; Arrays . fill ( checking , 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { for ( int i = 0 ; i < N ; i ++ ) { if ( j == 0 ) { int a1 , b1 , c1 , check ; a1 = sc . nextInt ( ) ; b1 = sc . nextInt ( ) ; c1 = sc . nextInt ( ) ; check = sc . nextInt ( ) ; if ( check == 1 ) { checking [ a1 - 1 ] = 1 ; checking [ b1 - 1 ] = 1 ; checking [ c1 - 1 ] = 1 ; } else { temp . add ( a1 ) ; temp . add ( b1 ) ; temp . add ( c1 ) ; } } else { if ( temp . isEmpty ( ) ) { break ; } int a2 = temp . pop ( ) ; int b2 = temp . pop ( ) ; int c2 = temp . pop ( ) ; if ( checking [ a2 - 1 ] + checking [ b2 - 1 ] + checking [ c2 - 1 ] == 2 ) { if ( checking [ a2 - 1 ] != 1 ) { checking [ a2 - 1 ] = 3 ; } else if ( checking [ b2 - 1 ] != 1 ) { checking [ b2 - 1 ] = 3 ; } else { checking [ c2 - 1 ] = 3 ; } } } } } for ( int contents : checking ) { int result ; if ( contents == 3 ) { result = 0 ; } else if ( contents == 0 ) { result = 2 ; } else { result = 1 ; } System . out . println ( result ) ; } } } }
import java . util . * ; public class GFG { public static int minRemove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; else countA . put ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; else countB . put ( b [ i ] , 1 ) ; } int res = 0 ; Set < Integer > s = countA . keySet ( ) ; for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ; return res ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 } ; int b [ ] = { 2 , 3 , 4 , 5 , 8 } ; int n = a . length ; int m = b . length ; System . out . println ( minRemove ( a , b , n , m ) ) ; } }
import java . util . Collections ; import java . util . Vector ; public class GFG { static int M = 20 ; static int [ ] [ ] [ ] [ ] dp = new int [ M ] [ M ] [ M ] [ 2 ] ; static int count ( int pos , int firstD , int lastD , int tight , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( firstD == lastD ) return 1 ; return 0 ; } if ( dp [ pos ] [ firstD ] [ lastD ] [ tight ] != - 1 ) return dp [ pos ] [ firstD ] [ lastD ] [ tight ] ; int ans = 0 ; int limit = ( tight == 1 ? 9 : num . elementAt ( pos ) ) ; for ( int dig = 0 ; dig <= limit ; dig ++ ) { int currFirst = firstD ; if ( pos == 0 ) currFirst = dig ; if ( currFirst == 0 && dig != 0 ) currFirst = dig ; int currTight = tight ; if ( dig < num . elementAt ( pos ) ) currTight = 1 ; ans += count ( pos + 1 , currFirst , dig , currTight , num ) ; } return dp [ pos ] [ firstD ] [ lastD ] [ tight ] = ans ; } static int solve ( int x ) { Vector < Integer > num = new Vector < > ( ) ; while ( x > 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < M ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; } public static void main ( String [ ] args ) { int L = 2 , R = 60 ; System . out . println ( solve ( R ) - solve ( L - 1 ) ) ; L = 1 ; R = 1000 ; System . out . println ( solve ( R ) - solve ( L - 1 ) ) ; } }
import java . util . Scanner ; public class JavaApplication125 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; int old = - 1 ; long ans = 0 ; for ( int i = 0 ; i < num ; i ++ ) { int s = sc . nextInt ( ) ; if ( s == 1 ) { if ( old >= 0 ) { ans *= ( i - old ) ; } else { ans = 1 ; } old = i ; } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int bit ( int x ) { int ans = 0 ; while ( x > 0 ) { x /= 2 ; ans ++ ; } return ans ; } static boolean check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; } static int bs ( int n ) { int l = 1 , r = ( int ) Math . sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } static int countDivisor ( int n ) { return n - bs ( n ) + 1 ; } static public void main ( String [ ] args ) { int n = 5 ; System . out . println ( countDivisor ( n ) ) ; } }
import java . util . * ; public class GFG { static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = Integer . MAX_VALUE ; String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; } public static void main ( String args [ ] ) { String s = " aaaaaaaa " ; int n = s . length ( ) ; System . out . println ( minimalSteps ( s , n ) / 2 ) ; } }
public class GFG { static boolean checkUtil ( int num , int dig , int base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( num / base , -- dig , base ) ; return false ; } static boolean check ( int num , int dig ) { for ( int base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; } public static void main ( String [ ] args ) { int num = 8 ; int dig = 3 ; if ( check ( num , dig ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
public class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } static int getMin ( int arr [ ] , int i , int j ) { int minVal = arr [ i ++ ] ; while ( i <= j ) { minVal = Math . min ( minVal , arr [ i ] ) ; i ++ ; } return minVal ; } static int getMax ( int arr [ ] , int i , int j ) { int maxVal = arr [ i ++ ] ; while ( i <= j ) { maxVal = Math . max ( maxVal , arr [ i ] ) ; i ++ ; } return maxVal ; } static void generateArr ( int arr [ ] , int n ) { if ( n == 0 ) return ; if ( n == 1 ) { System . out . println ( arr [ 0 ] ) ; return ; } int tmpArr [ ] = new int [ n ] ; tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) { tmpArr [ i ] = Math . abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) ; } tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) ; printArray ( tmpArr , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 2 , 4 , 3 } ; int n = arr . length ; generateArr ( arr , n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } String s = sc . next ( ) ; long sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( ch == ' B ' ) sum += a [ i ] ; } long ans = sum ; long sum1 = sum ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' A ' ) sum1 += a [ i ] ; else sum1 -= a [ i ] ; ans = Math . max ( ans , sum1 ) ; } sum1 = sum ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == ' A ' ) sum1 += a [ i ] ; else sum1 -= a [ i ] ; ans = Math . max ( ans , sum1 ) ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { float xa = sc . nextFloat ( ) ; float ya = sc . nextFloat ( ) ; float xb = sc . nextFloat ( ) ; float yb = sc . nextFloat ( ) ; float xc = sc . nextFloat ( ) ; float yc = sc . nextFloat ( ) ; float xd = sc . nextFloat ( ) ; float yd = sc . nextFloat ( ) ; float katamukiab = ( yb - ya ) / ( xb - xa ) ; float katamukicd = ( yd - yc ) / ( xd - xc ) ; if ( katamukiab == katamukicd ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public class GFG { static int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , n = 10 ; System . out . println ( nthXorFib ( n , a , b ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String card1 , card2 ; int player1 = 0 , player2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { card1 = sc . next ( ) ; card2 = sc . next ( ) ; if ( card1 . compareTo ( card2 ) >= 1 ) { player1 += 3 ; } else if ( card1 . compareTo ( card2 ) <= - 1 ) { player2 += 3 ; } else if ( card1 . compareTo ( card2 ) == 0 ) { player1 ++ ; player2 ++ ; } } System . out . println ( player1 + " ▁ " + player2 ) ; sc . close ( ) ; } }
import java . io . * ; public class GFG { static float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( Area ( a ) ) ; } }
public final class p073 { public static void main ( String [ ] args ) { System . out . println ( new p073 ( ) . run ( ) ) ; } public String run ( ) { return Integer . toString ( sternBrocotCount ( 1 , 3 , 1 , 2 ) ) ; } private static int sternBrocotCount ( int leftN , int leftD , int rightN , int rightD ) { int n = leftN + rightN ; int d = leftD + rightD ; if ( d > 12000 ) return 0 ; else return 1 + sternBrocotCount ( leftN , leftD , n , d ) + sternBrocotCount ( n , d , rightN , rightD ) ; } }
import java . io . PrintWriter ; import java . util . Scanner ; public class Filling_Shapes { static Scanner sc = new Scanner ( System . in ) ; static PrintWriter pw = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) { int n = sc . nextInt ( ) ; pw . println ( ( n % 2 ) == 1 ? 0 : ( int ) Math . pow ( 2 , n / 2 ) ) ; pw . close ( ) ; } public static int find ( int n ) { int arr [ ] = new int [ 60 + 1 ] ; arr [ 1 ] = 0 ; arr [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { arr [ i ] = arr [ i - 2 ] * 2 ; } return arr [ n ] ; } }
public class GFG { static void sieve ( boolean [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } static int sumPrime ( int d ) { int i ; int maxVal = ( int ) Math . pow ( 10 , d ) - 1 ; boolean prime [ ] = new boolean [ maxVal + 1 ] ; for ( i = 0 ; i < maxVal + 1 ; i ++ ) prime [ i ] = true ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int d = 3 ; System . out . println ( sumPrime ( d ) ) ; } }
import java . util . * ; public class GFG { static void sieve ( boolean prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } static int sumPrime ( int d ) { int maxVal = ( int ) ( Math . pow ( 2 , d ) - 1 ) ; boolean [ ] prime = new boolean [ maxVal + 1 ] ; Arrays . fill ( prime , true ) ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int d = 8 ; System . out . println ( sumPrime ( d ) ) ; } }
import java . io . * ; import java . util . * ; public class CF { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int test = in . nextInt ( ) ; for ( int t = 0 ; t < test ; t ++ ) { int n = in . nextInt ( ) , k = in . nextInt ( ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int v = in . nextInt ( ) ; list . add ( v ) ; } Collections . sort ( list ) ; int div = 1 ; int count = 0 ; long sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += list . get ( i ) ; if ( sum / ( div * 1.0 ) >= k ) { count ++ ; div ++ ; } else { break ; } } pw . println ( count ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . time . LocalDate ; import java . time . Period ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { age_difference ( ) ; } private static void age_difference ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] d = new int [ 6 ] ; for ( int i = 0 ; i < 6 ; i ++ ) { d [ i ] = sc . nextInt ( ) ; } LocalDate d1 = LocalDate . of ( d [ 0 ] , d [ 1 ] , d [ 2 ] ) ; LocalDate d2 = LocalDate . of ( d [ 3 ] , d [ 4 ] , d [ 5 ] ) ; int age_diff = Math . abs ( Period . between ( d1 , d2 ) . getYears ( ) ) ; if ( d [ 1 ] == d [ 4 ] && d [ 2 ] == d [ 5 ] ) { System . out . println ( age_diff ) ; } else { System . out . println ( age_diff + 1 ) ; } sc . close ( ) ; } }
import java . io . * ; public class GFG { static int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( maxPartitions ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int countMaxContiguous ( int arr [ ] , int n ) { int current_max = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) current_max = 0 ; else { current_max ++ ; max_so_far = Math . max ( current_max , max_so_far ) ; } } return max_so_far ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 2 , 4 , 3 , 8 , 9 } ; int n = arr . length ; System . out . println ( countMaxContiguous ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( h * r * ( float ) Math . sqrt ( 2 ) ) / ( h + ( float ) Math . sqrt ( 2 ) * r ) ; return a ; } public static void main ( String [ ] args ) { float h = 5 , r = 6 ; System . out . println ( cube ( h , r ) ) ; } }
import java . io . * ; public class GFG { static void pattern ( int rows_no ) { int i , j , k ; for ( i = 1 ; i <= rows_no ; i ++ ) { for ( k = 1 ; k < i ; k ++ ) System . out . print ( " ▁ " ) ; for ( j = i ; j <= rows_no ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } for ( i = rows_no - 1 ; i >= 1 ; i -- ) { for ( k = 1 ; k < i ; k ++ ) System . out . print ( " ▁ " ) ; for ( j = i ; j <= rows_no ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int rows_no = 7 ; pattern ( rows_no ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String n = in . nextLine ( ) ; for ( int i = 1 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) != '0' ) { int sum = 0 ; for ( int j = 0 ; j < n . length ( ) ; j ++ ) { sum += n . charAt ( j ) - '0' ; } System . out . println ( sum ) ; return ; } } if ( n . charAt ( 0 ) == '1' ) { System . out . println ( 10 ) ; return ; } System . out . println ( n . charAt ( 0 ) ) ; } }
class Geeks { static int check_digits ( int n ) { while ( n > 0 ) { if ( ( n % 10 ) % 2 == 0 ) return 0 ; n /= 10 ; } return 1 ; } static int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) > 0 ) return i ; } public static void main ( String args [ ] ) { int N = 2397 ; System . out . println ( smallest_number ( N ) ) ; } }
public class GFG { static int check_digits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 != 0 ) return 0 ; n /= 10 ; } return 1 ; } static int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) != 0 ) return i ; } public static void main ( String [ ] args ) { int N = 2397 ; System . out . println ( smallest_number ( N ) ) ; } }
import java . util . * ; public class GFG { static void triangular_series ( int n ) { int i , j = 1 , k = 1 ; for ( i = 1 ; i <= n ; i ++ ) { System . out . printf ( " % d ▁ " , k ) ; j = j + 1 ; k = k + j ; } } public static void main ( String [ ] args ) { int n = 5 ; triangular_series ( n ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class TheBestGift { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] str = br . readLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int m = Integer . parseInt ( str [ 1 ] ) ; int arr [ ] = new int [ m ] ; str = br . readLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ Integer . parseInt ( str [ i ] ) - 1 ] ++ ; } System . out . println ( getNumberOfWays2 ( arr , n ) ) ; } private static long getNumberOfWays1 ( int [ ] arr , int n ) { long count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { count = count + ( arr [ i ] * ( n - arr [ i ] ) ) ; } return count / 2 ; } static long sumNatual ( int n ) { return ( ( long ) n * ( n + 1l ) ) / 2 ; } private static long getNumberOfWays2 ( int [ ] arr , int n ) { long t = sumNatual ( n ) ; for ( int x : arr ) { t -= sumNatual ( x ) ; } return t ; } }
public class GFG { public static int findPosition ( int k , int n ) { long f1 = 0 , f2 = 1 , f3 ; int i = 2 ; while ( i != 0 ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; } public static void main ( String [ ] args ) { int n = 5 ; int k = 4 ; System . out . print ( " Position ▁ of ▁ n ' th ▁ multiple " + " ▁ of ▁ k ▁ in ▁ Fibonacci ▁ Series ▁ is ▁ " ) ; System . out . println ( findPosition ( k , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int len = s . length ( ) ; int n = 0 ; int c ; String ans ; boolean [ ] e = new boolean [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( e [ ( int ) ( s . charAt ( i ) ) - 97 ] == false ) n ++ ; e [ ( int ) ( s . charAt ( i ) ) - 97 ] = true ; } if ( n == 2 ) { c = 0 ; } else { c = len - 2 ; if ( s . charAt ( 0 ) == s . charAt ( len - 1 ) ) c -- ; } if ( c % 2 == 0 ) { ans = " Second " ; } else { ans = " First " ; } System . out . println ( ans ) ; sc . close ( ) ; } }
import java . io . * ; public class GFG { static int countMinimumMoves ( int arr [ ] , int n , int k ) { int i ; for ( i = k - 1 ; i < n ; i ++ ) if ( arr [ i ] != arr [ k - 1 ] ) return - 1 ; for ( i = k - 1 ; i >= 0 ; i -- ) if ( arr [ i ] != arr [ k - 1 ] ) return i + 1 ; return 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int K = 4 ; int n = arr . length ; System . out . print ( countMinimumMoves ( arr , n , K ) ) ; } }
import java . util . * ; class Solution { static long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long powerGCD ( long a , long b , long n ) { long e = power ( a , n , b ) ; return gcd ( e , b ) ; } public static void main ( String args [ ] ) { long a = 5 , b = 4 , n = 2 ; System . out . print ( powerGCD ( a , b , n ) ) ; } }
import java . io . * ; import java . util . * ; import java . math . * ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int t = in . nextInt ( ) ; int s = in . nextInt ( ) ; int q = in . nextInt ( ) ; long sum = 0 ; while ( s < t ) { s = s * q ; sum ++ ; } out . println ( sum ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } boolean hasNext ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( Exception e ) { return false ; } } return true ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public String nextLine ( ) { String str = null ; try { str = reader . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public BigInteger nextBigInteger ( ) { return new BigInteger ( next ( ) ) ; } public BigDecimal nextBigDecimal ( ) { return new BigDecimal ( next ( ) ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long n = in . nextLong ( ) ; long s = n - 2 ; System . out . println ( s * s ) ; } }
import java . util . HashSet ; public class GFG { public static int countIdenticalRows ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { HashSet < Integer > hs = new HashSet < > ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) { hs . add ( mat [ i ] [ j ] ) ; } if ( hs . size ( ) == 1 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 2 , 3 } , { 5 , 5 , 5 } } ; System . out . print ( countIdenticalRows ( mat ) ) ; } }
import java . util . * ; public class GFG { static void createSorted ( int a [ ] , int n ) { Vector < Integer > b = new Vector < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( b . isEmpty ( ) ) b . add ( a [ j ] ) ; else { int start = 0 , end = b . size ( ) - 1 ; int pos = 0 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( b . get ( mid ) == a [ j ] ) { b . add ( ( Math . max ( 0 , mid + 1 ) ) , a [ j ] ) ; break ; } else if ( b . get ( mid ) > a [ j ] ) pos = end = mid - 1 ; else pos = start = mid + 1 ; if ( start > end ) { pos = start ; b . add ( Math . max ( 0 , pos ) , a [ j ] ) ; break ; } } } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( b . get ( i ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 2 , 5 , 4 , 9 , 8 } ; int n = a . length ; createSorted ( a , n ) ; } }
import java . util . HashSet ; class geeks { public static int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { String temp = " " ; HashSet < Character > ans = new HashSet < > ( ) ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; } public static void main ( String [ ] args ) { String str = " ABCA " ; System . out . println ( countTotalDistinct ( str ) ) ; } }
import java . math . * ; public class GFG { static int firstDigit ( int n ) { int digits = ( int ) ( Math . log10 ( n ) ) ; n = ( int ) ( n / ( int ) ( Math . pow ( 10 , digits ) ) ) ; return n ; } static int lastDigit ( int n ) { return ( n % 10 ) ; } public static void main ( String args [ ] ) { int n = 98562 ; System . out . println ( firstDigit ( n ) + " ▁ " + lastDigit ( n ) ) ; } }
import java . util . * ; class solution { static void removeZeros ( int [ ] a , int n ) { int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != 0 ) { ind = i ; break ; } } if ( ind == - 1 ) { System . out . print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) ; return ; } int [ ] b = new int [ n - ind ] ; for ( int i = 0 ; i < n - ind ; i ++ ) b [ i ] = a [ ind + i ] ; for ( int i = 0 ; i < n - ind ; i ++ ) System . out . print ( b [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int [ ] a = { 0 , 0 , 0 , 1 , 2 , 0 , 3 } ; int n = a . length ; removeZeros ( a , n ) ; } }
import java . util . * ; public class GFG { static int find_maxm ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { int value = x . getKey ( ) ; int freq = x . getValue ( ) ; if ( value == freq ) { ans = Math . max ( ans , value ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . print ( find_maxm ( arr , n ) ) ; } }
import java . io . BufferedInputStream ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Scanner ; import java . util . TreeMap ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( new BufferedInputStream ( System . in ) ) ; int N = scan . nextInt ( ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = scan . nextInt ( ) ; Task tsk = new Task ( ) ; System . out . println ( tsk . solve ( arr ) ) ; } static class Task { public int solve ( int [ ] arr ) { int n = arr . length ; int [ ] sorted = Arrays . copyOf ( arr , n ) ; Arrays . sort ( sorted ) ; long total = ( long ) n * ( n + 1 ) / 2 ; int l = 0 , r = n - 1 ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int target = sorted [ mid ] ; int cur = 0 ; long cnt = 0 ; long [ ] bit = new long [ 2 * n + 2 ] ; for ( int x = n + 1 ; x < bit . length ; x += x & - x ) bit [ x ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { cur += arr [ i ] <= target ? 1 : - 1 ; for ( int x = cur + n + 1 ; x < bit . length ; x += x & - x ) bit [ x ] ++ ; for ( int x = cur + n ; x > 0 ; x -= x & - x ) cnt += bit [ x ] ; } if ( cnt >= total / 2 + 1 ) r = mid ; else l = mid + 1 ; } return sorted [ l ] ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x != 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; } static int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } static int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; } public static void main ( String args [ ] ) { int N = 35 ; System . out . print ( sumOfDigitsTwoParts ( N ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; double [ ] ca = new double [ ] { 35.5 , 37.5 , 40 , 43 , 50 , 55 , 70 } ; double [ ] cb = new double [ ] { 71 , 77 , 83 , 89 , 105 , 116 , 148 } ; String [ ] c = new String [ ] { " AAA " , " AA " , " A " , " B " , " C " , " D " , " E " , " NA " } ; while ( stdIn . hasNext ( ) ) { double a = stdIn . nextDouble ( ) ; double b = stdIn . nextDouble ( ) ; int ar = 100 ; int br = 100 ; for ( int i = 0 ; i < ca . length ; i ++ ) { if ( ca [ i ] > a ) { ar = i ; break ; } } for ( int i = 0 ; i < cb . length ; i ++ ) { if ( cb [ i ] > b ) { br = i ; break ; } } int ans = Math . max ( ar , br ) ; if ( ans == 100 ) { ans = c . length - 1 ; } System . out . println ( c [ ans ] ) ; } } }
import java . util . Scanner ; public class q1 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long a , b , c , d ; a = sc . nextLong ( ) ; b = sc . nextLong ( ) ; c = sc . nextLong ( ) ; d = sc . nextLong ( ) ; long res = Math . max ( c - 1 , a - c ) + Math . max ( d - 1 , b - d ) ; System . out . println ( res ) ; } } }
import java . util . Arrays ; import java . util . Scanner ; public class A_Remove_Smallest { public static void main ( String [ ] args ) { Scanner sn = new Scanner ( System . in ) ; int t = sn . nextInt ( ) ; while ( t -- > 0 ) { int n = sn . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sn . nextInt ( ) ; Arrays . sort ( arr ) ; int i ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) <= 1 ) continue ; else break ; } if ( i == n - 1 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import static java . lang . Math . sin ; public class GFG { static void cal_sin ( float n ) { float accuracy = ( float ) 0.0001 , denominator , sinx , sinval ; n = n * ( float ) ( 3.142 / 180.0 ) ; float x1 = n ; sinx = n ; sinval = ( float ) sin ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i + 1 ) ; x1 = - x1 * n * n / denominator ; sinx = sinx + x1 ; i = i + 1 ; } while ( accuracy <= sinval - sinx ) ; System . out . println ( sinx ) ; } public static void main ( String [ ] args ) { float n = 90 ; cal_sin ( n ) ; } }
public class GFG { static int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; static int multiply ( ) { int pro = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) pro = pro * arr [ i ] ; return pro ; } public static void main ( String [ ] args ) { System . out . println ( multiply ( ) ) ; } }
import java . math . BigDecimal ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int q , order_num , i , j , n = 0 , counter ; boolean [ ] flag = new boolean [ 64 ] ; try ( Scanner sc = new Scanner ( System . in ) ) { q = sc . nextInt ( ) ; for ( j = 0 ; j < q ; j ++ ) { order_num = sc . nextInt ( ) ; if ( order_num <= 3 ) { n = sc . nextInt ( ) ; } switch ( order_num ) { case 0 : System . out . println ( flag [ n ] ? "1" : "0" ) ; break ; case 1 : flag [ n ] = true ; break ; case 2 : flag [ n ] = false ; break ; case 3 : flag [ n ] = ! flag [ n ] ; break ; case 4 : counter = 1 ; for ( i = 0 ; i < 64 ; i ++ ) { if ( flag [ i ] != true ) { counter = 0 ; break ; } } System . out . println ( counter ) ; break ; case 5 : counter = 0 ; for ( i = 0 ; i < 64 ; i ++ ) { if ( flag [ i ] != false ) { counter = 1 ; break ; } } System . out . println ( counter ) ; break ; case 6 : counter = 1 ; for ( i = 0 ; i < 64 ; i ++ ) { if ( flag [ i ] == true ) { counter = 0 ; break ; } } System . out . println ( counter ) ; break ; case 7 : counter = 0 ; for ( i = 0 ; i < 64 ; i ++ ) { if ( flag [ i ] == true ) { counter ++ ; } } System . out . println ( counter ) ; break ; case 8 : BigDecimal sum = new BigDecimal ( "0" ) ; BigDecimal big = new BigDecimal ( "2" ) ; for ( i = 0 ; i < 64 ; i ++ ) { if ( flag [ i ] ) { sum = sum . add ( big . pow ( i ) ) ; } } System . out . println ( sum ) ; } } } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int bit ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } static int maxSumOfBits ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 } ; int n = arr . length ; System . out . print ( maxSumOfBits ( arr , n ) ) ; } }
import java . util . * ; public class JavaApplication70 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; int counter = 0 ; int fine = 0 ; ArrayList < String > arr = new ArrayList < > ( ) ; for ( int i = 0 ; i < num ; i ++ ) { String s = sc . next ( ) ; arr . add ( s ) ; } for ( int i = 0 ; i < num ; i ++ ) { for ( int k = 0 ; k < num ; k ++ ) { if ( arr . get ( k ) . charAt ( i ) == ' C ' ) { counter ++ ; } } fine += ( counter * ( counter - 1 ) ) / 2 ; counter = 0 ; } for ( int i = 0 ; i < num ; i ++ ) { for ( int k = 0 ; k < num ; k ++ ) { if ( arr . get ( i ) . charAt ( k ) == ' C ' ) { counter ++ ; } } fine += ( counter * ( counter - 1 ) ) / 2 ; counter = 0 ; } System . out . println ( fine ) ; } }
public class GFG { static int findMinIndex ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return findMinIndex ( arr , low , mid - 1 ) ; return findMinIndex ( arr , mid + 1 , high ) ; } static int binary_search ( int arr [ ] , int l , int h , int x ) { while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= x ) l = mid + 1 ; else h = mid - 1 ; } return h ; } static int countEleLessThanOrEqual ( int arr [ ] , int n , int x ) { int min_index = findMinIndex ( arr , 0 , n - 1 ) ; if ( x <= arr [ n - 1 ] ) return ( binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ) ; if ( ( min_index - 1 ) >= 0 && x <= arr [ min_index - 1 ] ) return ( n - min_index + binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) ; return n ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 10 , 12 , 15 , 2 , 4 , 5 } ; int n = arr . length ; int x = 14 ; System . out . print ( " Count ▁ = ▁ " + countEleLessThanOrEqual ( arr , n , x ) ) ; } }
import java . text . * ; public class GFG { static double f ( double x , double y ) { double v = y - 2 * x * x + 1 ; return v ; } static double predict ( double x , double y , double h ) { double y1p = y + h * f ( x , y ) ; return y1p ; } static double correct ( double x , double y , double x1 , double y1 , double h ) { double e = 0.00001 ; double y1c = y1 ; while ( Math . abs ( y1c - y1 ) > e ) { y1 = y1c ; y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) ; } return y1c ; } static void printFinalValues ( double x , double xn , double y , double h ) { while ( x < xn ) { double x1 = x + h ; double y1p = predict ( x , y , h ) ; double y1c = correct ( x , y , x1 , y1p , h ) ; x = x1 ; y = y1c ; } System . out . println ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = ▁ " + ( int ) x + " ▁ is ▁ : ▁ " +  String . format ( " % . 4 f " , y ) ) ; } public static void main ( String [ ] args ) { double x = 0 , y = 0.5 ; double xn = 1 ; double h = 0.2 ; printFinalValues ( x , xn , y , h ) ; } }
import java . util . * ; public class GFG { static void D_Pattern ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 1 || ( ( i == 0 || i == n - 1 ) && ( j > 1 && j < n - 2 ) ) || ( j == n - 2 && i != 0 && i != n - 1 ) ) System . out . print ( " * " ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 9 ; D_Pattern ( n ) ; } }
public class GFG { static void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; for ( int j = 1 ; j < first_y_position ; j ++ ) System . out . print ( " x " ) ; System . out . print ( " y " ) ; int j = first_y_position + 1 ; while ( second_y_position > 1 ) { System . out . print ( " x " ) ; second_y_position -- ; j ++ ; } System . out . print ( " y " ) ; while ( j < n ) { System . out . print ( " x " ) ; j ++ ; } } public static void main ( String [ ] args ) { int n = 5 ; int k = 7 ; kthString ( n , k ) ; } }
public class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int count_of_subarrays ( int N ) { int count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( count_of_subarrays ( N ) + " \n " ) ; } }
import java . util . * ; public class Solution { public int [ ] productExceptSelf ( int [ ] nums ) { int n = nums . length ; int [ ] res = new int [ n ] ; res [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res [ i ] = res [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { res [ i ] *= right ; right *= nums [ i ] ; } return res ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = {1,2,3,4} ; int [ ] out = sObj . productExceptSelf ( nums ) ; System . out . println ( Arrays . toString ( out ) ) ; } }
public class GFG { public static void getSmallestAndLargest ( String s , int k ) { String currStr = s . substring ( 0 , k ) ; String lexMin = currStr ; String lexMax = currStr ; for ( int i = k ; i < s . length ( ) ; i ++ ) { currStr = currStr . substring ( 1 , k ) + s . charAt ( i ) ; if ( lexMax . compareTo ( currStr ) < 0 ) lexMax = currStr ; if ( lexMin . compareTo ( currStr ) > 0 ) lexMin = currStr ; } System . out . println ( lexMin ) ; System . out . println ( lexMax ) ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int k = 3 ; getSmallestAndLargest ( str , k ) ; } }
import java . util . * ; public class CF840A { public static Scanner scanner ; public static void main ( String [ ] args ) { scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; List < Integer > a = new ArrayList < > ( ) ; int [ ] [ ] b = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( Integer . parseInt ( scanner . next ( ) ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] [ 0 ] = Integer . parseInt ( scanner . next ( ) ) ; b [ i ] [ 1 ] = i ; } a . sort ( Comparator . reverseOrder ( ) ) ; Arrays . sort ( b , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] o1 , int [ ] o2 ) { int cmp = Integer . compare ( o1 [ 0 ] , o2 [ 0 ] ) ; if ( cmp == 0 ) return Integer . compare ( o1 [ 1 ] , o2 [ 1 ] ) ; else return cmp ; } } ) ; int [ ] res = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] e = b [ i ] ; res [ e [ 1 ] ] = a . get ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " ▁ " ) ; } } }
import java . util . * ; public class GFG { static final int INT_BITS = 32 ; static int maxSubarrayXOR ( int set [ ] , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = Integer . MIN_VALUE ; for ( int j = index ; j < n ; j ++ ) { if ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) { maxEle = set [ j ] ; maxInd = j ; } } if ( maxEle == - 2147483648 ) continue ; int temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; maxInd = index ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) set [ j ] = set [ j ] ^ set [ maxInd ] ; } index ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= set [ i ] ; return res ; } public static void main ( String arg [ ] ) { int set [ ] = { 9 , 8 , 5 } ; int n = set . length ; System . out . print ( " Max ▁ subset ▁ XOR ▁ is ▁ " ) ; System . out . print ( maxSubarrayXOR ( set , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int number = sc . nextInt ( ) ; int [ ] wooden = new int [ number ] ; for ( int i = 0 ; i < wooden . length ; i ++ ) { int each = sc . nextInt ( ) ; wooden [ i ] = each ; } int [ ] height = new int [ wooden . length ] ; int count ; for ( int i = 0 ; i < wooden . length ; i ++ ) { if ( wooden [ i ] == 0 ) { continue ; } else { count = 1 ; for ( int j = i + 1 ; j < wooden . length ; j ++ ) { if ( wooden [ i ] == wooden [ j ] ) { wooden [ j ] = 0 ; count ++ ; } } height [ i ] = count ; } } int index = 0 ; int max = height [ 0 ] ; for ( int i = 0 ; i < height . length ; i ++ ) { if ( height [ i ] != 0 ) { index ++ ; } if ( max < height [ i ] ) { max = height [ i ] ; } } System . out . println ( max + " ▁ " + index ) ; } }
import java . util . * ; import java . lang . * ; class Main { static void minAbsSumPair ( int arr [ ] , int n ) { int sum , min_sum = 999999 ; int l = 0 , r = n - 1 ; int min_l = l , min_r = n - 1 ; if ( n < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } sort ( arr , l , r ) ; while ( l < r ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( sum ) < Math . abs ( min_sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } if ( sum < 0 ) l ++ ; else r -- ; } System . out . println ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_l ] + " ▁ and ▁ " + arr [ min_r ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 60 , - 10 , 70 , - 80 , 85 } ; int n = arr . length ; minAbsSumPair ( arr , n ) ; } static int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j < high ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } int temp = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = temp ; return i + 1 ; } static void sort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; sort ( arr , low , pi - 1 ) ; sort ( arr , pi + 1 , high ) ; } } }
class Solution { public int firstUniqChar ( String s ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( freq [ s . charAt ( i ) - ' a ' ] == 1 ) return i ; return - 1 ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String s = " leetcode " ; int out = sObj . firstUniqChar ( s ) ; System . out . println ( out ) ; } }
import java . util . LinkedList ; import java . util . Queue ; import java . util . Stack ; public class GFG { static boolean checkStackPermutation ( int ip [ ] , int op [ ] , int n ) { Queue < Integer > input = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { input . add ( ip [ i ] ) ; } Queue < Integer > output = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { output . add ( op [ i ] ) ; } Stack < Integer > tempStack = new Stack < > ( ) ; while ( ! input . isEmpty ( ) ) { int ele = input . poll ( ) ; if ( ele == output . peek ( ) ) { output . poll ( ) ; while ( ! tempStack . isEmpty ( ) ) { if ( tempStack . peek ( ) == output . peek ( ) ) { tempStack . pop ( ) ; output . poll ( ) ; } else break ; } } else { tempStack . push ( ele ) ; } } return ( input . isEmpty ( ) && tempStack . isEmpty ( ) ) ; } public static void main ( String [ ] args ) { int input [ ] = { 1 , 2 , 3 } ; int output [ ] = { 2 , 1 , 3 } ; int n = 3 ; if ( checkStackPermutation ( input , output , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " Not ▁ Possible " ) ; } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; int l = s . length ( ) ; boolean ans = true ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . indexOf ( s . charAt ( i ) , i + 1 ) != t . indexOf ( t . charAt ( i ) , i + 1 ) ) { ans = false ; break ; } } System . out . println ( ans ? " Yes " : " No " ) ; } }
import java . util . * ; class solution { static long getSum ( int n , int d ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 10 == d ) sum += i ; } return sum ; } public static void main ( String args [ ] ) { int n = 30 , d = 3 ; System . out . println ( getSum ( n , d ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int st = in . nextInt ( ) ; int end = in . nextInt ( ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int sum = 0 ; if ( st > end ) { int temp = end ; end = st ; st = temp ; } if ( n + m <= st ) { sum = end - st ; } else if ( n + m >= st && n - m < st ) { sum = end - n - m ; } else if ( n - m >= st && n <= end - m ) { sum = end - st - 2 * m ; } else if ( n - m < end && n + m >= end ) { sum = n - m - st ; } else { sum = end - st ; } if ( sum < 0 ) sum = 0 ; System . out . println ( sum ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { int e = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int temp = Math . max ( e - s , e - t ) ; System . out . println ( temp + 1 ) ; } } catch ( Exception e ) { } } }
import java . io . * ; public class GFG { static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } static public void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( findSum ( N , K ) ) ; } }
import java . util . Scanner ; import java . util . Arrays ; public class Ishu { static long gcd ( long a , long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; long t ; long n , ans = 1 ; t = scan . nextLong ( ) ; while ( t -- > 0 ) { n = scan . nextLong ( ) ; ans = 1 + ( ( 4 * n ) / gcd ( 4 * n , n + 1 ) ) ; System . out . println ( ans ) ; } } }
public class GFG { static double PI = 3.14 ; static double find_area ( int r , int d ) { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; } public static void main ( String [ ] args ) { int r = 4 , d = 5 ; System . out . println ( find_area ( r , d ) ) ; } }
import java . io . * ; public class GFG { static int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; } public static void main ( String [ ] args ) { int n = 5 ; int s = 11 ; System . out . println ( minimumNumbers ( n , s ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 1 , 1 , 1 , 1 } ; int n = arr . length ; int m = 1 ; System . out . println ( countTriplets ( arr , n , m ) ) ; } }
import java . io . * ; public class GFG { static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; } public static void main ( String [ ] args ) { int result = findIndex ( 21 ) ; System . out . println ( result ) ; } }
public class GFG { static boolean isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; } return false ; } static boolean isSatisfied ( char [ ] str , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str = " acaba " ; int n = str . length ( ) ; if ( isSatisfied ( str . toCharArray ( ) , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( countWays ( n ) ) ; } }
public class GFG { static double expect ( double m , double n ) { double ans = 0.0 , i ; for ( i = m ; i > 0 ; i -- ) ans += ( Math . pow ( i / m , n ) - Math . pow ( ( i - 1 ) / m , n ) ) * i ; return ans ; } public static void main ( String [ ] args ) { double m = 6 , n = 3 ; System . out . println ( String . format ( " % .5f " , expect ( m , n ) ) ) ; } }
import java . util . Arrays ; public class GFG { static long ProdOfPrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } long prod = 1 ; for ( int i = 2 ; i <= n ; i ++ ) if ( prime [ i ] ) prod *= i ; return prod ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . print ( ProdOfPrimes ( n ) ) ; } }
public final class p019 { public static void main ( String [ ] args ) { System . out . println ( new p019 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int y = 1901 ; y <= 2000 ; y ++ ) { for ( int m = 1 ; m <= 12 ; m ++ ) { if ( dayOfWeek ( y , m , 1 ) == 0 ) count ++ ; } } return Integer . toString ( count ) ; } private static int dayOfWeek ( int year , int month , int day ) { if ( year < 0 || year > 10000 || month < 1 || month > 12 || day < 1 || day > 31 ) throw new IllegalArgumentException ( ) ; int m = ( month - 3 + 4800 ) % 4800 ; int y = ( year + m / 12 ) % 400 ; m %= 12 ; return ( y + y / 4 - y / 100 + ( 13 * m + 2 ) / 5 + day + 2 ) % 7 ; } }
public class GFG { static class Date { int d , m , y ; public Date ( int d , int m , int y ) { this . d = d ; this . m = m ; this . y = y ; } } ; static int monthDays [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; static int countLeapYears ( Date d ) { int years = d . y ; if ( d . m <= 2 ) { years -- ; } return years / 4 - years / 100 + years / 400 ; } static int getDifference ( Date dt1 , Date dt2 ) { int n1 = dt1 . y * 365 + dt1 . d ; for ( int i = 0 ; i < dt1 . m - 1 ; i ++ ) { n1 += monthDays [ i ] ; } n1 += countLeapYears ( dt1 ) ; int n2 = dt2 . y * 365 + dt2 . d ; for ( int i = 0 ; i < dt2 . m - 1 ; i ++ ) { n2 += monthDays [ i ] ; } n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; } public static void main ( String [ ] args ) { Date dt1 = new Date ( 1 , 2 , 2000 ) ; Date dt2 = new Date ( 1 , 2 , 2004 ) ; System . out . println ( " Difference ▁ between ▁ two ▁ dates ▁ is ▁ " + getDifference ( dt1 , dt2 ) ) ; } }
import java . util . * ; public class GFG { static Set < Integer > st = new HashSet < Integer > ( ) ; static void generateNumbers ( int n , int num , int a , int b ) { if ( num > 0 && num < n ) st . add ( num ) ; if ( num >= n ) return ; if ( num * 10 + a > num ) generateNumbers ( n , num * 10 + a , a , b ) ; generateNumbers ( n , num * 10 + b , a , b ) ; } static void printNumbers ( int n ) { for ( int i = 0 ; i <= 9 ; i ++ ) for ( int j = i + 1 ; j <= 9 ; j ++ ) generateNumbers ( n , 0 , i , j ) ; System . out . print ( " The ▁ numbers ▁ are : ▁ " ) ; System . out . print ( st ) ; st . clear ( ) ; } public static void main ( String args [ ] ) { int n = 12 ; printNumbers ( n ) ; } }
import java . util . Scanner ; public class ProgressBar { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int k = scan . nextInt ( ) ; int t = scan . nextInt ( ) ; double temp = ( t * k * n ) / 100.0 ; int x = 0 ; while ( temp - k >= 0 ) { temp -= k ; x ++ ; } for ( int i = 0 ; i < x ; i ++ ) System . out . print ( k + " ▁ " ) ; if ( temp != 0 ) { System . out . print ( ( int ) temp + " ▁ " ) ; x ++ ; } for ( int i = x ; i < n ; i ++ ) System . out . print ( 0 + " ▁ " ) ; System . out . println ( ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class Main { Scanner sc ; void run ( ) { for ( ; ; ) { int N = ni ( ) ; int Q = ni ( ) ; if ( ( N | Q ) == 0 ) { break ; } int [ ] [ ] list = new int [ N ] [ ] ; Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 1 ; i < 100 ; ++ i ) { map . put ( i , 0 ) ; } for ( int i = 0 ; i < N ; ++ i ) { int M = ni ( ) ; list [ i ] = new int [ M ] ; for ( int j = 0 ; j < M ; ++ j ) { int d = ni ( ) ; list [ i ] [ j ] = d ; map . put ( d , map . get ( d ) + 1 ) ; } } int max = 0 ; int idx = 0 ; for ( Integer key : map . keySet ( ) ) { int n = map . get ( key ) ; if ( n >= Q ) { if ( max < n ) { idx = key ; max = n ; } } } System . out . println ( idx ) ; } } Main ( ) { sc = new Scanner ( System . in ) ; } int ni ( ) { return sc . nextInt ( ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } }
class OddOccurance { int getOddOccurrence ( int ar [ ] , int ar_size ) { int i ; int res = 0 ; for ( i = 0 ; i < ar_size ; i ++ ) { res = res ^ ar [ i ] ; } return res ; } public static void main ( String [ ] args ) { OddOccurance occur = new OddOccurance ( ) ; int ar [ ] = new int [ ] { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = ar . length ; System . out . println ( occur . getOddOccurrence ( ar , n ) ) ; } }
public class GFG { static int isKthBitSet ( long x , long k ) { int rslt = ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) ? 1 : 0 ; return rslt ; } static int isPalindrome ( long x ) { long l = 1 ; long r = ( Integer . SIZE / 8 ) * 8 ; while ( l < r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) { return 0 ; } l ++ ; r -- ; } return 1 ; } public static void main ( String [ ] args ) { long x = 1 << 15 + 1 << 16 ; System . out . println ( isPalindrome ( x ) ) ; x = ( 1 << 31 ) + 1 ; System . out . println ( isPalindrome ( x ) ) ; } }
public class GFG { static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static void findPrimePair ( int n ) { int flag = 0 ; boolean [ ] isPrime = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x != i && x * i == n ) { System . out . println ( i + " ▁ " + x ) ; flag = 1 ; return ; } } if ( flag == 0 ) System . out . println ( " No ▁ such ▁ pair ▁ found " ) ; } public static void main ( String [ ] args ) { int n = 39 ; findPrimePair ( n ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 15 , g ; g = gcd ( a , b ) ; System . out . println ( " GCD ( " + a + " ▁ , ▁ " + b + " ) ▁ = ▁ " + g ) ; a = 35 ; b = 10 ; g = gcd ( a , b ) ; System . out . println ( " GCD ( " + a + " ▁ , ▁ " + b + " ) ▁ = ▁ " + g ) ; a = 31 ; b = 2 ; g = gcd ( a , b ) ; System . out . println ( " GCD ( " + a + " ▁ , ▁ " + b + " ) ▁ = ▁ " + g ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 15 , g ; g = gcd ( a , b ) ; System . out . println ( " GCD ( " + a + " ▁ , ▁ " + b + " ) ▁ = ▁ " + g ) ; a = 35 ; b = 10 ; g = gcd ( a , b ) ; System . out . println ( " GCD ( " + a + " ▁ , ▁ " + b + " ) ▁ = ▁ " + g ) ; a = 31 ; b = 2 ; g = gcd ( a , b ) ; System . out . println ( " GCD ( " + a + " ▁ , ▁ " + b + " ) ▁ = ▁ " + g ) ; } }
public final class p174 { public static void main ( String [ ] args ) { System . out . println ( new p174 ( ) . run ( ) ) ; } private static final int SIZE_LIMIT = 1000000 ; private static final int TYPE_LIMIT = 10 ; public String run ( ) { int [ ] type = new int [ SIZE_LIMIT + 1 ] ; for ( int n = 3 ; ( n - 1 ) * 4 <= SIZE_LIMIT ; n ++ ) { for ( int m = n - 2 ; m >= 1 ; m -= 2 ) { int tiles = n * n - m * m ; if ( tiles > SIZE_LIMIT ) break ; type [ tiles ] ++ ; } } int count = 0 ; for ( int t : type ) { if ( 1 <= t && t <= TYPE_LIMIT ) count ++ ; } return Integer . toString ( count ) ; } }
import java . util . * ; import java . io . * ; public class binary_removal { static void remove ( String s ) { int one = 0 ; int zero = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { if ( s . charAt ( i - 1 ) == '1' ) one ++ ; } else { if ( s . charAt ( i - 1 ) == '0' && one > 0 ) { System . out . println ( " No " ) ; return ; } } } System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { FastReader in = new FastReader ( ) ; FastWriter out = new FastWriter ( ) ; int test = in . nextInt ( ) ; while ( test -- > 0 ) { String s = in . nextLine ( ) ; remove ( s ) ; } } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) . trim ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return str ; } } static class FastWriter { private final BufferedWriter bw ; public FastWriter ( ) { this . bw = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; } public void print ( Object object ) throws IOException { bw . append ( " " + object ) ; } public void println ( Object object ) throws IOException { print ( object ) ; bw . append ( " \n " ) ; } public void close ( ) throws IOException { bw . close ( ) ; } } }
public class GFG { static int maxZeros ( int N ) { int maxm = - 1 ; int cnt = 0 ; while ( N != 0 ) { if ( ( N & 1 ) == 0 ) { cnt ++ ; N >>= 1 ; maxm = Math . max ( maxm , cnt ) ; } else { maxm = Math . max ( maxm , cnt ) ; cnt = 0 ; N >>= 1 ; } } return maxm ; } public static void main ( String args [ ] ) { int N = 14 ; System . out . println ( maxZeros ( N ) ) ; } }
import java . io . * ; public class GFG { static void getLongestSeq ( int a [ ] , int n ) { int maxIdx = 0 , maxLen = 0 , currLen = 0 , currIdx = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] > 0 ) { currLen ++ ; if ( currLen == 1 ) currIdx = k ; } else { if ( currLen > maxLen ) { maxLen = currLen ; maxIdx = currIdx ; } currLen = 0 ; } } if ( maxLen > 0 ) { System . out . print ( " Index ▁ : ▁ " + maxIdx ) ; System . out . print ( " ▁ , Length ▁ : ▁ " + maxLen ) ; } else System . out . println ( " No ▁ positive ▁ sequence ▁ detected . " ) ; return ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 } ; int n = arr . length ; getLongestSeq ( arr , n ) ; } }
public class Linked_list_2D_Matrix { static class Node { int data ; Node right ; Node down ; } ; static Node construct ( int arr [ ] [ ] , int i , int j , int m , int n ) { if ( i > n - 1 || j > m - 1 ) return null ; Node temp = new Node ( ) ; temp . data = arr [ i ] [ j ] ; temp . right = construct ( arr , i , j + 1 , m , n ) ; temp . down = construct ( arr , i + 1 , j , m , n ) ; return temp ; } static void display ( Node head ) { Node Rp ; Node Dp = head ; while ( Dp != null ) { Rp = Dp ; while ( Rp != null ) { System . out . print ( Rp . data + " ▁ " ) ; Rp = Rp . right ; } System . out . println ( ) ; Dp = Dp . down ; } } public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int m = 3 , n = 3 ; Node head = construct ( arr , 0 , 0 , m , n ) ; display ( head ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws IOException { final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final int n = Integer . parseInt ( br . readLine ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( Integer . parseInt ( br . readLine ( ) ) ) ) ans ++ ; } System . out . println ( ans ) ; } private static boolean isPrime ( int x ) { if ( x < 2 ) return false ; if ( x <= 3 ) return true ; if ( x % 2 == 0 || x % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= x ; i += 6 ) { if ( x % i == 0 || x % ( i + 2 ) == 0 ) return false ; } return true ; } }
public class GFG { static void findNthTerm ( int N ) { int ans ; if ( N % 2 == 0 ) { ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 ; } else { ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 ; } System . out . print ( ans + " \n " ) ; } public static void main ( String [ ] args ) { int N = 3 ; findNthTerm ( N ) ; } }
public class GFG { static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , m = 5 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; } }
import java . util . * ; public class GFG { static int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } } public static void main ( String [ ] args ) { int a [ ] = { 10 , 30 , 40 , 50 , 20 } ; int k = 3 ; int n = a . length ; int dp [ ] = new int [ n ] ; Arrays . fill ( dp , - 1 ) ; System . out . println ( FindMinimumCost ( 0 , a , n , k , dp ) ) ; } }
import java . io . * ; public class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static long Probability ( int sum , int times ) { float favorable = 0 , total = 36 ; long probability = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { for ( int j = 1 ; j <= 6 ; j ++ ) { if ( ( i + j ) == sum ) favorable ++ ; } } int gcd1 = __gcd ( ( int ) favorable , ( int ) total ) ; favorable = favorable / ( float ) gcd1 ; total = total / ( float ) gcd1 ; probability = ( long ) Math . pow ( total , times ) ; return probability ; } public static void main ( String [ ] args ) { int sum = 7 , times = 7 ; System . out . println ( "1" + " / " + Probability ( sum , times ) ) ; } }
import java . util . Scanner ; public class Main { static int mod = 998244353 ; static long [ ] [ ] nchoosek ; public static void main ( String [ ] args ) { nchoosek = new long [ 4001 ] [ 4001 ] ; for ( int i = 0 ; i < nchoosek . length ; i ++ ) { nchoosek [ i ] [ 0 ] = nchoosek [ i ] [ i ] = 1 ; } for ( int i = 2 ; i < nchoosek . length ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { nchoosek [ i ] [ j ] = ( nchoosek [ i - 1 ] [ j ] + nchoosek [ i - 1 ] [ j - 1 ] ) % mod ; } } Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; for ( int i = 2 ; i <= 2 * k ; i ++ ) { int pairs ; if ( i > k ) { pairs = k - i / 2 ; } else { pairs = ( i - 1 ) / 2 ; } int active = k - 2 * pairs ; if ( i % 2 == 0 ) active -= 1 ; long times2 = 1 ; long total = 0 ; for ( int j = 0 ; j <= pairs ; j ++ ) { long choice = times2 * nchoosek [ pairs ] [ j ] % mod ; times2 = times2 * 2 % mod ; if ( active + j - 1 < 0 ) continue ; total += choice * nchoosek [ n + active - 1 ] [ active + j - 1 ] ; if ( i % 2 == 0 ) { total += choice * nchoosek [ n + active - 2 ] [ active + j - 1 ] ; } total %= mod ; } System . out . println ( total ) ; } } }
import java . util . * ; import java . util . Collections ; import java . util . stream . Collectors ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; double total = 0 ; for ( int i = 0 ; i < N ; i ++ ) { double money = sc . nextDouble ( ) ; String A = sc . next ( ) ; String B = " JPY " ; if ( A . equals ( B ) ) { total += money ; } else { total += money * 380000 ; } } System . out . println ( total ) ; } }
import java . io . * ; public class GFG { static int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 } ; int n = arr . length ; int num1 = 5 , num2 = 4 ; System . out . println ( getCount ( arr , n , num1 , num2 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; StringBuilder sb = new StringBuilder ( ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) { break ; } int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int min = Integer . MAX_VALUE ; for ( int i = 1 ; i < n ; i ++ ) { min = Math . min ( min , arr [ i ] - arr [ i - 1 ] ) ; } sb . append ( min ) . append ( " \n " ) ; } System . out . print ( sb ) ; } }
import java . util . * ; public class GFG { static int countSetBits ( int n ) { int cnt = 0 ; int [ ] setBits = new int [ n + 1 ] ; setBits [ 0 ] = 0 ; setBits [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { setBits [ i ] = setBits [ i / 2 ] ; } else { setBits [ i ] = setBits [ i - 1 ] + 1 ; } } for ( int i = 0 ; i <= n ; i ++ ) { cnt = cnt + setBits [ i ] ; } return cnt ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( countSetBits ( n ) ) ; } }
public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int largestGCD1Subset ( int A [ ] , int n ) { int currentGCD = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { currentGCD = gcd ( currentGCD , A [ i ] ) ; if ( currentGCD == 1 ) return n ; } return 0 ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 18 , 6 , 3 } ; int n = A . length ; System . out . println ( largestGCD1Subset ( A , n ) ) ; } }
import java . util . Arrays ; public final class p179 { public static void main ( String [ ] args ) { System . out . println ( new p179 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 7 ) ; public String run ( ) { int [ ] numDivisors = new int [ LIMIT + 1 ] ; Arrays . fill ( numDivisors , 2 ) ; for ( int i = 2 ; i < numDivisors . length ; i ++ ) { for ( int j = i * 2 ; j < numDivisors . length ; j += i ) numDivisors [ j ] ++ ; } int count = 0 ; for ( int i = 2 ; i < numDivisors . length - 1 ; i ++ ) { if ( numDivisors [ i ] == numDivisors [ i + 1 ] ) count ++ ; } return Integer . toString ( count ) ; } }
public class GFG { static void updateArray ( int arr [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; updateArray ( arr , N ) ; } }
public class GFG { static void findEncryptedArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( sum - arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; findEncryptedArray ( arr , N ) ; } }
public class GFG { static void updateArray ( int arr [ ] , int n ) { for ( int i = 0 ; i <= n - 2 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; updateArray ( arr , N ) ; } }
public class GFG { static int findMinDifference ( int arr [ ] , int n ) { int min , secondMin , max , secondMax ; min = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = Math . min ( max - secondMin , secondMax - min ) ; return diff ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( findMinDifference ( arr , n ) ) ; } }
import java . util . * ; import java . math . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int num = scanner . nextInt ( ) ; long [ ] [ ] pairs = new long [ num ] [ 2 ] ; for ( int i = 0 ; i < num ; i ++ ) { pairs [ i ] [ 0 ] = scanner . nextLong ( ) ; pairs [ i ] [ 1 ] = scanner . nextLong ( ) ; } HashSet < Long > commonFactors = new HashSet < > ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { long X = pairs [ 0 ] [ i ] ; for ( long k = 2 ; k <= ( long ) Math . ceil ( Math . sqrt ( X ) ) ; k ++ ) { if ( X % k == 0 ) { while ( X % k == 0 ) { X /= k ; } commonFactors . add ( k ) ; } } if ( X != 1 ) { commonFactors . add ( X ) ; } } for ( long val : commonFactors ) { boolean works = true ; for ( int i = 0 ; i < pairs . length ; i ++ ) { if ( pairs [ i ] [ 0 ] % val > 0 && pairs [ i ] [ 1 ] % val > 0 ) { works = false ; break ; } } if ( works ) { System . out . println ( val ) ; return ; } } System . out . println ( - 1 ) ; } }
import java . io . * ; import java . util . StringTokenizer ; import java . util . ArrayList ; import java . util . Collections ; class Main { public static void main ( String args [ ] ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String buf ; try { while ( ! ( buf = br . readLine ( ) ) . equals ( "0" ) ) { int n = Integer . parseInt ( buf ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) a . add ( Integer . parseInt ( st . nextToken ( ) ) ) ; Collections . sort ( a ) ; boolean end = false ; for ( int i = 0 ; i < n ; ) { int count = 1 ; int j = a . get ( i ) ; i ++ ; while ( i < a . size ( ) && j == a . get ( i ) ) { count ++ ; i ++ ; } if ( count > n / 2 ) { System . out . println ( a . get ( i - 1 ) ) ; end = true ; } if ( end ) break ; } if ( ! end ) { System . out . println ( " NO ▁ COLOR " ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
class Factorial { int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } public static void main ( String args [ ] ) { Factorial obj = new Factorial ( ) ; int num = 5 ; System . out . println ( " Factorial ▁ of ▁ " + num + " ▁ is ▁ " + obj . factorial ( num ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; StringTokenizer st ; st = new StringTokenizer ( br . readLine ( ) ) ; int n , d , x ; n = parseInt ( st . nextToken ( ) ) ; d = parseInt ( st . nextToken ( ) ) ; x = parseInt ( st . nextToken ( ) ) ; int [ ] [ ] price = new int [ d ] [ n ] ; for ( int i = 0 ; i < d ; i ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; for ( int j = 0 ; j < n ; j ++ ) { price [ i ] [ j ] = parseInt ( st . nextToken ( ) ) ; } } for ( int i = 0 ; i < d - 1 ; i ++ ) { int [ ] dp = new int [ x + 1 ] ; for ( int j = 0 ; j <= x ; j ++ ) { dp [ j ] = j ; } for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k <= x ; k ++ ) { if ( k >= price [ i ] [ j ] ) { dp [ k ] = Math . max ( dp [ k ] , dp [ k - price [ i ] [ j ] ] + price [ i + 1 ] [ j ] ) ; } } } x = dp [ x ] ; } System . out . println ( x ) ; } }
import java . io . * ; import java . util . Arrays ; import java . util . StringTokenizer ; public class er { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; TaskB solver = new TaskB ( ) ; solver . solve ( br , out ) ; out . close ( ) ; } } class TaskB { public void solve ( BufferedReader br , PrintWriter out ) throws IOException { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; Long a [ ] = new Long [ n + 1 ] ; Long [ ] sumA = new Long [ n + 1 ] ; Long [ ] sumB = new Long [ n + 1 ] ; a [ 0 ] = sumA [ 0 ] = sumB [ 0 ] = Long . valueOf ( 0 ) ; st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = Long . parseLong ( st . nextToken ( ) ) ; sumA [ i ] = sumA [ i - 1 ] + a [ i ] ; } Arrays . sort ( a ) ; for ( int i = 1 ; i <= n ; i ++ ) { sumB [ i ] = sumB [ i - 1 ] + a [ i ] ; } st = new StringTokenizer ( br . readLine ( ) ) ; int m = Integer . parseInt ( st . nextToken ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; int type = Integer . parseInt ( st . nextToken ( ) ) , l = Integer . parseInt ( st . nextToken ( ) ) , r = Integer . parseInt ( st . nextToken ( ) ) ; if ( type == 1 ) { out . println ( sumA [ r ] - sumA [ l - 1 ] ) ; } else { out . println ( sumB [ r ] - sumB [ l - 1 ] ) ; } } } }
import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; public class GFG { static int findMinimumX ( int a [ ] , int n ) { Set < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) st . add ( a [ i ] ) ; if ( st . size ( ) == 1 ) return 0 ; if ( st . size ( ) == 2 ) { Iterator < Integer > it = st . iterator ( ) ; int el1 = it . next ( ) ; int el2 = it . next ( ) ; if ( ( el2 - el1 ) % 2 == 0 ) return ( el2 - el1 ) / 2 ; else return ( el2 - el1 ) ; } if ( st . size ( ) == 3 ) { Iterator < Integer > it = st . iterator ( ) ; int el1 = it . next ( ) ; int el2 = it . next ( ) ; int el3 = it . next ( ) ; if ( ( el2 - el1 ) == ( el3 - el2 ) ) return el2 - el1 ; else return - 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 4 , 7 , 4 , 1 } ; int n = a . length ; System . out . println ( findMinimumX ( a , n ) ) ; } }
import java . util . * ; public class GfG { private static int findX ( int n , int k ) { int r = n , v , u ; int m = ( int ) Math . sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } } return r ; } public static void main ( String args [ ] ) { int n = 5 ; int k = 2 ; System . out . println ( findX ( n , k ) ) ; } }
public class GFG { static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) System . out . println ( " Given ▁ point ▁ lies ▁ " + " inside ▁ the ▁ rectangle " ) ; else System . out . println ( " Given ▁ point ▁ does ▁ not ▁ " + " lie ▁ on ▁ the ▁ rectangle " ) ; } }
public class GFG { static int N = 1000 ; static int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ ] = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
public class GFG { static int sum , n ; static float getAvg ( int x ) { sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } static void streamAvg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( ( int ) arr [ i ] ) ; System . out . println ( " Average ▁ of ▁ " + ( i + 1 ) + " ▁ numbers ▁ is ▁ " + avg ) ; } return ; } public static void main ( String [ ] args ) { float [ ] arr = new float [ ] { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }
import java . util . * ; public class GFG { static int MAX = 10000 ; static HashSet < Integer > s = new HashSet < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . add ( product + 1 ) ; } } } static boolean isEuclid ( int n ) { if ( s . contains ( n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Collections ; import java . util . Scanner ; import java . util . Vector ; public class SS { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int b = in . nextInt ( ) ; int [ ] arr = new int [ n ] ; Vector < Integer > v = new Vector < > ( ) ; int odd = 0 , even = 0 , count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = in . nextInt ( ) ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i != 0 && odd == even ) v . add ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; if ( arr [ i ] % 2 == 0 ) { even ++ ; } else odd ++ ; } Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( b >= v . get ( i ) ) { count ++ ; b -= v . get ( i ) ; } } System . out . println ( count ) ; } }
public class GFG { static int maxOperations ( String str ) { int i , g , gk , gks ; i = g = gk = gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' g ' ) { g ++ ; } else if ( str . charAt ( i ) == ' k ' ) { if ( g > 0 ) { g -- ; gk ++ ; } } else if ( str . charAt ( i ) == ' s ' ) { if ( gk > 0 ) { gk -- ; gks ++ ; } } } return gks ; } public static void main ( String args [ ] ) { String a = " ggkssk " ; System . out . print ( maxOperations ( a ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; Arrays . sort ( a ) ; int min = a [ 0 ] , max = a [ n - 1 ] ; int res = max - min + 1 - n ; System . out . println ( res ) ; } }
import java . util . Iterator ; import java . util . LinkedList ; import java . util . Scanner ; public class Forming_Teams { int count ; boolean [ ] seen ; int path = 0 , cycle = 1 ; LinkedList < LinkedList < Integer > > graph ; public int dfs ( int child , int par ) { if ( seen [ child ] == true ) return cycle ; seen [ child ] = true ; for ( Integer i : graph . get ( child ) ) { if ( i != par ) { this . count ++ ; if ( dfs ( i , child ) == cycle ) return cycle ; } } return path ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; Forming_Teams ft = new Forming_Teams ( ) ; ft . graph = new LinkedList < > ( ) ; for ( int i = 0 ; i <= m ; i ++ ) { ft . graph . add ( new LinkedList < Integer > ( ) ) ; } ft . seen = new boolean [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; ft . graph . get ( x ) . add ( y ) ; ft . graph . get ( y ) . add ( x ) ; } int toremove = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( ! ft . seen [ i ] ) { ft . count = 0 ; if ( ft . dfs ( i , 0 ) == ft . cycle ) { if ( ft . count % 2 == 1 ) toremove ++ ; } } } if ( ( m - toremove ) % 2 == 1 ) toremove ++ ; System . out . println ( toremove ) ; } }
import java . util . Arrays ; import java . util . Collections ; public class GFG { public static int kthSmallest ( Integer [ ] arr , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; } public static void main ( String [ ] args ) { Integer arr [ ] = new Integer [ ] { 12 , 3 , 5 , 7 , 19 } ; int k = 2 ; System . out . print ( " K ' th ▁ smallest ▁ element ▁ is ▁ " + kthSmallest ( arr , k ) ) ; } }
import java . util . * ; public class ques { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int [ ] arr2 = new int [ n ] ; try { for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; arr2 [ j ] = j + 1 ; } for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( arr2 [ j ] == arr [ j ] ) { int temp = arr2 [ j ] ; arr2 [ j ] = arr2 [ j + 1 ] ; arr2 [ j + 1 ] = temp ; } } if ( arr2 [ n - 1 ] == arr [ n - 1 ] ) { int temp = arr2 [ n - 1 ] ; arr2 [ n - 1 ] = arr2 [ n - 2 ] ; arr2 [ n - 2 ] = temp ; } for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr2 [ j ] + " ▁ " ) ; } System . out . println ( ) ; } catch ( Exception e ) { System . out . println ( - 1 ) ; } } } }
import java . math . BigInteger ; public final class p329 { public static void main ( String [ ] args ) { System . out . println ( new p329 ( ) . run ( ) ) ; } private static final int START_NUM = 1 ; private static final int END_NUM = 500 ; private static final String CROAK_SEQ = " PPPPNNPPPNPPNPN " ; static { assert 0 <= START_NUM && START_NUM < END_NUM && END_NUM < Integer . MAX_VALUE ; assert 1 <= CROAK_SEQ . length ( ) && CROAK_SEQ . length ( ) <= 31 ; } private static final int NUM_JUMPS = CROAK_SEQ . length ( ) - 1 ; private static final int NUM_TRIALS = 1 << NUM_JUMPS ; public String run ( ) { long globalNumerator = 0 ; boolean [ ] isPrime = Library . listPrimality ( END_NUM ) ; for ( int i = START_NUM ; i <= END_NUM ; i ++ ) { for ( int j = 0 ; j < NUM_TRIALS ; j ++ ) { int pos = i ; int trialNumerator = 1 ; if ( isPrime [ pos ] == ( CROAK_SEQ . charAt ( 0 ) == ' P ' ) ) trialNumerator *= 2 ; for ( int k = 0 ; k < NUM_JUMPS ; k ++ ) { if ( pos <= START_NUM ) pos ++ ; else if ( pos >= END_NUM ) pos -- ; else if ( ( ( j >>> k ) & 1 ) == 0 ) pos ++ ; else pos -- ; if ( isPrime [ pos ] == ( CROAK_SEQ . charAt ( k + 1 ) == ' P ' ) ) trialNumerator *= 2 ; } globalNumerator += trialNumerator ; } } BigInteger globalDenominator = BigInteger . valueOf ( END_NUM + 1L - START_NUM ) . shiftLeft ( NUM_JUMPS ) . multiply ( BigInteger . valueOf ( 3 ) . pow ( CROAK_SEQ . length ( ) ) ) ; return new Fraction ( BigInteger . valueOf ( globalNumerator ) , globalDenominator ) . toString ( ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; double r = 6371 ; return ( c * r ) ; } public static void main ( String [ ] args ) { double lat1 = 53.32055555555556 ; double lat2 = 53.31861111111111 ; double lon1 = - 1.7297222222222221 ; double lon2 = - 1.6997222222222223 ; System . out . println ( distance ( lat1 , lat2 , lon1 , lon2 ) + " ▁ K . M " ) ; } }
import java . io . * ; public class GFG { static int centeredOctahedral ( int n ) { return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) / 3 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( centeredOctahedral ( n ) ) ; System . out . println ( ) ; n = 9 ; System . out . print ( centeredOctahedral ( n ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { static boolean [ ] isDist ; static int N ; static int M ; static int p ; public static int INF = 1 << 24 ; public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; N = stdIn . nextInt ( ) ; M = stdIn . nextInt ( ) ; p = stdIn . nextInt ( ) ; Limit = N * 50 ; isDist = new boolean [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { int d = stdIn . nextInt ( ) ; isDist [ d ] = true ; } boolean [ ] isDist2 = Arrays . copyOf ( isDist , N ) ; solv ( 1 , p , 0 , 0 , false , isDist ) ; solv ( - 1 , p , 0 , 0 , false , isDist2 ) ; System . out . println ( min ) ; } static int min = 1 << 24 ; static int Limit ; public static void solv ( int vec , int now , int coun , int cos , boolean alC , boolean [ ] isDist ) { int nowp = now ; int cost = cos ; int count = coun ; while ( true ) { if ( min <= cost ) return ; if ( nowp == N ) nowp = 0 ; else if ( nowp == - 1 ) nowp = N - 1 ; if ( count == M ) { if ( min > cost ) min = cost ; return ; } if ( isDist [ nowp ] ) { isDist [ nowp ] = false ; count ++ ; if ( ! alC && cost < Limit ) { boolean [ ] isDist2 = Arrays . copyOf ( isDist , N ) ; solv ( vec * - 1 , nowp + vec * - 1 , count , cost + 100 , true , isDist2 ) ; } } if ( count == M ) { if ( min > cost ) min = cost ; return ; } while ( true ) { if ( nowp == N ) nowp = 0 ; else if ( nowp == - 1 ) nowp = N - 1 ; if ( ! isDist [ nowp ] ) { nowp += vec ; cost += 100 ; } else { break ; } } } } }
class Solution { static int max_element ( int A [ ] ) { int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < A . length ; i ++ ) if ( max < A [ i ] ) max = A [ i ] ; return max ; } static void SumDivPrime ( int A [ ] , int n ) { int max_val = ( max_element ( A ) ) + 1 ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ A [ i ] ] ) sum += A [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ A [ i ] ] && sum % A [ i ] == 0 ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = A . length ; SumDivPrime ( A , n ) ; } }
import java . io . * ; public class GFG { static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . length ; int k = 2 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 3 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 4 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; } }
import java . io . * ; class Solution { static int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; } public static void main ( String [ ] args ) { int n = 56287 , x = 27 ; System . out . println ( closestMultiple ( n , x ) ) ; } }
import java . util . * ; public class compititive_programmer { public static void main ( String args [ ] ) { int t ; Scanner in = new Scanner ( System . in ) ; t = in . nextInt ( ) ; in . nextLine ( ) ; while ( t != 0 ) { t -- ; String s = in . nextLine ( ) ; int zero = 0 , sum = 0 , even = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += ( s . charAt ( i ) - '0' ) ; if ( s . charAt ( i ) == '0' ) zero ++ ; if ( s . charAt ( i ) % 2 == 0 && s . charAt ( i ) != '0' ) even ++ ; } if ( zero != s . length ( ) && ( ( even == 0 && zero == 1 ) || zero == 0 || sum % 3 != 0 ) ) System . out . println ( " cyan " ) ; else System . out . println ( " red " ) ; } } }
import java . util . Arrays ; public class GFG { static int dp [ ] [ ] = new int [ 901 ] [ 8101 ] ; static int minimumNumberOfDigits ( int a , int b ) { if ( a > b || a < 0 || b < 0 || a > 900 || b > 8100 ) { return - 1 ; } if ( a == 0 && b == 0 ) { return 0 ; } if ( dp [ a ] [ b ] != - 1 ) { return dp [ a ] [ b ] ; } int ans = 101 ; for ( int i = 9 ; i >= 1 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != - 1 ) { ans = Math . min ( ans , k + 1 ) ; } } return dp [ a ] [ b ] = ans ; } static void printSmallestNumber ( int a , int b ) { for ( int [ ] row : dp ) { Arrays . fill ( row , - 1 ) ; } dp [ 0 ] [ 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( k == - 1 || k > 100 ) { System . out . println ( " - 1" ) ; } else { while ( a > 0 && b > 0 ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) { System . out . print ( i ) ; a -= i ; b -= i * i ; break ; } } } } } public static void main ( String args [ ] ) { int a = 18 , b = 162 ; printSmallestNumber ( a , b ) ; } }
import java . util . * ; public class GFG { static final int N = 5005 ; static int n , k ; static Vector < Integer > [ ] gr = new Vector [ N ] ; static int [ ] [ ] d = new int [ N ] [ 505 ] ; static int ans = 0 ; static void Add_edge ( int x , int y ) { gr [ x ] . add ( y ) ; gr [ y ] . add ( x ) ; } static void dfs ( int v , int par ) { d [ v ] [ 0 ] = 1 ; for ( Integer i : gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } } public static void main ( String [ ] args ) { n = 5 ; k = 2 ; for ( int i = 0 ; i < N ; i ++ ) gr [ i ] = new Vector < Integer > ( ) ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; System . out . print ( ans ) ; } }
import java . util . * ; public class GFG { static int findSubsequence ( int arr [ ] , int n ) { int len = 1 ; int tmp ; int i , j , d ; int dp [ ] = new int [ 10 ] ; int cnt [ ] = new int [ 10 ] ; int locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; Arrays . fill ( cnt , 0 ) ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] == 1 ) { dp [ d ] ++ ; locMax = Math . max ( locMax , dp [ d ] ) ; } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] == 1 ) { dp [ d ] = locMax ; } } len = Math . max ( len , locMax ) ; } return len ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , 44 , 29 , 33 , 96 , 89 } ; int n = arr . length ; System . out . print ( findSubsequence ( arr , n ) ) ; } }
import java . util . HashSet ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = input . nextInt ( ) ; int m = input . nextInt ( ) ; HashSet < Integer > set = new HashSet < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { set . add ( input . nextInt ( ) ) ; } int count = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( set . add ( input . nextInt ( ) ) == false ) count ++ ; } System . out . println ( count ) ; } } }
public class GCD { static int totalPrimeFactors ( int n ) { int count = 0 ; if ( ( n % 2 == 0 ) ) { count ++ ; while ( ( n % 2 == 0 ) ) n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { if ( ( n % i == 0 ) ) count ++ ; while ( ( n % i == 0 ) ) n /= 2 ; } if ( n > 2 ) count ++ ; return count ; } static int countPairs ( int G , int L ) { if ( L % G != 0 ) return 0 ; int div = L / G ; return ( 1 << totalPrimeFactors ( div ) ) ; } public static void main ( String [ ] args ) { int G = 2 , L = 12 ; System . out . print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + G ) ; System . out . print ( " ▁ & ▁ LCM ▁ " + L ) ; System . out . print ( " ▁ = ▁ " + countPairs ( G , L ) ) ; } }
public class GFG { static int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } public static void main ( String [ ] args ) { int a = 7 , N = 49 ; System . out . println ( " Sum ▁ of ▁ multiples ▁ of ▁ " + a + " ▁ up ▁ to ▁ " + N + " ▁ = ▁ " + calculate_sum ( a , N ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Map ; import java . util . StringTokenizer ; import java . util . TreeMap ; public class Transmigration { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int m = Integer . parseInt ( st . nextToken ( ) ) ; int k = Integer . parseInt ( st . nextToken ( ) . substring ( 2 ) ) ; TreeMap < String , Integer > skills = new TreeMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; String skillName = st . nextToken ( ) ; int skillScore = Integer . parseInt ( st . nextToken ( ) ) ; int newSkillScore = skillScore * k / 100 ; if ( newSkillScore < 100 ) continue ; skills . put ( skillName , newSkillScore ) ; } for ( int i = 0 ; i < m ; i ++ ) { String skillName = br . readLine ( ) ; if ( skills . containsKey ( skillName ) ) continue ; skills . put ( skillName , 0 ) ; } pw . println ( skills . size ( ) ) ; for ( Map . Entry < String , Integer > skill : skills . entrySet ( ) ) pw . println ( skill . getKey ( ) + " ▁ " + skill . getValue ( ) ) ; pw . flush ( ) ; pw . close ( ) ; } }
import java . io . * ; public class GFG { static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }
public class GFG { private static int next ( int [ ] arr , int target ) { int start = 0 , end = arr . length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 5 , 8 , 12 } ; System . out . println ( next ( arr , 8 ) ) ; } }
public class GFG { static String word [ ] = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; static void printWordsWithoutIfSwitch ( int n ) { int digits [ ] = new int [ 10 ] ; int dc = 0 ; do { digits [ dc ] = n % 10 ; n = n / 10 ; dc ++ ; } while ( n != 0 ) ; for ( int i = dc - 1 ; i >= 0 ; i -- ) System . out . print ( word [ digits [ i ] ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 350 ; printWordsWithoutIfSwitch ( n ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; long k = Integer . parseInt ( st . nextToken ( ) ) ; long m = Integer . parseInt ( st . nextToken ( ) ) ; long [ ] a = new long [ n ] ; st = new StringTokenizer ( f . readLine ( ) ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; sum += a [ i ] ; } Arrays . sort ( a ) ; double max = ( sum + Math . min ( m , n * k ) ) / ( double ) n ; for ( int i = 1 ; i < Math . min ( n , m + 1 ) ; i ++ ) { sum -= a [ i - 1 ] ; max = Math . max ( max , ( sum + Math . min ( m - i , ( n - i ) * k ) ) / ( double ) ( n - i ) ) ; } out . printf ( " % .20f \n " , max ) ; f . close ( ) ; out . close ( ) ; } }
public class GFG { static void solve ( char [ ] a , char [ ] b ) { int l = a . length ; int min = 0 , max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' + ' || b [ i ] == ' + ' || a [ i ] != b [ i ] ) max ++ ; if ( a [ i ] != ' + ' && b [ i ] != ' + ' && a [ i ] != b [ i ] ) min ++ ; } System . out . print ( min + max + " \n " ) ; } public static void main ( String [ ] args ) { String s1 = " a + c " , s2 = " + + b " ; solve ( s1 . toCharArray ( ) , s2 . toCharArray ( ) ) ; } }
public class GFG { static int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; } public static void main ( String [ ] args ) { int n = 5 ; int k = 2 ; int s = 2 ; System . out . print ( " Total ▁ Ways ▁ = ▁ " + TotalWays ( n , s , k ) ) ; } }
import java . io . * ; public class GFG { static int countEvenOdd ( int n ) { int even_count = 0 ; int odd_count = 0 ; while ( n > 0 ) { int rem = n % 10 ; if ( rem % 2 == 0 ) even_count ++ ; else odd_count ++ ; n = n / 10 ; } System . out . println ( " Even ▁ count ▁ : ▁ " + even_count ) ; System . out . println ( " Odd ▁ count ▁ : ▁ " + odd_count ) ; if ( even_count % 2 == 0 && odd_count % 2 != 0 ) return 1 ; else return 0 ; } public static void main ( String [ ] args ) { int n ; n = 2335453 ; int t = countEvenOdd ( n ) ; if ( t == 1 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; List < Integer > [ ] lists = new ArrayList [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) lists [ i ] = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int c = scanner . nextInt ( ) ; int g = scanner . nextInt ( ) - 1 ; lists [ g ] . add ( c ) ; } int [ ] dp = new int [ k + 1 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { Collections . sort ( lists [ i ] , Collections . reverseOrder ( ) ) ; ; for ( int j = k - 1 ; j >= 0 ; j -- ) { if ( dp [ j ] == - 1 ) continue ; int sum = 0 ; for ( int l = 0 ; l < lists [ i ] . size ( ) && j + l < k ; l ++ ) { sum += lists [ i ] . get ( l ) ; dp [ j + l + 1 ] = Math . max ( dp [ j + l + 1 ] , dp [ j ] + sum + ( l + 1 ) * l ) ; } } } System . out . println ( dp [ k ] ) ; } }
import java . util . * ; public class GFG { static class Point { int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } } ; static int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; } public static void main ( String [ ] args ) { Point p [ ] = { new Point ( 1 , 1 ) , new Point ( 2 , 2 ) , new Point ( - 1 , - 1 ) , new Point ( - 2 , 2 ) } ; int n = p . length ; System . out . println ( findmin ( p , n ) ) ; } }
import java . util . * ; class Solution { static int maxGCD ( int N , int P ) { int ans = 1 ; Map < Integer , Integer > prime_factors = new HashMap < Integer , Integer > ( ) ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { if ( prime_factors . get ( i ) == null ) prime_factors . put ( i , 1 ) ; else prime_factors . put ( i , ( prime_factors . get ( i ) + 1 ) ) ; P /= i ; } } if ( P != 1 ) if ( prime_factors . get ( P ) == null ) prime_factors . put ( P , 1 ) ; else prime_factors . put ( P , ( prime_factors . get ( P ) + 1 ) ) ; Set < Map . Entry < Integer , Integer > > st = prime_factors . entrySet ( ) ; for ( Map . Entry < Integer , Integer > me : st ) { ans *= Math . pow ( me . getKey ( ) , me . getValue ( ) / N ) ; } return ans ; } public static void main ( String args [ ] ) { int N = 3 , P = 24 ; System . out . println ( maxGCD ( N , P ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int mask [ ] = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { mask [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < Math . pow ( 2 , k ) ; i ++ ) { int bitArray [ ] = new int [ n ] ; int temp = i ; int index = 0 ; for ( int j = 0 ; temp > 0 ; j ++ ) { if ( temp % 2 == 1 ) { bitArray [ mask [ j ] ] = 1 ; index += Math . pow ( 2 , mask [ j ] ) ; } temp /= 2 ; } System . out . print ( index + " : " ) ; for ( int j = 0 ; j < k ; j ++ ) { if ( bitArray [ mask [ j ] ] == 1 ) System . out . print ( " ▁ " + mask [ j ] ) ; } System . out . println ( ) ; } } }
import java . util . * ; public class GFG { static class primeFactorization { int countOfPf , primeFactor ; public primeFactorization ( int countOfPf , int primeFactor ) { this . countOfPf = countOfPf ; this . primeFactor = primeFactor ; } } static void generateDivisors ( int curIndex , int curDivisor , Vector < primeFactorization > arr ) { if ( curIndex == arr . size ( ) ) { System . out . print ( curDivisor + " ▁ " ) ; return ; } for ( int i = 0 ; i <= arr . get ( curIndex ) . countOfPf ; ++ i ) { generateDivisors ( curIndex + 1 , curDivisor , arr ) ; curDivisor *= arr . get ( curIndex ) . primeFactor ; } } static void findDivisors ( int n ) { Vector < primeFactorization > arr = new Vector < > ( ) ; for ( int i = 2 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count += 1 ; } arr . add ( new primeFactorization ( count , i ) ) ; } } if ( n > 1 ) { arr . add ( new primeFactorization ( 1 , n ) ) ; } int curIndex = 0 , curDivisor = 1 ; generateDivisors ( curIndex , curDivisor , arr ) ; } public static void main ( String [ ] args ) { int n = 6 ; findDivisors ( n ) ; } }
import java . io . * ; import java . util . * ; public class Chain { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int max = 0 ; int n = sc . nextInt ( ) ; int [ ] beacon = new int [ 1000001 ] ; int [ ] dp = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; beacon [ a ] = sc . nextInt ( ) ; } if ( beacon [ 0 ] != 0 ) dp [ 0 ] = 1 ; for ( int i = 1 ; i < 1000001 ; i ++ ) { if ( beacon [ i ] != 0 && beacon [ i ] < i ) { dp [ i ] = dp [ i - beacon [ i ] - 1 ] + 1 ; } else if ( beacon [ i ] != 0 ) { dp [ i ] = 1 ; } else { dp [ i ] = dp [ i - 1 ] ; } max = Math . max ( max , dp [ i ] ) ; } System . out . print ( n - max ) ; } }
public class GFG { static String largestPalinSub ( String s ) { String res = " " ; char mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = ( char ) Math . max ( ( int ) mx , ( int ) s . charAt ( i ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == mx ) res += s . charAt ( i ) ; return res ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( largestPalinSub ( s ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; StringBuffer s = new StringBuffer ( sc . next ( ) ) ; int count ; int t = 0 ; StringBuffer u = new StringBuffer ( ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = 1 ; t = s . charAt ( i ) ; while ( i < s . length ( ) - 1 && s . charAt ( i + 1 ) == t ) { i ++ ; count ++ ; } u . append ( count ) ; u . append ( ( char ) t ) ; } s = new StringBuffer ( u ) ; u . delete ( 0 , u . length ( ) ) ; } System . out . println ( s ) ; } } }
import java . io . PrintWriter ; import java . util . * ; public class Good_seq { static Scanner sc = new Scanner ( System . in ) ; static PrintWriter pw = new PrintWriter ( System . out ) ; static int dp [ ] = new int [ 100001 ] ; public static ArrayList < Integer > factoriseopt ( int n ) { ArrayList < Integer > ans = new ArrayList < > ( ) ; if ( n == 1 ) { ans . add ( 1 ) ; return ans ; } for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } ans . add ( i ) ; } } if ( n != 1 ) ans . add ( n ) ; return ans ; } public static void main ( String [ ] args ) { int n = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > ansArrayList = factoriseopt ( arr [ i ] ) ; int best = 0 ; for ( int x : ansArrayList ) { best = Math . max ( best , dp [ x ] ) ; } for ( int x : ansArrayList ) { dp [ x ] = best + 1 ; } } int maxsofar = 0 ; for ( int x : dp ) { maxsofar = Math . max ( maxsofar , x ) ; } System . out . println ( maxsofar ) ; } }
public class GFG { static void initializeDiffArray ( int A [ ] , int D [ ] ) { int n = A . length ; D [ 0 ] = A [ 0 ] ; D [ n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) D [ i ] = A [ i ] - A [ i - 1 ] ; } static void update ( int D [ ] , int l , int r , int x ) { D [ l ] += x ; D [ r + 1 ] -= x ; } static int printArray ( int A [ ] , int D [ ] ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( i == 0 ) A [ i ] = D [ i ] ; else A [ i ] = D [ i ] + A [ i - 1 ] ; System . out . print ( A [ i ] + " ▁ " ) ; } System . out . println ( ) ; return 0 ; } public static void main ( String [ ] args ) { int A [ ] = { 10 , 5 , 20 , 40 } ; int n = A . length ; int D [ ] = new int [ n + 1 ] ; initializeDiffArray ( A , D ) ; update ( D , 0 , 1 , 10 ) ; printArray ( A , D ) ; update ( D , 1 , 3 , 20 ) ; update ( D , 2 , 2 , 30 ) ; printArray ( A , D ) ; } }
import java . util . * ; public class GFG { static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; } public static void main ( String [ ] args ) { int arrl [ ] = { 1 , 2 , 10 , 5 , 5 } ; int exit [ ] = { 4 , 5 , 12 , 9 , 12 } ; int n = arrl . length ; findMaxGuests ( arrl , exit , n ) ; } }
import java . util . Scanner ; public class Main { Scanner sc = new Scanner ( System . in ) ; void run ( ) { for ( ; ; ) { String in = sc . next ( ) ; if ( in . equals ( " # END " ) ) { return ; } String ans = " " ; for ( int i = 1 ; i < in . length ( ) ; i ++ ) { String lcs = lcs ( in . substring ( 0 , i ) , in . substring ( i , in . length ( ) ) ) ; if ( lcs . length ( ) > ans . length ( ) ) { ans = lcs ; } } System . out . println ( ans ) ; } } String lcs ( String s , String t ) { int n = s . length ( ) ; int m = t . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( s . charAt ( i ) == t . charAt ( j ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + 1 ; } else { dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; } } } char [ ] res = new char [ dp [ n ] [ m ] ] ; while ( n > 0 && m > 0 ) { if ( dp [ n ] [ m ] == dp [ n - 1 ] [ m ] ) { n -- ; } else if ( dp [ n ] [ m ] == dp [ n ] [ m - 1 ] ) { m -- ; } else { res [ dp [ n - 1 ] [ m - 1 ] ] = s . charAt ( n - 1 ) ; n -- ; m -- ; } } return String . valueOf ( res ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
public class GFG { static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; } public static void main ( String [ ] args ) { int n = 6 , r = 2 ; System . out . println ( "1 / " + calcFunction ( n , r ) ) ; } }
import java . util . * ; public class GFG { static void isPerfectSquare ( int x ) { int sr = ( int ) Math . sqrt ( x ) ; if ( sr * sr == x ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String args [ ] ) { int n = 7 , k = 2 ; isPerfectSquare ( n + k ) ; } }
import java . util . * ; public class Main { final static int NUM = ( int ) ( 1e5 + 2 ) ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; PriorityQueue < Integer > nums = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int tmp = sc . nextInt ( ) ; nums . add ( tmp ) ; map . put ( tmp , i ) ; } int bin = 0 ; int diff = 0 ; while ( ! nums . isEmpty ( ) ) { int num = nums . poll ( ) ; int idx = map . get ( num ) ; if ( ( bin % 2 ) != ( idx % 2 ) ) { diff ++ ; } bin ++ ; bin %= 2 ; } int ans = ( diff / 2 ) ; System . out . println ( ans ) ; } }
import java . io . PrintWriter ; import java . util . * ; import java . util . stream . Collectors ; public class A { public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ) { int n = in . nextInt ( ) ; List < Integer > a = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int value = in . nextInt ( ) ; a . add ( value ) ; } a = a . stream ( ) . distinct ( ) . sorted ( ) . collect ( Collectors . toList ( ) ) ; boolean found = false ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( i + 1 < a . size ( ) && i + 2 < a . size ( ) ) { if ( a . get ( i ) + 1 == a . get ( i + 1 ) && a . get ( i + 1 ) + 1 == a . get ( i + 2 ) ) { found = true ; } } } out . println ( found ? " YES " : " NO " ) ; } } }
import java . util . ArrayList ; import java . util . Scanner ; public class Main { static boolean check ( ArrayList < Integer > b ) { if ( b . get ( 0 ) != 1 ) { return false ; } for ( int i = 1 ; i < b . size ( ) ; i ++ ) { if ( b . get ( i - 1 ) != b . get ( i ) - 1 ) { return false ; } } return true ; } static boolean gap ( ArrayList < Integer > b ) { for ( int i = 0 ; i < b . size ( ) ; i ++ ) { if ( b . get ( i ) <= 0 ) { return false ; } } return true ; } static void removeGap ( ArrayList < Integer > b ) { for ( int i = 0 ; i < b . size ( ) ; i ++ ) { if ( b . get ( i ) <= 0 ) { b . remove ( i ) ; i -- ; continue ; } } b . trimToSize ( ) ; } public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; while ( true ) { int N = stdIn . nextInt ( ) ; if ( N == 0 ) { break ; } for ( int i = 0 ; i < N ; i ++ ) { list . add ( stdIn . nextInt ( ) ) ; } int c = 0 ; while ( ! check ( list ) && c < 10000 ) { c ++ ; if ( gap ( list ) ) { int size = list . size ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { list . set ( i , list . get ( i ) - 1 ) ; } list . add ( size ) ; } removeGap ( list ) ; } System . out . println ( ( check ( list ) ) ? c : - 1 ) ; list . clear ( ) ; list . trimToSize ( ) ; System . gc ( ) ; } } }
import java . util . * ; public class GFG { public static boolean isDivisible ( String S ) { int n = S . length ( ) ; if ( S . charAt ( n - 1 ) != '5' && S . charAt ( n - 1 ) != '0' ) return false ; int sum = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) sum += ( int ) S . charAt ( i ) ; if ( sum % 3 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { String S = "15645746327462384723984023940239" ; if ( isDivisible ( S ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; String S1 = "15645746327462384723984023940235" ; if ( isDivisible ( S1 ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public final class p142 { public static void main ( String [ ] args ) { System . out . println ( new p142 ( ) . run ( ) ) ; } private boolean [ ] isSquare ; public String run ( ) { int sumLimit = 10 ; while ( true ) { isSquare = new boolean [ sumLimit ] ; for ( int i = 0 ; i * i < sumLimit ; i ++ ) isSquare [ i * i ] = true ; int sum = findSum ( sumLimit ) ; if ( sum != - 1 ) { sum = sumLimit ; break ; } sumLimit *= 10 ; } while ( true ) { int sum = findSum ( sumLimit ) ; if ( sum == - 1 ) return Integer . toString ( sumLimit ) ; sumLimit = sum ; } } private int findSum ( int limit ) { for ( int a = 1 ; a * a < limit ; a ++ ) { for ( int b = a - 1 ; b > 0 ; b -- ) { if ( ( a + b ) % 2 != 0 ) continue ; int x = ( a * a + b * b ) / 2 ; int y = ( a * a - b * b ) / 2 ; if ( x + y + 1 >= limit ) continue ; int zlimit = Math . min ( y , limit - x - y ) ; for ( int c = Library . sqrt ( y ) + 1 ; c * c - y < zlimit ; c ++ ) { int z = c * c - y ; if ( isSquare [ x + z ] && isSquare [ x - z ] && isSquare [ y - z ] ) return x + y + z ; } } } return - 1 ; } }
public class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } static String encryptString ( String s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; String ans = " " ; for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s . charAt ( r ) ) == true ) { countVowels ++ ; } else { countConsonants ++ ; } } ans += String . valueOf ( countVowels * countConsonants ) ; } return ans ; } static public void main ( String [ ] args ) { String s = " hello " ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encryptString ( s , n , k ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; while ( in . hasNext ( ) ) { int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; String S = in . next ( ) ; String T = in . next ( ) ; int gcdNM = gcd ( N , M ) ; long lcmNM = ( ( long ) N / gcd ( N , M ) ) * M ; int stepS = M / gcdNM ; int stepT = N / gcdNM ; int curS = 0 ; int curT = 0 ; boolean isExisted = true ; while ( curS < S . length ( ) && curT < T . length ( ) ) { int idxXS = curS * stepS + 1 ; int idxXT = curT * stepT + 1 ; if ( idxXS == idxXT ) { if ( S . charAt ( curS ) != T . charAt ( curT ) ) { isExisted = false ; break ; } else { ++ curS ; ++ curT ; } } else if ( idxXS < idxXT ) { ++ curS ; } else if ( idxXT < idxXS ) { ++ curT ; } } if ( isExisted ) { System . out . println ( lcmNM ) ; } else { System . out . println ( - 1 ) ; } } } public static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
import java . util . Scanner ; public class B203 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; int [ ] [ ] black = new int [ N + 2 ] [ N + 2 ] ; for ( int m = 1 ; m <= M ; m ++ ) { int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; for ( int xx = x - 1 ; xx <= x + 1 ; xx ++ ) { for ( int yy = y - 1 ; yy <= y + 1 ; yy ++ ) { if ( ++ black [ xx ] [ yy ] == 9 ) { System . out . println ( m ) ; return ; } } } } System . out . println ( " - 1" ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { int dx [ ] = { 1 , 1 , 0 , - 1 , } ; int dy [ ] = { 0 , 1 , 1 , 1 } ; Scanner in = new Scanner ( System . in ) ; for ( ; ; ) { int n = in . nextInt ( ) ; if ( n == 0 ) return ; int a [ ] [ ] = new int [ n ] [ n ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; for ( int j = 0 ; j < n ; j ++ ) a [ i ] [ j ] = Integer . valueOf ( s . charAt ( j ) - '0' ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { int cnt = 0 ; int sy = i ; int sx = j ; while ( 0 <= sx && sx < n && sy < n && a [ sy ] [ sx ] == 1 ) { cnt ++ ; sx += dx [ k ] ; sy += dy [ k ] ; } ans = Math . max ( ans , cnt ) ; } } System . out . println ( ans ) ; } } }
import java . io . * ; import java . util . * ; public class GFG { static long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fourthPowerSum ( n ) ) ; } }
import java . util . HashMap ; public class GFG { public static int maxLengthSub ( int [ ] arr ) { int max_val = 0 ; int start = 0 ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int temp = 0 ; if ( map . containsKey ( arr [ i ] - 1 ) ) { temp = map . get ( arr [ i ] - 1 ) ; } if ( map . containsKey ( arr [ i ] ) ) { temp = Math . max ( temp , map . get ( arr [ i ] ) ) ; } if ( map . containsKey ( arr [ i ] + 1 ) ) { temp = Math . max ( temp , map . get ( arr [ i ] + 1 ) ) ; } temp ++ ; if ( temp > max_val ) { max_val = temp ; } map . put ( arr [ i ] , temp ) ; } return max_val ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; System . out . println ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " + maxLengthSub ( arr ) ) ; } }
import java . io . * ; public class GFG { public static void rearrange ( int [ ] arr ) { if ( arr == null || arr . length % 2 == 1 ) return ; int currIdx = ( arr . length - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ; rearrange ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( " ▁ " + arr [ i ] ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; long INF = 1 << 58 ; while ( true ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( ( n | k ) == 0 ) break ; long fare [ ] [ ] = new long [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( fare [ i ] , INF ) ; fare [ i ] [ i ] = 0 ; } for ( int i = 0 ; i < k ; i ++ ) { int init = sc . nextInt ( ) ; if ( init == 1 ) { int c = sc . nextInt ( ) - 1 ; int d = sc . nextInt ( ) - 1 ; int e = sc . nextInt ( ) ; if ( e < fare [ c ] [ d ] ) { fare [ c ] [ d ] = fare [ d ] [ c ] = e ; for ( int p = 0 ; p < n ; p ++ ) { for ( int q = 0 ; q < n ; q ++ ) { fare [ p ] [ q ] = Math . min ( fare [ p ] [ q ] , fare [ p ] [ c ] + fare [ c ] [ d ] + fare [ d ] [ q ] ) ; fare [ p ] [ q ] = Math . min ( fare [ p ] [ q ] , fare [ p ] [ d ] + fare [ c ] [ d ] + fare [ c ] [ q ] ) ; } } } } else { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; System . out . println ( fare [ a ] [ b ] != INF ? fare [ a ] [ b ] : - 1 ) ; } } } } }
import java . io . * ; public class GFG { static void countCharacterType ( String str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) { ch = Character . toLowerCase ( ch ) ; ; if ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } System . out . println ( " Vowels : ▁ " + vowels ) ; System . out . println ( " Consonant : ▁ " + consonant ) ; System . out . println ( " Digit : ▁ " + digit ) ; System . out . println ( " Special ▁ Character : ▁ " + specialChar ) ; } static public void main ( String [ ] args ) { String str = " geeks ▁ for ▁ geeks121" ; countCharacterType ( str ) ; } }
public class GFG { static double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; } public static void main ( String [ ] args ) { double l = 50 , b = 20 , h = 10 ; System . out . println ( increaseInVol ( l , b , h ) + " % " ) ; } }
import java . io . * ; import java . util . Arrays ; public class GFG { static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; } public static void main ( String args [ ] ) { int [ ] a = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 } ; int n = a . length ; System . out . print ( MaxTotalRectangleArea ( a , n ) ) ; } }
public class GFG { static class Node { int data ; Node next , prev ; } ; static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; return newNode ; } static Node insertEnd ( Node head , Node new_node ) { if ( head == null ) { new_node . next = new_node . prev = new_node ; head = new_node ; return head ; } Node last = ( head ) . prev ; new_node . next = head ; ( head ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return head ; } static Node reverse ( Node head ) { if ( head == null ) return null ; Node new_head = null ; Node last = head . prev ; Node curr = last , prev ; while ( curr . prev != last ) { prev = curr . prev ; new_head = insertEnd ( new_head , curr ) ; curr = prev ; } new_head = insertEnd ( new_head , curr ) ; return new_head ; } static void display ( Node head ) { if ( head == null ) return ; Node temp = head ; System . out . print ( " Forward ▁ direction : ▁ " ) ; while ( temp . next != head ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } System . out . print ( temp . data + " ▁ " ) ; Node last = head . prev ; temp = last ; System . out . print ( " \n Backward ▁ direction : ▁ " ) ; while ( temp . prev != last ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . prev ; } System . out . print ( temp . data + " ▁ " ) ; } public static void main ( String args [ ] ) { Node head = null ; head = insertEnd ( head , getNode ( 1 ) ) ; head = insertEnd ( head , getNode ( 2 ) ) ; head = insertEnd ( head , getNode ( 3 ) ) ; head = insertEnd ( head , getNode ( 4 ) ) ; head = insertEnd ( head , getNode ( 5 ) ) ; System . out . print ( " Current ▁ list : \n " ) ; display ( head ) ; head = reverse ( head ) ; System . out . print ( " \n \n Reversed ▁ list : \n " ) ; display ( head ) ; } }
public class GFG { static void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int n = 12345 ; lastFiveDigits ( n ) ; } }
import java . math . BigInteger ; public final class p080 { public static void main ( String [ ] args ) { System . out . println ( new p080 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i <= 100 ; i ++ ) { BigInteger x = BigInteger . valueOf ( i ) ; x = x . multiply ( BigInteger . TEN . pow ( 100 * 2 ) ) ; BigInteger y = sqrt ( x ) ; if ( ! y . multiply ( y ) . equals ( x ) ) { String s = y . toString ( ) . substring ( 0 , 100 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) sum += s . charAt ( j ) - '0' ; } } return Integer . toString ( sum ) ; } private static BigInteger sqrt ( BigInteger x ) { int i = 0 ; while ( BigInteger . TEN . pow ( i * 2 ) . compareTo ( x ) <= 0 ) i ++ ; BigInteger y = BigInteger . ZERO ; for ( ; i >= 0 ; i -- ) { int j ; BigInteger delta = null ; for ( j = 9 ; j >= 0 ; j -- ) { BigInteger temp = BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ; delta = y . shiftLeft ( 1 ) . add ( temp ) . multiply ( temp ) ; if ( delta . compareTo ( x ) <= 0 ) break ; } if ( j < 0 ) throw new AssertionError ( ) ; x = x . subtract ( delta ) ; y = y . add ( BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ) ; } return y ; } }
import java . io . * ; public class GFG { static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( " No ▁ Pythagoras ▁ " + " Triplet ▁ exists " ) ; else if ( n % 2 == 0 ) { int var = 1 * n * n / 4 ; System . out . print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " ) ; System . out . print ( n + " ▁ " ) ; System . out . print ( var - 1 + " ▁ " ) ; System . out . println ( var + 1 + " ▁ " ) ; } else if ( n % 2 != 0 ) { int var = 1 * n * n + 1 ; System . out . print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " ) ; System . out . print ( n + " ▁ " ) ; System . out . print ( var / 2 - 1 + " ▁ " ) ; System . out . println ( var / 2 + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 22 ; evaluate ( n ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long x = sc . nextLong ( ) ; long count = 0 ; count += b / x + 1 ; if ( a != 0 ) { count -= ( a - 1 ) / x + 1 ; } System . out . println ( count ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findNumber ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 2 , 4 } ; int n = arr . length ; System . out . println ( findNumber ( arr , n ) ) ; } }
public class GFG { static int countKdivPairs ( int A [ ] , int n , int K ) { int [ ] freq = new int [ K ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; if ( rem != 0 ) ans += freq [ K - rem ] ; else ans += freq [ 0 ] ; freq [ rem ] ++ ; } return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 2 , 1 , 7 , 5 , 3 } ; int n = A . length ; int K = 4 ; System . out . println ( countKdivPairs ( A , n , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; scanner . useDelimiter ( " , " ) ; String a = scanner . next ( ) ; String b = scanner . next ( ) ; String c = scanner . next ( ) ; System . out . println ( a + " ▁ " + b + " ▁ " + c ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] nums = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { nums [ i ] = sc . nextInt ( ) ; } int l = 0 , r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( l == 0 && nums [ n - i - 1 ] != nums [ 0 ] ) { l = n - i - 1 ; } if ( r == 0 && nums [ i ] != nums [ n - 1 ] ) { r = n - i - 1 ; } } System . out . println ( Math . max ( l , r ) ) ; } }
public class GFG { static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 } ; int n = arr . length ; System . out . println ( " Total ▁ Number ▁ of ▁ Even - Odd " + " ▁ subarrays ▁ are ▁ " + countSubarrays ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int SIZE = 26 ; static void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 0 ) { System . out . print ( str . charAt ( i ) ) ; } } } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; printChar ( str , n ) ; } }
public class GFG { public static void printChar ( String str , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; printChar ( str , n ) ; } }
public class GFG { static int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 } ; int n = arr . length ; int k = 7 ; System . out . println ( countGreater ( arr , n , k ) ) ; } }
import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; int MOD = 1000000 ; int [ ] [ ] es = { { 0 , 1 , 2 , 3 } , { 0 , 1 , 2 } , { 0 , 1 , 2 , 4 } , { 2 , 3 } , { 0 , 4 } } ; int len = 5 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) , w = sc . nextInt ( ) ; if ( w == 1 ) { int ret = 1 ; for ( int i = 0 ; i < h ; i ++ ) ret = ret * 2 % MOD ; System . out . println ( ret ) ; return ; } int [ ] [ ] cnt = new int [ 2 ] [ len ] ; cnt [ 0 ] [ 0 ] = 1 ; int p = 1 ; for ( int i = 0 ; i <= h ; i ++ ) { fill ( cnt [ p ] , 0 ) ; for ( int j = 0 ; j < len ; j ++ ) for ( int k = 0 ; k < es [ j ] . length ; k ++ ) { cnt [ p ] [ es [ j ] [ k ] ] = ( cnt [ p ] [ es [ j ] [ k ] ] + cnt [ 1 - p ] [ j ] ) % MOD ; } p = 1 - p ; } System . out . println ( cnt [ 1 - p ] [ 2 ] ) ; } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
public class GFG { static void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { System . out . println ( " NO " ) ; return ; } double a = ( N + Math . sqrt ( val ) ) / 2.0 ; double b = ( N - Math . sqrt ( val ) ) / 2.0 ; System . out . println ( " a ▁ = ▁ " + a ) ; System . out . println ( " b ▁ = ▁ " + b ) ; } public static void main ( String [ ] args ) { double N = 69.0 ; findAandB ( N ) ; } }
import java . util . * ; public class submitfinal { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t != 0 ) { int n = sc . nextInt ( ) ; int x , y ; int temp1 = Integer . MIN_VALUE , temp2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; ++ i ) { x = sc . nextInt ( ) ; y = sc . nextInt ( ) ; temp1 = Math . max ( temp1 , x ) ; temp2 = Math . min ( temp2 , y ) ; } System . out . println ( Math . max ( 0 , ( temp1 - temp2 ) ) ) ; t -- ; } } }
import java . util . * ; public class Main { static Set < String > set = new HashSet < String > ( ) ; static int n , m ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; n = in . nextInt ( ) ; m = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String str = in . next ( ) ; if ( str . contains ( " X " ) ) set . add ( str ) ; } if ( set . size ( ) == 1 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static final long MOD = 1000000007 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { char [ ] aa = sc . next ( ) . toCharArray ( ) ; if ( aa [ 0 ] == '0' ) { break ; } char [ ] bb = sc . next ( ) . toCharArray ( ) ; char [ ] cc = sc . next ( ) . toCharArray ( ) ; int n = aa . length ; long [ ] [ ] dp = new long [ n + 1 ] [ 2 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int da = aa [ n - i ] == ' ? ' ? - 1 : aa [ n - i ] - '0' ; int db = bb [ n - i ] == ' ? ' ? - 1 : bb [ n - i ] - '0' ; int dc = cc [ n - i ] == ' ? ' ? - 1 : cc [ n - i ] - '0' ; for ( int j = 0 ; j < 2 ; j ++ ) { for ( int carry = 0 ; carry < 2 ; carry ++ ) { int patterns = 0 ; for ( int a = 0 ; a < 10 ; a ++ ) { if ( da != - 1 && da != a ) { continue ; } for ( int b = 0 ; b < 10 ; b ++ ) { if ( db != - 1 && db != b ) { continue ; } int c = a + b + carry ; if ( ( j == 0 && c >= 10 ) || ( j == 1 && c < 10 ) ) { continue ; } if ( i == n ) { if ( a * b * c == 0 ) { continue ; } } if ( dc == - 1 || dc == c % 10 ) { patterns ++ ; } } } dp [ i ] [ j ] += dp [ i - 1 ] [ carry ] * patterns % MOD ; dp [ i ] [ j ] %= MOD ; } } } System . out . println ( dp [ n ] [ 0 ] ) ; } } }
import java . util . Scanner ; public class Multiply { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int a = sc . nextInt ( ) ; int two = 0 ; int three = 0 ; while ( a % 2 == 0 ) { a = a / 2 ; two ++ ; } while ( a % 3 == 0 ) { a = a / 3 ; three ++ ; } if ( a == 1 ) { if ( three >= two ) { int temp = two ; three -= two ; temp += three * 2 ; System . out . println ( temp ) ; } else { System . out . println ( " - 1" ) ; } } else { System . out . println ( " - 1" ) ; } } } }
import java . util . * ; public class GFG { static int minIncrementForUnique ( int [ ] A ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i : A ) { if ( mpp . containsKey ( i ) ) mpp . put ( i , mpp . get ( i ) + 1 ) ; else mpp . put ( i , 1 ) ; } Vector < Integer > taken = new Vector < Integer > ( ) ; int ans = 0 ; for ( int x = 0 ; x < 100000 ; x ++ ) { if ( mpp . containsKey ( x ) && mpp . get ( x ) >= 2 ) taken . add ( x * ( mpp . get ( x ) - 1 ) ) ; else if ( taken . size ( ) > 0 && ( ( mpp . containsKey ( x ) && mpp . get ( x ) == 0 ) || ! mpp . containsKey ( x ) ) ) { ans += x - taken . get ( taken . size ( ) - 1 ) ; taken . remove ( taken . size ( ) - 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 2 , 1 , 2 , 1 , 7 } ; System . out . print ( minIncrementForUnique ( A ) ) ; } }
import java . io . * ; import java . util . * ; public class A { private static final int MOD = 1000003 ; public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; int n = Integer . parseInt ( reader . readLine ( ) ) ; long ans = n == 0 ? 1 : pow ( 3 , n - 1 , MOD ) ; writer . println ( ans ) ; reader . close ( ) ; writer . close ( ) ; } static long pow ( int a , int p , int m ) { if ( p == 0 ) return ( long ) 1 % m ; if ( p == 1 ) return ( long ) a % m ; long v = pow ( a , p / 2 , m ) ; long ans = v * v % m ; if ( p % 2 == 1 ) ans = ans * a % m ; return ans ; } }
public class GFG { static int MOD = ( int ) ( 1e9 + 7 ) ; static int modulo_13 ( String s , int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 13 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = s . charAt ( i ) - '0' ; if ( s . charAt ( i ) == ' ? ' ) nxt = j ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( s . charAt ( i ) != ' ? ' ) break ; } } return ( int ) dp [ n ] [ 5 ] ; } public static void main ( String [ ] args ) { String s = " ? 44" ; int n = s . length ( ) ; System . out . println ( modulo_13 ( s , n ) ) ; } }
public class GFG { static int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / __gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return b - a + 1 - x - y + z ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 10 , b = 50 , c = 4 , d = 6 ; System . out . println ( countNums ( a , b , c , d ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static void printSubstrings ( int n ) { int s = ( int ) Math . log10 ( n ) ; int d = ( int ) ( Math . pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { System . out . println ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } } public static void main ( String args [ ] ) { int n = 123 ; printSubstrings ( n ) ; } }
public class GFG { static char NthCharacter ( int n ) { String s = " " ; int c = 1 ; for ( int i = 1 ; ; i ++ ) { if ( c < 10 ) s += Integer . toString ( c ) ; else { String s1 = " " ; int dup = c ; while ( dup > 0 ) { s1 += Integer . toString ( dup % 10 ) ; dup /= 10 ; } StringBuilder temp = new StringBuilder ( ) ; temp . append ( s1 ) ; temp = temp . reverse ( ) ; s += temp ; } c ++ ; if ( s . length ( ) >= n ) { return s . charAt ( n - 1 ) ; } } } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( NthCharacter ( n ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int tosi [ ] = new int [ n ] ; int M [ ] = new int [ n ] ; int D [ ] = new int [ n ] ; int i ; int k ; int c = 0 ; for ( k = 0 ; k < n ; k ++ ) { int total = 0 ; int day = 0 ; tosi [ k ] = sc . nextInt ( ) ; M [ k ] = sc . nextInt ( ) ; D [ k ] = sc . nextInt ( ) ; for ( i = tosi [ k ] + 1 ; i <= 1000 ; i ++ ) { if ( i % 3 == 0 ) { total += 200 ; } else { total += 195 ; } } if ( tosi [ k ] % 3 == 0 ) { int tuki = ( M [ k ] - 1 ) * 20 ; day = tuki + D [ k ] - 6 ; } else { if ( ( M [ k ] - 1 ) % 2 == 0 ) { day = ( ( M [ k ] - 1 ) / 2 ) * 20 + ( ( M [ k ] - 1 ) / 2 ) * 19 + D [ k ] - 1 ; } else { day = ( ( M [ k ] ) / 2 ) * 20 + ( ( M [ k ] - 1 ) / 2 ) * 19 + D [ k ] - 1 ; } } total = total - day ; System . out . println ( total ) ; } } }
import java . util . * ; public class GFG { static boolean check_prime ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 || n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static int countPrimeFrequent ( String s ) { int count = 0 ; Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( mp . containsKey ( s . charAt ( i ) ) ) { mp . put ( s . charAt ( i ) , mp . get ( s . charAt ( i ) ) + 1 ) ; } else { mp . put ( s . charAt ( i ) , 1 ) ; } } for ( Map . Entry < Character , Integer > entry : mp . entrySet ( ) ) { if ( check_prime ( entry . getValue ( ) ) ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( countPrimeFrequent ( s ) ) ; } }
import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int m = input . nextInt ( ) ; ArrayList < Integer > req = new ArrayList ( ) ; ArrayList < Integer > pre = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { req . add ( input . nextInt ( ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { pre . add ( input . nextInt ( ) ) ; } int i = n - 1 , j = m - 1 ; int ans = 0 ; while ( i >= 0 && j >= 0 ) { if ( req . get ( i ) > pre . get ( j ) ) { ans ++ ; } else { j -- ; } i -- ; } System . out . print ( ans + i + 1 ) ; } }
public class GFG { static int catalanDP ( int n ) { int catalan [ ] = new int [ n + 2 ] ; catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } return catalan [ n ] ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( catalanDP ( i ) + " ▁ " ) ; } } }
import java . math . BigInteger ; public final class p243 { public static void main ( String [ ] args ) { System . out . println ( new p243 ( ) . run ( ) ) ; } private static final Fraction TARGET = new Fraction ( BigInteger . valueOf ( 15499 ) , BigInteger . valueOf ( 94744 ) ) ; public String run ( ) { BigInteger totient = BigInteger . ONE ; BigInteger denominator = BigInteger . ONE ; for ( int p = 2 ; ; ) { totient = totient . multiply ( BigInteger . valueOf ( p - 1 ) ) ; denominator = denominator . multiply ( BigInteger . valueOf ( p ) ) ; do p ++ ; while ( ! Library . isPrime ( p ) ) ; if ( new Fraction ( totient , denominator ) . compareTo ( TARGET ) < 0 ) { for ( int i = 1 ; i < p ; i ++ ) { BigInteger numer = BigInteger . valueOf ( i ) . multiply ( totient ) ; BigInteger denom = BigInteger . valueOf ( i ) . multiply ( denominator ) ; if ( new Fraction ( numer , denom . subtract ( BigInteger . ONE ) ) . compareTo ( TARGET ) < 0 ) return denom . toString ( ) ; } } } } }
import java . util . Scanner ; public class Ishu { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int i , j , x = 0 , y = 0 , k = 0 , dx , dy ; boolean flag = true ; String s ; char [ ] ch = new char [ 100 ] ; int [ ] [ ] co = new int [ 2 ] [ 101 ] ; s = scan . next ( ) ; ch = s . toCharArray ( ) ; co [ 0 ] [ k ] = x ; co [ 1 ] [ k ] = y ; ++ k ; for ( i = 0 ; i < s . length ( ) ; ++ i ) { switch ( ch [ i ] ) { case ' L ' : -- x ; break ; case ' R ' : ++ x ; break ; case ' U ' : ++ y ; break ; case ' D ' : -- y ; break ; } co [ 0 ] [ k ] = x ; co [ 1 ] [ k ] = y ; ++ k ; } for ( i = 0 ; i < k - 3 ; ++ i ) { for ( j = i + 3 ; j < k ; ++ j ) { dx = co [ 0 ] [ i ] - co [ 0 ] [ j ] ; dy = co [ 1 ] [ i ] - co [ 1 ] [ j ] ; if ( dx < 0 ) dx *= ( - 1 ) ; if ( dy < 0 ) dy *= ( - 1 ) ; if ( ( dx <= 1 && dy == 0 ) || ( dy <= 1 && dx == 0 ) ) { flag = false ; break ; } } if ( ! flag ) break ; } if ( flag ) System . out . println ( " OK " ) ; else System . out . println ( " BUG " ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static boolean isPossible ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isPossible ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " + countDyckPaths ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int n = sc . nextInt ( ) ; System . out . println ( solve ( n ) ) ; } sc . close ( ) ; } static String solve ( int n ) { if ( n <= 30 ) { return " NO " ; } else if ( n == 36 || n == 40 || n == 44 ) { return String . format ( " YES \n 6 ▁ 10 ▁ 15 ▁ % d " , n - 31 ) ; } else { return String . format ( " YES \n 6 ▁ 10 ▁ 14 ▁ % d " , n - 30 ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } int ans = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = gcd ( ans , a [ i ] ) ; } System . out . println ( ans ) ; } private static int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } }
import java . util . * ; public class B975 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] a = new int [ 14 ] ; for ( int i = 0 ; i < 14 ; i ++ ) a [ i ] = sc . nextInt ( ) ; long max = 0 ; for ( int from = 0 ; from < 14 ; from ++ ) { int stones = a [ from ] ; int remainder = stones / 14 ; long score = ( remainder % 2 == 0 ) ? remainder : 0 ; for ( int i = 1 ; i < 14 ; i ++ ) { int count = a [ ( from + i ) % 14 ] + ( stones + 14 - i ) / 14 ; if ( count % 2 == 0 ) score += count ; } max = Math . max ( max , score ) ; } System . out . println ( max ) ; } }
public class GFG { static double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; } static public void main ( String args [ ] ) { double a = 6 ; System . out . println ( pentdiagonal ( a ) ) ; } }
public class GFG { static double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; } public static void main ( String [ ] args ) { float a = 9 ; System . out . println ( hexDiagonal ( a ) ) ; } }
import java . io . * ; public class GFG { static void translate ( char str [ ] ) { int len = str . length ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j = j + 2 ; str [ i ++ ] = ' C ' ; continue ; } str [ i ++ ] = str [ j ++ ] ; } if ( j == len - 1 ) str [ i ++ ] = str [ j ] ; str [ i ] = ' ▁ ' ; str [ len - 1 ] = ' ▁ ' ; } public static void main ( String args [ ] ) { String st = " helloABworldABGfG " ; char str [ ] = st . toCharArray ( ) ; translate ( str ) ; System . out . println ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; System . out . println ( str ) ; } }
import java . io . * ; public class GFG { static void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ▁ ' ; } } return ; } public static void main ( String args [ ] ) { String st = " helloABworldABGfG " ; char str [ ] = st . toCharArray ( ) ; translate ( str ) ; System . out . println ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; System . out . println ( str ) ; } }
public final class p128 { public static void main ( String [ ] args ) { System . out . println ( new p128 ( ) . run ( ) ) ; } private static final int TARGET = 2000 ; public String run ( ) { int count = 2 ; for ( int ring = 2 ; ; ring ++ ) { if ( ( long ) ring * 12 + 5 > Integer . MAX_VALUE ) throw new ArithmeticException ( ) ; if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 1 ) && Library . isPrime ( ring * 12 + 5 ) ) { count ++ ; if ( count == TARGET ) return Long . toString ( ( long ) ring * ( ring - 1 ) * 3 + 2 ) ; } if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 5 ) && Library . isPrime ( ring * 12 - 7 ) ) { count ++ ; if ( count == TARGET ) return Long . toString ( ( long ) ring * ( ring + 1 ) * 3 + 1 ) ; } } } }
import java . util . Scanner ; import static java . lang . Math . max ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int c = 0 ; for ( int i = 0 ; i <= max ( n , m ) ; i ++ ) { for ( int j = 0 ; j <= max ( n , m ) ; j ++ ) { if ( ( i * i ) + j == n && i + ( j * j ) == m ) c ++ ; } } System . out . println ( c ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } System . out . println ( largest + " ▁ " + smallest ) ; } public static void main ( String [ ] args ) throws java . lang . Exception { int n = 2346 ; Digits ( n ) ; } }
import java . io . * ; public class GFG { static void solve ( int d1 , int d2 , int d3 ) { int maxx = Math . max ( d1 , Math . max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( 2 * maxx > sum || sum % 2 == 1 ) { System . out . print ( " - 1" ) ; return ; } int x1 = 0 , y1 = 0 ; int x2 = d1 , y2 = 0 ; int x3 = ( d1 + d2 - d3 ) / 2 ; int y3 = ( d2 + d3 - d1 ) / 2 ; System . out . print ( " ( " + x1 + " , ▁ " + y1 + " ) , ▁ ( " + x2 + " , ▁ " + y2 + " ) ▁ and ▁ ( " + x3 + " , ▁ " + y3 + " ) " ) ; } public static void main ( String [ ] args ) { int d1 = 3 , d2 = 4 , d3 = 5 ; solve ( d1 , d2 , d3 ) ; } }
import java . io . * ; public class GFG { static int MAX_CHAR = 26 ; static boolean distributingBalls ( long k , long n , String str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; } static public void main ( String [ ] args ) { long n = 6 , k = 3 ; String str = " aacaab " ; if ( distributingBalls ( k , n , str ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . time . format . DateTimeFormatter ; import java . util . * ; import java . time . * ; public class Lesson { static Scanner sc = new Scanner ( System . in ) ; static public boolean check ( StringBuilder sb ) { int t = 0 ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( Character . toString ( sb . charAt ( i ) ) . equals ( " T " ) ) { t ++ ; } else if ( Character . toString ( sb . charAt ( i ) ) . equals ( " M " ) ) { if ( t <= 0 ) return false ; t -- ; } } return true ; } public static void main ( String ... args ) { int t = sc . nextInt ( ) ; OUTER_LOOP : while ( t -- > 0 ) { int n = sc . nextInt ( ) ; StringBuilder sb = new StringBuilder ( sc . next ( ) ) ; if ( sb . indexOf ( " M " ) < 0 ) { System . out . println ( " NO " ) ; continue ; } int T = 0 , m = 0 ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( Character . toString ( sb . charAt ( i ) ) . equals ( " T " ) ) T ++ ; else m ++ ; } if ( T / 2 != m ) { System . out . println ( " NO " ) ; continue ; } if ( check ( sb ) == true && check ( sb . reverse ( ) ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int e [ ] = new int [ 13 ] ; int i ; int p = 0 ; int k ; for ( i = 0 ; i < 12 ; i ++ ) { e [ i ] = scan . nextInt ( ) ; } for ( i = 0 ; i < 12 ; i ++ ) { for ( int j = 0 ; j < 12 - i ; j ++ ) { if ( e [ j ] < e [ j + 1 ] ) { int y = e [ j ] ; e [ j ] = e [ j + 1 ] ; e [ j + 1 ] = y ; } } } for ( int u = 0 ; u < 3 ; u ++ ) { for ( k = 0 ; k < 4 ; k ++ ) { i = u * 4 ; if ( e [ i ] == e [ i + 1 ] && e [ i + 2 ] == e [ i + 3 ] && e [ i ] == e [ i + 2 ] && e [ i + 1 ] == e [ i + 3 ] && e [ i ] == e [ i + 3 ] && e [ i + 1 ] == e [ i + 2 ] ) { p += 1 ; } else { p += 0 ; } } } if ( p == 12 ) { System . out . println ( " yes " ) ; } else { System . out . println ( " no " ) ; } } }
import java . io . * ; public class GFG { static int R = 4 ; static int C = 4 ; static int first ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 || arr [ mid - 1 ] == 0 ) && arr [ mid ] == 1 ) return mid ; else if ( arr [ mid ] == 0 ) return first ( arr , ( mid + 1 ) , high ) ; else return first ( arr , low , ( mid - 1 ) ) ; } return - 1 ; } static void rowWith0s ( int mat [ ] [ ] ) { int max_row_index = 0 , max = Integer . MIN_VALUE ; int min_row_index = 0 , min = Integer . MAX_VALUE ; int i , index ; for ( i = 0 ; i < R ; i ++ ) { index = first ( mat [ i ] , 0 , C - 1 ) ; int cntZeroes = 0 ; if ( index == - 1 ) { cntZeroes = C ; } else { cntZeroes = index ; } if ( max < cntZeroes ) { max = cntZeroes ; max_row_index = i ; } if ( min > cntZeroes ) { min = cntZeroes ; min_row_index = i ; } } System . out . println ( " Row ▁ with ▁ min ▁ 0s : ▁ " + ( min_row_index + 1 ) ) ; System . out . println ( " Row ▁ with ▁ max ▁ 0s : ▁ " + ( max_row_index + 1 ) ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 } , { 0 , 0 , 0 , 0 } } ; rowWith0s ( mat ) ; } }
import java . io . * ; public class GFG { static int bitAtGivenPosSetOrUnset ( int n , int k ) { int new_num = n >> ( k - 1 ) ; return ( new_num & 1 ) ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; if ( bitAtGivenPosSetOrUnset ( n , k ) == 1 ) System . out . println ( " Set " ) ; else System . out . println ( " Unset " ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Iterator ; import java . util . StringTokenizer ; public class MammothsGenomeDecoding { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; if ( n % 4 != 0 ) { System . out . println ( " = = = " ) ; return ; } int themost = n / 4 ; int numA = 0 ; int numG = 0 ; int numC = 0 ; int numT = 0 ; int numQM = 0 ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; StringBuffer sb = new StringBuffer ( st . nextToken ( ) ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == ' A ' ) numA ++ ; else if ( sb . charAt ( i ) == ' G ' ) numG ++ ; else if ( sb . charAt ( i ) == ' C ' ) numC ++ ; else if ( sb . charAt ( i ) == ' T ' ) numT ++ ; else numQM ++ ; } if ( numA > themost || numC > themost || numG > themost || numT > themost ) { System . out . println ( " = = = " ) ; return ; } for ( int j = 0 ; j < numQM ; j ++ ) { for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == ' ? ' ) { if ( numA < themost ) { sb . replace ( i , i + 1 , " A " ) ; numA ++ ; } else if ( numC < themost ) { sb . replace ( i , i + 1 , " C " ) ; ; numC ++ ; } else if ( numG < themost ) { sb . replace ( i , i + 1 , " G " ) ; ; numG ++ ; } else if ( numT < themost ) { sb . replace ( i , i + 1 , " T " ) ; ; numT ++ ; } } } } System . out . println ( sb ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { final int n = sc . nextInt ( ) ; if ( n == 0 ) { break ; } double [ ] pos = new double [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { pos [ i ] = 0 ; } final int start = sc . next ( ) . toCharArray ( ) [ 0 ] - ' A ' ; final int end = sc . next ( ) . toCharArray ( ) [ 0 ] - ' A ' ; final int not = sc . next ( ) . toCharArray ( ) [ 0 ] - ' A ' ; pos [ start ] = 1 ; double [ ] next = new double [ 9 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { next [ j ] = 0 ; } for ( int j = 0 ; j < 9 ; j ++ ) { if ( j % 3 != 0 && not != j - 1 ) { next [ j - 1 ] += pos [ j ] / 4 ; } else { next [ j ] += pos [ j ] / 4 ; } if ( j % 3 != 2 && not != j + 1 ) { next [ j + 1 ] += pos [ j ] / 4 ; } else { next [ j ] += pos [ j ] / 4 ; } if ( j / 3 != 0 && not != j - 3 ) { next [ j - 3 ] += pos [ j ] / 4 ; } else { next [ j ] += pos [ j ] / 4 ; } if ( j / 3 != 2 && not != j + 3 ) { next [ j + 3 ] += pos [ j ] / 4 ; } else { next [ j ] += pos [ j ] / 4 ; } } double [ ] tmp = next ; next = pos ; pos = tmp ; } System . out . printf ( " % .8f \n " , pos [ end ] ) ; } } }
import java . util . * ; public class Sol { public static void main ( String [ ] argc ) { Scanner sc = new Scanner ( System . in ) ; int l = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; int ans = 0 ; for ( long i = 1 ; i <= r ; i *= 2 ) { for ( long j = 1 ; j * i <= r ; j *= 3 ) { if ( i * j >= l ) ans += 1 ; } } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; sc . close ( ) ; int t = 1 ; for ( int i = 0 ; i < N ; i ++ ) { t = Math . min ( 2 * t , t + K ) ; } System . out . println ( t ) ; } }
import java . io . * ; public class GFG { static boolean arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = a . length ; int m = b . length ; if ( arePermutations ( a , b , n , m ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static int MAX_CHAR = 26 ; static void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - ' a ' ] == 1 || present [ str2 . charAt ( i ) - ' a ' ] == - 1 ) { present [ str2 . charAt ( i ) - ' a ' ] = - 1 ; } else { present [ str2 . charAt ( i ) - ' a ' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { System . out . print ( ( char ) ( i + ' a ' ) + " ▁ " ) ; } } } public static void main ( String [ ] args ) { String str1 = " characters " ; String str2 = " alphabets " ; findAndPrintUncommonChars ( str1 , str2 ) ; } }
public class GFG { static boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } public static void main ( String arg [ ] ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) System . out . print ( " Inside " ) ; else System . out . print ( " Outside " ) ; } }
public class GFG { static int minSum ( int arr [ ] , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 5 , 5 , 6 } ; int n = arr . length ; int x = 3 ; System . out . println ( minSum ( arr , n , x ) ) ; } }
public class GFG { static long nthTerm ( long n ) { long nth ; if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; } public static void main ( String [ ] args ) { long n ; n = 5 ; System . out . println ( nthTerm ( n ) ) ; n = 25 ; System . out . println ( nthTerm ( n ) ) ; n = 25000000 ; System . out . println ( nthTerm ( n ) ) ; n = 250000007 ; System . out . println ( nthTerm ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { List < Integer > list = new LinkedList < Integer > ( ) ; ListIterator < Integer > iterator = list . listIterator ( ) ; Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int cmd = scan . nextInt ( ) ; switch ( cmd ) { case 0 : iterator . add ( scan . nextInt ( ) ) ; iterator . previous ( ) ; break ; case 1 : int d = scan . nextInt ( ) ; if ( d > 0 ) { for ( int j = 0 ; j < d ; j ++ ) iterator . next ( ) ; } else { for ( int j = 0 ; j > d ; j -- ) iterator . previous ( ) ; } break ; case 2 : iterator . next ( ) ; iterator . remove ( ) ; break ; } } for ( Integer i : list ) System . out . println ( i ) ; } }
import java . util . Scanner ; public class c1029A { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int k = scan . nextInt ( ) ; String s = scan . next ( ) ; int ans = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . substring ( 0 , i ) . equals ( s . substring ( s . length ( ) - i ) ) ) { ans = i ; } } StringBuilder sb = new StringBuilder ( ) ; sb . append ( s . substring ( s . length ( ) - ans ) ) ; for ( int i = 0 ; i < k ; i ++ ) { sb . append ( s . substring ( ans ) ) ; } System . out . println ( sb ) ; } }
public class GFG { static class Node { int data ; Node left , right ; } ; static class INT { int a ; INT ( int a ) { this . a = a ; } } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static void printInorder ( Node node ) { if ( node == null ) return ; printInorder ( node . left ) ; System . out . printf ( " % d ▁ " , node . data ) ; printInorder ( node . right ) ; } static Node conBinaryTreeUtil ( int pre [ ] , int preM [ ] , INT preIndex , int l , int h , int size ) { if ( preIndex . a >= size || l > h ) return null ; Node root = newNode ( pre [ preIndex . a ] ) ; ++ ( preIndex . a ) ; if ( l == h ) return root ; int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ preIndex . a ] == preM [ i ] ) break ; if ( i <= h ) { root . left = conBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) ; root . right = conBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) ; } return root ; } static void conBinaryTree ( Node root , int pre [ ] , int preMirror [ ] , int size ) { INT preIndex = new INT ( 0 ) ; int preMIndex = 0 ; root = conBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) ; printInorder ( root ) ; } public static void main ( String args [ ] ) { int preOrder [ ] = { 1 , 2 , 4 , 5 , 3 , 6 , 7 } ; int preOrderMirror [ ] = { 1 , 3 , 7 , 6 , 2 , 5 , 4 } ; int size = preOrder . length ; Node root = new Node ( ) ; conBinaryTree ( root , preOrder , preOrderMirror , size ) ; } }
public class GFG { static final int no_of_chars = 256 ; static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int hash_pat [ ] = new int [ no_of_chars ] ; int hash_str [ ] = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) ] ++ ; if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . charAt ( start ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return str . substring ( start_index , start_index + min_len ) ; } public static void main ( String [ ] args ) { String str = " this ▁ is ▁ a ▁ test ▁ string " ; String pat = " tist " ; System . out . print ( " Smallest ▁ window ▁ is ▁ : \n ▁ " + findSubString ( str , pat ) ) ; } }
import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; while ( in . hasNext ( ) ) { Point2 p [ ] = new Point2 [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) p [ i ] = new Point2 ( in . nextDouble ( ) , in . nextDouble ( ) ) ; boolean judge = false ; if ( ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) > 0 && ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) > 0 && ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) > 0 ) || ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) < 0 && ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) < 0 && ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) < 0 ) ) judge = true ; System . out . println ( judge ? " YES " : " NO " ) ; } } static double ccw ( Point2 p1 , Point2 p2 , Point2 p3 ) { return ( p2 . y - p1 . y ) * ( p3 . x - p1 . x ) - ( p3 . y - p1 . y ) * ( p2 . x - p1 . x ) ; } } class Point2 { double x ; double y ; Point2 ( double x , double y ) { this . x = x ; this . y = y ; } }
import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class PolandBoardAndGame { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n > m ) System . out . println ( " YES " ) ; else if ( m > n ) System . out . println ( " NO " ) ; else { Map < String , Integer > map = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( sc . next ( ) , 1 ) ; } int dem = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( map . containsKey ( sc . next ( ) ) ) { dem ++ ; } } if ( dem % 2 == 0 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } } }
import java . util . * ; public class GFG { static int MAX = 100005 ; static Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; } static boolean is_prime ( int n ) { return ( n == 3 || n == 5 || n == 7 ) ; } static int find_Sum ( int n ) { int sum = 0 ; Vector < Integer > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) && n > 0 ; i ++ ) { int flag = 1 ; int a = v . get ( i ) ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } } return sum ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( find_Sum ( n ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] science = new int [ 4 ] ; int minsc = 100 ; int sumsc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { science [ i ] = sc . nextInt ( ) ; minsc = Math . min ( minsc , science [ i ] ) ; sumsc += science [ i ] ; } sumsc -= minsc ; int sumso = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; if ( sumso < x ) { sumso = x ; } System . out . println ( sumsc + sumso ) ; } }
import java . io . * ; import java . util . StringTokenizer ; public class BearAndGame1 { public static void main ( String [ ] args ) { InputReader sc = new InputReader ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] array = new int [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = sc . nextInt ( ) ; } int flag = 15 ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] <= flag ) { flag = array [ i ] + 15 ; } else { break ; } } int result = Math . min ( flag , 90 ) ; OutputStream outputStream = System . out ; PrintWriter out = new PrintWriter ( outputStream ) ; out . println ( result ) ; out . close ( ) ; } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }
import java . util . * ; public class GFG { static Vector < Integer > v = new Vector < > ( ) ; static int [ ] [ ] [ ] [ ] dp = new int [ 18 ] [ 180 ] [ 180 ] [ 2 ] ; static int memo ( int index , int evenSum , int oddSum , int tight ) { if ( index == v . size ( ) ) { if ( evenSum > oddSum ) { return 1 ; } else { return 0 ; } } if ( dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 ) { return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] ; } int limit = ( tight > 0 ) ? v . get ( index ) : 9 ; int ans = 0 ; for ( int d = 0 ; d <= limit ; d ++ ) { int currTight = 0 ; if ( d == v . get ( index ) ) { currTight = tight ; } if ( d % 2 != 0 ) { ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) ; } else { ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) ; } } dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans ; return ans ; } static int CountNum ( int n ) { v . clear ( ) ; while ( n > 0 ) { v . add ( n % 10 ) ; n = n / 10 ; } Collections . reverse ( v ) ; for ( int i = 0 ; i < 18 ; i ++ ) { for ( int j = 0 ; j < 180 ; j ++ ) { for ( int k = 0 ; k < 180 ; k ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) { dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } } } return memo ( 0 , 0 , 0 , 1 ) ; } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; System . out . println ( CountNum ( R ) - CountNum ( L - 1 ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; StringBuilder sb = new StringBuilder ( ) ; int c [ ] [ ] = new int [ 3 ] [ 3 ] ; boolean b = true ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { c [ i ] [ j ] = sc . nextInt ( ) ; } } loop : for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = i + 1 ; j < 3 ; j ++ ) { if ( c [ i ] [ 0 ] - c [ j ] [ 0 ] == c [ i ] [ 1 ] - c [ j ] [ 1 ] && c [ i ] [ 1 ] - c [ j ] [ 1 ] == c [ i ] [ 2 ] - c [ j ] [ 2 ] ) { } else { b = false ; break loop ; } } } loop : for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = i + 1 ; j < 3 ; j ++ ) { if ( c [ 0 ] [ i ] - c [ 0 ] [ j ] == c [ 1 ] [ i ] - c [ 1 ] [ j ] && c [ 1 ] [ i ] - c [ 1 ] [ j ] == c [ 2 ] [ i ] - c [ 2 ] [ j ] ) { } else { b = false ; break loop ; } } } if ( b ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . PrintStream ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; PrintStream ps = new PrintStream ( System . out ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } boolean flag = true ; b [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != 0 && b [ i - 1 ] - a [ i ] >= 0 ) { flag = false ; break ; } else b [ i ] = b [ i - 1 ] + a [ i ] ; } if ( ! flag ) ps . println ( - 1 ) ; else { for ( int i = 0 ; i < n ; i ++ ) { ps . print ( b [ i ] + " ▁ " ) ; } ps . println ( ) ; } } ps . close ( ) ; } }
public final class p218 { public static void main ( String [ ] args ) { System . out . println ( new p218 ( ) . run ( ) ) ; } public String run ( ) { return "0" ; } }
public class GFG { public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int result = search ( arr , x ) ; if ( result == - 1 ) System . out . print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else System . out . print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] input = br . readLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( input [ 0 ] ) ; long c = Long . parseLong ( input [ 1 ] ) ; long forwardMax [ ] = new long [ n + 1 ] ; long backwardMax [ ] = new long [ n + 1 ] ; long positions [ ] = new long [ n + 1 ] ; long values [ ] = new long [ n + 1 ] ; positions [ 0 ] = 0 ; values [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { input = br . readLine ( ) . split ( " ▁ " ) ; positions [ i ] = Long . parseLong ( input [ 0 ] ) ; values [ i ] = Long . parseLong ( input [ 1 ] ) ; } long max = 0 ; long sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum += values [ i ] ; max = Math . max ( max , sum - positions [ i ] ) ; forwardMax [ i ] = max ; } max = 0 ; sum = 0 ; for ( int i = n ; i >= 0 ; i -- ) { sum += values [ i ] ; max = Math . max ( max , sum - ( c - positions [ i ] ) ) ; backwardMax [ i ] = max ; } long res = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { res = Math . max ( res , forwardMax [ i ] ) ; if ( i != n ) res = Math . max ( res , forwardMax [ i ] - ( positions [ i ] ) + backwardMax [ i + 1 ] ) ; res = Math . max ( res , backwardMax [ i ] ) ; if ( i != 0 ) res = Math . max ( res , backwardMax [ i ] - ( c - positions [ i ] ) + forwardMax [ i - 1 ] ) ; } System . out . println ( res ) ; } }
import java . io . * ; public class GFG { static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( n ^ num ) ; } static int unsetBitsInGivenRange ( int n , int l , int r ) { int num = ( 1 << ( 4 * 8 - 1 ) ) - 1 ; num = toggleBitsFromLToR ( num , l , r ) ; return ( n & num ) ; } public static void main ( String [ ] args ) { int n = 42 ; int l = 2 , r = 5 ; System . out . println ( unsetBitsInGivenRange ( n , l , r ) ) ; } }
public class GFG { static int MinStep ( int a [ ] , int n ) { int positive = 0 , negative = 0 , zero = 0 ; int step = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } else if ( a [ i ] < 0 ) { negative ++ ; step = step + ( - 1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( negative % 2 == 0 ) { step = step + zero ; } else { if ( zero > 0 ) { step = step + zero ; } else { step = step + 2 ; } } return step ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , - 2 , - 1 , - 3 , 4 } ; int n = a . length ; System . out . println ( MinStep ( a , n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int number = sc . nextInt ( ) , start = sc . nextInt ( ) , end = sc . nextInt ( ) ; int [ ] arr = new int [ number + 1 ] ; String str = sc . next ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { arr [ i + 1 ] = str . charAt ( i ) - '0' ; } if ( arr [ start ] == arr [ end ] ) { System . out . println ( 0 ) ; } else { System . out . println ( Math . abs ( arr [ start ] - arr [ end ] ) ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] num = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) num [ i ] = sc . nextInt ( ) ; Arrays . sort ( num ) ; System . out . println ( num [ n - 1 ] + num [ n - 2 ] ) ; } } }
public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int x1 = 1 , y1 = 1 , x2 = 4 , y2 = 3 ; noOfSquares ( x1 , y1 , x2 , y2 ) ; } }
public class GFG { static String get_maximum ( char [ ] s , int a [ ] ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . valueOf ( s ) ; } } return String . valueOf ( s ) ; } public static void main ( String [ ] args ) { String s = "1337" ; int a [ ] = { 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 } ; System . out . println ( get_maximum ( s . toCharArray ( ) , a ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class GFG { static int MAX_DIGITS = 20 ; static int isOctal ( int n ) { while ( n > 0 ) { if ( ( n % 10 ) >= 8 ) return 0 ; else n = n / 10 ; } return 1 ; } static int isPalindrome ( int n ) { int divide = ( isOctal ( n ) == 0 ) ? 8 : 10 ; int octal [ ] = new int [ MAX_DIGITS ] ; int i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; } for ( int j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return 0 ; return 1 ; } public static void main ( String [ ] args ) { int n = 97 ; if ( isPalindrome ( n ) > 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; import static java . lang . Math . * ; public class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int x = 0 , y = 0 ; int t = 0 ; int n = in . nextInt ( ) ; String str = in . next ( ) ; char l [ ] = new char [ str . length ( ) ] ; l = str . toCharArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( l [ i ] != '4' && l [ i ] != '7' ) { t = 1 ; } } if ( t == 1 ) { System . out . println ( " NO " ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) { x = x + Character . getNumericValue ( l [ i ] ) ; } for ( int i = n - 1 ; i > ( n / 2 ) - 1 ; i -- ) { y = y + Character . getNumericValue ( l [ i ] ) ; } if ( x == y ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public class GFG { static int binarySearch ( int arr [ ] , int low , int high ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; int midValue = arr [ mid ] ; if ( mid == arr [ mid ] ) return mid ; int leftindex = Math . min ( mid - 1 , midValue ) ; int left = binarySearch ( arr , low , leftindex ) ; if ( left >= 0 ) return left ; int rightindex = Math . max ( mid + 1 , midValue ) ; int right = binarySearch ( arr , rightindex , high ) ; return right ; } public static void main ( String [ ] args ) { int arr [ ] = { - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 } ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + binarySearch ( arr , 0 , arr . length - 1 ) ) ; int arr1 [ ] = { - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 } ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + binarySearch ( arr1 , 0 , arr1 . length - 1 ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 10000 ; static int [ ] prodDig = new int [ MAX ] ; static int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; } static void findSeed ( int n ) { List < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . add ( i ) ; if ( res . size ( ) == 0 ) { System . out . println ( " NO ▁ seed ▁ exists " ) ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 138 ; findSeed ( n ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . List ; import java . util . Queue ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str [ ] = br . readLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int k = Integer . parseInt ( str [ 1 ] ) ; int x [ ] = new int [ n ] ; str = br . readLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = Integer . parseInt ( str [ i ] ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i + k - 1 < n ; i ++ ) { int left = x [ i ] ; int right = x [ i + k - 1 ] ; ans = Math . min ( ans , Math . min ( Math . abs ( left ) , Math . abs ( right ) ) + right - left ) ; } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; } static double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } } public static void main ( String [ ] args ) { double n = 3 ; System . out . println ( " Cubic ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + cubicRoot ( n ) ) ; } }
import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int a [ ] = new int [ 105 ] ; int max = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; if ( i > 0 && a [ i ] > a [ max ] ) { max = i ; } } int ansmax = a [ max ] + m ; for ( int i = 0 ; i <= m - 1 ; i ++ ) { int min = 0 ; for ( int j = 0 ; j <= n - 1 ; j ++ ) { if ( j > 0 && a [ j ] < a [ min ] ) { min = j ; } } a [ min ] ++ ; } max = 0 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( a [ i ] > a [ max ] ) { max = i ; } } int ansmin = a [ max ] ; System . out . print ( ansmin + " ▁ " + ansmax ) ; sc . close ( ) ; } }
import java . io . * ; public class GFG { static int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } static int findMinX ( int num [ ] , int rem [ ] , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; } public static void main ( String args [ ] ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = num . length ; System . out . println ( " x ▁ is ▁ " + findMinX ( num , rem , k ) ) ; } }
import java . util . * ; class solution { boolean compare ( int a , int b ) { return a > b ; } static int findMaxOR ( int [ ] arr , int n ) { int temp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } int maxOR = arr [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( maxOR | arr [ i ] ) > maxOR ) { maxOR = maxOR | arr [ i ] ; count ++ ; } } return count ; } public static void main ( String arrgs [ ] ) { int [ ] arr = { 5 , 1 , 3 , 4 , 2 } ; int n = arr . length ; System . out . println ( findMaxOR ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( seriesSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; } public static void main ( String args [ ] ) throws IOException { int n = 12 ; System . out . println ( aliquotSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pentagon_pyramidal ( n ) ) ; } }
import java . io . * ; public class GFG { static long fifthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i * i ) ; return sum ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( fifthPowerSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } public static void main ( String args [ ] ) throws IOException { int n = 4 ; System . out . println ( squaresum ( n ) ) ; } }
import java . io . * ; public class GFG { static int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( seriesSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumOfSeries ( n ) ) ; } }
public class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( fourthPowerSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int squareSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; } public static void main ( String args [ ] ) throws IOException { System . out . println ( squareSum ( 8 ) ) ; } }
import java . io . * ; public class GFG { static float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } static public void main ( String [ ] args ) { int n = 2 ; System . out . println ( AvgofSquareN ( n ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; } static public void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int solve ( int n , int base ) { int sum = 0 ; while ( n > 0 ) { int remainder = n % base ; sum += remainder ; n = n / base ; } return sum ; } static void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int n = 8 ; SumsOfDigits ( n ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class Main { static final int N = 10000 ; public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } void solve ( ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Long > p = new ArrayList < Long > ( ) ; for ( long i = 2 ; p . size ( ) <= N ; ++ i ) { boolean f = true ; for ( int j = 0 ; j < p . size ( ) ; ++ j ) { f &= i % p . get ( j ) != 0 ; if ( ! f ) break ; } if ( f ) { p . add ( i ) ; } } while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += p . get ( i ) ; } System . out . println ( sum ) ; } sc . close ( ) ; } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } }
import java . io . * ; public class GFG { public static void main ( String [ ] args ) { System . out . println ( Integer . bitCount ( 4 ) ) ; System . out . println ( Integer . bitCount ( 15 ) ) ; } }
public class Optimal_BST2 { static int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { int cost [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; cost [ i ] [ j ] = Integer . MAX_VALUE ; for ( int r = i ; r <= j ; r ++ ) { int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; } static int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) { if ( k >= freq . length ) continue ; s += freq [ k ] ; } return s ; } public static void main ( String [ ] args ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = keys . length ; System . out . println ( " Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ " + optimalSearchTree ( keys , freq , n ) ) ; } }
public class GFG { static int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; } public static void main ( String [ ] args ) { int x = 1 , y = 5 , z = 8 ; System . out . print ( get ( x , y , z ) + " \n " ) ; } }
import java . io . * ; import java . util . * ; public class CodeForces { public static final int BUFFERSIZE = 512000 ; private static Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) , BUFFERSIZE ) ) ; private static PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out , BUFFERSIZE ) ) ; public static void solve ( ) { int n = sc . nextInt ( ) ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( sc . nextInt ( ) , i ) ; } int lastLoc = map . get ( 1 ) ; long ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int newLoc = map . get ( i ) ; ans += Math . abs ( lastLoc - newLoc ) ; lastLoc = newLoc ; } out . println ( ans ) ; } public static void main ( String args [ ] ) throws Exception { in . init ( System . in ) ; solve ( ) ; out . close ( ) ; } public static class in { static BufferedReader reader ; static StringTokenizer tokenizer ; static void init ( InputStream input ) { reader = new BufferedReader ( new InputStreamReader ( input ) , BUFFERSIZE ) ; tokenizer = new StringTokenizer ( " " ) ; } static String next ( ) throws IOException { while ( ! tokenizer . hasMoreTokens ( ) ) tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; return tokenizer . nextToken ( ) ; } static int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } static double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } static long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } } }
import java . io . * ; public class GFG { static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static int maxcoefficientvalue ( int n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( maxcoefficientvalue ( n ) ) ; } }
public class GFG { static boolean isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } } static int vowelPairs ( String s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) && isVowel ( s . charAt ( i + 1 ) ) ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String s = " abaebio " ; int n = s . length ( ) ; System . out . print ( vowelPairs ( s , n ) ) ; } }
import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { solve ( ) ; } private static void solve ( ) { Scanner scn = new Scanner ( System . in ) ; PrintWriter pr = new PrintWriter ( System . out ) ; while ( true ) { int N = scn . nextInt ( ) ; if ( N == 0 ) break ; int W = scn . nextInt ( ) ; int H = scn . nextInt ( ) ; int [ ] [ ] map = new int [ W + 1 ] [ H + 1 ] ; while ( N -- > 0 ) { map [ scn . nextInt ( ) ] [ scn . nextInt ( ) ] ++ ; } int S = scn . nextInt ( ) ; int T = scn . nextInt ( ) ; int max = 0 ; for ( int s = 1 ; s <= W - S + 1 ; s ++ ) { for ( int t = 1 ; t <= H - T + 1 ; t ++ ) { int count = 0 ; for ( int a = s ; a < s + S ; a ++ ) { for ( int b = t ; b < t + T ; b ++ ) { count += map [ a ] [ b ] ; } } if ( max < count ) { max = count ; } } } pr . println ( max ) ; } pr . flush ( ) ; scn . close ( ) ; } }
public class GFG { static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; if ( j == M ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { String s1 = " for " ; String s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) System . out . println ( " Not ▁ present " ) ; else System . out . println ( " Present ▁ at ▁ index ▁ " + res ) ; } }
public class GFG { static float angleOncirCumference ( float z ) { return ( z / 2 ) ; } public static void main ( String [ ] args ) { float angle = 65 ; float z = angleOncirCumference ( angle ) ; System . out . println ( " The ▁ angle ▁ is ▁ " + z + " ▁ degrees " ) ; } }
import java . io . * ; public class GFG { static void countSubarraysof1and0 ( int a [ ] , int n ) { int count1 = 0 , count0 = 0 ; int number1 = 0 , number0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) { count1 += 1 ; } else { number1 += ( count1 ) * ( count1 + 1 ) / 2 ; count1 = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count0 += 1 ; } else { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; count0 = 0 ; } } if ( count1 > 0 ) number1 += ( count1 ) * ( count1 + 1 ) / 2 ; if ( count0 > 0 ) number0 += ( count0 ) * ( count0 + 1 ) / 2 ; System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : ▁ " + number0 ) ; System . out . println ( " \n Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : ▁ " + number1 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = a . length ; countSubarraysof1and0 ( a , n ) ; ; } }
public class GFG { static void printNumbers ( int N ) { int flag = 1 ; int x = N ; if ( N > 0 ) { while ( x > 0 && flag == 1 ) { int digit = x % 10 ; if ( digit != 1 && digit != 3 ) { flag = 0 ; } x = x / 10 ; } if ( flag == 1 ) { System . out . print ( N + " ▁ " ) ; } printNumbers ( N - 1 ) ; } } public static void main ( String [ ] args ) { int N = 20 ; printNumbers ( N ) ; } }
import java . io . * ; public class GFG { static void printPermutation ( int n , int k ) { int i , mx = n ; for ( i = 1 ; i <= k ; i ++ ) { System . out . print ( mx + " ▁ " ) ; mx -- ; } for ( i = 1 ; i <= mx ; i ++ ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 5 , K = 3 ; if ( K >= N - 1 ) System . out . print ( " Not ▁ Possible " ) ; else printPermutation ( N , K ) ; } }
import java . util . Scanner ; public class TheRank { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int ans = 0 ; int rank = 1 ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; int d = in . nextInt ( ) ; int sum = a + b + c + d ; arr [ i ] = sum ; } for ( int j : arr ) { if ( arr [ 0 ] < j ) { rank ++ ; } } System . out . println ( rank ) ; } }
import java . util . * ; public class GFG { static boolean check ( String s1 , String s2 ) { Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { mp . put ( s1 . charAt ( i ) , mp . get ( s1 . charAt ( i ) ) == null ? 1 : mp . get ( s1 . charAt ( i ) ) + 1 ) ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( mp . get ( s2 . charAt ( i ) ) > 0 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String s1 = " geeksforgeeks " , s2 = " geeks " ; boolean yes_or_no = check ( s1 , s2 ) ; if ( yes_or_no == true ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; boolean flag = false ; int k = n * ( a - b ) ; int m = n * ( a + b ) ; if ( k > ( c + d ) || m < ( c - d ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } } }
import java . util . * ; import java . io . * ; public class GFG { static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }
import java . io . * ; public class GFG { static int N = 3 ; static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; } public static void main ( String [ ] args ) { int tri [ ] [ ] = { { 1 , 0 , 0 } , { 4 , 8 , 0 } , { 1 , 5 , 3 } } ; System . out . println ( maxPathSum ( tri , 2 , 2 ) ) ; } }
public class GFG { static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . length ; if ( isHeap ( arr , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
public class GFG { static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . length - 1 ; if ( isHeap ( arr , 0 , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner in = new Scanner ( System . in ) ; long ax = in . nextLong ( ) ; long ay = in . nextLong ( ) ; long bx = in . nextLong ( ) ; long by = in . nextLong ( ) ; long cx = in . nextLong ( ) ; long cy = in . nextLong ( ) ; System . out . println ( ( ( bx - ax ) * ( cy - ay ) == ( cx - ax ) * ( by - ay ) ) || ( ( ax - bx ) * ( ax - bx ) + ( ay - by ) * ( ay - by ) != ( cx - bx ) * ( cx - bx ) + ( cy - by ) * ( cy - by ) ) ? " No " : " Yes " ) ; } }
public class GFG { static int findMinDel ( int [ ] arr , int n ) { int min_num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 2 } ; int n = arr . length ; System . out . print ( findMinDel ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int count ( int x , int y ) { int ans = 0 ; Map < Integer , Integer > m = new HashMap < > ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . containsKey ( x ) ) return - 1 ; m . put ( x , 1 ) ; x = x * 10 ; } return ans ; } public static void main ( String [ ] args ) { int res = count ( 1 , 2 ) ; if ( ( res == - 1 ) ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; res = count ( 5 , 3 ) ; if ( ( res == - 1 ) ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; res = count ( 3 , 5 ) ; if ( ( res == - 1 ) ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; } }
import java . io . * ; import java . util . * ; public class GFG { public static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 40 , 50 , 90 } ; int n = 3 ; if ( isPossibleToMakeDivisible ( arr , n ) ) System . out . print ( " Yes \n " ) ; else System . out . print ( " No \n " ) ; } }
import java . util . * ; class Main { private static int N , K ; private static List < Integer > [ ] vec ; private static int ans ; public static void main ( String args [ ] ) { new Thread ( null , ( ) -> { Scanner sc = new Scanner ( System . in ) ; N = sc . nextInt ( ) ; K = sc . nextInt ( ) ; ans = 0 ; vec = new ArrayList [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { vec [ i ] = new ArrayList < > ( 0 ) ; } for ( int i = 0 ; i < N ; i ++ ) { int a = sc . nextInt ( ) - 1 ; if ( i != 0 ) { vec [ a ] . add ( i ) ; } else { if ( a != 0 ) { ans ++ ; } } } dfs ( 0 , 0 ) ; System . out . println ( ans ) ; } , " " , 1 << 24 ) . start ( ) ; } private static int dfs ( int v , int pre ) { int hight = 0 ; for ( int j = 0 ; j < vec [ v ] . size ( ) ; j ++ ) { hight = Math . max ( hight , dfs ( vec [ v ] . get ( j ) , v ) ) ; } if ( pre != 0 && hight == K - 1 ) { hight = 0 ; ans ++ ; } else { hight ++ ; } return hight ; } }
class Test { static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { System . out . print ( j * j * j + " ▁ ▁ " ) ; break ; } } } } public static void main ( String [ ] args ) { int a = 1 , b = 100 ; System . out . println ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : " ) ; printCubes ( a , b ) ; } }
public class GFG { static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 6 ; int d = 4 ; System . out . println ( n + " ▁ moduo ▁ " + d + " ▁ is ▁ " + getModulo ( n , d ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class pre598 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; int n = obj . nextInt ( ) , d = obj . nextInt ( ) , arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = obj . nextInt ( ) ; Arrays . sort ( arr ) ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 , l = arr [ i ] + d ; for ( int j = i ; j < n ; j ++ ) { if ( l < arr [ j ] ) break ; count ++ ; } max = Math . max ( max , count ) ; } System . out . println ( n - max ) ; } }
import java . io . * ; import java . math . * ; import java . security . * ; import java . text . * ; import java . util . * ; public class CodeForce { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; String sr = br . readLine ( ) ; String ss = sr . substring ( 0 , sr . length ( ) - 1 ) ; char ch = sr . charAt ( sr . length ( ) - 1 ) ; ArrayList < Character > list = new ArrayList < Character > ( ) ; list . add ( ' f ' ) ; list . add ( ' e ' ) ; list . add ( ' d ' ) ; list . add ( ' a ' ) ; list . add ( ' b ' ) ; list . add ( ' c ' ) ; Long x = Long . parseLong ( ss ) ; long m = x % 2 ; long k = ( x - 1 ) / 4 ; long re = x - k ; long total = 0l ; total = 16 * k ; if ( m == 0 ) { total += 7 + list . indexOf ( ch ) + 1 ; } if ( m == 1 ) { total += list . indexOf ( ch ) + 1 ; } System . out . println ( total ) ; } }
public class GFG { static boolean isPerfectCube ( int x ) { int cr = ( int ) Math . cbrt ( x ) ; return ( cr * cr * cr == x ) ; } static void canBePerfectCube ( int N , int K ) { if ( isPerfectCube ( N + K ) || isPerfectCube ( N - K ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int N = 7 ; int K = 1 ; canBePerfectCube ( N , K ) ; N = 5 ; K = 4 ; canBePerfectCube ( N , K ) ; N = 7 ; K = 2 ; canBePerfectCube ( N , K ) ; } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . next ( ) ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; sc . close ( ) ; int result = 2 * n ; for ( int i = 0 ; i < n ; i ++ ) { String foot = t . substring ( 0 , n - i ) ; if ( s . endsWith ( foot ) ) { result -= foot . length ( ) ; break ; } } System . out . println ( result ) ; } }
import java . io . * ; import java . util . * ; class Graph { private int V ; private LinkedList < Integer > adj [ ] ; Graph ( int v ) { V = v ; adj = new LinkedList [ v ] ; for ( int i = 0 ; i < v ; ++ i ) adj [ i ] = new LinkedList ( ) ; } void addEdge ( int v , int w ) { adj [ v ] . add ( w ) ; } void DFSUtil ( int v , boolean visited [ ] ) { visited [ v ] = true ; System . out . print ( v + " ▁ " ) ; Iterator < Integer > i = adj [ v ] . listIterator ( ) ; while ( i . hasNext ( ) ) { int n = i . next ( ) ; if ( ! visited [ n ] ) DFSUtil ( n , visited ) ; } } void DFS ( int v ) { boolean visited [ ] = new boolean [ V ] ; DFSUtil ( v , visited ) ; } public static void main ( String args [ ] ) { Graph g = new Graph ( 4 ) ; g . addEdge ( 0 , 1 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 1 , 2 ) ; g . addEdge ( 2 , 0 ) ; g . addEdge ( 2 , 3 ) ; g . addEdge ( 3 , 3 ) ; System . out . println ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; g . DFS ( 2 ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void countDigits ( double val , long [ ] arr ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; } static void countFrequency ( int x , int n ) { long [ ] freq_count = new long [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { double val = Math . pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { System . out . print ( freq_count [ i ] + " ▁ " ) ; } } public static void main ( String args [ ] ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ; public class Coder { static int n ; static StringBuffer str = new StringBuffer ( ) ; static List < Long > a ; static void solve ( ) { Collections . sort ( a ) ; long cur = a . get ( 0 ) * 2 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a . get ( i ) . equals ( a . get ( i - 1 ) ) ) continue ; if ( a . get ( i ) < cur ) { str . append ( " YES \n " ) ; return ; } cur = a . get ( i ) * 2 ; } str . append ( " NO \n " ) ; } public static void main ( String [ ] args ) throws java . lang . Exception { BufferedReader bf ; PrintWriter pw ; boolean lenv = false ; if ( lenv ) { bf = new BufferedReader ( new FileReader ( " input . txt " ) ) ; pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( " output . txt " ) ) ) ; } else { bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; pw = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; } String s [ ] = bf . readLine ( ) . trim ( ) . split ( " \\ s + " ) ; n = Integer . parseInt ( s [ 0 ] ) ; a = new ArrayList < > ( ) ; s = bf . readLine ( ) . trim ( ) . split ( " \\ s + " ) ; for ( int i = 0 ; i < n ; i ++ ) a . add ( Long . parseLong ( s [ i ] ) ) ; solve ( ) ; pw . println ( str ) ; pw . flush ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t = scan . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scan . nextInt ( ) ; System . out . println ( maxLeft ( n ) ) ; } } public static int maxLeft ( int n ) { return n > 2 ? n - 2 : 0 ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; HashSet < Integer > hs = new HashSet < > ( ) ; int a = sc . nextInt ( ) ; for ( int i = 0 ; i < a ; i ++ ) { hs . add ( sc . nextInt ( ) ) ; } int b = sc . nextInt ( ) ; for ( int i = 0 ; i < b ; i ++ ) { hs . add ( sc . nextInt ( ) ) ; } if ( hs . size ( ) == n ) System . out . println ( " I ▁ become ▁ the ▁ guy . " ) ; else System . out . print ( " Oh , ▁ my ▁ keyboard ! " ) ; } }
import java . io . * ; public class GFG { static int m = 6 , n = 4 ; static int linearCheck ( int ar [ ] [ ] , int arr [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { boolean matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 0 , 1 , 0 } , { 10 , 9 , 22 , 23 } , { 40 , 40 , 40 , 40 } , { 43 , 44 , 55 , 68 } , { 81 , 73 , 100 , 132 } , { 100 , 75 , 125 , 133 } } ; int row [ ] = { 10 , 9 , 22 , 23 } ; System . out . println ( linearCheck ( mat , row ) ) ; } }
import java . util . Scanner ; public class CandyAndFriend { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t > 0 ) { int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; sum += a [ i ] ; } if ( sum % n == 0 ) { int div = sum / n ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > div ) { count ++ ; } } System . out . println ( count ) ; } else { System . out . println ( - 1 ) ; } t -- ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . solveD ( ) ; } private void solveD ( ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] t = new int [ N ] ; int sum_t = 0 ; for ( int i = 0 ; i < N ; i ++ ) { t [ i ] = sc . nextInt ( ) * 2 ; sum_t += t [ i ] ; } int [ ] v = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { v [ i ] = sc . nextInt ( ) * 2 ; } int tmp_v = 0 ; int tmp_t = 0 ; int [ ] max_v = new int [ sum_t + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { max_v [ tmp_t ] = v [ i ] < tmp_v ? v [ i ] : tmp_v ; tmp_v = max_v [ tmp_t ] ; for ( int t_ind = 0 ; t_ind < t [ i ] ; t_ind ++ ) { max_v [ ++ tmp_t ] = v [ i ] < tmp_v + 1 ? v [ i ] : tmp_v + 1 ; tmp_v = max_v [ tmp_t ] ; } } tmp_v = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { max_v [ tmp_t ] = v [ i ] < tmp_v ? v [ i ] : tmp_v ; tmp_v = max_v [ tmp_t ] ; for ( int t_ind = 0 ; t_ind < t [ i ] ; t_ind ++ ) { int back_v = v [ i ] < tmp_v + 1 ? v [ i ] : tmp_v + 1 ; -- tmp_t ; max_v [ tmp_t ] = max_v [ tmp_t ] < back_v ? max_v [ tmp_t ] : back_v ; tmp_v = max_v [ tmp_t ] ; } } double answer = 0 ; for ( int i = 0 ; i < sum_t ; i ++ ) { answer += ( max_v [ i ] + max_v [ i + 1 ] ) ; } System . out . println ( answer * 0.125 ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 7 * ( int ) Math . pow ( n , 2 ) - 7 * n + 7 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 3 ) + ( int ) Math . pow ( n , 2 ) ; } public static void main ( String arr [ ] ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) - n - 1 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) - 2 * n + 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + n - 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; public class shashwat { static Scanner in = new Scanner ( System . in ) ; public static void main ( String args [ ] ) { int n1 = in . nextInt ( ) ; int n2 = in . nextInt ( ) ; int x = Math . abs ( n1 ) + Math . abs ( n2 ) ; if ( n1 >= 0 && n2 >= 0 ) System . out . println ( 0 + " ▁ " + x + " ▁ " + x + " ▁ " + 0 ) ; else if ( n1 < 0 && n2 >= 0 ) System . out . println ( " - " + x + " ▁ " + 0 + " ▁ " + 0 + " ▁ " + x ) ; else if ( n1 < 0 && n2 < 0 ) System . out . println ( " - " + x + " ▁ " + 0 + " ▁ " + 0 + " ▁ - " + x ) ; else System . out . println ( 0 + " ▁ - " + x + " ▁ " + x + " ▁ " + 0 ) ; } }
import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { try ( Scanner in = new Scanner ( System . in ) ) { String s = in . nextLine ( ) ; int K = Integer . parseInt ( in . nextLine ( ) ) ; HashSet < String > subs = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int index = i ; for ( int j = 0 ; j < K ; j ++ ) { if ( index + 1 + j <= s . length ( ) ) { subs . add ( s . substring ( index , index + 1 + j ) ) ; } } } ArrayList < String > subs2 = new ArrayList < > ( ) ; subs2 . addAll ( subs ) ; Collections . sort ( subs2 ) ; System . out . println ( subs2 . get ( K - 1 ) ) ; } } }
import java . util . * ; class Solution { private List < Integer > memo ; public Solution ( ) { memo = new ArrayList ( ) ; memo . add ( 0 ) ; memo . add ( 1 ) ; } public int fib ( int N ) { if ( N < memo . size ( ) ) return memo . get ( N ) ; for ( int i = memo . size ( ) ; i <= N ; i ++ ) { memo . add ( memo . get ( i - 1 ) + memo . get ( i - 2 ) ) ; } return memo . get ( N ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int N = 2 ; int out = sObj . fib ( N ) ; System . out . println ( out ) ; } }
import java . io . PrintWriter ; import java . util . * ; public class ForbiddenSubsequence { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int [ ] alph = new int [ 26 ] ; String s = sc . next ( ) ; String abc = sc . next ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { alph [ s . charAt ( i ) - ' a ' ] ++ ; } if ( abc . equals ( " abc " ) && ( alph [ 0 ] > 0 && alph [ 1 ] > 0 && alph [ 2 ] > 0 ) ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 1 ) { while ( alph [ 2 ] > 0 ) { res . append ( ( char ) ( 2 + ' a ' ) ) ; alph [ 2 ] -- ; } while ( alph [ 1 ] > 0 ) { res . append ( ( char ) ( 1 + ' a ' ) ) ; alph [ 1 ] -- ; } i ++ ; } else { while ( alph [ i ] > 0 ) { res . append ( ( char ) ( i + ' a ' ) ) ; alph [ i ] -- ; } } } pw . println ( res ) ; } else { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { while ( alph [ i ] > 0 ) { res . append ( ( char ) ( i + ' a ' ) ) ; alph [ i ] -- ; } } pw . println ( res ) ; } } pw . flush ( ) ; } }
import java . lang . Math . * ; public class GFG { static final double PI = 3.142 ; static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } public static void main ( String [ ] args ) { float x = 50 ; int n = 5 ; System . out . println ( ( float ) ( cosXSertiesSum ( x , 5 ) * 1000000 ) / 1000000.00 ) ; } }
public class GFG { static float findNumber ( int N , int S ) { float i = ( ( ( float ) ( N ) * ( float ) ( N + 1 ) ) / 4 ) - ( ( float ) ( S + 1 ) / 2 ) ; return i ; } static void check ( int N , int S ) { float i = findNumber ( N , S ) ; int integerI = ( int ) i ; if ( i - integerI == 0 ) System . out . println ( " Yes : ▁ " + integerI + " , ▁ " + ( integerI + 1 ) ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int N = 4 , S = 3 ; check ( N , S ) ; N = 5 ; S = 3 ; check ( N , S ) ; } }
import java . io . * ; public class GFG { static boolean multipleOfThree ( int K , int dig0 , int dig1 ) { long sum = 0 ; int temp = ( dig0 + dig1 ) % 10 ; sum = dig0 + dig1 ; if ( K == 2 ) { if ( sum % 3 == 0 ) return true ; else return false ; } sum += temp ; long numberofGroups = ( K - 3 ) / 4 ; int remNumberofDigits = ( K - 3 ) % 4 ; sum += ( numberofGroups * 20 ) ; for ( int i = 0 ; i < remNumberofDigits ; i ++ ) { temp = ( 2 * temp ) % 10 ; sum += temp ; } if ( sum % 3 == 0 ) return true ; else return false ; } static public void main ( String [ ] args ) { int K = 5 , dig0 = 3 , dig1 = 4 ; if ( multipleOfThree ( K , dig0 , dig1 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; sum += a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) b [ i ] = sc . nextInt ( ) ; Arrays . sort ( b ) ; long ans = b [ n - 1 ] + b [ n - 2 ] ; if ( sum <= ans ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } catch ( Exception e ) { } } }
public class GFG { static int countOcc ( String s ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j < i + 4 ; j ++ ) { switch ( s . charAt ( j ) ) { case ' c ' : c ++ ; break ; case ' l ' : l ++ ; break ; case ' a ' : a ++ ; break ; case ' p ' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String s = " clapc " ; System . out . print ( countOcc ( s . toLowerCase ( ) ) ) ; } }
import java . io . * ; public class GFG { static int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; } public static void main ( String [ ] args ) { int x = 100 , y = 19 ; System . out . println ( countSteps ( x , y ) ) ; } }
public class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 3 ; if ( isSunnyNum ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . lang . * ; public class GFG { static double PI = 3.14159265 ; public static double area_inscribed ( double P , double B , double H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double P = 3 , B = 4 , H = 5 ; System . out . println ( area_inscribed ( P , B , H ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int N = sc . nextInt ( ) ; if ( N == 0 ) { break ; } char replaces [ ] = new char [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { replaces [ sc . next ( ) . toCharArray ( ) [ 0 ] ] = sc . next ( ) . toCharArray ( ) [ 0 ] ; } long M = sc . nextLong ( ) ; for ( long i = 0 ; i < M ; i ++ ) { char c = sc . next ( ) . toCharArray ( ) [ 0 ] ; System . out . print ( replaces [ c ] != 0 ? replaces [ c ] : c ) ; } System . out . println ( ) ; } } }
import java . util . * ; public class GFG { static int getCount ( int [ ] v , int n ) { Arrays . sort ( v ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) ; if ( tmp == v [ i ] ) cnt ++ ; } return cnt ; } static int upperBound ( int [ ] array , int length , int value ) { int low = 0 ; int high = length ; while ( low < high ) { final int mid = ( low + high ) / 2 ; if ( value >= array [ mid ] ) { low = mid + 1 ; } else { high = mid ; } } return low ; } public static void main ( String [ ] args ) { int n = 4 ; int [ ] v = { 1 , 2 , 3 , 4 } ; System . out . println ( getCount ( v , n ) ) ; } }
public class GFG { static int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = Math . min ( count_of_two , count_of_five ) ; return ans ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( trailing_zeros ( N ) ) ; } }
public class GfG { public static int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; } public static boolean isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 105 , b = 106 ; if ( isEqual ( a , b ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . LinkedList ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { new Main ( ) . mainrun ( ) ; } Scanner scan ; private int N ; private final long MOD = 1000000007 ; private Node [ ] node ; private void mainrun ( ) { scan = new Scanner ( System . in ) ; N = scan . nextInt ( ) ; node = new Node [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { node [ i ] = new Node ( scan . next ( ) ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { node [ scan . nextInt ( ) - 1 ] . child . add ( scan . nextInt ( ) - 1 ) ; } System . out . println ( looprun ( node [ 0 ] ) % MOD ) ; scan . close ( ) ; } private long looprun ( Node n ) { long ans = 1 ; switch ( n . type ) { case " E " : for ( Integer no : n . child ) { ans *= looprun ( node [ no ] ) ; ans %= MOD ; } if ( n . isOption ) { ans += 1 ; } break ; case " R " : for ( Integer no : n . child ) { ans *= looprun ( node [ no ] ) + 1 ; ans %= MOD ; } if ( ! n . isOption ) { ans -= 1 ; } break ; case " A " : for ( Integer no : n . child ) { ans += looprun ( node [ no ] ) ; } if ( ! n . isOption ) { ans -= 1 ; } break ; } return ans ; } } class Node { String type ; boolean isOption ; LinkedList < Integer > child ; Node ( String str ) { String [ ] sp = str . split ( " " ) ; type = sp [ 0 ] ; isOption = ( sp . length == 2 ) ; child = new LinkedList < > ( ) ; } }
import java . util . Arrays ; import java . util . Locale ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int size = scn . nextInt ( ) ; int [ ] arr = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = scn . nextInt ( ) ; } System . out . println ( asd ( arr ) ) ; } public static int asd ( int [ ] arr ) { Arrays . sort ( arr ) ; return arr [ arr . length / 2 ] ; } }
import java . util . * ; public class VasyaTheHipster { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a , b ; a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; int count = 0 ; while ( true ) { if ( a > 0 && b > 0 ) { count ++ ; a -- ; b -- ; } else break ; } int ans = a / 2 + b / 2 ; System . out . println ( count + " ▁ " + ans ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; public class Main { public static void main ( String [ ] args ) throws IOException { OutputStreamWriter osr = new OutputStreamWriter ( System . out ) ; PrintWriter o = new PrintWriter ( osr ) ; FastReader fr = new FastReader ( ) ; double n = fr . nextDouble ( ) , m = fr . nextDouble ( ) ; for ( int i = 0 ; i < m - ( n % m ) ; i ++ ) o . print ( ( int ) ( n / m ) + " ▁ " ) ; for ( int i = ( int ) ( m - ( n % m ) ) ; i < m ; i ++ ) o . print ( ( int ) ceil ( n / m ) + " ▁ " ) ; o . close ( ) ; } } class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { InputStreamReader isr = new InputStreamReader ( System . in ) ; br = new BufferedReader ( isr ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public String nextLine ( ) throws IOException { return br . readLine ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public int [ ] intArray ( int size ) throws IOException { int [ ] arr = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) arr [ i ] = nextInt ( ) ; return arr ; } public char [ ] charArray ( ) throws IOException { return nextLine ( ) . toCharArray ( ) ; } } class Pair { int x ; int y ; public Pair ( int x , int y ) { this . x = x ; this . y = y ; } static class Compare implements Comparator < Pair > { @ Override public int compare ( Pair o1 , Pair o2 ) { return ( o1 . y - o2 . y ) ; } } }
public class GFG { static int totalPairs ( String s1 , String s2 ) { int count = 0 ; int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s1 . charAt ( i ) ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s2 . charAt ( i ) ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) { count += ( arr1 [ i ] * arr2 [ i ] ) ; } return count ; } public static void main ( String [ ] args ) { String s1 = " geeks " ; String s2 = " forgeeks " ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }
public class GFG { static int countSubSeq ( int i , int sum , int cnt , int a [ ] , int n ) { if ( i == n ) { if ( sum == 0 && cnt > 0 ) { return 1 ; } else { return 0 ; } } int ans = 0 ; ans += countSubSeq ( i + 1 , sum , cnt , a , n ) ; ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) ; return ans ; } public static void main ( String [ ] args ) { int a [ ] = { - 1 , 2 , - 2 , 1 } ; int n = a . length ; System . out . println ( countSubSeq ( 0 , 0 , 0 , a , n ) ) ; } }
import java . util . Scanner ; public class Decoding { public static void main ( String [ ] args ) { Scanner reader = new Scanner ( System . in ) ; int n = reader . nextInt ( ) ; char [ ] s = new char [ n ] ; char [ ] newS = new char [ n ] ; String input = reader . next ( ) ; s = input . toCharArray ( ) ; int mid = ( n - 1 ) / 2 ; int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = i + 1 ; if ( n % 2 == 0 ) { newS [ mid - counter ] = s [ i ] ; } else { newS [ mid + counter ] = s [ i ] ; } if ( counter >= 0 ) { counter = counter - temp ; } else { counter = counter + temp ; } } System . out . println ( new String ( newS ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int count = 0 ; for ( int i = 1 ; Math . pow ( i + a , n ) <= m ; i ++ ) { int x = ( int ) ( Math . pow ( i + a , n ) ) ; int y = getCount ( x ) ; if ( y == i ) { count ++ ; } } System . out . println ( count ) ; } static int getCount ( int x ) { int count = 0 ; while ( x > 0 ) { count += x % 10 ; x /= 10 ; } return count ; } }
class Main { static int pivotedBinarySearch ( int arr [ ] , int n , int key ) { int pivot = findPivot ( arr , 0 , n - 1 ) ; if ( pivot == - 1 ) return binarySearch ( arr , 0 , n - 1 , key ) ; if ( arr [ pivot ] == key ) return pivot ; if ( arr [ 0 ] <= key ) return binarySearch ( arr , 0 , pivot - 1 , key ) ; return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; } static int findPivot ( int arr [ ] , int low , int high ) { if ( high < low ) return - 1 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ( mid - 1 ) ; if ( arr [ low ] >= arr [ mid ] ) return findPivot ( arr , low , mid - 1 ) ; return findPivot ( arr , mid + 1 , high ) ; } static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } public static void main ( String args [ ] ) { int arr1 [ ] = { 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 } ; int n = arr1 . length ; int key = 3 ; System . out . println ( " Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ " + pivotedBinarySearch ( arr1 , n , key ) ) ; } }
import java . util . Scanner ; public class HocJava { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n , mod = 1000000007 ; n = sc . nextInt ( ) ; long res = 0 ; long [ ] [ ] c = new long [ 4050 ] [ 4050 ] ; long [ ] dp = new long [ 4050 ] ; for ( int i = 1 ; i <= n ; i ++ ) { c [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; j ++ ) { c [ i ] [ j ] = ( c [ i - 1 ] [ j - 1 ] + c [ i - 1 ] [ j ] ) % mod ; } c [ i ] [ i ] = 1 ; } dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) dp [ i ] = ( dp [ i ] + dp [ j ] * c [ i - 1 ] [ j ] ) % mod ; } for ( int i = 0 ; i < n ; i ++ ) { long g = dp [ i ] * c [ n ] [ i ] % mod ; res = ( res + g ) % mod ; } System . out . println ( res ) ; } }
import java . awt . Point ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class A843 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; Point [ ] P = new Point [ N ] ; for ( int n = 0 ; n < N ; n ++ ) { P [ n ] = new Point ( n , in . nextInt ( ) ) ; } Arrays . sort ( P , new Comparator < Point > ( ) { @ Override public int compare ( Point o1 , Point o2 ) { return o1 . y - o2 . y ; } } ) ; StringBuilder output = new StringBuilder ( ) ; int lineCount = 0 ; boolean [ ] used = new boolean [ N ] ; for ( int n = 0 ; n < N ; n ++ ) { if ( ! used [ n ] ) { lineCount ++ ; int count = 0 ; int pos = n ; StringBuilder line = new StringBuilder ( ) ; while ( ! used [ pos ] ) { count ++ ; used [ pos ] = true ; line . append ( ' ▁ ' ) . append ( pos + 1 ) ; pos = P [ pos ] . x ; } output . append ( count ) . append ( line ) . append ( ' \n ' ) ; } } System . out . println ( lineCount ) ; System . out . print ( output ) ; } }
import java . util . * ; import java . io . * ; class Main { public static void main ( String [ ] args ) { final Scanner stdin = new Scanner ( System . in ) ; final int d = stdin . nextInt ( ) ; int [ ] dx = { 0 , 1 , 0 , - 1 } ; int [ ] dy = { - 1 , 0 , 1 , 0 } ; final int UP = 0 ; final int RIGHT = 1 ; final int DOWN = 2 ; final int LEFT = 3 ; for ( int t = 0 ; t < d ; t ++ ) { final int n = stdin . nextInt ( ) ; char [ ] [ ] map = new char [ n ] [ n ] ; for ( char [ ] array : map ) { Arrays . fill ( array , ' ▁ ' ) ; } int x = 0 ; int y = n ; int dir = UP ; int [ ] move = getMoveDistance ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < move [ i ] ; j ++ ) { x += dx [ dir ] ; y += dy [ dir ] ; map [ y ] [ x ] = ' # ' ; } dir = ( dir + 1 ) % 4 ; } for ( char [ ] array : map ) { System . out . println ( new String ( array ) ) ; } if ( t < d - 1 ) { System . out . println ( ) ; } } } static int [ ] getMoveDistance ( final int n ) { if ( n == 1 ) { int [ ] ans = { 1 } ; return ans ; } else { int [ ] ans = new int [ n ] ; ans [ 0 ] = n ; int rest = n ; rest -= 1 ; for ( int index = 1 ; index < n ; ) { ans [ index ] = rest ; index ++ ; if ( index >= n ) { break ; } ans [ index ] = rest ; index ++ ; rest -= 2 ; } return ans ; } } }
public final class p090 { public static void main ( String [ ] args ) { System . out . println ( new p090 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { for ( int j = i ; j < ( 1 << 10 ) ; j ++ ) { if ( Integer . bitCount ( i ) == 6 && Integer . bitCount ( j ) == 6 && isArrangementValid ( i , j ) ) count ++ ; } } return Integer . toString ( count ) ; } private static int [ ] [ ] SQUARES = { { 0 , 1 } , { 0 , 4 } , { 0 , 9 } , { 1 , 6 } , { 2 , 5 } , { 3 , 6 } , { 4 , 9 } , { 6 , 4 } , { 8 , 1 } } ; private static boolean isArrangementValid ( int a , int b ) { if ( testBit ( a , 6 ) || testBit ( a , 9 ) ) a |= ( 1 << 6 ) | ( 1 << 9 ) ; if ( testBit ( b , 6 ) || testBit ( b , 9 ) ) b |= ( 1 << 6 ) | ( 1 << 9 ) ; for ( int [ ] sqr : SQUARES ) { if ( ! ( testBit ( a , sqr [ 0 ] ) && testBit ( b , sqr [ 1 ] ) || testBit ( a , sqr [ 1 ] ) && testBit ( b , sqr [ 0 ] ) ) ) return false ; } return true ; } private static boolean testBit ( int x , int i ) { return ( ( x >>> i ) & 1 ) != 0 ; } }
import java . util . LinkedList ; import java . util . Scanner ; import java . util . Iterator ; class Graph { private int totalVertex ; private LinkedList < LinkedList < Integer > > adjList ; public Graph ( ) { totalVertex = 0 ; } public void loadAdjList ( ) { Scanner in = new Scanner ( System . in ) ; totalVertex = in . nextInt ( ) ; adjList = new LinkedList < LinkedList < Integer > > ( ) ; for ( int i = 0 ; i < totalVertex ; i ++ ) { LinkedList < Integer > tmp = new LinkedList < Integer > ( ) ; int idx1 = in . nextInt ( ) - 1 ; int degree = in . nextInt ( ) ; for ( int j = 0 ; j < degree ; j ++ ) { int idx2 = in . nextInt ( ) - 1 ; tmp . add ( idx2 ) ; } adjList . add ( tmp ) ; } in . close ( ) ; } public void printAdjMatrix ( ) { Integer [ ] [ ] adjMatrix = new Integer [ totalVertex ] [ totalVertex ] ; for ( int i = 0 ; i < totalVertex ; i ++ ) { LinkedList < Integer > vertexes = this . adjList . get ( i ) ; for ( int j = 0 ; j < totalVertex ; j ++ ) { if ( vertexes . contains ( j ) ) { adjMatrix [ i ] [ j ] = 1 ; System . out . print ( "1" ) ; } else { adjMatrix [ i ] [ j ] = 0 ; System . out . print ( "0" ) ; } if ( j != totalVertex - 1 ) { System . out . print ( " ▁ " ) ; } } System . out . println ( ) ; } } } public class Main { public static void main ( String argv [ ] ) { Graph g = new Graph ( ) ; g . loadAdjList ( ) ; g . printAdjMatrix ( ) ; } }
import java . util . Scanner ; import java . util . Arrays ; public class Main1 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; char [ ] [ ] pic = new char [ n ] [ m ] ; String temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = sc . next ( ) ; for ( int j = 0 ; j < m ; j ++ ) { pic [ i ] [ j ] = temp . charAt ( j ) ; } } int inc = 0 , inc1 = 0 ; boolean [ ] comeIn = new boolean [ 4 ] ; if ( n > 1 || m > 1 ) { for ( int x = 0 ; x < n - 1 ; x ++ ) { for ( int y = 0 ; y < m - 1 ; y ++ ) { for ( int i = x ; i < 2 + x ; i ++ ) { for ( int j = y ; j < 2 + y ; j ++ ) { if ( pic [ i ] [ j ] == ' f ' && comeIn [ 0 ] == false ) { inc ++ ; comeIn [ 0 ] = true ; } else if ( pic [ i ] [ j ] == ' a ' && comeIn [ 1 ] == false ) { inc ++ ; comeIn [ 1 ] = true ; } else if ( pic [ i ] [ j ] == ' c ' && comeIn [ 2 ] == false ) { inc ++ ; comeIn [ 2 ] = true ; } else if ( pic [ i ] [ j ] == ' e ' && comeIn [ 3 ] == false ) { inc ++ ; comeIn [ 3 ] = true ; } } } if ( inc == 4 ) inc1 ++ ; inc = 0 ; Arrays . fill ( comeIn , false ) ; } } System . out . println ( inc1 ) ; } else { System . out . println ( "0" ) ; } sc . close ( ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Stack ; public class AlternatingCurrent { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; char [ ] in = br . readLine ( ) . trim ( ) . toCharArray ( ) ; Stack < Character > stk = new Stack < > ( ) ; for ( Character c : in ) { if ( stk . isEmpty ( ) ) { stk . push ( c ) ; continue ; } char top = stk . peek ( ) ; if ( top == c ) { stk . pop ( ) ; } else { stk . push ( c ) ; } } if ( stk . isEmpty ( ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class Main { static int X , Y , E ; static int [ ] x , y ; static ArrayList < Integer > [ ] g ; static boolean [ ] vis ; static int [ ] matchTo ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; X = sc . nextInt ( ) ; Y = sc . nextInt ( ) ; E = sc . nextInt ( ) ; x = new int [ E ] ; y = new int [ E ] ; g = new ArrayList [ X + Y ] ; for ( int i = 0 ; i < X + Y ; ++ i ) { g [ i ] = new ArrayList < > ( ) ; } for ( int i = 0 ; i < E ; ++ i ) { x [ i ] = sc . nextInt ( ) ; y [ i ] = sc . nextInt ( ) + X ; g [ x [ i ] ] . add ( y [ i ] ) ; g [ y [ i ] ] . add ( x [ i ] ) ; } vis = new boolean [ X + Y ] ; matchTo = new int [ X + Y ] ; Arrays . fill ( matchTo , - 1 ) ; int match = 0 ; for ( int i = 0 ; i < X ; ++ i ) { Arrays . fill ( vis , false ) ; if ( dfs ( i ) ) ++ match ; } System . out . println ( match ) ; } static boolean dfs ( int v ) { if ( v < 0 ) return true ; for ( int u : g [ v ] ) { if ( vis [ u ] ) continue ; vis [ u ] = true ; if ( dfs ( matchTo [ u ] ) ) { matchTo [ u ] = v ; matchTo [ v ] = u ; return true ; } } return false ; } }
import java . util . * ; public class GFG { static int MAX = 100 ; static int countMountains ( int a [ ] [ ] , int n ) { int [ ] [ ] A = new int [ n + 2 ] [ n + 2 ] ; int count = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) { for ( int j = 0 ; j < n + 2 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) { A [ i ] [ j ] = Integer . MIN_VALUE ; } else { A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; System . out . print ( countMountains ( a , n ) ) ; } }
public class GFG { static int N = 100005 ; static int d [ ] = new int [ N ] , pre [ ] = new int [ N ] ; static void Positive_Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } } public static void main ( String [ ] args ) { Positive_Divisors ( ) ; int n = 15 ; System . out . println ( pre [ n ] ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; int m = s . nextInt ( ) ; int [ ] memory = new int [ m ] ; int allocIdx = 0 ; for ( int j = 0 ; j < t ; j ++ ) { switch ( s . next ( ) ) { case " alloc " : int n = s . nextInt ( ) ; int len = 0 ; boolean canAlloc = false ; for ( int i = 0 ; i < m ; i ++ ) { if ( memory [ i ] == 0 ) len ++ ; else len = 0 ; if ( len == n ) { canAlloc = true ; len = i - n + 1 ; break ; } } if ( canAlloc ) { allocIdx ++ ; for ( int i = len ; i < len + n ; i ++ ) memory [ i ] = allocIdx ; System . out . println ( allocIdx ) ; } else System . out . println ( " NULL " ) ; break ; case " erase " : int x = s . nextInt ( ) ; if ( x <= 0 ) { System . out . println ( " ILLEGAL _ ERASE _ ARGUMENT " ) ; break ; } boolean hasErased = false ; for ( int i = 0 ; i < m ; i ++ ) { if ( memory [ i ] == x ) { memory [ i ] = 0 ; hasErased = true ; } } if ( ! hasErased ) System . out . println ( " ILLEGAL _ ERASE _ ARGUMENT " ) ; break ; case " defragment " : int d = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( memory [ i ] == 0 ) d ++ ; else memory [ i - d ] = memory [ i ] ; } for ( int i = m - d ; i < m ; i ++ ) memory [ i ] = 0 ; break ; default : System . out . println ( " h " ) ; break ; } } s . close ( ) ; } }
import java . util . * ; public class GFG { static double area_of_regular_polygon ( double n , double len ) { double P = ( len * n ) ; double A = len / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; double area = ( P * A ) / 2 ; return area ; } static double area_of_triangle_inscribed ( double n , double len ) { double area = area_of_regular_polygon ( n , len ) ; double triangle = area / n ; double ins_tri = ( triangle * 3 ) ; return ins_tri ; } static public void main ( String [ ] arg ) { double n = 6 , len = 10 ; System . out . printf ( " % .3f " , area_of_triangle_inscribed ( n , len ) ) ; } }
public class GFG { static final int MAX = 256 ; static String lastNonRepeating ( String str , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . charAt ( i ) ; if ( freq [ ch ] == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int n = str . length ( ) ; System . out . println ( lastNonRepeating ( str , n ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; int left = Integer . MAX_VALUE , right = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; b [ i ] = in . nextInt ( ) ; left = Math . min ( a [ i ] , left ) ; right = Math . max ( b [ i ] , right ) ; } int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == left && b [ i ] == right ) { ans = i + 1 ; break ; } } pw . println ( ans ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
public class GFG { static float y ( float x ) { return ( 1 / ( 1 + x ) ) ; } static float BooleRule ( float a , float b ) { int n = 4 ; int h ; h = ( int ) ( ( b - a ) / n ) ; float sum = 0 ; float bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; } public static void main ( String [ ] args ) { System . out . printf ( ( " f ( x ) ▁ = ▁ % .4f " ) , BooleRule ( 0 , 4 ) ) ; } }
import java . util . * ; public class GFG { static int maxN = 300 ; static int maxM = 300 ; static int dp [ ] [ ] = new int [ maxN ] [ maxM ] ; static boolean v [ ] [ ] = new boolean [ maxN ] [ maxM ] ; static int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = arr . length ; int m = 3 ; int ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) ; if ( ans == - 1 ) System . out . print ( 0 ) ; else System . out . print ( ans ) ; } }
public class GFG { static int maxN = 20 ; static int maxM = 64 ; static int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; static boolean [ ] [ ] v = new boolean [ maxN ] [ maxM ] ; static int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = arr . length ; int m = 3 ; int ans = findLen ( arr , 0 , 0 , n , m ) ; if ( ans == - 1 ) System . out . println ( 0 ) ; else System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { static int cost [ ] [ ] ; static int n ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; for ( ; ; ) { n = in . nextInt ( ) ; if ( n == 0 ) return ; cost = new int [ n + 1 ] [ n + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; cost [ a ] [ b ] = cost [ b ] [ a ] = c ; ans += cost [ a ] [ b ] * 2 ; } for ( int i = 1 ; i <= n ; i ++ ) { int reaf = 0 ; int ii = 0 , jj = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( cost [ i ] [ j ] > 0 || cost [ i ] [ j ] == - 1 ) { reaf ++ ; ii = i ; jj = j ; } } if ( i != 1 && reaf == 1 ) { ans -= cost [ ii ] [ jj ] * 2 ; cost [ ii ] [ jj ] = cost [ jj ] [ ii ] = - 1 ; } } System . out . println ( ans - max ( 1 ) ) ; } } static int max ( int m ) { int cut = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( cost [ m ] [ i ] > 0 ) { cost [ i ] [ m ] = 0 ; cut = Math . max ( cut , cost [ m ] [ i ] + max ( i ) ) ; } } return cut ; } }
import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int N ; public static void main ( String [ ] args ) { String S = sc . next ( ) ; N = Integer . parseInt ( S ) ; int ans = 0 ; for ( int i = 3 ; i <= S . length ( ) - 1 ; i ++ ) { ans += ( int ) Math . pow ( 3 , i ) - 3 * ( int ) Math . pow ( 2 , i ) + 3 ; } ans += f ( 3 * ( int ) Math . pow ( 10 , S . length ( ) - 1 ) , S . length ( ) - 2 ) ; ans += f ( 5 * ( int ) Math . pow ( 10 , S . length ( ) - 1 ) , S . length ( ) - 2 ) ; ans += f ( 7 * ( int ) Math . pow ( 10 , S . length ( ) - 1 ) , S . length ( ) - 2 ) ; System . out . println ( ans ) ; } static int f ( int a , int m ) { if ( m >= 0 ) { return f ( a + 3 * ( int ) Math . pow ( 10 , m ) , m - 1 ) + f ( a + 5 * ( int ) Math . pow ( 10 , m ) , m - 1 ) + f ( a + 7 * ( int ) Math . pow ( 10 , m ) , m - 1 ) ; } else { String s = Integer . toString ( a ) ; if ( s . indexOf ( "3" ) != - 1 && s . indexOf ( "5" ) != - 1 && s . indexOf ( "7" ) != - 1 && a <= N ) { return 1 ; } else { return 0 ; } } } }
import java . util . * ; public class GFG { static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 100 , 300 , 200 , 1000 , 20 , 30 } ; int n = arr . length ; int k = 3 ; System . out . println ( minDiff ( arr , n , k ) ) ; } }
import java . util . * ; class Main { int n ; int [ ] t = new int [ 10 ] ; Main ( ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; while ( n > 0 ) { n -- ; for ( int i = 0 ; i < 10 ; i ++ ) { t [ i ] = sc . nextInt ( ) ; } System . out . println ( solve ( ) ) ; } } String solve ( ) { int L = 0 , R = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( L < t [ i ] ) L = t [ i ] ; else if ( R < t [ i ] ) R = t [ i ] ; else return " NO " ; } return " YES " ; } public static void main ( String [ ] args ) { new Main ( ) ; } }
import java . util . * ; public class problem1455b { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int x = sc . nextInt ( ) ; int val = 0 ; int turn = 0 ; while ( val < x ) { val += turn + 1 ; turn ++ ; } if ( val == x ) { System . out . println ( turn ) ; } else if ( val == x + 1 ) { System . out . println ( turn + 1 ) ; } else { System . out . println ( turn ) ; } } } }
import java . io . * ; public class GFG { static float Mean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } static float meanAbsDevtion ( float arr [ ] , int n ) { float absSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) absSum = absSum + Math . abs ( arr [ i ] - Mean ( arr , n ) ) ; return absSum / n ; } public static void main ( String [ ] args ) { float arr [ ] = { 10 , 15 , 15 , 17 , 18 , 21 } ; int n = arr . length ; System . out . println ( meanAbsDevtion ( arr , n ) ) ; } }
public final class p204 { public static void main ( String [ ] args ) { System . out . println ( new p204 ( ) . run ( ) ) ; } public String run ( ) { return Integer . toString ( count ( 0 , 1 ) ) ; } private static long LIMIT = Library . pow ( 10 , 9 ) ; private int [ ] primes = Library . listPrimes ( 100 ) ; private int count ( int primeIndex , long product ) { if ( primeIndex == primes . length ) return product <= LIMIT ? 1 : 0 ; else { int count = 0 ; while ( product <= LIMIT ) { count += count ( primeIndex + 1 , product ) ; product *= primes [ primeIndex ] ; } return count ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int maximumXOR ( int n , int l , int r ) { int x = 0 ; for ( int i = ( int ) ( Math . log ( r ) / Math . log ( 2 ) ) ; i >= 0 ; -- i ) { if ( ( n & ( 1 << i ) ) > 0 ) { if ( ( x > r ) || ( x + ( 1 << i ) - 1 < l ) ) x ^= ( 1 << i ) ; } else { if ( ( x ^ ( 1 << i ) ) <= r ) x ^= ( 1 << i ) ; } } return n ^ x ; } public static void main ( String args [ ] ) { int n = 7 , l = 2 , r = 23 ; System . out . println ( " The ▁ output ▁ is ▁ " + maximumXOR ( n , l , r ) ) ; } }
import java . util . Vector ; public class GFG { static int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } } int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int CountTrailingZeros ( int n ) { String bit = Integer . toBinaryString ( n ) ; StringBuilder bit1 = new StringBuilder ( ) ; bit1 . append ( bit ) ; bit1 = bit1 . reverse ( ) ; int zero = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( bit1 . charAt ( i ) == '0' ) zero ++ ; else break ; } return zero ; } public static void main ( String [ ] args ) { int n = 4 ; int ans = CountTrailingZeros ( n ) ; System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Shopping { public void input ( int numberOne , int numberTwo , int numberThree ) { int one = numberOne + numberTwo + numberThree ; int two = 2 * ( numberOne + numberTwo ) ; int three = 2 * ( numberOne + numberThree ) ; int four = 2 * ( numberTwo + numberThree ) ; System . out . println ( java . lang . Math . min ( java . lang . Math . min ( one , two ) , java . lang . Math . min ( three , four ) ) ) ; } public static void main ( String [ ] a ) { Scanner input = new Scanner ( System . in ) ; Shopping instance = new Shopping ( ) ; int numOne = input . nextInt ( ) ; int numTwo = input . nextInt ( ) ; int numThree = input . nextInt ( ) ; instance . input ( numOne , numTwo , numThree ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { FastScanner input = new FastScanner ( ) ; int tc = input . nextInt ( ) ; work : while ( tc -- > 0 ) { int n = input . nextInt ( ) ; long a [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = input . nextLong ( ) ; } int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { count ++ ; i ++ ; } } System . out . println ( count ) ; } } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) throws IOException { return br . readLine ( ) ; } } }
import java . util . * ; public class GFG { static int distinctSubString ( String P , String Q , int K , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P . charAt ( j ) - ' a ' ; sum += Q . charAt ( pos ) - '0' ; s += P . charAt ( j ) ; if ( sum <= K ) { S . add ( s ) ; } else { break ; } } } return S . size ( ) ; } public static void main ( String [ ] args ) { String P = " abcde " ; String Q = "12345678912345678912345678" ; int K = 5 ; int N = P . length ( ) ; System . out . print ( distinctSubString ( P , Q , K , N ) ) ; } }
public class GFG { static char [ ] makeEven ( String string ) { char [ ] str = string . toCharArray ( ) ; int n = str . length ; int even = Integer . MAX_VALUE , index = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( str [ i ] - '0' ) % 2 == 0 ) { even = ( str [ i ] - '0' ) ; index = i ; } if ( even <= ( str [ n - 1 ] - '0' ) ) { break ; } } if ( even == Integer . MAX_VALUE ) { return str ; } swap ( str , index , n - 1 ) ; return str ; } static void swap ( char [ ] str , int index1 , int index2 ) { char temp = str [ index1 ] ; str [ index1 ] = str [ index2 ] ; str [ index2 ] = temp ; } public static void main ( String [ ] args ) { String str = "1356425" ; System . out . print ( makeEven ( str ) ) ; } }
public class GFG { static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( div [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; findDivisors ( n ) ; } }
import java . util . * ; public class ProB { static int a , b ; static long ans ; static String ss ; static char [ ] aa , bb ; static int [ ] mm = new int [ 200005 ] ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; ss = in . next ( ) ; aa = ss . toCharArray ( ) ; a = ss . length ( ) ; ss = in . next ( ) ; bb = ss . toCharArray ( ) ; b = ss . length ( ) ; for ( int i = 1 ; i <= b ; i ++ ) mm [ i ] = mm [ i - 1 ] + bb [ i - 1 ] - '0' ; for ( int i = 0 ; i < a ; i ++ ) { if ( aa [ i ] == '0' ) ans += ( long ) mm [ b - a + i + 1 ] - mm [ i ] ; else ans += ( long ) b - a + 1 - ( mm [ b - a + i + 1 ] - mm [ i ] ) ; } System . out . println ( ans ) ; } }
import java . util . Arrays ; public class GFG { static final int MAX_CHAR = 256 ; static void printDistinct ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ▁ ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR && index [ i ] != n ; i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ; } public static void main ( String args [ ] ) { String str = " GeeksforGeeks " ; printDistinct ( str ) ; } }
public class GFG { static int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; } public static void main ( String args [ ] ) { int x = 5 , k = 2 , m = 3 ; System . out . println ( calculate ( x , k , m ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Main { static void converthenumber ( int n ) { String s = Integer . toString ( n ) ; String res = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' || s . charAt ( i ) == '3' || s . charAt ( i ) == '5' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) res += s . charAt ( i ) ; if ( res . length ( ) == 2 ) break ; } if ( res . length ( ) == 2 ) System . out . println ( res ) ; else System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { int n = 18720 ; converthenumber ( n ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; List < String > chk = new ArrayList < > ( ) ; for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) { chk . add ( c1 + " " ) ; } for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) { for ( char c2 = ' a ' ; c2 <= ' z ' ; c2 ++ ) { chk . add ( c1 + " " + c2 ) ; } } for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) { for ( char c2 = ' a ' ; c2 <= ' z ' ; c2 ++ ) { for ( char c3 = ' a ' ; c3 <= ' z ' ; c3 ++ ) { chk . add ( c1 + " " + c2 + " " + c3 ) ; } } } int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; String s = sc . next ( ) ; for ( String str : chk ) { if ( s . contains ( str ) ) continue ; System . out . println ( str ) ; break ; } } } public static boolean isPowerOfTen ( long input ) { if ( input % 10 != 0 || input == 0 ) { return false ; } if ( input == 10 ) { return true ; } return isPowerOfTen ( input / 10 ) ; } static boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long lcm ( long a , long b ) { return ( a / gcd ( a , b ) ) * b ; } }
import java . util . * ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; public class Main { static class Reader { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer tokenizer = new StringTokenizer ( " " ) ; String next ( ) throws IOException { while ( ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; } int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } void close ( ) throws IOException { reader . close ( ) ; } } public static void main ( String [ ] args ) throws IOException { Reader sc = new Reader ( ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int TT = sc . nextInt ( ) ; while ( TT -- > 0 ) { HashSet < Integer > set = new HashSet < > ( ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) set . add ( sc . nextInt ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) out . print ( Math . max ( i + 1 , set . size ( ) ) + " ▁ " ) ; } out . flush ( ) ; } }
import java . io . * ; public class GFG { static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } static int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } static public void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; char [ ] [ ] field = new char [ h ] [ ] ; int [ ] [ ] orbs = new int [ h + 1 ] [ w + 1 ] ; int [ ] [ ] ingots = new int [ h + 1 ] [ w + 1 ] ; for ( int i = 0 ; i < h ; i ++ ) { field [ i ] = sc . next ( ) . toCharArray ( ) ; for ( int j = w - 1 ; j >= 0 ; j -- ) { orbs [ i ] [ j ] = orbs [ i ] [ j + 1 ] ; if ( field [ i ] [ j ] == ' O ' ) { orbs [ i ] [ j ] ++ ; } } } for ( int j = 0 ; j < w ; j ++ ) { for ( int i = h - 1 ; i >= 0 ; i -- ) { ingots [ i ] [ j ] = ingots [ i + 1 ] [ j ] ; if ( field [ i ] [ j ] == ' I ' ) { ingots [ i ] [ j ] ++ ; } } } long total = 0 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( field [ i ] [ j ] == ' J ' ) { total += orbs [ i ] [ j ] * ingots [ i ] [ j ] ; } } } System . out . println ( total ) ; } }
import java . io . * ; public class GFG { static int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i < Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % k == 0 ) { count ++ ; } if ( ( n / i ) % k == 0 ) { count ++ ; } } } if ( ( i * i == n ) && ( i % k == 0 ) ) { count -- ; } return count ; } public static void main ( String [ ] args ) { int n = 12 , k = 3 ; System . out . println ( countDivisors ( n , k ) ) ; } }
import java . io . * ; public class GFG { static int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 12 , k = 3 ; System . out . println ( countDivisors ( n , k ) ) ; } }
public class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int findModuloByM ( int X , int N , int M ) { if ( N < 6 ) { String temp = " " ; for ( int i = 0 ; i < N ; i ++ ) temp = temp + ( char ) ( X + 48 ) ; int res = Integer . parseInt ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } public static void main ( String [ ] args ) { int X = 6 , N = 14 , M = 9 ; System . out . println ( findModuloByM ( X , N , M ) ) ; } }
import java . util . * ; public class IntegerPoints { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; long out [ ] = new long [ t ] ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int p2 = 0 ; for ( int j = 0 ; j < n ; j ++ ) { p2 += ( sc . nextInt ( ) % 2 + 1 ) % 2 ; } int m = sc . nextInt ( ) ; int q2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { q2 += ( sc . nextInt ( ) % 2 + 1 ) % 2 ; } out [ i ] = ( long ) p2 * q2 + ( long ) ( n - p2 ) * ( m - q2 ) ; } for ( int i = 0 ; i < t ; i ++ ) { System . out . println ( out [ i ] ) ; } } }
import java . io . * ; public class GFG { static int findMaxDiff ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( " Invalid ▁ " ) ; return 0 ; } int min_val = Integer . MAX_VALUE , max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - i ) > max_val ) max_val = arr [ i ] - i ; if ( ( arr [ i ] - i ) < min_val ) min_val = arr [ i ] - i ; } return ( max_val - min_val ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 15 , 4 , 12 , 13 } ; int n = arr . length ; System . out . println ( findMaxDiff ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; public class B1150 { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String [ ] [ ] arr = new String [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String line = br . readLine ( ) ; for ( int k = 0 ; k < n ; k ++ ) { arr [ i ] [ k ] = line . charAt ( k ) + " " ; } } System . out . println ( solve ( arr , n ) ) ; } public static String solve ( String [ ] [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] [ k ] . equals ( " . " ) ) { if ( i + 2 < n && k + 1 < n && k - 1 >= 0 ) { if ( arr [ i ] [ k ] . equals ( " . " ) && arr [ i + 1 ] [ k ] . equals ( " . " ) && arr [ i + 1 ] [ k - 1 ] . equals ( " . " ) && arr [ i + 1 ] [ k + 1 ] . equals ( " . " ) && arr [ i + 2 ] [ k ] . equals ( " . " ) ) { arr [ i ] [ k ] = " # " ; arr [ i + 1 ] [ k ] = " # " ; arr [ i + 1 ] [ k - 1 ] = " # " ; arr [ i + 1 ] [ k + 1 ] = " # " ; arr [ i + 2 ] [ k ] = " # " ; } else { return " NO " ; } } else { return " NO " ; } } } } return " YES " ; } }
public class GFG { static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }
import java . util . * ; import java . util . Arrays ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; long a [ ] = new long [ n ] ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; sum += a [ i ] ; } if ( sum % n != 0 ) { System . out . println ( " NO " ) ; } else { sum /= n ; boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == sum ) { flag = true ; break ; } } if ( flag ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } }
public class GFG { static boolean isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) == 1 ) return true ; return false ; } static int setKthBit ( int n , int k ) { return ( ( 1 << ( k - 1 ) ) | n ) ; } static boolean allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } static boolean bitsAreInAltOrder ( int n ) { int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; } static boolean bitsAreInAltPatrnInGivenRange ( int n , int l , int r ) { int num , left_shift ; if ( isKthBitSet ( n , r ) ) { num = n ; left_shift = r ; } else { num = setKthBit ( n , ( r + 1 ) ) ; left_shift = r + 1 ; } num = num & ( ( 1 << left_shift ) - 1 ) ; num = num >> ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; } public static void main ( String [ ] args ) { int n = 18 ; int l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; } static int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; } static int NumberOfWays ( int n , int x , int y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; } public static void main ( String [ ] args ) throws java . lang . Exception { int n = 5 , x = 4 , y = 2 ; System . out . println ( NumberOfWays ( n , x , y ) ) ; } }
import java . util . Arrays ; public class GFG { static String commonPrefixUtil ( String str1 , String str2 ) { String result = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( j ) ) { break ; } result += str1 . charAt ( i ) ; } return ( result ) ; } static void commonPrefix ( String arr [ ] , int n ) { Arrays . sort ( arr ) ; System . out . println ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) ; } public static void main ( String [ ] args ) { String arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = arr . length ; commonPrefix ( arr , n ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long a [ ] = new long [ N * 3 ] ; for ( int i = 0 ; i < N * 3 ; i ++ ) { a [ i ] = sc . nextLong ( ) ; } Arrays . sort ( a ) ; long sum = 0 ; for ( int i = N ; i < 3 * N ; i += 2 ) { sum += a [ i ] ; } System . out . println ( sum ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] a = new int [ N + 1 ] ; for ( int i = 1 ; i < N + 1 ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } sc . close ( ) ; int count = 0 ; boolean valid = true ; int current = 1 ; while ( valid ) { count ++ ; current = a [ current ] ; if ( current == 2 ) { valid = false ; } if ( count == N ) { count = 0 ; valid = false ; } } if ( count == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( count ) ; } } }
public final class p301 { public static void main ( String [ ] args ) { System . out . println ( new p301 ( ) . run ( ) ) ; } public String run ( ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int c = a + b ; a = b ; b = c ; } return Integer . toString ( a ) ; } }
import java . util . * ; public class GFG { static void findFrequencyUtil ( int arr [ ] , int low , int high , int [ ] freq ) { if ( arr [ low ] == arr [ high ] ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( low + high ) / 2 ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } } static void findFrequency ( int arr [ ] , int n ) { int [ ] freq = new int [ arr [ n - 1 ] + 1 ] ; findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr [ n - 1 ] ; i ++ ) if ( freq [ i ] != 0 ) System . out . println ( " Element ▁ " + i + " ▁ occurs ▁ " + freq [ i ] + " ▁ times " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 } ; int n = arr . length ; findFrequency ( arr , n ) ; } }
import java . util . Arrays ; public final class p070 { public static void main ( String [ ] args ) { System . out . println ( new p070 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 7 ) ; public String run ( ) { int minNumer = 1 ; int minDenom = 0 ; int [ ] totients = Library . listTotients ( LIMIT - 1 ) ; for ( int n = 2 ; n < totients . length ; n ++ ) { int tot = totients [ n ] ; if ( ( long ) n * minDenom < ( long ) minNumer * tot && hasSameDigits ( n , tot ) ) { minNumer = n ; minDenom = tot ; } } if ( minDenom == 0 ) throw new RuntimeException ( " Not ▁ found " ) ; return Integer . toString ( minNumer ) ; } private static boolean hasSameDigits ( int x , int y ) { char [ ] xdigits = Integer . toString ( x ) . toCharArray ( ) ; char [ ] ydigits = Integer . toString ( y ) . toCharArray ( ) ; Arrays . sort ( xdigits ) ; Arrays . sort ( ydigits ) ; return Arrays . equals ( xdigits , ydigits ) ; } }
import java . io . * ; public class GFG { static void intersection ( int a [ ] , int b [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { System . out . print ( a [ i ] + " ▁ " ) ; i ++ ; j ++ ; } } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 } ; int b [ ] = { 3 , 3 , 5 } ; int n = a . length ; int m = b . length ; intersection ( a , b , n , m ) ; } }
import java . util . * ; public class GFG { static int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; int x = ( int ) Math . exp ( sum / n ) ; return x + 1 ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 4 } ; int n = a . length ; System . out . println ( findMin ( a , n ) ) ; } }
import java . util . * ; class solution { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } static int minPerfectSquare ( int arr [ ] , int n ) { int minPerfectSq ; int lcm = lcmOfArray ( arr , n ) ; minPerfectSq = ( int ) lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 2 != 0 ) minPerfectSq *= 2 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 2 != 0 ) minPerfectSq *= i ; i += 2 ; } return minPerfectSq ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ; System . out . println ( minPerfectSquare ( arr , n ) ) ; } }
class cfg { static int subarrayCount ( int arr [ ] , int n ) { int result = 0 ; int fast = 0 , slow = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { fast ++ ; } else { int len = fast - slow + 1 ; result += len * ( len - 1 ) / 2 ; fast = i ; slow = i ; } } if ( fast != slow ) { int len = fast - slow + 1 ; result += len * ( len - 1 ) / 2 ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( subarrayCount ( arr , n ) ) ; } }
import java . util . * ; public class class1 { public static void main ( String arg [ ] ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; while ( t -- > 0 ) { long n = input . nextLong ( ) ; long ans = 0 ; int flag = 0 ; while ( n > 0 ) { int x = 0 ; if ( n % 2 == 0 ) { long temp = n / 2 ; if ( n % 4 == 0 && n > 8 ) { temp = n - 1 ; x ++ ; } n = temp ; if ( flag == 0 ) { flag = 1 ; if ( x > 0 ) { ans += 1 ; } else { ans += temp ; } } else { flag = 0 ; } } else { if ( flag == 0 ) { n = n - 1 ; ans += 1 ; flag = 1 ; } else { n = n - 1 ; flag = 0 ; } } } System . out . println ( ans ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new java . util . Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scan . nextInt ( ) ; } long sum , min , max ; sum = 0 ; max = - 1000000 ; min = 1000000 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( max <= a [ i ] ) { max = a [ i ] ; } if ( min >= a [ i ] ) { min = a [ i ] ; } } System . out . println ( min + " ▁ " + max + " ▁ " + sum ) ; } }
import java . util . Arrays ; public class GFG { static final int MAX_CHARS = 256 ; static String findSubString ( String str ) { int n = str . length ( ) ; int dist_count = 0 ; boolean [ ] visited = new boolean [ MAX_CHARS ] ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str . charAt ( i ) ] == false ) { visited [ str . charAt ( i ) ] = true ; dist_count ++ ; } } int start = 0 , start_index = - 1 ; int min_len = Integer . MAX_VALUE ; int count = 0 ; int [ ] curr_count = new int [ MAX_CHARS ] ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str . charAt ( j ) ] ++ ; if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str . charAt ( start ) ] > 1 ) { if ( curr_count [ str . charAt ( start ) ] > 1 ) curr_count [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } return str . substring ( start_index , start_index + min_len ) ; } public static void main ( String args [ ] ) { String str = " aabcbcdbca " ; System . out . println ( " Smallest ▁ window ▁ containing ▁ all ▁ distinct " + " ▁ characters ▁ is : ▁ " + findSubString ( str ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; double A = sc . nextInt ( ) ; double B = sc . nextInt ( ) ; double C = sc . nextInt ( ) ; double D = sc . nextInt ( ) ; double E = sc . nextInt ( ) ; double F = sc . nextInt ( ) ; double water = 0 ; double suger = 0 ; double watmax = 0 ; double sugmax = 0 ; double maxnodo = 100 * E / ( 100 + E ) ; double nodo = 0 ; double nodomax = 0 ; for ( int a = 0 ; a <= F / 100 ; a += A ) { for ( int b = 0 ; b <= F / 100 ; b += B ) { for ( int c = 0 ; c <= F ; c += C ) { for ( int d = 0 ; d <= F ; d += D ) { water = 100 * a + 100 * b ; suger = c + d ; if ( water == 0 || water + suger > F ) { break ; } nodo = 100 * suger / ( water + suger ) ; if ( nodo >= nodomax && nodo <= maxnodo ) { watmax = water ; sugmax = suger ; nodomax = nodo ; } } } } } System . out . println ( ( int ) watmax + ( int ) sugmax + " ▁ " + ( int ) sugmax ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] before = null ; while ( true ) { if ( ! sc . hasNext ( ) ) { break ; } String str [ ] = sc . next ( ) . split ( " , " ) ; int [ ] inner = new int [ str . length ] ; for ( int i = 0 ; i < str . length ; i ++ ) { inner [ i ] = Integer . parseInt ( str [ i ] ) ; } if ( before == null ) { before = inner ; } else { int [ ] tmp = new int [ inner . length ] ; for ( int i = 0 ; i < before . length ; i ++ ) { if ( i < tmp . length ) { if ( tmp [ i ] < before [ i ] + inner [ i ] ) { tmp [ i ] = before [ i ] + inner [ i ] ; } } if ( before . length > tmp . length ) { if ( ( i - 1 ) < tmp . length && ( i - 1 ) >= 0 ) { if ( tmp [ i - 1 ] < before [ i ] + inner [ i - 1 ] ) { tmp [ i - 1 ] = before [ i ] + inner [ i - 1 ] ; } } } else { if ( ( i + 1 ) < tmp . length ) { if ( tmp [ i + 1 ] < before [ i ] + inner [ i + 1 ] ) { tmp [ i + 1 ] = before [ i ] + inner [ i + 1 ] ; } } } } before = tmp ; } } System . out . println ( before [ 0 ] ) ; } }
public class GFG { static void countPairs ( int arr [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } System . out . println ( ( even ) * ( n - 1 ) ) ; System . out . println ( ( odd ) * ( n - 1 ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int n = arr . length ; countPairs ( arr , n ) ; } }
import java . util . Scanner ; public class A1613 { private static final double [ ] POWER = { 1 , 10 , 100 , 1000 , 10000 , 100000 } ; public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int noOfComparison = s . nextInt ( ) ; for ( int i = 0 ; i < noOfComparison ; i ++ ) { int x1 = s . nextInt ( ) ; int p1 = s . nextInt ( ) ; int x2 = s . nextInt ( ) ; int p2 = s . nextInt ( ) ; compare ( x1 , p1 , x2 , p2 ) ; } } private static void compare ( int x1 , int p1 , int x2 , int p2 ) { if ( p1 == p2 ) { directCompare ( x1 , x2 ) ; } else { double xx1 = x1 ; double xx2 = x2 ; while ( xx1 % 10 == 0 ) { xx1 /= 10 ; p1 ++ ; } while ( xx2 % 10 == 0 ) { xx2 /= 10 ; p2 ++ ; } if ( p1 > p2 ) { xx1 *= cachedPower ( p1 - p2 ) ; } else if ( p2 > p1 ) { xx2 *= cachedPower ( p2 - p1 ) ; } directCompare ( xx1 , xx2 ) ; } } private static double cachedPower ( int p ) { if ( p < 6 ) { return POWER [ p ] ; } else { return Math . pow ( 10 , ( p ) ) ; } } private static void directCompare ( int x1 , int x2 ) { if ( x1 > x2 ) { System . out . println ( " > " ) ; } else if ( x2 > x1 ) { System . out . println ( " < " ) ; } else { System . out . println ( " = " ) ; } } private static void directCompare ( double x1 , double x2 ) { if ( x1 > x2 ) { System . out . println ( " > " ) ; } else if ( x2 > x1 ) { System . out . println ( " < " ) ; } else { System . out . println ( " = " ) ; } } }
import java . util . HashMap ; import java . util . HashSet ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; String arrs [ ] = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrs [ i ] = sc . next ( ) ; } int [ ] length = new int [ n ] ; int index = 0 ; int returnDex = 0 ; for ( String tmp : arrs ) { int dexG = tmp . indexOf ( " G " ) ; int dexS = tmp . indexOf ( " S " ) ; if ( dexG > dexS ) { returnDex = - 1 ; } length [ index ++ ] = dexS - dexG ; } HashSet set = new HashSet < Integer > ( ) ; for ( int len : length ) { set . add ( len ) ; } if ( returnDex == - 1 ) { System . out . println ( returnDex ) ; } else { System . out . println ( set . size ( ) ) ; } } }
public class GFG { static boolean search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x || arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 } ; int x = 130 ; int n = arr . length ; if ( search ( arr , n , x ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; public class GFG { static void countFreq ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( arr [ i ] ) != - 1 ) { System . out . println ( arr [ i ] + " ▁ " + mp . get ( arr [ i ] ) ) ; mp . put ( arr [ i ] , - 1 ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = arr . length ; countFreq ( arr , n ) ; } }
import java . util . * ; public class GFG { static int MinCostTree ( int arr [ ] , int n ) { int ans = 0 ; Vector < Integer > st = new Vector < Integer > ( ) ; st . add ( Integer . MAX_VALUE ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( st . get ( st . size ( ) - 1 ) <= arr [ i ] ) { int x = st . get ( st . size ( ) - 1 ) ; st . remove ( st . size ( ) - 1 ) ; ans += x * Math . min ( st . get ( st . size ( ) - 1 ) , arr [ i ] ) ; } st . add ( arr [ i ] ) ; } for ( int i = 2 ; i < st . size ( ) ; i ++ ) ans += st . get ( i ) * st . get ( i - 1 ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 } ; int n = arr . length ; System . out . print ( MinCostTree ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; String t = sc . next ( ) ; int cache1 [ ] = new int [ 26 ] ; int cache2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { cache1 [ s . charAt ( i ) - ' a ' ] ++ ; cache2 [ t . charAt ( i ) - ' a ' ] ++ ; } int flag = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( cache1 [ i ] != cache2 [ i ] ) { flag = 1 ; break ; } } if ( flag == 1 ) { System . out . println ( " - 1" ) ; System . exit ( 0 ) ; } char [ ] s1 = s . toCharArray ( ) ; char [ ] s2 = t . toCharArray ( ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; int pos = - 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s1 [ j ] == s2 [ i ] ) { pos = j ; break ; } } for ( int j = pos - 1 ; j >= i ; j -- ) { l . add ( j ) ; char temp = s1 [ j + 1 ] ; s1 [ j + 1 ] = s1 [ j ] ; s1 [ j ] = temp ; } s1 [ i ] = s2 [ i ] ; } System . out . println ( l . size ( ) ) ; for ( int x : l ) { System . out . print ( ( x + 1 ) + " ▁ " ) ; } System . out . println ( ) ; } }
public class GFG { static void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; System . out . println ( " x ^ 2 ▁ - ▁ ( " + sum + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; } public static void main ( String args [ ] ) { int a = 2 , b = 3 ; findEquation ( a , b ) ; } }
import java . util . * ; class solution { static void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " ▁ x ) ▁ + ▁ " ) ; System . out . print ( " y ^ 2 ▁ + ▁ ( " + b + " ▁ y ) ▁ = ▁ " ) ; System . out . println ( c + " . " ) ; } public static void main ( String arr [ ] ) { double x1 = 2 , y1 = - 3 , r = 8 ; circle_equation ( x1 , y1 , r ) ; } }
import java . util . * ; public class GFG { static void unique_combination ( int l , int sum , int K , Vector < Integer > local , Vector < Integer > A ) { if ( sum == K ) { System . out . print ( " { " ) ; for ( int i = 0 ; i < local . size ( ) ; i ++ ) { if ( i != 0 ) System . out . print ( " ▁ " ) ; System . out . print ( local . get ( i ) ) ; if ( i != local . size ( ) - 1 ) System . out . print ( " , ▁ " ) ; } System . out . println ( " } " ) ; return ; } for ( int i = l ; i < A . size ( ) ; i ++ ) { if ( sum + A . get ( i ) > K ) continue ; if ( i == 1 && A . get ( i ) == A . get ( i - 1 ) && i > l ) continue ; local . add ( A . get ( i ) ) ; unique_combination ( i + 1 , sum + A . get ( i ) , K , local , A ) ; local . remove ( local . size ( ) - 1 ) ; } } static void Combination ( Vector < Integer > A , int K ) { Collections . sort ( A ) ; Vector < Integer > local = new Vector < Integer > ( ) ; unique_combination ( 0 , 0 , K , local , A ) ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 10 , 1 , 2 , 7 , 6 , 1 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int K = 8 ; Combination ( A , K ) ; } }
import java . util . * ; public class demo1 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int q = sc . nextInt ( ) ; for ( int j = 0 ; j < q ; j ++ ) { int x = sc . nextInt ( ) ; int l = 0 ; int r = n - 1 ; int m = 0 ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( x >= arr [ m ] ) l = m + 1 ; else r = m - 1 ; } System . out . println ( l ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . regex . Pattern ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder builder = new StringBuilder ( ) ; int n = Integer . parseInt ( reader . readLine ( ) ) ; Pattern pattern = Pattern . compile ( " that | this " ) ; while ( n -- > 0 ) { String result = reader . readLine ( ) ; String a = result ; loop : for ( int i = 1 ; i < 26 ; i = i + 2 ) { for ( int j = 0 ; j < 26 ; j ++ ) { a = rep ( result , i , j ) ; if ( pattern . matcher ( a ) . find ( ) ) { builder . append ( a ) . append ( ' \n ' ) ; break loop ; } } } } System . out . print ( builder ) ; } private static String rep ( String a , int i , int j ) { char [ ] chs = new char [ a . length ( ) ] ; for ( int k = 0 ; k < a . length ( ) ; k ++ ) { if ( ' a ' <= a . charAt ( k ) && a . charAt ( k ) <= ' z ' ) { int b = a . charAt ( k ) - 97 ; chs [ k ] = ( char ) ( ( b * i + j ) % 26 + 97 ) ; } else { chs [ k ] = a . charAt ( k ) ; } } return String . valueOf ( chs ) ; } }
public class GFG { static boolean findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } } public static void main ( String [ ] args ) { int a = 2 , b = 4 ; int n = 3 ; if ( findNature ( a , b , n ) ) System . out . println ( " Odd " ) ; else System . out . println ( " Even " ) ; } }
import java . util . Scanner ; import java . util . stream . * ; class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; for ( ; ; ) { final int a = cin . nextInt ( ) ; final int b = cin . nextInt ( ) ; if ( a == 0 ) break ; System . out . println ( IntStream . range ( 0 , a / 2 + 1 ) . asDoubleStream ( ) . map ( i -> Math . abs ( b - Math . hypot ( i , a - i ) ) ) . min ( ) . getAsDouble ( ) ) ; } } }
public class GFG { static int max_sum ( int a [ ] , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; } else if ( n == 2 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , dp [ 0 ] ) ; } else if ( n >= 3 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = Math . max ( a [ 2 ] , Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ) ; int i = 3 ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , - 2 , 4 , 3 } ; int n = arr . length ; System . out . println ( max_sum ( arr , n ) ) ; } }
import java . util . Arrays ; import java . util . Locale ; import java . util . Scanner ; public class Sleuth { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String question = scanner . nextLine ( ) . trim ( ) ; String originalQ = question . substring ( 0 , question . length ( ) - 1 ) . trim ( ) ; String ch = originalQ . substring ( originalQ . length ( ) - 1 ) ; String [ ] vowels = new String [ ] { " A " , " E " , " I " , " O " , " U " , " Y " } ; boolean b = Arrays . stream ( vowels ) . anyMatch ( e -> e . equalsIgnoreCase ( ch ) || e . toLowerCase ( Locale . US ) . equalsIgnoreCase ( ch ) ) ; System . out . println ( b ? " YES " : " NO " ) ; } }
import java . util . * ; class solution { static int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; } public static void main ( String args [ ] ) { int n = 4 , k = 6 ; System . out . println ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; System . out . println ( minimumX ( n , k ) ) ; } }
import java . util . * ; public class C { private static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int C = in . nextInt ( ) ; for ( int thisCase = 1 ; thisCase <= C ; thisCase ++ ) { System . out . printf ( " Case ▁ # % d : ▁ % d % n " , thisCase , largestCircle ( ) ) ; } } private static int largestCircle ( ) { int N = in . nextInt ( ) ; int bff [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { bff [ i ] = in . nextInt ( ) - 1 ; } int status [ ] = new int [ N ] ; int chainLength [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { status [ i ] = - 2 ; chainLength [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( bff [ bff [ i ] ] == i ) { status [ i ] = - 1 ; } } int maxLoopSize = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] != - 1 ) { int current = bff [ i ] ; status [ i ] = i ; int steps = 1 ; boolean done = false ; while ( ! done ) { if ( current == i ) { if ( steps > maxLoopSize ) { maxLoopSize = steps ; } done = true ; } else if ( status [ current ] == i ) { done = true ; } else if ( status [ current ] == - 1 ) { if ( steps > chainLength [ current ] ) { chainLength [ current ] = steps ; } done = true ; } else { steps ++ ; status [ current ] = i ; current = bff [ current ] ; } } } } int frankenCircle = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] == - 1 ) { frankenCircle += ( chainLength [ i ] + 1 ) ; } } return Math . max ( frankenCircle , maxLoopSize ) ; } }
import java . util . * ; class solution { static float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; } public static void main ( String args [ ] ) { float C = 720 , P = 13 ; System . out . println ( SellingPrice ( C , P ) ) ; } }
import java . util . * ; public class c { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t , j , i , n , p1 , p2 , c , p [ ] ; t = sc . nextInt ( ) ; for ( j = 1 ; j <= t ; j ++ ) { n = sc . nextInt ( ) ; p = new int [ n + 5 ] ; for ( i = 0 ; i < n ; i ++ ) { p [ sc . nextInt ( ) ] = i ; } p1 = p2 = p [ 1 ] ; System . out . print ( 1 ) ; for ( i = 2 ; i <= n ; i ++ ) { c = p [ i ] ; if ( c > p2 ) p2 = c ; else if ( c < p1 ) p1 = c ; if ( ( p2 - p1 ) == i - 1 ) System . out . print ( 1 ) ; else System . out . print ( 0 ) ; } System . out . println ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; long n = scanner . nextLong ( ) ; long s = scanner . nextLong ( ) ; if ( n < s ) { System . out . println ( - 1 ) ; return ; } for ( int d = 39 ; d > 1 ; d -- ) { long b = lowerBound ( d , n ) ; while ( d * Math . log ( b ) <= Math . log ( n ) ) { if ( test ( b , n , s ) ) { System . out . println ( b ) ; return ; } b ++ ; } } for ( int a1 = ( int ) Math . sqrt ( n - s ) ; a1 >= 1 ; a1 -- ) { if ( ( n - s ) % a1 == 0 ) { long b = ( n - s ) / a1 + 1 ; long a0 = n - a1 * b ; if ( a0 >= 0 && a0 < b && a0 + a1 == s ) { System . out . println ( b ) ; return ; } } } if ( n == s ) { System . out . println ( n + 1 ) ; } else { System . out . println ( - 1 ) ; } } private static boolean test ( long b , long n , long s ) { if ( b < 2 ) return false ; long sum = 0 ; while ( n > 0 ) { sum += n % b ; n /= b ; } return sum == s ; } private static long lowerBound ( int d , long n ) { long left = 1 ; long right = n ; double logn = Math . log ( n ) ; while ( right - left > 1 ) { long mid = ( left + right ) / 2 ; double logm = ( d + 1 ) * Math . log ( mid ) ; if ( logm > logn ) { right = mid ; } else { left = mid ; } } return right ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . * ; import static java . lang . Long . max ; import static java . lang . Long . toHexString ; import static java . lang . Math . abs ; import static java . lang . Math . sin ; public class B { public static void main ( String [ ] args ) { MyScanner in = new MyScanner ( ) ; int m = in . nextInt ( ) ; int b = in . nextInt ( ) ; long result = 0 ; for ( int x = 1 ; x <= m * b ; ++ x ) { long y = ( long ) ( - 1.0 * x / m + b ) ; result = Math . max ( result , 1L * ( x + 1 ) * ( y ) * ( y + 1 ) / 2 + 1L * ( y + 1 ) * ( x ) * ( x + 1 ) / 2 ) ; } System . out . println ( result ) ; } public static class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
public class GFG { static int check ( int n , int m ) { if ( m % n == 0 ) { System . out . print ( " YES " ) ; } else { System . out . print ( " NO " ) ; } return 0 ; } public static void main ( String [ ] args ) { int n = 5 ; int m = 10 ; check ( n , m ) ; } }
import java . io . * ; public class Main { public static void main ( String [ ] argv ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String cantidad = br . readLine ( ) ; String [ ] solucion = new String [ Integer . parseInt ( cantidad ) ] ; for ( int i = 0 ; i < Integer . parseInt ( cantidad ) ; i ++ ) { String cantidadfor = br . readLine ( ) ; int cantidadelementos = Integer . parseInt ( cantidadfor ) ; String [ ] elementosS = br . readLine ( ) . split ( " ▁ " ) ; int [ ] elementos = new int [ cantidadelementos ] ; for ( int j = 0 ; j < elementosS . length ; j ++ ) { elementos [ j ] = Integer . parseInt ( elementosS [ j ] ) ; } for ( int j = 0 ; j < cantidadelementos ; j ++ ) { boolean centinela = false ; for ( int k = cantidadelementos - 1 ; k >= 0 ; k -- ) { if ( elementos [ j ] == elementos [ k ] && k - j >= 2 ) { solucion [ i ] = " YES " ; break ; } } if ( centinela ) break ; } } for ( int i = 0 ; i < solucion . length ; i ++ ) { if ( solucion [ i ] == null ) { solucion [ i ] = " NO " ; } } for ( int i = 0 ; i < solucion . length ; i ++ ) { System . out . println ( solucion [ i ] ) ; } } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; if ( a <= b ) { System . out . println ( b - a ) ; } else { System . out . println ( a - b ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; char [ ] c = new char [ a ] ; String s = sc . next ( ) ; c = s . toCharArray ( ) ; char [ ] ch = new char [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { ch [ i ] = ( char ) ( ' a ' + i ) ; } for ( int i = 0 ; i < b ; i ++ ) { String m = sc . next ( ) ; String n = sc . next ( ) ; char mm = m . charAt ( 0 ) ; char nn = n . charAt ( 0 ) ; int flag = 1 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( ch [ j ] == mm && flag == 1 ) { ch [ j ] = nn ; flag = 0 ; } if ( ch [ j ] == nn && flag == 1 ) { ch [ j ] = mm ; flag = 0 ; } flag = 1 ; } } for ( int i = 0 ; i < a ; i ++ ) { c [ i ] = ch [ c [ i ] - 97 ] ; } System . out . println ( c ) ; } }
import java . util . * ; public class GFG { static int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { String str = " geeks " ; char ch = ' e ' ; int N = 2 ; System . out . print ( findNthOccur ( str , ch , N ) ) ; } }
import java . util . Scanner ; public class MUHandSticks { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; byte sticks [ ] = new byte [ 9 ] ; for ( byte i = 0 ; i < 6 ; i ++ ) sticks [ s . nextInt ( ) - 1 ] ++ ; boolean legs = false , headbody = false ; for ( byte i = 0 ; i < 9 ; i ++ ) { if ( sticks [ i ] >= 4 ) legs = true ; if ( sticks [ i ] >= 6 ) headbody = true ; if ( sticks [ i ] == 2 ) headbody = true ; } if ( legs && headbody ) System . out . println ( " Elephant " ) ; else if ( legs ) System . out . println ( " Bear " ) ; else System . out . println ( " Alien " ) ; } }
import java . math . BigInteger ; public final class p401 { public static void main ( String [ ] args ) { System . out . println ( new p401 ( ) . run ( ) ) ; } private static final long LIMIT = 1000000000000000L ; private static final long MODULUS = Library . pow ( 10 , 9 ) ; public String run ( ) { int splitCount = ( int ) Library . sqrt ( LIMIT ) ; splitCount = Math . max ( splitCount / 3 , 1 ) ; int splitAt = ( int ) ( LIMIT / ( splitCount + 1 ) ) ; long sum = 0 ; for ( int i = 1 ; i <= splitAt ; i ++ ) { long count = LIMIT / i % MODULUS ; long term = ( long ) i * i % MODULUS ; term = term * count % MODULUS ; sum = ( sum + term ) % MODULUS ; } for ( int i = splitCount ; i >= 1 ; i -- ) { long start = LIMIT / ( i + 1 ) ; long end = LIMIT / i ; long sumSquares = sumSquaresMod ( end ) - sumSquaresMod ( start ) ; sumSquares = ( sumSquares + MODULUS ) % MODULUS ; sum = ( sum + i * sumSquares % MODULUS ) % MODULUS ; } return Long . toString ( sum ) ; } private static final BigInteger MODULUS_BI = BigInteger . valueOf ( MODULUS ) ; private static final BigInteger SIX_BI = BigInteger . valueOf ( 6 ) ; private static long sumSquaresMod ( long n ) { BigInteger x = BigInteger . valueOf ( n ) ; BigInteger y = x . multiply ( x . add ( BigInteger . ONE ) ) ; y = y . multiply ( x . shiftLeft ( 1 ) . add ( BigInteger . ONE ) ) ; y = y . divide ( SIX_BI ) ; y = y . mod ( MODULUS_BI ) ; return y . longValue ( ) ; } }
import java . util . * ; public class CodeForces1389B { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = input . nextInt ( ) ; int k = input . nextInt ( ) ; int z = input . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = input . nextInt ( ) ; } int res = 0 ; for ( int zz = 0 ; zz <= z ; zz ++ ) { int dist = k - 2 * zz ; if ( dist < 0 ) { break ; } int max = 0 , score = 0 ; for ( int j = 0 ; j <= dist ; j ++ ) { if ( j < n - 1 ) { max = Math . max ( max , a [ j ] + a [ j + 1 ] ) ; } score += a [ j ] ; } res = Math . max ( res , score + max * zz ) ; } System . out . println ( res ) ; } } }
import java . util . * ; import java . io . * ; import java . lang . Math ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int len = scan . nextInt ( ) ; int a [ ] = new int [ len ] ; int l = 0 ; int r = 0 ; boolean flag = false ; boolean isTrue = false ; for ( int i = 0 ; i < len ; i ++ ) { a [ i ] = scan . nextInt ( ) ; if ( a [ i ] != i + 1 && ! flag ) { l = i + 1 ; flag = true ; continue ; } if ( a [ i ] != i + 1 && flag ) { r = i + 1 ; if ( ( a [ r - 1 ] - a [ r - 2 ] > 0 ) ) isTrue = true ; } } System . out . println ( ( ! isTrue ) ? l + " ▁ " + r : "0" + " ▁ " + "0" ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] [ ] b = new int [ n ] [ 3 ] [ 2 ] ; ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 , h , m ; k < 2 ; k ++ ) b [ i ] [ j ] [ k ] = sc . nextInt ( ) * 60 + sc . nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) { int res = 0 ; for ( int p = 0 ; p < n ; p ++ ) { if ( b [ p ] [ 0 ] [ 0 ] <= b [ i ] [ 0 ] [ 1 ] && b [ i ] [ 0 ] [ 1 ] <= b [ p ] [ 0 ] [ 1 ] && b [ p ] [ 1 ] [ 0 ] <= b [ j ] [ 1 ] [ 1 ] && b [ j ] [ 1 ] [ 1 ] <= b [ p ] [ 1 ] [ 1 ] && b [ p ] [ 2 ] [ 0 ] <= b [ k ] [ 2 ] [ 1 ] && b [ k ] [ 2 ] [ 1 ] <= b [ p ] [ 2 ] [ 1 ] ) res ++ ; } ans = Math . max ( ans , res ) ; } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new AOJ1159 ( ) . doIt ( ) ; } class AOJ1159 { int n , p ; void solve ( ) { int [ ] person = new int [ n ] ; int wan = p ; int ban = 0 ; int result = - 1 ; while ( true ) { if ( wan == 0 ) { wan = person [ ban ] ; person [ ban ] = 0 ; } else { wan -- ; person [ ban ] ++ ; } if ( person [ ban ] == p ) { result = ban ; break ; } ban = ( ban + 1 ) % n ; } System . out . println ( result ) ; } void doIt ( ) { while ( in . hasNext ( ) ) { n = in . nextInt ( ) ; p = in . nextInt ( ) ; if ( n + p == 0 ) break ; solve ( ) ; } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { MyScanner sc = new MyScanner ( ) ; int n = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; a [ 0 ] = sc . nextInt ( ) ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } PrintWriter pw = new PrintWriter ( System . out ) ; for ( int i = 0 ; i < q ; i ++ ) { long x = sc . nextLong ( ) ; long cnt = 0 ; int right = 0 ; long sum = 0 ; for ( int left = 0 ; left < n ; left ++ ) { while ( right < n && sum + a [ right ] <= x ) sum += a [ right ++ ] ; cnt += right - left ; if ( right == left ) right ++ ; else sum -= a [ left ] ; } pw . println ( cnt ) ; } pw . flush ( ) ; } static class MyScanner { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) , 1 << 15 ) ; StringTokenizer tokenizer ; String next ( ) { try { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } } catch ( IOException ignored ) { } return tokenizer . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
import java . util . Scanner ; public class CodeForce_1409A { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < t ; i ++ ) { a = scanner . nextInt ( ) ; b = scanner . nextInt ( ) ; int counter = 0 ; if ( a < b ) { counter = ( b - a ) / 10 ; } else if ( a > b ) { counter = ( a - b ) / 10 ; } if ( a % 10 != b % 10 ) { counter ++ ; } System . out . println ( counter ) ; } } }
import java . util . * ; public class GFG { static int maxSize = ( int ) ( 1e5 + 5 ) ; static boolean [ ] isFib = new boolean [ maxSize ] ; static int [ ] prefix = new int [ maxSize ] ; static int digitSum ( int num ) { int s = 0 ; while ( num != 0 ) { s = s + num % 10 ; num = num / 10 ; } return s ; } static void generateFibonacci ( ) { Arrays . fill ( isFib , false ) ; int prev = 0 , curr = 1 ; isFib [ prev ] = isFib [ curr ] = true ; while ( curr < maxSize ) { int temp = curr + prev ; if ( temp < maxSize ) isFib [ temp ] = true ; prev = curr ; curr = temp ; } } static void precompute ( int k ) { generateFibonacci ( ) ; for ( int i = 1 ; i < maxSize ; i ++ ) { int sum = digitSum ( i ) ; if ( isFib [ sum ] == true && sum % k == 0 ) { prefix [ i ] ++ ; } } for ( int i = 1 ; i < maxSize ; i ++ ) { prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] ; } } static void performQueries ( int k , int q , int [ ] [ ] query ) { precompute ( k ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = query [ i ] [ 0 ] , r = query [ i ] [ 1 ] ; int cnt = prefix [ r ] - prefix [ l - 1 ] ; System . out . print ( cnt + " \n " ) ; } } public static void main ( String [ ] args ) { int [ ] [ ] query = { { 1 , 11 } , { 5 , 15 } , { 2 , 24 } } ; int k = 2 , q = query . length ; performQueries ( k , q , query ) ; } }
import java . util . Scanner ; public class A1642 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { long [ ] X = new long [ 3 ] ; long [ ] Y = new long [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { X [ i ] = in . nextInt ( ) ; Y [ i ] = in . nextInt ( ) ; } long answer = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( Y [ i ] == Y [ ( i + 1 ) % 3 ] && Y [ i ] > Y [ ( i + 2 ) % 3 ] ) { answer += Math . abs ( X [ ( i + 1 ) % 3 ] - X [ i ] ) ; } } System . out . println ( answer ) ; } } }
public class GFG { static boolean isPalindrome ( String str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( len - 1 - i ) ) return false ; } return true ; } static boolean createStringAndCheckPalindrome ( int N ) { String sub = " " + N , res_str = " " ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length ( ) < sum ) res_str += sub ; if ( res_str . length ( ) > sum ) res_str = res_str . substring ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; } public static void main ( String args [ ] ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] array = new int [ 4 ] [ 13 ] ; for ( int i = 1 ; i <= n ; i ++ ) { String s = sc . next ( ) ; int a = sc . nextInt ( ) ; if ( s . equals ( " S " ) ) { array [ 0 ] [ a - 1 ] = 1 ; } else if ( s . equals ( " H " ) ) { array [ 1 ] [ a - 1 ] = 1 ; } else if ( s . equals ( " C " ) ) { array [ 2 ] [ a - 1 ] = 1 ; } else if ( s . equals ( " D " ) ) { array [ 3 ] [ a - 1 ] = 1 ; } } for ( int i = 0 ; i < array . length ; i ++ ) { for ( int j = 0 ; j < array [ 0 ] . length ; j ++ ) { if ( array [ i ] [ j ] == 0 && i == 0 ) { System . out . println ( " S ▁ " + ( j + 1 ) ) ; } else if ( array [ i ] [ j ] == 0 && i == 1 ) { System . out . println ( " H ▁ " + ( j + 1 ) ) ; } else if ( array [ i ] [ j ] == 0 && i == 2 ) { System . out . println ( " C ▁ " + ( j + 1 ) ) ; } else if ( array [ i ] [ j ] == 0 && i == 3 ) { System . out . println ( " D ▁ " + ( j + 1 ) ) ; } } } } }
import java . io . * ; public class GFG { static int sum_even_and_even_index ( int arr [ ] , int n ) { int i = 0 , sum = 0 ; for ( i = 0 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 0 ) { sum += arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 12 , 1 , 18 , 8 } ; int n = arr . length ; System . out . println ( " Sum ▁ of ▁ even ▁ numbers " + " ▁ at ▁ even ▁ indices ▁ is ▁ " + + sum_even_and_even_index ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; import java . util . Arrays ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner scan = new Scanner ( System . in ) ; int T = scan . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = scan . next ( ) ; int len = s . length ( ) ; if ( len == 1 ) { System . out . println ( " NO " ) ; continue ; } int count = 1 ; boolean a = true ; for ( int j = 0 ; j < len - 1 ; j ++ ) { if ( s . charAt ( j ) == s . charAt ( j + 1 ) ) { count ++ ; } else { if ( count == 1 ) { a = false ; break ; } else if ( j == len - 2 ) { a = false ; } else { count = 1 ; } } } if ( a == true ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . io . * ; public class GFG { static void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { System . out . print ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arr_size = arr . length ; printDuplicates ( arr , arr_size ) ; } }
import java . util . Scanner ; public class CF1293B { public static Scanner scanner ; public static void main ( String [ ] args ) { scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += ( 1.0 / ( double ) ( n - i ) ) ; System . out . println ( res ) ; } }
public class GFG { static int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( sum ( n ) ) ; } }
public class GFG { static int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( maxHandshake ( n ) ) ; } }
public class GFG { static int grayCode ( int n ) { return n ^ ( n >> 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( grayCode ( n ) ) ; } }
public class GFG { static int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( Max_Sum ( n ) ) ; } }
public class GFG { static int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( possibleways ( n ) ) ; } }
public class GFG { static int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; } public static void main ( String [ ] args ) { int n = 21 ; System . out . println ( CountSetBits ( n ) ) ; } }
public class GFG { static int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; } public static void main ( String [ ] args ) { int m = 3 , n = 2 ; System . out . println ( sum ( m , n ) ) ; } }
public class GFG { static int SUM ( int n , int m ) { if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; int sum = SUM ( n , m - 1 ) ; return ( sum * ( sum + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; int m = 3 ; System . out . println ( " SUM ( " + n + " , ▁ " + m + " ) : ▁ " + SUM ( n , m ) ) ; } }
public class GFG { static int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( maxLCM ( n ) ) ; } }
public class GFG { static int findSum ( int n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
public class GFG { static int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } } public static void main ( String [ ] args ) { int n = 18 ; System . out . println ( cntWays ( n ) ) ; } }
public class GFG { static void find_composite_nos ( int n ) { System . out . println ( 9 * n + " ▁ " + 8 * n ) ; } public static void main ( String [ ] args ) { int n = 4 ; find_composite_nos ( n ) ; } }
public class GFG { static int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return ( n & 1 ) > 0 ? 1 : 6 ; } public static void main ( String args [ ] ) { int n = 7 ; System . out . println ( findThirdDigit ( n ) ) ; } }
public class GFG { static long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; } public static void main ( String args [ ] ) { long n = 8 ; System . out . println ( countMaxIntersect ( n ) ) ; } }
class Solution { static int sum ( int n ) { if ( n == 1 ) { return 2 ; } else { return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; } } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( sum ( n ) ) ; } }
public class GFG { static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; } public static void main ( String [ ] args ) { int n = 48 ; System . out . println ( highestPowerOf2 ( n ) ) ; } }
public class GFG { static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntersections ( n ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; sc . close ( ) ; String c = " None " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) { if ( ! s . contains ( " " + ( char ) i ) ) { c = " " + ( char ) i ; break ; } } System . out . println ( c ) ; } }
import java . util . * ; import java . io . * ; public class A1581 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int n = in . nextInt ( ) ; int [ ] arr = new int [ n ] ; Arrays . setAll ( arr , i -> in . nextInt ( ) ) ; Arrays . sort ( arr ) ; if ( arr [ 0 ] == 1 ) { pw . println ( 1 ) ; pw . close ( ) ; return ; } else { if ( n == 1 ) { pw . println ( arr [ 0 ] ) ; pw . close ( ) ; return ; } } boolean yes = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % arr [ 0 ] != 0 ) { yes = false ; break ; } } if ( yes ) pw . println ( arr [ 0 ] ) ; else pw . println ( - 1 ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } static int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; } }
import java . util . Scanner ; public class Main { private static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { System . out . println ( 1200 > sc . nextInt ( ) ? " ABC " : " ARC " ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { static final int maxElementValue = ( int ) Math . pow ( 10 , 9 ) ; public static void main ( String [ ] args ) throws IOException { try ( BufferedReader console = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { console . readLine ( ) ; int [ ] elements = Arrays . stream ( console . readLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] rightDistance = new int [ elements . length + 1 ] ; rightDistance [ rightDistance . length - 1 ] = maxElementValue ; int [ ] leftDistance = new int [ elements . length + 1 ] ; leftDistance [ 0 ] = maxElementValue ; for ( int i = rightDistance . length - 2 ; i >= 0 ; i -- ) { if ( elements [ i ] == 0 ) { rightDistance [ i ] = 0 ; } else { rightDistance [ i ] = rightDistance [ i + 1 ] + 1 ; } } for ( int j = 1 ; j < leftDistance . length ; j ++ ) { if ( elements [ j - 1 ] == 0 ) { leftDistance [ j ] = 0 ; } else { leftDistance [ j ] = leftDistance [ j - 1 ] + 1 ; } } for ( int i = 0 ; i < elements . length ; i ++ ) { System . out . print ( Math . min ( rightDistance [ i ] , leftDistance [ i + 1 ] ) ) ; if ( i + 1 < elements . length ) System . out . print ( " ▁ " ) ; } } } }
public class GFG { static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } public static void main ( String [ ] args ) { int x = 12 , y = 15 , z = 5 ; System . out . printf ( " Minimum ▁ of ▁ 3" + " ▁ numbers ▁ is ▁ % d " , smallest ( x , y , z ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int c1 = scan . nextInt ( ) ; int c5 = scan . nextInt ( ) ; int c10 = scan . nextInt ( ) ; int c50 = scan . nextInt ( ) ; int c100 = scan . nextInt ( ) ; int c500 = scan . nextInt ( ) ; if ( c1 + c5 * 5 + c10 * 10 + c50 * 50 + c100 * 100 + c500 * 500 < 1000 ) { System . out . println ( "0" ) ; } else { System . out . println ( "1" ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Another { public static void main ( String [ ] args ) throws IOException { FastReader in = new FastReader ( ) ; PrintWriter pw = new PrintWriter ( System . out ) ; long m = in . nextLong ( ) ; long R = in . nextLong ( ) ; pw . printf ( " % .12f \n " , ( 2 + 2. * ( m - 1 ) * m * ( m + 1 ) / 3 / m / m - 2 * ( 2 - Math . sqrt ( 2 ) ) + ( 2 - Math . sqrt ( 2 ) ) * ( 2 * m + 2 * ( m - 1 ) ) / m / m ) * R ) ; pw . flush ( ) ; pw . close ( ) ; } static class FastReader { StringTokenizer st ; BufferedReader br ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public String next ( ) throws IOException { if ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; } public boolean hasNext ( ) throws IOException { if ( st != null && st . hasMoreTokens ( ) ) { return true ; } String s = br . readLine ( ) ; if ( s == null || s . isEmpty ( ) ) { return false ; } st = new StringTokenizer ( s ) ; return true ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public String nextLine ( ) throws IOException { return br . readLine ( ) ; } } }
public class GFG { static int countCubes ( int a , int b ) { return ( int ) ( Math . floor ( Math . cbrt ( b ) ) - Math . ceil ( Math . cbrt ( a ) ) + 1 ) ; } public static void main ( String [ ] args ) { int a = 7 , b = 28 ; System . out . print ( " Count ▁ of ▁ cubes ▁ is ▁ " + countCubes ( a , b ) ) ; } }
import java . io . IOException ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; while ( true ) { int D = scanner . nextInt ( ) ; int N = scanner . nextInt ( ) ; if ( ( D | N ) == 0 ) break ; int [ ] a = new int [ N ] ; int [ ] e = new int [ N ] ; int [ ] r = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int aa = scanner . nextInt ( ) ; int ee = scanner . nextInt ( ) ; int rr = scanner . nextInt ( ) ; a [ i ] = aa ; e [ i ] = ee ; r [ i ] = rr ; } int [ ] [ ] dp = new int [ D + 1 ] [ 101 ] ; for ( int [ ] d : dp ) Arrays . fill ( d , INF ) ; dp [ D ] [ 0 ] = 0 ; for ( int i = D ; i > 0 ; i -- ) { for ( int j = 0 ; j <= 100 ; j ++ ) { if ( dp [ i ] [ j ] == INF ) continue ; for ( int k = 0 ; k < N ; k ++ ) { if ( j < r [ k ] ) continue ; dp [ Math . max ( 0 , i - a [ k ] ) ] [ Math . min ( 100 , j + e [ k ] ) ] = Math . min ( dp [ Math . max ( 0 , i - a [ k ] ) ] [ Math . min ( 100 , j + e [ k ] ) ] , dp [ i ] [ j ] + 1 ) ; } } } int ret = INF ; for ( int i = 0 ; i < 101 ; i ++ ) ret = Math . min ( ret , dp [ 0 ] [ i ] ) ; System . out . println ( ret == INF ? " NA " : ret ) ; } } int INF = 1 << 30 ; }
public final class p012 { public static void main ( String [ ] args ) { System . out . println ( new p012 ( ) . run ( ) ) ; } public String run ( ) { int triangle = 0 ; for ( int i = 1 ; ; i ++ ) { if ( Integer . MAX_VALUE - triangle < i ) throw new ArithmeticException ( " Overflow " ) ; triangle += i ; if ( countDivisors ( triangle ) > 500 ) return Integer . toString ( triangle ) ; } } private static int countDivisors ( int n ) { int count = 0 ; int end = Library . sqrt ( n ) ; for ( int i = 1 ; i < end ; i ++ ) { if ( n % i == 0 ) count += 2 ; } if ( end * end == n ) count ++ ; return count ; } }
import java . io . * ; public class GFG { static int findDelta ( int a , int b , int c , int d ) { return ( b * c - a * d ) / ( d - c ) ; } public static void main ( String args [ ] ) { int a = 3 , b = 9 , c = 3 , d = 5 ; System . out . print ( " \u0394 X ▁ = ▁ " + findDelta ( a , b , c , d ) ) ; } }
public class GFG { static boolean SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } return false ; } static void findPrimePair ( int n ) { boolean isPrime [ ] = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { System . out . print ( i + " ▁ " + ( n - i ) ) ; return ; } } } public static void main ( String [ ] args ) { int n = 74 ; findPrimePair ( n ) ; } }
public class GFG { static int replaceDigit ( int x , int d1 , int d2 ) { int result = 0 , multiply = 1 ; while ( x % 10 > 0 ) { int remainder = x % 10 ; if ( remainder == d1 ) result = result + d2 * multiply ; else result = result + remainder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; } public static void main ( String [ ] args ) { int x = 645 , d1 = 6 , d2 = 5 ; System . out . println ( replaceDigit ( x , d1 , d2 ) ) ; } }
public class GFG { static int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i || j == n - 1 - i ) { if ( i == n - 1 - j ) { System . out . print ( " / " ) ; } else { System . out . print ( " \\ " ) ; } } else { System . out . print ( " * " ) ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; } public static void main ( String [ ] args ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; } }
import java . util . HashMap ; class Test { static int arr [ ] = new int [ ] { 1 , 5 , 7 , - 1 , 5 } ; static int getPairsCount ( int n , int sum ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , 0 ) ; hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; } int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . get ( sum - arr [ i ] ) != null ) twice_count += hm . get ( sum - arr [ i ] ) ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; } public static void main ( String [ ] args ) { int sum = 6 ; System . out . println ( " Count ▁ of ▁ pairs ▁ is ▁ " + getPairsCount ( arr . length , sum ) ) ; } }
import java . util . * ; public class GFG { static int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) ; int x = scanner . nextInt ( ) ; int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; int times = Math . min ( a , b ) - 1 + n - Math . max ( a , b ) ; if ( times > x ) { System . out . println ( n - 1 - ( times - x ) ) ; } else { System . out . println ( n - 1 ) ; } } } }
import java . util . ArrayList ; import java . util . Comparator ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; int sum = 0 ; ArrayList < Integer > a = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int tmp = scanner . nextInt ( ) ; sum += tmp ; if ( tmp % 10 != 0 ) { a . add ( tmp ) ; } } a . sort ( Comparator . naturalOrder ( ) ) ; int i = 0 ; while ( sum % 10 == 0 && i < a . size ( ) ) { sum -= a . get ( i ) ; i ++ ; } if ( sum % 10 == 0 ) { sum = 0 ; } System . out . println ( sum ) ; } }
import java . util . * ; public class RepaintingStreet { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; List < Integer > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; if ( ! l . contains ( a [ i ] ) ) { l . add ( a [ i ] ) ; } } int ans = Integer . MAX_VALUE ; for ( int j = 0 ; j < l . size ( ) ; j ++ ) { int moves = 0 ; int big = l . get ( j ) ; for ( int i = 0 ; i < n ; ) { if ( a [ i ] == big ) { i ++ ; continue ; } moves ++ ; i += k ; } ans = Math . min ( moves , ans ) ; } System . out . println ( ans ) ; } } }
import java . io . * ; import java . util . * ; public class GFG { static int findRepeatingNumber ( int [ ] arr , int n ) { int sq = ( int ) Math . sqrt ( n ) ; int range = ( n / sq ) + 1 ; int [ ] count = new int [ range ] ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m . put ( arr [ i ] , 1 ) ; if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; } } return - 1 ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 1 , 2 , 3 , 5 , 4 } ; int n = 5 ; System . out . println ( " One ▁ of ▁ the ▁ numbers ▁ repeated ▁ in ▁ the ▁ array ▁ is : ▁ " + findRepeatingNumber ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static long maxPrimeFactors ( long n ) { long maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) maxPrime = n ; return maxPrime ; } public static void main ( String [ ] args ) { Long n = 15l ; System . out . println ( maxPrimeFactors ( n ) ) ; n = 25698751364526l ; System . out . println ( maxPrimeFactors ( n ) ) ; } }
import java . util . Scanner ; public class Beat { int number ; public Beat ( int number ) { this . number = number ; } public int getNumber ( ) { return number ; } static int numberEven = 0 ; static int numberOdd = 0 ; public void input ( int number ) { if ( number % 2 == 0 ) { numberEven ++ ; } else { numberOdd ++ ; } } public void printResult ( ) { System . out . println ( java . lang . Math . min ( numberEven , numberOdd ) ) ; numberEven = 0 ; numberOdd = 0 ; } public static void main ( String [ ] a ) { Scanner input = new Scanner ( System . in ) ; int number = input . nextInt ( ) ; Beat instance = new Beat ( number ) ; for ( int i = 0 ; i < instance . getNumber ( ) ; i ++ ) { int num = input . nextInt ( ) ; for ( int k = 0 ; k < num ; k ++ ) { int n = input . nextInt ( ) ; instance . input ( n ) ; } instance . printResult ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; char [ ] s1 = sc . next ( ) . toCharArray ( ) ; int ans = 0 ; int c1 = 0 ; int c0 = 0 ; for ( int i = 0 ; i < s1 . length ; i ++ ) { if ( s1 [ i ] == '1' ) { if ( c0 > 0 ) { c0 -- ; ans ++ ; } else { c1 ++ ; } } else { if ( c1 > 0 ) { c1 -- ; ans ++ ; } else { c0 ++ ; } } } System . out . println ( ans * 2 ) ; } }
public class GFG { static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } System . out . print ( " No ▁ Triplet " ) ; } public static void main ( String arg [ ] ) { int n = 12 ; pythagoreanTriplet ( n ) ; } }
public class GFG { public static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; } public static void main ( String [ ] args ) { int a = 33 ; int b = - 24 ; System . out . print ( countDigits ( a , b ) ) ; } }
import java . util . * ; public class GFG { public static int indexOfFirstOne ( int arr [ ] , int low , int high ) { int mid = 0 ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == 1 && ( mid == 0 || arr [ mid - 1 ] == 0 ) ) break ; else if ( arr [ mid ] == 1 ) high = mid - 1 ; else low = mid + 1 ; } return mid ; } public static int posOfFirstOne ( int arr [ ] ) { int l = 0 , h = 1 ; while ( arr [ h ] == 0 ) { l = h ; h = 2 * h ; } return indexOfFirstOne ( arr , l , h ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 1 , 1 , 1 , 1 } ; System . out . println ( " Index ▁ = ▁ " + posOfFirstOne ( arr ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class main { public static void main ( String [ ] args ) { FastReader fr = new FastReader ( ) ; int n = fr . nextInt ( ) ; int sum = 0 , total = 0 , i = 1 ; if ( n == 2 ) { System . out . println ( 1 ) ; return ; } while ( n > 0 ) { n -= 1 ; if ( n > 0 ) { if ( n >= 2 ) { total ++ ; } n -= 2 ; } total ++ ; } System . out . println ( total ) ; } static class FastReader { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { } return st . nextToken ( ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
import java . math . BigDecimal ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { double num ; Scanner sc = new Scanner ( System . in ) ; Doctor d ; while ( true ) { num = sc . nextDouble ( ) ; if ( num < 0 ) { break ; } d = new Doctor ( num ) ; if ( d . judge ( ) ) { System . out . println ( d . getBD ( ) ) ; } else { System . out . println ( " NA " ) ; } } } } class Doctor { double num ; String bd ; int integers ; double decimals ; Doctor ( double num ) { this . num = num ; bd = " " ; integers = ( int ) num ; decimals = new BigDecimal ( num - integers ) . setScale ( 4 , BigDecimal . ROUND_UP ) . doubleValue ( ) ; } public boolean judge ( ) { if ( integers > 255 || decimals > 0.9375 ) { return false ; } return true ; } private boolean toBinaryDigits ( ) { String tmp = " " ; int count = 1 ; for ( int i = integers ; i > 0 ; i /= 2 ) { tmp += i % 2 ; } StringBuffer sb = new StringBuffer ( tmp ) ; for ( int i = 0 ; i < 8 - tmp . length ( ) ; i ++ ) { bd += "0" ; } bd += sb . reverse ( ) . toString ( ) + " . " ; while ( true ) { if ( decimals == 0 ) { bd += "0000" ; break ; } if ( count > 4 ) { return false ; } decimals *= 2 ; if ( decimals >= 1 ) { decimals -= 1 ; bd += "1" ; if ( decimals == 0 ) { for ( int i = 0 ; i < 4 - count ; i ++ ) { bd += "0" ; } break ; } } else { bd += "0" ; } count ++ ; } return true ; } public String getBD ( ) { if ( toBinaryDigits ( ) ) { return bd ; } return " NA " ; } }
public class GFG { static int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; } static int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return - 1 ; } public static void main ( String [ ] args ) { int n = 43 ; System . out . println ( " x ▁ = ▁ " + findX ( n ) ) ; } }
import java . util . * ; import java . util . Map . Entry ; class Main { static int mod = ( int ) ( Math . pow ( 10 , 9 ) + 7 ) ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] a = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ Integer . parseInt ( sc . next ( ) ) - 1 ] = i ; } long ans = 1 ; long cnt = 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != N - 1 && a [ i ] < a [ i + 1 ] ) cnt ++ ; else { ans = Math . max ( ans , cnt ) ; cnt = 1 ; } } ans = Math . max ( ans , cnt ) ; ans = N - ans ; System . out . println ( ans ) ; } }
import java . io . * ; import java . util . * ; class Main { private void compute ( ) { Scanner scanner = new Scanner ( System . in ) ; for ( int i = 0 ; i < 7 ; i ++ ) { int nHigh = scanner . nextInt ( ) ; int nLow = scanner . nextInt ( ) ; System . out . println ( nHigh - nLow ) ; } } public static void main ( String args [ ] ) { new Main ( ) . compute ( ) ; } }
import java . util . * ; public class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void performQueries ( int [ ] A , pair [ ] q ) { int n = A . length ; int [ ] pref_xor = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) { pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] ; } for ( pair i : q ) { int L = i . first , R = i . second ; if ( L > R ) { int temp = L ; L = R ; R = temp ; } if ( L != R && pref_xor [ R ] == pref_xor [ L - 1 ] ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } static public void main ( String [ ] arg ) { int [ ] Arr = { 1 , 1 , 2 , 2 , 1 } ; pair [ ] q = { new pair ( 1 , 5 ) , new pair ( 1 , 4 ) , new pair ( 3 , 4 ) } ; performQueries ( Arr , q ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( in . nextInt ( ) ) ; } Collections . sort ( list ) ; int c = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( list . get ( i ) >= c ) { c ++ ; } } pw . println ( c ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . util . Locale ; import java . util . Scanner ; public class B215 { public static void main ( String [ ] args ) { Locale . setDefault ( Locale . US ) ; Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int [ ] R1 = new int [ N ] ; for ( int n = 0 ; n < N ; n ++ ) { R1 [ n ] = in . nextInt ( ) ; } int M = in . nextInt ( ) ; int [ ] P1 = new int [ M ] ; for ( int m = 0 ; m < M ; m ++ ) { P1 [ m ] = in . nextInt ( ) ; } int K = in . nextInt ( ) ; int [ ] P2 = new int [ K ] ; for ( int k = 0 ; k < K ; k ++ ) { P2 [ k ] = in . nextInt ( ) ; } int A = in . nextInt ( ) ; int B = in . nextInt ( ) ; int maxR1 = 0 ; for ( int r1 : R1 ) { maxR1 = Math . max ( maxR1 , r1 ) ; } int maxP1 = 0 ; for ( int p1 : P1 ) { maxP1 = Math . max ( maxP1 , p1 ) ; } int minP2 = Integer . MAX_VALUE ; for ( int p2 : P2 ) { minP2 = Math . min ( minP2 , p2 ) ; } double r2 = Math . sqrt ( maxR1 * maxR1 * ( double ) B * maxP1 / ( A * minP2 + B * maxP1 ) ) ; System . out . println ( r2 ) ; } }
public class HelloWorld { public static void trapeziumPattern ( int num ) { int firsthalf = 1 ; int secondhalf = ( num * num ) + 1 ; int numOfSpaces = 0 ; for ( int numOfLines = num ; numOfLines >= 1 ; numOfLines -- ) { for ( int numOfSpacesCounter = numOfSpaces ; numOfSpacesCounter >= 1 ; numOfSpacesCounter -- ) { System . out . print ( " ▁ " ) ; } for ( int firstHalfCounter = 1 ; firstHalfCounter <= numOfLines ; firstHalfCounter ++ ) { if ( firstHalfCounter == numOfLines ) System . out . print ( ( firsthalf ++ ) ) ; else System . out . print ( ( firsthalf ++ ) + " * " ) ; } for ( int secondHalfCounter = 1 ; secondHalfCounter <= numOfLines ; secondHalfCounter ++ ) { System . out . print ( " * " + ( secondhalf ++ ) ) ; } System . out . println ( ) ; numOfSpaces += 2 ; secondhalf = ( secondhalf - 1 ) - ( ( numOfLines - 1 ) * 2 ) ; } } public static void main ( String [ ] args ) { trapeziumPattern ( 3 ) ; } }
import java . util . * ; public class GFG { static void findPerm ( int n , Vector < Integer > differences ) { Vector < Integer > ans = new Vector < Integer > ( ) ; ans . clear ( ) ; ans . add ( 0 ) ; int x = 0 ; for ( int i = 0 ; i <= n - 2 ; ++ i ) { int diff = differences . get ( i ) ; x = x + diff ; ans . add ( x ) ; } Vector < Integer > anss = new Vector < Integer > ( ) ; for ( Integer obj : ans ) anss . add ( obj ) ; Collections . sort ( ans ) ; int flag = - 1 ; for ( int i = 1 ; i <= n - 1 ; ++ i ) { int res = ans . get ( i ) - ans . get ( i - 1 ) ; if ( res != 1 ) { flag = 0 ; } } if ( flag == 0 ) { System . out . print ( - 1 ) ; return ; } else { Map < Integer , Integer > mpp = new HashMap < > ( ) ; mpp . clear ( ) ; int j = 1 ; Vector < Integer > value_at_index = new Vector < Integer > ( ) ; for ( Integer x1 : ans ) { mpp . put ( x1 , j ) ; ++ j ; } for ( Integer x2 : anss ) { value_at_index . add ( mpp . get ( x2 ) ) ; } for ( Integer x3 : value_at_index ) { System . out . print ( x3 + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { Vector < Integer > differences = new Vector < Integer > ( ) ; differences . add ( 2 ) ; differences . add ( - 3 ) ; differences . add ( 2 ) ; int n = differences . size ( ) + 1 ; findPerm ( n , differences ) ; } }
import java . io . * ; public class GFG { static int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } static void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { System . out . print ( num + " ▁ " ) ; i ++ ; } } return ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( " First ▁ " + n + " ▁ " + k + " - almost ▁ prime ▁ numbers : ▁ " ) ; printKAlmostPrimes ( k , n ) ; } }
public class GFG { static int solve ( int N , int K ) { int [ ] combo ; combo = new int [ 50 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } public static void main ( String args [ ] ) { int N = 29 ; int K = 5 ; System . out . println ( solve ( N , K ) ) ; solve ( N , K ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } private void run ( ) { Scanner scanner = new Scanner ( System . in ) ; while ( true ) { int x = scanner . nextInt ( ) ; if ( x == 0 ) break ; boolean sign = x > 0 ; StringBuilder builder = new StringBuilder ( ) ; x = Math . abs ( x ) ; while ( x > 0 ) { int t = ( x % 10 ) ; if ( ! sign && t != 0 ) { t = 10 - t ; x += 10 ; } builder . insert ( 0 , t ) ; sign = ! sign ; x /= 10 ; } System . out . println ( builder ) ; } } }
public class GFG { static float normal ( float m , float n ) { float N = ( float ) ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; } public static void main ( String [ ] args ) { float m = - 5 , n = 3 ; System . out . println ( normal ( m , n ) ) ; } }
import java . io . * ; import java . util . * ; public class Assignment4 { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = br . readLine ( ) ; String [ ] num = str . split ( " ▁ " ) ; double n = Double . parseDouble ( num [ 0 ] ) ; double h = Double . parseDouble ( num [ 1 ] ) ; for ( double i = 1.0 ; i < n ; i ++ ) { double ans = h * Math . sqrt ( i / n ) ; System . out . printf ( " % f ▁ " , ans ) ; if ( i == n - 1 ) System . out . println ( ) ; } } }
public class GFG { static int countBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n >>= 1 ; } return count ; } public static void main ( String [ ] arg ) { int i = 65 ; System . out . print ( countBits ( i ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( h * w - ( h / a * a ) * ( w / b * b ) ) ; } }
import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , max = 0 , ans = 0 ; List < Integer > l = new ArrayList < > ( ) ; int [ ] t = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { t [ i ] = sc . nextInt ( ) ; max = Math . max ( max , t [ i ] ) ; } for ( int i = 1 ; i <= max ; i ++ ) { if ( max % i == 0 ) { l . add ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < l . size ( ) ; j ++ ) { if ( l . get ( j ) >= t [ i ] ) { ans += l . get ( j ) - t [ i ] ; break ; } } } System . out . println ( ans ) ; } }
import java . io . * ; public class GFG { static int LongestSubarray ( int [ ] arr , int n , int k ) { int [ ] arr2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr2 [ i ] = arr [ i ] % k ; int current_length , max_length = 0 ; int j ; for ( int i = 0 ; i < n ; ) { current_length = 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr2 [ j ] == arr2 [ i ] ) current_length ++ ; else break ; } max_length = Math . max ( max_length , current_length ) ; i = j ; } return max_length ; } public static void main ( String [ ] args ) { int [ ] arr = { 4 , 9 , 7 , 18 , 29 , 11 } ; int n = arr . length ; int k = 11 ; System . out . println ( LongestSubarray ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { FastScanner fs = new FastScanner ( ) ; int T = 1 , i , j = 0 , k = 0 ; long n , m , l , ans = 0l , ans2 = 0l , ans3 = 0l , b , c ; for ( int tt = 0 ; tt < T ; tt ++ ) { n = fs . nextLong ( ) ; m = fs . nextLong ( ) ; if ( n == 1 ) { System . out . println ( 1 ) ; return ; } if ( n - m > m - 1 ) System . out . println ( m + 1 ) ; else System . out . println ( m - 1 ) ; } } static final Random random = new Random ( ) ; static void ruffleSort ( int [ ] a ) { int n = a . length ; for ( int i = 0 ; i < n ; i ++ ) { int oi = random . nextInt ( n ) , temp = a [ oi ] ; a [ oi ] = a [ i ] ; a [ i ] = temp ; } Arrays . sort ( a ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }
public class GFG { static boolean isHeterogram ( String s , int n ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ▁ ' ) { if ( hash [ s . charAt ( i ) - ' a ' ] == 0 ) hash [ s . charAt ( i ) - ' a ' ] = 1 ; else return false ; } } return true ; } public static void main ( String [ ] args ) { String s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; int n = s . length ( ) ; if ( isHeterogram ( s , n ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
public final class p024 { public static void main ( String [ ] args ) { System . out . println ( new p024 ( ) . run ( ) ) ; } public String run ( ) { int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] = i ; for ( int i = 0 ; i < 999999 ; i ++ ) { if ( ! Library . nextPermutation ( array ) ) throw new AssertionError ( ) ; } String ans = " " ; for ( int i = 0 ; i < array . length ; i ++ ) ans += array [ i ] ; return ans ; } }
public class GFG { static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static int MX = 2001 ; static int OFF = 1000 ; static class point { int x , y ; public point ( int x , int y ) { this . x = x ; this . y = y ; } } ; static int countPoints ( int n , point points [ ] ) { int [ ] minx = new int [ MX ] ; int [ ] miny = new int [ MX ] ; for ( int i = 0 ; i < n ; i ++ ) { minx [ i ] = Integer . MAX_VALUE ; miny [ i ] = Integer . MAX_VALUE ; } int [ ] maxx = new int [ MX ] ; int [ ] maxy = new int [ MX ] ; int x , y ; for ( int i = 0 ; i < n ; i ++ ) { points [ i ] . x += OFF ; points [ i ] . y += OFF ; x = points [ i ] . x ; y = points [ i ] . y ; minx [ y ] = Math . min ( minx [ y ] , x ) ; maxx [ y ] = Math . max ( maxx [ y ] , x ) ; miny [ x ] = Math . min ( miny [ x ] , y ) ; maxy [ x ] = Math . max ( maxy [ x ] , y ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = points [ i ] . x ; y = points [ i ] . y ; if ( x > minx [ y ] && x < maxx [ y ] ) if ( y > miny [ x ] && y < maxy [ x ] ) count ++ ; } return count ; } public static void main ( String [ ] args ) { point points [ ] = { new point ( 0 , 0 ) , new point ( 0 , 1 ) , new point ( 1 , 0 ) , new point ( 0 , - 1 ) , new point ( - 1 , 0 ) } ; int n = points . length ; System . out . println ( countPoints ( n , points ) ) ; } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . solve ( ) ; } public void solve ( ) { Scanner scan = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; long X = scan . nextLong ( ) ; long Y = scan . nextLong ( ) ; long Z = Y / X ; long answer = f ( Z ) + 1 ; System . out . println ( answer ) ; } public long f ( long Z ) { long t = 1 ; long result = 0 ; while ( t < Z ) { t *= 2 ; result += 1 ; } if ( t == Z ) { return result ; } return result - 1 ; } }
import java . util . * ; public class GFG { static int sticks [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; static int countSticks ( String str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str . charAt ( i ) - '0' ] ) ; } return cnt ; } public static void main ( String [ ] args ) { String str = "56" ; int n = str . length ( ) ; System . out . println ( countSticks ( str , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; int t = Integer . parseInt ( in . readLine ( ) ) ; while ( t -- > 0 ) { int n = Integer . parseInt ( in . readLine ( ) ) ; int [ ] a = new int [ n ] ; StringTokenizer st = new StringTokenizer ( in . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } boolean replaceNext = false ; int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( replaceNext ) { a [ i ] = Math . max ( a [ i - 1 ] , a [ i + 1 ] ) ; ans ++ ; replaceNext = false ; } if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) { replaceNext = true ; } } if ( replaceNext ) { a [ n - 1 ] = a [ n - 2 ] ; ans ++ ; replaceNext = false ; } out . println ( ans ) ; for ( int i = 0 ; i < n ; i ++ ) { out . print ( a [ i ] + " ▁ " ) ; } out . println ( ) ; } in . close ( ) ; out . close ( ) ; } }
public class GFG { static void command ( boolean arr [ ] , int a , int b ) { arr [ a ] ^= true ; arr [ b + 1 ] ^= true ; } static void process ( boolean arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { arr [ k ] ^= arr [ k - 1 ] ; } } static void result ( boolean arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { if ( arr [ k ] == true ) System . out . print ( "1" + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 5 , m = 3 ; boolean arr [ ] = new boolean [ n + 2 ] ; command ( arr , 1 , 5 ) ; command ( arr , 2 , 5 ) ; command ( arr , 3 , 5 ) ; process ( arr , n ) ; result ( arr , n ) ; } }
import java . util . * ; public class GFG { static int mostFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( mostFrequent ( arr , n ) ) ; } }
public class GFG { static int MAX = 26 ; static int maxLength ( String str , int len ) { int res = 0 ; int lastPos [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int C = str . charAt ( i ) - ' a ' ; if ( lastPos [ C ] != - 1 ) { res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; System . out . println ( maxLength ( str , len ) ) ; } }
public class GFG { static final int MAX = 1000000 ; static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Integer . MAX_VALUE ; } public static void main ( String [ ] args ) { int k = 1 ; int arr [ ] = { 1 } ; int n = arr . length ; System . out . println ( ksmallest ( arr , n , k ) ) ; } }
public class GFG { static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; } public static void main ( String [ ] args ) { int N = 2795 ; if ( isDivisible ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; public class GFG { static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; } public static void main ( String [ ] args ) { int N = 59173 ; if ( isDivisible ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; public class GFG { static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; } public static void main ( String [ ] args ) { int N = 1922 ; if ( isDivisible ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; public class GFG { static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) <= 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; } public static void main ( String args [ ] ) { int N = 5041 ; if ( isDivisible ( N ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static long Odd_Sum ( int n ) { long total = ( n + 1 ) / 2 ; long odd = total * total ; return odd ; } static long Even_Sum ( int n ) { long total = ( n ) / 2 ; long even = total * ( total + 1 ) ; return even ; } static long sumLtoR ( int L , int R ) { long odd_sum , even_sum ; odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) ; even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) ; return even_sum - odd_sum ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . println ( sumLtoR ( L , R ) ) ; } }
import java . io . * ; class Ratio { static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; } public static void main ( String args [ ] ) { int lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( int ) ( Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) ; } public static void main ( String [ ] args ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . HashSet ; import java . util . Set ; public final class p087 { public static void main ( String [ ] args ) { System . out . println ( new p087 ( ) . run ( ) ) ; } private static final int LIMIT = 50000000 ; public String run ( ) { int [ ] primes = Library . listPrimes ( Library . sqrt ( LIMIT ) ) ; Set < Integer > sums = new HashSet < > ( ) ; sums . add ( 0 ) ; for ( int i = 2 ; i <= 4 ; i ++ ) { Set < Integer > newsums = new HashSet < > ( ) ; for ( int p : primes ) { long q = 1 ; for ( int j = 0 ; j < i ; j ++ ) q *= p ; if ( q > LIMIT ) break ; int r = ( int ) q ; for ( int x : sums ) { if ( x + r <= LIMIT ) newsums . add ( x + r ) ; } } sums = newsums ; } return Integer . toString ( sums . size ( ) ) ; } }
import java . util . * ; public class GFG { static int longLenSub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = arr . length ; System . out . println ( " Longest ▁ length ▁ subsequence ▁ = ▁ " + longLenSub ( arr , n ) ) ; } }
import java . util . Scanner ; public class Problem1 { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { int a = s . nextInt ( ) ; int b = s . nextInt ( ) ; System . out . println ( a + b ) ; } } }
import java . io . * ; public class GFG { static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " Sum ▁ of ▁ all ▁ elements : " + calculateSum ( n ) ) ; } }
import java . io . * ; public class GFG { static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( " Sum ▁ of ▁ all ▁ elements : " + calculateSum ( n ) ) ; } }
public class GFG { static int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 80 , 2 , 6 , 3 , 100 } ; int n = arr . length ; System . out . print ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , n ) ) ; } }
import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static String line ; static final int MOD = 100000007 ; static long solve ( int len , int loop ) { long ret = 0 ; long [ ] dp = new long [ len + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; ++ i ) { for ( int j = 1 ; j <= Math . min ( loop , i ) ; ++ j ) { dp [ i ] += dp [ i - j ] ; } dp [ i ] %= MOD ; if ( ( len - i ) % loop == 0 ) { ret += dp [ i ] ; ret %= MOD ; } } return ret ; } static int solve ( ) { long ans = 1 ; int prev = 0 ; for ( int i = 1 ; i < line . length ( ) ; ++ i ) { if ( line . charAt ( i ) != line . charAt ( i - 1 ) ) { ans *= solve ( i - prev , loop ( line . charAt ( prev ) ) ) ; ans %= MOD ; prev = i ; } } ans *= solve ( line . length ( ) - prev , loop ( line . charAt ( prev ) ) ) ; ans %= MOD ; return ( int ) ans ; } static int loop ( char c ) { return c == '8' || c == '0' ? 3 : 5 ; } public static void main ( String [ ] args ) throws Exception { while ( true ) { line = sc . next ( ) ; if ( line . equals ( " # " ) ) break ; System . out . println ( solve ( ) ) ; } } }
public class GFG { public static int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countPairs ( n ) ) ; } }
import java . io . * ; import java . util . StringTokenizer ; public class er { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; Fast f = new Fast ( ) ; f . sol ( br , pw ) ; pw . close ( ) ; } } class Fast { public void sol ( BufferedReader br , PrintWriter pw ) throws IOException { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; String s = st . nextToken ( ) ; Integer cum [ ] = new Integer [ s . length ( ) + 1 ] ; cum [ 0 ] = cum [ s . length ( ) ] = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) cum [ i ] = cum [ i - 1 ] + 1 ; else cum [ i ] = cum [ i - 1 ] ; } st = new StringTokenizer ( br . readLine ( ) ) ; Integer q = Integer . parseInt ( st . nextToken ( ) ) ; while ( q -- != 0 ) { st = new StringTokenizer ( br . readLine ( ) ) ; Integer l = Integer . parseInt ( st . nextToken ( ) ) , r = Integer . parseInt ( st . nextToken ( ) ) - 1 ; pw . println ( cum [ r ] - cum [ l - 1 ] ) ; } } }
import java . io . IOException ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; while ( true ) { int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; if ( ( n | m ) == 0 ) break ; int [ ] pow3 = new int [ n + 1 ] ; pow3 [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) pow3 [ i ] = pow3 [ i - 1 ] * 3 ; int [ ] c = new int [ n ] ; for ( int i = 0 ; i < 3 ; i ++ ) { int a = scanner . nextInt ( ) ; for ( int j = a ; j > 0 ; j -- ) { int k = scanner . nextInt ( ) ; c [ n - k ] = i ; } } int p = 0 ; int x = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int d = Math . abs ( p - c [ i ] ) ; x += pow3 [ i ] * d ; if ( d == 1 ) p = 2 - p ; } int y = pow3 [ n ] - 1 - x ; if ( x > y ) x = y ; System . out . println ( x > m ? - 1 : x ) ; } } }
import java . util . * ; public class GFG { static int MAX = 100000 ; static void print ( int g1 [ ] , int a , int g2 [ ] , int b ) { for ( int i = 0 ; i < a ; i ++ ) { System . out . print ( g1 [ i ] + " ▁ " ) ; } System . out . print ( " and ▁ " ) ; for ( int i = 0 ; i < b ; i ++ ) { System . out . print ( g2 [ i ] + " ▁ " ) ; } System . out . println ( ) ; } static boolean checksum ( int g1 [ ] , int a , int g2 [ ] , int b ) { int i , x ; for ( i = 0 , x = 0 ; i < a ; i ++ ) { x += g1 [ i ] ; } for ( i = 0 ; i < b ; i ++ ) { x -= g2 [ i ] ; } return ( x == 0 ) ; } static void formgroups ( int arr [ ] , int x , int g1 [ ] , int a , int g2 [ ] , int b , int n ) { if ( x == n ) { if ( checksum ( g1 , a , g2 , b ) ) { print ( g1 , a , g2 , b ) ; } return ; } g1 [ a ] = arr [ x ] ; formgroups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) ; g2 [ b ] = arr [ x ] ; formgroups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 9 , 4 , 5 } ; int n = arr . length ; int [ ] g1 = new int [ MAX ] ; int [ ] g2 = new int [ MAX ] ; formgroups ( arr , 0 , g1 , 0 , g2 , 0 , n ) ; } }
import java . util . * ; public class a { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int [ ] a = new int [ 3 ] ; a [ 0 ] = in . nextInt ( ) ; a [ 1 ] = in . nextInt ( ) ; a [ 2 ] = in . nextInt ( ) ; Arrays . sort ( a ) ; int max = 0 ; int d [ ] = new int [ n + 1 ] ; Arrays . fill ( d , - 500 ) ; d [ 0 ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( i - a [ j ] >= 0 && d [ i - a [ j ] ] != - 1 ) d [ i ] = Math . max ( d [ i ] , d [ i - a [ j ] ] + 1 ) ; System . out . println ( d [ n ] ) ; } }
import java . io . * ; public class GFG { static int maxSubseq ( int [ ] vec , int n ) { int suffix = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( vec [ i ] == 1 ) { suffix ++ ; vec [ i ] = suffix ; } } int res = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vec [ i ] == 0 ) zero ++ ; if ( vec [ i ] > 0 ) res = Math . max ( res , zero + vec [ i ] ) ; } return Math . max ( res , zero ) ; } static public void main ( String [ ] args ) { int [ ] input = { 0 , 1 , 0 , 0 , 1 , 0 } ; int n = input . length ; System . out . println ( maxSubseq ( input , n ) ) ; } }
import java . io . * ; public class GFG { static int R = 4 ; static int C = 4 ; static int countPaths ( int maze [ ] [ ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; } public static void main ( String [ ] args ) { int maze [ ] [ ] = { { 0 , 0 , 0 , 0 } , { 0 , - 1 , 0 , 0 } , { - 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; System . out . println ( countPaths ( maze ) ) ; } }
import java . util . * ; public class GFG { static void isPrime ( int N ) { boolean isPrime = true ; int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 || N % 3 == 0 || N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > Math . sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) System . out . println ( " Prime ▁ Number " ) ; else System . out . println ( " Not ▁ a ▁ Prime ▁ Number " ) ; } public static void main ( String args [ ] ) { int N = 121 ; isPrime ( N ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int x1 = scan . nextInt ( ) ; int y1 = scan . nextInt ( ) ; int x2 = scan . nextInt ( ) ; int y2 = scan . nextInt ( ) ; int x3 = x2 + ( y1 - y2 ) ; int y3 = y2 - ( x1 - x2 ) ; int x4 = x1 - ( y2 - y1 ) ; int y4 = y1 + ( x2 - x1 ) ; System . out . println ( x3 + " ▁ " + y3 + " ▁ " + x4 + " ▁ " + y4 ) ; } }
public class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void main ( String [ ] args ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . printf ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , lps ( seq . toCharArray ( ) , 0 , n - 1 ) ) ; } }
public class GFG { static int findLength ( String str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int lsum = 0 , rsum = 0 ; while ( r < n && l >= 0 ) { lsum += str . charAt ( l ) - '0' ; rsum += str . charAt ( r ) - '0' ; if ( lsum == rsum ) { ans = Math . max ( ans , r - l + 1 ) ; } l -- ; r ++ ; } } return ans ; } static public void main ( String [ ] args ) { String str = "123123" ; System . out . println ( " Length ▁ of ▁ the ▁ substring ▁ is ▁ " + findLength ( str , str . length ( ) ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void print ( char a [ ] , int n , int ind ) { for ( int i = ind ; i < n + ind ; i ++ ) System . out . print ( a [ ( i % n ) ] + " ▁ " ) ; } public static void main ( String argc [ ] ) { char [ ] a = new char [ ] { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; int n = 6 ; print ( a , n , 3 ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void print ( char a [ ] , int n , int ind ) { char [ ] b = new char [ ( 2 * n ) ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = b [ n + i ] = a [ i ] ; for ( int i = ind ; i < n + ind ; i ++ ) System . out . print ( b [ i ] + " ▁ " ) ; } public static void main ( String argc [ ] ) { char [ ] a = new char [ ] { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; int n = 6 ; print ( a , n , 3 ) ; } }
import java . util . Scanner ; public class ER42B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) , a = in . nextInt ( ) , b = in . nextInt ( ) ; String s = in . next ( ) ; int ans = a + b ; int flip = a > b ? 1 : - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; if ( s . charAt ( i ) == ' * ' ) flip = a > b ? 1 : - 1 ; else { if ( flip == 1 ) a = ( a == 0 ? 0 : a - 1 ) ; else b = ( b == 0 ? 0 : b - 1 ) ; flip *= - 1 ; } } System . out . println ( ans - a - b ) ; } }
import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int id = sc . nextInt ( ) ; Node root = new Node ( ++ id , 0 , sc . next ( ) ) ; for ( int i = 1 ; i < n ; i ++ ) { int targetId = sc . nextInt ( ) ; Node parent = root . findNode ( targetId ) ; parent . children . add ( new Node ( ++ id , parent . depth + 1 , sc . next ( ) ) ) ; } root . printContents ( ) ; sc . close ( ) ; } } class Node { int id , depth ; String contents ; List < Node > children ; Node ( int i , int d , String c ) { id = i ; depth = d ; contents = c ; children = new ArrayList < Node > ( ) ; } public Node findNode ( int id ) { if ( id == this . id ) return this ; for ( Node child : children ) { Node target = child . findNode ( id ) ; if ( target != null ) return target ; } return null ; } public void printContents ( ) { for ( int i = 0 ; i < depth ; i ++ ) System . out . print ( ' . ' ) ; System . out . println ( contents ) ; for ( Node child : children ) child . printContents ( ) ; } }
import java . io . * ; import java . nio . Buffer ; import java . sql . Array ; import java . util . * ; public class Main2 { static int v1 ; static int v2 ; static int t ; static int d ; static int [ ] [ ] dp ; public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; v1 = sc . nextInt ( ) ; v2 = sc . nextInt ( ) ; t = sc . nextInt ( ) ; d = sc . nextInt ( ) ; dp = new int [ t ] [ 1200 ] ; for ( int [ ] x : dp ) Arrays . fill ( x , - 1 ) ; int ans = - 1 ; if ( t == 2 ) System . out . println ( v1 + v2 ) ; else System . out . println ( v1 + v2 + calculate ( 1 , v1 , v1 ) ) ; } public static int calculate ( int currentTime , int currentSpeed , int prev ) { if ( currentSpeed < 0 ) return - ( int ) ( 1e8 ) ; if ( currentTime == t - 1 ) { if ( Math . abs ( currentSpeed - v2 ) <= d ) return 0 ; return - ( int ) ( 1e8 ) ; } if ( dp [ currentTime ] [ currentSpeed ] != - 1 ) { return dp [ currentTime ] [ currentSpeed ] ; } int bestAns = - ( int ) ( 1e8 ) ; for ( int i = 0 ; i <= d ; i ++ ) { int ans = currentSpeed + i + calculate ( currentTime + 1 , currentSpeed + i , currentSpeed ) ; int ans2 = currentSpeed - i + calculate ( currentTime + 1 , currentSpeed - i , currentSpeed ) ; bestAns = Math . max ( bestAns , Math . max ( ans , ans2 ) ) ; } return dp [ currentTime ] [ currentSpeed ] = bestAns ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] a = sc . next ( ) . toCharArray ( ) , b = sc . next ( ) . toCharArray ( ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = n - 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( b [ j ] >= a [ i ] ) -- j ; } System . out . println ( j + 1 ) ; j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( b [ i ] > a [ j ] ) ++ j ; } System . out . print ( j ) ; } }
import java . util . * ; import java . lang . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] num = new int [ 3 ] ; num [ 0 ] = sc . nextInt ( ) ; num [ 1 ] = sc . nextInt ( ) ; num [ 2 ] = sc . nextInt ( ) ; Arrays . sort ( num ) ; int dis1 = num [ 2 ] - num [ 0 ] ; int dis2 = num [ 2 ] - num [ 1 ] ; int ans = 0 ; if ( dis1 % 2 == 0 && dis2 % 2 == 0 ) { ans = dis1 / 2 + dis2 / 2 ; } else if ( dis1 % 2 != 0 && dis2 % 2 != 0 ) { ans = dis1 / 2 + dis2 / 2 + 1 ; } else { ans = dis1 / 2 + dis2 / 2 + 2 ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; while ( T -- > 0 ) { int n = sc . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 || i == j ) { System . out . print ( 1 + " ▁ " ) ; } else { System . out . print ( 0 + " ▁ " ) ; } } System . out . println ( ) ; } } } }
public class GFG { static void bin ( Integer n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . printf ( " % d " , n & 1 ) ; } public static void main ( String [ ] args ) { bin ( 131 ) ; System . out . printf ( " \n " ) ; bin ( 3 ) ; } }
public final class p001 { public static void main ( String [ ] args ) { System . out . println ( new p001 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( i % 3 == 0 || i % 5 == 0 ) sum += i ; } return Integer . toString ( sum ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String str = sc . next ( ) ; String s = " " ; String s1 = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' n ' ) { s += "1 ▁ " ; } if ( str . charAt ( i ) == ' z ' ) { s1 += "0 ▁ " ; } } System . out . println ( s + s1 ) ; } }
import java . util . * ; public class Main { static void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int R = sc . nextInt ( ) , G = sc . nextInt ( ) ; System . out . println ( ( 2 * G ) - R ) ; sc . close ( ) ; } public static void main ( String args [ ] ) { solve ( ) ; } }
import java . io . * ; public class GFG { static int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( Circular ( n - 1 ) ) ; } }
import java . util . * ; public class GFG { static int productDiagonals ( int arr [ ] [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * arr [ i ] [ i ] ; product = product * arr [ i ] [ n - i - 1 ] ; } if ( n % 2 == 1 ) { product = product / arr [ n / 2 ] [ n / 2 ] ; } return product ; } public static void main ( String [ ] args ) { int arr1 [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 7 , 4 , 2 } , { 2 , 2 , 2 , 1 } } ; System . out . print ( productDiagonals ( arr1 , 4 ) + " \n " ) ; int arr2 [ ] [ ] = { { 2 , 1 , 2 , 1 , 2 } , { 1 , 2 , 1 , 2 , 1 } , { 2 , 1 , 2 , 1 , 2 } , { 1 , 2 , 1 , 2 , 1 } , { 2 , 1 , 2 , 1 , 2 } } ; System . out . print ( productDiagonals ( arr2 , 5 ) + " \n " ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; void run ( ) { for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) { break ; } int map [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { map [ sc . nextInt ( ) ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { String ans = " - " ; if ( map [ i ] != 0 ) { char [ ] ch = new char [ map [ i ] ] ; Arrays . fill ( ch , ' * ' ) ; ans = new String ( ch ) ; } System . out . println ( ans ) ; } } } public static void main ( String [ ] args ) { Main m = new Main ( ) ; m . run ( ) ; } }
public class GFG { static final int NO_OF_CHARS = 256 ; static char getSecondMostFreq ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) ( count [ str . charAt ( i ) ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; char res = getSecondMostFreq ( str ) ; if ( res != ' \ 0' ) System . out . println ( " Second ▁ most ▁ frequent ▁ char " + " ▁ is ▁ " + res ) ; else System . out . println ( " No ▁ second ▁ most ▁ frequent " + " character " ) ; } }
import java . util . * ; public class Main { void run ( ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] dp = new int [ 5 ] [ 4001 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { for ( int ii = 0 ; ii <= 1000 * i ; ii ++ ) { for ( int iii = Math . max ( 0 , ii - 1000 ) ; iii <= ii ; iii ++ ) { dp [ i ] [ ii ] += dp [ i - 1 ] [ iii ] ; } } } while ( sc . hasNext ( ) ) { System . out . println ( dp [ 4 ] [ sc . nextInt ( ) ] ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class SortExample { static void mySort ( Integer [ ] arr ) { int n = arr . length ; Arrays . sort ( arr , 0 , n / 2 ) ; Arrays . sort ( arr , n / 2 , n , Collections . reverseOrder ( ) ) ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 } ; mySort ( arr ) ; System . out . printf ( " Modified ▁ Array ▁ : ▁ % s " , Arrays . toString ( arr ) ) ; } }
import java . io . * ; public class GFG { static int minflip ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] > 0 ^ arr2 [ i ] > 0 != arr3 [ i ] > 0 ) flip ++ ; return ( flip <= p + q ) ? flip : - 1 ; } static public void main ( String [ ] args ) { int [ ] arr1 = { 1 , 0 , 1 , 1 , 1 , 1 , 1 } ; int [ ] arr2 = { 0 , 1 , 1 , 1 , 1 , 0 , 0 } ; int [ ] arr3 = { 1 , 1 , 1 , 1 , 0 , 0 , 1 } ; int n = arr1 . length ; int p = 2 , q = 4 ; System . out . println ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) ; } }
import java . io . * ; public class GFG { static double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . printf ( " Sum ▁ is ▁ % f " , sum ( n ) ) ; } }
import java . util . * ; public class GFG { static void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < Integer > ( ) ; Vector < Integer > oddArr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } Collections . sort ( evenArr ) ; Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr . get ( j ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; bitonicGenerator ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
public class GFG { static int countPairs ( int arr [ ] , int n ) { int count = 0 ; int right = 0 , left = 0 ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ i ] = false ; while ( right < n ) { while ( right < n && ! visited [ arr [ right ] ] ) { count += ( right - left ) ; visited [ arr [ right ] ] = true ; right ++ ; } while ( left < right && ( right != n && visited [ arr [ right ] ] ) ) { visited [ arr [ left ] ] = false ; left ++ ; } } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 2 , 4 , 3 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . util . * ; class TreeNode { public int val ; public TreeNode left ; public TreeNode right ; public TreeNode ( int rootData ) { this . val = rootData ; this . left = null ; this . right = null ; } } public class Solution { HashSet < String > trees = new HashSet < > ( ) ; public boolean isSubtree ( TreeNode s , TreeNode t ) { String tree1 = preorder ( s , true ) ; String tree2 = preorder ( t , true ) ; return tree1 . indexOf ( tree2 ) >= 0 ; } public String preorder ( TreeNode t , boolean left ) { if ( t == null ) { if ( left ) return " lnull " ; else return " rnull " ; } return " # " + t . val + " ▁ " + preorder ( t . left , true ) + " ▁ " + preorder ( t . right , false ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; TreeNode root = new TreeNode ( 3 ) ; root . left = new TreeNode ( 4 ) ; root . right = new TreeNode ( 5 ) ; root . left . left = new TreeNode ( 1 ) ; root . left . right = new TreeNode ( 2 ) ; TreeNode subRoot = new TreeNode ( 4 ) ; subRoot . left = new TreeNode ( 1 ) ; subRoot . right = new TreeNode ( 2 ) ; boolean out = sObj . isSubtree ( root , subRoot ) ; System . out . println ( out ) ; } }
public class GFG { static int M = 1001 ; static int MOD = 998244353 ; static int [ ] [ ] dp = new int [ M ] [ M ] ; static int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 , K = 0 ; for ( int i = 0 ; i <= M ; i ++ ) for ( int j = 0 ; j <= M ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . println ( ( M * solve ( 2 , 0 , N , M , K ) ) ) ; } }
public final class p222 { public static void main ( String [ ] args ) { System . out . println ( new p222 ( ) . run ( ) ) ; } public String run ( ) { sphereRadii = new double [ 21 ] ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) sphereRadii [ i ] = ( i + 30 ) * 1000 ; minLength = new double [ sphereRadii . length ] [ 1 << sphereRadii . length ] ; double min = Double . POSITIVE_INFINITY ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) min = Math . min ( findMinimumLength ( i , ( 1 << sphereRadii . length ) - 1 ) + sphereRadii [ i ] , min ) ; return Long . toString ( Math . round ( min ) ) ; } private double [ ] sphereRadii ; private double [ ] [ ] minLength ; private double findMinimumLength ( int currentSphereIndex , int setOfSpheres ) { if ( ( setOfSpheres & ( 1 << currentSphereIndex ) ) == 0 ) throw new IllegalArgumentException ( ) ; if ( minLength [ currentSphereIndex ] [ setOfSpheres ] == 0 ) { double result ; if ( Integer . bitCount ( setOfSpheres ) == 1 ) result = sphereRadii [ currentSphereIndex ] ; else { result = Double . POSITIVE_INFINITY ; int newSetOfSpheres = setOfSpheres ^ ( 1 << currentSphereIndex ) ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) { if ( ( newSetOfSpheres & ( 1 << i ) ) == 0 ) continue ; double temp = Math . sqrt ( ( sphereRadii [ i ] + sphereRadii [ currentSphereIndex ] - 50000 ) * 200000 ) ; temp += findMinimumLength ( i , newSetOfSpheres ) ; result = Math . min ( temp , result ) ; } } minLength [ currentSphereIndex ] [ setOfSpheres ] = result ; } return minLength [ currentSphereIndex ] [ setOfSpheres ] ; } }
import java . io . * ; public class Main { public static void main ( String args [ ] ) { int n ; int sides [ ] = new int [ 3 ] ; boolean judge = false ; String line ; String tmp [ ] ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { line = reader . readLine ( ) ; n = Integer . parseInt ( line ) ; for ( int i = 0 ; i < n ; i ++ ) { line = reader . readLine ( ) ; tmp = line . split ( " ▁ " ) ; for ( int j = 0 ; j < sides . length ; j ++ ) { sides [ j ] = Integer . parseInt ( tmp [ j ] ) ; sides [ j ] *= sides [ j ] ; } for ( int j = 0 ; j < sides . length ; j ++ ) { if ( sides [ j % 3 ] == sides [ ( j + 1 ) % 3 ] + sides [ ( j + 2 ) % 3 ] ) { judge = true ; break ; } else judge = false ; } Answer ( judge ) ; } } catch ( IOException e ) { System . exit ( 0 ) ; } } static void Answer ( boolean j ) { if ( j ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; public class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
import java . io . * ; public class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; double l , p , q ; l = input . nextDouble ( ) ; p = input . nextDouble ( ) ; q = input . nextDouble ( ) ; System . out . println ( ( p * l ) / ( p + q ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t > 0 ) { int n = sc . nextInt ( ) ; int arr [ ] = new int [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( Math . abs ( arr [ n ] - arr [ n - 1 ] ) ) ; t -- ; } } }
import java . io . * ; import java . util . * ; public class S { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; long cntp [ ] = new long [ 11 ] ; long cntn [ ] = new long [ 11 ] ; long cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int a = in . nextInt ( ) ; if ( a == 0 ) cnt ++ ; else if ( a > 0 ) cntp [ a ] ++ ; else if ( a < 0 ) cntn [ Math . abs ( a ) ] ++ ; } long res = 0 ; for ( int i = 1 ; i < 11 ; i ++ ) res = res + ( cntp [ i ] * cntn [ i ] ) ; res = res + ( ( cnt * ( cnt - 1 ) ) / 2 ) ; System . out . print ( res ) ; } }
import java . io . * ; import java . util . * ; public class CF95A extends PrintWriter { CF95A ( ) { super ( System . out , true ) ; } Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] $ ) { CF95A o = new CF95A ( ) ; o . main ( ) ; o . flush ( ) ; } int compare ( char [ ] aa , int i , char [ ] bb , int j , int m ) { while ( m -- > 0 ) { char a = Character . toUpperCase ( aa [ i ] ) ; char b = Character . toUpperCase ( bb [ j ] ) ; if ( a != b ) return a - b ; i ++ ; j ++ ; } return 0 ; } void main ( ) { int n = sc . nextInt ( ) ; char [ ] [ ] ss = new char [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) ss [ i ] = sc . next ( ) . toCharArray ( ) ; char [ ] cc = sc . next ( ) . toCharArray ( ) ; int m = cc . length ; char c = sc . next ( ) . charAt ( 0 ) ; char c_ = Character . toUpperCase ( c ) ; char a = c == ' a ' ? ' b ' : ' a ' ; char a_ = Character . toUpperCase ( a ) ; boolean [ ] lucky = new boolean [ m ] ; for ( int j = 0 ; j < m ; j ++ ) for ( int i = 0 ; i < n ; i ++ ) { int l = ss [ i ] . length ; if ( m - j >= l && compare ( cc , j , ss [ i ] , 0 , l ) == 0 ) for ( int h = 0 ; h < l ; h ++ ) lucky [ j + h ] = true ; } for ( int j = 0 ; j < m ; j ++ ) if ( lucky [ j ] ) { if ( Character . toLowerCase ( cc [ j ] ) == c ) cc [ j ] = Character . isUpperCase ( cc [ j ] ) ? a_ : a ; else cc [ j ] = Character . isUpperCase ( cc [ j ] ) ? c_ : c ; } println ( cc ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; char [ ] c = sc . next ( ) . toCharArray ( ) ; int [ ] w = new int [ a + 1 ] ; int [ ] e = new int [ a + 1 ] ; int min = a ; for ( int i = 1 ; i <= a ; i ++ ) { if ( c [ i - 1 ] == ' W ' ) { w [ i ] ++ ; } else { e [ i ] ++ ; } w [ i ] += w [ i - 1 ] ; e [ i ] += e [ i - 1 ] ; } for ( int i = 1 ; i <= a ; i ++ ) { min = Math . min ( min , w [ i - 1 ] + e [ a ] - e [ i ] ) ; } System . out . println ( min ) ; } }
import java . util . Scanner ; public class CF1213A { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int num1 = scan . nextInt ( ) ; if ( num1 % 2 == 0 ) { even ++ ; } else { odd ++ ; } } if ( even > odd ) { System . out . println ( odd ) ; } else { System . out . println ( even ) ; } } }
import java . util . * ; public class Main { public void doIt ( ) { Scanner sc = new Scanner ( System . in ) ; final int MAX = 10000000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 3 ; i <= MAX ; i += 2 ) { prime [ i ] = true ; } for ( int i = 3 ; i * i <= MAX ; i += 2 ) { if ( prime [ i ] ) { for ( int j = i * 3 ; j <= MAX ; j += i * 2 ) { prime [ j ] = false ; } } } int n = sc . nextInt ( ) ; while ( n != 0 ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; i >= 13 ; i -= 2 ) { if ( prime [ i ] && prime [ i - 2 ] && prime [ i - 6 ] && prime [ i - 8 ] ) { System . out . println ( i ) ; break ; } } n = sc . nextInt ( ) ; } } public static void main ( String [ ] args ) { Main obj = new Main ( ) ; obj . doIt ( ) ; } }
import java . util . * ; import java . io . * ; public class B_Spider_Man { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } static FastReader scan = new FastReader ( ) ; public static void main ( String [ ] args ) { int t = 1 ; while ( t -- > 0 ) { solve ( ) ; } } public static void solve ( ) { int t = scan . nextInt ( ) ; int [ ] arr = new int [ t ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = scan . nextInt ( ) ; } int prevWinner = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == 1 ) { if ( prevWinner == 0 ) { prevWinner = 2 ; } } if ( prevWinner == 2 || prevWinner == 0 ) { if ( ( arr [ i ] - 1 ) % 2 == 0 ) { System . out . println ( 2 ) ; prevWinner = 2 ; } else { System . out . println ( 1 ) ; prevWinner = 1 ; } } else { if ( ( arr [ i ] - 1 ) % 2 == 0 ) { System . out . println ( 1 ) ; prevWinner = 1 ; } else { System . out . println ( 2 ) ; prevWinner = 2 ; } } } } }
import java . util . * ; public class GFG { static boolean powerOfTwo ( int n ) { return ( ( n & n - 1 ) == 0 ) ; } static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; return powerOfTwo ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = Integer . parseUnsignedInt ( "9" ) ; if ( onlyFirstAndLastAreSet ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; import java . util . Collections ; public class GFG { static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } public static void main ( String arg [ ] ) { int m = 6 , n = 4 ; Integer X [ ] = { 2 , 1 , 3 , 1 , 4 } ; Integer Y [ ] = { 4 , 1 , 2 } ; System . out . print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ; } }
public class GCD { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int countPairs ( int G , int L ) { int count = 0 ; int p = G * L ; for ( int a = 1 ; a <= L ; a ++ ) if ( ( p % a == 0 ) && gcd ( a , p / a ) == G ) count ++ ; return count ; } public static void main ( String [ ] args ) { int G = 2 , L = 12 ; System . out . print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + G ) ; System . out . print ( " ▁ & ▁ LCM ▁ " + L ) ; System . out . print ( " ▁ = ▁ " + countPairs ( G , L ) ) ; } }
import java . io . * ; public class GFG { static void multiply ( int a [ ] [ ] , int b [ ] [ ] ) { int mul [ ] [ ] = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; } static int power ( int F [ ] [ ] , int n ) { int M [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; } static int findNthTerm ( int n ) { int F [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; return power ( F , n - 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " F ( 5 ) ▁ is ▁ " + findNthTerm ( n ) ) ; } }
import java . io . * ; public class GFG { static void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + " ▁ " + b + " ▁ " + c ) ; } public static void main ( String [ ] args ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; } }
class Solution { public boolean checkPossibility ( int [ ] nums ) { int brokenPoint = 0 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] > nums [ i + 1 ] ) { brokenPoint ++ ; if ( brokenPoint >= 2 ) return false ; if ( i - 1 < 0 || nums [ i - 1 ] <= nums [ i + 1 ] ) nums [ i ] = nums [ i + 1 ] ; else nums [ i + 1 ] = nums [ i ] ; } } return true ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 4 , 2 , 3 } ; boolean out = sObj . checkPossibility ( nums ) ; System . out . println ( out ) ; } }
public class GFG { static boolean check ( int mid , int array [ ] , int n , int K ) { int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] > mid ) return false ; sum += array [ i ] ; if ( sum > mid ) { count ++ ; sum = array [ i ] ; } } count ++ ; if ( count <= K ) return true ; return false ; } static int solve ( int array [ ] , int n , int K ) { int start = 1 ; int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { end += array [ i ] ; } int answer = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , array , n , K ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } return answer ; } public static void main ( String [ ] args ) { int array [ ] = { 1 , 2 , 3 , 4 } ; int n = array . length ; int K = 3 ; System . out . println ( solve ( array , n , K ) ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int M ; static int [ ] memo = new int [ 1 << 22 ] ; public static void main ( String [ ] args ) { while ( true ) { M = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; if ( M == 0 ) break ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { list . add ( Integer . parseInt ( sc . next ( ) , 2 ) ) ; } Arrays . fill ( memo , - 1 ) ; System . out . println ( rec ( 0 , list ) ) ; } } static int rec ( int used , ArrayList < Integer > list ) { if ( list . size ( ) <= 1 ) return 0 ; if ( memo [ used ] >= 0 ) return memo [ used ] ; int ret = 99 ; for ( int i = 0 ; i < M ; ++ i ) { if ( ( used & ( 3 << ( 2 * i ) ) ) != 0 ) continue ; ArrayList < Integer > on = new ArrayList < Integer > ( ) ; ArrayList < Integer > off = new ArrayList < Integer > ( ) ; for ( int v : list ) { if ( ( v & ( 1 << i ) ) != 0 ) { on . add ( v ) ; } else { off . add ( v ) ; } } if ( on . isEmpty ( ) || off . isEmpty ( ) ) continue ; ret = Math . min ( ret , Math . max ( rec ( used | ( 1 << ( 2 * i ) ) , on ) , rec ( used | ( 2 << ( 2 * i ) ) , off ) ) ) ; } memo [ used ] = ret + 1 ; return ret + 1 ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( solve ( a , b ) ) ; } sc . close ( ) ; } static int solve ( int a , int b ) { return Math . min ( Math . min ( computeSquareArea ( a + a , b ) , computeSquareArea ( a + b , Math . max ( a , b ) ) ) , computeSquareArea ( a , b + b ) ) ; } static int computeSquareArea ( int side1 , int side2 ) { int size = Math . max ( side1 , side2 ) ; return size * size ; } }
import java . io . * ; import java . util . * ; public class Solution { public static boolean solve ( int a [ ] , int b [ ] , int n ) { int [ ] ans = new int [ n ] ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , ( a [ i ] - b [ i ] ) ) ; } if ( max < 0 ) { return false ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] - max ; if ( temp <= 0 ) { ans [ i ] = 0 ; } else { ans [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] != b [ i ] ) { return false ; } } return true ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } if ( solve ( a , b , n ) == true ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public class GFG { static String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' ) return ( " Even " ) ; else return ( " Odd " ) ; } public static void main ( String [ ] args ) { String N = "735" ; System . out . print ( even_or_odd ( N ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; class Vector { int [ ] A ; int length = 0 ; Vector ( ) { A = new int [ 20 ] ; } void add ( int x ) { if ( length == A . length ) { A = Arrays . copyOf ( A , length * 2 ) ; } A [ length ] = x ; length ++ ; } void deleteBack ( ) { length -- ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( length > 0 ) sb . append ( A [ 0 ] ) ; for ( int i = 1 ; i < length ; ++ i ) { sb . append ( " ▁ " ) ; sb . append ( A [ i ] ) ; } return sb . toString ( ) ; } } public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , q = sc . nextInt ( ) ; Vector [ ] v = new Vector [ n ] ; boolean [ ] active = new boolean [ n ] ; for ( int i = 0 ; i < q ; ++ i ) { int req = sc . nextInt ( ) , t = sc . nextInt ( ) ; switch ( req ) { case 0 : if ( ! active [ t ] ) { v [ t ] = new Vector ( ) ; active [ t ] = true ; } v [ t ] . add ( sc . nextInt ( ) ) ; break ; case 1 : if ( active [ t ] ) System . out . println ( v [ t ] ) ; else System . out . println ( ) ; break ; case 2 : active [ t ] = false ; break ; } } } }
import java . io . * ; import java . util . * ; public class pr6 { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) , k1 = 0 , k2 = 0 , w1 = 0 , w2 = 0 , a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scan . nextInt ( ) ; if ( a [ i ] % 2 == 0 ) { w1 ++ ; k1 = i + 1 ; } else { w2 ++ ; k2 = i + 1 ; } } System . out . println ( ( w1 == 1 ) ? k1 : k2 ) ; } }
public class GFG { static int solve ( String X , String Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + Math . abs ( X . charAt ( i - 1 ) - Y . charAt ( i - 1 ) ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = Math . max ( sol , i - j ) ; } return sol ; } public static void main ( String [ ] args ) { int N = 4 ; String X = " abcd " , Y = " bcde " ; int K = 3 ; System . out . print ( solve ( X , Y , N , K ) + " \n " ) ; } }
import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; int INF = 1 << 28 ; double EPS = 1e-9 ; int n , m ; int [ ] a ; void run ( ) { n = sc . nextInt ( ) ; m = sc . nextInt ( ) ; a = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } solve ( ) ; } void solve ( ) { int gcd = a [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { gcd = gcd ( gcd , a [ i ] ) ; } println ( gcd ( gcd , n ) == 1 ? " Yes " : " No " ) ; } int gcd ( int a , int b ) { return a == 0 ? b : gcd ( b % a , a ) ; } void println ( String s ) { System . out . println ( s ) ; } void print ( String s ) { System . out . print ( s ) ; } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . * ; public class GFG { static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; } public static void main ( String [ ] args ) { int n = 15 ; if ( isPrime ( n , 2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static boolean isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } static int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; } public static void main ( String [ ] args ) { int n = 27 ; System . out . println ( minimumSum ( n ) ) ; } }
import java . util . * ; public class GFG { static boolean isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } static int minimumCost ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( minimumCost ( n ) ) ; } }
public class GFG { static int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; } public static void main ( String [ ] args ) { int x = 156 ; System . out . println ( " Next ▁ higher ▁ number ▁ with ▁ same " + " number ▁ of ▁ set ▁ bits ▁ is ▁ " + snoob ( x ) ) ; } }
public class GFG { static int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( properDivisorSum ( n ) ) ; n = 5 ; System . out . println ( properDivisorSum ( n ) ) ; } }
import java . io . * ; public class GFG { static int getMinLength ( double arr [ ] , int n ) { int count = 0 ; int result = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { count ++ ; } else { if ( count != 0 ) result = Math . min ( result , count ) ; count = 0 ; } } return result ; } public static void main ( String [ ] args ) { double arr [ ] = { 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( getMinLength ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int getLevenstein ( StringBuilder input ) { StringBuilder revInput = new StringBuilder ( input ) ; revInput = revInput . reverse ( ) ; int n = input . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = Integer . MAX_VALUE ; for ( int i = n , j = 0 ; i >= 0 ; i -- , j ++ ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; } public static void main ( String [ ] args ) { StringBuilder input = new StringBuilder ( " myfirstgeekarticle " ) ; System . out . println ( getLevenstein ( input ) ) ; } }
import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public final class p088 { public static void main ( String [ ] args ) { System . out . println ( new p088 ( ) . run ( ) ) ; } private static final int LIMIT = 12000 ; private int [ ] minSumProduct ; public String run ( ) { minSumProduct = new int [ LIMIT + 1 ] ; Arrays . fill ( minSumProduct , Integer . MAX_VALUE ) ; for ( int i = 2 ; i <= LIMIT * 2 ; i ++ ) factorize ( i , i , i , 0 , 0 ) ; Set < Integer > items = new HashSet < > ( ) ; for ( int i = 2 ; i < minSumProduct . length ; i ++ ) items . add ( minSumProduct [ i ] ) ; int sum = 0 ; for ( int n : items ) sum += n ; return Integer . toString ( sum ) ; } private void factorize ( int n , int remain , int maxFactor , int sum , int terms ) { if ( remain == 1 ) { if ( sum > n ) throw new AssertionError ( ) ; terms += n - sum ; if ( terms <= LIMIT && n < minSumProduct [ terms ] ) minSumProduct [ terms ] = n ; } else { for ( int i = 2 ; i <= maxFactor ; i ++ ) { if ( remain % i == 0 ) { int factor = i ; factorize ( n , remain / factor , Math . min ( factor , maxFactor ) , sum + factor , terms + 1 ) ; } } } } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String [ ] sa = br . readLine ( ) . split ( " ▁ " ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( sa [ i ] ) ; } br . close ( ) ; int mod = 1000000007 ; long p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p = p * i % mod ; } long [ ] q = new long [ n ] ; q [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { q [ i ] = ( q [ i - 1 ] + modinv ( i + 1 , mod ) ) % mod ; } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long val = q [ i ] + q [ n - i - 1 ] - 1 ; val *= a [ i ] ; val %= mod ; val *= p ; val %= mod ; ans += val ; ans %= mod ; } System . out . println ( ans ) ; } static long modinv ( long a , int m ) { long b = m ; long u = 1 ; long v = 0 ; long tmp = 0 ; while ( b > 0 ) { long t = a / b ; a -= t * b ; tmp = a ; a = b ; b = tmp ; u -= t * v ; tmp = u ; u = v ; v = tmp ; } u %= m ; if ( u < 0 ) u += m ; return u ; } }
import java . util . LinkedList ; import java . util . Queue ; import java . util . Stack ; public class Queue_reverse { static Queue < Integer > queue ; static void Print ( ) { while ( ! queue . isEmpty ( ) ) { System . out . print ( queue . peek ( ) + " ▁ " ) ; queue . remove ( ) ; } } static Queue < Integer > reverseQueue ( Queue < Integer > q ) { if ( q . isEmpty ( ) ) return q ; int data = q . peek ( ) ; q . remove ( ) ; q = reverseQueue ( q ) ; q . add ( data ) ; return q ; } public static void main ( String args [ ] ) { queue = new LinkedList < Integer > ( ) ; queue . add ( 56 ) ; queue . add ( 27 ) ; queue . add ( 30 ) ; queue . add ( 45 ) ; queue . add ( 85 ) ; queue . add ( 92 ) ; queue . add ( 58 ) ; queue . add ( 80 ) ; queue . add ( 90 ) ; queue . add ( 100 ) ; queue = reverseQueue ( queue ) ; Print ( ) ; } }
import java . io . * ; public class GFG { static int MAX = 1000000 ; static boolean prime [ ] = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int findDiff ( int arr [ ] , int n ) { int min = MAX + 2 , max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == true ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } } return ( max == - 1 ) ? - 1 : ( max - min ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 4 ; int arr [ ] = { 1 , 2 , 3 , 5 } ; int res = findDiff ( arr , n ) ; if ( res == - 1 ) System . out . print ( " No ▁ prime ▁ numbers " ) ; else System . out . println ( " Difference ▁ is ▁ " + res ) ; } }
import java . awt . geom . Point2D ; import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new AOJ_GRL_2 ( ) ; } class AOJ_GRL_2 { int cost [ ] [ ] ; int d [ ] ; boolean used [ ] ; int V ; int INF ; int cnt ; void Prim ( int s ) { d = new int [ V ] ; used = new boolean [ V ] ; INF = Integer . MAX_VALUE ; Arrays . fill ( used , false ) ; Arrays . fill ( d , INF ) ; d [ s ] = 0 ; cnt = 0 ; while ( true ) { int v = - 1 ; for ( int u = 0 ; u < V ; u ++ ) { if ( ! used [ u ] && ( v == - 1 || d [ u ] < d [ v ] ) ) v = u ; } if ( v == - 1 ) break ; used [ v ] = true ; int a = d [ v ] / 100 ; if ( a > 0 ) a -- ; cnt += a ; for ( int k = 0 ; k < V ; k ++ ) if ( ! used [ k ] && cost [ v ] [ k ] != 0 ) { d [ k ] = Math . min ( cost [ v ] [ k ] , d [ k ] ) ; } } } public AOJ_GRL_2 ( ) { while ( true ) { V = in . nextInt ( ) ; cost = new int [ V ] [ V ] ; if ( V == 0 ) break ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String input [ ] = in . next ( ) . split ( " , " ) ; int a = Integer . parseInt ( input [ 0 ] ) ; int b = Integer . parseInt ( input [ 1 ] ) ; int c = Integer . parseInt ( input [ 2 ] ) ; cost [ a ] [ b ] = c ; cost [ b ] [ a ] = c ; } Prim ( 0 ) ; System . out . println ( cnt ) ; } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import static java . lang . Math . ceil ; public class A_Summer_Camp { static BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static PrintWriter out = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) throws IOException { int n = Integer . parseInt ( in . readLine ( ) ) ; String s = " " ; for ( int i = 1 ; i <= n ; i ++ ) { s += i ; } out . print ( s . charAt ( n - 1 ) ) ; out . close ( ) ; } }
import java . util . * ; public class GFG { static int distinctSubString ( String P , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { boolean [ ] freq = new boolean [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P . charAt ( j ) - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P . charAt ( j ) ; S . add ( s ) ; } } return S . size ( ) ; } public static void main ( String [ ] args ) { String S = " abba " ; int N = S . length ( ) ; System . out . print ( distinctSubString ( S , N ) ) ; } }
import java . io . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) { solve ( ) ; } public static void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int x = 0 ; if ( ( n - k ) % ( k - 1 ) == 0 ) { x = ( n - k ) / ( k - 1 ) ; } else { x = ( n - k ) / ( k - 1 ) + 1 ; } System . out . println ( x + 1 ) ; } }
import java . util . * ; public class GFG { static int minimumAdjacentDifference ( int a [ ] , int n , int k ) { int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = Integer . bitCount ( i ) ; if ( cnt == n - k ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) temp . add ( a [ j ] ) ; } int maxDiff = Integer . MIN_VALUE ; for ( int j = 0 ; j < temp . size ( ) - 1 ; j ++ ) { maxDiff = Math . max ( maxDiff , temp . get ( j + 1 ) - temp . get ( j ) ) ; } minDiff = Math . min ( minDiff , maxDiff ) ; } } return minDiff ; } public static void main ( String args [ ] ) { int n = 5 ; int k = 2 ; int a [ ] = { 3 , 7 , 8 , 10 , 14 } ; System . out . println ( minimumAdjacentDifference ( a , n , k ) ) ; } }
import java . util . * ; public class GFG { static void difference ( int arr [ ] , int n ) { int largest = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( largest < arr [ i ] ) largest = arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = largest - arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 5 , 9 , 3 , 2 } ; int n = arr . length ; difference ( arr , n ) ; } }
import java . util . * ; class Count { public static int countKdivPairs ( int A [ ] , int n , int K ) { int freq [ ] = new int [ K ] ; for ( int i = 0 ; i < n ; i ++ ) ++ freq [ A [ i ] % K ] ; int sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i <= K / 2 && i != ( K - i ) ; i ++ ) sum += freq [ i ] * freq [ K - i ] ; if ( K % 2 == 0 ) sum += ( freq [ K / 2 ] * ( freq [ K / 2 ] - 1 ) / 2 ) ; return sum ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 2 , 1 , 7 , 5 , 3 } ; int n = 6 ; int K = 4 ; System . out . print ( countKdivPairs ( A , n , K ) ) ; } }
import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { String [ ] S = new String [ 3 ] ; S [ 0 ] = sc . next ( ) ; if ( S [ 0 ] . equals ( "0" ) ) { break ; } S [ 1 ] = sc . next ( ) ; S [ 2 ] = sc . next ( ) ; boolean f = true ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( S [ i ] . charAt ( 0 ) == S [ i ] . charAt ( 1 ) && S [ i ] . charAt ( 1 ) == S [ i ] . charAt ( 2 ) && S [ i ] . charAt ( 0 ) != ' + ' ) { System . out . println ( S [ i ] . charAt ( 0 ) ) ; f = false ; break ; } if ( S [ 0 ] . charAt ( i ) == S [ 1 ] . charAt ( i ) && S [ 1 ] . charAt ( i ) == S [ 2 ] . charAt ( i ) && S [ 0 ] . charAt ( i ) != ' + ' ) { System . out . println ( S [ 0 ] . charAt ( i ) ) ; f = false ; break ; } } if ( f && S [ 0 ] . charAt ( 0 ) == S [ 1 ] . charAt ( 1 ) && S [ 1 ] . charAt ( 1 ) == S [ 2 ] . charAt ( 2 ) && S [ 0 ] . charAt ( 0 ) != ' + ' ) { System . out . println ( S [ 0 ] . charAt ( 0 ) ) ; f = false ; } if ( f && S [ 0 ] . charAt ( 2 ) == S [ 1 ] . charAt ( 1 ) && S [ 1 ] . charAt ( 1 ) == S [ 2 ] . charAt ( 0 ) && S [ 0 ] . charAt ( 2 ) != ' + ' ) { System . out . println ( S [ 0 ] . charAt ( 2 ) ) ; f = false ; } if ( f ) { System . out . println ( " NA " ) ; } } } }
import java . io . * ; class Binary { static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " + maxOnesIndex ( arr , n ) ) ; } }
class Solution { static int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } public static void main ( String args [ ] ) { int n = 4 , k = 6 ; System . out . println ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; System . out . println ( minimumX ( n , k ) ) ; } }
public class GFG { static long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; } public static void main ( String [ ] args ) { long a = 10123465234878998L ; long b = 65746311545646431L ; long m = 10005412336548794L ; System . out . print ( moduloMultiplication ( a , b , m ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { int MAX = ' Z ' - ' A ' + 1 ; int n ; int [ ] inDeg , outDeg , vis ; int [ ] [ ] nei ; boolean check ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { if ( vis [ i ] != 1 ) { return false ; } } int cnt = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( inDeg [ i ] != outDeg [ i ] ) { return false ; } } return true ; } void dfs ( int k ) { if ( vis [ k ] == 1 ) { return ; } vis [ k ] = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( 0 < nei [ k ] [ i ] ) { dfs ( i ) ; } } } void run ( ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { n = sc . nextInt ( ) ; if ( n == 0 ) { break ; } int s = 0 ; inDeg = new int [ MAX ] ; outDeg = new int [ MAX ] ; vis = new int [ MAX ] ; nei = new int [ MAX ] [ MAX ] ; Arrays . fill ( vis , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { char [ ] c = sc . next ( ) . toCharArray ( ) ; int u = c [ 0 ] - ' a ' ; int v = c [ c . length - 1 ] - ' a ' ; outDeg [ u ] ++ ; inDeg [ v ] ++ ; nei [ u ] [ v ] = 1 ; vis [ u ] = vis [ v ] = - 1 ; s = u ; } dfs ( s ) ; if ( check ( ) ) { System . out . println ( " OK " ) ; } else { System . out . println ( " NG " ) ; } } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
import java . util . Scanner ; import java . util . stream . IntStream ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int N = scan . nextInt ( ) ; int [ ] a = IntStream . range ( 0 , N ) . map ( i -> scan . nextInt ( ) ) . toArray ( ) ; int index = 0 ; for ( int i = 0 ; i < N ; ++ i ) if ( Math . abs ( a [ index ] ) < Math . abs ( a [ i ] ) ) index = i ; System . out . println ( 2 * N - 1 ) ; for ( int i = 0 ; i < N ; ++ i ) System . out . println ( ( index + 1 ) + " ▁ " + ( i + 1 ) ) ; if ( a [ index ] > 0 ) { for ( int i = 2 ; i <= N ; ++ i ) System . out . println ( ( i - 1 ) + " ▁ " + i ) ; } else { for ( int i = N - 1 ; i >= 1 ; -- i ) System . out . println ( ( i + 1 ) + " ▁ " + i ) ; } } }
import java . util . ArrayList ; public class GFG { static boolean checkPalindrome ( String str ) { int len = str . length ( ) ; len -- ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( len ) ) return false ; len -- ; } return true ; } static void printSolution ( ArrayList < ArrayList < String > > partitions ) { for ( ArrayList < String > i : partitions ) { for ( String j : i ) { System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; } } static ArrayList < ArrayList < String > > addStrings ( ArrayList < ArrayList < String > > v , String s , ArrayList < String > temp , int index ) { int len = s . length ( ) ; String str = " " ; ArrayList < String > current = new ArrayList < > ( temp ) ; if ( index == 0 ) temp . clear ( ) ; for ( int i = index ; i < len ; ++ i ) { str = str + s . charAt ( i ) ; if ( checkPalindrome ( str ) ) { temp . add ( str ) ; if ( i + 1 < len ) { v = addStrings ( v , s , temp , i + 1 ) ; } else { v . add ( temp ) ; } temp = new ArrayList < > ( current ) ; } } return v ; } static void partition ( String s , ArrayList < ArrayList < String > > v ) { ArrayList < String > temp = new ArrayList < > ( ) ; v = addStrings ( v , s , temp , 0 ) ; printSolution ( v ) ; } public static void main ( String args [ ] ) { String s = " geeks " ; ArrayList < ArrayList < String > > partitions = new ArrayList < > ( ) ; partition ( s , partitions ) ; } }
import java . util . * ; import java . math . * ; class Main { static final int M = 100000007 ; public static int comb ( int n , int c ) { BigInteger b = BigInteger . ONE ; for ( int i = 0 ; i < c ; i ++ ) { b = b . multiply ( new BigInteger ( String . valueOf ( n - i ) ) ) . divide ( new BigInteger ( String . valueOf ( i + 1 ) ) ) ; } return b . mod ( new BigInteger ( String . valueOf ( M ) ) ) . intValue ( ) ; } public static void main ( String [ ] Z ) { Scanner cin = new Scanner ( System . in ) ; int r = cin . nextInt ( ) , c = cin . nextInt ( ) , a1 = cin . nextInt ( ) , a2 = cin . nextInt ( ) , b1 = cin . nextInt ( ) , b2 = cin . nextInt ( ) ; int x = Math . abs ( a1 - b1 ) , y = Math . abs ( a2 - b2 ) ; x = Math . min ( x , r - x ) ; y = Math . min ( y , c - y ) ; int z = 1 ; if ( x == r - x ) z *= 2 ; if ( y == c - y ) z *= 2 ; System . out . println ( z * comb ( x + y , Math . min ( x , y ) ) % M ) ; } }
import java . util . * ; public class GFG { static void findSubsequence ( int [ ] arr , int n , int k ) { HashMap < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( M . containsKey ( arr [ i ] ) ) M . put ( arr [ i ] , M . get ( arr [ i ] ) + 1 ) ; else M . put ( arr [ i ] , 1 ) ; } int [ ] numCount = new int [ k + 1 ] ; for ( int i = 0 ; i <= k ; ++ i ) numCount [ i ] = 0 ; Iterator < HashMap . Entry < Integer , Integer > > itr = M . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { HashMap . Entry < Integer , Integer > entry = itr . next ( ) ; if ( entry . getKey ( ) <= k ) { for ( int i = 1 ; ; ++ i ) { if ( entry . getKey ( ) * i > k ) break ; numCount [ entry . getKey ( ) * i ] += entry . getValue ( ) ; } } else break ; } int lcm = 0 , length = 0 ; for ( int i = 1 ; i <= k ; ++ i ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) System . out . println ( - 1 ) ; else { System . out . println ( " LCM ▁ = ▁ " + lcm + " , ▁ Length ▁ = ▁ " + length ) ; System . out . print ( " Indexes ▁ = ▁ " ) ; for ( int i = 0 ; i < n ; ++ i ) if ( lcm % arr [ i ] == 0 ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int k = 14 ; int arr [ ] = { 2 , 3 , 4 , 5 } ; int n = arr . length ; findSubsequence ( arr , n , k ) ; } }
import java . io . * ; public class GFG { static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = a . length ; int m = b . length ; System . out . println ( count_pairs ( a , b , n , m ) ) ; } }
public class GFG { static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; } public static void main ( String [ ] args ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = a . length ; int m = b . length ; System . out . println ( count_pairs ( a , b , n , m ) ) ; } }
class MaximumDiffrence { int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int min_element = arr [ 0 ] ; int i ; for ( i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] - min_element > max_diff ) max_diff = arr [ i ] - min_element ; if ( arr [ i ] < min_element ) min_element = arr [ i ] ; } return max_diff ; } public static void main ( String [ ] args ) { MaximumDiffrence maxdif = new MaximumDiffrence ( ) ; int arr [ ] = { 1 , 2 , 6 , 80 , 100 } ; int size = arr . length ; System . out . println ( " Maximum ▁ difference ▁ is ▁ " + maxdif . maxDiff ( arr , size ) ) ; } }
public class GFG { static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static int findMax ( int n ) { return binomialCoeff ( n , n / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( findMax ( n ) ) ; } }
public class GFG { final static int MAX = 26 ; static int max_element ( int freq [ ] ) { int max_ele = freq [ 0 ] ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max_ele < freq [ i ] ) max_ele = freq [ i ] ; } return max_ele ; } static int minimumAddition ( String str , int len ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int maxFreq = max_element ( freq ) ; int minAddition = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 0 ) { minAddition += Math . abs ( maxFreq - freq [ i ] ) ; } } return minAddition ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; System . out . println ( minimumAddition ( str , len ) ) ; } }
import java . util . Scanner ; public class test195 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; char a [ ] = in . next ( ) . toCharArray ( ) ; char b [ ] = in . next ( ) . toCharArray ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( a [ i ] - b [ i ] ) > 5 ) { sum += 10 - Math . abs ( a [ i ] - b [ i ] ) ; } else { sum += Math . abs ( a [ i ] - b [ i ] ) ; } } System . out . println ( sum ) ; in . close ( ) ; } }
import java . util . * ; public class GFG { static final int MAX = 32 ; static long [ ] pow2 = new long [ MAX ] ; static boolean [ ] visited = new boolean [ MAX ] ; static Vector < Long > ans = new Vector < > ( ) ; static void power_2 ( ) { long ans = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = ans ; ans *= 2 ; } } static int countSetBits ( long x ) { int setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; } static void add ( long num ) { int point = 0 ; long value = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( visited [ i ] ) continue ; else { if ( num % 2 == 1 ) { value += ( 1 << i ) ; } num /= 2 ; } } ans . add ( value ) ; } static void solve ( long n , long k ) { ans . add ( k ) ; int countk = countSetBits ( k ) ; if ( pow2 [ countk ] < n ) { System . out . print ( - 1 ) ; return ; } int count = 0 ; for ( long i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( count == n ) break ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { long n = 3 , k = 5 ; power_2 ( ) ; solve ( n , k ) ; } }
public final class p027 { public static void main ( String [ ] args ) { System . out . println ( new p027 ( ) . run ( ) ) ; } public String run ( ) { int bestNum = 0 ; int bestA = 0 ; int bestB = 0 ; for ( int a = - 1000 ; a <= 1000 ; a ++ ) { for ( int b = - 1000 ; b <= 1000 ; b ++ ) { int num = numberOfConsecutivePrimesGenerated ( a , b ) ; if ( num > bestNum ) { bestNum = num ; bestA = a ; bestB = b ; } } } return Integer . toString ( bestA * bestB ) ; } private static int numberOfConsecutivePrimesGenerated ( int a , int b ) { for ( int i = 0 ; ; i ++ ) { int n = i * i + i * a + b ; if ( n < 0 || ! Library . isPrime ( n ) ) return i ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; import java . util . * ; import static java . lang . System . out ; import static java . lang . Math . * ; public class pre149 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; int tc = obj . nextInt ( ) ; while ( tc -- != 0 ) { long n = obj . nextInt ( ) , k = obj . nextInt ( ) ; if ( n > k ) { out . println ( ( k * ( k + 1 ) ) / 2 ) ; } else { n -- ; n = ( n * ( n + 1 ) ) / 2 ; n ++ ; out . println ( n ) ; } } } }
import java . io . * ; public class GFG { static int MAX = 100001 ; static int [ ] isPrime = new int [ MAX ] ; static int sieve ( ) { for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == 0 ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = 1 ; } } return - 1 ; } static int findSubset ( int [ ] a , int n ) { int cnt1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) cnt1 ++ ; if ( cnt1 > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] != 1 ) && ( isPrime [ a [ i ] + 1 ] == 0 ) ) { System . out . println ( cnt1 + 1 ) ; for ( int j = 0 ; j < cnt1 ; j ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . println ( a [ i ] ) ; return 0 ; } } } if ( cnt1 >= 2 ) { System . out . println ( cnt1 ) ; for ( int i = 0 ; i < cnt1 ; i ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . println ( ) ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) { System . out . println ( 2 ) ; System . out . println ( a [ i ] + " ▁ " + a [ j ] ) ; return 0 ; } } } System . out . println ( - 1 ) ; return - 1 ; } public static void main ( String args [ ] ) { sieve ( ) ; int [ ] A = new int [ ] { 2 , 1 , 1 } ; int n = A . length ; findSubset ( A , n ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n , r , t , sum , pos ; n = scan . nextInt ( ) ; r = scan . nextInt ( ) ; t = scan . nextInt ( ) ; sum = 0 ; int [ ] p = new int [ n ] ; int [ ] water = new int [ r ] ; int [ ] empty = new int [ r ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = scan . nextInt ( ) ; } for ( int i = 1 ; i <= t ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { pos = ( p [ j ] * i % r ) ; if ( i > 1 ) { empty [ pos ] ++ ; } if ( water [ pos ] > 0 ) { water [ pos ] -- ; } else { sum ++ ; } } for ( int j = 0 ; j < r ; j ++ ) { if ( empty [ j ] > 0 ) { water [ j ] += empty [ j ] ; empty [ j ] = 0 ; } } } System . out . println ( sum ) ; scan . close ( ) ; } }
import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; s . nextLine ( ) ; for ( int j = 0 ; j < n ; j ++ ) { char c [ ] = s . nextLine ( ) . toCharArray ( ) ; for ( int i = 0 ; i < c . length - 6 ; i ++ ) { if ( c [ i ] == ' H ' && c [ i + 1 ] == ' o ' && c [ i + 2 ] == ' s ' && c [ i + 3 ] == ' h ' && c [ i + 4 ] == ' i ' && c [ i + 5 ] == ' n ' && c [ i + 6 ] == ' o ' ) { c [ i + 6 ] = ' a ' ; i += 6 ; } } System . out . println ( new String ( c ) ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; class BinarySearch { static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = arr . length ; System . out . println ( countRotations ( arr , 0 , n - 1 ) ) ; } }
import java . util . * ; public class main { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int n = scn . nextInt ( ) ; int k = scn . nextInt ( ) ; int i = 1 , req = 1 ; while ( k - req >= 0 ) { if ( k - req >= 0 ) { k = k - req ; } else { break ; } i ++ ; if ( i % n != 0 ) req = i % n ; else req = n ; } System . out . println ( k ) ; } }
import java . util . Arrays ; public class GFG { static boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } public static void main ( String arg [ ] ) { int arr [ ] = { 1 , 7 } ; int n = arr . length ; int m = 5 ; if ( modularSum ( arr , n , m ) ) System . out . print ( " YES \n " ) ; else System . out . print ( " NO \n " ) ; } }
import java . util . * ; import java . lang . Math . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int b = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int res = 0 ; for ( int j = b ; j < e ; j ++ ) if ( a [ j ] == k ) res ++ ; System . out . println ( res ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long x = sc . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ n ] ; long [ ] totals = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ 0 ] [ i ] = sc . nextInt ( ) ; totals [ 0 ] += arr [ 0 ] [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = Math . min ( arr [ i - 1 ] [ j ] , arr [ i - 1 ] [ ( j - 1 + n ) % n ] ) ; totals [ i ] += arr [ i ] [ j ] ; } totals [ i ] += x * i ; } Arrays . sort ( totals ) ; System . out . println ( totals [ 0 ] ) ; } }
import java . util . * ; public class Main { static int max , d , w ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; while ( true ) { d = in . nextInt ( ) ; w = in . nextInt ( ) ; if ( d == 0 ) break ; int G [ ] [ ] = new int [ d ] [ w ] ; max = 0 ; for ( int i = 0 ; i < d ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) G [ i ] [ j ] = Integer . parseInt ( in . next ( ) ) ; } for ( int i = 0 ; i <= d - 3 ; i ++ ) { for ( int j = 0 ; j <= w - 3 ; j ++ ) solve ( G , i , j , 3 , 3 ) ; } System . out . println ( max ) ; } } static void solve ( int [ ] [ ] A , int y , int x , int dep , int wid ) { if ( y + dep > d || x + wid > w ) return ; int edgmin = 9 , lkmax = 0 , maxv = 0 ; for ( int i = y ; i < dep + y ; i ++ ) { for ( int j = x ; j < wid + x ; j ++ ) { if ( i == y || i == dep + y - 1 || j == x || j == wid + x - 1 ) edgmin = Math . min ( edgmin , A [ i ] [ j ] ) ; else { lkmax = Math . max ( lkmax , A [ i ] [ j ] ) ; } } } if ( edgmin > lkmax ) { for ( int i = y + 1 ; i < dep + y - 1 ; i ++ ) { for ( int j = x + 1 ; j < x + wid - 1 ; j ++ ) maxv += edgmin - A [ i ] [ j ] ; } } max = Math . max ( max , maxv ) ; solve ( A , y , x , dep + 1 , wid ) ; solve ( A , y , x , dep , wid + 1 ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long k = sc . nextLong ( ) ; long arr [ ] = new long [ ( int ) n ] ; for ( long i = 0 ; i < ( int ) n ; ++ i ) { arr [ ( int ) i ] = sc . nextLong ( ) ; } if ( k == 1 ) { System . out . println ( n ) ; System . exit ( 0 ) ; } long ans [ ] = new long [ ( int ) n ] ; Arrays . sort ( arr ) ; for ( long i = 0 ; i < ( int ) n ; ++ i ) { if ( ans [ ( int ) i ] == 0 ) { long ktimes = k * arr [ ( int ) i ] ; long index = Arrays . binarySearch ( arr , ktimes ) ; if ( index >= 0 ) { ans [ ( int ) index ] = - 1 ; } } } long ans1 = 0 ; for ( long i = 0 ; i < n ; ++ i ) { if ( ans [ ( int ) i ] == 0 ) { ++ ans1 ; } } System . out . println ( ans1 ) ; } }
public class GFG { static int sum ( int k , int n ) { int sum = ( int ) ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; } public static void main ( String args [ ] ) { int n = 3 ; int K = 3 ; System . out . print ( sum ( K , n ) ) ; } }
public class GFG { static long dp [ ] [ ] [ ] = new long [ 18 ] [ 2 ] [ 162 ] ; static long solve ( int i , boolean tight , int sum_so_far , int Sum , String number , int len ) { if ( i == len ) { if ( sum_so_far == Sum ) return 1 ; else return 0 ; } long ans = dp [ i ] [ 1 ] [ sum_so_far ] ; if ( ans != - 1 ) { return ans ; } ans = 0 ; boolean ntight ; int nsum_so_far ; for ( char currdigit = '0' ; currdigit <= '9' ; currdigit ++ ) { if ( ! tight && currdigit > number . charAt ( i ) ) { break ; } ntight = tight || currdigit < number . charAt ( i ) ; nsum_so_far = sum_so_far + ( currdigit - '0' ) ; ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , len ) ; } return ans ; } public static void main ( String [ ] args ) { long count = 0 ; int sum = 4 ; String number = "100" ; for ( int i = 0 ; i < 18 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( int k = 0 ; k < 162 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; } } System . out . println ( solve ( 0 , false , 0 , sum , number , number . length ( ) ) ) ; } }
import java . util . Scanner ; public class FriendsDecision { static int count = 0 ; public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; sc . nextLine ( ) ; String [ ] arr = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextLine ( ) ; decision ( arr [ i ] ) ; } System . out . println ( count ) ; } private static void decision ( String entery ) { int localct = 0 ; String [ ] inputs = entery . split ( " ▁ " ) ; for ( int i = 0 ; i < inputs . length ; i ++ ) { if ( inputs [ i ] . equals ( "1" ) ) localct ++ ; } if ( localct > 1 ) count ++ ; } }
import java . io . * ; import java . util . * ; class Node { int data ; Node left , right ; Node ( int key ) { data = key ; left = right = null ; } } public class GFG { static int evenOddLevelDifference ( Node root ) { if ( root == null ) return 0 ; Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; int level = 0 ; int evenSum = 0 , oddSum = 0 ; while ( q . size ( ) != 0 ) { int size = q . size ( ) ; level ++ ; while ( size > 0 ) { Node temp = q . remove ( ) ; if ( level % 2 == 0 ) evenSum += temp . data ; else oddSum += temp . data ; if ( temp . left != null ) q . add ( temp . left ) ; if ( temp . right != null ) q . add ( temp . right ) ; size -- ; } } return ( oddSum - evenSum ) ; } public static void main ( String args [ ] ) { Node root = new Node ( 5 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 6 ) ; root . left . left = new Node ( 1 ) ; root . left . right = new Node ( 4 ) ; root . left . right . left = new Node ( 3 ) ; root . right . right = new Node ( 8 ) ; root . right . right . right = new Node ( 9 ) ; root . right . right . left = new Node ( 7 ) ; System . out . println ( " Difference ▁ between ▁ sums ▁ is ▁ " + evenOddLevelDifference ( root ) ) ; } }
import java . io . * ; public class GFG { static int countSubarrays ( int a [ ] , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { count += 1 ; } else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( count != 0 ) number += ( count ) * ( count + 1 ) / 2 ; return number ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 } ; int n = a . length ; int k = 5 ; System . out . println ( countSubarrays ( a , n , k ) ) ; } }
public class GFG { static int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 3 , 1 , 5 } ; int n = arr . length ; System . out . println ( minCost ( arr , n ) ) ; } }
import java . util . * ; public class GFG { public static void printLastOccurrence ( int a [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map . put ( a [ i ] , i ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . get ( a [ i ] ) == i ) System . out . print ( a [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 5 , 5 , 1 , 6 , 1 } ; int n = a . length ; printLastOccurrence ( a , n ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) { return ; } int up1 = 0 , up2 = 0 ; int [ ] k = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { k [ i ] = sc . nextInt ( ) ; if ( k [ i ] > 0 ) { up1 ++ ; if ( k [ i ] >= 2 ) { up2 ++ ; } } } if ( up2 == 0 ) { System . out . println ( " NA " ) ; } else { System . out . println ( up1 + 1 ) ; } } } }
import java . lang . * ; import java . util . * ; public class GFG { public int countPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; } public static void main ( String args [ ] ) { GFG g = new GFG ( ) ; int n = 5 , m = 5 ; System . out . println ( g . countPaths ( n , m ) ) ; } }
public class GFG { static float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; } public static void main ( String [ ] args ) { float n = 20 ; float a = 2.5f , d = 1.5f ; System . out . print ( sumOfAP ( a , d , n ) ) ; } }
import java . util . * ; class solution { static long countPairs ( int arr [ ] , int n ) { long count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) count ++ ; } } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 0 , 3 , 1 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static void coordinateCompression ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; } int index = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int itr : s ) { index ++ ; mp . put ( itr , index ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = mp . get ( arr [ i ] ) ; } } static int query ( int BIT [ ] , int index , int n ) { int ans = 0 ; while ( index > 0 ) { ans = Math . max ( ans , BIT [ index ] ) ; index -= index & ( - index ) ; } return ans ; } static void update ( int BIT [ ] , int index , int n ) { int x = query ( BIT , index - 1 , n ) ; int value = x + 1 ; while ( index <= n ) { BIT [ index ] = Math . max ( BIT [ index ] , value ) ; index += index & ( - index ) ; } } static int findLISLength ( int arr [ ] , int n ) { coordinateCompression ( arr , n ) ; int [ ] BIT = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { BIT [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { update ( BIT , arr [ i ] , n ) ; } int ans = query ( BIT , n , n ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 } ; int n = arr . length ; int ans = findLISLength ( arr , n ) ; System . out . println ( ans ) ; } }
import java . io . * ; import java . util . * ; public class Groups { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int Q = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < Q ; i ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; int [ ] [ ] schedule = new int [ N ] [ 5 ] ; int x = 0 ; for ( int j = 0 ; j < N ; j ++ ) { String line = br . readLine ( ) ; StringTokenizer sr = new StringTokenizer ( line ) ; for ( int k = 0 ; k < 5 ; k ++ ) { schedule [ x ] [ k ] = Integer . parseInt ( sr . nextToken ( ) ) ; } x ++ ; } boolean check = false ; outer : for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = j + 1 ; k < 5 ; k ++ ) { int day1count = 0 ; int day2count = 0 ; int bothcount = 0 ; int neither = 0 ; for ( int l = 0 ; l < schedule . length ; l ++ ) { if ( schedule [ l ] [ j ] == 0 && schedule [ l ] [ k ] == 0 ) { neither ++ ; } if ( schedule [ l ] [ j ] == 1 && schedule [ l ] [ k ] == 0 ) { day1count ++ ; } else if ( schedule [ l ] [ j ] == 0 && schedule [ l ] [ k ] == 1 ) { day2count ++ ; } else if ( schedule [ l ] [ j ] == 1 && schedule [ l ] [ k ] == 1 ) { bothcount ++ ; } } if ( neither > 0 ) { continue ; } else if ( day1count > schedule . length / 2 || day2count > schedule . length / 2 ) { continue ; } else { check = true ; break outer ; } } } System . out . println ( check ? " YES " : " NO " ) ; } } }
import java . math . BigInteger ; public final class p164 { public static void main ( String [ ] args ) { System . out . println ( new p164 ( ) . run ( ) ) ; } private static final int BASE = 10 ; private static final int DIGITS = 20 ; private static final int CONSECUTIVE = 3 ; private static final int MAX_SUM = 9 ; public String run ( ) { BigInteger [ ] [ ] ways = new BigInteger [ DIGITS + CONSECUTIVE + 1 ] [ Library . pow ( BASE , CONSECUTIVE ) ] ; ways [ 0 ] [ 0 ] = BigInteger . ONE ; for ( int prefix = 1 ; prefix < ways [ 0 ] . length ; prefix ++ ) ways [ 0 ] [ prefix ] = BigInteger . ZERO ; for ( int digits = 1 ; digits < ways . length ; digits ++ ) { for ( int prefix = 0 ; prefix < ways [ digits ] . length ; prefix ++ ) { BigInteger sum = BigInteger . ZERO ; if ( digitSum ( prefix ) <= MAX_SUM ) { for ( int nextDigit = 0 ; nextDigit < BASE ; nextDigit ++ ) sum = sum . add ( ways [ digits - 1 ] [ prefix % Library . pow ( BASE , CONSECUTIVE - 1 ) * BASE + nextDigit ] ) ; } ways [ digits ] [ prefix ] = sum ; } } return ways [ DIGITS + CONSECUTIVE ] [ 0 ] . subtract ( ways [ DIGITS + CONSECUTIVE - 1 ] [ 0 ] ) . toString ( ) ; } private static int digitSum ( int n ) { int sum = 0 ; for ( ; n != 0 ; n /= 10 ) sum += n % 10 ; return sum ; } }
import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . IllegalFormatCodePointException ; import java . util . Scanner ; public class Main { static ArrayList md = new ArrayList ( ) ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String [ ] l = new String [ 4 ] ; l [ 0 ] = in . next ( ) ; l [ 1 ] = in . next ( ) ; l [ 2 ] = in . next ( ) ; l [ 3 ] = in . next ( ) ; char a ; boolean f = false ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { a = l [ i ] . charAt ( j ) ; if ( l [ i ] . charAt ( j + 1 ) == a ) { if ( l [ i + 1 ] . charAt ( j ) == a || l [ i + 1 ] . charAt ( j + 1 ) == a ) { f = true ; break ; } else if ( i > 0 && ( l [ i - 1 ] . charAt ( j ) == a || l [ i - 1 ] . charAt ( j + 1 ) == a ) ) { f = true ; break ; } else f = false ; } if ( l [ 3 ] . charAt ( j ) == l [ 3 ] . charAt ( j + 1 ) && ( l [ 2 ] . charAt ( j ) == l [ 3 ] . charAt ( j ) || l [ 2 ] . charAt ( j + 1 ) == l [ 3 ] . charAt ( j + 1 ) ) ) { f = true ; break ; } } if ( f == true ) { break ; } } if ( f == true ) { System . out . println ( " YES " ) ; } else System . out . println ( " NO " ) ; } }
class Solution { public boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { for ( int r = 1 ; r < matrix . length ; ++ r ) for ( int c = 1 ; c < matrix [ 0 ] . length ; ++ c ) if ( matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] ) return false ; return true ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 } , { 5 , 1 , 2 , 3 } , { 9 , 5 , 1 , 2 } } ; boolean out = sObj . isToeplitzMatrix ( matrix ) ; System . out . println ( out ) ; } }
public final class p094 { public static void main ( String [ ] args ) { System . out . println ( new p094 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 9 ) ; public String run ( ) { long sum = 0 ; for ( int s = 1 ; s * s <= ( LIMIT + 1 ) / 3 ; s += 2 ) { for ( int t = s - 2 ; t > 0 ; t -= 2 ) { if ( Library . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( a * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } } } } return Long . toString ( sum ) ; } }
import java . util . * ; class Main { void solve ( ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int N = sc . nextInt ( ) ; int T = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; if ( N == 0 && T == 0 && L == 0 && B == 0 ) break ; int [ ] square = new int [ N + 1 ] ; for ( int i = 0 ; i < L ; i ++ ) square [ sc . nextInt ( ) ] = 1 ; for ( int i = 0 ; i < B ; i ++ ) square [ sc . nextInt ( ) ] = 2 ; double [ ] [ ] dp = new double [ N + 1 ] [ T + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int j = 0 ; j < T ; j ++ ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int s = 1 ; s <= 6 ; s ++ ) { int idx = 1 ; int num = i + s ; if ( square [ i ] == 1 ) idx = 2 ; if ( i + s > N ) num = 2 * N - ( i + s ) ; if ( square [ num ] == 2 && j + idx <= T ) { dp [ 0 ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 ; } else if ( j + idx <= T ) { dp [ num ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 ; } } } } double goal = 0.0 ; for ( int i = 0 ; i <= T ; i ++ ) goal += dp [ N ] [ i ] ; System . out . printf ( " % .6f \n " , goal ) ; } } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } }
import java . util . Scanner ; public class oddsum { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int s = 0 ; int o = 0 ; int e = 0 ; int a = in . nextInt ( ) ; int x ; for ( int i = 0 ; i < a ; i ++ ) { x = in . nextInt ( ) ; s += x ; if ( x % 2 != 0 ) { o ++ ; } else e ++ ; } if ( s % 2 != 0 ) { System . out . println ( " YES " ) ; } else { if ( o >= 1 && e >= 1 ) System . out . println ( " YES " ) ; else { System . out . println ( " NO " ) ; } } } } }
public class GFG { static int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; } public static void main ( String [ ] args ) { int [ ] H = new int [ ] { 2 , 4 , 8 , 16 } ; int K = 3 ; int n = H . length ; System . out . println ( minInsertions ( H , n , K ) ) ; } }
public class GFG { static int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; } public static void main ( String args [ ] ) { String str = " abc " ; int len = str . length ( ) ; System . out . println ( countWords ( str , len ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . * ; public class evenSum { static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static PrintWriter pw = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) throws IOException , InterruptedException { int n = Integer . parseInt ( br . readLine ( ) + " " ) ; long max = 0 ; String s = br . readLine ( ) ; String [ ] x = s . split ( " ▁ " ) ; ArrayList < Integer > even = new ArrayList < Integer > ( n ) ; ArrayList < Integer > odd = new ArrayList < Integer > ( n ) ; while ( n -- > 0 ) { int y = Integer . parseInt ( x [ n ] ) ; if ( y % 2 == 0 ) even . add ( y ) ; else odd . add ( y ) ; } for ( int i = 0 ; i < even . size ( ) ; i ++ ) max += even . get ( i ) ; int [ ] odd2 = new int [ odd . size ( ) ] ; for ( int i = 0 ; i < odd . size ( ) ; i ++ ) odd2 [ i ] = odd . get ( i ) ; Arrays . sort ( odd2 ) ; for ( int i = odd2 . length - 1 ; i > 0 ; i -- ) max += odd2 [ i ] ; if ( odd2 . length % 2 == 0 && odd2 . length > 0 ) max += odd2 [ 0 ] ; pw . println ( max ) ; pw . close ( ) ; } }
import java . util . * ; public class GFG { public static ArrayList < Integer > getPerfectSquares ( int n ) { ArrayList < Integer > perfectSquares = new ArrayList < > ( ) ; int current = 1 , i = 1 ; while ( current <= n ) { perfectSquares . add ( current ) ; current = ( int ) Math . pow ( ++ i , 2 ) ; } return perfectSquares ; } public static int maxPairSum ( int arr [ ] ) { int n = arr . length ; int max , secondMax ; if ( arr [ 0 ] > arr [ 1 ] ) { max = arr [ 0 ] ; secondMax = arr [ 1 ] ; } else { max = arr [ 1 ] ; secondMax = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return ( max + secondMax ) ; } public static int countPairsWith ( int n , ArrayList < Integer > perfectSquares , HashSet < Integer > nums ) { int count = 0 ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int temp = perfectSquares . get ( i ) - n ; if ( temp > n && nums . contains ( temp ) ) count ++ ; } return count ; } public static int countPairs ( int arr [ ] ) { int i , n = arr . length ; int max = maxPairSum ( arr ) ; ArrayList < Integer > perfectSquares = getPerfectSquares ( max ) ; HashSet < Integer > nums = new HashSet < > ( ) ; for ( i = 0 ; i < n ; i ++ ) nums . add ( arr [ i ] ) ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) { count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 6 , 9 , 10 , 20 } ; System . out . println ( countPairs ( arr ) ) ; } }
public class GFG { static double findHypotenuse ( double side1 , double side2 ) { double h = Math . sqrt ( ( side1 * side1 ) + ( side2 * side2 ) ) ; return h ; } public static void main ( String s [ ] ) { int side1 = 3 , side2 = 4 ; System . out . printf ( " % .2f " , findHypotenuse ( side1 , side2 ) ) ; } }
import java . util . * ; class Main { static void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ; } }
import java . util . Scanner ; public class StroneGame { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t > 0 ) { int n = sc . nextInt ( ) ; int [ ] ar = new int [ n ] ; int max = 0 ; int min = 100000 ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = sc . nextInt ( ) ; if ( ar [ i ] < min ) { min = ar [ i ] ; x = i + 1 ; } if ( ar [ i ] > max ) { max = ar [ i ] ; y = i + 1 ; } } int pos1 , pos2 = 1 , pos3 , pos4 = 1 , a , b , mm , total = 0 ; pos1 = x ; pos2 += n - x ; if ( pos1 < pos2 ) { a = pos1 ; } else { a = pos2 ; } pos3 = y ; pos4 += n - y ; if ( pos3 < pos4 ) { b = pos3 ; } else { b = pos4 ; } int div = Math . abs ( y - x ) ; if ( div < a || div < b ) { mm = Math . min ( a , b ) ; total += mm + div ; } else { total += a + b ; } System . out . println ( total ) ; t -- ; } } }
import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Throwable { Scanner sc = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; String first = sc . next ( ) ; String second = sc . next ( ) ; HashMap < String , Integer > map = new HashMap < > ( ) ; map . put ( " monday " , 1 ) ; map . put ( " tuesday " , 2 ) ; map . put ( " wednesday " , 3 ) ; map . put ( " thursday " , 4 ) ; map . put ( " friday " , 5 ) ; map . put ( " saturday " , 6 ) ; map . put ( " sunday " , 7 ) ; int diff = 0 ; if ( map . get ( second ) >= map . get ( first ) ) diff = map . get ( second ) - map . get ( first ) ; else diff = 7 - map . get ( first ) + map . get ( second ) ; boolean ok = diff == 0 || diff == 2 || diff == 3 ; out . println ( ok ? " YES " : " NO " ) ; out . flush ( ) ; out . close ( ) ; } static class Scanner { StringTokenizer st ; BufferedReader br ; public Scanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public String nextLine ( ) throws IOException { return br . readLine ( ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; boolean f = false ; boolean s = false ; int ind = 0 ; String [ ] x = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . next ( ) ; if ( f == false ) { if ( x [ i ] . contains ( " OO " ) ) { f = true ; ind = i ; } } } if ( f == true ) { System . out . println ( " YES " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != ind ) { System . out . println ( x [ i ] ) ; } else { if ( x [ i ] . substring ( 0 , 2 ) . equals ( " OO " ) ) { System . out . print ( " + + " + x [ i ] . substring ( 2 , 5 ) + " \n " ) ; } else if ( x [ i ] . substring ( 3 , 5 ) . equals ( " OO " ) ) System . out . print ( x [ i ] . substring ( 0 , 3 ) + " + + " + " \n " ) ; } } } else System . out . println ( " NO " ) ; } }
public class GFG { static class Node { int data ; Node next ; Node ( int x ) { data = x ; next = null ; } } ; static void printList ( Node head ) { if ( head == null ) return ; Node temp = head ; do { System . out . print ( temp . data + " - > " ) ; temp = temp . next ; } while ( temp != head ) ; System . out . println ( head . data ) ; } static Node deleteK ( Node head_ref , int k ) { Node head = head_ref ; if ( head == null ) return null ; Node curr = head , prev = null ; while ( true ) { if ( curr . next == head && curr == head ) break ; printList ( head ) ; for ( int i = 0 ; i < k ; i ++ ) { prev = curr ; curr = curr . next ; } if ( curr == head ) { prev = head ; while ( prev . next != head ) prev = prev . next ; head = curr . next ; prev . next = head ; head_ref = head ; } else if ( curr . next == head ) { prev . next = head ; } else { prev . next = curr . next ; } } return head ; } static Node insertNode ( Node head_ref , int x ) { Node head = head_ref ; Node temp = new Node ( x ) ; if ( head == null ) { temp . next = temp ; head_ref = temp ; return head_ref ; } else { Node temp1 = head ; while ( temp1 . next != head ) temp1 = temp1 . next ; temp1 . next = temp ; temp . next = head ; } return head ; } public static void main ( String args [ ] ) { Node head = null ; head = insertNode ( head , 1 ) ; head = insertNode ( head , 2 ) ; head = insertNode ( head , 3 ) ; head = insertNode ( head , 4 ) ; head = insertNode ( head , 5 ) ; head = insertNode ( head , 6 ) ; head = insertNode ( head , 7 ) ; head = insertNode ( head , 8 ) ; head = insertNode ( head , 9 ) ; int k = 4 ; head = deleteK ( head , k ) ; } }
public class GFG { static int steps ( int cur , int x , int n ) { if ( x == 0 ) return Integer . MAX_VALUE ; if ( x > 0 ) return Math . abs ( ( n - cur ) / x ) ; else return Math . abs ( ( cur - 1 ) / x ) ; } static int countSteps ( int curx , int cury , int n , int m , int [ ] [ ] moves ) { int count = 0 ; int k = moves . length ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i ] [ 0 ] ; int y = moves [ i ] [ 1 ] ; int stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 , x = 1 , y = 1 ; int [ ] [ ] moves = { { 1 , 1 } , { 1 , 1 } , { 0 , - 2 } } ; System . out . print ( countSteps ( x , y , n , m , moves ) ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class Main { static ArrayList md = new ArrayList ( ) ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int x1 = in . nextInt ( ) ; int x2 = in . nextInt ( ) ; int x3 = in . nextInt ( ) ; int point = Math . min ( x1 , Math . min ( x2 , x3 ) ) ; if ( ( x1 > x2 && x1 < x3 ) || ( x1 > x3 && x1 < x2 ) ) { point = x1 ; } else if ( ( x1 > x2 && x2 > x3 ) || ( x2 < x3 && x2 > x1 ) ) { point = x2 ; } else point = x3 ; int d = 0 ; d = ( Math . abs ( x1 - point ) + Math . abs ( x2 - point ) + Math . abs ( x3 - point ) ) ; System . out . println ( d ) ; } }
public class GFG { static int cntSubArr ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ? 1 : 0 ; } } return ans ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( cntSubArr ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static boolean isVowel ( char c ) { if ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) return true ; return false ; } static boolean isVowelPrime ( String str , int n ) { boolean [ ] prime = new boolean [ n ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < n ; i += p ) prime [ i ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) && ! prime [ i ] ) return false ; } return true ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; if ( isVowelPrime ( str , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; } public static void main ( String args [ ] ) { String str = "2553432" ; System . out . println ( minStepToDeleteString ( str ) ) ; } }
public class GFG { static final int limit = 10000000 ; static int [ ] position = new int [ limit + 1 ] ; static void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } } public static void main ( String [ ] args ) { sieve ( ) ; int n = 11 ; System . out . print ( position [ n ] ) ; } }
public class GFG { static final int DP_s = 9 ; static int getNumMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < len ; ++ i ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } public static void main ( String [ ] args ) { System . out . println ( getNumMonotone ( 10 ) ) ; } }
public class GFG { static final int DP_s = 9 ; static int getNumMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < len ; ++ i ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } public static void main ( String [ ] args ) { System . out . println ( getNumMonotone ( 10 ) ) ; } }
public class GFG { static int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 1 , 2 , 3 , 2 , 2 , 1 } , l = 1 , r = 1 ; int n = a . length ; System . out . println ( maxCost ( a , n , l , r ) ) ; } }
import java . util . Scanner ; public class B1680 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int R = in . nextInt ( ) ; int C = in . nextInt ( ) ; char [ ] [ ] A = new char [ R ] [ ] ; for ( int r = 0 ; r < R ; r ++ ) { A [ r ] = in . next ( ) . toCharArray ( ) ; } int r = - 1 ; int c = - 1 ; outer : for ( int rr = 0 ; rr < R ; rr ++ ) { for ( int cc = 0 ; cc < C ; cc ++ ) { if ( A [ rr ] [ cc ] == ' R ' ) { r = rr ; c = cc ; break outer ; } } } boolean ok = true ; for ( int rr = r + 1 ; rr < R ; rr ++ ) { for ( int cc = 0 ; cc < c ; cc ++ ) { if ( A [ rr ] [ cc ] == ' R ' ) { ok = false ; } } } System . out . println ( ok ? " YES " : " NO " ) ; } } }
class Test { static final double PI = Math . PI ; static double findArea ( int r ) { return PI * Math . pow ( r , 2 ) ; } public static void main ( String [ ] args ) { System . out . println ( " Area ▁ is ▁ " + findArea ( 5 ) ) ; } }
import java . io . * ; import java . util . * ; public class DmwS { static int [ ] below ; static boolean [ ] vis ; static long result ; static int K ; static LinkedList [ ] adj ; static int [ ] unis ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; K = sc . nextInt ( ) ; adj = new LinkedList [ N ] ; unis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { adj [ i ] = new LinkedList ( ) ; } for ( int i = 0 ; i < 2 * K ; i ++ ) { int town = sc . nextInt ( ) - 1 ; unis [ town ] ++ ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { int x = sc . nextInt ( ) - 1 ; int y = sc . nextInt ( ) - 1 ; adj [ x ] . add ( y ) ; adj [ y ] . add ( x ) ; } below = new int [ N ] ; vis = new boolean [ N ] ; dfs ( 0 ) ; System . out . println ( result ) ; } static void dfs ( int node ) { vis [ node ] = true ; below [ node ] = unis [ node ] ; for ( Integer adj : ( LinkedList < Integer > ) adj [ node ] ) { if ( vis [ adj ] ) continue ; dfs ( adj ) ; below [ node ] += below [ adj ] ; result += Math . min ( below [ adj ] , 2 * K - below [ adj ] ) ; } } }
import java . io . * ; import java . lang . * ; public class GFG { public static int nthTerm ( int N ) { return Math . abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int getHeight ( int X ) { return ( 2 * X ) ; } public static void main ( String [ ] args ) throws java . lang . Exception { int X = 35 ; System . out . println ( getHeight ( X ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class KPaths { static final int V = 4 ; int countwalks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; return count ; } public static void main ( String [ ] args ) throws java . lang . Exception { int graph [ ] [ ] = new int [ ] [ ] { { 0 , 1 , 1 , 1 } , { 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 } } ; int u = 0 , v = 3 , k = 2 ; KPaths p = new KPaths ( ) ; System . out . println ( p . countwalks ( graph , u , v , k ) ) ; } }
public class GFG { static long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; double x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return ( long ) ( Math . floor ( x ) + 1 ) ; } public static void main ( String [ ] args ) { System . out . print ( findDigits ( 4 , 16 ) + " \n " ) ; System . out . print ( findDigits ( 5 , 8 ) + " \n " ) ; System . out . print ( findDigits ( 12 , 16 ) + " \n " ) ; System . out . print ( findDigits ( 19 , 13 ) + " \n " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int q = in . nextInt ( ) ; init ( n ) ; for ( int i = 0 ; i < q ; i ++ ) { if ( in . nextInt ( ) == 0 ) { add ( in . nextInt ( ) , in . nextInt ( ) ) ; } else { System . out . println ( sum ( in . nextInt ( ) , in . nextInt ( ) ) ) ; } } } static int [ ] nodes ; static int size ; static void init ( int n ) { size = 1 ; while ( size < n ) size *= 2 ; nodes = new int [ size + 1 ] ; } static void add ( int target , int value ) { while ( target < nodes . length ) { nodes [ target ] += value ; target += target & ( - target ) ; } } static int sum ( int s , int t ) { return sum ( t ) - sum ( s - 1 ) ; } static int sum ( int t ) { int res = 0 ; while ( t > 0 ) { res += nodes [ t ] ; t -= t & ( - t ) ; } return res ; } }
import java . io . * ; import java . util . * ; public class Main { static Map < Long , Long > check = new HashMap < Long , Long > ( ) ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String buf ; String [ ] input ; long N ; N = Long . parseLong ( br . readLine ( ) ) ; System . out . println ( solve ( N ) ) ; } static long solve ( long n ) { long a , b ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; if ( check . containsKey ( n / 2 ) ) { a = check . get ( n / 2 ) ; } else { a = solve ( n / 2 ) % 1000000007 ; check . put ( n / 2 , a ) ; } if ( check . containsKey ( n / 2 - 1 ) ) { b = check . get ( n / 2 - 1 ) ; } else { b = solve ( n / 2 - 1 ) % 1000000007 ; check . put ( n / 2 - 1 , b ) ; } if ( n % 2 == 1 ) { return ( 2 * a + b ) % 1000000007 ; } else { return ( 2 * b + a ) % 1000000007 ; } } }
import java . util . Scanner ; public class Main { static int numerator ; static int denominator ; static int maxproduct ; static int parts ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { numerator = sc . nextInt ( ) ; denominator = sc . nextInt ( ) ; maxproduct = sc . nextInt ( ) ; parts = sc . nextInt ( ) ; if ( parts == 0 ) break ; int count = 0 ; count += Judge ( numerator , denominator , parts , 1 , 0 ) ; System . out . println ( count ) ; } } static int Judge ( int p , int q , int separate , int now_pro , int prev_deno ) { int count = 0 ; if ( p == 0 ) { count ++ ; } if ( separate <= 0 ) return count ; int deno = maxproduct / now_pro + 1 ; while ( separate * q < p * deno ) deno -- ; while ( p * deno >= q && prev_deno <= deno ) { int subtraction_deno = q * deno ; int subtraction_nume = p * deno - q ; if ( now_pro * deno <= maxproduct ) { count += Judge ( subtraction_nume , subtraction_deno , separate - 1 , now_pro * deno , deno ) ; } deno -- ; } return count ; } }
import java . io . * ; import java . util . Arrays ; public class GFG { static String s = " " ; static String ReverseString ( String s ) { char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < arr . length / 2 ; i ++ ) { char temp = arr [ i ] ; arr [ i ] = arr [ arr . length - i - 1 ] ; arr [ arr . length - i - 1 ] = temp ; } return new String ( arr ) ; } static void binary_conversion ( int m ) { while ( m != 0 ) { int tmp = m % 2 ; s += Integer . toString ( tmp ) ; m = ( int ) ( m / 2 ) ; } s = ReverseString ( s ) ; } static int find_character ( int n , int m , int i ) { binary_conversion ( m ) ; String s1 = " " ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < s . length ( ) ; y ++ ) { if ( s . charAt ( y ) == '1' ) s1 += "10" ; else s1 += "01" ; } s = s1 ; s1 = " " ; } return s . charAt ( i ) - '0' ; } public static void main ( String args [ ] ) { int m = 5 , n = 2 , i = 8 ; System . out . print ( find_character ( n , m , i ) ) ; } }
import java . util . * ; public class GFG { static int countSubsets ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < > ( ) ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ; even_count = us . size ( ) ; return ( int ) ( Math . pow ( 2 , even_count ) - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 } ; int n = arr . length ; System . out . println ( " Number ▁ of ▁ subsets ▁ = ▁ " + countSubsets ( arr , n ) ) ; } }
import java . util . * ; public class GFG { static int MAX = 1000 ; static int [ ] f = new int [ MAX ] ; static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = 0 ; if ( ( n & 1 ) != 0 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( ( n & 1 ) != 0 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; } public static void main ( String args [ ] ) { int a = 3 , b = 12 ; System . out . println ( findLCMFibonacci ( a , b ) ) ; } }
public class GFG { static int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = ( int ) Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; } public static void main ( String args [ ] ) { int n , w ; n = 3 ; w = 4 ; System . out . println ( findNumbers ( n , w ) ) ; } }
import java . util . * ; public class GFG { static Character findKthChar ( String s , int k ) { int len = s . length ( ) ; int i = 0 ; int total_len = 0 ; while ( i < len ) { if ( Character . isLetter ( s . charAt ( i ) ) ) { total_len ++ ; if ( total_len == k ) return s . charAt ( i ) ; i ++ ; } else { int n = 0 ; while ( i < len && ! Character . isLetter ( s . charAt ( i ) ) ) { n = n * 10 + ( s . charAt ( i ) - '0' ) ; i ++ ; } int next_total_len = total_len * n ; if ( k <= next_total_len ) { int pos = k % total_len ; if ( pos == 0 ) { pos = total_len ; } return findKthChar ( s , pos ) ; } else { total_len = next_total_len ; } } } return ' ▁ ' ; } public static void main ( String [ ] args ) { String s = " ab2c3" ; int k = 5 ; System . out . println ( findKthChar ( s , k ) ) ; } }
import java . io . * ; public class GFG { static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; } public static void main ( String args [ ] ) { String s = " abcde " ; System . out . println ( countNonEmptySubstr ( s ) ) ; } }