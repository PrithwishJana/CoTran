import math NEW_LINE def sieve_of_erastosthenes ( num ) : NEW_LINE INDENT input_list = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( num ) ] NEW_LINE input_list [ 0 ] = input_list [ 1 ] = False NEW_LINE input_list [ 2 ] = input_list [ 3 ] = input_list [ 5 ] = True NEW_LINE sqrt = math . sqrt ( num ) NEW_LINE for serial in range ( 3 , num , 2 ) : NEW_LINE INDENT if serial >= sqrt : NEW_LINE INDENT return input_list NEW_LINE DEDENT for s in range ( serial ** 2 , num , serial ) : NEW_LINE INDENT input_list [ s ] = False NEW_LINE DEDENT DEDENT DEDENT primeTable = sieve_of_erastosthenes ( 13 * ( 10 ** 5 ) ) NEW_LINE while True : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE if k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if primeTable [ k ] : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT i = k NEW_LINE while primeTable [ i ] is False : i += 1 NEW_LINE j = i - 1 NEW_LINE while primeTable [ j ] is False : j -= 1 NEW_LINE print ( i - j ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 ; NEW_LINE def countFreq ( str1 , freq , len1 ) : NEW_LINE INDENT for i in range ( len1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len1 ) : NEW_LINE INDENT count_odd = 0 ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT DEDENT if ( len1 % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 ; NEW_LINE odd_str += chr ( i + ord ( ' a ' ) ) ; NEW_LINE return odd_str ; NEW_LINE DEDENT DEDENT return odd_str ; NEW_LINE DEDENT def findPalindromicString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) ; NEW_LINE freq = [ 0 ] * MAX_CHAR ; NEW_LINE countFreq ( str1 , freq , len1 ) ; NEW_LINE if ( canMakePalindrome ( freq , len1 ) == False ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " ; NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) ; NEW_LINE front_str = " " ; NEW_LINE rear_str = " ▁ " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " ; NEW_LINE if ( freq [ i ] != 0 ) : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) ; NEW_LINE for j in range ( 1 , int ( freq [ i ] / 2 ) + 1 ) : NEW_LINE INDENT temp += ch ; NEW_LINE DEDENT front_str += temp ; NEW_LINE rear_str = temp + rear_str ; NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) ; NEW_LINE DEDENT str1 = " malayalam " ; NEW_LINE print ( findPalindromicString ( str1 ) ) ; NEW_LINE
import math NEW_LINE def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT def norm2 ( a , b ) : NEW_LINE INDENT return ( b . real - a . real ) ** 2 + ( b . imag - a . imag ) ** 2 NEW_LINE DEDENT def is_intersect ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT ta = cross ( p1 - p0 , p2 - p0 ) NEW_LINE tb = cross ( p1 - p0 , p3 - p0 ) NEW_LINE tc = cross ( p3 - p2 , p0 - p2 ) NEW_LINE td = cross ( p3 - p2 , p1 - p2 ) NEW_LINE if ta * tb < 0 and tc * td < 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def distance_option ( p0 , p1 , p2 ) : NEW_LINE INDENT nn = norm2 ( p0 , p1 ) NEW_LINE if 0 <= dot ( p1 - p0 , p2 - p0 ) <= nn : NEW_LINE INDENT return abs ( cross ( p1 - p0 , p2 - p0 ) ) / math . sqrt ( nn ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . sqrt ( min ( norm2 ( p0 , p2 ) , norm2 ( p1 , p2 ) ) ) NEW_LINE DEDENT DEDENT def distance ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT if is_intersect ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return min ( distance_option ( p0 , p1 , p2 ) , distance_option ( p0 , p1 , p3 ) , distance_option ( p2 , p3 , p0 ) , distance_option ( p2 , p3 , p1 ) ) NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for _ in [ 0 ] * q : NEW_LINE INDENT x_y = map ( int , input ( ) . split ( ) ) NEW_LINE p0 , p1 , p2 , p3 = [ x + y * 1j for x , y in zip ( * [ x_y ] * 2 ) ] NEW_LINE print ( " { : . 10f } " . format ( distance ( p0 , p1 , p2 , p3 ) ) ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 for i in range ( 9 ) ] NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( count9s ( "01809" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE print ( count9s ( "4189" ) ) NEW_LINE DEDENT
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = fastPow ( N , int ( K / 2 ) ) ; NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp ; NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( countWays ( N , K ) ) ; NEW_LINE
NUM = ( 0b0111111 , 0b0000110 , 0b1011011 , 0b1001111 , 0b1100110 , 0b1101101 , 0b1111101 , 0b0100111 , 0b1111111 , 0b1101111 , ) NEW_LINE while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == - 1 : break NEW_LINE current = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = NUM [ int ( input ( ) ) ] NEW_LINE print ( format ( current ^ num , ' b ' ) . zfill ( 7 ) ) NEW_LINE current = num NEW_LINE DEDENT DEDENT
MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product , i = 1 , 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " * " , i , " = " , N * i ) NEW_LINE return mul_table ( N , i + 1 ) NEW_LINE DEDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE
def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT n = 13 ; m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 ; m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 ; m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 ; m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE
def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE Len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ Len ] ) : NEW_LINE INDENT Len += 1 NEW_LINE lps [ i ] = Len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( Len != 0 ) : NEW_LINE INDENT Len = lps [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 : lps [ i ] ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : lps [ lps [ n - 1 ] - 1 ] ] ) NEW_LINE DEDENT DEDENT s = " fixprefixsuffix " NEW_LINE Longestsubstring ( s ) NEW_LINE
import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE
a = input ( ) . split ( ) NEW_LINE n = int ( a [ 0 ] ) NEW_LINE d = int ( a [ 1 ] ) NEW_LINE array = input ( ) . split ( ) NEW_LINE a = 0 NEW_LINE while a < n : NEW_LINE INDENT array [ a ] = int ( array [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT a = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if array [ i ] >= array [ i + 1 ] : NEW_LINE INDENT a += ( array [ i ] - array [ i + 1 ] ) // d + 1 NEW_LINE array [ i + 1 ] += ( ( array [ i ] - array [ i + 1 ] ) // d + 1 ) * d NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( a ) NEW_LINE
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input1 = num ; NEW_LINE count = 0 ; NEW_LINE factor = [ 0 ] * ( num + 1 ) ; NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT factor [ 2 ] = count ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 ; NEW_LINE DEDENT product = 1 ; NEW_LINE for i in range ( 0 , len ( factor ) ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i ; NEW_LINE DEDENT DEDENT if ( product == input1 ) : NEW_LINE INDENT print ( " Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT DEDENT checkIfPowerIsolated ( 12 ) ; NEW_LINE checkIfPowerIsolated ( 18 ) ; NEW_LINE checkIfPowerIsolated ( 35 ) ; NEW_LINE
s , a , c = list ( input ( ) ) , 1 , 0 NEW_LINE for x in s : NEW_LINE INDENT if x == ' A ' and a : a = 0 NEW_LINE elif x == ' Z ' and not a : a , c = 1 , c + 1 NEW_LINE DEDENT print ( ' AZ ' * c if c else - 1 ) NEW_LINE
from collections import defaultdict NEW_LINE from sys import stdin NEW_LINE input = stdin . buffer . readline NEW_LINE def func ( ) : NEW_LINE INDENT indices = defaultdict ( list ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT indices [ a [ i ] ] . append ( i ) NEW_LINE DEDENT for i in indices : NEW_LINE INDENT if len ( indices [ i ] ) < 2 : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( len ( indices [ i ] ) - 1 ) : NEW_LINE INDENT first = indices [ i ] [ j ] NEW_LINE second = indices [ i ] [ j + 1 ] NEW_LINE ans = max ( ans , n - second + first ) NEW_LINE DEDENT DEDENT print ( ans if ans else - 1 ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE func ( ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - 48 NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - 48 NEW_LINE summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = summ // 10 NEW_LINE result [ i_n1 + i_n2 ] = summ % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += chr ( result [ i ] + 48 ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT str1 = "1235421415454545454545454544" NEW_LINE str2 = "1714546546546545454544548544544545" NEW_LINE if ( ( str1 [ 0 ] == ' - ' or str2 [ 0 ] == ' - ' ) and ( str1 [ 0 ] != ' - ' or str2 [ 0 ] != ' - ' ) ) : NEW_LINE INDENT print ( " - " , end = ' ' ) NEW_LINE DEDENT if ( str1 [ 0 ] == ' - ' and str2 [ 0 ] != ' - ' ) : NEW_LINE INDENT str1 = str1 [ 1 : ] NEW_LINE DEDENT elif ( str1 [ 0 ] != ' - ' and str2 [ 0 ] == ' - ' ) : NEW_LINE INDENT str2 = str2 [ 1 : ] NEW_LINE DEDENT elif ( str1 [ 0 ] == ' - ' and str2 [ 0 ] == ' - ' ) : NEW_LINE INDENT str1 = str1 [ 1 : ] NEW_LINE str2 = str2 [ 1 : ] NEW_LINE DEDENT print ( multiply ( str1 , str2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE X = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE Y = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( ' Yes ' if sum ( Y ) <= sum ( X ) else ' No ' ) NEW_LINE
n_square , k_th = map ( int , input ( ) . split ( ) ) NEW_LINE slogan = input ( ) NEW_LINE if k_th - 1 < ( n_square - 1 ) - ( k_th - 1 ) : NEW_LINE INDENT while k_th - 1 > 0 : NEW_LINE INDENT k_th -= 1 NEW_LINE print ( " LEFT " ) NEW_LINE DEDENT for i in range ( n_square ) : NEW_LINE INDENT print ( f " PRINT ▁ { slogan [ i ] } " ) NEW_LINE if i != n_square - 1 : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT n_right = n_square - k_th NEW_LINE while n_right : NEW_LINE INDENT n_right -= 1 NEW_LINE print ( " RIGHT " ) NEW_LINE DEDENT for i in range ( n_square - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( f " PRINT ▁ { slogan [ i ] } " ) NEW_LINE if i != 0 : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE DEDENT DEDENT DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printDistSum ( arr , n ) NEW_LINE
def Subtract ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 2 , 3 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE a , b = 9 , 7 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE DEDENT
from cmd import IDENTCHARS NEW_LINE n = int ( input ( ) ) NEW_LINE l = 1 NEW_LINE r = n NEW_LINE while ( l < r ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE idxcnt = mid * ( mid + 1 ) / 2 NEW_LINE if ( idxcnt < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid NEW_LINE DEDENT DEDENT l -= 1 NEW_LINE idxcnt = l * ( l + 1 ) / 2 NEW_LINE print ( int ( n - idxcnt ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def loveTriangle ( idx , seen ) : NEW_LINE INDENT if idx in seen : NEW_LINE INDENT if len ( seen ) == 3 : NEW_LINE INDENT return idx NEW_LINE DEDENT return - 1 NEW_LINE DEDENT return loveTriangle ( arr [ idx - 1 ] , seen | set ( [ idx ] ) ) NEW_LINE DEDENT isTrue = False NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i == loveTriangle ( arr [ i - 1 ] , set ( [ i ] ) ) : NEW_LINE INDENT isTrue = True NEW_LINE break NEW_LINE DEDENT DEDENT if isTrue : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < 26 : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT ch = str NEW_LINE ch = list ( ch ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT ch = ' ' . join ( ch ) NEW_LINE print ( ch ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE getModifiedString ( str ) NEW_LINE DEDENT
def is_correct ( hourMax , minuteMax , time ) : NEW_LINE INDENT h , m = time . split ( " : " ) NEW_LINE mirrored = { "0" : "0" , "1" : "1" , "2" : "5" , "3" : " " , "4" : " " , "5" : "2" , "6" : " " , "7" : " " , "8" : "8" , "9" : " " } NEW_LINE mirrored_h = mirrored [ h [ 1 ] ] + mirrored [ h [ 0 ] ] NEW_LINE mirrored_m = mirrored [ m [ 1 ] ] + mirrored [ m [ 0 ] ] NEW_LINE if len ( mirrored_h ) == 2 and int ( mirrored_h ) < minuteMax and len ( mirrored_m ) == 2 and int ( mirrored_m ) < hourMax : NEW_LINE INDENT return mirrored_m + " : " + mirrored_h NEW_LINE DEDENT return False NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT hourMax , minuteMax = map ( int , input ( ) . split ( ) ) NEW_LINE hourNow , minuteNow = map ( int , input ( ) . split ( " : " ) ) NEW_LINE result = "00:00" NEW_LINE flag = False NEW_LINE for hour in range ( hourNow , hourMax ) : NEW_LINE INDENT start = minuteNow if hour == hourNow else 0 NEW_LINE for minute in range ( start , minuteMax ) : NEW_LINE INDENT time = "0" * ( 2 - len ( str ( hour ) ) ) + str ( hour ) + " : " + "0" * ( 2 - len ( str ( minute ) ) ) + str ( minute ) NEW_LINE mirrored = is_correct ( hourMax , minuteMax , time ) NEW_LINE if mirrored : NEW_LINE INDENT result = time NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : break NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
from typing import List , Tuple , Union NEW_LINE from math import ceil NEW_LINE from typing import List NEW_LINE def munimum_number_of_piles ( n : int , n_values : List [ int ] ) -> int : NEW_LINE INDENT n_values . sort ( ) NEW_LINE pile = - 1 NEW_LINE for idx , s in enumerate ( n_values ) : NEW_LINE INDENT k = int ( ceil ( ( idx + 1 ) / ( s + 1 ) ) ) NEW_LINE pile = max ( pile , k ) NEW_LINE DEDENT return pile NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( munimum_number_of_piles ( n , a ) ) NEW_LINE
x = int ( input ( ) ) NEW_LINE for jj in range ( x ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : print ( 3 ) NEW_LINE else : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT p = 0 NEW_LINE k = n NEW_LINE while n % 2 == 0 : NEW_LINE INDENT p += 1 NEW_LINE n //= 2 NEW_LINE DEDENT t = 2 ** p NEW_LINE if t == k : NEW_LINE INDENT print ( t + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE root = int ( n ** ( 1 / 2 ) ) + 1 NEW_LINE isPrime = [ True ] * ( n + 3 ) NEW_LINE for i in range ( 4 , n + 3 , 2 ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT ans = 0 NEW_LINE prePrime = - 1 NEW_LINE for i in range ( 3 , n + 3 , 2 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT if prePrime + 2 == i : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT prePrime = i NEW_LINE if i > root : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i * i , n + 3 , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE
L = [ ] NEW_LINE input ( ) NEW_LINE r = 1 NEW_LINE for k in input ( ) . split ( ) : NEW_LINE INDENT L += [ r ] * int ( k ) NEW_LINE r += 1 NEW_LINE DEDENT input ( ) NEW_LINE for j in input ( ) . split ( ) : NEW_LINE INDENT print ( L [ int ( j ) - 1 ] ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE sumL = [ 0 ] * ( n + 2 ) NEW_LINE L = 1 NEW_LINE sumL [ - 2 ] = 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT L = sumL [ i + 1 ] NEW_LINE j = 2 NEW_LINE while i * j <= n : NEW_LINE INDENT L += ( sumL [ i * j ] - sumL [ min ( n , ( i + 1 ) * j - 1 ) + 1 ] ) NEW_LINE L %= m NEW_LINE j += 1 NEW_LINE DEDENT L %= m NEW_LINE sumL [ i ] = ( sumL [ i + 1 ] + L ) NEW_LINE sumL [ i ] %= m NEW_LINE DEDENT print ( L ) NEW_LINE
from collections import deque NEW_LINE def printMax ( arr , n , k ) : NEW_LINE INDENT Qi = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT while Qi and arr [ i ] >= arr [ Qi [ - 1 ] ] : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) ; NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT print ( str ( arr [ Qi [ 0 ] ] ) + " ▁ " , end = " " ) NEW_LINE while Qi and Qi [ 0 ] <= i - k : NEW_LINE INDENT Qi . popleft ( ) NEW_LINE DEDENT while Qi and arr [ i ] >= arr [ Qi [ - 1 ] ] : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT print ( str ( arr [ Qi [ 0 ] ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 1 , 78 , 90 , 57 , 89 , 56 ] NEW_LINE k = 3 NEW_LINE printMax ( arr , len ( arr ) , k ) NEW_LINE DEDENT
def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "0110" NEW_LINE length = len ( string ) NEW_LINE if isValid ( string , length ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
import random NEW_LINE def lehmann ( n , t ) : NEW_LINE INDENT a = random . randint ( 2 , n - 1 ) NEW_LINE e = ( n - 1 ) / 2 NEW_LINE while ( t > 0 ) : NEW_LINE INDENT result = ( ( int ) ( a ** e ) ) % n NEW_LINE if ( ( result % n ) == 1 or ( result % n ) == ( n - 1 ) ) : NEW_LINE INDENT a = random . randint ( 2 , n - 1 ) NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT n = 13 NEW_LINE t = 10 NEW_LINE if ( n == 2 ) : NEW_LINE INDENT print ( "2 ▁ is ▁ Prime . " ) NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( n , " is ▁ Composite " ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = lehmann ( n , t ) NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT print ( n , " may ▁ be ▁ Prime . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ Composite . " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT if a <= 0 or b <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if a > b : NEW_LINE INDENT i += a // b NEW_LINE a -= a // b * b NEW_LINE DEDENT else : NEW_LINE INDENT i += b // a NEW_LINE b -= b // a * a NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE print ( ' impossible ' if k > len ( s ) else max ( 0 , k - len ( set ( s ) ) ) ) NEW_LINE
N = 3 NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE trace = 0 NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT trace += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , -10 ] ] NEW_LINE print ( MaxTraceSub ( mat ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , input ( ) . split ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT if xb2 < xa1 or xb1 > xa2 or yb2 < ya1 or yb1 > ya2 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def convert_to_binary ( n ) : NEW_LINE INDENT listy = [ ] NEW_LINE while n > 0 : NEW_LINE INDENT listy . append ( n % 2 ) NEW_LINE n //= 2 NEW_LINE DEDENT for i in range ( 31 - len ( listy ) ) : NEW_LINE INDENT listy . append ( 0 ) NEW_LINE DEDENT return listy NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT test_cases = range ( int ( input ( ) ) ) NEW_LINE for test_case in test_cases : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( u ) for u in input ( ) . split ( " ▁ " ) ] NEW_LINE real_counter = [ 0 for i in range ( 31 ) ] NEW_LINE for i in a : NEW_LINE INDENT x = convert_to_binary ( i ) NEW_LINE for i in range ( len ( real_counter ) ) : NEW_LINE INDENT real_counter [ i ] += x [ i ] NEW_LINE DEDENT DEDENT collector = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in real_counter : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT collector [ i ] += 1 NEW_LINE DEDENT DEDENT real_collector = [ ] NEW_LINE for i in range ( len ( collector ) ) : NEW_LINE INDENT if collector [ i ] > 0 : NEW_LINE INDENT real_collector . append ( i ) NEW_LINE DEDENT DEDENT final_answer = [ 1 ] NEW_LINE if sum ( real_collector ) == 0 : NEW_LINE INDENT print ( " ▁ " . join ( [ str ( i ) for i in range ( 1 , n + 1 ) ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT min_collector = min ( real_collector ) NEW_LINE real_collector = real_counter NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i > min_collector : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT is_good = True NEW_LINE for j in real_collector : NEW_LINE INDENT if j % i != 0 : NEW_LINE INDENT is_good = False NEW_LINE break NEW_LINE DEDENT DEDENT if is_good : NEW_LINE INDENT final_answer . append ( i ) NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ " . join ( [ str ( k ) for k in final_answer ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT
import math NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE li = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT li [ i ] = math . ceil ( arr [ i ] / m ) NEW_LINE DEDENT maxi = max ( li ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if maxi == li [ i ] : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum = pos_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum = neg_sum + arr [ i ] NEW_LINE DEDENT arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE replacedArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE replacedArray ( N , arr1 ) NEW_LINE printArray ( N , arr1 ) NEW_LINE
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for j in range ( i + 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ j ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE replacedArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE replacedArray ( N , arr1 ) NEW_LINE printArray ( N , arr1 ) NEW_LINE DEDENT
def countDivisbleby4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 ; NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ '1' , '2' , '4' ] NEW_LINE print ( countDivisbleby4 ( s ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE res = " YES " if max ( s [ : 2 ] ) + max ( s [ 2 : ] ) == sum ( sorted ( s ) [ 2 : ] ) else " NO " NEW_LINE print ( res ) NEW_LINE DEDENT
l = [ ] NEW_LINE limit = 10000000000 NEW_LINE def gen ( number , four , seven ) : NEW_LINE INDENT if ( number > limit ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( number > 0 and four == seven ) : NEW_LINE INDENT l . append ( number ) NEW_LINE DEDENT gen ( number * 10 + 4 , four + 1 , seven ) NEW_LINE gen ( number * 10 + 7 , four , seven + 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT gen ( 0 , 0 , 0 ) NEW_LINE l . sort ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for val in l : NEW_LINE INDENT if ( val >= n ) : NEW_LINE INDENT ans = val NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE has = False NEW_LINE prop = n == 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == k : has = True NEW_LINE if a [ i ] >= k and i > 0 : NEW_LINE INDENT if a [ i - 1 ] >= k : prop = True NEW_LINE if i > 1 and a [ i - 2 ] >= k : prop = True NEW_LINE DEDENT DEDENT print ( " yes " if has and prop else " no " ) NEW_LINE DEDENT
T = int ( input ( ) ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT D , I , M , N = input ( ) . split ( ' ▁ ' ) NEW_LINE D , I , M , N = int ( D ) , int ( I ) , int ( M ) , int ( N ) NEW_LINE x = input ( ) . split ( ' ▁ ' ) NEW_LINE r = [ 0 ] * 256 NEW_LINE for q in x : NEW_LINE INDENT nr = list ( map ( lambda i : i + D , r ) ) NEW_LINE q = int ( q ) NEW_LINE if M == 0 : NEW_LINE INDENT for i in range ( 256 ) : NEW_LINE INDENT nr [ i ] = min ( nr [ i ] , r [ i ] + abs ( q - i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 256 ) : NEW_LINE INDENT for j in range ( 256 ) : NEW_LINE INDENT nr [ j ] = min ( nr [ j ] , r [ i ] + abs ( q - j ) + ( max ( 0 , abs ( i - j ) - 1 ) // M ) * I ) NEW_LINE DEDENT DEDENT DEDENT r = nr NEW_LINE DEDENT print ( ' Case ▁ # % d : ▁ % s ' % ( C , min ( r ) ) ) NEW_LINE DEDENT
def count_island ( ban ) : NEW_LINE INDENT def remove ( x , y ) : NEW_LINE INDENT if 0 <= y < 12 and 0 <= x < 12 and ban [ y ] [ x ] == 1 : NEW_LINE INDENT ban [ y ] [ x ] = 0 NEW_LINE for dx , dy in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] : NEW_LINE INDENT remove ( x + dx , y + dy ) NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for y in range ( 12 ) : NEW_LINE INDENT for x in range ( 12 ) : NEW_LINE INDENT if ban [ y ] [ x ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE remove ( x , y ) NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT ban = [ ] NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT if s : NEW_LINE INDENT ban . append ( list ( map ( int , s ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT count_island ( ban ) NEW_LINE ban = [ ] NEW_LINE DEDENT DEDENT if ban : count_island ( ban ) NEW_LINE
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = min ( arr ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = 0 NEW_LINE for i in arr : NEW_LINE INDENT res += ( i - k ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT
def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE print ( printKDistinct ( arr , size , 2 ) ) NEW_LINE
def fib ( f , n ) : NEW_LINE INDENT f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT def findLastDigit ( n ) : NEW_LINE INDENT f = [ 0 ] * 61 ; NEW_LINE f = fib ( f , 60 ) ; NEW_LINE return f [ n % 60 ] ; NEW_LINE DEDENT n = 1 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 61 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 7 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 67 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE
ABC = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ABC . count ( 5 ) == 2 : NEW_LINE INDENT print ( ' YES ' if sum ( ABC ) == 17 else ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
N , Z , W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = [ W ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = [ 0 ] * ( N + 1 ) NEW_LINE Y = [ 1e9 ] * ( N + 1 ) NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT X [ i ] = max ( [ abs ( A [ i - 1 ] - A [ N ] ) ] + [ Y [ j ] for j in range ( i + 1 , N + 1 ) ] ) NEW_LINE Y [ i ] = min ( [ abs ( A [ i - 1 ] - A [ N ] ) ] + [ X [ j ] for j in range ( i + 1 , N + 1 ) ] ) NEW_LINE DEDENT print ( X [ 1 ] ) NEW_LINE
def countEleLessThanOrEqual ( arr1 , arr2 , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr2 [ j ] <= arr1 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE countEleLessThanOrEqual ( arr1 , arr2 , m , n ) NEW_LINE
_ , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( min ( arr ) ) NEW_LINE DEDENT elif k == 2 : NEW_LINE INDENT print ( max ( arr [ 0 ] , arr [ - 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( arr ) ) NEW_LINE DEDENT
A = input ( ) . split ( ) NEW_LINE print ( * A ) NEW_LINE S = int ( input ( ) ) NEW_LINE for _ in " ▁ " * S : NEW_LINE INDENT B , C = input ( ) . split ( ) NEW_LINE A [ A . index ( B ) ] = C NEW_LINE print ( * A ) NEW_LINE DEDENT
import sys NEW_LINE from os import path NEW_LINE if path . exists ( ' input . txt ' ) : NEW_LINE INDENT sys . stdin = open ( ' input . txt ' , ' r ' ) NEW_LINE sys . stdout = open ( ' output . txt ' , ' w ' ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ ( n - 1 ) // 2 ] ) NEW_LINE
import sys NEW_LINE k , p = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE ans2 = 0 NEW_LINE i = 1 NEW_LINE while ans2 < k : NEW_LINE INDENT s = str ( i ) NEW_LINE ans += int ( s + s [ : : - 1 ] ) NEW_LINE ans2 += 1 NEW_LINE i += 1 NEW_LINE DEDENT print ( ans % p ) NEW_LINE
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a_to_i = { a : i for i , a in enumerate ( A , start = 1 ) } NEW_LINE L = [ i - 1 for i in range ( N + 2 ) ] NEW_LINE R = [ i + 1 for i in range ( N + 2 ) ] NEW_LINE ans = 0 NEW_LINE for a in range ( N , 0 , - 1 ) : NEW_LINE INDENT i = a_to_i [ a ] NEW_LINE ans += a * ( R [ i ] - i ) * ( i - L [ i ] ) NEW_LINE L [ R [ i ] ] = L [ i ] NEW_LINE R [ L [ i ] ] = R [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + str ( lps ( seq ) ) ) NEW_LINE
def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = " " ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " ▁ + " , x , end = " " ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , " = ▁ " , end = " " ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = " YES " NEW_LINE if abs ( a - b ) > 1 or a + b == 0 : NEW_LINE INDENT ans = " NO " NEW_LINE DEDENT print ( ans ) NEW_LINE
def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) ; NEW_LINE ans = ( x * y ) / ( s * s ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT m = 385 ; NEW_LINE n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " aabbbcc " NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printMax ( arr , n , k ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if arr [ i + j ] > max : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( str ( max ) + " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printMax ( arr , n , k ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE eps = 10 ** - 9 NEW_LINE def main ( ) : NEW_LINE INDENT import sys NEW_LINE from collections import deque NEW_LINE input = sys . stdin . buffer . readline NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE adj = [ [ ] for _ in range ( N + 1 ) ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . append ( b ) NEW_LINE adj [ b ] . append ( a ) NEW_LINE DEDENT seen = [ 0 ] * ( N + 1 ) NEW_LINE single = 0 NEW_LINE bipartite = 0 NEW_LINE not_bipartite = 0 NEW_LINE for v0 in range ( 1 , N + 1 ) : NEW_LINE INDENT if seen [ v0 ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT flg = 1 NEW_LINE que = deque ( ) NEW_LINE que . append ( v0 ) NEW_LINE seen [ v0 ] = 1 NEW_LINE cnt = 0 NEW_LINE while que : NEW_LINE INDENT v = que . popleft ( ) NEW_LINE cnt += 1 NEW_LINE for u in adj [ v ] : NEW_LINE INDENT if seen [ u ] == 0 : NEW_LINE INDENT seen [ u ] = - seen [ v ] NEW_LINE que . append ( u ) NEW_LINE DEDENT else : NEW_LINE INDENT if seen [ u ] == seen [ v ] : NEW_LINE INDENT flg = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT if cnt == 1 : NEW_LINE INDENT single += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if flg : NEW_LINE INDENT bipartite += 1 NEW_LINE DEDENT else : NEW_LINE INDENT not_bipartite += 1 NEW_LINE DEDENT DEDENT DEDENT ans = N ** 2 - ( N - single ) ** 2 NEW_LINE ans += ( bipartite + not_bipartite ) ** 2 NEW_LINE ans += bipartite ** 2 NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def ss ( a , b ) : NEW_LINE INDENT a = min ( a , b ) NEW_LINE return a * ( a + 1 ) // 2 + ( b - a ) * a NEW_LINE DEDENT def solve ( a , b , p ) : NEW_LINE INDENT lft = p - 1 NEW_LINE rt = a - p NEW_LINE b -= a NEW_LINE x = 0 NEW_LINE y = b NEW_LINE while x != y : NEW_LINE INDENT tmp = ( x + y + 1 ) // 2 NEW_LINE if ss ( lft , tmp - 1 ) + ss ( rt , tmp - 1 ) + tmp > b : NEW_LINE INDENT y = tmp - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = tmp NEW_LINE DEDENT DEDENT return x + 1 NEW_LINE DEDENT a , b , p = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( a , b , p ) ) NEW_LINE
from itertools import combinations NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE ans = 10 ** 18 * 5 NEW_LINE for x in combinations ( range ( N ) , 2 ) : NEW_LINE INDENT u = max ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] ) NEW_LINE d = min ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] ) NEW_LINE for y in combinations ( range ( N ) , 2 ) : NEW_LINE INDENT r = max ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] ) NEW_LINE l = min ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if d <= P [ i ] [ 0 ] <= u and l <= P [ i ] [ 1 ] <= r : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= K : NEW_LINE INDENT ans = min ( ans , ( u - d ) * ( r - l ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT l += [ input ( ) ] NEW_LINE d [ l [ i ] ] = i NEW_LINE DEDENT z = list ( l ) NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT l . sort ( key = lambda x : x [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l . sort ( reverse = True , key = lambda x : x [ i ] ) NEW_LINE DEDENT DEDENT for i in l : NEW_LINE INDENT print ( d [ i ] + 1 , end = " ▁ " ) NEW_LINE DEDENT
def pre_process ( substrings , s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = " " ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] ; NEW_LINE substrings . append ( dup ) ; NEW_LINE DEDENT DEDENT substrings . sort ( ) ; NEW_LINE return substrings ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geek " ; NEW_LINE substrings = [ ] ; NEW_LINE substrings = pre_process ( substrings , s ) ; NEW_LINE queries = [ 1 , 5 , 10 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( substrings [ queries [ i ] - 1 ] ) ; NEW_LINE DEDENT DEDENT
f = [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] NEW_LINE b = [ [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] ] NEW_LINE while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 : break NEW_LINE r , c , d = 1 , 1 , 0 NEW_LINE while True : NEW_LINE INDENT buf = input ( ) . split ( ) NEW_LINE if buf [ 0 ] == " STOP " : break NEW_LINE elif buf [ 0 ] == " RIGHT " : d = ( d + 1 ) % 4 NEW_LINE elif buf [ 0 ] == " LEFT " : d = ( d + 3 ) % 4 NEW_LINE else : NEW_LINE INDENT if buf [ 0 ] == " FORWARD " : NEW_LINE INDENT r2 = r + int ( buf [ 1 ] ) * f [ d ] [ 1 ] NEW_LINE c2 = c + int ( buf [ 1 ] ) * f [ d ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT r2 = r + int ( buf [ 1 ] ) * b [ d ] [ 1 ] NEW_LINE c2 = c + int ( buf [ 1 ] ) * b [ d ] [ 0 ] NEW_LINE DEDENT if r2 < 1 : r2 = 1 NEW_LINE if r2 > h : r2 = h NEW_LINE if c2 < 1 : c2 = 1 NEW_LINE if c2 > w : c2 = w NEW_LINE r , c = r2 , c2 NEW_LINE DEDENT DEDENT print ( c , r ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE x = 0 NEW_LINE ans = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if s [ j ] == s [ i ] == ' x ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if x > 1 : NEW_LINE INDENT ans += x - 1 NEW_LINE DEDENT x = 0 NEW_LINE DEDENT i = j NEW_LINE DEDENT if x > 1 : NEW_LINE INDENT ans += x - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
while 1 : NEW_LINE INDENT x = input ( ) NEW_LINE if x == "0" : NEW_LINE INDENT break NEW_LINE DEDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 1 , len ( x ) ) : NEW_LINE INDENT if x [ i ] == " A " : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if a > b : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT print ( a , b ) NEW_LINE DEDENT
def fact ( N ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( N * N ) * fact ( N ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k , x = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( k - 1 ) * 9 + x ) NEW_LINE DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE maximumArea ( l , b , x , y ) NEW_LINE
NO_OF_CHARS = 256 NEW_LINE def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallesteSubstr_maxDistictChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = max_distinct_char ( str , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT subs = str [ i : j ] NEW_LINE subs_lenght = len ( subs ) NEW_LINE sub_distinct_char = max_distinct_char ( subs , subs_lenght ) NEW_LINE if ( subs_lenght < minl and max_distinct == sub_distinct_char ) : NEW_LINE INDENT minl = subs_lenght NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " AABBBCBB " NEW_LINE l = smallesteSubstr_maxDistictChar ( str ) ; NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : " , l ) NEW_LINE DEDENT
def f ( n , s1 , s2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ i ] ) : NEW_LINE INDENT if ( s1 [ i ] == ' R ' or s2 [ i ] == ' R ' ) : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT DEDENT return " YES " NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE print ( f ( n , s1 , s2 ) ) NEW_LINE DEDENT
def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 ] * n ; NEW_LINE col = [ 0 ] * n NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] ; NEW_LINE y = q [ i ] [ 1 ] ; NEW_LINE row [ x - 1 ] += 1 ; NEW_LINE col [ y - 1 ] += 1 ; NEW_LINE DEDENT r1 = 0 ; NEW_LINE r2 = 0 ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] % 2 == 0 ) : NEW_LINE INDENT r1 += 1 ; NEW_LINE DEDENT if ( row [ i ] % 2 == 1 ) : NEW_LINE INDENT r2 += 1 ; NEW_LINE DEDENT if ( col [ i ] % 2 == 0 ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 ; NEW_LINE DEDENT DEDENT count = r1 * c1 + r2 * c2 ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 ; NEW_LINE q = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 1 ] ] ; NEW_LINE size = len ( q ) ; NEW_LINE print ( findNumberOfEvenCells ( n , q , size ) ) ; NEW_LINE DEDENT
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkType ( arr , n ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( n // 2 - max ( s . count ( '10' ) , s . count ( '01' ) ) ) NEW_LINE DEDENT
from fractions import Fraction NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if c > a or d > b : NEW_LINE INDENT if c > a and d > b : NEW_LINE INDENT p = min ( Fraction ( b / d ) . limit_denominator ( ) , Fraction ( a / c ) . limit_denominator ( ) ) NEW_LINE DEDENT elif c > a : NEW_LINE INDENT p = Fraction ( a / c ) . limit_denominator ( ) NEW_LINE DEDENT else : NEW_LINE INDENT p = Fraction ( b / d ) . limit_denominator ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT p = min ( Fraction ( b / d ) . limit_denominator ( ) , Fraction ( a / c ) . limit_denominator ( ) ) NEW_LINE DEDENT c *= p NEW_LINE d *= p NEW_LINE up , down = ( a * b - c * d ) , a * b NEW_LINE ans = str ( Fraction ( up / down ) . limit_denominator ( ) ) NEW_LINE print ( '0/1' if ans == '0' else ans ) NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT print ( arr ) NEW_LINE DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE
def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " % sth ▁ Centered ▁ square ▁ number : " % n , centered_square_num ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n <= k : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 and k % 2 == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif n % 2 == 1 and k % 2 == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT x = 2 * k - 1 NEW_LINE min_sum = ( ( 1 + x ) ** 2 ) / 4 NEW_LINE if min_sum > n : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif min_sum == n : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n - min_sum ) % 2 == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
n = int ( input ( ) ) // 2 NEW_LINE s = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( s [ : n ] ) ** 2 + sum ( s [ n : ] ) ** 2 ) NEW_LINE
def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def lenOfLongSubarrWithGivenSum ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum , maxLen = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT if ( Sum not in um . keys ( ) ) : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum in um . keys ( ) ) : NEW_LINE INDENT if ( ( Sum - k ) in um . keys ( ) and maxLen < ( i - um [ Sum - k ] ) ) : NEW_LINE INDENT maxLen = i - um [ Sum - k ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT def lenLongSubarrWithMaxSum ( arr , n ) : NEW_LINE INDENT maxSum = maxSubArraySum ( arr , n ) NEW_LINE return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) NEW_LINE DEDENT arr = [ 5 , - 2 , - 1 , 3 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ longest ▁ subarray ▁ having ▁ maximum ▁ sum ▁ = " , lenLongSubarrWithMaxSum ( arr , n ) ) NEW_LINE
import itertools NEW_LINE def check ( x : int ) -> bool : NEW_LINE INDENT s = str ( x ) NEW_LINE prev = ord ( s [ 0 ] ) NEW_LINE for c in s [ 1 : ] : NEW_LINE INDENT if ord ( c ) != prev + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT prev = ord ( c ) NEW_LINE DEDENT return True NEW_LINE DEDENT def main ( ) -> None : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE max_ = - 1 NEW_LINE for c in itertools . combinations ( sorted ( v ) , 2 ) : NEW_LINE INDENT p = c [ 0 ] * c [ 1 ] NEW_LINE if check ( p ) : NEW_LINE INDENT max_ = max ( max_ , p ) NEW_LINE DEDENT DEDENT print ( max_ ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def find ( dividend , divisor , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return ( 0 , dividend ) NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if ( n > divisor ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif ( n < 0 ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == divisor ) : NEW_LINE INDENT mid += 1 NEW_LINE n = 0 NEW_LINE DEDENT return ( mid , n ) NEW_LINE DEDENT return find ( dividend , divisor , start , end ) NEW_LINE DEDENT def divide ( dividend , divisor ) : NEW_LINE INDENT return find ( dividend , divisor , 1 , dividend ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT dividend = 10 ; divisor = 3 NEW_LINE ans = divide ( dividend , divisor ) NEW_LINE print ( str ( ans [ 0 ] ) + " , ▁ " , end = " " ) NEW_LINE print ( str ( ans [ 1 ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE cities = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( cities ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( abs ( cities [ 0 ] - cities [ 1 ] ) , abs ( cities [ 0 ] - cities [ - 1 ] ) ) NEW_LINE DEDENT elif i == len ( cities ) - 1 : NEW_LINE INDENT print ( abs ( cities [ - 1 ] - cities [ i - 1 ] ) , abs ( cities [ 0 ] - cities [ - 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT mn = min ( abs ( cities [ i ] - cities [ i - 1 ] ) , abs ( cities [ i ] - cities [ i + 1 ] ) ) NEW_LINE mx = max ( abs ( cities [ i ] - cities [ 0 ] ) , abs ( cities [ i ] - cities [ - 1 ] ) ) NEW_LINE print ( mn , mx ) NEW_LINE DEDENT DEDENT
def solve ( ) : NEW_LINE INDENT n , i = map ( int , input ( ) . split ( ) ) NEW_LINE ns = sorted ( [ * map ( int , input ( ) . split ( ) ) ] ) NEW_LINE k = 1 << ( i * 8 // n ) NEW_LINE lis = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ns [ i ] != ns [ i + 1 ] : lis . append ( i + 1 ) NEW_LINE DEDENT lis . append ( n ) NEW_LINE print ( 0 if len ( lis ) <= k else n - max ( lis [ i + k ] - lis [ i ] for i in range ( len ( lis ) - k ) ) ) NEW_LINE DEDENT solve ( ) NEW_LINE
def towerOfHanoi ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move ▁ disk " , n - 1 , " from ▁ rod " , from_rod , " to ▁ rod " , aux_rod2 ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE print ( " Move ▁ disk " , n - 1 , " from ▁ rod " , aux_rod2 , " to ▁ rod " , to_rod ) NEW_LINE towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT n = 4 NEW_LINE towerOfHanoi ( n , ' A ' , ' D ' , ' B ' , ' C ' ) NEW_LINE
import os , sys , io , math NEW_LINE from tokenize import Triple NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE a = '1000' NEW_LINE b = '1001' NEW_LINE c = '1010' NEW_LINE d = '1011' NEW_LINE e = '1100' NEW_LINE f = '1101' NEW_LINE g = '1110' NEW_LINE h = '1111' NEW_LINE s = IS ( ) NEW_LINE res = ' ' NEW_LINE for i in s : NEW_LINE INDENT if i == ' > ' : res += a NEW_LINE elif i == ' < ' : res += b NEW_LINE elif i == ' + ' : res += c NEW_LINE elif i == ' - ' : res += d NEW_LINE elif i == ' . ' : res += e NEW_LINE elif i == ' , ' : res += f NEW_LINE elif i == ' [ ' : res += g NEW_LINE else : res += h NEW_LINE DEDENT print ( ( int ( res , 2 ) ) % ( 10 ** 6 + 3 ) ) NEW_LINE
M = { } NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT query = input ( ) . split ( ) NEW_LINE if query [ 0 ] == '0' : M [ query [ 1 ] ] = query [ 2 ] NEW_LINE elif query [ 0 ] == '1' : NEW_LINE INDENT if query [ 1 ] in M : print ( M [ query [ 1 ] ] ) NEW_LINE else : print ( 0 ) NEW_LINE DEDENT else : M [ query [ 1 ] ] = 0 NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] ; prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
from math import log2 NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT
D , G = map ( int , input ( ) . split ( ) ) NEW_LINE PC = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( 2 ** D ) : NEW_LINE INDENT score = 0 NEW_LINE problem = 0 NEW_LINE for j in range ( D ) : NEW_LINE INDENT if ( i >> j ) & 1 : NEW_LINE INDENT score += 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] NEW_LINE problem += PC [ j ] [ 0 ] NEW_LINE DEDENT DEDENT if score > G : NEW_LINE INDENT continue NEW_LINE DEDENT left = G - score NEW_LINE for j in range ( D ) : NEW_LINE INDENT if ( i >> j ) & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if left > 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT tmp = ( left + ( 100 * ( j + 1 ) ) - 1 ) // ( 100 * ( j + 1 ) ) NEW_LINE ans = min ( ans , problem + min ( tmp , PC [ j ] [ 0 ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE if sum ( a ) == m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxi = l . count ( max ( l ) ) NEW_LINE mini = l . count ( min ( l ) ) NEW_LINE if n == 1 or len ( l ) == l . count ( l [ 0 ] ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( l ) - maxi - mini ) NEW_LINE DEDENT
from math import floor , log2 NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = pow ( 2 , floor ( log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 3 , 4 , 9 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( " Length ▁ of ▁ LCIS ▁ is " , LCIS ( arr1 , n , arr2 , m ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if int ( x % 2 ) == 0 else 1 ) + countSetBitsUtil ( int ( x / 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( " Total ▁ set ▁ bit ▁ count ▁ is " , countSetBits ( n ) ) NEW_LINE DEDENT
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE j = high + 1 NEW_LINE while ( True ) : NEW_LINE INDENT i += 1 NEW_LINE while ( arr [ i ] < pivot ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j -= 1 NEW_LINE while ( arr [ j ] > pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT return j NEW_LINE DEDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE printArray ( arr , n ) NEW_LINE
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE printArray ( arr , n ) NEW_LINE
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 10 ** 9 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def minPossibleSum ( a , n , x ) : NEW_LINE INDENT mxSum = maxSubArraySum ( a , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum = sum - mxSum + mxSum / x NEW_LINE print ( round ( sum , 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE X = 2 NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE minPossibleSum ( A , N , X ) NEW_LINE DEDENT
def fun ( p ) : NEW_LINE INDENT return p . index ( max ( p ) ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE var = p [ 0 ] NEW_LINE ans = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT l . append ( [ p [ j ] , j ] ) NEW_LINE DEDENT l . sort ( key = lambda x : x [ 0 ] ) NEW_LINE l = l [ : : - 1 ] NEW_LINE ind = 0 NEW_LINE ans . append ( p [ l [ 0 ] [ 1 ] : n ] ) NEW_LINE for j in range ( n - 1 ) : NEW_LINE INDENT if l [ j + 1 ] [ 1 ] > l [ j ] [ 1 ] : NEW_LINE INDENT temp = l [ j + 1 ] NEW_LINE l [ j + 1 ] = l [ j ] NEW_LINE l [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( p [ l [ j + 1 ] [ 1 ] : l [ j ] [ 1 ] ] ) NEW_LINE DEDENT DEDENT for j in range ( len ( ans ) ) : NEW_LINE INDENT print ( * ans [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def printArray ( N , SUM , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) / 2 NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 NEW_LINE if ( minSum > SUM or maxSum < SUM ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT arr = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE DEDENT sum = minSum NEW_LINE i = N NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT x = sum + ( K - i ) NEW_LINE if ( x < SUM ) : NEW_LINE INDENT sum = sum + ( K - i ) NEW_LINE arr [ i ] = K NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( SUM - sum ) NEW_LINE sum = SUM NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT print ( int ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE SUM = 15 NEW_LINE K = 8 NEW_LINE printArray ( N , SUM , K ) NEW_LINE DEDENT
COST = 3 ; NEW_LINE def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST ; NEW_LINE x %= COST ; NEW_LINE type2 = y // COST ; NEW_LINE y %= COST ; NEW_LINE type3 = z // COST ; NEW_LINE z %= COST ; NEW_LINE type4 = min ( x , min ( y , z ) ) ; NEW_LINE maxItems = type1 + type2 + type3 + type4 ; NEW_LINE return maxItems ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 4 ; y = 5 ; z = 6 ; NEW_LINE print ( maxItems ( x , y , z ) ) ; NEW_LINE DEDENT
from collections import deque NEW_LINE def run_tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) > 0 ) : NEW_LINE INDENT x = A . popleft ( ) NEW_LINE y = B . popleft ( ) NEW_LINE if ( x == y ) : NEW_LINE INDENT total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B . appendleft ( y ) NEW_LINE A . append ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = deque ( ) NEW_LINE A . append ( 3 ) NEW_LINE A . append ( 2 ) NEW_LINE A . append ( 1 ) NEW_LINE A . append ( 4 ) NEW_LINE B = deque ( ) NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 3 ) NEW_LINE B . append ( 2 ) NEW_LINE print ( run_tasks ( A , B ) ) NEW_LINE DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( " { : . 1 f } " . format ( y0 ) + " x " + " ▁ + ▁ " + " { : . 1 f } " . format ( x0 ) + " y ▁ = ▁ " + " { : . 1 f } " . format ( c ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE line ( x0 , y0 ) NEW_LINE DEDENT
input ( ) NEW_LINE print ( len ( set ( map ( frozenset , input ( ) . split ( ) ) ) ) ) NEW_LINE
import sys NEW_LINE EPS = 1e-9 NEW_LINE def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT def check_ccw ( p0 , p1 , p2 ) : NEW_LINE INDENT a , b = p1 - p0 , p2 - p0 NEW_LINE if cross ( a , b ) > EPS : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif cross ( a , b ) < - 1 * EPS : NEW_LINE INDENT flag = - 1 NEW_LINE DEDENT elif dot ( a , b ) < - 1 * EPS : NEW_LINE INDENT flag = 2 NEW_LINE DEDENT elif abs ( a ) < abs ( b ) : NEW_LINE INDENT flag = - 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT return flag NEW_LINE DEDENT def check_intersection ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT intersected = ( check_ccw ( p0 , p1 , p2 ) * check_ccw ( p0 , p1 , p3 ) <= 0 ) and ( check_ccw ( p2 , p3 , p0 ) * check_ccw ( p2 , p3 , p1 ) <= 0 ) NEW_LINE return intersected NEW_LINE DEDENT def solve ( _lines ) : NEW_LINE INDENT for line in _lines : NEW_LINE INDENT line = tuple ( map ( int , line ) ) NEW_LINE p0 , p1 , p2 , p3 = ( x + y * 1j for x , y in zip ( line [ : : 2 ] , line [ 1 : : 2 ] ) ) NEW_LINE intersected = check_intersection ( p0 , p1 , p2 , p3 ) NEW_LINE if intersected : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT _input = sys . stdin . readlines ( ) NEW_LINE l_num = int ( _input [ 0 ] ) NEW_LINE lines = map ( lambda x : x . split ( ) , _input [ 1 : ] ) NEW_LINE solve ( lines ) NEW_LINE DEDENT
def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( unique ) > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " aaaaab " NEW_LINE if ( isAnyNotPalindrome ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE
x = int ( input ( ) ) NEW_LINE N , S = 0 , 0 NEW_LINE po = 0 NEW_LINE c = " YES " NEW_LINE for i in range ( x ) : NEW_LINE INDENT p = list ( input ( ) . split ( ) ) NEW_LINE if N == 0 and S == 0 : NEW_LINE INDENT if p [ 1 ] != " South " : NEW_LINE INDENT c = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT if S - N == 20000 : NEW_LINE INDENT if p [ 1 ] != " North " : NEW_LINE INDENT c = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT if p [ 1 ] == " North " : NEW_LINE INDENT po = po - int ( p [ 0 ] ) NEW_LINE N += int ( p [ 0 ] ) NEW_LINE if po < 0 : NEW_LINE INDENT c = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT elif p [ 1 ] == " South " : NEW_LINE INDENT S += int ( p [ 0 ] ) NEW_LINE po = po + int ( p [ 0 ] ) NEW_LINE if po > 20000 : NEW_LINE INDENT c = " N0" NEW_LINE break NEW_LINE DEDENT DEDENT if N == S : N , S = 0 , 0 NEW_LINE DEDENT if N != S : c = " NO " NEW_LINE print ( c ) NEW_LINE
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 ] * 3 ; NEW_LINE arr [ 0 ] = a ; NEW_LINE arr [ 1 ] = b ; NEW_LINE arr [ 2 ] = c ; NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; NEW_LINE k = k - diff ; NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a1 = 6 ; b1 = 3 ; c1 = 2 ; k1 = 7 ; NEW_LINE if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
adjacency = [ [ ] for i in range ( 100 ) ] NEW_LINE def insert ( x , y ) : NEW_LINE INDENT adjacency [ x ] . append ( y ) NEW_LINE DEDENT def dfs ( node , leaf , vis ) : NEW_LINE INDENT leaf [ node ] = 0 NEW_LINE vis [ node ] = 1 NEW_LINE for it in adjacency [ node ] : NEW_LINE INDENT if ( vis [ it ] == False ) : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_LINE leaf [ node ] += leaf [ it ] NEW_LINE DEDENT DEDENT if ( len ( adjacency [ node ] ) == 0 ) : NEW_LINE INDENT leaf [ node ] = 1 NEW_LINE DEDENT DEDENT def printLeaf ( n , leaf ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " The ▁ node " , i , " has " , leaf [ i ] , " leaf ▁ nodes " ) NEW_LINE DEDENT DEDENT N = 6 NEW_LINE insert ( 1 , 2 ) NEW_LINE insert ( 1 , 3 ) NEW_LINE insert ( 3 , 4 ) NEW_LINE insert ( 3 , 5 ) NEW_LINE insert ( 3 , 6 ) NEW_LINE leaf = [ 0 for i in range ( N + 1 ) ] NEW_LINE vis = [ 0 for i in range ( N + 1 ) ] NEW_LINE dfs ( 1 , leaf , vis ) NEW_LINE printLeaf ( N , leaf ) NEW_LINE
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT s = S ( ) NEW_LINE k = I ( ) NEW_LINE l = 0 NEW_LINE for c in s : NEW_LINE INDENT if c != '1' : NEW_LINE INDENT break NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if l >= k : NEW_LINE INDENT return 1 NEW_LINE DEDENT return s [ l ] NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT line = input ( ) NEW_LINE bought_count = Counter ( line ) NEW_LINE line = input ( ) NEW_LINE made_cout = Counter ( line ) NEW_LINE res = 0 NEW_LINE for color in made_cout : NEW_LINE INDENT if color not in bought_count : NEW_LINE INDENT return print ( - 1 ) NEW_LINE DEDENT res += min ( bought_count [ color ] , made_cout [ color ] ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT X = ' AGGT12' NEW_LINE Y = '12TXAYB ' NEW_LINE Z = '12XBA ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( ' Length ▁ of ▁ LCS ▁ is ' , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE r = [ * map ( int , input ( ) . split ( ) ) ] NEW_LINE ans = abs ( r [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += abs ( r [ i ] - r [ i - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def isSpiltPossible ( n , a ) : NEW_LINE INDENT Sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( Sum % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( Sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if ( isSpiltPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE f = [ 0 ] * 4 NEW_LINE for i in l : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT f [ 0 ] += 1 NEW_LINE f [ 1 ] = max ( f [ 0 ] , f [ 1 ] ) NEW_LINE f [ 2 ] = max ( f [ 2 ] + 1 , f [ 2 ] ) NEW_LINE f [ 3 ] = max ( f [ 3 ] , f [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ 1 ] = max ( f [ 1 ] + 1 , f [ 0 ] ) NEW_LINE f [ 2 ] = max ( f [ 2 ] , f [ 1 ] ) NEW_LINE f [ 3 ] = max ( f [ 3 ] + 1 , f [ 2 ] ) NEW_LINE DEDENT DEDENT print ( f [ 3 ] ) NEW_LINE
def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True NEW_LINE aeven = False NEW_LINE n = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] NEW_LINE b = steps [ i ] [ 1 ] NEW_LINE if ( not ( aeven or a & 1 ) ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif ( not ( a & 1 ) ) : NEW_LINE INDENT if ( not ( b & 1 ) ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if ( beven ) : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT if ( not ( beven ^ aeven ) ) : NEW_LINE INDENT even += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT print ( " even ▁ = ▁ " , even , " , ▁ odd ▁ = ▁ " , odd , sep = " " ) NEW_LINE DEDENT min = 1 NEW_LINE max = 4 NEW_LINE steps = [ [ 1 , 2 ] , [ 3 , 4 ] ] NEW_LINE count_even_odd ( min , max , steps ) NEW_LINE
vamshi , z = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( vamshi // z + 1 ) * z ) NEW_LINE
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] = p_factors [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE
def reverserWords ( string ) : NEW_LINE INDENT st = list ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] != " ▁ " : NEW_LINE INDENT st . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = " " ) NEW_LINE st . pop ( ) NEW_LINE DEDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = " " ) NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " Geeks ▁ for ▁ Geeks " NEW_LINE reverserWords ( string ) NEW_LINE DEDENT
input ( ) NEW_LINE a = b = 0 NEW_LINE for x , y in zip ( input ( ) , input ( ) ) : NEW_LINE INDENT a += x > y NEW_LINE b += x < y NEW_LINE DEDENT print ( - 1 if a == 0 else b // a + 1 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE N = n + 2 NEW_LINE is_prime = [ 1 ] * N NEW_LINE is_prime [ 0 ] = 0 NEW_LINE is_prime [ 1 ] = 0 NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= N : NEW_LINE INDENT if is_prime [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT j = 2 * i NEW_LINE while j < N : NEW_LINE INDENT is_prime [ j ] = 0 NEW_LINE j += i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT sieve ( ) NEW_LINE c = 0 NEW_LINE if ( n < 5 ) : NEW_LINE INDENT c = 1 NEW_LINE s = "1 ▁ " NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( ( i + 1 ) != 4 ) : NEW_LINE INDENT s += "1 ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT s += "2 ▁ " NEW_LINE c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "2" ) NEW_LINE s = " " NEW_LINE i = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = i + 1 NEW_LINE if ( is_prime [ k ] == 1 ) : NEW_LINE INDENT s += "1 ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT s += "2 ▁ " NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
from __future__ import ( division , absolute_import , print_function , unicode_literals ) NEW_LINE from sys import stdin NEW_LINE import re NEW_LINE for line in stdin : NEW_LINE INDENT stack = [ ] NEW_LINE for s in line . split ( ) : NEW_LINE INDENT if re . match ( ' [ - + ] ? \ d + ' , s ) : NEW_LINE INDENT stack . append ( float ( s ) ) NEW_LINE DEDENT elif s == ' + ' : NEW_LINE INDENT n = stack . pop ( ) NEW_LINE stack [ - 1 ] += n NEW_LINE DEDENT elif s == ' - ' : NEW_LINE INDENT n = stack . pop ( ) NEW_LINE stack [ - 1 ] -= n NEW_LINE DEDENT elif s == ' * ' : NEW_LINE INDENT n = stack . pop ( ) NEW_LINE stack [ - 1 ] *= n NEW_LINE DEDENT elif s == ' / ' : NEW_LINE INDENT n = stack . pop ( ) NEW_LINE stack [ - 1 ] /= n NEW_LINE DEDENT DEDENT print ( ' { : . 6f } ' . format ( stack [ - 1 ] ) ) NEW_LINE DEDENT
num_inp = lambda : int ( input ( ) ) NEW_LINE arr_inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sp_inp = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE str_inp = lambda : input ( ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( - ( - k // n ) ) NEW_LINE
def findNthTerm ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE print ( 3 ** ( n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE N = 11 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countNonIncreasing ( arr , n ) ) ; NEW_LINE DEDENT
def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE Sum += A1 [ i ] NEW_LINE DEDENT c . sort ( ) NEW_LINE c = c [ : : - 1 ] NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += c [ i ] NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( Sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT A1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE A2 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = 5 NEW_LINE x , y = 3 , 3 NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x // 1000 > 0 : NEW_LINE INDENT print ( 10 * ( x % 10 - 1 ) + 10 ) NEW_LINE DEDENT elif x // 100 > 0 : NEW_LINE INDENT print ( 10 * ( x % 10 - 1 ) + 6 ) NEW_LINE DEDENT elif x // 10 > 0 : NEW_LINE INDENT print ( 10 * ( x % 10 - 1 ) + 3 ) NEW_LINE DEDENT else : print ( 10 * ( x % 10 - 1 ) + 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE cost = [ [ float ( ' inf ' ) ] * n for _ in range ( n ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE cost [ a - 1 ] [ b - 1 ] = c NEW_LINE cost [ b - 1 ] [ a - 1 ] = d NEW_LINE DEDENT s , g , V , P = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if cost [ i ] [ j ] > cost [ i ] [ k ] + cost [ k ] [ j ] : NEW_LINE INDENT cost [ i ] [ j ] = cost [ i ] [ k ] + cost [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( V - P - cost [ s - 1 ] [ g - 1 ] - cost [ g - 1 ] [ s - 1 ] ) NEW_LINE
r1 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE c1 , c2 = map ( int , input ( ) . split ( ) ) NEW_LINE d1 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE x = ( d1 + c1 - r2 ) // 2 NEW_LINE y = r1 - x NEW_LINE z = c1 - x NEW_LINE w = d1 - x NEW_LINE if 1 <= x <= 9 and 1 <= y <= 9 and 1 <= z <= 9 and 1 <= w <= 9 and len ( set ( [ x , y , z , w ] ) ) == 4 : NEW_LINE INDENT print ( x , y ) NEW_LINE print ( z , w ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
from bisect import bisect_left , bisect_right NEW_LINE while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Set = set ( ) NEW_LINE def go ( i , weight ) : NEW_LINE INDENT if i == m : NEW_LINE INDENT Set . add ( weight ) NEW_LINE return NEW_LINE DEDENT go ( i + 1 , weight ) NEW_LINE go ( i + 1 , weight + w [ i ] ) NEW_LINE go ( i + 1 , weight - w [ i ] ) NEW_LINE DEDENT go ( 0 , 0 ) NEW_LINE ans = False NEW_LINE for i in a : NEW_LINE INDENT if i not in Set : NEW_LINE INDENT if ans == False : NEW_LINE INDENT ans = set ( abs ( s - i ) for s in Set ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = set ( s for s in ans if i + s in Set or i - s in Set ) NEW_LINE DEDENT DEDENT DEDENT if ans == False : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT elif len ( ans ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( ans ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE m = { " A " : float ( ' inf ' ) , " B " : float ( ' inf ' ) , " C " : float ( ' inf ' ) , " AB " : float ( ' inf ' ) , " AC " : float ( ' inf ' ) , " BC " : float ( ' inf ' ) , " ABC " : float ( ' inf ' ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT inp = input ( ) NEW_LINE item = inp . split ( ' ▁ ' ) NEW_LINE l = " " . join ( sorted ( item [ 1 ] ) ) NEW_LINE m [ l ] = min ( m [ l ] , int ( item [ 0 ] ) ) NEW_LINE DEDENT res = float ( ' inf ' ) NEW_LINE res = min ( res , m [ " A " ] + m [ " B " ] + m [ " C " ] ) NEW_LINE res = min ( res , m [ " AB " ] + m [ " C " ] ) NEW_LINE res = min ( res , m [ " AC " ] + m [ " B " ] ) NEW_LINE res = min ( res , m [ " A " ] + m [ " BC " ] ) NEW_LINE res = min ( res , m [ " BC " ] + m [ " AB " ] ) NEW_LINE res = min ( res , m [ " AC " ] + m [ " BC " ] ) NEW_LINE res = min ( res , m [ " AC " ] + m [ " AB " ] ) NEW_LINE res = min ( res , m [ " ABC " ] ) NEW_LINE print ( res if res != float ( ' inf ' ) else - 1 ) NEW_LINE
def startsWith ( str , pre ) : NEW_LINE INDENT strLen = len ( str ) NEW_LINE preLen = len ( pre ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < strLen and j < preLen ) : NEW_LINE INDENT if ( str [ i ] != pre [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def endsWith ( str , suff ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if ( str [ i ] != suff [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkString ( str , a , b ) : NEW_LINE INDENT if ( len ( str ) != len ( a ) + len ( b ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( startsWith ( str , a ) ) : NEW_LINE INDENT if ( endsWith ( str , b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( startsWith ( str , b ) ) : NEW_LINE INDENT if ( endsWith ( str , a ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = " GeeksforGeeks " NEW_LINE a = " Geeksfo " NEW_LINE b = " rGeeks " NEW_LINE if ( checkString ( str , a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE
TEN = 10 NEW_LINE def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % TEN NEW_LINE n //= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( sum % TEN == 0 ) : NEW_LINE INDENT return ( n * TEN ) NEW_LINE DEDENT extra = TEN - ( sum % TEN ) NEW_LINE return ( ( n * TEN ) + extra ) NEW_LINE DEDENT def firstNTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE firstNTerms ( n ) NEW_LINE
def power ( x , a ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT x = x * x ; NEW_LINE a >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT maxProduct = 0 ; NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , int ( N / 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , int ( N / 3 ) - 1 ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , int ( N / 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT DEDENT maxProduct = breakInteger ( 10 ) ; NEW_LINE print ( maxProduct ) ; NEW_LINE
import sys NEW_LINE from itertools import accumulate NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] NEW_LINE def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] NEW_LINE def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] NEW_LINE def Yes ( ) : print ( ' Yes ' ) NEW_LINE def No ( ) : print ( ' No ' ) NEW_LINE def YES ( ) : print ( ' YES ' ) NEW_LINE def NO ( ) : print ( ' NO ' ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = 1000001 NEW_LINE table = list ( range ( N + 1 ) ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if table [ i ] == i : NEW_LINE INDENT for j in range ( i , N + 1 , i ) : NEW_LINE INDENT table [ j ] *= 1 - 1 / i NEW_LINE DEDENT DEDENT DEDENT table [ 0 ] = 1 NEW_LINE ans = list ( accumulate ( table ) ) NEW_LINE for i in range ( INT ( ) ) : NEW_LINE INDENT a = INT ( ) NEW_LINE print ( int ( ans [ a ] ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( "2018" + s [ 4 : ] ) NEW_LINE
from queue import Queue NEW_LINE def firstnonrepeating ( Str ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE q = Queue ( ) NEW_LINE charCount = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT q . put ( Str [ i ] ) NEW_LINE charCount [ ord ( Str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT if ( charCount [ ord ( q . queue [ 0 ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q . queue [ 0 ] , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( q . empty ( ) ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT MAX_CHAR = 26 NEW_LINE Str = " aabc " NEW_LINE firstnonrepeating ( Str ) NEW_LINE
from collections import defaultdict NEW_LINE n = int ( input ( ) ) NEW_LINE graph = defaultdict ( list ) NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT i , j = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE graph [ i ] . append ( j ) NEW_LINE graph [ j ] . append ( i ) NEW_LINE DEDENT left = 0 NEW_LINE right = 0 NEW_LINE color = defaultdict ( int ) NEW_LINE visited = set ( ) NEW_LINE def dfs ( node ) : NEW_LINE INDENT level = [ node ] NEW_LINE if node not in color : NEW_LINE INDENT color [ node ] = 1 NEW_LINE DEDENT while level : NEW_LINE INDENT node = level . pop ( ) NEW_LINE for val in graph [ node ] : NEW_LINE INDENT if val not in visited : NEW_LINE INDENT color [ val ] = 1 - color [ node ] NEW_LINE visited . add ( val ) NEW_LINE level . append ( val ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i not in visited : NEW_LINE INDENT visited . add ( i ) NEW_LINE dfs ( i ) NEW_LINE DEDENT DEDENT for val in range ( 1 , n + 1 ) : NEW_LINE INDENT if color [ val ] == 0 : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right += 1 NEW_LINE DEDENT DEDENT print ( left * right - n + 1 ) NEW_LINE
def solve ( n , m , obstacles , rangee ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE rangee = sorted ( rangee ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT rangee [ i ] = 2 * rangee [ i ] NEW_LINE val -= rangee [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE m = 5 NEW_LINE obstacles = 3 NEW_LINE rangee = [ 1.0 , 1.25 , 1.15 ] NEW_LINE print ( solve ( n , m , obstacles , rangee ) ) NEW_LINE
s = input ( ) NEW_LINE t = int ( input ( ) ) NEW_LINE e1 = eval ( s ) NEW_LINE e2 = int ( s [ 0 ] ) NEW_LINE i = 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT x = int ( s [ i + 1 ] ) NEW_LINE if s [ i ] == ' + ' : NEW_LINE INDENT e2 += x NEW_LINE DEDENT else : NEW_LINE INDENT e2 *= x NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if e1 == t and e2 == t : NEW_LINE INDENT print ( " U " ) NEW_LINE DEDENT elif e1 == t : NEW_LINE INDENT print ( " M " ) NEW_LINE DEDENT elif e2 == t : NEW_LINE INDENT print ( " L " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " I " ) NEW_LINE DEDENT
class MinStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . min_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . min_stack ) == 0 : NEW_LINE INDENT self . min_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if x <= self . min_stack [ - 1 ] : NEW_LINE INDENT self . min_stack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . min_stack . append ( self . min_stack [ - 1 ] ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) > 0 : NEW_LINE INDENT self . min_stack . pop ( ) NEW_LINE self . stack . pop ( ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT if len ( self . stack ) > 0 : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT return None NEW_LINE DEDENT def getMin ( self ) : NEW_LINE INDENT if len ( self . min_stack ) > 0 : NEW_LINE INDENT return self . min_stack [ - 1 ] NEW_LINE DEDENT return None NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = MinStack ( ) NEW_LINE m . push ( - 2 ) NEW_LINE m . push ( 0 ) NEW_LINE m . push ( - 3 ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE m . pop ( ) NEW_LINE print ( m . top ( ) ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE DEDENT
one = [ " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " ] ; NEW_LINE ten = [ " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = " " ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = " " ; NEW_LINE out += numToWords ( ( n // 10000000 ) , " crore ▁ " ) ; NEW_LINE out += numToWords ( ( ( n // 100000 ) % 100 ) , " lakh ▁ " ) ; NEW_LINE out += numToWords ( ( ( n // 1000 ) % 100 ) , " thousand ▁ " ) ; NEW_LINE out += numToWords ( ( ( n // 100 ) % 10 ) , " hundred ▁ " ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += " and ▁ " ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , " " ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE
def flipSign ( a ) : NEW_LINE INDENT neg = 0 ; NEW_LINE tmp = 1 if a < 0 else - 1 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT neg += tmp ; NEW_LINE a += tmp ; NEW_LINE DEDENT return neg ; NEW_LINE DEDENT def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) ; NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipSign ( b ) ; NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return mul ( b , a ) ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for i in range ( abs ( b ) , 0 , - 1 ) : NEW_LINE INDENT sum += a ; NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT sum = flipSign ( sum ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT quotient = 0 ; NEW_LINE divisor = flipSign ( abs ( b ) ) ; NEW_LINE for dividend in range ( abs ( a ) , abs ( divisor ) + divisor , divisor ) : NEW_LINE INDENT quotient += 1 ; NEW_LINE DEDENT if ( areDifferentSign ( a , b ) ) : NEW_LINE INDENT quotient = flipSign ( quotient ) ; NEW_LINE DEDENT return quotient ; NEW_LINE DEDENT print ( " Subtraction ▁ is " , sub ( 4 , - 2 ) ) ; NEW_LINE print ( " Product ▁ is " , mul ( - 9 , 6 ) ) ; NEW_LINE a , b = 8 , 2 ; NEW_LINE if ( b ) : NEW_LINE INDENT print ( " Division ▁ is " , division ( a , b ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Exception ▁ : - ▁ Divide ▁ by ▁ 0" ) ; NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE while ( n / i != n ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT num = 5 ; NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( num ) ) NEW_LINE
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( ( number % x == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE DEDENT
import collections NEW_LINE import math NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = collections . defaultdict ( int ) NEW_LINE for x in a : NEW_LINE INDENT c = 0 NEW_LINE while x > 0 : NEW_LINE INDENT c += x % 2 NEW_LINE x //= 2 NEW_LINE DEDENT d [ c ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in d . values ( ) : NEW_LINE INDENT ans += v * ( v - 1 ) // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = 1 NEW_LINE while t > 0 : NEW_LINE INDENT main ( ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( min_noOf_operation ( arr , N , k ) ) NEW_LINE
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = 2 ** n ; NEW_LINE count = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 5 , 6 , 7 ] ; NEW_LINE X = 5 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( CountSubSet ( arr , n , X ) ) ; NEW_LINE DEDENT
n = 5 NEW_LINE def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 1 ) <= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 1 ] , [ 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 1 , 0 ] , [ 9 , 6 , 4 , 2 , 3 ] ] NEW_LINE print ( FindMaxProduct ( arr , n ) ) NEW_LINE DEDENT
MAX = 50002 ; NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime = [ True ] * ( MAX ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE z = y NEW_LINE while ( x >= z ) : NEW_LINE INDENT count += ( x // z ) NEW_LINE z *= y NEW_LINE DEDENT return count NEW_LINE DEDENT def modMult ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def countWays ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , len ( primes ) ) : NEW_LINE INDENT powers = power ( n , primes [ i ] ) NEW_LINE if ( powers == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = modMult ( ans , powers + 1 , m ) % m NEW_LINE DEDENT if ( ( ( ans - 1 ) % m ) < 0 ) : NEW_LINE INDENT return ( ans - 1 + m ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans - 1 ) % m NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE n = 4 NEW_LINE m = 7 NEW_LINE print ( countWays ( n , m ) ) NEW_LINE DEDENT
def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 ; NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( smallestIndexsum ( arr , n ) ) ; NEW_LINE DEDENT
y1 , m1 , d1 = input ( ) . split ( " : " ) NEW_LINE y2 , m2 , d2 = input ( ) . split ( " : " ) NEW_LINE from datetime import * NEW_LINE date1 = datetime ( year = int ( y1 ) , month = int ( m1 ) , day = int ( d1 ) ) NEW_LINE date2 = datetime ( year = int ( y2 ) , month = int ( m2 ) , day = int ( d2 ) ) NEW_LINE res = date2 - date1 NEW_LINE print ( abs ( res . days ) ) NEW_LINE
S = input ( ) NEW_LINE totalQ = S . count ( " Q " ) NEW_LINE CQ = 0 NEW_LINE CQAQ = 0 NEW_LINE for i in S : NEW_LINE INDENT if i == " Q " : NEW_LINE INDENT CQ += 1 NEW_LINE DEDENT elif i == " A " : NEW_LINE INDENT CQAQ += CQ * ( totalQ - CQ ) NEW_LINE DEDENT DEDENT print ( CQAQ ) NEW_LINE
import sys NEW_LINE input_methods = [ ' clipboard ' , ' file ' , ' key ' ] NEW_LINE using_method = 0 NEW_LINE input_method = input_methods [ using_method ] NEW_LINE tin = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE lin = lambda : list ( tin ( ) ) NEW_LINE mod = 1000000007 NEW_LINE def main ( ) : NEW_LINE INDENT n , k = tin ( ) NEW_LINE al = lin ( ) NEW_LINE al . sort ( reverse = True ) NEW_LINE ss = sum ( al ) NEW_LINE arrive = [ 0 ] * k NEW_LINE arrive [ 0 ] = 1 NEW_LINE useful_set = set ( ) NEW_LINE for v in al : NEW_LINE INDENT ss -= v NEW_LINE u_max = 0 NEW_LINE if v >= k : NEW_LINE INDENT useful_set . add ( v ) NEW_LINE continue NEW_LINE DEDENT for i , _ in enumerate ( arrive ) : NEW_LINE INDENT p = k - i - 1 NEW_LINE is_on = arrive [ p ] NEW_LINE if is_on == 1 and p + v >= k : NEW_LINE INDENT useful_set . add ( v ) NEW_LINE u_max = k NEW_LINE DEDENT elif is_on == 1 : NEW_LINE INDENT arrive [ p + v ] = 1 NEW_LINE u_max = max ( u_max , p + v ) NEW_LINE DEDENT DEDENT if u_max + ss >= k : NEW_LINE INDENT useful_set . add ( v ) NEW_LINE DEDENT DEDENT ret = 0 NEW_LINE for v in al : NEW_LINE INDENT if v not in useful_set : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT isTest = False NEW_LINE def pa ( v ) : NEW_LINE INDENT if isTest : NEW_LINE INDENT print ( v ) NEW_LINE DEDENT DEDENT def input_clipboard ( ) : NEW_LINE INDENT import clipboard NEW_LINE input_text = clipboard . get ( ) NEW_LINE input_l = input_text . splitlines ( ) NEW_LINE for l in input_l : NEW_LINE INDENT yield l NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT if sys . platform == ' ios ' : NEW_LINE INDENT if input_method == input_methods [ 0 ] : NEW_LINE INDENT ic = input_clipboard ( ) NEW_LINE input = lambda : ic . __next__ ( ) NEW_LINE DEDENT elif input_method == input_methods [ 1 ] : NEW_LINE INDENT sys . stdin = open ( ' inputFile . txt ' ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT isTest = True NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT ret = main ( ) NEW_LINE if ret is not None : NEW_LINE INDENT print ( ret ) NEW_LINE DEDENT DEDENT
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE m = s // n NEW_LINE if s % n == 0 : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m + 1 ) NEW_LINE DEDENT
def multiply ( v , x ) : NEW_LINE INDENT carry = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + v [ i ] * x NEW_LINE v [ i ] = res % 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT v . append ( carry % 10 ) NEW_LINE carry //= 10 NEW_LINE DEDENT DEDENT def findSumOfDigits ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT multiply ( v , i ) NEW_LINE DEDENT sum = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000 NEW_LINE print ( findSumOfDigits ( n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT return nSpidersToSeeIn ( tuple ( input ( ) for _ in range ( int ( input ( ) . split ( ) [ 0 ] ) ) ) ) NEW_LINE DEDENT def nSpidersToSeeIn ( field ) : NEW_LINE INDENT return ' ▁ ' . join ( map ( str , tuple ( sum ( spiders ( field , x , y ) for y in range ( 1 , len ( field ) ) ) for x in range ( len ( field [ 0 ] ) ) ) ) ) NEW_LINE DEDENT def spiders ( field , iRow , iCol ) : NEW_LINE INDENT nSpiders = 0 NEW_LINE iRight , iLeft = iRow - iCol , iRow + iCol NEW_LINE if iRight >= 0 and field [ iCol ] [ iRight ] == ' R ' : NEW_LINE INDENT nSpiders += 1 NEW_LINE DEDENT if iLeft < len ( field [ 0 ] ) and field [ iCol ] [ iLeft ] == ' L ' : NEW_LINE INDENT nSpiders += 1 NEW_LINE DEDENT if not iCol % 2 and field [ iCol ] [ iRow ] == ' U ' : NEW_LINE INDENT nSpiders += 1 NEW_LINE DEDENT return nSpiders NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE out = [ 0 for _ in range ( n ) ] NEW_LINE comp = [ i + 2 for i in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l , r , x = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE t = l NEW_LINE while t <= r : NEW_LINE INDENT next_val = comp [ t - 1 ] NEW_LINE if out [ t - 1 ] == 0 and t != x : NEW_LINE INDENT out [ t - 1 ] = x NEW_LINE DEDENT comp [ t - 1 ] = r + 1 if t >= x else x NEW_LINE t = next_val NEW_LINE DEDENT DEDENT print ( * out ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] NEW_LINE ans = [ 0 ] * n NEW_LINE mx = arr [ - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] = max ( 0 , mx - arr [ i ] + 1 ) NEW_LINE if arr [ i ] > mx : NEW_LINE INDENT mx = arr [ i ] NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT n = 4 ; NEW_LINE print ( pell ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE i , j = 1 , n * n NEW_LINE while i < j : NEW_LINE INDENT print ( i , j ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT
def binary_search ( arr , low , high , ele ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] == ele : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > ele : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printSmall ( arr , asize , n ) : NEW_LINE INDENT copy_arr = arr . copy ( ) NEW_LINE copy_arr . sort ( ) NEW_LINE for i in range ( asize ) : NEW_LINE INDENT if binary_search ( copy_arr , low = 0 , high = n , ele = arr [ i ] ) > - 1 : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE
R = int ( input ( ) . split ( ) [ - 1 ] ) NEW_LINE best_buy = min ( map ( int , input ( ) . split ( ) ) ) NEW_LINE best_sell = max ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num_buy = R // best_buy NEW_LINE print ( max ( R , R + ( best_sell - best_buy ) * num_buy ) ) NEW_LINE
from sys import maxsize NEW_LINE maximum , x , ans = - maxsize , None , maxsize NEW_LINE graph = [ [ ] for i in range ( 100 ) ] NEW_LINE weight = [ 0 ] * 100 NEW_LINE def dfs ( node , parent ) : NEW_LINE INDENT global x , ans , graph , weight , maximum NEW_LINE a = bin ( weight [ node ] + x ) . count ( '1' ) NEW_LINE if maximum < a : NEW_LINE INDENT maximum = a NEW_LINE ans = node NEW_LINE DEDENT elif maximum == a : NEW_LINE INDENT ans = min ( ans , node ) NEW_LINE DEDENT for to in graph [ node ] : NEW_LINE INDENT if to == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 15 NEW_LINE weight [ 1 ] = 5 NEW_LINE weight [ 2 ] = 10 NEW_LINE weight [ 3 ] = 11 NEW_LINE weight [ 4 ] = 8 NEW_LINE weight [ 5 ] = 6 NEW_LINE graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 2 ] . append ( 3 ) NEW_LINE graph [ 2 ] . append ( 4 ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
MAX = 26 NEW_LINE def updateFreq ( strr , freq ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT freq [ ord ( strr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def maxCount ( strr , patt ) : NEW_LINE INDENT strrFreq = [ 0 for i in range ( MAX ) ] NEW_LINE updateFreq ( strr , strrFreq ) NEW_LINE pattFreq = [ 0 for i in range ( MAX ) ] NEW_LINE updateFreq ( patt , pattFreq ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( pattFreq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , strrFreq [ i ] // pattFreq [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT strr = " geeksforgeeks " NEW_LINE patt = " geeks " NEW_LINE print ( maxCount ( strr , patt ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = eval ( input ( ) . replace ( " ▁ " , " | " ) ) NEW_LINE b = eval ( input ( ) . replace ( " ▁ " , " | " ) ) NEW_LINE print ( a + b ) NEW_LINE
n , L , R , QL , QR = map ( int , input ( ) . split ( ) ) NEW_LINE W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_el = [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum_el . append ( W [ i - 1 ] + sum_el [ i - 1 ] ) NEW_LINE DEDENT answer = QR * ( n - 1 ) + sum_el [ n ] * R NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT energy = L * sum_el [ i ] + R * ( sum_el [ n ] - sum_el [ i ] ) NEW_LINE if i > ( n - i ) : NEW_LINE INDENT energy = energy + ( i - ( n - i ) - 1 ) * QL NEW_LINE DEDENT elif ( n - i ) > i : NEW_LINE INDENT energy = energy + ( ( n - i ) - i - 1 ) * QR NEW_LINE DEDENT if energy < answer : NEW_LINE INDENT answer = energy NEW_LINE DEDENT DEDENT print ( answer ) NEW_LINE
def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE
def maxSubStr ( str , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if count0 == count1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if count0 != count1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT str = "0100110101" NEW_LINE n = len ( str ) NEW_LINE print ( maxSubStr ( str , n ) ) NEW_LINE
a , b , c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( a , b , c ) , max ( a , b , c ) ) NEW_LINE
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def maximumAbsolute ( arr , n ) : NEW_LINE INDENT mn = 10 ** 9 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = max ( mx , arr [ i - 1 ] ) NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max ( mx , arr [ i + 1 ] ) NEW_LINE DEDENT DEDENT common_integer = ( mn + mx ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == - 1 ) : NEW_LINE INDENT arr [ i ] = common_integer NEW_LINE DEDENT DEDENT max_diff = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE if ( diff > max_diff ) : NEW_LINE INDENT max_diff = diff NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 1 , - 1 , 11 , - 1 , 3 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumAbsolute ( arr , n ) ) NEW_LINE DEDENT
MOD = 1000000007 NEW_LINE def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 ] * 3 for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 ; NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE dp [ 1 ] [ 2 ] = 0 ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( countStrings ( N ) ) NEW_LINE DEDENT
def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE print ( longest_subseq ( n , k , s ) ) NEW_LINE DEDENT main ( ) NEW_LINE
def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT Len = 2 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT Len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Len = 2 NEW_LINE DEDENT mx = max ( mx , Len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE
def minimumSubarrays ( ar , n ) : NEW_LINE INDENT se = [ ] NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if se . count ( ar [ i ] ) == 0 : NEW_LINE INDENT se . append ( ar [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE se . clear ( ) NEW_LINE se . append ( ar [ i ] ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( minimumSubarrays ( ar , n ) ) NEW_LINE
def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
_ , a = map ( int , input ( ) . split ( ) ) NEW_LINE days = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE names = 0 NEW_LINE lists = 0 NEW_LINE for i in days : NEW_LINE INDENT names += i NEW_LINE print ( names // a - lists , end = ' ▁ ' ) NEW_LINE lists += names // a - lists NEW_LINE DEDENT
MAXN = 1000005 ; NEW_LINE even = [ 0 ] * MAXN ; NEW_LINE odd = [ 0 ] * MAXN ; NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd [ i ] = 1 ; NEW_LINE DEDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even [ i ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] ; NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] ; NEW_LINE DEDENT DEDENT def isOdd ( L , R ) : NEW_LINE INDENT cnt = odd [ R ] ; NEW_LINE if ( L > 0 ) : NEW_LINE INDENT cnt -= odd [ L - 1 ] ; NEW_LINE DEDENT if ( cnt == R - L + 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def performQueries ( a , n , q , m ) : NEW_LINE INDENT precompute ( a , n ) ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT L = q [ i ] [ 0 ] ; NEW_LINE R = q [ i ] [ 1 ] ; NEW_LINE if ( isOdd ( L , R ) ) : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE q = [ [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 6 ] ] ; NEW_LINE m = len ( q ) ; NEW_LINE performQueries ( a , n , q , m ) ; NEW_LINE DEDENT
tests = int ( input ( ) ) NEW_LINE for _ in range ( tests ) : NEW_LINE INDENT windows = int ( input ( ) ) NEW_LINE test = True NEW_LINE for k in range ( ( windows // 3 + 1 ) ) : NEW_LINE INDENT if test : NEW_LINE INDENT for j in range ( ( windows // 5 + 1 ) ) : NEW_LINE INDENT if test : NEW_LINE INDENT for i in range ( ( windows // 7 + 1 ) ) : NEW_LINE INDENT if i * 7 + j * 5 + k * 3 == windows : NEW_LINE INDENT print ( k , j , i ) NEW_LINE test = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if test : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def solve ( m , n , o , p , hhmm ) : NEW_LINE INDENT h = int ( hhmm [ 0 ] + hhmm [ 1 ] ) NEW_LINE m = int ( hhmm [ 3 ] + hhmm [ 4 ] ) NEW_LINE lft = h * 60 + m NEW_LINE rt = lft + n NEW_LINE i = 30 * 10 NEW_LINE ans = 0 NEW_LINE while i < 1440 : NEW_LINE INDENT if i < rt and i + p > lft : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i += o NEW_LINE DEDENT return ans NEW_LINE DEDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE o , p = map ( int , input ( ) . split ( ) ) NEW_LINE hhmm = input ( ) NEW_LINE print ( solve ( m , n , o , p , hhmm ) ) NEW_LINE
i = input ; l = 3 NEW_LINE for _ in [ 0 ] * int ( i ( ) ) : NEW_LINE INDENT x = int ( i ( ) ) NEW_LINE if x == l : print ( ' NO ' ) ; exit ( ) NEW_LINE l ^= x NEW_LINE DEDENT print ( ' YES ' ) NEW_LINE
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT steps = [ 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 ] NEW_LINE n = len ( steps ) NEW_LINE print ( times ( steps , n ) ) NEW_LINE
D = 360 NEW_LINE x = [ 0 for i in range ( D ) ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m , d , v , s = map ( int , input ( ) . split ( ) ) NEW_LINE m -= 1 NEW_LINE d -= 1 NEW_LINE start = 30 * m + d NEW_LINE end = ( start + v - 1 ) % D NEW_LINE h = [ False for _ in range ( D ) ] NEW_LINE for j in range ( v ) : NEW_LINE INDENT y = ( start + j ) % D NEW_LINE h [ y ] = True NEW_LINE DEDENT for j in range ( D ) : NEW_LINE INDENT if h [ j ] : NEW_LINE INDENT x [ j ] = max ( x [ j ] , s ) NEW_LINE DEDENT else : NEW_LINE INDENT A = abs ( start - j ) NEW_LINE if A > D // 2 : NEW_LINE INDENT A = D - A NEW_LINE DEDENT B = abs ( end - j ) NEW_LINE if B > D // 2 : NEW_LINE INDENT B = D - B NEW_LINE DEDENT x [ j ] = max ( x [ j ] , s - min ( A , B ) ) NEW_LINE DEDENT DEDENT DEDENT print ( min ( x ) ) NEW_LINE
print ( ( ' Um _ nik ' , ' Petr ' ) [ int ( input ( ) ) // 1000 <= sum ( i == x for i , x in enumerate ( map ( int , input ( ) . split ( ) ) , 1 ) ) ] ) NEW_LINE
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE gr1 = [ 2 ] NEW_LINE gr2 = [ 4 , 6 , 9 , 11 ] NEW_LINE if x in gr1 : NEW_LINE INDENT x_gr = 1 NEW_LINE DEDENT elif x in gr2 : NEW_LINE INDENT x_gr = 2 NEW_LINE DEDENT else : NEW_LINE INDENT x_gr = 3 NEW_LINE DEDENT if y in gr1 : NEW_LINE INDENT y_gr = 1 NEW_LINE DEDENT elif y in gr2 : NEW_LINE INDENT y_gr = 2 NEW_LINE DEDENT else : NEW_LINE INDENT y_gr = 3 NEW_LINE DEDENT if x_gr == y_gr : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE Sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( Sum > k ) : NEW_LINE INDENT while ( Sum > k ) : NEW_LINE INDENT Sum = Sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE
n = input ( ) NEW_LINE b = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if n [ i ] == "1" : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE
def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( str ( n ) + " th ▁ palindrome ▁ of ▁ " + str ( k ) + " ▁ digit ▁ = ▁ " , end = " " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE print ( ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( str ( n ) + " th ▁ palindrome ▁ of ▁ " + str ( k ) + " ▁ digit ▁ = ▁ " , end = " " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE print ( ) NEW_LINE DEDENT
import array NEW_LINE from bisect import * NEW_LINE from collections import * NEW_LINE import fractions NEW_LINE import heapq NEW_LINE from itertools import * NEW_LINE import math NEW_LINE import random NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE Xs = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Ys = Xs [ : : - 1 ] NEW_LINE Y_sum = [ 0 ] * N NEW_LINE Y_sum [ 0 ] = Ys [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Y_sum [ i ] = Y_sum [ i - 1 ] + Ys [ i ] NEW_LINE DEDENT ans = 1e100 NEW_LINE for rep_num in range ( 1 , N + 1 ) : NEW_LINE INDENT local_ans = X * rep_num NEW_LINE local_ans += 5 * Y_sum [ rep_num - 1 ] NEW_LINE i = 2 * rep_num - 1 NEW_LINE n = 1 NEW_LINE while i <= N - 1 : NEW_LINE INDENT local_ans += ( 2 * n + 3 ) * ( Y_sum [ i ] - Y_sum [ i - rep_num ] ) NEW_LINE n += 1 NEW_LINE i += rep_num NEW_LINE DEDENT local_ans += ( 2 * n + 3 ) * ( Y_sum [ N - 1 ] - Y_sum [ i - rep_num ] ) NEW_LINE ans = min ( ans , local_ans ) NEW_LINE DEDENT print ( ans + N * X ) NEW_LINE
MAX = 10000 NEW_LINE hashTable = [ 0 ] * MAX NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
p1 , p2 , p3 , p4 , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if min ( p1 , p2 , p3 , p4 ) > a and min ( p1 , p2 , p3 , p4 ) <= b : NEW_LINE INDENT print ( min ( p1 , p2 , p3 , p4 ) - a ) NEW_LINE DEDENT elif min ( p1 , p2 , p3 , p4 ) > b and min ( p1 , p2 , p3 , p4 ) > a and a != b : NEW_LINE INDENT print ( b - a + 1 ) NEW_LINE DEDENT elif a == b and min ( p1 , p2 , p3 , p4 ) > a : NEW_LINE INDENT print ( min ( p1 , p2 , p3 , p4 ) - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 = n % 10 NEW_LINE n1 = n // 10 NEW_LINE d0 = d % 10 NEW_LINE d1 = d // 10 NEW_LINE if ( n1 == d0 and n0 * d == n * d1 ) or ( n0 == d1 and n1 * d == n * d0 ) : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom // fractions . gcd ( numer , denom ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPascal ( n ) ) NEW_LINE
for _ in [ 0 ] * int ( input ( ) ) : a , b , x , y = map ( int , input ( ) . split ( ) ) ; print ( max ( b * x , b * ( a - x - 1 ) , a * y , a * ( b - y - 1 ) ) ) NEW_LINE
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ * enumerate ( arr ) ] NEW_LINE arrpos . sort ( key = lambda it : it [ 1 ] ) NEW_LINE vis = { k : False for k in range ( n ) } NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vis [ i ] or arrpos [ i ] [ 0 ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] [ 0 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT if cycle_size > 0 : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 5 , 4 , 3 , 2 ] NEW_LINE print ( minSwaps ( arr ) ) NEW_LINE
N = 1000005 NEW_LINE prime = [ True for i in range ( N ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while ( num ) : NEW_LINE INDENT if ( prime [ num ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while ( num // power ) : NEW_LINE INDENT if ( prime [ num % power ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 25 NEW_LINE sieve ( ) NEW_LINE print ( sumTruncatablePrimes ( n ) ) NEW_LINE
def findWeights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = pow ( 3 , power + 1 ) - 1 NEW_LINE sum //= 2 NEW_LINE power += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " ▁ " ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT X = 2 NEW_LINE findWeights ( X ) NEW_LINE
def addToArrayForm ( A , K ) : NEW_LINE INDENT v , ans = [ ] , [ ] NEW_LINE rem , i = 0 , 0 NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT my = A [ i ] + ( K % 10 ) + rem NEW_LINE if my > 9 : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( my ) NEW_LINE rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT while K > 0 : NEW_LINE INDENT my = ( K % 10 ) + rem NEW_LINE v . append ( my % 10 ) NEW_LINE if my // 10 > 0 : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT if rem > 0 : NEW_LINE INDENT v . append ( rem ) NEW_LINE DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( v [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 7 , 4 ] NEW_LINE K = 181 NEW_LINE ans = addToArrayForm ( A , K ) NEW_LINE for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printPaths ( inputchar , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( inputchar , " " , 0 , i , R , C ) ; NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( inputchar , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = " ▁ " ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + inputchar [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( inputchar , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT inputchar = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( inputchar ) ; NEW_LINE C = len ( inputchar [ 0 ] ) ; NEW_LINE printPaths ( inputchar , R , C ) ; NEW_LINE DEDENT
def assign_room ( direction , hotel ) : NEW_LINE INDENT if direction == " L " : NEW_LINE INDENT for x in range ( 10 ) : NEW_LINE INDENT if hotel [ x ] == 0 : NEW_LINE INDENT hotel [ x ] = "1" NEW_LINE return hotel NEW_LINE DEDENT DEDENT DEDENT elif direction == " R " : NEW_LINE INDENT for x in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if hotel [ x ] == 0 : NEW_LINE INDENT hotel [ x ] = "1" NEW_LINE return hotel NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT hotel [ int ( direction ) ] = 0 NEW_LINE return hotel NEW_LINE DEDENT DEDENT rooms = [ 0 ] * 10 NEW_LINE n = int ( input ( " " ) ) NEW_LINE instructions = input ( " " ) NEW_LINE for x in instructions : NEW_LINE INDENT assign_room ( x , rooms ) NEW_LINE DEDENT for x in rooms : NEW_LINE INDENT print ( x , end = " " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a1 , b1 = map ( int , input ( ) . split ( ) ) NEW_LINE if max ( a , b ) == max ( a1 , b1 ) : NEW_LINE INDENT if min ( a , b ) + min ( a1 , b1 ) == max ( a , b ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def precisionCompute ( x , y , n ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT print ( " Infinite " ) ; NEW_LINE return ; NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) ; NEW_LINE return ; NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT print ( x // y ) ; NEW_LINE return ; NEW_LINE DEDENT if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : NEW_LINE INDENT print ( " - " , end = " " ) ; NEW_LINE if x <= 0 : NEW_LINE INDENT x = - x ; NEW_LINE DEDENT if y <= 0 : NEW_LINE INDENT y = - y ; NEW_LINE DEDENT DEDENT d = x // y ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( d , end = " " ) ; NEW_LINE x = x - ( y * d ) ; NEW_LINE if x == 0 : NEW_LINE INDENT break ; NEW_LINE DEDENT x = x * 10 ; NEW_LINE d = x // y ; NEW_LINE if ( i == 0 ) : NEW_LINE INDENT print ( " . " , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT x = 22 ; NEW_LINE y = 7 ; NEW_LINE n = 15 ; NEW_LINE precisionCompute ( x , y , n ) ; NEW_LINE print ( ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) ; NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT s = [ ] NEW_LINE q = [ ] NEW_LINE elements = 0 NEW_LINE def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT def printSpecificLevelOrder ( self , root ) : NEW_LINE INDENT self . s . append ( root ) NEW_LINE prnt = self . s . pop ( 0 ) NEW_LINE self . q . append ( prnt . data ) NEW_LINE if prnt . right : NEW_LINE INDENT self . s . append ( root . right ) NEW_LINE DEDENT if prnt . left : NEW_LINE INDENT self . s . append ( root . left ) NEW_LINE DEDENT while ( len ( self . s ) > 0 ) : NEW_LINE INDENT first = self . s . pop ( 0 ) NEW_LINE self . q . append ( first . data ) NEW_LINE second = self . s . pop ( 0 ) NEW_LINE self . q . append ( second . data ) NEW_LINE if first . left and second . right and first . right and second . left : NEW_LINE INDENT self . s . append ( first . left ) NEW_LINE self . s . append ( second . right ) NEW_LINE self . s . append ( first . right ) NEW_LINE self . s . append ( second . left ) NEW_LINE DEDENT DEDENT for elements in reversed ( self . q ) : NEW_LINE INDENT print ( elements , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( " Specific ▁ Level ▁ Order ▁ Traversal ▁ of ▁ Binary ▁ Tree ▁ is " ) NEW_LINE root . printSpecificLevelOrder ( root ) NEW_LINE
def hollowSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( i == 1 or i == rows ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( j == 1 or j == rows ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT def solidSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def printPattern ( rows ) : NEW_LINE INDENT print ( " Solid ▁ Square : " ) NEW_LINE solidSquare ( rows ) NEW_LINE print ( " \n Hollow ▁ Square : " ) NEW_LINE hollowSquare ( rows ) NEW_LINE DEDENT rows = 5 NEW_LINE printPattern ( rows ) NEW_LINE
from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def solution ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( " abcd " * ( n // 4 ) + " abc " [ : n % 4 ] ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT import sys NEW_LINE import threading NEW_LINE sys . setrecursionlimit ( 1 << 30 ) NEW_LINE threading . stack_size ( 1 << 27 ) NEW_LINE thread = threading . Thread ( target = main ) NEW_LINE thread . start ( ) ; thread . join ( ) NEW_LINE
import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlsts ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def words ( ) : return [ i for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE def chars ( ) : return [ i for i in sys . stdin . readline ( ) . strip ( ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT n = inp ( ) NEW_LINE t = [ ] ; w = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = values ( ) NEW_LINE t . append ( a ) ; w . append ( b ) NEW_LINE DEDENT sm = sum ( t ) NEW_LINE cnt = sum ( w ) NEW_LINE dp = [ - float ( ' inf ' ) ] * ( sm + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( sm , t [ i ] - 1 , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , dp [ j - t [ i ] ] + w [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( dp ) ) : NEW_LINE INDENT rem = cnt - dp [ i ] NEW_LINE if dp [ i ] > 0 and rem <= i : print ( i ) ; break NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= x and x <= a + b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from math import gcd as __gcd NEW_LINE def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLargest ( arr , n ) ) NEW_LINE DEDENT
def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 ; NEW_LINE findWinner ( n ) ; NEW_LINE DEDENT
from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal " " ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . BFS ( 2 ) NEW_LINE
from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal " " ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . BFS ( 2 ) NEW_LINE
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 1 for i in range ( n + 1 ) ] NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 13 , 2 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE a = 5 NEW_LINE getElements ( a , arr , n ) NEW_LINE
__author__ = ' Tianren ▁ Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( R , P , S ) : NEW_LINE INDENT if ( R < 0 or P < 0 or S < 0 ) : NEW_LINE INDENT return " IMPOSSIBLE " NEW_LINE DEDENT if R + P + S == 1 : NEW_LINE INDENT return ' R ' if R > 0 else ' P ' if P > 0 else ' S ' NEW_LINE DEDENT Rn , Pn , Sn = ( R + S - P ) // 2 , ( P - S + R ) // 2 , ( - R + S + P ) // 2 NEW_LINE if ( Rn > R or Pn > P or Sn > S ) : NEW_LINE INDENT return " IMPOSSIBLE " NEW_LINE DEDENT res = solve ( Rn , Pn , Sn ) NEW_LINE if res == " IMPOSSIBLE " : NEW_LINE INDENT return " IMPOSSIBLE " NEW_LINE DEDENT else : NEW_LINE INDENT nres = ' ' NEW_LINE m = { ' R ' : ' RS ' , ' S ' : ' SP ' , ' P ' : ' PR ' } NEW_LINE for c in res : NEW_LINE INDENT nres += m [ c ] NEW_LINE DEDENT return nres NEW_LINE DEDENT DEDENT def asort ( S ) : NEW_LINE INDENT if S == " IMPOSSIBLE " : NEW_LINE INDENT return S NEW_LINE DEDENT l = len ( S ) NEW_LINE if l > 1 : NEW_LINE INDENT Sl = asort ( S [ : l // 2 ] ) NEW_LINE Sh = asort ( S [ l // 2 : ] ) NEW_LINE S = Sl + Sh if Sl < Sh else Sh + Sl NEW_LINE DEDENT return S NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , R , P , S = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE print ( " Case ▁ # { } : ▁ { } " . format ( t + 1 , asort ( solve ( R , P , S ) ) ) ) NEW_LINE DEDENT DEDENT
I = input NEW_LINE n , m = map ( int , I ( ) . split ( ) ) NEW_LINE b = [ 1 ] * n * 2 NEW_LINE b [ 0 ] = b [ n - 1 ] = b [ n ] = b [ 2 * n - 1 ] = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT r , c = map ( int , I ( ) . split ( ) ) NEW_LINE b [ r - 1 ] = b [ n + c - 1 ] = 0 NEW_LINE DEDENT if n % 2 and b [ n // 2 ] and b [ n + n // 2 ] : b [ n // 2 ] = 0 NEW_LINE print ( sum ( b ) ) NEW_LINE
import math NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 ; NEW_LINE P = 1 ; NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = math . sqrt ( S * S - 4 * P ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : " , ( int ) ( x ) , " & " , ( int ) ( y ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * fact ( n - 1 ) ) NEW_LINE DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
import math NEW_LINE primes = [ ] NEW_LINE for p in range ( 2 , 10001 ) : NEW_LINE INDENT for m in range ( 2 , math . floor ( math . sqrt ( p ) ) + 1 ) : NEW_LINE INDENT if p % m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT targ = int ( input ( ) ) NEW_LINE while targ != 0 : NEW_LINE INDENT ans = 0 NEW_LINE for p in range ( len ( primes ) ) : NEW_LINE INDENT if primes [ p ] > targ : NEW_LINE INDENT break NEW_LINE DEDENT tempsum = 0 NEW_LINE for l in range ( p , len ( primes ) ) : NEW_LINE INDENT tempsum += primes [ l ] NEW_LINE if tempsum > targ : NEW_LINE INDENT break NEW_LINE DEDENT elif tempsum == targ : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE targ = int ( input ( ) ) NEW_LINE DEDENT
from math import atan2 , pi NEW_LINE N , * XY = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE XY = list ( zip ( * [ iter ( XY ) ] * 2 ) ) NEW_LINE for i , ( x , y ) in enumerate ( XY ) : NEW_LINE INDENT D = sorted ( atan2 ( X - x , Y - y ) for j , ( X , Y ) in enumerate ( XY ) if j != i ) NEW_LINE D . append ( D [ 0 ] + 2 * pi ) NEW_LINE ans = 0 NEW_LINE for a , b in zip ( D , D [ 1 : ] ) : NEW_LINE INDENT if b - a >= pi : NEW_LINE INDENT ans = ( b - a ) - pi NEW_LINE DEDENT DEDENT print ( ans / ( 2 * pi ) ) NEW_LINE DEDENT
alp = [ ' * * * * * * * * * * * * ' , ' * qwertyuiop * ' , ' * asdfghjkl * * ' , ' * zxcvbnm * * * * ' , ' * * * * * * * * * * * * ' ] NEW_LINE _alp = ' ' . join ( alp ) NEW_LINE def check ( now , nxt ) : NEW_LINE INDENT a , b = _alp . find ( now ) // 12 , _alp . find ( now ) % 12 NEW_LINE c , d = _alp . find ( nxt ) // 12 , _alp . find ( nxt ) % 12 NEW_LINE q1 = _log [ - 1 ] NEW_LINE q2 = ' L ' if d <= 5 else ' R ' NEW_LINE log . append ( q2 ) NEW_LINE if abs ( a - c ) + abs ( b - d ) <= 1 : NEW_LINE INDENT _log . append ( q1 ) NEW_LINE DEDENT else : NEW_LINE INDENT _log . append ( q2 ) NEW_LINE DEDENT DEDENT while 1 : NEW_LINE INDENT s = input ( ) NEW_LINE if s == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT log = [ ' L ' if _alp . find ( s [ 0 ] ) % 12 <= 5 else ' R ' ] NEW_LINE _log = [ log [ 0 ] ] NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT check ( s [ i ] , s [ i + 1 ] ) NEW_LINE DEDENT count = 0 NEW_LINE for x , y in zip ( log , _log ) : NEW_LINE INDENT if x != y : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT c = log [ 0 ] NEW_LINE ans = 0 NEW_LINE for v in log : NEW_LINE INDENT if c != v : NEW_LINE INDENT c = v NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
length , tour = input ( ) , input ( ) NEW_LINE print ( ' YES ' if tour . count ( ' SF ' ) > tour . count ( ' FS ' ) else ' NO ' ) NEW_LINE
bigres = [ ] NEW_LINE t = int ( input ( ) ) NEW_LINE for m in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE res = a [ 0 ] * a [ 1 ] NEW_LINE for q in range ( len ( a ) - 1 ) : NEW_LINE INDENT res = max ( res , ( a [ q ] * a [ q + 1 ] ) ) NEW_LINE DEDENT bigres += [ res ] NEW_LINE DEDENT for i in range ( len ( bigres ) ) : NEW_LINE INDENT print ( bigres [ i ] ) NEW_LINE DEDENT
def __gcd ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT small = y NEW_LINE DEDENT else : NEW_LINE INDENT small = x NEW_LINE DEDENT for i in range ( 1 , small + 1 ) : NEW_LINE INDENT if ( ( x % i == 0 ) and ( y % i == 0 ) ) : NEW_LINE INDENT gcd = i NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) / __gcd ( a , b ) ; NEW_LINE DEDENT def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = int ( n / a - ( m - 1 ) / a ) NEW_LINE b_divisor = int ( n / b - ( m - 1 ) / b ) NEW_LINE common_divisor = int ( n / lcm - ( m - 1 ) / lcm ) NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT m = 3 NEW_LINE n = 11 NEW_LINE a = 2 NEW_LINE b = 3 ; NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE m = 11 NEW_LINE n = 1000000 NEW_LINE a = 6 NEW_LINE b = 35 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE
s = input ( ) NEW_LINE t = ' , . ? ! ' NEW_LINE for i in t : s = s . replace ( i , i + ' ▁ ' ) NEW_LINE s = ' ▁ ' . join ( s . strip ( ) . split ( ) ) NEW_LINE for i in t : s = s . replace ( ' ▁ ' + i , i ) NEW_LINE print ( s ) NEW_LINE
from collections import defaultdict NEW_LINE import sys NEW_LINE def smallestKFreq ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE res1 = sys . maxsize NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == k : NEW_LINE INDENT res = min ( res , key ) NEW_LINE DEDENT DEDENT return res if res != res1 else - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( smallestKFreq ( arr , n , k ) ) NEW_LINE
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbddeecc " NEW_LINE if areVowelsInOrder ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
INF = 10 ** 20 NEW_LINE MAX_INT = 10 ** 6 NEW_LINE a = [ INF ] * MAX_INT NEW_LINE b = [ INF ] * MAX_INT NEW_LINE a [ 0 ] , b [ 0 ] = 0 , 0 NEW_LINE for i in range ( 1 , 200 ) : NEW_LINE INDENT t = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE mm = min ( t * 5 , MAX_INT ) NEW_LINE for j in range ( t , mm ) : NEW_LINE INDENT if a [ j ] > a [ j - t ] + 1 : NEW_LINE INDENT a [ j ] = a [ j - t ] + 1 NEW_LINE DEDENT DEDENT if t % 2 == 0 : continue NEW_LINE for j in range ( t , MAX_INT ) : NEW_LINE INDENT if b [ j ] > b [ j - t ] + 1 : NEW_LINE INDENT b [ j ] = b [ j - t ] + 1 NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : exit ( ) NEW_LINE print ( a [ N ] , b [ N ] ) NEW_LINE DEDENT
def countOfLetters ( string ) : NEW_LINE INDENT letter = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ( string [ i ] >= ' A ' and string [ i ] <= ' Z ' ) or ( string [ i ] >= ' a ' and string [ i ] <= ' z ' ) ) : NEW_LINE INDENT letter += 1 ; NEW_LINE DEDENT DEDENT return letter ; NEW_LINE DEDENT def countOfNumbers ( string ) : NEW_LINE INDENT number = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] >= '0' and string [ i ] <= '9' ) : NEW_LINE INDENT number += 1 ; NEW_LINE DEDENT DEDENT return number ; NEW_LINE DEDENT def check ( string ) : NEW_LINE INDENT if ( countOfLetters ( string ) == countOfNumbers ( string ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeKs01324" ; NEW_LINE check ( string ) ; NEW_LINE DEDENT
lis = [ ] NEW_LINE cnt = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n : NEW_LINE INDENT cnt += 1 NEW_LINE lis . append ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( lis . pop ( cnt - 1 ) ) NEW_LINE cnt -= 1 NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
N , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 1 or x == 2 * N - 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE l = [ i for i in range ( 1 , 2 * N ) ] NEW_LINE l . remove ( x - 1 ) NEW_LINE l . remove ( x ) NEW_LINE l . remove ( x + 1 ) NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT print ( l [ i ] ) NEW_LINE DEDENT print ( x - 1 ) NEW_LINE print ( x ) NEW_LINE print ( x + 1 ) NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT print ( l [ N - 2 + i ] ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE perfectDiv = [ 0 ] * MAX NEW_LINE def precomputeCounts ( ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i < MAX : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE DEDENT
N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( A ) * sum ( B ) ) NEW_LINE
n , t , e = map ( int , input ( ) . split ( ) ) NEW_LINE xlst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i , x in enumerate ( xlst ) : NEW_LINE INDENT a = ( t - e - 1 ) // x NEW_LINE if ( a + 1 ) * x <= t + e : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
from math import ceil NEW_LINE def cal_IST ( h , r ) : NEW_LINE INDENT IST = round ( ( h * r * 1.0 ) / 360 , 3 ) ; NEW_LINE int_IST = int ( IST ) ; NEW_LINE float_IST = ceil ( ( IST - int_IST ) * 60 ) ; NEW_LINE print ( str ( int_IST ) + " : " + str ( float_IST ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT h = 20 ; NEW_LINE r = 150 ; NEW_LINE cal_IST ( h , r ) ; NEW_LINE DEDENT
import math NEW_LINE def printRoots ( n ) : NEW_LINE INDENT theta = math . pi * 2 / n NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( " { : . 3 f } " . format ( real ) , end = " " ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " " ) NEW_LINE DEDENT print ( " { : . 3 f } " . format ( abs ( img ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT printRoots ( 1 ) NEW_LINE printRoots ( 2 ) NEW_LINE printRoots ( 3 ) NEW_LINE DEDENT
def findCart ( arr1 , arr2 , n , n1 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n1 ) : NEW_LINE INDENT print ( " { " , arr1 [ i ] , " , ▁ " , arr2 [ j ] , " } , ▁ " , sep = " " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE findCart ( arr1 , arr2 , n1 , n2 ) ; NEW_LINE
def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE count_right = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 ; NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE SumOfKthPrimes ( arr , n , k ) ; NEW_LINE
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( Sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE SieveOfEratosthenes ( ) NEW_LINE n , k = 5 , 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE solve ( arr , n , k ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def productOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE productOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT
def findAllSequences ( diff , out , start , end ) : NEW_LINE INDENT if ( abs ( diff ) > ( end - start + 1 ) // 2 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT print ( ' ' . join ( list ( out ) ) , end = " ▁ " ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT out [ start ] = '0' ; NEW_LINE out [ end ] = '1' ; NEW_LINE findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = out [ end ] = '1' ; NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = out [ end ] = '0' ; NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = '1' ; NEW_LINE out [ end ] = '0' ; NEW_LINE findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE out = [ " " ] * ( 2 * n ) ; NEW_LINE findAllSequences ( 0 , out , 0 , 2 * n - 1 ) NEW_LINE print ( ) NEW_LINE
def check ( h , high ) : NEW_LINE INDENT h . sort ( ) NEW_LINE summ = 0 NEW_LINE for i in range ( len ( h ) - 1 , - 1 , - 2 ) : NEW_LINE INDENT summ += h [ i ] NEW_LINE DEDENT return summ <= high NEW_LINE DEDENT n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = - 1 NEW_LINE r = len ( a ) + 1 NEW_LINE while r - l > 1 : NEW_LINE INDENT m = ( r + l ) // 2 NEW_LINE if check ( a [ : m ] , h ) : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , " - > " , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " NULL " ) NEW_LINE DEDENT def cntNodes ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cntNodes ( node . next ) ) NEW_LINE DEDENT def updateList ( head , m ) : NEW_LINE INDENT cnt = cntNodes ( head ) NEW_LINE if ( cnt != m and m < cnt ) : NEW_LINE INDENT skip = cnt - m NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while ( skip > 0 ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE skip -= 1 NEW_LINE DEDENT prev . next = None NEW_LINE tempHead = head NEW_LINE head = curr NEW_LINE while ( curr . next != None ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT curr . next = tempHead NEW_LINE DEDENT printList ( head ) NEW_LINE DEDENT head = newNode ( 4 ) NEW_LINE head . next = newNode ( 5 ) NEW_LINE head . next . next = newNode ( 6 ) NEW_LINE head . next . next . next = newNode ( 1 ) NEW_LINE head . next . next . next . next = newNode ( 2 ) NEW_LINE head . next . next . next . next . next = newNode ( 3 ) NEW_LINE m = 3 NEW_LINE updateList ( head , m ) NEW_LINE
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 27 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " aaacaabbaa " NEW_LINE k = 2 NEW_LINE print ( maxSubStrings ( s , k ) ) NEW_LINE DEDENT
N = 100 NEW_LINE def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE l . sort ( reverse = True ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if l [ i ] >= l [ i - 1 ] : NEW_LINE INDENT if l [ i - 1 ] == 0 : NEW_LINE INDENT l [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT l [ i ] = l [ i - 1 ] - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l [ i ] = l [ i ] NEW_LINE DEDENT DEDENT print ( sum ( l ) ) NEW_LINE
for p in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n % 2 : NEW_LINE INDENT x , y = n // 2 , n // 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x , y = n // 2 - 1 , n // 2 + 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n * k , 2 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT d , s = x * k , 0 NEW_LINE while d < ( n * k ) : NEW_LINE INDENT s += a [ d ] NEW_LINE d += y NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT
n , r = input ( ) . split ( ' ▁ ' ) NEW_LINE stack = [ [ ] for _ in range ( int ( n ) ) ] NEW_LINE for _ in range ( int ( r ) ) : NEW_LINE INDENT row = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE c = row [ 0 ] NEW_LINE i = row [ 1 ] NEW_LINE if c == 0 : NEW_LINE INDENT stack [ i ] . append ( row [ 2 ] ) NEW_LINE DEDENT if stack [ i ] : NEW_LINE INDENT if c == 1 : NEW_LINE INDENT print ( stack [ i ] [ - 1 ] ) NEW_LINE DEDENT if c == 2 : NEW_LINE INDENT stack [ i ] . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] ; NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) ; NEW_LINE DEDENT printArray ( arr , n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE modifyArray ( arr , n , k ) ; NEW_LINE DEDENT
def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( " { : . 3 f } " . format ( ans [ 0 ] ) , " { : . 3 f } " . format ( ans [ 1 ] ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE color = ' blue ' NEW_LINE block = 0 NEW_LINE i = 0 NEW_LINE while i != n : NEW_LINE INDENT command = str ( input ( ) ) NEW_LINE if command == ' lock ' : NEW_LINE INDENT block = 1 NEW_LINE DEDENT elif command == ' unlock ' : NEW_LINE INDENT block = 0 NEW_LINE DEDENT elif block == 0 : NEW_LINE INDENT color = command NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( color ) NEW_LINE
def minOperations ( ar , k ) : NEW_LINE INDENT ar = sorted ( ar ) NEW_LINE opsNeeded = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT opsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = opsNeeded NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , opsNeeded ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 1 , 9 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minOperations ( arr , k ) ) NEW_LINE
def charCheck ( input_char ) : NEW_LINE INDENT if ( ( int ( ord ( input_char ) ) >= 65 and int ( ord ( input_char ) ) <= 90 ) or ( int ( ord ( input_char ) ) >= 97 and int ( ord ( input_char ) ) <= 122 ) ) : NEW_LINE INDENT print ( " ▁ Alphabet ▁ " ) NEW_LINE DEDENT elif ( int ( ord ( input_char ) ) >= 48 and int ( ord ( input_char ) ) <= 57 ) : NEW_LINE INDENT print ( " ▁ Digit ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Special ▁ Character ▁ " ) NEW_LINE DEDENT DEDENT input_char = ' $ ' NEW_LINE charCheck ( input_char ) NEW_LINE
n = int ( input ( ) ) NEW_LINE mat = [ [ ] for i in range ( n ) ] NEW_LINE b = [ int ( j ) - 1 for j in str ( input ( ) ) . split ( ' ▁ ' ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mat [ i ] . append ( b [ i ] ) NEW_LINE DEDENT i = 0 NEW_LINE h = ' ' NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT l = [ 0 for j in range ( n ) ] NEW_LINE a = i NEW_LINE while True : NEW_LINE INDENT l [ a ] += 1 NEW_LINE if l [ a ] > 1 : NEW_LINE INDENT break NEW_LINE DEDENT a = mat [ a ] [ 0 ] NEW_LINE DEDENT m = 0 NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT if l [ j ] > m : NEW_LINE INDENT m = l [ j ] NEW_LINE x = j + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT h = h + str ( x ) + ' ▁ ' NEW_LINE i = i + 1 NEW_LINE DEDENT print ( h ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a - 1 ] . append ( b ) NEW_LINE d [ b - 1 ] . append ( a ) NEW_LINE DEDENT x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if len ( d [ i ] ) > 1 : NEW_LINE INDENT for i1 in range ( len ( d [ i ] ) ) : NEW_LINE INDENT for i2 in range ( i1 + 1 , len ( d [ i ] ) ) : NEW_LINE INDENT if ( i + 1 in d [ d [ i ] [ i1 ] - 1 ] ) and ( d [ i ] [ i2 ] in d [ d [ i ] [ i1 ] - 1 ] ) and ( i + 1 in d [ d [ i ] [ i2 ] - 1 ] ) and ( d [ i ] [ i1 ] in d [ d [ i ] [ i2 ] - 1 ] ) : NEW_LINE INDENT z = ( i + 1 , d [ i ] [ i1 ] , d [ i ] [ i2 ] ) NEW_LINE x . append ( z ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT c1 = 1e9 NEW_LINE for a , b , c in x : NEW_LINE INDENT c1 = min ( c1 , w [ a - 1 ] + w [ b - 1 ] + w [ c - 1 ] ) NEW_LINE DEDENT print ( c1 if c1 != 1e9 else - 1 ) NEW_LINE
u = input NEW_LINE n , k = map ( int , u ( ) . split ( ) ) NEW_LINE M = [ int ( i ) for i in u ( ) . split ( ) ] NEW_LINE m = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT for p in range ( n ) : NEW_LINE INDENT if ( 0 == M [ p ] ) : NEW_LINE INDENT print ( p + 1 , end = ' ▁ ' ) NEW_LINE break NEW_LINE DEDENT DEDENT for l in range ( p + 1 - k ) : M [ l ] -= 1 NEW_LINE M [ p ] -= 1 NEW_LINE DEDENT
import math NEW_LINE import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE rows = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = [ ] NEW_LINE cords = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT r . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE for j in range ( rows [ i ] ) : NEW_LINE INDENT cords [ r [ i ] [ j ] ] = [ i , j ] NEW_LINE DEDENT DEDENT it = 1 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( rows [ i ] ) : NEW_LINE INDENT if r [ i ] [ j ] != it : NEW_LINE INDENT tmp = [ cords [ it ] [ 0 ] , cords [ it ] [ 1 ] ] NEW_LINE r [ i ] [ j ] , r [ cords [ it ] [ 0 ] ] [ cords [ it ] [ 1 ] ] = r [ cords [ it ] [ 0 ] ] [ cords [ it ] [ 1 ] ] , r [ i ] [ j ] NEW_LINE cords [ r [ cords [ it ] [ 0 ] ] [ cords [ it ] [ 1 ] ] ] = tmp * 1 NEW_LINE ans . append ( [ i , j , cords [ it ] [ 0 ] , cords [ it ] [ 1 ] ] ) NEW_LINE DEDENT it += 1 NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j + 1 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ctX = 0 NEW_LINE ctY = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT ctX += 1 ; NEW_LINE DEDENT elif ( arr [ j ] == y ) : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT if ( ctX == ctY ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while ( t ) : NEW_LINE INDENT t -= 1 NEW_LINE s = input ( ) NEW_LINE n = len ( s ) NEW_LINE ct = 0 NEW_LINE for i in s : NEW_LINE INDENT if ( i == "0" ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT if ( ct < n - ct ) : NEW_LINE INDENT print ( ct ) NEW_LINE DEDENT elif ( ct > n - ct ) : NEW_LINE INDENT print ( n - ct ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n != 2 ) : NEW_LINE INDENT print ( ct - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT
input ( ) NEW_LINE c = 0 NEW_LINE f = { } NEW_LINE for x in input ( ) . split ( ) : f [ x ] = d = f . get ( x , 0 ) + 1 ; c += d % 2 * 2 - 1 NEW_LINE print ( [ ' Agasa ' , ' Conan ' ] [ c > 0 ] ) NEW_LINE
a = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT
target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total ▁ number ▁ of ▁ triplets ▁ found : ' , totalCount ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( * [ 1 , 1 ] ) NEW_LINE print ( - l [ 0 ] ) NEW_LINE print ( * [ 1 , 1 ] ) NEW_LINE print ( 0 ) NEW_LINE print ( * [ 1 , 1 ] ) NEW_LINE print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * [ 1 , 1 ] ) NEW_LINE print ( - l [ 0 ] ) NEW_LINE print ( * [ 1 , n ] ) NEW_LINE x = [ 0 for _ in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x [ i ] = - l [ i ] * n NEW_LINE DEDENT print ( * x ) NEW_LINE print ( * [ 2 , n ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] = ( n - 1 ) * l [ i ] NEW_LINE DEDENT print ( * x [ 1 : ] ) NEW_LINE DEDENT
from math import gcd as __gcd NEW_LINE def finalNum ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in arr : NEW_LINE INDENT result = __gcd ( result , i ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( finalNum ( arr , n ) ) NEW_LINE
N = 1000 NEW_LINE def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ [ ] for i in range ( n ) ] NEW_LINE if n == 1 : return a [ 0 ] NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT while len ( v [ steps ] ) > 1 : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if steps & 1 : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE index , value , a [ 0 ] = 0 , 2 , 2 NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE index , value = 3 , 5 NEW_LINE value = 5 NEW_LINE a [ index ] = value NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE DEDENT
def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) // 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE
import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE def pin ( type = int ) : return map ( type , input ( ) . split ( ) ) NEW_LINE def tupin ( t = int ) : return tuple ( pin ( t ) ) NEW_LINE def lispin ( t = int ) : return list ( pin ( t ) ) NEW_LINE from collections import Counter NEW_LINE def resolve ( ) : NEW_LINE INDENT S = input ( ) NEW_LINE c = Counter ( S ) NEW_LINE print ( ( c [ " g " ] - c [ " p " ] ) // 2 ) NEW_LINE DEDENT resolve ( ) NEW_LINE
def pattern ( N ) : NEW_LINE INDENT k , space , rows = 0 , 1 , N NEW_LINE for i in range ( rows , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT if i != rows : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT space += 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if j != rows : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def pathSumHelper ( self , root , target , so_far , cache ) : NEW_LINE INDENT if root : NEW_LINE INDENT complement = so_far + root . val - target NEW_LINE if complement in cache : NEW_LINE INDENT self . result += cache [ complement ] NEW_LINE DEDENT cache [ so_far + root . val ] = cache . get ( so_far + root . val , 0 ) + 1 NEW_LINE self . pathSumHelper ( root . left , target , so_far + root . val , cache ) NEW_LINE self . pathSumHelper ( root . right , target , so_far + root . val , cache ) NEW_LINE cache [ so_far + root . val ] -= 1 NEW_LINE DEDENT return NEW_LINE DEDENT def pathSum ( self , root , sum ) : NEW_LINE INDENT self . result = 0 NEW_LINE self . pathSumHelper ( root , sum , 0 , { 0 : 1 } ) NEW_LINE return self . result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE tree = TreeNode ( 10 ) NEW_LINE tree . left = TreeNode ( 5 ) NEW_LINE tree . right = TreeNode ( - 3 ) NEW_LINE tree . left . left = TreeNode ( 3 ) NEW_LINE tree . left . right = TreeNode ( 2 ) NEW_LINE tree . right . right = TreeNode ( 11 ) NEW_LINE tree . left . left . left = TreeNode ( 3 ) NEW_LINE tree . left . left . right = TreeNode ( - 2 ) NEW_LINE tree . left . right . right = TreeNode ( 1 ) NEW_LINE s = 8 NEW_LINE out = sObj . pathSum ( tree , s ) ; NEW_LINE print ( out ) NEW_LINE DEDENT
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " Case ▁ " + str ( i + 1 ) + " : " ) NEW_LINE num = int ( input ( ) ) NEW_LINE for j in range ( 0 , 10 ) : NEW_LINE INDENT num *= num NEW_LINE sn = str ( num ) NEW_LINE if len ( sn ) < 8 : NEW_LINE INDENT d = 8 - len ( sn ) NEW_LINE for k in range ( d ) : NEW_LINE INDENT sn = "0" + sn NEW_LINE DEDENT DEDENT num = int ( sn [ 2 : 6 ] ) NEW_LINE print ( num ) NEW_LINE DEDENT DEDENT
MAX = 250000 NEW_LINE SQRT = 500 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 2 , MAX , 2 ) : prime [ i ] = False NEW_LINE for i in range ( 3 , SQRT , 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT sieve ( ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans , m = 0 , n << 1 NEW_LINE if n == 1 : ans += 1 NEW_LINE i = n + 1 NEW_LINE if ( i & 1 ) == 0 : i += 1 NEW_LINE while i <= m : NEW_LINE INDENT if prime [ i ] : ans += 1 NEW_LINE i += 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxVal ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxOR ( arr , n ) ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT if len ( J ) == 0 or len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j_set = set ( J ) NEW_LINE ans = 0 NEW_LINE for c in S : NEW_LINE INDENT if c in j_set : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE J = " aA " NEW_LINE S = " aAAbbbb " NEW_LINE out = sObj . numJewelsInStones ( J , S ) NEW_LINE print ( out ) NEW_LINE DEDENT
MAX = 100 ; NEW_LINE n = 0 ; NEW_LINE store = [ 0 ] * MAX ; NEW_LINE graph = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] ; NEW_LINE d = [ 0 ] * MAX ; NEW_LINE def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT def maxCliques ( i , l ) : NEW_LINE INDENT max_ = 0 ; NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j ; NEW_LINE if ( is_clique ( l + 1 ) ) : NEW_LINE INDENT max_ = max ( max_ , l ) ; NEW_LINE max_ = max ( max_ , maxCliques ( j , l + 1 ) ) ; NEW_LINE DEDENT DEDENT return max_ ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] ; NEW_LINE size = len ( edges ) ; NEW_LINE n = 4 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; NEW_LINE graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; NEW_LINE d [ edges [ i ] [ 0 ] ] += 1 ; NEW_LINE d [ edges [ i ] [ 1 ] ] += 1 ; NEW_LINE DEDENT print ( maxCliques ( 0 , 1 ) ) ; NEW_LINE DEDENT
import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 2 ** k NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE
R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , m , s , f = R ( ) NEW_LINE if s < f : NEW_LINE INDENT d = 1 NEW_LINE c = ' R ' NEW_LINE DEDENT else : NEW_LINE INDENT d = - 1 NEW_LINE c = ' L ' NEW_LINE DEDENT res = " " NEW_LINE i = 1 NEW_LINE j = s NEW_LINE t , l , r = R ( ) NEW_LINE k = 1 NEW_LINE while j != f : NEW_LINE INDENT if i > t and k < m : NEW_LINE INDENT t , l , r = R ( ) NEW_LINE k += 1 NEW_LINE DEDENT if i == t and ( l <= j <= r or l <= j + d <= r ) : NEW_LINE INDENT res += ' X ' NEW_LINE DEDENT else : NEW_LINE INDENT res += c NEW_LINE j += d NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( res ) NEW_LINE
def subsetPairNotDivisibleByK ( arr , N , K ) : NEW_LINE INDENT f = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , ( K // 2 ) + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( subsetPairNotDivisibleByK ( arr , N , K ) ) NEW_LINE
import sys NEW_LINE def main ( lines ) : NEW_LINE INDENT w , m , k = list ( map ( int , lines [ 0 ] . split ( ) ) ) NEW_LINE max_length = 0 NEW_LINE available_digits = int ( w / k ) NEW_LINE while available_digits > 0 : NEW_LINE INDENT current_cost_per_n = len ( str ( m ) ) NEW_LINE same_cost_until = 10 ** ( current_cost_per_n ) NEW_LINE usable_numbers = same_cost_until - m NEW_LINE use_digits = usable_numbers * current_cost_per_n NEW_LINE m = same_cost_until NEW_LINE if available_digits >= use_digits : NEW_LINE INDENT max_length += usable_numbers NEW_LINE available_digits -= use_digits NEW_LINE DEDENT else : NEW_LINE INDENT max_length += int ( available_digits / current_cost_per_n ) NEW_LINE available_digits = 0 NEW_LINE DEDENT DEDENT print ( max_length ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( sys . stdin . readlines ( ) ) NEW_LINE DEDENT
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( str ( 1 ) + " , ▁ " + str ( c / ( a * 1.0 ) ) ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE c = - 5 NEW_LINE printRoots ( a , b , c ) NEW_LINE
memo = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 2 ) ] for k in range ( 32 ) ] NEW_LINE def dp ( pos , fl , pr , bin ) : NEW_LINE INDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) : NEW_LINE INDENT return memo [ pos ] [ fl ] [ pr ] ; NEW_LINE DEDENT val = 0 NEW_LINE if ( bin [ pos ] == '0' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , fl , 0 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , 1 , 0 , bin ) NEW_LINE DEDENT if ( pr == 0 ) : NEW_LINE INDENT if ( fl == 1 ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT DEDENT memo [ pos ] [ fl ] [ pr ] = val NEW_LINE return val NEW_LINE DEDENT def findIntegers ( num ) : NEW_LINE INDENT bin = " " NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( num % 2 ) : NEW_LINE INDENT bin += "1" NEW_LINE DEDENT else : NEW_LINE INDENT bin += "0" NEW_LINE DEDENT num //= 2 NEW_LINE DEDENT bin = bin [ : : - 1 ] ; NEW_LINE return dp ( 0 , 0 , 0 , bin ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE print ( findIntegers ( N ) ) NEW_LINE DEDENT
N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT
def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash1 . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPair ( n ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE createHash ( hash1 , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i in hash1 and ( n - i ) in hash1 ) : NEW_LINE INDENT print ( str ( i ) + " , ▁ " + str ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 90 NEW_LINE findFibonacciPair ( N ) NEW_LINE DEDENT
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE
import sys NEW_LINE def maxLength ( s , n ) : NEW_LINE INDENT ans = - ( sys . maxsize + 1 ) ; NEW_LINE A , L , R = [ ] , [ ] , [ ] ; NEW_LINE freq = [ 0 ] * ( n + 5 ) ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT freq [ j ] = count ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) ; NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) ; NEW_LINE DEDENT max_len = - ( sys . maxsize + 1 ) ; NEW_LINE min_val = sys . maxsize ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) ; NEW_LINE A . append ( min_val ) ; NEW_LINE l = 0 ; r = j ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 ; NEW_LINE if ( A [ mid ] <= R [ j ] ) : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) ; NEW_LINE r = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) ; NEW_LINE A . clear ( ) ; NEW_LINE R . clear ( ) ; NEW_LINE L . clear ( ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababbbacbcbcca " ; NEW_LINE n = len ( s ) ; NEW_LINE print ( maxLength ( s , n ) ) ; NEW_LINE DEDENT
N = 100005 NEW_LINE gr = [ [ ] for i in range ( N ) ] NEW_LINE colour = [ - 1 ] * N NEW_LINE edges = [ ] NEW_LINE bip = True NEW_LINE def add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE edges . append ( ( x , y ) ) NEW_LINE DEDENT def dfs ( x , col ) : NEW_LINE INDENT colour [ x ] = col NEW_LINE global bip NEW_LINE for i in gr [ x ] : NEW_LINE INDENT if colour [ i ] == - 1 : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT elif colour [ i ] == col : NEW_LINE INDENT bip = False NEW_LINE DEDENT DEDENT DEDENT def Directed_Graph ( n , m ) : NEW_LINE INDENT dfs ( 1 , 1 ) NEW_LINE if not bip : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if colour [ edges [ i ] [ 0 ] ] == 0 : NEW_LINE INDENT edges [ i ] [ 0 ] , edges [ i ] [ 1 ] = edges [ i ] [ 1 ] , edges [ i ] [ 0 ] NEW_LINE DEDENT print ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m = 4 , 3 NEW_LINE add_edge ( 1 , 2 ) NEW_LINE add_edge ( 1 , 3 ) NEW_LINE add_edge ( 1 , 4 ) NEW_LINE Directed_Graph ( n , m ) NEW_LINE DEDENT
input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = set ( l ) NEW_LINE if any ( i % 2 == 0 for i in s ) and any ( i % 2 != 0 for i in s ) : NEW_LINE INDENT l . sort ( ) NEW_LINE DEDENT print ( * l ) NEW_LINE
k , n , w = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , w + 1 ) : NEW_LINE INDENT sum += k * i NEW_LINE DEDENT if sum <= n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum - n ) NEW_LINE DEDENT
def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( not isPrime ( k ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE DEDENT
a = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE n , k = map ( int , input ( ) . split ( ) ) ; t = a [ : 2 ] * n NEW_LINE if k > n or ( k == 1 and n != 1 ) : print ( - 1 ) NEW_LINE elif n == 1 : print ( ' a ' ) NEW_LINE else : print ( t [ : n - k + 2 ] + a [ 2 : k ] ) NEW_LINE
global maxn NEW_LINE maxn = 16 NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ - 1 for i in range ( maxn ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE v = [ 4 , 6 , 9 ] NEW_LINE for i in range ( 1 , maxn , 1 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = v [ k ] NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT def Maximum_Summands ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = int ( ( n - maxn ) / 4 ) + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE dp = precompute ( ) NEW_LINE print ( Maximum_Summands ( dp , n ) ) NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is " , int ( countSquares ( n ) ) ) NEW_LINE
from collections import defaultdict NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE al = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE modd = defaultdict ( int ) NEW_LINE s = 0 NEW_LINE for a in al : NEW_LINE INDENT s += a NEW_LINE s %= m NEW_LINE modd [ s ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in modd . values ( ) : NEW_LINE INDENT ans += i * ( i - 1 ) // 2 NEW_LINE DEDENT ans += modd [ 0 ] NEW_LINE print ( ans ) NEW_LINE
import sys ; NEW_LINE def FindSubarray ( arr , n , k ) : NEW_LINE INDENT count_one = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_one [ i ] = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE DEDENT sum = count_one [ 0 ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT if ( count_one [ 0 ] >= k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT ans = sys . maxsize ; NEW_LINE i = 1 ; NEW_LINE j = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( k == count_one [ j ] ) : NEW_LINE INDENT ans = 1 ; NEW_LINE break ; NEW_LINE DEDENT elif ( k == count_one [ i ] ) : NEW_LINE INDENT ans = 1 ; NEW_LINE break ; NEW_LINE DEDENT elif ( sum + count_one [ i ] < k ) : NEW_LINE INDENT sum += count_one [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT elif ( sum + count_one [ i ] > k ) : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) ; NEW_LINE sum -= count_one [ j ] ; NEW_LINE j += 1 ; NEW_LINE DEDENT elif ( sum + count_one [ i ] == k ) : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) ; NEW_LINE sum += count_one [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT if ( ans != sys . maxsize ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( FindSubarray ( arr , n , k ) ) ; NEW_LINE DEDENT
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( " Loss ▁ = " , " { : . 3 f } " . format ( loss ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT
N , M , X = map ( int , input ( ) . split ( ) ) NEW_LINE A = sum ( int ( i ) < X for i in input ( ) . split ( ) ) NEW_LINE print ( min ( A , M - A ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE sushi = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE res = 0 NEW_LINE before , after = 0 , 0 NEW_LINE cur = sushi [ 0 ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if sushi [ i ] == cur : NEW_LINE INDENT before += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = i NEW_LINE jS = sushi [ j ] NEW_LINE cur = sushi [ j ] NEW_LINE while j < n and sushi [ j ] == jS : NEW_LINE INDENT after += 1 NEW_LINE j += 1 NEW_LINE DEDENT i = j NEW_LINE res = max ( res , min ( before , after ) ) NEW_LINE before = after NEW_LINE after = 0 NEW_LINE DEDENT DEDENT print ( res * 2 ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10000000 ) if get_terminal ( i ) == 89 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT TERMINALS = ( 1 , 89 ) NEW_LINE def get_terminal ( n ) : NEW_LINE INDENT while n not in TERMINALS : NEW_LINE INDENT n = square_digit_sum ( n ) NEW_LINE DEDENT return n NEW_LINE DEDENT def square_digit_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n > 0 : NEW_LINE INDENT result += SQUARE_DIGITS_SUM [ n % 1000 ] NEW_LINE n //= 1000 NEW_LINE DEDENT return result NEW_LINE DEDENT SQUARE_DIGITS_SUM = [ sum ( int ( c ) ** 2 for c in str ( i ) ) for i in range ( 1000 ) ] NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) ; NEW_LINE DEDENT return fact ( len ( distinct_char ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countStrings ( string , n ) ) ; NEW_LINE DEDENT
M = 4 NEW_LINE N = 5 NEW_LINE def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] in mp . keys ( ) and mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 1 , 4 , 8 ] , [ 3 , 7 , 8 , 5 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] , [ 8 , 1 , 2 , 7 , 9 ] ] NEW_LINE printCommonElements ( mat ) NEW_LINE
import sys NEW_LINE import time NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE from functools import lru_cache NEW_LINE INF = 10 ** 18 + 3 NEW_LINE EPS = 1e-10 NEW_LINE MAX_CACHE = 10 ** 9 NEW_LINE def time_it ( function , output = sys . stderr ) : NEW_LINE INDENT def wrapped ( * args , ** kwargs ) : NEW_LINE INDENT start = time . time ( ) NEW_LINE res = function ( * args , ** kwargs ) NEW_LINE elapsed_time = time . time ( ) - start NEW_LINE print ( ' " % s " ▁ took ▁ % f ▁ ms ' % ( function . __name__ , elapsed_time * 1000 ) , file = output ) NEW_LINE return res NEW_LINE DEDENT return wrapped NEW_LINE DEDENT @ time_it NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x1 , x2 = map ( int , input ( ) . split ( ) ) NEW_LINE funcs = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT k , b = map ( int , input ( ) . split ( ) ) NEW_LINE funcs . append ( lambda x , k = k , b = b : k * x + b ) NEW_LINE DEDENT comp = lambda x : lambda i : funcs [ i ] ( x ) NEW_LINE sorted1 = sorted ( range ( n ) , key = comp ( x1 + EPS ) ) NEW_LINE sorted2 = sorted ( range ( n ) , key = comp ( x2 - EPS ) ) NEW_LINE print ( " Yes " if sorted1 != sorted2 else " No " ) NEW_LINE DEDENT def set_input ( file ) : NEW_LINE INDENT global input NEW_LINE input = lambda : file . readline ( ) . strip ( ) NEW_LINE DEDENT def set_output ( file ) : NEW_LINE INDENT global print NEW_LINE local_print = print NEW_LINE def print ( * args , ** kwargs ) : NEW_LINE INDENT kwargs [ " file " ] = kwargs . get ( " file " , file ) NEW_LINE return local_print ( * args , ** kwargs ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set_input ( open ( " input . txt " , " r " ) if " MINE " in sys . argv else sys . stdin ) NEW_LINE set_output ( sys . stdout ) NEW_LINE main ( ) NEW_LINE DEDENT
import math NEW_LINE def line2int ( linea ) : NEW_LINE INDENT temp = " " NEW_LINE for i in linea : NEW_LINE INDENT if i == " ▁ " : NEW_LINE INDENT if temp != " " : NEW_LINE INDENT val1 = int ( temp ) NEW_LINE temp = " " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = temp + i NEW_LINE DEDENT DEDENT val2 = int ( temp ) NEW_LINE return ( val1 , val2 ) NEW_LINE DEDENT ( n , t ) = line2int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ( salida , intervalo ) = line2int ( input ( ) ) NEW_LINE if salida < t : NEW_LINE INDENT salida = salida + ( math . ceil ( ( t - salida ) / intervalo ) * intervalo ) NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT out = [ i + 1 , salida ] NEW_LINE DEDENT elif salida < out [ 1 ] : NEW_LINE INDENT out = [ i + 1 , salida ] NEW_LINE DEDENT DEDENT print ( out [ 0 ] ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE
def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( " No ▁ such ▁ triplet ▁ found " ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( small ) + " ▁ " + str ( large ) + " ▁ " + str ( arr [ i ] ) ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " ▁ " ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE rem = [ 0 ] * K ; NEW_LINE rem [ 0 ] = N // K ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 ; NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in rage ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 ; K = 4 ; NEW_LINE print ( findPairCount ( N , K ) ) ; NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : break NEW_LINE if n > 0 : a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if m > 0 : b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = i = j = 0 NEW_LINE s , t = 0 , - 1 NEW_LINE while i < n or j < m : NEW_LINE INDENT if i < n : NEW_LINE INDENT if s == a [ i ] : i += 1 NEW_LINE if i < n : t = a [ i ] NEW_LINE DEDENT if j < m : NEW_LINE INDENT if s == b [ j ] : j += 1 NEW_LINE if j < m and ( t < 0 or b [ j ] < t ) : t = b [ j ] NEW_LINE DEDENT if t >= 0 : NEW_LINE INDENT if i < n and t == a [ i ] : i += 1 NEW_LINE if j < m and t == b [ j ] : j += 1 NEW_LINE ans = max ( ans , t - s ) NEW_LINE s , t = t , - 1 NEW_LINE DEDENT DEDENT if t >= 0 : ans = max ( ans , t - s ) NEW_LINE print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = max ( arr ) NEW_LINE arr_sum = sum ( arr ) NEW_LINE if arr_sum - x >= x and arr_sum % 2 == 0 : print ( ' YES ' ) NEW_LINE else : print ( ' NO ' ) NEW_LINE
PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT n = 9 NEW_LINE print ( str ( n ) + " th ▁ Fibonacci ▁ Number ▁ = ▁ " + str ( fib ( n ) ) ) NEW_LINE
def kthSmallest ( n , k ) : NEW_LINE INDENT return 2 * k NEW_LINE DEDENT n = 8 ; k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE
def printSumTricky ( mat , k ) : NEW_LINE INDENT global n NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ None ] * n for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = Sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = Sum NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT Sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( Sum , end = " ▁ " ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( Sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumTricky ( mat , k ) NEW_LINE
M = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE a = M [ 0 ] NEW_LINE b = M [ 1 ] NEW_LINE n = M [ 2 ] NEW_LINE if a != 0 : NEW_LINE INDENT if b % a != 0 : NEW_LINE INDENT print ( ' No ▁ solution ' ) NEW_LINE DEDENT else : NEW_LINE INDENT b = b // a NEW_LINE x , y = 0 , - 2000 NEW_LINE if b >= 0 : NEW_LINE INDENT while y < b : NEW_LINE INDENT y = pow ( x , n ) NEW_LINE x = x + 1 NEW_LINE DEDENT if y > b : NEW_LINE INDENT print ( ' No ▁ solution ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( ' No ▁ solution ' ) NEW_LINE DEDENT else : NEW_LINE INDENT x = - 1 NEW_LINE y = 2000 NEW_LINE while y > b : NEW_LINE INDENT y = pow ( x , n ) NEW_LINE x = x - 1 NEW_LINE DEDENT if y < b : NEW_LINE INDENT print ( ' No ▁ solution ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ▁ solution ' ) NEW_LINE DEDENT DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE DEDENT X = 4 NEW_LINE Y = 3 NEW_LINE M = 6 NEW_LINE W = 5 NEW_LINE print ( totalWays ( X , Y , M , W ) ) NEW_LINE
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n and ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if n == a or n == a - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == a - 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE DEDENT
N , P = map ( int , input ( ) . split ( ) ) NEW_LINE def combi ( N , K ) : NEW_LINE INDENT a = 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT a *= N - i NEW_LINE DEDENT for j in range ( K ) : NEW_LINE INDENT a /= j + 1 NEW_LINE DEDENT return a NEW_LINE DEDENT ans = 0 NEW_LINE lis = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ls = [ ] NEW_LINE for a in lis : NEW_LINE INDENT ls . append ( a % 2 ) NEW_LINE DEDENT one = ls . count ( 1 ) NEW_LINE zero = ls . count ( 0 ) NEW_LINE pattern_a = 0 NEW_LINE pattern_b = 0 NEW_LINE for j in range ( zero + 1 ) : NEW_LINE INDENT pattern_b += combi ( zero , j ) NEW_LINE DEDENT time = 0 NEW_LINE while time <= one : NEW_LINE INDENT if time % 2 == P : NEW_LINE INDENT pattern_a += combi ( one , time ) NEW_LINE DEDENT time += 1 NEW_LINE DEDENT print ( int ( pattern_a * pattern_b ) ) NEW_LINE
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 1000 ; r = 6000 NEW_LINE print ( countNumbers ( l , r ) ) NEW_LINE
import math NEW_LINE def findGreater ( a , b ) : NEW_LINE INDENT x = a * ( math . log ( b ) ) ; NEW_LINE y = b * ( math . log ( a ) ) ; NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( " a ^ b ▁ is ▁ greater " ) ; NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( " b ^ a ▁ is ▁ greater " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Both ▁ are ▁ equal " ) ; NEW_LINE DEDENT DEDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE c = 2 ; NEW_LINE d = 4 ; NEW_LINE findGreater ( a , b ) ; NEW_LINE findGreater ( c , d ) ; NEW_LINE
import math as mt NEW_LINE def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l , r = 0 , 0 NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( r < l ) : NEW_LINE INDENT return 26 * ( n + 1 ) NEW_LINE DEDENT elif ( l == r ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i - 1 ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] != str2 [ i ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT str1 = " toy " NEW_LINE str2 = " try " NEW_LINE n = len ( str1 ) NEW_LINE print ( findAnswer ( str1 , str2 , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for p in range ( t ) : NEW_LINE INDENT n , x , m = map ( int , input ( ) . split ( ) ) NEW_LINE L = x NEW_LINE R = x NEW_LINE for i in range ( m ) : NEW_LINE INDENT l , r = ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if l <= R and r >= L : NEW_LINE INDENT L = min ( L , l ) NEW_LINE R = max ( R , r ) NEW_LINE DEDENT DEDENT print ( R - L + 1 ) NEW_LINE DEDENT
def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) ; NEW_LINE prev = num & 1 ; NEW_LINE num = num >> 1 ; NEW_LINE for i in range ( 1 , ( r - l ) ) : NEW_LINE INDENT curr = num & 1 ; NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT prev = curr ; NEW_LINE num = num >> 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 18 ; NEW_LINE l = 1 ; NEW_LINE r = 3 ; NEW_LINE if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
import sys NEW_LINE i = sys . stdin . readline NEW_LINE n , m = map ( int , i ( ) . split ( ) ) NEW_LINE sa = i ( ) . count ( " - " ) NEW_LINE sa = min ( [ n - sa , sa ] ) NEW_LINE ss = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , i ( ) . split ( ) ) NEW_LINE b -= a NEW_LINE ss . append ( ( b % 2 and b <= sa << 1 ) and "1 \n " or "0 \n " ) NEW_LINE DEDENT print ( " " . join ( ss ) ) NEW_LINE
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = 0 NEW_LINE r , c = 0 , - 1 NEW_LINE dl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tl = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if c < 0 and tl . count ( 0 ) : NEW_LINE INDENT r = i NEW_LINE c = tl . index ( 0 ) NEW_LINE DEDENT dl += [ tl ] NEW_LINE DEDENT s = sum ( dl [ ( r + 1 ) % n ] ) NEW_LINE a = s - sum ( dl [ r ] ) NEW_LINE dl [ r ] [ c ] = a NEW_LINE if n > 1 and a < 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if s != sum ( dl [ i ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT dl = list ( map ( list , zip ( * dl ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s != sum ( dl [ i ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT s1 = s2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 += dl [ i ] [ i ] NEW_LINE s2 += dl [ i ] [ n - i - 1 ] NEW_LINE DEDENT if not ( s1 == s2 == s ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT a = 1 NEW_LINE DEDENT print ( a ) NEW_LINE
import sched NEW_LINE def inp ( ) : NEW_LINE INDENT return ( int ( input ( ) ) ) NEW_LINE DEDENT def inlt ( ) : NEW_LINE INDENT return ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT def insr ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE return ( list ( s [ : len ( s ) - 1 ] ) ) NEW_LINE DEDENT def invr ( ) : NEW_LINE INDENT return ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT days , minWalks = inlt ( ) NEW_LINE schedule = inlt ( ) NEW_LINE additionalWalks = 0 NEW_LINE for i , value in enumerate ( schedule ) : NEW_LINE INDENT if i != len ( schedule ) - 1 : NEW_LINE INDENT if value + schedule [ i + 1 ] < minWalks : NEW_LINE INDENT missingWalks = minWalks - ( value + schedule [ i + 1 ] ) NEW_LINE additionalWalks = additionalWalks + missingWalks NEW_LINE schedule [ i + 1 ] = schedule [ i + 1 ] + missingWalks NEW_LINE DEDENT DEDENT DEDENT print ( additionalWalks ) NEW_LINE print ( * schedule ) NEW_LINE
MAX = 1000000 NEW_LINE def maximumOccurredElement ( L , R , n ) : NEW_LINE INDENT arr = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 NEW_LINE arr [ R [ i ] + 1 ] -= 1 NEW_LINE DEDENT msum = arr [ 0 ] NEW_LINE for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if ( msum < arr [ i ] ) : NEW_LINE INDENT msum = arr [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = [ 1 , 4 , 9 , 13 , 21 ] NEW_LINE R = [ 15 , 8 , 12 , 20 , 30 ] NEW_LINE n = len ( L ) NEW_LINE print ( maximumOccurredElement ( L , R , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE back = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT p = input ( ) NEW_LINE if p [ : : - 1 ] == back : count += 1 NEW_LINE back = p NEW_LINE DEDENT print ( count + 1 ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n < 1 : NEW_LINE INDENT if m < 1 : NEW_LINE INDENT print ( n , m ) NEW_LINE quit ( ) NEW_LINE DEDENT print ( " Impossible " ) NEW_LINE quit ( ) NEW_LINE DEDENT if m > n : NEW_LINE INDENT min = m NEW_LINE max = n + m - 1 NEW_LINE print ( min , max ) NEW_LINE DEDENT if m <= n : NEW_LINE INDENT min = n NEW_LINE max = n + m - 1 NEW_LINE if m == 0 : NEW_LINE INDENT max = n NEW_LINE DEDENT print ( min , max ) NEW_LINE DEDENT
def func ( x ) : NEW_LINE INDENT return ( float ( 1 ) / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT interval_size = ( float ( upper_limit - lower_limit ) / interval_limit ) NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) ; NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( ( float ( 3 * interval_size ) / 8 ) * sum ) NEW_LINE DEDENT interval_limit = 10 NEW_LINE lower_limit = 1 NEW_LINE upper_limit = 10 NEW_LINE integral_res = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( " { : . 4 f } " . format ( integral_res ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE X = int ( input ( ) ) NEW_LINE Y = int ( input ( ) ) NEW_LINE if N <= K : NEW_LINE INDENT print ( int ( N * X ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( K * X + ( N - K ) * Y ) ) NEW_LINE DEDENT
import math NEW_LINE while True : NEW_LINE INDENT x = float ( input ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT h = float ( input ( ) ) NEW_LINE l = math . sqrt ( 0.25 * x ** 2 + h ** 2 ) NEW_LINE print ( x ** 2 + 2 * x * l ) NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE i = 10 NEW_LINE while k : NEW_LINE INDENT i += 9 NEW_LINE if sum ( map ( int , str ( i ) ) ) == 10 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE n = 20 NEW_LINE printPrimeQuad ( 20 ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = " ABCD " NEW_LINE y = " BACDBDCD " NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT
from collections import defaultdict as dd NEW_LINE st = dd ( int ) NEW_LINE av = dd ( int ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE se = set ( ) NEW_LINE for i in s : NEW_LINE INDENT se . add ( i . lower ( ) ) NEW_LINE DEDENT for i in t : NEW_LINE INDENT av [ i ] += 1 NEW_LINE DEDENT for i in s : NEW_LINE INDENT st [ i ] += 1 NEW_LINE DEDENT y , w = 0 , 0 NEW_LINE for i in se : NEW_LINE INDENT j = i . upper ( ) NEW_LINE a , b = min ( st [ i ] , av [ i ] ) , min ( st [ j ] , av [ j ] ) NEW_LINE y += a + b NEW_LINE st [ i ] -= a NEW_LINE st [ j ] -= b NEW_LINE av [ i ] -= a NEW_LINE av [ j ] -= b NEW_LINE c , d = min ( st [ i ] , av [ j ] ) , min ( st [ j ] , av [ i ] ) NEW_LINE w += c + d NEW_LINE DEDENT print ( y , w ) NEW_LINE
MAX = 1000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 6 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE n = 100 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE DEDENT
MAX = 10000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE i = n - 1 ; NEW_LINE while ( sequence [ i + 1 ] != 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE i = i - sequence [ i + 1 ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 5 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE DEDENT
MAX = 10000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sequence [ i ] == nthTerm ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 5 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE DEDENT
import math NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) / int ( math . gcd ( a , b ) ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = ( int ( mid / a ) + int ( mid / b ) - int ( mid / lcm ) ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return int ( max ( int ( mid / a ) * a , int ( mid / b ) * b ) ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE
import calendar NEW_LINE y = int ( input ( ) ) NEW_LINE is_run = calendar . isleap ( y ) NEW_LINE week = calendar . weekday ( y , 1 , 1 ) NEW_LINE while True : NEW_LINE INDENT y = y + 1 NEW_LINE if calendar . isleap ( y ) == is_run and calendar . weekday ( y , 1 , 1 ) == week : NEW_LINE INDENT print ( y ) NEW_LINE break NEW_LINE DEDENT DEDENT
N = int ( input ( ) ) NEW_LINE base = [ 0 ] * 3 NEW_LINE out = 0 NEW_LINE point = 0 NEW_LINE inning = 0 NEW_LINE while True : NEW_LINE INDENT event = input ( ) NEW_LINE if event == " HIT " : NEW_LINE INDENT if base [ 2 ] == 1 : NEW_LINE INDENT point += 1 NEW_LINE DEDENT base [ 2 ] = base [ 1 ] NEW_LINE base [ 1 ] = base [ 0 ] NEW_LINE base [ 0 ] = 1 NEW_LINE DEDENT elif event == " HOMERUN " : NEW_LINE INDENT point += sum ( base ) + 1 NEW_LINE base = [ 0 ] * 3 NEW_LINE DEDENT elif event == " OUT " : NEW_LINE INDENT out += 1 NEW_LINE if out == 3 : NEW_LINE INDENT print ( point ) NEW_LINE inning += 1 NEW_LINE if inning == N : NEW_LINE INDENT break NEW_LINE DEDENT base = [ 0 ] * 3 NEW_LINE out = 0 NEW_LINE point = 0 NEW_LINE DEDENT DEDENT DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def findValue ( x , y , z ) : NEW_LINE INDENT g = __gcd ( y , z ) NEW_LINE return ( x * g ) / __gcd ( x , g ) NEW_LINE DEDENT x = 30 NEW_LINE y = 40 NEW_LINE z = 400 NEW_LINE print ( " % d " % findValue ( x , y , z ) ) NEW_LINE
def foot ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; NEW_LINE x2 = a * k + x1 ; NEW_LINE y2 = b * k + y1 ; NEW_LINE z2 = c * k + z1 ; NEW_LINE print ( " x2 ▁ = " , " { : . 1 f } " . format ( x2 ) , end = " ▁ " ) NEW_LINE print ( " y2 ▁ = " , " { : . 1 f } " . format ( y2 ) , end = " ▁ " ) NEW_LINE print ( " z2 ▁ = " , " { : . 1 f } " . format ( z2 ) , end = " ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE foot ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE DEDENT
c = [ ] NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c . append ( input ( ) ) NEW_LINE DEDENT if c [ 0 ] [ 0 ] == c [ 1 ] [ 2 ] and c [ 0 ] [ 1 ] == c [ 1 ] [ 1 ] and c [ 0 ] [ 2 ] == c [ 1 ] [ 0 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE
PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 - 1 ) ) NEW_LINE DEDENT a = 7 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE
def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n / 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 9 NEW_LINE check ( n , m ) NEW_LINE
def solve ( a , n , m ) : NEW_LINE INDENT b = [ ] NEW_LINE flag = False NEW_LINE for i in a : NEW_LINE INDENT curr = i // n NEW_LINE if curr >= 3 : NEW_LINE INDENT flag = True NEW_LINE DEDENT if curr >= 2 : NEW_LINE INDENT b . append ( curr ) NEW_LINE DEDENT DEDENT if m % 2 == 1 : NEW_LINE INDENT if not flag : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return sum ( b ) >= m NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if solve ( a . copy ( ) , n , m ) or solve ( a . copy ( ) , m , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( negProdSubArr ( arr , n ) ) NEW_LINE
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 ; NEW_LINE cntNeg = negProdSubArr ( arr , n ) ; NEW_LINE return ( total - cntNeg ) ; NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( int ( posProdSubArr ( arr , n ) ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE cnt = 1 NEW_LINE ans = 0 NEW_LINE while cnt <= k and cnt < n : NEW_LINE INDENT cnt *= 2 NEW_LINE ans += 1 NEW_LINE DEDENT if cnt >= n : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - cnt ) // k NEW_LINE ans += 1 if ( n - cnt ) % k else 0 NEW_LINE return ans NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT while a % b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return b NEW_LINE DEDENT def LCM ( a , b ) : NEW_LINE INDENT return a * b // GCD ( a , b ) NEW_LINE DEDENT l = input ( ) . split ( ' ▁ ' ) NEW_LINE x , y , a , b = int ( l [ 0 ] ) , int ( l [ 1 ] ) , int ( l [ 2 ] ) , int ( l [ 3 ] ) NEW_LINE lcm = LCM ( x , y ) NEW_LINE print ( b // lcm - ( a - 1 ) // lcm ) NEW_LINE
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE
def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 for i in range ( n ) ] NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and a [ s [ - 1 ] ] < a [ i ] ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE del s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 NEW_LINE del s [ - 1 ] NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT while ( j < i or max_upto [ j ] < i + k - 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT a = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print_max ( a , n , k ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = max ( sum ( int ( c ) for c in str ( a ** b ) ) for a in range ( 100 ) for b in range ( 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def countWindowDistinct ( win , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT if ( win [ i ] == win [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT print ( countWindowDistinct ( arr [ i : k + i ] , k ) ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE countDistinct ( arr , n , k ) NEW_LINE
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = [ '1' , '2' , '3' , '4' ] NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE DEDENT
max = 4 NEW_LINE def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 2 NEW_LINE dp = [ [ - 1 for x in range ( n + 1 ) ] for y in range ( max ) ] NEW_LINE print ( m * countWays ( 1 , 0 , dp , n , m , k ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n // i == i : NEW_LINE INDENT summ += i NEW_LINE DEDENT else : NEW_LINE INDENT summ += i NEW_LINE summ += n // i NEW_LINE DEDENT DEDENT DEDENT return summ - n NEW_LINE DEDENT def printAliquot ( n ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE s = set ( ) NEW_LINE s . add ( n ) NEW_LINE nextt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if n in s : NEW_LINE INDENT print ( " Repeats ▁ with " , n ) NEW_LINE break NEW_LINE DEDENT print ( n , end = " ▁ " ) NEW_LINE s . add ( n ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT printAliquot ( 12 ) NEW_LINE DEDENT
n , a , b = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE lista = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE listb = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT if k + 1 in lista : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE a = 1 ; NEW_LINE cnt = 0 ; NEW_LINE flag = True ; NEW_LINE sum += a ; NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = None ; NEW_LINE if ( flag ) : NEW_LINE INDENT nextElement = a * 2 ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * ( 3 / 2 ) ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT a = nextElement ; NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 8 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b % a , a ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = gcd ( a , b ) NEW_LINE a = a // c NEW_LINE b = b // c NEW_LINE if a == b : NEW_LINE INDENT ans1 = 1 NEW_LINE ans2 = 0 NEW_LINE DEDENT elif a % 2 == 0 or b % 2 == 0 : NEW_LINE INDENT ans1 = 1 NEW_LINE ans2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans1 = a * b // 2 + 1 NEW_LINE ans2 = a * b // 2 NEW_LINE DEDENT print ( ans1 , ans2 ) NEW_LINE DEDENT
from math import sqrt NEW_LINE sz = int ( 1e5 ) ; NEW_LINE isPrime = [ True ] * ( sz + 1 ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT fst = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT fst = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT snd = 0 ; NEW_LINE for i in range ( fst + 1 , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT snd = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( snd == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = snd - fst ; NEW_LINE left = snd + 1 ; NEW_LINE right = R ; NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT if ( i - snd <= diff ) : NEW_LINE INDENT fst = snd ; NEW_LINE snd = i ; NEW_LINE diff = snd - fst ; NEW_LINE DEDENT DEDENT DEDENT return diff ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) ; NEW_LINE L = 21 ; R = 50 ; NEW_LINE print ( minDifference ( L , R ) ) ; NEW_LINE DEDENT
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt = preCnt + 1 NEW_LINE start = start + 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT suffCnt = suffCnt + 1 NEW_LINE end = end - 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE i = start NEW_LINE result = 0 NEW_LINE while ( i <= end ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT midCnt = midCnt + 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return max ( result , preCnt + suffCnt ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) NEW_LINE DEDENT
INF = 10 ** 20 NEW_LINE d , n = map ( int , input ( ) . split ( ) ) NEW_LINE temp = [ int ( input ( ) ) for i in range ( d ) ] NEW_LINE temp . insert ( 0 , 0 ) NEW_LINE alst = [ ] NEW_LINE blst = [ ] NEW_LINE clst = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE alst . append ( a ) NEW_LINE blst . append ( b ) NEW_LINE clst . append ( c ) NEW_LINE DEDENT dp = [ [ 0 ] * n for i in range ( d + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not ( alst [ i ] <= temp [ 1 ] <= blst [ i ] ) : NEW_LINE INDENT dp [ 1 ] [ i ] = - INF NEW_LINE DEDENT DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT t = temp [ i ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if alst [ j ] <= t <= blst [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ x ] + abs ( clst [ j ] - clst [ x ] ) for x in range ( n ) ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp [ d ] ) ) NEW_LINE
def f ( s ) : NEW_LINE INDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] < s [ i - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( i , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE f ( input ( ) ) NEW_LINE
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; NEW_LINE N = 0 ; NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = s - pSq ; NEW_LINE P = d / ( 2.0 * N ) ; NEW_LINE A = N + P ; NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; NEW_LINE return sqrt_of_s ; NEW_LINE DEDENT num = 9.2345 ; NEW_LINE sqroot_of_num = sqroot ( num ) ; NEW_LINE print ( " Square ▁ root ▁ of " , num , " = " , round ( ( sqroot_of_num * 100000.0 ) / 100000.0 , 5 ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE temp = 0 NEW_LINE seen = set ( ) NEW_LINE p = 0 NEW_LINE while len ( seen ) != n : NEW_LINE INDENT ans += 1 NEW_LINE if p % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i not in seen and arr [ i ] <= temp : NEW_LINE INDENT seen . add ( i ) NEW_LINE temp += 1 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i not in seen and arr [ i ] <= temp : NEW_LINE INDENT seen . add ( i ) NEW_LINE temp += 1 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT R , N = map ( int , input ( ) . split ( ) ) NEW_LINE if not ( R | N ) : NEW_LINE INDENT break NEW_LINE DEDENT geta = 20 NEW_LINE buildings = [ 0 ] * ( geta * 2 ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT xl , xr , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( xl + geta , xr + geta ) : NEW_LINE INDENT buildings [ i ] = max ( buildings [ i ] , h ) NEW_LINE DEDENT DEDENT left , right = 0 , 20 NEW_LINE for _ in range ( 100 ) : NEW_LINE INDENT mid = ( left + right ) / 2 NEW_LINE flag = True NEW_LINE for i in range ( - R + geta , R + geta ) : NEW_LINE INDENT if i < geta : NEW_LINE INDENT y = pow ( R * R - ( i - geta + 1 ) * ( i - geta + 1 ) , 0.5 ) NEW_LINE flag &= buildings [ i ] >= y - R + mid NEW_LINE DEDENT else : NEW_LINE INDENT y = pow ( R * R - ( i - geta ) * ( i - geta ) , 0.5 ) NEW_LINE flag &= buildings [ i ] >= y - R + mid NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT left = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT print ( " { : . 20f } " . format ( left ) ) NEW_LINE DEDENT
for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT i = r = 0 NEW_LINE for x in sorted ( map ( int , s . split ( ) ) ) : i += 1 ; r = ( i , r ) [ x > i ] NEW_LINE print ( r + 1 ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( str ( oct ( n ) [ 2 : ] ) . translate ( str . maketrans ( "4567" , "5789" ) ) ) NEW_LINE DEDENT
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n + 1 ) ] NEW_LINE inc = [ 0 for i in range ( n + 1 ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = float ( ' - inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ = " , maxAlternateSum ( arr , n ) ) NEW_LINE
def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] ) ; NEW_LINE return ; NEW_LINE DEDENT barr = [ 0 ] * n ; NEW_LINE barr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; NEW_LINE barr [ n - 1 ] = arr [ n - 1 ] & arr [ n - 2 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT barr [ i ] = arr [ i - 1 ] & arr [ i + 1 ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( barr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE generateArr ( arr , n ) ; NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT A = 3 NEW_LINE B = 2 NEW_LINE C = 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE
from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) ; NEW_LINE r = ( 10 ** d ) - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT def largestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) ; NEW_LINE r = ( 10 ** d ) - 1 ; NEW_LINE for i in range ( r , l , - 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE queries = [ 2 , 5 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( smallestPrime ( queries [ i ] ) , largestPrime ( queries [ i ] ) ) ; NEW_LINE DEDENT DEDENT
INF = 10 ** 20 NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE dist = [ ] NEW_LINE weth = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT dist . append ( int ( input ( ) ) ) NEW_LINE DEDENT for _ in range ( m ) : NEW_LINE INDENT weth . append ( int ( input ( ) ) ) NEW_LINE DEDENT dp = [ INF ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n , 0 , - 1 ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - 1 ] + dist [ j - 1 ] * weth [ i ] ) NEW_LINE DEDENT DEDENT print ( dp [ n ] ) NEW_LINE
n , k , x = map ( int , input ( ) . split ( ) ) NEW_LINE ls = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for m in range ( 1 , k + 1 ) : NEW_LINE INDENT ls [ - m ] = x NEW_LINE DEDENT print ( sum ( ls ) ) NEW_LINE
import sys NEW_LINE from math import * NEW_LINE from bisect import * NEW_LINE def read_input ( input_path = None ) : NEW_LINE INDENT if input_path is None : NEW_LINE INDENT f = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT f = open ( input_path , ' r ' ) NEW_LINE DEDENT n , m , a , d = map ( int , f . readline ( ) . split ( ) ) NEW_LINE t = list ( map ( int , f . readline ( ) . split ( ) ) ) NEW_LINE return n , m , a , d , t NEW_LINE DEDENT def sol ( n1 , m , a , d , t ) : NEW_LINE INDENT insort ( t , a * n1 ) NEW_LINE pred = 0 NEW_LINE k = 0 NEW_LINE n = 0 NEW_LINE step = d // a + 1 NEW_LINE answer = 0 NEW_LINE fl = 0 NEW_LINE for i in t : NEW_LINE INDENT if i > pred : NEW_LINE INDENT if fl == 0 : NEW_LINE INDENT n = ( i - pred + ( pred % a ) ) // a NEW_LINE if n != 0 : NEW_LINE INDENT k += ( n // step ) * step - step * ( n % step == 0 ) + 1 NEW_LINE if k > n1 : NEW_LINE INDENT k = n1 NEW_LINE fl = 1 NEW_LINE DEDENT DEDENT if ( k * a + d >= i ) and ( n != 0 ) : NEW_LINE INDENT pred = k * a + d NEW_LINE DEDENT else : NEW_LINE INDENT pred = i + d NEW_LINE k = floor ( pred // a ) NEW_LINE answer += 1 NEW_LINE DEDENT k = min ( floor ( pred // a ) , n1 ) NEW_LINE answer += n // step + ( n % step != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT answer += 1 NEW_LINE pred = i + d NEW_LINE DEDENT DEDENT if i == a * n1 : NEW_LINE INDENT fl = 1 NEW_LINE DEDENT DEDENT return [ f " { answer } " ] NEW_LINE DEDENT def solve ( input_path = None ) : NEW_LINE INDENT return sol ( * read_input ( input_path ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT for line in sol ( * read_input ( ) ) : NEW_LINE INDENT print ( f " { line } " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE test_case = int ( input ( ) ) NEW_LINE while test_case : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE sum = n * ( n + 1 ) // 2 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum -= i * 2 NEW_LINE i *= 2 NEW_LINE DEDENT print ( int ( sum ) ) NEW_LINE test_case -= 1 NEW_LINE DEDENT
s = list ( input ( ) ) NEW_LINE x = True NEW_LINE dt = { } NEW_LINE for i in s : NEW_LINE INDENT if i in dt : NEW_LINE INDENT dt [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dt [ i ] = 1 NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE x = True NEW_LINE for key , value in dt . items ( ) : NEW_LINE INDENT if value % 2 != 0 and cnt < 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif value % 2 != 0 and cnt >= 1 : NEW_LINE INDENT x = False NEW_LINE break NEW_LINE DEDENT DEDENT if x : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT elif not x and len ( s ) % 2 == 0 : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT elif not x and len ( s ) % 2 != 0 : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT n = reverse ( n ) NEW_LINE sumOdd = 0 NEW_LINE sumEven = 0 NEW_LINE c = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT sumEven += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += n % 10 NEW_LINE DEDENT n //= 10 NEW_LINE c += 1 NEW_LINE DEDENT print ( " Sum ▁ odd ▁ = " , sumOdd ) NEW_LINE print ( " Sum ▁ even ▁ = " , sumEven ) NEW_LINE DEDENT n = 457892 NEW_LINE getSum ( n ) NEW_LINE
def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT def row ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE if ( h < w ) : NEW_LINE INDENT row_no = row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( ht , h ) NEW_LINE DEDENT disp ( row_no , no_block ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 50 NEW_LINE w = 20 NEW_LINE h = 35 NEW_LINE a = 700 NEW_LINE ht = 140 NEW_LINE calculate ( l , w , h , a , ht ) NEW_LINE DEDENT
bin = [ "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" ] ; NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] ; NEW_LINE DEDENT binary = binary [ 0 : len ( binary ) - 1 ] ; NEW_LINE count = 1 ; prev = - 1 ; j = 0 ; NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) ; NEW_LINE prev = j ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT octal = "13" ; NEW_LINE print ( maxFreq ( octal ) ) ; NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 for i in range ( n ) ] NEW_LINE cc = [ 0 for i in range ( n ) ] NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT cv [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + isVowel ( s [ i ] ) NEW_LINE cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == False ) NEW_LINE DEDENT ans = " " NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += str ( prod ) NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ) NEW_LINE ans += str ( prod ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sm = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + freq [ i ] / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( round ( frequency_sum / sm , 4 ) ) NEW_LINE DEDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = len ( num ) NEW_LINE print ( " { : . 4 f } " . format ( harmonicMean ( num , freq , n ) ) ) NEW_LINE
import math NEW_LINE def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * math . tan ( ( 180 / n ) * math . pi / 180 ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { : . 3 f } ' . format ( polyarea ( n , a ) ) ) NEW_LINE DEDENT
import sys NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a / __gcd ( a , b ) * b ) ; NEW_LINE DEDENT def getMinValue ( c ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( pow ( c , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( c % i == 0 and lcm ( i , c / i ) == c ) : NEW_LINE INDENT ans = min ( ans , max ( i , c / i ) ) ; NEW_LINE DEDENT DEDENT return int ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT c = 6 ; NEW_LINE print ( getMinValue ( c ) ) ; NEW_LINE DEDENT
while ( True ) : NEW_LINE INDENT M , Nmin , Nmax = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE if M + Nmin + Nmax == 0 : NEW_LINE INDENT break NEW_LINE DEDENT P = [ int ( input ( ) ) for _ in range ( M ) ] NEW_LINE dif = [ 0 ] * ( M ) NEW_LINE for i in range ( len ( P ) - 1 ) : NEW_LINE INDENT dif [ i + 1 ] = P [ i ] - P [ i + 1 ] NEW_LINE DEDENT ans = Nmin NEW_LINE tmp = dif [ Nmin ] NEW_LINE for i in range ( Nmin + 1 , Nmax + 1 ) : NEW_LINE INDENT if dif [ i ] >= tmp : NEW_LINE INDENT ans = i NEW_LINE tmp = dif [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
R = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b , q , i , m = R ( ) NEW_LINE a = set ( R ( ) ) NEW_LINE c = 0 NEW_LINE for _ in range ( 99 ) : NEW_LINE INDENT if abs ( b ) > i : break NEW_LINE if b not in a : c += 1 NEW_LINE b *= q NEW_LINE DEDENT print ( c if c < 32 else ' inf ' ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = int ( input ( ) ) , { } NEW_LINE x = map ( int , input ( ) . split ( ) ) NEW_LINE for i , v in enumerate ( x ) : m [ v ] = i + 1 NEW_LINE m = dict ( sorted ( m . items ( ) ) ) NEW_LINE print ( m [ list ( m ) [ 0 ] ] , m [ list ( m ) [ - 1 ] ] ) NEW_LINE DEDENT
import math NEW_LINE def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEW_LINE return round ( fibo ) NEW_LINE DEDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n2 < n1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT if ( isSmaller ( str1 , str2 ) ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE str1 = str1 [ : : - 1 ] NEW_LINE str2 = str2 [ : : - 1 ] NEW_LINE carry = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT sub = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) - ( ord ( str2 [ i ] ) - ord ( '0' ) ) - carry ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str3 = str3 + str ( sub ) NEW_LINE DEDENT for i in range ( n2 , n1 ) : NEW_LINE INDENT sub = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) - carry ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str3 = str3 + str ( sub ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "978" NEW_LINE str2 = "12977" NEW_LINE print ( findDiff ( str1 , str2 ) ) NEW_LINE s1 = "100" NEW_LINE s2 = "1000000" NEW_LINE print ( findDiff ( s1 , s2 ) ) NEW_LINE DEDENT
def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 ; c1 = 0 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT elif ( s1 [ i ] == '1' and s2 [ i ] == '0' ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT ans = c0 // 2 + c1 // 2 ; NEW_LINE if ( c0 % 2 == 0 and c1 % 2 == 0 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT elif ( ( c0 + c1 ) % 2 == 0 ) : NEW_LINE INDENT return ans + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = "0011" ; s2 = "1111" ; NEW_LINE ans = minSwaps ( s1 , s2 ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT
class SegmentTree : NEW_LINE INDENT def _max ( self , a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT def __init__ ( self , n ) : NEW_LINE INDENT self . N = 1 NEW_LINE while ( self . N < n ) : NEW_LINE INDENT self . N *= 2 NEW_LINE DEDENT self . seg = [ 0 ] * ( self . N * 2 - 1 ) NEW_LINE DEDENT def max_update ( self , k , a ) : NEW_LINE INDENT k += self . N - 1 NEW_LINE self . seg [ k ] = a NEW_LINE while ( 0 < k ) : NEW_LINE INDENT k = ( k - 1 ) // 2 ; NEW_LINE self . seg [ k ] = self . _max ( self . seg [ 2 * k + 1 ] , self . seg [ 2 * k + 2 ] ) NEW_LINE DEDENT DEDENT def _max_query ( self , a , b , k , l , r ) : NEW_LINE INDENT if r <= a or b <= l : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a <= l and r <= b : NEW_LINE INDENT return self . seg [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT vl = self . _max_query ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) NEW_LINE vr = self . _max_query ( a , b , k * 2 + 2 , ( l + r ) // 2 , r ) NEW_LINE return self . _max ( vl , vr ) NEW_LINE DEDENT DEDENT def max_query ( self , a , b ) : NEW_LINE INDENT return self . _max_query ( a , b , 0 , 0 , self . N ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE st = SegmentTree ( n + 1 ) NEW_LINE for x in X : NEW_LINE INDENT st . max_update ( x , st . max_query ( 0 , x ) + x ) NEW_LINE DEDENT print ( ( n * ( n + 1 ) ) // 2 - st . max_query ( 0 , n + 1 ) ) NEW_LINE
a = input ( ) NEW_LINE p = a . index ( ' ^ ' ) NEW_LINE c = sum ( ( i - p ) * int ( y ) for i , y in enumerate ( a ) if y . isdigit ( ) ) NEW_LINE print ( [ [ ' balance ' , ' right ' ] [ c > 0 ] , ' left ' ] [ c < 0 ] ) NEW_LINE
def normalSieve ( n ) : NEW_LINE INDENT prime = [ 0 ] * int ( n / 2 ) ; NEW_LINE i = 3 ; NEW_LINE while ( i * i < n ) : NEW_LINE INDENT if ( prime [ int ( i / 2 ) ] == 0 ) : NEW_LINE INDENT j = i * i ; NEW_LINE while ( j < n ) : NEW_LINE INDENT prime [ int ( j / 2 ) ] = 1 ; NEW_LINE j += i * 2 ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT print ( 2 , end = " ▁ " ) ; NEW_LINE i = 3 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( prime [ int ( i / 2 ) ] == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 100 ; NEW_LINE normalSieve ( n ) ; NEW_LINE DEDENT
txt = input ( ) NEW_LINE out = " " NEW_LINE cap = 0 NEW_LINE small = 0 NEW_LINE for t in txt : NEW_LINE INDENT if t . islower ( ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cap += 1 NEW_LINE DEDENT DEDENT if small >= cap : NEW_LINE INDENT for t in txt : NEW_LINE INDENT out += t . lower ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for t in txt : NEW_LINE INDENT out += t . upper ( ) NEW_LINE DEDENT DEDENT print ( out ) NEW_LINE
def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT mn = arr [ 0 ] NEW_LINE freq = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < mn ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE freq = 1 NEW_LINE DEDENT elif ( arr [ i ] == mn ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 , 4 ] NEW_LINE print ( frequencyOfSmallest ( N , arr ) ) NEW_LINE DEDENT
def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i = 0 ; j = 0 ; NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE j += 1 ; NEW_LINE if ( j == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 ; NEW_LINE j = 0 ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] ; NEW_LINE n = len ( A ) ; NEW_LINE B = [ 3 , 0 , 5 , 1 ] ; NEW_LINE m = len ( B ) ; NEW_LINE if ( isSubArray ( A , B , n , m ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( int ( input ( ) ) ) NEW_LINE DEDENT ans = n - 1 NEW_LINE last = 0 NEW_LINE for i in l : NEW_LINE INDENT ans += abs ( last - i ) + 1 NEW_LINE last = i NEW_LINE DEDENT print ( ans ) NEW_LINE
def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE
def ok ( last4 ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT t = list ( last4 ) NEW_LINE if i >= 1 : NEW_LINE INDENT t [ i ] , t [ i - 1 ] = t [ i - 1 ] , t [ i ] NEW_LINE DEDENT if ' ' . join ( t ) . count ( ' AGC ' ) >= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( cur , last3 ) : NEW_LINE INDENT if last3 in memo [ cur ] : NEW_LINE INDENT return memo [ cur ] [ last3 ] NEW_LINE DEDENT if cur == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT ret = 0 NEW_LINE for c in " ACGT " : NEW_LINE INDENT if ok ( last3 + c ) : NEW_LINE INDENT ret = ( ret + dfs ( cur + 1 , last3 [ 1 : ] + c ) ) % mod NEW_LINE DEDENT DEDENT memo [ cur ] [ last3 ] = ret NEW_LINE return ret NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE memo = [ { } for i in range ( n + 1 ) ] NEW_LINE print ( dfs ( 0 , ' TTT ' ) ) NEW_LINE
i = 0 NEW_LINE sumsell = 0 NEW_LINE sumn = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT at , n = map ( int , input ( ) . split ( " , " ) ) NEW_LINE sumsell += at * n NEW_LINE sumn += n NEW_LINE i += 1 NEW_LINE DEDENT except EOFError : break NEW_LINE DEDENT print ( sumsell ) NEW_LINE print ( ( int ) ( sumn / i + 0.5 ) ) NEW_LINE
MAX = 100 ; NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE C [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( sumOfproduct ( n ) ) ; NEW_LINE
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string1 = input ( " Enter ▁ the ▁ first ▁ string : ▁ " ) NEW_LINE print ( string1 , end = " \n " ) NEW_LINE string2 = input ( " Enter ▁ the ▁ second ▁ string : ▁ " ) NEW_LINE print ( string2 , end = " \n " ) NEW_LINE print ( " Are ▁ both ▁ strings ▁ same : " , end = " ▁ " ) NEW_LINE if ( string1 == string2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def pairCount ( arr , n ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE k = int ( sqrt ( max_val ) ) + 1 NEW_LINE for p in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( int ( pairCount ( arr , n ) ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getPrime ( arr , n ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT return str ( sum ( NUMBERS ) ) [ : 10 ] NEW_LINE DEDENT NUMBERS = [ 37107287533902102798797998220837590246510135740250 , 46376937677490009712648124896970078050417018260538 , 74324986199524741059474233309513058123726617309629 , 91942213363574161572522430563301811072406154908250 , 23067588207539346171171980310421047513778063246676 , 89261670696623633820136378418383684178734361726757 , 28112879812849979408065481931592621691275889832738 , 44274228917432520321923589422876796487670272189318 , 47451445736001306439091167216856844588711603153276 , 70386486105843025439939619828917593665686757934951 , 62176457141856560629502157223196586755079324193331 , 64906352462741904929101432445813822663347944758178 , 92575867718337217661963751590579239728245598838407 , 58203565325359399008402633568948830189458628227828 , 80181199384826282014278194139940567587151170094390 , 35398664372827112653829987240784473053190104293586 , 86515506006295864861532075273371959191420517255829 , 71693888707715466499115593487603532921714970056938 , 54370070576826684624621495650076471787294438377604 , 53282654108756828443191190634694037855217779295145 , 36123272525000296071075082563815656710885258350721 , 45876576172410976447339110607218265236877223636045 , 17423706905851860660448207621209813287860733969412 , 81142660418086830619328460811191061556940512689692 , 51934325451728388641918047049293215058642563049483 , 62467221648435076201727918039944693004732956340691 , 15732444386908125794514089057706229429197107928209 , 55037687525678773091862540744969844508330393682126 , 18336384825330154686196124348767681297534375946515 , 80386287592878490201521685554828717201219257766954 , 78182833757993103614740356856449095527097864797581 , 16726320100436897842553539920931837441497806860984 , 48403098129077791799088218795327364475675590848030 , 87086987551392711854517078544161852424320693150332 , 59959406895756536782107074926966537676326235447210 , 69793950679652694742597709739166693763042633987085 , 41052684708299085211399427365734116182760315001271 , 65378607361501080857009149939512557028198746004375 , 35829035317434717326932123578154982629742552737307 , 94953759765105305946966067683156574377167401875275 , 88902802571733229619176668713819931811048770190271 , 25267680276078003013678680992525463401061632866526 , 36270218540497705585629946580636237993140746255962 , 24074486908231174977792365466257246923322810917141 , 91430288197103288597806669760892938638285025333403 , 34413065578016127815921815005561868836468420090470 , 23053081172816430487623791969842487255036638784583 , 11487696932154902810424020138335124462181441773470 , 63783299490636259666498587618221225225512486764533 , 67720186971698544312419572409913959008952310058822 , 95548255300263520781532296796249481641953868218774 , 76085327132285723110424803456124867697064507995236 , 37774242535411291684276865538926205024910326572967 , 23701913275725675285653248258265463092207058596522 , 29798860272258331913126375147341994889534765745501 , 18495701454879288984856827726077713721403798879715 , 38298203783031473527721580348144513491373226651381 , 34829543829199918180278916522431027392251122869539 , 40957953066405232632538044100059654939159879593635 , 29746152185502371307642255121183693803580388584903 , 41698116222072977186158236678424689157993532961922 , 62467957194401269043877107275048102390895523597457 , 23189706772547915061505504953922979530901129967519 , 86188088225875314529584099251203829009407770775672 , 11306739708304724483816533873502340845647058077308 , 82959174767140363198008187129011875491310547126581 , 97623331044818386269515456334926366572897563400500 , 42846280183517070527831839425882145521227251250327 , 55121603546981200581762165212827652751691296897789 , 32238195734329339946437501907836945765883352399886 , 75506164965184775180738168837861091527357929701337 , 62177842752192623401942399639168044983993173312731 , 32924185707147349566916674687634660915035914677504 , 99518671430235219628894890102423325116913619626622 , 73267460800591547471830798392868535206946944540724 , 76841822524674417161514036427982273348055556214818 , 97142617910342598647204516893989422179826088076852 , 87783646182799346313767754307809363333018982642090 , 10848802521674670883215120185883543223812876952786 , 71329612474782464538636993009049310363619763878039 , 62184073572399794223406235393808339651327408011116 , 66627891981488087797941876876144230030984490851411 , 60661826293682836764744779239180335110989069790714 , 85786944089552990653640447425576083659976645795096 , 66024396409905389607120198219976047599490197230297 , 64913982680032973156037120041377903785566085089252 , 16730939319872750275468906903707539413042652315011 , 94809377245048795150954100921645863754710598436791 , 78639167021187492431995700641917969777599028300699 , 15368713711936614952811305876380278410754449733078 , 40789923115535562561142322423255033685442488917353 , 44889911501440648020369068063960672322193204149535 , 41503128880339536053299340368006977710650566631954 , 81234880673210146739058568557934581403627822703280 , 82616570773948327592232845941706525094512325230608 , 22918802058777319719839450180888072429661980811197 , 77158542502016545090413245809786882778948721859617 , 72107838435069186155435662884062257473692284509516 , 20849603980134001723930671666823555245252804609722 , 53503534226472524250874054075591789781264330331690 , ] NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printDistinct ( arr , n ) ; NEW_LINE
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) NEW_LINE print ( a * b ) NEW_LINE DEDENT
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif ( n % 6 == 4 ) : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT if ( n % 6 == 0 ) : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 17 NEW_LINE n = 3 NEW_LINE print ( nth_term ( a , b , n ) ) NEW_LINE DEDENT
def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def combinedSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE ran = ( 1 << n ) - 1 NEW_LINE for i in range ( ran + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "123" NEW_LINE print ( combinedSum ( s ) ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return n / 3 + n / 7 - n / 21 ; NEW_LINE DEDENT n = ( ( int ) ( countMultiples ( 25 ) ) ) ; NEW_LINE print ( " Count ▁ = " , n ) ; NEW_LINE
import numpy as np NEW_LINE SIZE = 26 NEW_LINE def longSub ( str , k ) : NEW_LINE INDENT freq = np . zeros ( 26 , dtype = np . int ) NEW_LINE start = 0 NEW_LINE maxLen = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE freq [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT if ( maxLen < ( i - start ) ) : NEW_LINE INDENT maxLen = i - start NEW_LINE DEDENT while ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT freq [ ord ( str [ start ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE start = start + 1 NEW_LINE DEDENT DEDENT DEDENT if ( maxLen < ( n - start ) ) : NEW_LINE INDENT maxLen = n - start NEW_LINE DEDENT return maxLen ; NEW_LINE DEDENT str = " babcaag " NEW_LINE k = 1 NEW_LINE print ( " Length ▁ = " , longSub ( str , k ) ) NEW_LINE
from sys import stdin , stdout NEW_LINE input = stdin . readline NEW_LINE n = int ( input ( ) ) ; sa = sg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , g = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= g : NEW_LINE INDENT if sa + a - sg <= 500 : NEW_LINE INDENT sa += a ; stdout . write ( " A " ) NEW_LINE DEDENT else : NEW_LINE INDENT sg += g ; stdout . write ( " G " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if sg + g - sa <= 500 : NEW_LINE INDENT sg += g ; stdout . write ( " G " ) NEW_LINE DEDENT else : NEW_LINE INDENT sa += a ; stdout . write ( " A " ) NEW_LINE DEDENT DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT mp = '0123456789abcdef ' NEW_LINE ans = ' ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT n = num & 15 NEW_LINE c = mp [ n ] NEW_LINE ans = c + ans NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans . lstrip ( '0' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num = 26 NEW_LINE out = sObj . toHex ( num ) NEW_LINE print ( out ) NEW_LINE DEDENT
numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE start = 0 NEW_LINE arr = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( 0 , numbers [ 0 ] ) : NEW_LINE INDENT string = " " NEW_LINE next = start NEW_LINE for j in range ( 0 , numbers [ 0 ] ) : NEW_LINE INDENT if count < numbers [ 1 ] : NEW_LINE INDENT if j == next : NEW_LINE INDENT string += ' L ' NEW_LINE count += 1 NEW_LINE next += 2 NEW_LINE if next >= numbers [ 0 ] : NEW_LINE INDENT start = 1 if start == 0 else 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT string += " S " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT string += " S " NEW_LINE DEDENT DEDENT arr . append ( string ) NEW_LINE DEDENT if count < numbers [ 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result = result + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeks " NEW_LINE str2 = " cake " NEW_LINE longestString ( str1 , str2 ) NEW_LINE DEDENT
def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret = ret + 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l // mul ) * mul == ( r // mul ) * mul ) : NEW_LINE INDENT if ( ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( odd_c ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE DEDENT zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if ( ( l % 2 == 1 ) and ( r % 2 == 1 ) ) : NEW_LINE INDENT zero_bit_cnt = zero_bit_cnt + 1 NEW_LINE DEDENT if ( zero_bit_cnt % 2 == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE
def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q4 ( s , i ) : NEW_LINE INDENT if ( i == s . length ( ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " abbaabb " ; NEW_LINE q0 ( s , 0 ) ; NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE ans = [ ] NEW_LINE while 1 : NEW_LINE INDENT M = int ( readline ( ) ) NEW_LINE if M == 0 : NEW_LINE INDENT break NEW_LINE DEDENT P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] NEW_LINE memo = { } NEW_LINE def dfs ( i , rest ) : NEW_LINE INDENT if i == M : NEW_LINE INDENT return rest == 0 NEW_LINE DEDENT key = ( i , rest ) NEW_LINE if key in memo : NEW_LINE INDENT return memo [ key ] NEW_LINE DEDENT res = 0 NEW_LINE a , b = P [ i ] NEW_LINE for j in range ( 0 , b + 1 ) : NEW_LINE INDENT if rest - j * a < 0 : NEW_LINE INDENT break NEW_LINE DEDENT res += dfs ( i + 1 , rest - j * a ) NEW_LINE DEDENT memo [ key ] = res NEW_LINE return res NEW_LINE DEDENT G = int ( input ( ) ) NEW_LINE for i in range ( G ) : NEW_LINE INDENT ans . append ( str ( dfs ( 0 , int ( input ( ) ) ) ) ) NEW_LINE DEDENT DEDENT write ( " \n " . join ( ans ) ) NEW_LINE write ( " \n " ) NEW_LINE
def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( ( ord ( T [ 0 ] ) - ord ( '0' ) ) * 10 + ord ( T [ 1 ] ) - ord ( '0' ) ) * 60 + ( ( ord ( T [ 3 ] ) - ord ( '0' ) ) * 10 + ord ( T [ 4 ] ) - ord ( '0' ) ) ) ; NEW_LINE minutes += K NEW_LINE hour = ( int ( minutes / 60 ) ) % 24 NEW_LINE min = minutes % 60 NEW_LINE if ( hour < 10 ) : NEW_LINE INDENT print ( " 0 " + str ( hour ) + " : " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ( hour ) + " : " , end = " " ) NEW_LINE DEDENT if ( min < 10 ) : NEW_LINE INDENT print ( " 0 " + str ( min ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ( min) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = "21:39" NEW_LINE K = 43 NEW_LINE findTime ( T , K ) NEW_LINE DEDENT
import sys NEW_LINE def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ = " , maxProd ) NEW_LINE print ( " Maximum ▁ Sum ▁ = " , maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "3675356291" NEW_LINE m = 5 NEW_LINE maxProductSum ( string , m ) NEW_LINE DEDENT
R = 3 NEW_LINE C = 3 NEW_LINE import sys NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT def min ( x , y , z ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x if ( x < z ) else z NEW_LINE DEDENT else : NEW_LINE INDENT return y if ( y < z ) else z NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( sum ( abs ( x - i ) for x , i in zip ( p , range ( s , n + 1 , 2 ) ) ) for s in ( 1 , 2 ) ) ) NEW_LINE
MAX = 100003 NEW_LINE ws = [ 0 for i in range ( MAX ) ] NEW_LINE par = [ - 1 for i in range ( MAX * 2 ) ] NEW_LINE def weight ( x ) : NEW_LINE INDENT root ( x ) NEW_LINE return ws [ x ] NEW_LINE DEDENT def root ( x ) : NEW_LINE INDENT if par [ x ] < 0 : return x NEW_LINE p = root ( par [ x ] ) NEW_LINE ws [ x ] = ws [ x ] + ws [ par [ x ] ] NEW_LINE par [ x ] = p NEW_LINE return par [ x ] NEW_LINE DEDENT def unite ( y , x , z ) : NEW_LINE INDENT z = z + weight ( x ) NEW_LINE z = z - weight ( y ) NEW_LINE x = root ( x ) NEW_LINE y = root ( y ) NEW_LINE if x == y : return 0 NEW_LINE if par [ y ] < par [ x ] : NEW_LINE INDENT tmp = x NEW_LINE x = y NEW_LINE y = tmp NEW_LINE z = - z NEW_LINE DEDENT par [ x ] = par [ x ] + par [ y ] NEW_LINE par [ y ] = x NEW_LINE ws [ y ] = z NEW_LINE return 1 NEW_LINE DEDENT def diff ( x , y ) : NEW_LINE INDENT if root ( x ) != root ( y ) : return 0 NEW_LINE ans = ws [ x ] - ws [ y ] NEW_LINE return 1 , ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT global ans NEW_LINE N , Q = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE for q in range ( Q ) : NEW_LINE INDENT t , * cmd = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE if t : NEW_LINE INDENT x , y = cmd NEW_LINE z = diff ( x , y ) NEW_LINE if z == False : print ( " ? " ) NEW_LINE else : print ( z [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT x , y , z = cmd NEW_LINE unite ( x , y , z ) NEW_LINE DEDENT DEDENT DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = 6 NEW_LINE B = 15 NEW_LINE M = 3 NEW_LINE print ( sumDivisibles ( A , B , M ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to " , n , " that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is " , countNumbersWith4 ( n ) ) NEW_LINE
wah = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE x , y , n = wah [ 0 ] , wah [ 1 ] , int ( input ( ) ) NEW_LINE all = [ x , y , y - x , - x , - y , x - y ] NEW_LINE res = ( n - 1 ) % 6 NEW_LINE print ( all [ res ] % 1000000007 ) NEW_LINE
INT_MIN = - 2 ** 31 NEW_LINE INT_MAX = 2 ** 31 NEW_LINE def findPostOrderUtil ( pre , n , minval , maxval , preIndex ) : NEW_LINE INDENT if ( preIndex [ 0 ] == n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( pre [ preIndex [ 0 ] ] < minval or pre [ preIndex [ 0 ] ] > maxval ) : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ preIndex [ 0 ] ] NEW_LINE preIndex [ 0 ] += 1 NEW_LINE findPostOrderUtil ( pre , n , minval , val , preIndex ) NEW_LINE findPostOrderUtil ( pre , n , val , maxval , preIndex ) NEW_LINE print ( val , end = " ▁ " ) NEW_LINE DEDENT def findPostOrder ( pre , n ) : NEW_LINE INDENT preIndex = [ 0 ] NEW_LINE findPostOrderUtil ( pre , n , INT_MIN , INT_MAX , preIndex ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT pre = [ 40 , 30 , 35 , 80 , 100 ] NEW_LINE n = len ( pre ) NEW_LINE findPostOrder ( pre , n ) NEW_LINE DEDENT
def countWays ( n , arr , k ) : NEW_LINE INDENT if ( k <= 0 or k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( ) NEW_LINE for element in arr : NEW_LINE INDENT s . add ( element ) NEW_LINE DEDENT if ( len ( s ) <= k ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return len ( s ) - k ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countWays ( n , arr , k ) ) NEW_LINE DEDENT
cnt = input ( ) NEW_LINE for k in range ( int ( cnt ) ) : NEW_LINE INDENT ip = input ( ) NEW_LINE if ip == " " : NEW_LINE INDENT print ( "0000:0000:0000:0000:0000:0000:0000:0000" ) NEW_LINE continue NEW_LINE DEDENT ip = ip . split ( " : " ) NEW_LINE ret = " " NEW_LINE if ip [ 0 ] == " " : NEW_LINE INDENT ip = [ "0000" ] * ( 8 - len ( ip ) + 2 ) + ip [ 2 : ] NEW_LINE DEDENT elif ip [ - 1 ] == " " : NEW_LINE INDENT ip = ip [ : - 2 ] + [ "0000" ] * ( 8 - len ( ip ) + 2 ) NEW_LINE DEDENT for i in range ( len ( ip ) ) : NEW_LINE INDENT if ip [ i ] == " " : NEW_LINE INDENT ip = ip [ : i ] + [ "0000" ] * ( 8 - len ( ip ) + 1 ) + ip [ i + 1 : ] NEW_LINE DEDENT DEDENT for i in range ( len ( ip ) ) : NEW_LINE INDENT if ip [ i ] != " " : NEW_LINE INDENT ip [ i ] = "0" * ( 4 - len ( ip [ i ] ) ) + ip [ i ] NEW_LINE DEDENT DEDENT print ( " : " . join ( ip ) ) NEW_LINE DEDENT
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if flag == 1 else False ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) != None ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE W = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT W . append ( list ( input ( ) ) ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if W [ i ] [ 0 ] != W [ i - 1 ] [ - 1 ] : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT W . sort ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if W [ i ] == W [ i - 1 ] : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT if cnt == 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( findNum ( div , rem , N ) ) NEW_LINE DEDENT
def segregate0and1 ( arr , size ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = size - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT ( arr [ type0 ] , arr [ type1 ] ) = ( arr [ type1 ] , arr [ type0 ] ) NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE segregate0and1 ( arr , arr_size ) NEW_LINE print ( " Array ▁ after ▁ segregation ▁ is " , end = " ▁ " ) NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE d = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE print ( len ( set ( d ) ) ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE a = ord ( t [ 0 ] ) - ord ( s [ 0 ] ) NEW_LINE b = int ( t [ 1 ] ) - int ( s [ 1 ] ) NEW_LINE x = abs ( a ) NEW_LINE y = abs ( b ) NEW_LINE c = [ ' R ' , ' U ' , ' L ' , ' D ' ] NEW_LINE i = 0 NEW_LINE j = 1 NEW_LINE if a < 0 : NEW_LINE INDENT i = 2 NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT j = 3 NEW_LINE DEDENT k = j NEW_LINE if x > y : NEW_LINE INDENT k = i NEW_LINE x , y = y , x NEW_LINE DEDENT m = c [ i ] + c [ j ] NEW_LINE n = c [ k ] NEW_LINE print ( y ) NEW_LINE for l in range ( x ) : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT for l in range ( y - x ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def f ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE h , w = f ( ) ; print ( sum ( [ sum ( [ ( x + 1 ) * ( w - x ) * v for x , v in enumerate ( f ( ) ) ] ) * ( y + 1 ) * ( h - y ) for y in range ( h ) ] ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE for i , X in enumerate ( L ) : NEW_LINE INDENT for j , Y in enumerate ( X ) : NEW_LINE INDENT if Y == 1 or any ( Y - L [ t ] [ j ] in X for t in range ( n ) ) : continue NEW_LINE print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE
a , b = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE MAX = ( 1 << 32 ) - 1 NEW_LINE print ( " { :032b } " . format ( a & b ) ) NEW_LINE print ( " { :032b } " . format ( a | b ) ) NEW_LINE print ( " { :032b } " . format ( a ^ b ) ) NEW_LINE
x = int ( input ( ) ) NEW_LINE print ( f ' { x : 032b } ' ) NEW_LINE print ( f ' { ~ x ▁ & ▁ 0xffffffff : 032b } ' ) NEW_LINE print ( f ' { x ▁ < < ▁ 1 ▁ & ▁ 0xffffffff : 032b } ' ) NEW_LINE print ( f ' { x ▁ > > ▁ 1:032b } ' ) NEW_LINE
import itertools as i , collections as c NEW_LINE b = c . Counter ( s [ 0 ] for s in open ( 0 ) . readlines ( ) [ 1 : ] if s [ 0 ] in " MARCH " ) NEW_LINE print ( sum ( p * q * r for p , q , r in i . combinations ( b . values ( ) , 3 ) ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE s1 = a [ 0 ] NEW_LINE s2 = b [ 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( a ) or j < len ( b ) : NEW_LINE INDENT if s1 == s2 : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE if i < len ( a ) and j < len ( b ) : NEW_LINE INDENT s1 = a [ i ] NEW_LINE s2 = b [ j ] NEW_LINE DEDENT DEDENT elif s1 < s2 : NEW_LINE INDENT i += 1 NEW_LINE s1 += a [ i ] NEW_LINE DEDENT elif s2 < s1 : NEW_LINE INDENT j += 1 NEW_LINE s2 += b [ j ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT a , en , b = input ( ) . split ( ) NEW_LINE if en == ' ? ' : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE if en == ' + ' : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT elif en == ' - ' : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT elif en == ' * ' : NEW_LINE INDENT print ( a * b ) NEW_LINE DEDENT elif en == ' / ' : NEW_LINE INDENT print ( int ( a / b ) ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 for _ in range ( n - 1 ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT d [ i ] = a [ i + 1 ] - a [ i ] NEW_LINE DEDENT cnt = 1 NEW_LINE l = r = cur = 0 NEW_LINE while l < n - 1 : NEW_LINE INDENT while r < n - 1 and cur * d [ r ] >= 0 : NEW_LINE INDENT if cur == 0 : NEW_LINE INDENT cur = d [ r ] NEW_LINE DEDENT r += 1 NEW_LINE DEDENT if r < n - 1 and cur * d [ r ] < 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT r += 1 NEW_LINE l = r NEW_LINE cur = 0 NEW_LINE DEDENT print ( cnt ) NEW_LINE
MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE prime = [ 0 ] * 100005 NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == 0 : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 100 , 11 , 500 , 2 , 17 , 1 ] NEW_LINE sortedArray ( arr , n ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE import math NEW_LINE def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= maxElement : NEW_LINE INDENT hash1 . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def gcdFibonacciFreq ( arr , n ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE createHash ( hash1 , max ( arr ) ) NEW_LINE m = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT gcd = 0 NEW_LINE for it in m . keys ( ) : NEW_LINE INDENT if ( m [ it ] in hash1 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , it ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdFibonacciFreq ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = 3.14 * R * R / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 ; NEW_LINE print ( " Area ▁ of ▁ semicircle ▁ = " , " { : . 4 f } " . format ( find_Area ( a ) ) ) ; NEW_LINE DEDENT
def findQuadruples ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 0 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findQuadruples ( a , b , c , d , x , n ) ) NEW_LINE
def findSmallest ( s , q , m ) : NEW_LINE INDENT N = len ( s ) NEW_LINE H = [ [ 0 for i in range ( 26 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT H [ i ] [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT H [ i ] [ j ] += H [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT l = q [ j ] [ 0 ] NEW_LINE r = q [ j ] [ 1 ] NEW_LINE n = q [ j ] [ 2 ] NEW_LINE sum = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] NEW_LINE if ( sum >= n ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " afbccdeb " NEW_LINE q = [ [ 2 , 4 , 1 ] , [ 1 , 6 , 4 ] , [ 1 , 8 , 7 ] ] NEW_LINE x = len ( q ) NEW_LINE findSmallest ( s , q , x ) NEW_LINE DEDENT
def miner ( a , b , mines ) : NEW_LINE INDENT s = 0 NEW_LINE j = 0 NEW_LINE while j < len ( mines ) and mines [ j ] != "1" : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == len ( mines ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( j + 1 , len ( mines ) ) : NEW_LINE INDENT if mines [ i ] == "0" and mines [ i - 1 ] == "1" : NEW_LINE INDENT r1 = i - 1 NEW_LINE DEDENT elif mines [ i ] == "1" and mines [ i - 1 ] == "0" : NEW_LINE INDENT s += min ( b * ( i - r1 - 1 ) , a ) NEW_LINE DEDENT DEDENT s += a NEW_LINE return s NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE mines = input ( ) NEW_LINE print ( miner ( a , b , mines ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE start_point = 0 NEW_LINE numb_moves = 0 NEW_LINE if n == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif n % 3 == 0 : NEW_LINE INDENT print ( int ( n / 3 ) ) NEW_LINE continue NEW_LINE DEDENT elif n == 2 or n == 3 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = n % 3 NEW_LINE print ( int ( ( n - x ) / 3 + 1 ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE q = [ ] NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT q += [ i ] NEW_LINE DEDENT DEDENT for j in q : NEW_LINE INDENT w = n // j NEW_LINE s = s [ : w ] [ : : - 1 ] + s [ w : ] NEW_LINE DEDENT print ( ' ' . join ( s ) ) NEW_LINE
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) ; NEW_LINE DEDENT print ( " Double ▁ factorial ▁ is " , doublefactorial ( 5 ) ) ; NEW_LINE
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = l + 1 NEW_LINE h = h - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def minRemovals ( str ) : NEW_LINE INDENT if ( str [ 0 ] == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT print ( minRemovals ( "010010" ) ) NEW_LINE print ( minRemovals ( "0100101" ) ) NEW_LINE
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ ] NEW_LINE sumofdigit . append ( int ( num [ 0 ] ) ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = "1234" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a / n ) * int ( b / n ) NEW_LINE ans += int ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b / n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) / n ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT LIMIT = 1000000 NEW_LINE maxnumer = 0 NEW_LINE maxdenom = 1 NEW_LINE for d in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if n * maxdenom > d * maxnumer : NEW_LINE INDENT maxnumer = n NEW_LINE maxdenom = d NEW_LINE DEDENT DEDENT return str ( maxnumer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
c = [ 0 ] * 100 ; NEW_LINE def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 1 + i ] = 1 ; NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] ; NEW_LINE DEDENT c [ 0 ] = - c [ 0 ] ; NEW_LINE DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT coef ( n ) ; NEW_LINE c [ 0 ] = c [ 0 ] + 1 ; NEW_LINE c [ n ] = c [ n ] - 1 ; NEW_LINE i = n ; NEW_LINE while ( i > - 1 and c [ i ] % n == 0 ) : NEW_LINE INDENT i = i - 1 ; NEW_LINE DEDENT return True if i < 0 else False ; NEW_LINE DEDENT n = 37 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Prime " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) ; NEW_LINE DEDENT
import sys NEW_LINE def count_greater ( arr , n ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE counter = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT counter += 1 ; NEW_LINE DEDENT if ( arr [ i ] <= min ) : NEW_LINE INDENT min = arr [ i ] ; NEW_LINE DEDENT DEDENT return counter ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( count_greater ( arr , n ) ) ; NEW_LINE DEDENT
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a_list . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = x - a_list [ i ] NEW_LINE count += 1 NEW_LINE if x <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count - 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > 0 : right += 1 NEW_LINE elif a < 0 : left += 1 NEW_LINE DEDENT if left == 0 or right == 0 or left == 1 or right == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
while True : NEW_LINE INDENT T , D , L = map ( int , input ( ) . split ( ) ) NEW_LINE if T == 0 : break NEW_LINE a = [ ] NEW_LINE for i in range ( T ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x >= L : a . append ( i ) NEW_LINE DEDENT T , ans = T - 1 , 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT x = D NEW_LINE if T - a [ i - 1 ] < D : x = T - a [ i - 1 ] NEW_LINE if a [ i ] - a [ i - 1 ] < x : ans += a [ i ] - a [ i - 1 ] NEW_LINE else : ans += x NEW_LINE DEDENT if a : ans += T - a [ - 1 ] if a [ - 1 ] + D > T else D NEW_LINE print ( ans ) NEW_LINE DEDENT
def minimumSwaps ( arr ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = arr [ arr [ i ] - 1 ] ; NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] ; NEW_LINE arr [ i ] = temp ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] ; NEW_LINE print ( minimumSwaps ( arr ) ) ; NEW_LINE DEDENT
import eulerlib , heapq NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 500500 NEW_LINE MODULUS = 500500507 NEW_LINE isprime = eulerlib . list_primality ( 7376507 ) NEW_LINE queue = [ ] NEW_LINE nextprime = 2 NEW_LINE heapq . heappush ( queue , nextprime ) NEW_LINE ans = 1 NEW_LINE for _ in range ( TARGET ) : NEW_LINE INDENT item = heapq . heappop ( queue ) NEW_LINE ans *= item NEW_LINE ans %= MODULUS NEW_LINE heapq . heappush ( queue , item ** 2 ) NEW_LINE if item == nextprime : NEW_LINE INDENT nextprime += 1 NEW_LINE while not isprime [ nextprime ] : NEW_LINE INDENT nextprime += 1 NEW_LINE DEDENT heapq . heappush ( queue , nextprime ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( " , x , " , ▁ " , y , " ) " , sep = " " ) NEW_LINE DEDENT a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] NEW_LINE n = len ( a ) NEW_LINE findUniquePair ( a , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = input ( ) NEW_LINE s . append ( k ) NEW_LINE DEDENT flag = 0 NEW_LINE d1 = [ ] NEW_LINE d2 = [ ] NEW_LINE rem = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 . append ( s [ i ] [ j ] ) NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 . append ( s [ i ] [ j ] ) NEW_LINE DEDENT if ( i != j and i != n - j - 1 ) : NEW_LINE INDENT rem . add ( s [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( rem ) != 1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( d1 != d2 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( len ( set ( d1 ) ) != 1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( set ( d1 ) == rem ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT
import re NEW_LINE import sys NEW_LINE for s in sys . stdin : NEW_LINE INDENT print ( re . sub ( r " @ ( \ d ) ( . ) " , lambda m : m . group ( 2 ) * int ( m . group ( 1 ) ) , s . rstrip ( ) ) ) NEW_LINE DEDENT
def isMajority ( a ) : NEW_LINE INDENT mp = { } NEW_LINE for i in a : NEW_LINE INDENT if i in mp : mp [ i ] += 1 NEW_LINE else : mp [ i ] = 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if mp [ x ] >= len ( a ) // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE print ( " Yes " if isMajority ( a ) else " No " ) NEW_LINE
n , w = map ( int , input ( ) . split ( ) ) NEW_LINE vw_l = [ [ int ( x ) for x in input ( ) . split ( ) ] for y in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( w + 1 ) for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT _v , _w = vw_l [ i ] NEW_LINE for j in range ( w + 1 ) : NEW_LINE INDENT if j < _w : NEW_LINE INDENT dp [ i + 1 ] [ j ] = dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j - _w ] + _v , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ w ] ) NEW_LINE
from __future__ import ( division , absolute_import , print_function , unicode_literals ) NEW_LINE from sys import stdin NEW_LINE from math import cos , sin , atan2 , pi NEW_LINE PI2 = pi / 2 NEW_LINE L = [ None , ( 1.0 , 0.0 ) ] NEW_LINE for _ in range ( 2 , 1001 ) : NEW_LINE INDENT x , y = L [ - 1 ] NEW_LINE rad = atan2 ( y , x ) + PI2 NEW_LINE L . append ( ( x + cos ( rad ) , y + sin ( rad ) ) ) NEW_LINE DEDENT for line in stdin : NEW_LINE INDENT n = int ( line ) NEW_LINE if n == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT print ( ' { :0.2f } \n { :0.2f } ' . format ( * L [ n ] ) ) NEW_LINE DEDENT
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT count = 0 NEW_LINE curr = 1 NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( str ( curr ) + " ▁ " , end = ' ' ) NEW_LINE count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT curr = curr + 1 NEW_LINE DEDENT while ( count < k ) : NEW_LINE INDENT print ( str ( curr ) + " ▁ " , end = ' ' ) NEW_LINE curr = curr + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printKMissing ( arr , n , k ) ; NEW_LINE
def printNumbers ( a , n ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE for j in range ( 1 , num + 1 ) : NEW_LINE INDENT if j * j > num : NEW_LINE INDENT break NEW_LINE DEDENT if ( num % j == 0 ) : NEW_LINE INDENT if ( j != 1 ) : NEW_LINE INDENT mpp [ j ] = mpp . get ( j , 0 ) + 1 NEW_LINE DEDENT if ( ( num // j ) != j ) : NEW_LINE INDENT mpp [ num // j ] = mpp . get ( num // j , 0 ) + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT maxi = 0 NEW_LINE for it in mpp : NEW_LINE INDENT maxi = max ( mpp [ it ] , maxi ) NEW_LINE DEDENT for it in mpp : NEW_LINE INDENT if ( mpp [ it ] == maxi ) : NEW_LINE INDENT print ( it , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT a = [ 12 , 15 , 27 , 20 , 40 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n ) NEW_LINE
s = input ( ) NEW_LINE ts = s . replace ( " a " , " " ) NEW_LINE ls = len ( ts ) // 2 NEW_LINE ans = s [ : len ( s ) - ls ] NEW_LINE if len ( ts ) % 2 or ans . replace ( " a " , " " ) != ts [ ls : ] : NEW_LINE INDENT print ( " : ( " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE K = max ( map ( a . count , a ) ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT if a . count ( a [ i ] ) < K : NEW_LINE INDENT C = a . count ( a [ i ] ) NEW_LINE n -= C NEW_LINE Val = a [ i ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT a . remove ( Val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT MinI = 1000001 NEW_LINE ID = - 1 NEW_LINE A = list ( set ( a ) ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT j = n - 1 NEW_LINE while j >= 0 and a [ j ] != A [ i ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j < MinI : NEW_LINE INDENT MinI = j NEW_LINE ID = A [ i ] NEW_LINE DEDENT DEDENT print ( ID ) NEW_LINE
def checkIfStartsWithCapital ( string ) : NEW_LINE INDENT if ( string [ 0 ] >= ' A ' and string [ 0 ] <= ' Z ' ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def check ( string ) : NEW_LINE INDENT if ( checkIfStartsWithCapital ( string ) ) : NEW_LINE INDENT print ( " Accepted " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Accepted " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksforGeeks " ; NEW_LINE check ( string ) ; NEW_LINE string = " geeksforgeeks " ; NEW_LINE check ( string ) ; NEW_LINE DEDENT
def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) / ( n + 1 ) ) ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE print ( " Average ▁ of " , i + 1 , " numbers ▁ is " , " { : . 1 f } " . format ( avg ) ) ; NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE isprime = eulerlib . list_primality ( 999999 ) NEW_LINE primes = eulerlib . list_primes ( 999999 ) NEW_LINE consecutive = 0 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT sum = primes [ i ] NEW_LINE consec = 1 NEW_LINE for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE consec += 1 NEW_LINE if sum >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ sum ] and consec > consecutive : NEW_LINE INDENT ans = sum NEW_LINE consecutive = consec NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT i , j , maxm = 0 , 0 , 0 NEW_LINE lst = [ 1 for s in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 ) : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if maxm < lst [ i ] : NEW_LINE INDENT maxm = lst [ i ] NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ lst ▁ is " , lis ( arr , n ) ) NEW_LINE
a , b = ( i for i in input ( ) . split ( ) ) NEW_LINE z = int ( a + b ) NEW_LINE import math NEW_LINE if z ** ( 1 / 2 ) == math . floor ( z ** ( 1 / 2 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def fix ( A ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s . add ( A [ i ] ) NEW_LINE DEDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if i in s : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 ] NEW_LINE print ( fix ( A ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = abs ( A [ 0 ] + A [ 1 ] - A [ 2 ] - A [ 3 ] ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT now = 0 NEW_LINE for t in range ( 4 ) : NEW_LINE INDENT if t == i or t == j : NEW_LINE INDENT now += A [ t ] NEW_LINE DEDENT else : NEW_LINE INDENT now -= A [ t ] NEW_LINE DEDENT DEDENT if abs ( now ) < ans : NEW_LINE INDENT ans = abs ( now ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def makeOddNode ( head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE i = 0 NEW_LINE while ptr != None : NEW_LINE INDENT next = ptr . next NEW_LINE if ptr . data % 2 == 0 : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT while head != None : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = None NEW_LINE Arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 6 ) NEW_LINE n = len ( Arr ) NEW_LINE print ( " Original ▁ List : " , end = " ▁ " ) NEW_LINE printList ( head ) NEW_LINE print ( ) NEW_LINE makeOddNode ( head , Arr , n ) NEW_LINE print ( " New ▁ odd ▁ List : " , end = " ▁ " ) NEW_LINE printList ( head ) NEW_LINE DEDENT
s_max = [ 0 ] NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT s = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT s += ( 10 - j - 1 ) * ( i - j ) NEW_LINE DEDENT s_max . append ( s ) NEW_LINE DEDENT def check ( u , r , s , m ) : NEW_LINE INDENT if r == 0 : NEW_LINE INDENT return s == 0 NEW_LINE DEDENT n = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT n *= 2 NEW_LINE if u [ i ] : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT if ( n , r , s ) in m : NEW_LINE INDENT return m [ ( n , r , s ) ] NEW_LINE DEDENT if s < 0 or s > s_max [ r ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if not u [ i ] : NEW_LINE INDENT u [ i ] = True NEW_LINE ans += check ( u , r - 1 , s - i * r , m ) NEW_LINE u [ i ] = False NEW_LINE DEDENT DEDENT m [ ( n , r , s ) ] = ans NEW_LINE return m [ ( n , r , s ) ] NEW_LINE DEDENT memo = { } NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE used = [ False for i in range ( 10 ) ] NEW_LINE ans = check ( used , n , s , memo ) NEW_LINE print ( ans ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return int ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , int ( n / 2 ) ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if ( n % 2 ) : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT
MAX = 1000001 NEW_LINE MAX_sqrt = MAX ** ( 0.5 ) NEW_LINE primeUpto = [ 0 ] * ( MAX ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * ( MAX ) NEW_LINE isPrime [ 0 ] , isPrime [ 1 ] = 0 , 0 NEW_LINE for i in range ( 2 , int ( MAX_sqrt ) ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ( N - ans + 1 ) if ans else 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 10 , 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT
def countOperations ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( ( i * i ) < n and ( n % i ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( ( i * i ) > n ) : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countOperations ( n ) ) NEW_LINE
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ac = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == ' A ' and s [ i + 1 ] == ' C ' : NEW_LINE INDENT ac [ i ] = 1 NEW_LINE DEDENT DEDENT acc = [ 0 ] * n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT acc [ i + 1 ] = acc [ i ] + ac [ i ] NEW_LINE DEDENT lr = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = lr [ i ] [ 0 ] - 1 NEW_LINE r = lr [ i ] [ 1 ] - 1 NEW_LINE print ( acc [ r ] - acc [ l ] ) NEW_LINE DEDENT
T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( l , l * 2 ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 16 NEW_LINE count = [ 0 ] * ( LIMIT ** 2 // 2 ) NEW_LINE count [ 0 ] = 1 NEW_LINE s = 0 NEW_LINE for p in eulerlib . list_primes ( LIMIT ) : NEW_LINE INDENT for i in reversed ( range ( s + 1 ) ) : NEW_LINE INDENT count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS NEW_LINE DEDENT s += p NEW_LINE DEDENT isprime = eulerlib . list_primality ( s + 1 ) NEW_LINE ans = sum ( count [ i ] for i in range ( s + 1 ) if isprime [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while row_num != 0 : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 0 , n ) : NEW_LINE INDENT print ( countOddNumber ( row_num ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 93 NEW_LINE print ( " Following ▁ is ▁ minimal ▁ number " , " of ▁ change ▁ for " , n , " : ▁ " , end = " " ) NEW_LINE findMin ( n ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : all ( sorted ( str ( i ) ) == sorted ( str ( j * i ) ) for j in range ( 2 , 7 ) ) NEW_LINE ans = next ( i for i in itertools . count ( 1 ) if cond ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans ; NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findEle ( arr , n ) ) NEW_LINE DEDENT
def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT strA = ' abcd ' NEW_LINE strB = ' cbdad ' NEW_LINE print ( findExtraCharacter ( strA , strB ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT balls = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE if balls == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for cs in range ( 54 ) : NEW_LINE INDENT for ts in range ( 96 ) : NEW_LINE INDENT if pow ( cs , 3 ) <= balls : NEW_LINE INDENT ans = max ( ans , pow ( cs , 3 ) ) NEW_LINE DEDENT if ts * ( ts + 1 ) * ( ts + 2 ) // 6 <= balls : NEW_LINE INDENT ans = max ( ans , ts * ( ts + 1 ) * ( ts + 2 ) // 6 ) NEW_LINE DEDENT if pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) // 6 <= balls : NEW_LINE INDENT ans = max ( ans , pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) // 6 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def substitute ( text , a , b ) : NEW_LINE INDENT pos = 0 NEW_LINE newText = text NEW_LINE L1 = len ( a ) NEW_LINE L2 = len ( b ) NEW_LINE while True : NEW_LINE INDENT idx = newText . find ( a , pos ) NEW_LINE if idx < 0 : NEW_LINE INDENT return newText NEW_LINE DEDENT newText = newText [ : idx ] + b + newText [ idx + L1 : ] NEW_LINE pos = idx + L2 NEW_LINE DEDENT return newText NEW_LINE DEDENT def transform ( orig , goal , count ) : NEW_LINE INDENT global subs NEW_LINE global minCount NEW_LINE if len ( orig ) > len ( goal ) : NEW_LINE INDENT return NEW_LINE DEDENT if orig == goal : NEW_LINE INDENT minCount = min ( minCount , count ) NEW_LINE return NEW_LINE DEDENT for key in subs : NEW_LINE INDENT newStr = substitute ( orig , key , subs [ key ] ) NEW_LINE if newStr != orig : NEW_LINE INDENT transform ( newStr , goal , count + 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT subs = { } NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , b = input ( ) . strip ( ) . split ( ) NEW_LINE subs [ a ] = b NEW_LINE DEDENT orig = input ( ) . strip ( ) NEW_LINE goal = input ( ) . strip ( ) NEW_LINE minCount = 999999999 NEW_LINE transform ( orig , goal , 0 ) NEW_LINE if minCount == 999999999 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( minCount ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE ls = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = dict ( ) NEW_LINE ans = True NEW_LINE for el in ls : NEW_LINE INDENT if el not in cnt : NEW_LINE INDENT cnt [ el ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ el ] += 1 NEW_LINE DEDENT if cnt [ el ] > ( n + 1 ) // 2 : NEW_LINE INDENT ans = False NEW_LINE DEDENT DEDENT if ans : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE max2 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE
def operations ( op , n , k ) : NEW_LINE INDENT i , count = 0 , 0 NEW_LINE nVal = 0 NEW_LINE minimum = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE minimum = min ( minimum , nVal ) NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if ( nVal >= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( minimum ) ) // abs ( nVal ) NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if ( k <= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT op = [ - 60 , 65 , - 1 , 14 , - 25 ] NEW_LINE n = len ( op ) NEW_LINE k = 100000 NEW_LINE print ( operations ( op , n , k ) ) NEW_LINE
pref = [ 0 ] * 100010 ; NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( x ** ( 1 / 3 ) ) ; NEW_LINE rslt = x if ( cr * cr * cr == x ) else 0 ; NEW_LINE return rslt ; NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] ; NEW_LINE print ( sum , end = " ▁ " ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT compute ( ) ; NEW_LINE Q = 4 ; NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] ; NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; NEW_LINE DEDENT DEDENT
import sys NEW_LINE f = sys . stdin NEW_LINE n , r , l = map ( int , f . readline ( ) . split ( ) ) NEW_LINE appearance = [ 0 ] * n NEW_LINE point = [ 0 ] * n NEW_LINE top = 0 NEW_LINE pre_t = 0 NEW_LINE for line in f : NEW_LINE INDENT d , t , x = map ( int , line . split ( ) ) NEW_LINE d -= 1 NEW_LINE appearance [ top ] += t - pre_t NEW_LINE pre_t = t NEW_LINE point [ d ] += x NEW_LINE if 0 < x and top != d : NEW_LINE INDENT if point [ top ] < point [ d ] : NEW_LINE INDENT top = d NEW_LINE DEDENT elif point [ top ] == point [ d ] and d < top : NEW_LINE INDENT top = d NEW_LINE DEDENT DEDENT elif x < 0 and top == d : NEW_LINE INDENT top = point . index ( max ( point ) ) NEW_LINE DEDENT DEDENT appearance [ top ] += l - pre_t NEW_LINE print ( 1 + appearance . index ( max ( appearance ) ) ) NEW_LINE
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( str ( n ) + " th ▁ Centered ▁ cube ▁ number : ▁ " + str ( centered_cube ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( str ( n ) + " th ▁ Centered ▁ cube ▁ number : ▁ " + str ( centered_cube ( n ) ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for testcase in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE lef , rig , sw = 1 , 1 , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT sw = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( sw == 0 ) : NEW_LINE INDENT print ( s ) NEW_LINE continue NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT lef = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT rig = i NEW_LINE break NEW_LINE DEDENT DEDENT st = s [ : lef ] + '0' + s [ rig + 1 : ] NEW_LINE print ( st ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : print ( " True " ) NEW_LINE else : print ( " False " ) NEW_LINE if ( isPower ( 1 , 20 ) ) : print ( " True " ) NEW_LINE else : print ( " False " ) NEW_LINE if ( isPower ( 2 , 128 ) ) : print ( " True " ) NEW_LINE else : print ( " False " ) NEW_LINE if ( isPower ( 2 , 30 ) ) : print ( " True " ) NEW_LINE else : print ( " False " ) NEW_LINE
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 1 , 20 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 2 , 128 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 2 , 30 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE answer = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] ; NEW_LINE DEDENT return answer * ( 2 * k - 2 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] ; NEW_LINE k = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minimumValue ( arr , n , k ) ) ; NEW_LINE DEDENT
def bfs ( x , visited , order ) : NEW_LINE INDENT if visited [ x ] : NEW_LINE INDENT return NEW_LINE DEDENT visited [ x ] = True NEW_LINE for to in edges [ x ] : NEW_LINE INDENT bfs ( to , visited , order ) NEW_LINE DEDENT order . append ( x ) NEW_LINE DEDENT def bfs_rev ( x ) : NEW_LINE INDENT if visited [ x ] : NEW_LINE INDENT return [ ] NEW_LINE DEDENT visited [ x ] = True NEW_LINE ret = [ x ] NEW_LINE for to in rev_edges [ x ] : NEW_LINE INDENT ret += bfs_rev ( to ) NEW_LINE DEDENT return ret NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE edges = [ [ ] for _ in range ( 200 ) ] NEW_LINE rev_edges = [ [ ] for _ in range ( 200 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT u , s , d = input ( ) . split ( ) NEW_LINE u = int ( u ) - 1 NEW_LINE d = int ( d ) - 1 + 100 NEW_LINE if s == " lock " : NEW_LINE INDENT edges [ d ] . append ( u ) NEW_LINE rev_edges [ u ] . append ( d ) NEW_LINE DEDENT else : NEW_LINE INDENT edges [ u ] . append ( d ) NEW_LINE rev_edges [ d ] . append ( u ) NEW_LINE DEDENT DEDENT order = [ ] NEW_LINE visited = [ False ] * 200 NEW_LINE for i in range ( 200 ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT bfs ( i , visited , order ) NEW_LINE DEDENT DEDENT order . reverse ( ) NEW_LINE visited = [ False ] * 200 NEW_LINE for i in order : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT if len ( bfs_rev ( i ) ) >= 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / math . gcd ( arr [ i ] , lcm ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = int ( findLCM ( arr , n ) ) ; NEW_LINE count = ( r / lcm ) - ( ( l - 1 ) / lcm ) ; NEW_LINE print ( int ( count ) ) ; NEW_LINE DEDENT arr = [ 1 , 4 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE l = 1 ; NEW_LINE r = 10 ; NEW_LINE countNumbers ( arr , n , l , r ) ; NEW_LINE
def get_n ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def get_ns ( ) : NEW_LINE INDENT return [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE DEDENT import math NEW_LINE def main ( ) : NEW_LINE INDENT n = get_n ( ) NEW_LINE ns = sorted ( set ( [ get_n ( ) for _ in range ( n ) ] ) ) [ : 100 ] NEW_LINE top3 = [ 9999999999 , 9999999999 , 9999999999 ] NEW_LINE for i , a in enumerate ( ns ) : NEW_LINE INDENT for j , b in enumerate ( ns ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT keta = int ( math . log10 ( b ) ) + 1 NEW_LINE c = a * pow ( 10 , keta ) + b NEW_LINE if c < top3 [ 2 ] : NEW_LINE INDENT top3 = sorted ( top3 + [ c ] ) [ : - 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( top3 [ 2 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE n = n * 4 NEW_LINE a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] NEW_LINE mp = { } NEW_LINE a . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE area = a [ i ] * a [ j ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT x = a [ i ] * a [ j ] NEW_LINE if ( x != area ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] in mp : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , value in mp . items ( ) : NEW_LINE INDENT if ( value % 2 != 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT test = int ( input ( ) ) NEW_LINE for t in range ( 0 , test ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for key , value in map . items ( ) : NEW_LINE INDENT x = key ; NEW_LINE frequency = value ; NEW_LINE if ( x <= frequency ) : NEW_LINE INDENT ans += ( frequency - x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinDeletion ( a , n ) ) ; NEW_LINE DEDENT
def fromStart ( inp , del11 ) : NEW_LINE INDENT inp1 = inp [ 0 : del1 - 1 ] ; NEW_LINE inp2 = inp [ del1 : len ( inp ) ] ; NEW_LINE return inp1 + inp2 ; NEW_LINE DEDENT def fromEnd ( inp , del1 ) : NEW_LINE INDENT inp1 = inp [ 0 : len ( inp ) - del1 ] ; NEW_LINE inp2 = inp [ len ( inp ) - del1 + 1 : len ( inp ) ] ; NEW_LINE return inp1 + inp2 ; NEW_LINE DEDENT in1 = 1234 ; NEW_LINE inp = str ( in1 ) ; NEW_LINE del1 = 3 ; NEW_LINE print ( " num _ after _ deleting _ from _ starting " , fromStart ( inp , del1 ) ) ; NEW_LINE print ( " num _ after _ deleting _ from _ ending " , fromEnd ( inp , del1 ) ) ; NEW_LINE
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 200 NEW_LINE print ( nondecdigits ( n ) ) NEW_LINE DEDENT
anti , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = abs ( anti - c ) ; m = abs ( b - d ) NEW_LINE if anti == c : print ( anti + m , b , c + m , d ) NEW_LINE elif b == d : print ( anti , b + l , c , d + l ) NEW_LINE elif l != m : print ( - 1 ) NEW_LINE else : print ( anti , d , c , b ) NEW_LINE
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE CielWon = False NEW_LINE while ( y > 1 and x * 10 + y > 21 ) : NEW_LINE INDENT t = min ( x , 2 ) NEW_LINE x -= t NEW_LINE y -= ( 2 - t ) * 10 + 2 NEW_LINE if ( y < 2 or 10 * x + y < 22 ) : NEW_LINE INDENT CielWon = True NEW_LINE break NEW_LINE DEDENT y -= 2 NEW_LINE t = min ( 2 , y // 10 ) NEW_LINE y -= 10 * t NEW_LINE x -= 2 - t NEW_LINE DEDENT print ( ' Ciel ' if CielWon else ' Hanako ' ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE s = list ( s ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT if s [ j ] == ' . ' : NEW_LINE INDENT if ( i + j ) & 1 : s [ j ] = ' W ' NEW_LINE else : s [ j ] = ' B ' NEW_LINE DEDENT DEDENT l . append ( s ) NEW_LINE DEDENT for c in l : print ( " " . join ( c ) ) NEW_LINE
import itertools NEW_LINE def find ( s , ch ) : NEW_LINE INDENT return [ i for i , ltr in enumerate ( s ) if ltr == ch ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) . replace ( " ▁ " , " " ) NEW_LINE if '0' not in s : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT indices = find ( s , '0' ) NEW_LINE if len ( indices ) == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT maximum = 0 NEW_LINE combs = itertools . combinations ( indices , 2 ) NEW_LINE for x in combs : NEW_LINE INDENT maximum = max ( maximum , 2 + 2 * ( abs ( indices . index ( x [ 0 ] ) - indices . index ( x [ 1 ] ) ) - 1 ) - ( abs ( x [ 0 ] - x [ 1 ] ) - 1 ) ) NEW_LINE DEDENT print ( s . count ( '1' ) + maximum ) NEW_LINE DEDENT DEDENT DEDENT
def countDistictSubarray ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vid = dict ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while ( right < n and window < k ) : NEW_LINE INDENT if arr [ right ] in vid . keys ( ) : NEW_LINE INDENT vid [ arr [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vid [ arr [ right ] ] = 1 NEW_LINE DEDENT if ( vid [ arr [ right ] ] == 1 ) : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if ( window == k ) : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vid [ arr [ left ] ] -= 1 NEW_LINE if ( vid [ arr [ left ] ] == 0 ) : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 1 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistictSubarray ( arr , n ) ) NEW_LINE
n , s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = s NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = max ( ans , a + b ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : return False ; NEW_LINE if ( n <= 3 ) : return True ; NEW_LINE if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i = 5 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i = i + 6 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bin ( i ) . count ( '1' ) ; NEW_LINE if ( isPrime ( tot_bit ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT l = 6 ; NEW_LINE r = 10 ; NEW_LINE print ( primeBitsInRange ( l , r ) ) ; NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) ; NEW_LINE count += 1 NEW_LINE DEDENT return count ; NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; NEW_LINE if ( sum == k ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 4 ; NEW_LINE print ( pairs ( arr , n , k ) ) ; NEW_LINE DEDENT
from queue import Queue NEW_LINE def reverseQueueFirstKElements ( k , Queue ) : NEW_LINE INDENT if ( Queue . empty ( ) == True or k > Queue . qsize ( ) ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT Stack = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT Stack . append ( Queue . queue [ 0 ] ) NEW_LINE Queue . get ( ) NEW_LINE DEDENT while ( len ( Stack ) != 0 ) : NEW_LINE INDENT Queue . put ( Stack [ - 1 ] ) NEW_LINE Stack . pop ( ) NEW_LINE DEDENT for i in range ( Queue . qsize ( ) - k ) : NEW_LINE INDENT Queue . put ( Queue . queue [ 0 ] ) NEW_LINE Queue . get ( ) NEW_LINE DEDENT DEDENT def Print ( Queue ) : NEW_LINE INDENT while ( not Queue . empty ( ) ) : NEW_LINE INDENT print ( Queue . queue [ 0 ] , end = " ▁ " ) NEW_LINE Queue . get ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Queue = Queue ( ) NEW_LINE Queue . put ( 10 ) NEW_LINE Queue . put ( 20 ) NEW_LINE Queue . put ( 30 ) NEW_LINE Queue . put ( 40 ) NEW_LINE Queue . put ( 50 ) NEW_LINE Queue . put ( 60 ) NEW_LINE Queue . put ( 70 ) NEW_LINE Queue . put ( 80 ) NEW_LINE Queue . put ( 90 ) NEW_LINE Queue . put ( 100 ) NEW_LINE k = 5 NEW_LINE reverseQueueFirstKElements ( k , Queue ) NEW_LINE Print ( Queue ) NEW_LINE DEDENT
a = int ( input ( ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE tmp = b NEW_LINE win1 = 0 NEW_LINE win2 = 0 NEW_LINE cnt = 0 NEW_LINE for j in arr : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt % 2 == 1 : NEW_LINE INDENT print ( " errorgorn " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " maomao90" ) NEW_LINE DEDENT DEDENT
def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k / 2 NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT k = 31 NEW_LINE print ( int ( xorCalc ( k ) ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low , high = 1 , num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE mid_square = mid * mid NEW_LINE if mid_square == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid_square < num : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num = 16 NEW_LINE out = sObj . isPerfectSquare ( num ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if ( 2 * max ( a , b , c ) - ( a + b + c ) == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import os , sys , io , math NEW_LINE from tokenize import Triple NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE n = IN ( ) NEW_LINE l = I ( ) NEW_LINE c = 0 NEW_LINE r = [ ] NEW_LINE s = sum ( l ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s - l [ i ] ) / ( n - 1 ) == l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE r . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE print ( * r ) NEW_LINE
nq = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE queue = list ( ) NEW_LINE for i in range ( nq [ 0 ] ) : NEW_LINE INDENT queue . append ( input ( ) . split ( ) ) NEW_LINE DEDENT ti = 0 NEW_LINE cur = 0 NEW_LINE while int ( queue [ cur ] [ 1 ] ) > 0 : NEW_LINE INDENT num = queue [ cur ] NEW_LINE syori = int ( num [ 1 ] ) - nq [ 1 ] NEW_LINE if syori > 0 : NEW_LINE INDENT num [ 1 ] = syori NEW_LINE queue . append ( num ) NEW_LINE ti += nq [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ti += int ( num [ 1 ] ) NEW_LINE print ( ' { } ▁ { } ' . format ( num [ 0 ] , ti ) ) NEW_LINE DEDENT cur += 1 NEW_LINE if len ( queue ) <= cur : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = index - 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE rotations = 2 NEW_LINE ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] NEW_LINE index = 1 NEW_LINE print ( findElement ( arr , ranges , rotations , index ) ) NEW_LINE
MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i < MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isExists ( a , n ) : NEW_LINE INDENT freq = { i : 0 for i in a } NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if Sum % 2 == 0 : NEW_LINE INDENT if freq [ Sum // 2 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isExists ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 ; NEW_LINE return area ; NEW_LINE DEDENT d1 = 4 ; NEW_LINE d2 = 6 ; NEW_LINE print ( " Area ▁ of ▁ Kite ▁ = " , areaOfKite ( d1 , d2 ) ) ; NEW_LINE
seats = [ '0' ] * 3 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT seats [ i ] = [ ' # ' ] * ( 11 ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE endl = [ " | D | ) " , " | . | " , " | . | ) " ] NEW_LINE P = " " NEW_LINE if ( n == 0 ) : NEW_LINE INDENT P = """ + - - - - - - - - - - - - - - - - - - - - - - - - + STRNEWLINE | # . # . # . # . # . # . # . # . # . # . # . | D | ) STRNEWLINE | # . # . # . # . # . # . # . # . # . # . # . | . | STRNEWLINE | # . . . . . . . . . . . . . . . . . . . . . . . | STRNEWLINE | # . # . # . # . # . # . # . # . # . # . # . | . | ) STRNEWLINE + - - - - - - - - - - - - - - - - - - - - - - - - + """ NEW_LINE DEDENT elif ( n == 1 ) : NEW_LINE INDENT P = """ + - - - - - - - - - - - - - - - - - - - - - - - - + STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | D | ) STRNEWLINE | # . # . # . # . # . # . # . # . # . # . # . | . | STRNEWLINE | # . . . . . . . . . . . . . . . . . . . . . . . | STRNEWLINE | # . # . # . # . # . # . # . # . # . # . # . | . | ) STRNEWLINE + - - - - - - - - - - - - - - - - - - - - - - - - + """ NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT P = """ + - - - - - - - - - - - - - - - - - - - - - - - - + STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | D | ) STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | . | STRNEWLINE | # . . . . . . . . . . . . . . . . . . . . . . . | STRNEWLINE | # . # . # . # . # . # . # . # . # . # . # . | . | ) STRNEWLINE + - - - - - - - - - - - - - - - - - - - - - - - - + """ NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT P = """ + - - - - - - - - - - - - - - - - - - - - - - - - + STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | D | ) STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | . | STRNEWLINE | O . . . . . . . . . . . . . . . . . . . . . . . | STRNEWLINE | # . # . # . # . # . # . # . # . # . # . # . | . | ) STRNEWLINE + - - - - - - - - - - - - - - - - - - - - - - - - + """ NEW_LINE DEDENT elif ( n == 4 ) : NEW_LINE INDENT P = """ + - - - - - - - - - - - - - - - - - - - - - - - - + STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | D | ) STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | . | STRNEWLINE | O . . . . . . . . . . . . . . . . . . . . . . . | STRNEWLINE | O . # . # . # . # . # . # . # . # . # . # . | . | ) STRNEWLINE + - - - - - - - - - - - - - - - - - - - - - - - - + """ NEW_LINE DEDENT elif ( n == 34 ) : NEW_LINE INDENT P = """ + - - - - - - - - - - - - - - - - - - - - - - - - + STRNEWLINE | O . O . O . O . O . O . O . O . O . O . O . | D | ) STRNEWLINE | O . O . O . O . O . O . O . O . O . O . O . | . | STRNEWLINE | O . . . . . . . . . . . . . . . . . . . . . . . | STRNEWLINE | O . O . O . O . O . O . O . O . O . O . O . | . | ) STRNEWLINE + - - - - - - - - - - - - - - - - - - - - - - - - + """ NEW_LINE DEDENT if ( n <= 4 or n == 34 ) : NEW_LINE INDENT print ( P ) NEW_LINE DEDENT else : NEW_LINE INDENT n -= 1 NEW_LINE s = n // 3 NEW_LINE r = n % 3 NEW_LINE print ( " + - - - - - - - - - - - - - - - - - - - - - - - - + " ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT res = " | " + ( ' O . ' * s ) + ( ' O . ' if i < r else ' # . ' ) + ( ' # . ' * ( 11 - s - 1 ) ) + endl [ i ] NEW_LINE print ( res ) NEW_LINE if i == 1 : print ( " | O . . . . . . . . . . . . . . . . . . . . . . . | " ) NEW_LINE DEDENT print ( " + - - - - - - - - - - - - - - - - - - - - - - - - + " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def productEqual ( n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 ; prodEven = 1 NEW_LINE while n > 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE prodOdd *= digit NEW_LINE n = n // 10 NEW_LINE if n == 0 : NEW_LINE INDENT break ; NEW_LINE DEDENT digit = n % 10 NEW_LINE prodEven *= digit NEW_LINE n = n // 10 NEW_LINE DEDENT if prodOdd == prodEven : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 4324 NEW_LINE if productEqual ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
char_list = list ( map ( chr , range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) ) ) NEW_LINE char_list += list ( map ( chr , range ( ord ( ' A ' ) , ord ( ' Z ' ) + 1 ) ) ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT keys = list ( map ( int , input ( ) . split ( " ▁ " ) ) ) NEW_LINE sentence = input ( ) NEW_LINE for i in range ( len ( sentence ) ) : NEW_LINE INDENT if sentence [ i ] . isupper ( ) : NEW_LINE INDENT j = ord ( sentence [ i ] ) - ord ( ' A ' ) + 26 NEW_LINE DEDENT else : NEW_LINE INDENT j = ord ( sentence [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT print ( char_list [ j - keys [ i % len ( keys ) ] ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE checkEVENodd ( arr , n , 1 , 3 ) NEW_LINE
i = input ( ) NEW_LINE W , H , x , y , r = map ( int , i . split ( ) ) NEW_LINE if x - r < 0 or y - r < 0 or x + r > W or y + r > H : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE
import math as mt NEW_LINE def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = True NEW_LINE prime [ 1 ] = True NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( compositeProduct ( arr , n ) ) NEW_LINE
while True : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 and y == 0 : break NEW_LINE liste = [ x , y ] NEW_LINE liste . sort ( ) NEW_LINE print ( liste [ 0 ] , liste [ 1 ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = input ( ) [ : : - 1 ] NEW_LINE if n [ : 2 ] == ' op ' : NEW_LINE INDENT print ( ' FILIPINO ' ) NEW_LINE DEDENT elif n [ : 5 ] == ' adinm ' : NEW_LINE INDENT print ( ' KOREAN ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' JAPANESE ' ) NEW_LINE DEDENT DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left ; NEW_LINE d = arr [ 1 ] - arr [ 0 ] ; NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) ; NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ] ; NEW_LINE queries = 3 ; NEW_LINE q = [ [ 2 , 4 ] , [ 2 , 6 ] , [ 5 , 6 ] ] ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT
from math import * ; NEW_LINE def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 ; NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c ; NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a ; NEW_LINE y = j // b ; NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) ; NEW_LINE DEDENT DEDENT DEDENT return maxVal ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) ; NEW_LINE DEDENT
a = [ int ( input ( ) ) for i in range ( 10 ) ] NEW_LINE a . sort ( ) NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT print ( " % d " % a [ - i ] ) NEW_LINE DEDENT
import math as mt NEW_LINE def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT def numberOfPossiblePallindrome ( string , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if string [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ string [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ string [ i ] ] = 1 NEW_LINE DEDENT DEDENT k = 0 NEW_LINE num = 0 NEW_LINE den = 1 NEW_LINE fi = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] % 2 == 0 ) : NEW_LINE INDENT fi = mp [ it ] // 2 NEW_LINE DEDENT else : NEW_LINE INDENT fi = ( mp [ it ] - 1 ) // 2 NEW_LINE k += 1 NEW_LINE DEDENT num = num + fi NEW_LINE den = den * fact ( fi ) NEW_LINE DEDENT if ( num != 0 ) : NEW_LINE INDENT num = fact ( num ) NEW_LINE DEDENT ans = num // den NEW_LINE if ( k != 0 ) : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT string = " ababab " NEW_LINE n = len ( string ) NEW_LINE print ( numberOfPossiblePallindrome ( string , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT if ( l == sorted ( l , reverse = True ) ) : NEW_LINE INDENT print ( '1' ) NEW_LINE break NEW_LINE DEDENT elif ( l == sorted ( l ) ) : NEW_LINE INDENT print ( n ) NEW_LINE break NEW_LINE DEDENT elif ( l [ : n // 2 ] != sorted ( l [ : n // 2 ] ) ) : NEW_LINE INDENT l = l [ n // 2 : ] NEW_LINE n //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT l = l [ : n // 2 ] NEW_LINE n //= 2 NEW_LINE DEDENT DEDENT DEDENT
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT s = input ( ) NEW_LINE flag = False if s [ - 1 ] != ' B ' else True NEW_LINE if flag : NEW_LINE INDENT summ = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' A ' : NEW_LINE INDENT summ += 1 NEW_LINE DEDENT else : NEW_LINE INDENT summ -= 1 NEW_LINE DEDENT if summ < 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT
def first_substring ( s ) : NEW_LINE INDENT n = len ( s ) ; c = 0 ; NEW_LINE mpp = { } ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' or s [ i ] == ' # ' ) : NEW_LINE INDENT s1 = s [ c : i ] ; NEW_LINE mpp [ s1 ] = 1 ; NEW_LINE c = i + 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( s [ j ] == ' ▁ ' ) : NEW_LINE INDENT break ; NEW_LINE DEDENT s1 = s [ i : j + 1 ] ; NEW_LINE s2 = s1 ; NEW_LINE s1 = s1 [ : : - 1 ] ; NEW_LINE if s1 in mpp : NEW_LINE INDENT if mpp [ s1 ] : NEW_LINE INDENT return s2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return " - 1" ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " mango ▁ is ▁ sweet ▁ when ▁ nam ▁ en ▁ tastes ▁ it # " ; NEW_LINE s1 = first_substring ( s ) ; NEW_LINE print ( s1 ) ; NEW_LINE DEDENT
def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 44522255 NEW_LINE print ( countConsecutive ( n ) ) NEW_LINE DEDENT
def findAngle ( n ) : NEW_LINE INDENT interiorAngle = int ( ( n - 2 ) * 180 / n ) NEW_LINE exteriorAngle = int ( 360 / n ) NEW_LINE print ( " Interior ▁ angle : " , interiorAngle ) NEW_LINE print ( " Exterior ▁ angle : " , exteriorAngle ) NEW_LINE DEDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE
import math NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) , end = " ▁ " ) ; NEW_LINE print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ) ; NEW_LINE DEDENT n = 4 ; NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE
t = int ( input ( ) ) NEW_LINE for l in range ( t ) : NEW_LINE INDENT input ( ) NEW_LINE strm = input ( ) NEW_LINE ls = len ( strm ) NEW_LINE strm = strm . rstrip ( ' ) ' ) NEW_LINE if ls - len ( strm ) > len ( strm ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE x = input ( ) NEW_LINE s = " " NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( x ) - 1 , 2 ) : NEW_LINE INDENT k = x [ i : i + 2 ] NEW_LINE if k . count ( " a " ) == 2 or k . count ( " b " ) == 2 : NEW_LINE INDENT k = " ab " NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + k NEW_LINE DEDENT print ( count ) NEW_LINE print ( s ) NEW_LINE
from math import log2 NEW_LINE discard_count = 0 NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT global discard_count NEW_LINE if ( sum > k ) : NEW_LINE INDENT discard_count += power ( 2 , n - i ) NEW_LINE return ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if ( sum + a [ i ] + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if ( sum + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT def countSubsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = log2 ( K ) NEW_LINE prefix = [ 0 ] * n NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = log2 ( arr [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT prefix [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE DEDENT total = power ( 2 , n ) - 1 NEW_LINE if ( sum <= k ) : NEW_LINE INDENT return total NEW_LINE DEDENT solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return total - discard_count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 ; NEW_LINE print ( countSubsequences ( arr , n , k ) ) NEW_LINE DEDENT
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " ▁ " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT def isIdentical ( root1 , root2 ) : NEW_LINE INDENT if ( root1 == None and root2 == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( root1 != None and root2 == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( root1 == None and root2 != None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( root1 . data == root2 . data and isIdentical ( root1 . left , root2 . left ) and isIdentical ( root1 . right , root2 . right ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = newNode ( 5 ) NEW_LINE root2 = newNode ( 5 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 8 ) NEW_LINE root1 . left . left = newNode ( 2 ) NEW_LINE root1 . left . right = newNode ( 4 ) NEW_LINE root2 . left = newNode ( 3 ) NEW_LINE root2 . right = newNode ( 8 ) NEW_LINE root2 . left . left = newNode ( 2 ) NEW_LINE root2 . left . right = newNode ( 4 ) NEW_LINE if ( isIdentical ( root1 , root2 ) ) : NEW_LINE INDENT print ( " Both ▁ BSTs ▁ are ▁ identical " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " BSTs ▁ are ▁ not ▁ identical " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE si , sj = [ 0 ] * ( n + 1 ) , [ 0 ] * ( n + 1 ) NEW_LINE s = input ( ) . strip ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sj [ i + 1 ] = sj [ i ] + ( s [ i ] == ' J ' ) NEW_LINE si [ i + 1 ] = si [ i ] + ( s [ i ] == ' I ' ) NEW_LINE DEDENT ans = a = b = c = 0 NEW_LINE for i in range ( 1 , n ) : a = max ( a , sj [ i ] * ( si [ n ] - si [ i ] ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' O ' : NEW_LINE INDENT b += si [ n ] - si [ i + 1 ] NEW_LINE c += sj [ i ] NEW_LINE ans += ( si [ n ] - si [ i + 1 ] ) * sj [ i ] NEW_LINE DEDENT DEDENT print ( ans + max ( a , b , c ) ) NEW_LINE
class Dice : NEW_LINE INDENT def __init__ ( self , eyes ) : NEW_LINE INDENT self . _eyes = [ ' dummy ' ] + eyes NEW_LINE DEDENT @ property NEW_LINE def eye ( self ) : NEW_LINE INDENT return self . _eyes [ 1 ] NEW_LINE DEDENT def roll ( self , direction ) : NEW_LINE INDENT a = self . _eyes NEW_LINE if direction == ' N ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 2 ] , a [ 6 ] , a [ 3 ] , a [ 4 ] , a [ 1 ] , a [ 5 ] ] NEW_LINE DEDENT elif direction == ' S ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 5 ] , a [ 1 ] , a [ 3 ] , a [ 4 ] , a [ 6 ] , a [ 2 ] ] NEW_LINE DEDENT elif direction == ' W ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 3 ] , a [ 2 ] , a [ 6 ] , a [ 1 ] , a [ 5 ] , a [ 4 ] ] NEW_LINE DEDENT elif direction == ' E ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 4 ] , a [ 2 ] , a [ 1 ] , a [ 6 ] , a [ 5 ] , a [ 3 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ' NEWS箱推し ' ) NEW_LINE DEDENT DEDENT DEDENT eyes = input ( ) . split ( ) NEW_LINE dice = Dice ( eyes ) NEW_LINE direction_text = input ( ) NEW_LINE for d in direction_text : NEW_LINE INDENT dice . roll ( d ) NEW_LINE DEDENT print ( dice . eye ) NEW_LINE
class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def add ( data ) : NEW_LINE INDENT newnode = node ( 0 ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def printArr ( a , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT def findlength ( head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while ( curr != None ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT def convertArr ( head ) : NEW_LINE INDENT len1 = findlength ( head ) NEW_LINE arr = [ ] NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT arr . append ( curr . data ) NEW_LINE curr = curr . next NEW_LINE DEDENT printArr ( arr , len1 ) NEW_LINE DEDENT head = node ( 0 ) NEW_LINE head = add ( 1 ) NEW_LINE head . next = add ( 2 ) NEW_LINE head . next . next = add ( 3 ) NEW_LINE head . next . next . next = add ( 4 ) NEW_LINE head . next . next . next . next = add ( 5 ) NEW_LINE convertArr ( head ) NEW_LINE
import numpy as np NEW_LINE def nonDecNums ( n ) : NEW_LINE INDENT a = np . zeros ( ( n + 1 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return int ( a [ n ] [ 0 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( " Non - decreasing ▁ digits ▁ = " , nonDecNums ( n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE f = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ( i + l [ i ] ) % n NEW_LINE if x in d : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT DEDENT if f == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT min_num = min ( nums ) NEW_LINE return sum ( [ i - min_num for i in nums ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= 0 and 0 <= b : NEW_LINE INDENT print ( " Zero " ) NEW_LINE DEDENT elif a < 0 and min ( b - a , - a ) % 2 == 0 : NEW_LINE INDENT print ( " Negative " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT n = 12 NEW_LINE print ( firstSetBit ( n ) ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def maximumChars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str1 [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str1 [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT str1 = " abba " NEW_LINE print ( maximumChars ( str1 ) ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE z = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT z . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT z . sort ( ) NEW_LINE L = 0 NEW_LINE R = 0 NEW_LINE ans = 0 NEW_LINE ans1 = 0 NEW_LINE while L < n and R < n : NEW_LINE INDENT ans = max ( z [ R ] [ 1 ] , ans ) NEW_LINE if abs ( z [ L ] [ 0 ] - z [ R ] [ 0 ] ) < d : NEW_LINE INDENT ans1 += z [ R ] [ 1 ] NEW_LINE R += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans1 , ans ) NEW_LINE ans1 -= z [ L ] [ 1 ] NEW_LINE L += 1 NEW_LINE DEDENT DEDENT print ( max ( ans , ans1 ) ) NEW_LINE
from math import sqrt NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = 5 * sqrt ( 3 ) * a * a NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( ( 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * a * a * a ) NEW_LINE return volume NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area : " , " { : . 2 f } " . format ( findArea ( a ) ) ) NEW_LINE print ( " Volume : " , " { : . 2 f } " . format ( findVolume ( a ) ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT nine_pyramidal_pdf = [ 1 ] NEW_LINE PYRAMIDAL_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT nine_pyramidal_pdf = convolve ( nine_pyramidal_pdf , PYRAMIDAL_DIE_PDF ) NEW_LINE DEDENT six_cubic_pdf = [ 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT six_cubic_pdf = convolve ( six_cubic_pdf , CUBIC_DIE_PDF ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( nine_pyramidal_pdf ) ) : NEW_LINE INDENT ans += nine_pyramidal_pdf [ i ] * sum ( six_cubic_pdf [ : i ] ) NEW_LINE DEDENT ans = float ( ans ) / ( sum ( nine_pyramidal_pdf ) * sum ( six_cubic_pdf ) ) NEW_LINE return f " { ans : .7f } " NEW_LINE DEDENT def convolve ( a , b ) : NEW_LINE INDENT c = [ 0 ] * ( len ( a ) + len ( b ) - 1 ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( b ) ) : NEW_LINE INDENT c [ i + j ] += a [ i ] * b [ j ] NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = M // s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M , s = 12 , 13 , 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) ; NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT
scores_of_the_participants = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE total_scores = sum ( scores_of_the_participants ) NEW_LINE chosen_teams = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT for j in range ( i + 1 , 6 ) : NEW_LINE INDENT for k in range ( j + 1 , 6 ) : NEW_LINE INDENT if scores_of_the_participants [ i ] + scores_of_the_participants [ j ] + scores_of_the_participants [ k ] == total_scores - ( scores_of_the_participants [ i ] + scores_of_the_participants [ j ] + scores_of_the_participants [ k ] ) : NEW_LINE INDENT chosen_teams += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if chosen_teams == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT
def _popcnt32 ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT number = int ( number / 2 ) NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = int ( res | ( 1 << ( 32 - i ) ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if lst [ i ] > k : cnt += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
a1 , a2 = map ( int , input ( ) . split ( ) ) NEW_LINE t = 0 NEW_LINE if a1 == 1 and a2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT while a1 > 0 and a2 > 0 : NEW_LINE INDENT if a1 > a2 : NEW_LINE INDENT a2 += 1 NEW_LINE a1 -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT a2 -= 2 NEW_LINE a1 += 1 NEW_LINE DEDENT t += 1 NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def xorQueries ( self , arr , queries ) : NEW_LINE INDENT pref = [ 0 ] NEW_LINE for e in arr : NEW_LINE INDENT pref . append ( e ^ pref [ - 1 ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE for [ l , r ] in queries : NEW_LINE INDENT ans . append ( pref [ r + 1 ] ^ pref [ l ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE arr = [ 1 , 3 , 4 , 8 ] NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 2 ] , [ 0 , 3 ] , [ 3 , 3 ] ] NEW_LINE out = sObj . xorQueries ( arr , queries ) NEW_LINE print ( out ) NEW_LINE DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( ' a ' ) and ord ( str [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 , 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " ab4c12ed3" NEW_LINE k = 21 NEW_LINE print ( encodedChar ( str , k ) ) NEW_LINE DEDENT
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 2 NEW_LINE printPossible ( a , b , c ) NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 ; NEW_LINE sign = 1 if ( ( n + 1 ) % 2 == 0 ) else - 1 ; NEW_LINE result_sum = sign * abs_sum ; NEW_LINE return result_sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2 ; NEW_LINE print ( summation ( N ) ) ; NEW_LINE DEDENT
def sortSquare ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE sortSquare ( arr , n ) NEW_LINE print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
n , t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE f = False NEW_LINE c = 1 NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT c = ( i + 1 ) + a [ i ] NEW_LINE if ( c - 1 ) < i : NEW_LINE INDENT break NEW_LINE DEDENT if c == t : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT if c > t : NEW_LINE INDENT break NEW_LINE DEDENT i = c - 1 NEW_LINE DEDENT if f : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE * A , = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 0 : NEW_LINE INDENT s = set ( ) NEW_LINE p = i NEW_LINE can = 1 NEW_LINE while p not in s : NEW_LINE INDENT if l [ p ] == 1 : NEW_LINE INDENT can = 0 NEW_LINE break NEW_LINE DEDENT s . add ( p ) NEW_LINE l [ p ] = 1 NEW_LINE p = ( p + A [ p ] ) % n NEW_LINE DEDENT if can : NEW_LINE INDENT while l [ p ] == 1 : NEW_LINE INDENT l [ p ] = 2 NEW_LINE p = ( p + A [ p ] ) % n NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( sum ( e == 2 for e in l ) ) NEW_LINE
import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 55 NEW_LINE if ( isTriangular ( n ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k , d = 4 , 4 NEW_LINE printNumberWithDR ( k , d ) NEW_LINE DEDENT
N = 3 ; NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT i = N - 1 ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = N - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT print ( ) ; NEW_LINE i = i - 1 ; NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE rotateMatrix ( mat ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % 500 == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n // 500 ) * 500 ) NEW_LINE DEDENT
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 4513 NEW_LINE print ( getProduct ( n ) ) NEW_LINE
while 1 : NEW_LINE INDENT b , r , g , c , s , t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if t == 0 : break NEW_LINE cnt = b * 5 + r * 3 + s NEW_LINE coins = ( b * 5 + r * 3 ) * ( 15 - 2 ) NEW_LINE coins += b * 15 NEW_LINE coins += r * 15 NEW_LINE coins += 7 * g NEW_LINE coins += 2 * c NEW_LINE coins += 100 - ( t - cnt ) * 3 NEW_LINE print ( coins ) NEW_LINE DEDENT
maxn = 1010 NEW_LINE mod = 1000000007 NEW_LINE comb = [ [ 0 for i in range ( maxn ) ] for i in range ( maxn ) ] NEW_LINE comb [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT comb [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT comb [ i ] [ j ] = comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] % mod NEW_LINE DEDENT DEDENT k = int ( input ( ) ) NEW_LINE color = [ int ( input ( ) ) for i in range ( k ) ] NEW_LINE res = 1 NEW_LINE total = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod NEW_LINE total += color [ i ] % mod NEW_LINE DEDENT print ( res % mod ) NEW_LINE
PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE
def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev_n = reverseDigits ( n ) ; NEW_LINE if ( rev_n == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4562 NEW_LINE if isPalindrome ( n ) == 1 : NEW_LINE INDENT print ( " Is " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , True ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Is " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , False ) NEW_LINE DEDENT n = 2002 NEW_LINE if isPalindrome ( n ) == 1 : NEW_LINE INDENT print ( " Is " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , True ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Is " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , False ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT res = [ ] NEW_LINE pos1 = len ( num1 ) - 1 NEW_LINE pos2 = len ( num2 ) - 1 NEW_LINE carry = 0 NEW_LINE while pos1 >= 0 or pos2 >= 0 or carry == 1 : NEW_LINE INDENT digit1 = digit2 = 0 NEW_LINE if pos1 >= 0 : NEW_LINE INDENT digit1 = ord ( num1 [ pos1 ] ) - ord ( '0' ) NEW_LINE DEDENT if pos2 >= 0 : NEW_LINE INDENT digit2 = ord ( num2 [ pos2 ] ) - ord ( '0' ) NEW_LINE DEDENT res . append ( str ( ( digit1 + digit2 + carry ) % 10 ) ) NEW_LINE carry = ( digit1 + digit2 + carry ) // 10 NEW_LINE pos1 -= 1 NEW_LINE pos2 -= 1 NEW_LINE DEDENT return ' ' . join ( res [ : : - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num1 = "11" NEW_LINE num2 = "123" NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT print ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) NEW_LINE n = 2 NEW_LINE for n in range ( 10000 ) : NEW_LINE INDENT if isPerfect ( n ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ perfect ▁ number " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for x in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT p = x NEW_LINE while ( p <= n ) : NEW_LINE INDENT p = p * x NEW_LINE if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for x in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = ( int ) ( math . pow ( x , y ) ) NEW_LINE while ( p <= n and p > 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT y = y + 1 NEW_LINE p = math . pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
from math import gcd as __gcd NEW_LINE def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( __gcd ( gcd , sum - gcd ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( " a ▁ = ▁ " + str ( min ( gcd , sum - gcd ) ) + " , ▁ b ▁ = ▁ " + str ( sum - min ( gcd , sum - gcd ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , rb , cb , rd , cd = map ( int , input ( ) . split ( ) ) ; t = 0 NEW_LINE df , dp = 1 , 1 NEW_LINE while True : NEW_LINE INDENT if rb == n : NEW_LINE INDENT df = - 1 * df NEW_LINE DEDENT if cb == m : NEW_LINE INDENT dp = - 1 * dp NEW_LINE DEDENT if rb == rd or cb == cd : NEW_LINE INDENT break NEW_LINE DEDENT rb += df ; cb += dp ; t += 1 NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT
N , A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE if ( A <= N or C <= N ) : NEW_LINE INDENT if N % A == 0 : NEW_LINE INDENT X = int ( N / A ) * B NEW_LINE DEDENT else : NEW_LINE INDENT X = int ( N / A + 1 ) * B NEW_LINE DEDENT if N % C == 0 : NEW_LINE INDENT Y = int ( N / C ) * D NEW_LINE DEDENT else : NEW_LINE INDENT Y = int ( N / C + 1 ) * D NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT X = B NEW_LINE Y = D NEW_LINE DEDENT if X <= Y : NEW_LINE INDENT print ( int ( X ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( Y ) ) NEW_LINE DEDENT
def totalPairs ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE m [ x ] = m . get ( x , 0 ) + 1 ; NEW_LINE DEDENT result = 0 NEW_LINE for it in m : NEW_LINE INDENT result += ( m [ it ] * ( m [ it ] - 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 7 , 5 , 3 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( totalPairs ( arr , n ) ) NEW_LINE
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT
q , h , s , d = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE pricesfor2 = [ q * 8 , h * 4 , s * 2 , d ] NEW_LINE pricesfor2 = sorted ( pricesfor2 ) NEW_LINE nep = n % 2 == 1 NEW_LINE n //= 2 NEW_LINE res = n * pricesfor2 [ 0 ] NEW_LINE if ( nep ) : NEW_LINE INDENT res += min ( q * 4 , min ( h * 2 , s ) ) NEW_LINE DEDENT print ( res ) NEW_LINE
def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def answer ( a , b , c , d , e , f ) : NEW_LINE INDENT if ( e > f ) : NEW_LINE INDENT m = min ( a , d ) NEW_LINE ans = e * m NEW_LINE d -= m NEW_LINE ans += f * min ( b , c , d ) NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( b , c , d ) NEW_LINE ans = f * m NEW_LINE d -= m NEW_LINE ans += e * min ( a , d ) NEW_LINE DEDENT return ans NEW_LINE DEDENT for T in range ( 1 ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE f = int ( input ( ) ) NEW_LINE print ( answer ( a , b , c , d , e , f ) ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def Solve ( self , A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 2 ] * n NEW_LINE A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k < n ) : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT obj = Solution ( ) NEW_LINE a = [ 9 , 4 , 7 , 2 , 10 ] NEW_LINE print ( obj . Solve ( a ) ) NEW_LINE
def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 2147483648 NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - i * d NEW_LINE if a0 in freq : NEW_LINE INDENT freq [ a0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT if freq [ a0 ] > maxFreq : NEW_LINE INDENT maxFreq = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - maxFreq ) NEW_LINE DEDENT n = 5 NEW_LINE d = 1 NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] NEW_LINE ans = minimumChanges ( arr , n , d ) NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ [ * map ( int , input ( ) . split ( ) ) , i ] for i in range ( n ) ] NEW_LINE a = * filter ( lambda x : all ( any ( v >= u for u , v in zip ( c [ : 3 ] , x [ : 3 ] ) ) for c in a ) , a ) , NEW_LINE print ( min ( a , key = lambda x : x [ 3 ] ) [ 4 ] + 1 ) NEW_LINE
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 1 , 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE
def check ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += v [ i ] - x NEW_LINE DEDENT if sum >= s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT t = 1 NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n , s = ( int ( _ ) for _ in input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE l = 0 NEW_LINE r = 0x3f3f3f3f NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE r = min ( v [ i ] , r ) NEW_LINE DEDENT if sum < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT while l < r : NEW_LINE INDENT mid = ( l + r + 1 ) >> 1 NEW_LINE if check ( mid ) == True : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE DEDENT DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ccccdeededff " ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE ans = [ i for i in range ( 50 ) ] NEW_LINE for i in range ( 50 ) : NEW_LINE INDENT ans [ - 1 - i ] += k // 50 NEW_LINE DEDENT for i in range ( k % 50 ) : NEW_LINE INDENT ans [ - 1 - i ] += 1 NEW_LINE DEDENT print ( 50 ) NEW_LINE print ( * ans ) NEW_LINE
def zeroUpto ( digits ) : NEW_LINE INDENT first = int ( ( pow ( 10 , digits ) - 1 ) / 9 ) ; NEW_LINE second = int ( ( pow ( 9 , digits ) - 1 ) / 8 ) ; NEW_LINE return 9 * ( first - second ) ; NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = len ( num ) ; NEW_LINE total = zeroUpto ( k - 1 ) ; NEW_LINE non_zero = 0 ; NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT non_zero -= 1 ; NEW_LINE break ; NEW_LINE DEDENT non_zero += ( ( ( ord ( num [ i ] ) - ord ( '0' ) ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) ) ; NEW_LINE DEDENT no = 0 ; NEW_LINE remaining = 0 ; NEW_LINE calculatedUpto = 0 ; NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT no = no * 10 + ( ord ( num [ i ] ) - ord ( '0' ) ) ; NEW_LINE if ( i != 0 ) : NEW_LINE INDENT calculatedUpto = calculatedUpto * 10 + 9 ; NEW_LINE DEDENT DEDENT remaining = no - calculatedUpto ; NEW_LINE ans = zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) ; NEW_LINE return ans ; NEW_LINE DEDENT num = "107" ; NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to " , num , " is " , countZero ( num ) ) ; NEW_LINE num = "1264" ; NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to " , num , " is " , countZero ( num ) ) ; NEW_LINE
import math NEW_LINE def cone ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = ( a * math . sqrt ( 2 ) ) / 3 ; NEW_LINE h = ( 2 * a ) / 3 ; NEW_LINE V = 3.14 * math . pow ( r , 2 ) * h ; NEW_LINE return V ; NEW_LINE DEDENT a = 5 ; NEW_LINE print ( " { : . 4 f } " . format ( cone ( a ) ) ) ; NEW_LINE
import math as mt NEW_LINE def Prime ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( n + 1 ) ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkSumPrime ( string ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT summ += abs ( int ( string [ i - 1 ] ) - int ( string [ i ] ) ) NEW_LINE DEDENT if Prime ( summ ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT num = 142 NEW_LINE string = str ( num ) NEW_LINE s = [ i for i in string ] NEW_LINE if checkSumPrime ( s ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime \n " ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT print ( " { : . 3 f } " . format ( sum ( 8 ) ) ) NEW_LINE print ( " { : . 3 f } " . format ( sum ( 10 ) ) ) NEW_LINE
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT p = [ 2 , 5 , 1 , 3 , 4 ] ; NEW_LINE n = len ( p ) ; NEW_LINE print ( countElements ( p , n ) ) ; NEW_LINE DEDENT
x , y = input ( ) . split ( ) NEW_LINE print ( ' = ' if x == y else ' > ' if x > y else ' < ' ) NEW_LINE
def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE print ( " Volume ▁ of ▁ triangular ▁ prism : ▁ " , findVolume ( l , b , h ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE count = [ 0 ] * 26 NEW_LINE for c in s : NEW_LINE INDENT count [ ord ( c ) - ord ( " A " ) ] += 1 NEW_LINE DEDENT count . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if count [ i ] >= k : NEW_LINE INDENT res += k * k NEW_LINE print ( res ) NEW_LINE exit ( ) NEW_LINE DEDENT k -= count [ i ] NEW_LINE res += count [ i ] ** 2 NEW_LINE DEDENT print ( res ) NEW_LINE
def compute ( ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = i * ( i + 1 ) // 2 NEW_LINE pentagon = j * ( j * 3 - 1 ) // 2 NEW_LINE hexagon = k * ( k * 2 - 1 ) NEW_LINE minimum = min ( triangle , pentagon , hexagon ) NEW_LINE if minimum == max ( triangle , pentagon , hexagon ) : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT if minimum == triangle : i += 1 NEW_LINE if minimum == pentagon : j += 1 NEW_LINE if minimum == hexagon : k += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT arr = [ True ] * ( N + 1 ) ; NEW_LINE prod = 1 ; NEW_LINE res = 0 ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( arr [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = False ; NEW_LINE DEDENT prod *= p ; NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res += 1 ; NEW_LINE DEDENT p += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT N = 500 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE
from math import sqrt NEW_LINE def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X // i != i ) : NEW_LINE INDENT b . append ( X // i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " All ▁ Non - empty ▁ Subarrays " ) NEW_LINE subArray ( arr , n ) ; NEW_LINE
for n in [ * map ( int , open ( 0 ) ) ] [ 1 : ] : print ( * ( ( 0 - - n // 6 , n // 4 ) , [ - 1 ] ) [ n % 2 or n < 3 ] ) NEW_LINE
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , n ) ) ; NEW_LINE DEDENT
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( int ( n / 2 ) ) : NEW_LINE INDENT sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
_MIN = - 2147483648 NEW_LINE _MAX = 2147483648 NEW_LINE class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestLeftLeafNode ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( not temp . left . left and not temp . left . right ) : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newnode ( 1 ) NEW_LINE root . left = newnode ( 2 ) NEW_LINE root . right = newnode ( 3 ) NEW_LINE root . left . Left = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 5 ) NEW_LINE root . right . right = newnode ( 6 ) NEW_LINE root . right . left . right = newnode ( 7 ) NEW_LINE root . right . right . right = newnode ( 8 ) NEW_LINE root . right . left . right . left = newnode ( 9 ) NEW_LINE root . right . right . right . right = newnode ( 10 ) NEW_LINE result = getDeepestLeftLeafNode ( root ) NEW_LINE if result : NEW_LINE INDENT print ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ Left ▁ leaf ▁ not ▁ found " ) NEW_LINE DEDENT DEDENT
_MIN = - 2147483648 NEW_LINE _MAX = 2147483648 NEW_LINE class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestRightLeafNode ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE if ( not temp . right . left and not temp . right . right ) : NEW_LINE INDENT result = temp . right NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newnode ( 1 ) NEW_LINE root . left = newnode ( 2 ) NEW_LINE root . right = newnode ( 3 ) NEW_LINE root . left . right = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 5 ) NEW_LINE root . right . right = newnode ( 6 ) NEW_LINE root . right . left . right = newnode ( 7 ) NEW_LINE root . right . right . right = newnode ( 8 ) NEW_LINE root . right . left . right . left = newnode ( 9 ) NEW_LINE root . right . right . right . right = newnode ( 10 ) NEW_LINE result = getDeepestRightLeafNode ( root ) NEW_LINE if result : NEW_LINE INDENT print ( " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT old_a = a NEW_LINE a = b NEW_LINE b = old_a + b NEW_LINE DEDENT print ( b ) NEW_LINE
import math NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT swap ( c , d ) NEW_LINE swap ( a , b ) NEW_LINE DEDENT lcm = ( a * c ) / math . gcd ( a , c ) NEW_LINE x = lcm / a NEW_LINE b = int ( b * x ) NEW_LINE y = lcm / c NEW_LINE d = int ( d * y ) NEW_LINE k = math . gcd ( b , d ) NEW_LINE b = int ( b / k ) NEW_LINE d = int ( d / k ) NEW_LINE print ( b , " : " , d ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT
def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ : ▁ " , maxsum_SIS ( arr , n ) ) , NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : return a NEW_LINE return GCD ( b , a % b ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT finalGCD = GCD ( arr [ i ] , finalGCD ) NEW_LINE DEDENT return finalGCD NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT maxElement = findMaxSumUtil ( arr , n ) NEW_LINE return ( maxElement * n ) NEW_LINE DEDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE
import math as mt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT a , b , x , y = 20 , 52 , 5 , 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT x , y , w , h = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT cx , cy = map ( int , input ( ) . split ( ) ) NEW_LINE if x <= cx <= x + w and y <= cy <= y + h : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def divisibleby37 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( l % 3 == 1 ) : NEW_LINE INDENT n = "00" + n NEW_LINE l += 2 NEW_LINE DEDENT elif ( l % 3 == 2 ) : NEW_LINE INDENT n = "0" + n NEW_LINE l += 1 NEW_LINE DEDENT gSum = 0 NEW_LINE while ( l != 0 ) : NEW_LINE INDENT group = int ( n [ l - 3 : l ] ) NEW_LINE l = l - 3 NEW_LINE gSum = gSum + group NEW_LINE DEDENT if ( gSum >= 1000 ) : NEW_LINE INDENT return ( divisibleby37 ( str ( gSum ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gSum % 37 == 0 ) NEW_LINE DEDENT DEDENT print ( divisibleby37 ( "8955795758" ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ - 1 ] if y < n or n - 1 + pow ( y - n + 1 , 2 ) < x else [ 1 ] * ( n - 1 ) + [ y - n + 1 ] NEW_LINE sys . stdout . write ( " \n " . join ( map ( str , ans ) ) ) NEW_LINE
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def findMinCost ( X , Y , costX , costY ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE len_LCS = lcs ( X , Y , m , n ) NEW_LINE return ( costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ) NEW_LINE DEDENT X = " ef " NEW_LINE Y = " gh " NEW_LINE print ( ' Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ ' , end = ' ' ) NEW_LINE print ( ' identical ▁ is ▁ = ▁ ' , findMinCost ( X , Y , 10 , 20 ) ) NEW_LINE
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base / 2 NEW_LINE return int ( base * ( base + 1 ) / 2 ) NEW_LINE DEDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE
import math NEW_LINE def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0.0 NEW_LINE root = 0.0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT square += ( arr [ i ] ** 2 ) NEW_LINE DEDENT mean = ( square / ( float ) ( n ) ) NEW_LINE root = math . sqrt ( mean ) NEW_LINE return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " { : . 4 f } " . format ( rmsValue ( arr , n ) ) ) NEW_LINE DEDENT
m , n = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ int ( input ( ) ) for _ in range ( m ) ] NEW_LINE ce = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE dp = [ [ float ( ' inf ' ) ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if j < ce [ i ] [ 0 ] : NEW_LINE INDENT dp [ i + 1 ] [ j ] = min ( dp [ i ] [ j ] , ce [ i ] [ 1 ] ) NEW_LINE continue NEW_LINE DEDENT dp [ i + 1 ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j - ce [ i ] [ 0 ] ] + ce [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT p . sort ( ) NEW_LINE p . reverse ( ) NEW_LINE sump = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT sump [ i + 1 ] += sump [ i ] + p [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , sump [ i ] - dp [ n ] [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
class Heap : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _nodes = [ ] NEW_LINE DEDENT @ classmethod NEW_LINE def create ( cls , li ) : NEW_LINE INDENT heap = cls ( ) NEW_LINE heap . _nodes = li NEW_LINE return heap NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT self . cur = 0 NEW_LINE return self NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT if self . cur >= len ( self . _nodes ) : NEW_LINE INDENT raise StopIteration NEW_LINE DEDENT self . cur += 1 NEW_LINE node = self . _nodes [ self . cur - 1 ] NEW_LINE if self . cur // 2 - 1 >= 0 : NEW_LINE INDENT parent = self . _nodes [ self . cur // 2 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT parent = None NEW_LINE DEDENT if self . cur * 2 - 1 < len ( self . _nodes ) : NEW_LINE INDENT left = self . _nodes [ self . cur * 2 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT left = None NEW_LINE DEDENT if self . cur * 2 < len ( self . _nodes ) : NEW_LINE INDENT right = self . _nodes [ self . cur * 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT right = None NEW_LINE DEDENT return ( node , parent , left , right ) NEW_LINE DEDENT DEDENT def run ( ) : NEW_LINE INDENT _ = int ( input ( ) ) NEW_LINE nodes = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE heap = Heap . create ( nodes ) NEW_LINE for ( i , node ) in enumerate ( heap ) : NEW_LINE INDENT n , p , nl , nr = node NEW_LINE s = " node ▁ { } : ▁ key ▁ = ▁ { } , ▁ " . format ( i + 1 , n ) NEW_LINE if p is not None : NEW_LINE INDENT s += " parent ▁ key ▁ = ▁ { } , ▁ " . format ( p ) NEW_LINE DEDENT if nl is not None : NEW_LINE INDENT s += " left ▁ key ▁ = ▁ { } , ▁ " . format ( nl ) NEW_LINE DEDENT if nr is not None : NEW_LINE INDENT s += " right ▁ key ▁ = ▁ { } , ▁ " . format ( nr ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT run ( ) NEW_LINE DEDENT
import numpy as np NEW_LINE n = 6 ; m = 6 ; NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 3 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 ; m2 = 0 ; m3 = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ( j // ( m // 3 ) ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 1 ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE DEDENT print ( int ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ; NEW_LINE maxSum ( arr ) ; NEW_LINE DEDENT
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " , x5 , " , ▁ " , y5 , " ) ▁ " , end = " ▁ " ) NEW_LINE print ( " ( " , x6 , " , ▁ " , y6 , " ) ▁ " , end = " ▁ " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( " , x7 , " , ▁ " , y7 , " ) ▁ " , end = " ▁ " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( " , x8 , " , ▁ " , y8 , " ) ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE x3 = 2 NEW_LINE y3 = 3 NEW_LINE x4 = 7 NEW_LINE y4 = 9 NEW_LINE FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) NEW_LINE DEDENT
n_hamsters : int = int ( input ( ) ) NEW_LINE hamsters = input ( ) NEW_LINE hamsters_standing = len ( [ ham for ham in hamsters if ham == " X " ] ) NEW_LINE hamsters_sitting = n_hamsters - hamsters_standing NEW_LINE if hamsters_standing == hamsters_sitting : NEW_LINE INDENT print ( 0 ) NEW_LINE print ( hamsters ) NEW_LINE DEDENT elif hamsters_standing > hamsters_sitting : NEW_LINE INDENT num_change = ( hamsters_standing - hamsters_sitting ) // 2 NEW_LINE print ( num_change ) NEW_LINE result = " " NEW_LINE for hamster in hamsters : NEW_LINE INDENT if hamster == " X " and num_change > 0 : NEW_LINE INDENT result += " x " NEW_LINE num_change -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += hamster NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT else : NEW_LINE INDENT num_change = ( hamsters_sitting - hamsters_standing ) // 2 NEW_LINE print ( num_change ) NEW_LINE result = " " NEW_LINE for hamster in hamsters : NEW_LINE INDENT if hamster == " x " and num_change > 0 : NEW_LINE INDENT result += " X " NEW_LINE num_change -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += hamster NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE dm = d NEW_LINE em = e * 5 NEW_LINE max = max ( dm , em ) NEW_LINE min = min ( dm , em ) NEW_LINE rem = n % max NEW_LINE div = int ( ( n - rem ) / max ) NEW_LINE i = div NEW_LINE ans = rem NEW_LINE while i > - 1 : NEW_LINE INDENT dum = 0 NEW_LINE dum += n NEW_LINE rl = dum - ( i * max ) NEW_LINE fin = rl % min NEW_LINE if fin < ans : NEW_LINE INDENT if fin == 0 : NEW_LINE INDENT ans = 0 NEW_LINE i = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = fin NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - sys . maxsize - 1 ; NEW_LINE maxindex = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( val [ i ] / wt [ i ] ) > maxratio ) : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) ; NEW_LINE maxindex = i ; NEW_LINE DEDENT DEDENT return ( W * maxratio ) ; NEW_LINE DEDENT val = [ 14 , 27 , 44 , 19 ] ; NEW_LINE wt = [ 6 , 7 , 9 , 8 ] ; NEW_LINE n = len ( val ) ; NEW_LINE W = 50 ; NEW_LINE print ( knapSack ( W , wt , val , n ) ) ; NEW_LINE
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE index += 1 NEW_LINE i += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE index += 1 NEW_LINE j += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 9 , 8 , 13 , 2 , 19 , 14 ] NEW_LINE n = len ( arr ) NEW_LINE AlternateRearrange ( arr , n ) NEW_LINE
A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A <= C and B >= C : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 for i in range ( 32 ) ] NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = n // 2 NEW_LINE i += 1 NEW_LINE DEDENT binary = " " NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += str ( binaryNum [ j ] ) NEW_LINE DEDENT return binary NEW_LINE DEDENT def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findOccurrence ( arr , n , pattern ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT binary = decToBinary ( arr [ i ] ) NEW_LINE print ( countFreq ( pattern , binary ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 106 , 7 , 8 ] NEW_LINE pattern = "10" NEW_LINE n = len ( arr ) NEW_LINE findOccurrence ( arr , n , pattern ) NEW_LINE
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT
import random NEW_LINE class Solution ( object ) : NEW_LINE INDENT def findKthLargest ( self , nums , k ) : NEW_LINE INDENT random . shuffle ( nums ) NEW_LINE return self . quickSelection ( nums , 0 , len ( nums ) - 1 , len ( nums ) - k ) NEW_LINE DEDENT def quickSelection ( self , nums , start , end , k ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT pivot = nums [ end ] NEW_LINE left = start NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if nums [ i ] <= pivot : NEW_LINE INDENT nums [ left ] , nums [ i ] = nums [ i ] , nums [ left ] NEW_LINE left += 1 NEW_LINE DEDENT DEDENT nums [ left ] , nums [ end ] = nums [ end ] , nums [ left ] NEW_LINE if left == k : NEW_LINE INDENT return nums [ left ] NEW_LINE DEDENT elif left < k : NEW_LINE INDENT return self . quickSelection ( nums , left + 1 , end , k ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . quickSelection ( nums , start , left - 1 , k ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE out = sObj . findKthLargest ( nums , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n /= 10 ; NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 9876543 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 ; NEW_LINE sum += k ; NEW_LINE n /= 10 ; NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT return " NO " ; NEW_LINE DEDENT n = 123 ; NEW_LINE print ( isDivisible ( n ) ) ; NEW_LINE
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( " GREATER " if a > b else " LESS " if a < b else " EQUAL " ) NEW_LINE
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) NEW_LINE area = ( totalSquares * size * size ) NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 4 NEW_LINE b = 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE DEDENT
def arrange ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT if ( N == 2 or N == 3 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT even = - 1 NEW_LINE odd = - 1 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT even = N NEW_LINE odd = N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = N NEW_LINE even = N - 1 NEW_LINE DEDENT while ( odd >= 1 ) : NEW_LINE INDENT print ( odd , end = " ▁ " ) NEW_LINE odd = odd - 2 NEW_LINE DEDENT while ( even >= 2 ) : NEW_LINE INDENT print ( even , end = " ▁ " ) NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arrange ( N ) NEW_LINE DEDENT
import sys NEW_LINE def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if ( abs ( sum1 - sum2 ) < min ) : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 2 , 1 , 5 , 7 , 8 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMinEqualSums ( a , N ) ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 or n == 2 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT u = str ( ) NEW_LINE v = n // 3 NEW_LINE w = n % 3 NEW_LINE u += '21' * v NEW_LINE if w == 1 : NEW_LINE INDENT u = '1' + u NEW_LINE DEDENT elif w == 2 : NEW_LINE INDENT u += '2' NEW_LINE DEDENT print ( u ) NEW_LINE DEDENT DEDENT
def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findOptimalSolution ( a , N ) ) NEW_LINE DEDENT
n , b = map ( int , input ( ) . split ( ) ) NEW_LINE time = 0 NEW_LINE queue = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t , d = map ( int , input ( ) . split ( ) ) NEW_LINE while len ( queue ) != 0 and t >= queue [ 0 ] : NEW_LINE INDENT queue . pop ( 0 ) NEW_LINE DEDENT if len ( queue ) <= b : NEW_LINE INDENT time = max ( t , time ) + d NEW_LINE queue . append ( time ) NEW_LINE print ( time , end = " ▁ " ) NEW_LINE DEDENT else : print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT nm = input ( ) NEW_LINE nm = nm . split ( ) NEW_LINE inp = input ( ) NEW_LINE inp = inp . split ( ) NEW_LINE for i in range ( int ( nm [ 0 ] ) ) : NEW_LINE INDENT inp . append ( int ( inp [ 0 ] ) ) NEW_LINE inp . pop ( 0 ) NEW_LINE DEDENT inp . sort ( ) NEW_LINE sum1 = 0 NEW_LINE for i in range ( int ( nm [ 0 ] ) ) : NEW_LINE INDENT sum1 += max ( inp [ i - 1 ] , inp [ i ] ) NEW_LINE DEDENT if ( sum1 + int ( nm [ 0 ] ) ) <= int ( nm [ 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if k == 0 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT elif int ( s ) <= 9 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT c = 0 NEW_LINE condition = 0 NEW_LINE ans = ' ' NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == 0 and condition == 0 : NEW_LINE INDENT ans += '1' NEW_LINE if s [ i ] == '1' : NEW_LINE INDENT c += 0 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT elif condition == 0 : NEW_LINE INDENT ans += '0' NEW_LINE if s [ i ] == '0' : NEW_LINE INDENT c += 0 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == k : NEW_LINE INDENT condition = 1 NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE if j == len ( s ) - 1 : NEW_LINE INDENT c = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
a = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT data = input ( ) . split ( ) NEW_LINE a . append ( [ int ( i ) for i in data ] ) NEW_LINE DEDENT def func ( a ) : NEW_LINE INDENT band = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT if a [ i ] [ 3 ] == 1 : NEW_LINE INDENT if a [ ( i + 2 ) % 4 ] [ 1 ] : NEW_LINE INDENT band = 1 NEW_LINE DEDENT if a [ ( i + 1 ) % 4 ] [ 0 ] or a [ ( i + 3 ) % 4 ] [ 2 ] : NEW_LINE INDENT band = 1 NEW_LINE DEDENT if a [ i ] [ 0 ] or a [ i ] [ 1 ] or a [ i ] [ 2 ] : NEW_LINE INDENT band = 1 NEW_LINE DEDENT DEDENT DEDENT if band : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT func ( a ) NEW_LINE
N = 10000 ; NEW_LINE MOD = 1000000007 ; NEW_LINE F = [ 0 ] * N ; NEW_LINE def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 ; NEW_LINE F [ 2 ] = 3 ; NEW_LINE F [ 3 ] = 4 ; NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE precompute ( ) ; NEW_LINE print ( F [ n ] ) ; NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT num = 2 NEW_LINE cnt = 0 NEW_LINE while True : NEW_LINE INDENT ini = num * ( num + 1 ) // 2 NEW_LINE if n < ini : NEW_LINE INDENT break NEW_LINE DEDENT while ini <= n : NEW_LINE INDENT if ini == n : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT ini += num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def CeilIndex ( A , l , r , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( A [ m ] >= key ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def LongestIncreasingSubsequenceLength ( A , size ) : NEW_LINE INDENT tailTable = [ 0 for i in range ( size + 1 ) ] NEW_LINE len = 0 NEW_LINE tailTable [ 0 ] = A [ 0 ] NEW_LINE len = 1 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT if ( A [ i ] < tailTable [ 0 ] ) : NEW_LINE INDENT tailTable [ 0 ] = A [ i ] NEW_LINE DEDENT elif ( A [ i ] > tailTable [ len - 1 ] ) : NEW_LINE INDENT tailTable [ len ] = A [ i ] NEW_LINE len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tailTable [ CeilIndex ( tailTable , - 1 , len - 1 , A [ i ] ) ] = A [ i ] NEW_LINE DEDENT DEDENT return len NEW_LINE DEDENT A = [ 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Increasing ▁ Subsequence ▁ is ▁ " , LongestIncreasingSubsequenceLength ( A , n ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Xmn , Xmx = min ( X ) , max ( X ) NEW_LINE temp = [ ] NEW_LINE res = Xmx - Xmn NEW_LINE for x in range ( Xmn , Xmx + 1 ) : NEW_LINE INDENT for n in range ( N ) : NEW_LINE INDENT temp . append ( abs ( X [ n ] - x ) ) NEW_LINE DEDENT if max ( temp ) < res : NEW_LINE INDENT res = max ( temp ) NEW_LINE DEDENT temp = [ ] NEW_LINE DEDENT print ( res ) NEW_LINE
import math NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( 1 for i in range ( LIMIT ) if get_chain_length ( i ) == 60 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def get_chain_length ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT seen . add ( n ) NEW_LINE n = factorialize ( n ) NEW_LINE if n in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT DEDENT DEDENT def factorialize ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n != 0 : NEW_LINE INDENT result += FACTORIAL [ n % 10 ] NEW_LINE n //= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT FACTORIAL = [ math . factorial ( i ) for i in range ( 10 ) ] NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE i = K - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE DEDENT
from math import log , trunc NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( ( a + b ) // 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( min ( a , b ) , ( a + b ) // 4 ) ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT students = [ 0 for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT scores = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT students [ i ] += scores [ i ] NEW_LINE DEDENT DEDENT print ( max ( students ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE now = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if now <= l : NEW_LINE INDENT print ( l , end = ' ▁ ' ) NEW_LINE now = l + 1 NEW_LINE DEDENT elif now <= r : NEW_LINE INDENT print ( now , end = ' ▁ ' ) NEW_LINE now += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT n = 7 NEW_LINE m = 4 NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ " , countWays ( n , m ) ) NEW_LINE
def bomb_required ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT bomb_required ( 3 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( ( n + 1 ) & - ( n + 1 ) ) NEW_LINE
s = str ( input ( ) ) NEW_LINE my_str = ' ' NEW_LINE for c in s : NEW_LINE INDENT if c == '0' or c == '1' : NEW_LINE INDENT my_str += c NEW_LINE DEDENT elif c == ' B ' and len ( my_str ) != 0 : NEW_LINE INDENT my_str = my_str [ : len ( my_str ) - 1 ] NEW_LINE DEDENT DEDENT print ( my_str ) NEW_LINE
import itertools NEW_LINE while True : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE if ( n == 0 ) & ( x == 0 ) : break NEW_LINE ret = 0 NEW_LINE for v in itertools . combinations ( list ( range ( 1 , n + 1 ) ) , 3 ) : NEW_LINE INDENT if sum ( v ) == x : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT DEDENT print ( ret ) NEW_LINE DEDENT
from math import gcd as __gcd NEW_LINE MAX = 100 NEW_LINE def recur ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return - 10 ** 9 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if ( cnt % 2 == 0 ) : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT dp [ ind ] [ cnt ] = ans NEW_LINE return ans NEW_LINE DEDENT a = [ 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 ; NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( n ) ] NEW_LINE print ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE arr = sorted ( [ x - int ( x ) for x in arr if x - int ( x ) != 0 ] ) NEW_LINE o = 2 * n - len ( arr ) NEW_LINE arr_sum = sum ( arr ) NEW_LINE res = int ( 2e9 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if i + o >= n : NEW_LINE INDENT res = min ( res , abs ( i - arr_sum ) ) NEW_LINE DEDENT DEDENT print ( " % .3f " % res ) NEW_LINE
def equivalentBase4 ( bin ) : NEW_LINE INDENT if ( bin == "00" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( bin == "01" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bin == "10" ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( bin == "11" ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT def isDivisibleBy5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if ( ( l % 2 ) == 1 ) : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE isOddDigit = 1 NEW_LINE for i in range ( 0 , len ( bin ) , 2 ) : NEW_LINE INDENT if ( isOddDigit ) : NEW_LINE INDENT odd_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT isOddDigit = isOddDigit ^ 1 NEW_LINE DEDENT if ( abs ( odd_sum - even_sum ) % 5 == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT bin = "10000101001" NEW_LINE print ( isDivisibleBy5 ( bin ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE score = { } NEW_LINE score [ tuple ( range ( 8 ) ) ] = 0 NEW_LINE queue = deque ( ) NEW_LINE queue . append ( tuple ( range ( 8 ) ) ) NEW_LINE move = ( ( 1 , 4 ) , ( 0 , 2 , 5 ) , ( 1 , 3 , 6 ) , ( 2 , 7 ) , ( 0 , 5 ) , ( 1 , 4 , 6 ) , ( 2 , 5 , 7 ) , ( 3 , 6 ) ) NEW_LINE while queue : NEW_LINE INDENT puz = queue . popleft ( ) NEW_LINE pos = puz . index ( 0 ) NEW_LINE for npos in move [ pos ] : NEW_LINE INDENT npuz = list ( puz ) NEW_LINE npuz [ pos ] , npuz [ npos ] = npuz [ npos ] , 0 NEW_LINE npuz = tuple ( npuz ) NEW_LINE if npuz not in score : NEW_LINE INDENT queue . append ( npuz ) NEW_LINE score [ npuz ] = score [ puz ] + 1 NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT puzzle = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( score [ puzzle ] ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
from itertools import permutations NEW_LINE nums = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE o = input ( ) . split ( ) NEW_LINE print ( min ( eval ( " min ( ( ( a { 0 } b ) {1 } c ) {2 } d , ( a { 0 } b ) {2 } ( c { 1 } d ) ) " . format ( * o ) ) for a , b , c , d in permutations ( nums ) ) ) NEW_LINE
from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N /= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT
from time import sleep NEW_LINE x = int ( input ( ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE ans = ( x - a ) % b NEW_LINE sleep ( a * 0.001 ) NEW_LINE print ( ans ) NEW_LINE
def main ( ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE elems = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE all_same = lambda arr : all ( [ x == arr [ 0 ] for x in arr ] ) NEW_LINE if all_same ( elems ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT if not all_same ( elems [ k - 1 : ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT target = elems [ - 1 ] NEW_LINE to_delete = elems [ 0 : k - 1 ] NEW_LINE while to_delete and to_delete [ - 1 ] == target : NEW_LINE INDENT to_delete . pop ( ) NEW_LINE DEDENT print ( len ( to_delete ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " The ▁ number ▁ after ▁ unsetting ▁ the ▁ rightmost ▁ set ▁ bit " , fun ( n ) ) NEW_LINE
def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE while y in S : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT
def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if ( sum not in s . keys ( ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE s [ sum ] = 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT a = [ 12 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 4 , 3 , 8 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPairs ( a , b , n , m ) ) NEW_LINE
import math NEW_LINE def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import heapq NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE Q = [ [ ] for i in range ( n ) ] NEW_LINE queries = list ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT queries . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for query in queries : NEW_LINE INDENT if query [ 0 ] == 0 : NEW_LINE INDENT heapq . heappush ( Q [ query [ 1 ] ] , - query [ 2 ] ) NEW_LINE DEDENT elif query [ 0 ] == 1 : NEW_LINE INDENT if Q [ query [ 1 ] ] : NEW_LINE INDENT print ( - Q [ query [ 1 ] ] [ 0 ] ) NEW_LINE DEDENT DEDENT elif query [ 0 ] == 2 : NEW_LINE INDENT if Q [ query [ 1 ] ] : NEW_LINE INDENT heapq . heappop ( Q [ query [ 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT
def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is " , calculate_min_sum ( a , n ) ) NEW_LINE print ( " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is " , calculate_max_sum ( a , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE B = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( min ( len ( A ) , len ( B ) ) ) : NEW_LINE INDENT if A [ i ] < B [ i ] : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif A [ i ] > B [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( A ) < len ( B ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
N = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = 0 NEW_LINE m2 = 0 NEW_LINE m4 = 0 NEW_LINE for n in a : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT elif n % 4 != 0 : NEW_LINE INDENT m2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m4 += 1 NEW_LINE DEDENT DEDENT if m4 >= odd or ( m2 == 0 and m4 >= odd - 1 ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return true NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ len ( s2 ) - 1 ] + s2 NEW_LINE s2 = s2 [ 0 : len ( s2 ) - 1 ] NEW_LINE if ( s != s2 and isPalindrome ( s2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if ( len ( s ) <= 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT max = cnt [ 0 ] NEW_LINE for i in range ( len ( cnt ) ) : NEW_LINE INDENT if cnt [ i ] > max : NEW_LINE INDENT max = cnt [ i ] NEW_LINE DEDENT DEDENT if ( max >= len ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ans ( s ) == True : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " nolon " NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( k , n ) ) NEW_LINE
def minCost ( n , arr , cost ) : NEW_LINE INDENT Sum , totalCost = 0 , 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * Sum NEW_LINE arr [ n - 1 ] += Sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( c , a , n ) : NEW_LINE INDENT CCA , CCC , CAN = 0 , 0 , 0 NEW_LINE CAN = min ( c , a , n ) NEW_LINE c -= CAN NEW_LINE a -= CAN NEW_LINE if a > 0 and c > 0 : NEW_LINE INDENT CCA = min ( a , c // 2 ) NEW_LINE c -= ( CCA * 2 ) NEW_LINE DEDENT if c > 2 : NEW_LINE INDENT CCC = c // 3 NEW_LINE DEDENT return CAN + CCA + CCC NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT Q = int ( input ( ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT c , a , n = map ( int , input ( ) . split ( ) ) NEW_LINE ans = solve ( c , a , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE m = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ar = [ 0 ] * m NEW_LINE ans = 0 NEW_LINE if m >= 3 : NEW_LINE INDENT for i in range ( 2 , m ) : NEW_LINE INDENT if s [ i - 2 : i + 1 ] == " IOI " : NEW_LINE INDENT ar [ i ] = ar [ i - 2 ] + 1 NEW_LINE if ar [ i ] >= n : ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = input ( ) NEW_LINE length = len ( n ) NEW_LINE minval = 10000 NEW_LINE for i in range ( length - 1 ) : NEW_LINE INDENT n1 = n [ i ] NEW_LINE for j in range ( i + 1 , length ) : NEW_LINE INDENT n2 = n [ j ] NEW_LINE if int ( n1 + n2 ) % 25 == 0 : NEW_LINE INDENT val = length - i - 2 NEW_LINE if val < minval : NEW_LINE INDENT minval = val NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( minval ) NEW_LINE DEDENT
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . left = None ; NEW_LINE self . right = None ; NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return newNode ( data ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( data < root . data ) : NEW_LINE INDENT root . left = insert ( root . left , data ) ; NEW_LINE DEDENT if ( data > root . data ) : NEW_LINE INDENT root . right = insert ( root . right , data ) ; NEW_LINE DEDENT return root ; NEW_LINE DEDENT DEDENT def inOrder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return ; NEW_LINE DEDENT else : NEW_LINE INDENT inOrder ( root . left ) ; NEW_LINE print ( root . data , end = " ▁ " ) ; NEW_LINE inOrder ( root . right ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE root = None ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) ; NEW_LINE DEDENT inOrder ( root ) ; NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * ( MAX_CHAR ) NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT X = ' OldSite : GeeksforGeeks . org ' NEW_LINE Y = ' NewSite : GeeksQuiz . com ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( ' Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ' , LCSubStr ( X , Y , m , n ) ) NEW_LINE
def countOccurrences ( x , d ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( x ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT x = int ( x / 10 ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def maxOccurring ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x ; NEW_LINE DEDENT result = 0 ; NEW_LINE max_count = 1 ; NEW_LINE for d in range ( 10 ) : NEW_LINE INDENT count = countOccurrences ( x , d ) ; NEW_LINE if ( count >= max_count ) : NEW_LINE INDENT max_count = count ; NEW_LINE result = d ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT x = 1223355 ; NEW_LINE print ( " Max ▁ occurring ▁ digit ▁ is " , maxOccurring ( x ) ) ; NEW_LINE
def printLogestIncSubArr ( arr , n ) : NEW_LINE INDENT m = 1 NEW_LINE l = 1 NEW_LINE maxIndex = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( m < l ) : NEW_LINE INDENT m = l NEW_LINE maxIndex = i - m NEW_LINE DEDENT l = 1 NEW_LINE DEDENT DEDENT if ( m < l ) : NEW_LINE INDENT m = l NEW_LINE maxIndex = n - m NEW_LINE DEDENT for i in range ( maxIndex , ( m + maxIndex ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printLogestIncSubArr ( arr , n ) NEW_LINE
a = int ( input ( ) ) NEW_LINE for i in range ( a , 0 , - 1 ) : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE a = i NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l , r , x = map ( int , input ( ) . split ( ) ) NEW_LINE d = 0 NEW_LINE for i in range ( l - 1 , r ) : NEW_LINE INDENT if w [ x - 1 ] > w [ i ] : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT if d == x - l : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Maximum ▁ sum ▁ is : " , Max_Sum ( a , n ) ) NEW_LINE
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) NEW_LINE i , j = 0 , 0 NEW_LINE turn = False NEW_LINE commands = 0 NEW_LINE while True : NEW_LINE INDENT if i == x and j == y : NEW_LINE INDENT break NEW_LINE DEDENT if turn : NEW_LINE INDENT if i == x : NEW_LINE INDENT pass NEW_LINE DEDENT if i < x : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT commands += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if j == y : NEW_LINE INDENT pass NEW_LINE DEDENT elif j < y : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT commands += 1 NEW_LINE DEDENT turn = not turn NEW_LINE DEDENT print ( commands if x == y else commands - 1 ) NEW_LINE DEDENT DEDENT
def reverse ( str1 , x ) : NEW_LINE INDENT n = ( len ( str1 ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , len ( str1 ) ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT str1 = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE reverse ( str1 , x ) NEW_LINE
def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str [ i ] == str [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def minimumNumberOfDeletions ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE l = lps ( str ) NEW_LINE return ( n - l ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE print ( " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " , minimumNumberOfDeletions ( str ) ) NEW_LINE DEDENT
def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] [ : : - 1 ] NEW_LINE minprice = [ a [ 0 ] ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minprice . append ( min ( minprice [ i - 1 ] , a [ i ] ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += a [ i ] > minprice [ i ] NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE ans = 0 NEW_LINE primes = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE sqrt = eulerlib . sqrt ( LIMIT ) NEW_LINE for ( i , p ) in enumerate ( primes ) : NEW_LINE INDENT if p > sqrt : NEW_LINE INDENT break NEW_LINE DEDENT end = binary_search ( primes , LIMIT // p ) NEW_LINE ans += ( end + 1 if end >= 0 else - end - 1 ) - i NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def binary_search ( lst , x ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( lst ) NEW_LINE while start < end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if x < lst [ mid ] : NEW_LINE INDENT end = mid NEW_LINE DEDENT elif x > lst [ mid ] : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif x == lst [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT return - start - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
M = 20 NEW_LINE dp = [ ] NEW_LINE d , K = None , None NEW_LINE def count ( pos , cnt , tight , nonz , num : list ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if cnt == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if tight else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currCnt = cnt NEW_LINE if dig == d : NEW_LINE INDENT if d != 0 or not d and nonz : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT DEDENT currTight = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += count ( pos + 1 , currCnt , currTight , ( nonz or dig != 0 ) , num ) NEW_LINE DEDENT dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT global dp , K , d NEW_LINE num = [ ] NEW_LINE while x : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( 2 ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 11 NEW_LINE R = 100 NEW_LINE d = 2 NEW_LINE K = 1 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT
ip = input ( ) NEW_LINE st = " " NEW_LINE if len ( ip ) != 1 : NEW_LINE INDENT if ip [ 0 ] == "9" : NEW_LINE INDENT st = "9" NEW_LINE ip = ip [ 1 : ] NEW_LINE DEDENT for i in ip : NEW_LINE INDENT if int ( i ) > 4 : NEW_LINE INDENT n = 9 - int ( i ) NEW_LINE st += str ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT st += i NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT st = ip NEW_LINE DEDENT print ( int ( st ) ) NEW_LINE
def isPeak ( arr , n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] > num ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( j < n and arr [ j ] > num ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isTrough ( arr , n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] < num ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( j < n and arr [ j ] < num ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def printPeaksTroughs ( arr , n ) : NEW_LINE INDENT print ( " Peaks ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPeak ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE print ( " Troughs ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isTrough ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 10 , 5 , 7 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPeaksTroughs ( arr , n ) NEW_LINE
def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = " negative " , " zero " , " positive " NEW_LINE val = index ( n ) NEW_LINE print ( n , " is " , s [ val ] ) NEW_LINE DEDENT check ( 30 ) NEW_LINE check ( - 20 ) NEW_LINE check ( 0 ) NEW_LINE
def frequency ( a , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == x : count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE print ( frequency ( a , x ) ) NEW_LINE
def isNumBalanced ( N ) : NEW_LINE INDENT st = str ( N ) NEW_LINE isBalanced = True NEW_LINE freq = [ 0 ] * 10 NEW_LINE n = len ( st ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ int ( st [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 9 ) : NEW_LINE INDENT if freq [ i ] != freq [ i + 1 ] : NEW_LINE INDENT isBalanced = False NEW_LINE DEDENT DEDENT if isBalanced : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 1234567890 NEW_LINE flag = isNumBalanced ( N ) NEW_LINE if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 0 NEW_LINE for i in reversed ( range ( 100 ) ) : NEW_LINE INDENT numer , denom = e_contfrac_term ( i ) * numer + denom , numer NEW_LINE DEDENT ans = sum ( int ( c ) for c in str ( numer ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def e_contfrac_term ( i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif i % 3 == 2 : NEW_LINE INDENT return i // 3 * 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from fractions import gcd NEW_LINE import math NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = int ( ( x * y ) / ( gcd ( x , y ) ) ) NEW_LINE return int ( ( z * ans ) / ( gcd ( ans , z ) ) ) NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = math . pow ( 10 , n - 1 ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if reminder == 0 : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber += lcm - reminder NEW_LINE if ndigitnumber < math . pow ( 10 , n ) : NEW_LINE INDENT return int ( ndigitnumber ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE z = 5 NEW_LINE res = findDivisible ( n , x , y , z ) NEW_LINE if res != 0 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT
from math import gcd , sqrt NEW_LINE prime = [ True ] * 100001 NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( 100001 ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p ** 2 , 100001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT __gcd = gcd ( a , b ) NEW_LINE for i in range ( 2 , __gcd + 1 ) : NEW_LINE INDENT if prime [ i ] and __gcd % i == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE a , b = 6 , 12 NEW_LINE common_prime ( a , b ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE m_inf = float ( " - inf " ) NEW_LINE n = int ( input ( ) ) NEW_LINE phrase = [ 0 ] * ( 394 ) NEW_LINE for s , l , p in ( map ( int , input ( ) . split ( ) ) for _ in [ 0 ] * n ) : NEW_LINE INDENT for i , _p in enumerate ( phrase [ s : l + 1 ] , start = s ) : NEW_LINE INDENT phrase [ i ] = _p if _p > p else p NEW_LINE DEDENT DEDENT dp = [ 0 ] + [ m_inf ] * 393 NEW_LINE for length , p in filter ( itemgetter ( 1 ) , enumerate ( phrase ) ) : NEW_LINE INDENT for from_p , to_p , to in zip ( dp , dp [ length : ] , range ( length , 395 ) ) : NEW_LINE INDENT dp [ to ] = to_p if to_p >= from_p + p else from_p + p NEW_LINE DEDENT DEDENT result = [ dp [ int ( input ( ) ) ] for _ in [ 0 ] * int ( input ( ) ) ] NEW_LINE print ( * ( result if m_inf not in result else [ - 1 ] ) , sep = " \n " ) NEW_LINE
import sys NEW_LINE from collections import deque NEW_LINE input = sys . stdin . buffer . readline NEW_LINE N = int ( input ( ) ) NEW_LINE adj = [ [ ] for _ in range ( N + 1 ) ] NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . append ( b ) NEW_LINE adj [ b ] . append ( a ) NEW_LINE DEDENT que = deque ( ) NEW_LINE que . append ( 1 ) NEW_LINE seen = [ 0 ] * ( N + 1 ) NEW_LINE seen [ 1 ] = 1 NEW_LINE par = [ 0 ] * ( N + 1 ) NEW_LINE child_num = [ 0 ] * ( N + 1 ) NEW_LINE while que : NEW_LINE INDENT v = que . popleft ( ) NEW_LINE for u in adj [ v ] : NEW_LINE INDENT if seen [ u ] == 0 : NEW_LINE INDENT seen [ u ] = 1 NEW_LINE par [ u ] = v NEW_LINE child_num [ v ] += 1 NEW_LINE que . append ( u ) NEW_LINE DEDENT DEDENT DEDENT seq = deque ( ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if child_num [ i ] == 0 : NEW_LINE INDENT seq . append ( i ) NEW_LINE DEDENT DEDENT while seq : NEW_LINE INDENT c = seq . pop ( ) NEW_LINE seen [ c ] = 0 NEW_LINE if seen [ par [ c ] ] == 0 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE exit ( ) NEW_LINE DEDENT seen [ par [ c ] ] = 0 NEW_LINE child_num [ par [ par [ c ] ] ] -= 1 NEW_LINE if child_num [ par [ par [ c ] ] ] == 0 : NEW_LINE INDENT seq . append ( par [ par [ c ] ] ) NEW_LINE DEDENT DEDENT print ( ' Second ' ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( " ▁ " ) ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in input ( ) : NEW_LINE INDENT temp . append ( int ( i ) ) NEW_LINE DEDENT arr . append ( temp ) NEW_LINE DEDENT res = " YES " NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT try : NEW_LINE INDENT count = arr [ i + 1 ] [ j ] + arr [ i ] [ j + 1 ] + arr [ i + 1 ] [ j + 1 ] + arr [ i ] [ j ] NEW_LINE if count == 3 : NEW_LINE INDENT res = " NO " NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE pw_list = [ len ( input ( ) ) for _ in range ( n ) ] NEW_LINE pw = len ( input ( ) ) NEW_LINE p = sorted ( pw_list ) NEW_LINE head = p . index ( pw ) NEW_LINE tail = n - list ( reversed ( p ) ) . index ( pw ) - 1 NEW_LINE worst_case = head + ( ( head ) // k ) * 5 + 1 NEW_LINE best_case = tail + ( tail // k ) * 5 + 1 NEW_LINE print ( worst_case , best_case ) NEW_LINE
n = input ( ) . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . lower ( ) NEW_LINE p = input ( ) . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . lower ( ) NEW_LINE c = input ( ) . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . lower ( ) NEW_LINE z = [ n + p + c , n + c + p , c + n + p , c + p + n , p + c + n , p + n + c ] NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT q = input ( ) . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . lower ( ) NEW_LINE if q in z : print ( " ACC " ) NEW_LINE else : print ( " WA " ) NEW_LINE DEDENT
T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , L = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE a = sorted ( int ( i , 2 ) for i in input ( ) . split ( ) ) NEW_LINE b = sorted ( int ( i , 2 ) for i in input ( ) . split ( ) ) NEW_LINE ans = L + 1 NEW_LINE for i in b : NEW_LINE INDENT if sorted ( a [ 0 ] ^ i ^ j for j in a ) == b : NEW_LINE INDENT ans = min ( ans , bin ( a [ 0 ] ^ i ) . count ( '1' ) ) NEW_LINE DEDENT DEDENT if ans == L + 1 : NEW_LINE INDENT ans = ' NOT ▁ POSSIBLE ' NEW_LINE DEDENT print ( " Case ▁ # { } : ▁ { } " . format ( case , ans ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT grid [ i ] [ j ] = 0 NEW_LINE ans = max ( self . dfs ( grid , i , j ) , ans ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def dfs ( self , grid , i , j ) : NEW_LINE INDENT stack = [ ( i , j ) ] NEW_LINE area = 0 NEW_LINE while stack : NEW_LINE INDENT r , c = stack . pop ( - 1 ) NEW_LINE area += 1 NEW_LINE for nr , nc in ( ( r - 1 , c ) , ( r + 1 , c ) , ( r , c - 1 ) , ( r , c + 1 ) ) : NEW_LINE INDENT if ( 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] ) : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT return area NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE grid = [ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 ] ] NEW_LINE out = sObj . maxAreaOfIsland ( grid ) NEW_LINE print ( out ) NEW_LINE DEDENT
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 2 NEW_LINE n = 2 NEW_LINE print ( sum ( x , y , n ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if ( i * i < n + 2 and ( n % i == 0 or n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def deleteNonPrimeNodes ( head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ( ptr != None and isPrime ( ptr . data ) != True ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if ( ptr == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while ( curr != None ) : NEW_LINE INDENT if ( isPrime ( curr . data ) != True ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE print ( " Original ▁ List : ▁ " ) NEW_LINE printList ( head ) NEW_LINE head = deleteNonPrimeNodes ( head ) NEW_LINE print ( " \n Modified ▁ List : ▁ " ) NEW_LINE printList ( head ) NEW_LINE DEDENT
N , M , L = map ( int , input ( ) . split ( ) ) NEW_LINE tbl = [ [ ] for i in range ( 45 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT d , a , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE tbl [ d * N + a - 1 ] . append ( ( k , t ) ) NEW_LINE DEDENT dp = [ [ 0 for i in range ( 45 ) ] for j in range ( 45 ) ] NEW_LINE for da in range ( 5 * N ) : NEW_LINE INDENT for i in range ( L + 1 ) : NEW_LINE INDENT if i < L : NEW_LINE INDENT for k , t in tbl [ da ] : NEW_LINE INDENT dp [ da + k ] [ i + 1 ] = max ( dp [ da + k ] [ i + 1 ] , dp [ da ] [ i ] + t ) NEW_LINE DEDENT DEDENT dp [ da + 1 ] [ i ] = max ( dp [ da + 1 ] [ i ] , dp [ da ] [ i ] ) NEW_LINE DEDENT DEDENT print ( dp [ 5 * N ] [ L ] ) NEW_LINE
n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ [ " W " , 1 ] for _ in range ( n ) ] NEW_LINE b [ 0 ] = [ " R " , 1 ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b [ x - 1 ] [ 1 ] -= 1 NEW_LINE if b [ x - 1 ] [ 0 ] == " R " : NEW_LINE INDENT b [ y - 1 ] = [ " R " , b [ y - 1 ] [ 1 ] + 1 ] NEW_LINE if b [ x - 1 ] [ 1 ] == 0 : NEW_LINE INDENT b [ x - 1 ] [ 0 ] = " W " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT b [ y - 1 ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] [ 0 ] == " R " : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for k in range ( H ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT B = [ ] NEW_LINE for k in range ( H ) : NEW_LINE INDENT for l in range ( W ) : NEW_LINE INDENT if s [ k ] [ l ] == " B " : NEW_LINE INDENT B . append ( [ k , l ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for e in B : NEW_LINE INDENT for f in B : NEW_LINE INDENT ans = max ( ans , abs ( e [ 0 ] - f [ 0 ] ) + abs ( e [ 1 ] - f [ 1 ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def minReplacement ( string ) : NEW_LINE INDENT if len ( string ) > 26 : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if Hash [ j ] == 0 : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string [ i ] = chr ( j + ord ( ' a ' ) ) NEW_LINE Hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' ' . join ( string ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " xxxxyyyy " NEW_LINE minReplacement ( list ( string ) ) NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_1 = [ 0 for i in range ( n + 1 ) ] NEW_LINE post_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if ( s [ j - 1 ] == '0' ) : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if ( s [ n - j ] == '0' ) : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "000011100000" NEW_LINE print ( longestSubseq ( s ) ) NEW_LINE DEDENT
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( N / i ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( " Factor ▁ Power " ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( str ( curr ) + " \ t " + str ( cnt ) ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE
import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num = int ( num / 10 ) NEW_LINE DEDENT DEDENT longest = - sys . maxsize - 1 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] and hash [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c ) // 2 ) NEW_LINE DEDENT
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 7 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( va [ 3 ] != vb [ 3 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) NEW_LINE return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 14 NEW_LINE b = 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE DEDENT
N = 1000001 NEW_LINE c = 0 NEW_LINE n = 0 NEW_LINE m = 0 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE def dfs ( a , b , v , vis ) : NEW_LINE INDENT global c NEW_LINE vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT def Calculate ( v ) : NEW_LINE INDENT global c NEW_LINE vis = [ 0 for i in range ( n + 1 ) ] NEW_LINE c = 0 NEW_LINE dfs ( a , b , v , vis ) NEW_LINE ans1 = n - c - 1 NEW_LINE vis = [ 0 for i in range ( len ( vis ) ) ] NEW_LINE c = 0 NEW_LINE dfs ( b , a , v , vis ) NEW_LINE ans2 = n - c - 1 NEW_LINE print ( ans1 * ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE m = 7 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] NEW_LINE v = [ [ ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT v [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE v [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT Calculate ( v ) NEW_LINE DEDENT
def l ( n ) : return len ( str ( n ) ) NEW_LINE def el ( n ) : return int ( str ( n ) [ 1 : ] ) NEW_LINE def first ( n ) : return int ( str ( n ) [ 0 ] ) NEW_LINE def maxima ( n ) : NEW_LINE INDENT if l ( n ) == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT elif first ( n ) == 1 : NEW_LINE INDENT return max ( 9 ** ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( ( first ( n ) - 1 ) * 9 ** ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE print ( maxima ( n ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x = a NEW_LINE h = 0 NEW_LINE s = 0 NEW_LINE while x > 0 : NEW_LINE INDENT x -= 1 NEW_LINE h += 1 NEW_LINE s += 1 NEW_LINE DEDENT while s // b != 0 : NEW_LINE INDENT h += 1 NEW_LINE s = s - b + 1 NEW_LINE DEDENT print ( h ) NEW_LINE
import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sm = sm + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE res = max ( res , getSum ( n // i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE
l , r = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE curr = r NEW_LINE s = 0 NEW_LINE while curr : NEW_LINE INDENT s += 1 NEW_LINE curr //= 10 NEW_LINE DEDENT first = 10 ** s NEW_LINE second = first // 2 NEW_LINE ans = - 1 NEW_LINE for i in [ l , r , first , second ] : NEW_LINE INDENT if i >= l and i <= r : NEW_LINE INDENT curr = i NEW_LINE rev = ' ' NEW_LINE for k in str ( curr ) : NEW_LINE INDENT rev += str ( 9 - int ( k ) ) NEW_LINE DEDENT ans = max ( ans , int ( rev ) * curr ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
N = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = l [ i ] NEW_LINE j = i - 1 NEW_LINE while j >= 0 and l [ j ] > t : NEW_LINE INDENT l [ j + 1 ] , l [ j ] = l [ j ] , l [ j + 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT print ( * l ) NEW_LINE DEDENT
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while cnt < 2 and i * i <= num : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num //= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isProduct ( i ) and not isPerfectSquare ( i ) ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( len ( vec ) ) : NEW_LINE INDENT print ( vec [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 30 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
data = """ \ STRNEWLINE 111111101010101111100101001111111 STRNEWLINE 100000100000000001010110001000001 STRNEWLINE 101110100110110000011010001011101 STRNEWLINE 101110101011001001111101001011101 STRNEWLINE 101110101100011000111100101011101 STRNEWLINE 100000101010101011010000101000001 STRNEWLINE 111111101010101010101010101111111 STRNEWLINE 000000001111101111100111100000000 STRNEWLINE 100010111100100001011110111111001 STRNEWLINE 110111001111111100100001000101100 STRNEWLINE 011100111010000101000111010001010 STRNEWLINE 011110000110001111110101100000011 STRNEWLINE 111111111111111000111001001011000 STRNEWLINE 111000010111010011010011010100100 STRNEWLINE 101010100010110010110101010000010 STRNEWLINE 101100000101010001111101000000000 STRNEWLINE 000010100011001101000111101011010 STRNEWLINE 101001001111101111000101010001110 STRNEWLINE 101101111111000100100001110001000 STRNEWLINE 000010011000100110000011010000010 STRNEWLINE 001101101001101110010010011011000 STRNEWLINE 011101011010001000111101010100110 STRNEWLINE 111010100110011101001101000001110 STRNEWLINE 110001010010101111000101111111000 STRNEWLINE 001000111011100001010110111110000 STRNEWLINE 000000001110010110100010100010110 STRNEWLINE 111111101000101111000110101011010 STRNEWLINE 100000100111010101111100100011011 STRNEWLINE 101110101001010000101000111111000 STRNEWLINE 101110100011010010010111111011010 STRNEWLINE 101110100100011011110110101110000 STRNEWLINE 100000100110011001111100111100000 STRNEWLINE 111111101101000101001101110010001 STRNEWLINE """ NEW_LINE data = [ [ x for x in l ] for l in data . splitlines ( ) ] NEW_LINE x , y = input ( ) . split ( ) NEW_LINE x , y = int ( x ) , int ( y ) NEW_LINE print ( data [ x ] [ y ] ) NEW_LINE
from itertools import count NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE start = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT start = i NEW_LINE while ( start <= n ) : NEW_LINE INDENT count += 1 NEW_LINE start = start * 10 + i NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
import math NEW_LINE def divSum ( n ) : NEW_LINE INDENT sum = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = ( sum + i + math . floor ( n / i ) ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) ; NEW_LINE DEDENT num1 = 559 ; NEW_LINE num2 = 703 ; NEW_LINE if ( areEquivalent ( num1 , num2 ) == True ) : NEW_LINE INDENT print ( " Equivalent " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Equivalent " ) ; NEW_LINE DEDENT
def findY ( x ) : NEW_LINE INDENT if ( x > 2 ) : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE DEDENT
MOD = 1000000007 NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if a [ m ] > a [ j ] : m = j NEW_LINE DEDENT if i != m : a [ m ] , a [ i ] = a [ i ] , a [ m ] ; c += 1 NEW_LINE DEDENT print ( * a ) NEW_LINE print ( c ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE W , H = map ( int , input ( ) . split ( ) ) NEW_LINE m = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] NEW_LINE dx = [ [ 1 , 1 , 1 , 0 , - 1 , 0 ] , [ 0 , 1 , 0 , - 1 , - 1 , - 1 ] ] NEW_LINE dy = [ - 1 , 0 , 1 , 1 , 0 , - 1 ] NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT if m [ y ] [ x ] != 0 : NEW_LINE INDENT return NEW_LINE DEDENT m [ y ] [ x ] = 2 NEW_LINE for xx , yy in zip ( dx [ y % 2 ] , dy ) : NEW_LINE INDENT tx , ty = x + xx , y + yy NEW_LINE if 0 <= tx < W and 0 <= ty < H : NEW_LINE INDENT dfs ( tx , ty ) NEW_LINE DEDENT DEDENT DEDENT for x in range ( W ) : NEW_LINE INDENT dfs ( x , 0 ) NEW_LINE dfs ( x , H - 1 ) NEW_LINE DEDENT for y in range ( H ) : NEW_LINE INDENT dfs ( 0 , y ) NEW_LINE dfs ( W - 1 , y ) NEW_LINE DEDENT from itertools import product NEW_LINE n = 0 NEW_LINE for x , y in product ( range ( W ) , range ( H ) ) : NEW_LINE INDENT if m [ y ] [ x ] != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT fn = n NEW_LINE for xx , yy in zip ( dx [ y % 2 ] , dy ) : NEW_LINE INDENT tx , ty = x + xx , y + yy NEW_LINE if 0 <= tx < W and 0 <= ty < H : NEW_LINE INDENT if m [ ty ] [ tx ] == 2 : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT DEDENT print ( n ) NEW_LINE
from sys import stdin NEW_LINE from math import sqrt NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE ans = [ [ a [ 0 ] , ] , ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( ans ) - 1 NEW_LINE while r > l : NEW_LINE INDENT m = ( r + l ) // 2 NEW_LINE if a [ i ] > ans [ m ] [ len ( ans [ m ] ) - 1 ] : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if a [ i ] > ans [ l ] [ len ( ans [ l ] ) - 1 ] : NEW_LINE INDENT ans [ l ] . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( [ a [ i ] , ] ) NEW_LINE DEDENT DEDENT for arr in ans : NEW_LINE INDENT print ( * arr ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE DEDENT
from itertools import combinations NEW_LINE def find ( lst , n ) : NEW_LINE INDENT print ( ' YES ' if [ 1 for r in range ( 1 , len ( lst ) + 1 ) for subset in combinations ( lst , r ) if sum ( subset ) == n ] else ' NO ' ) NEW_LINE DEDENT find ( [ - 1 , 2 , 4 , 121 ] , 5 ) NEW_LINE
def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( fre [ i ] % k == 0 ) : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE while ( x ) : NEW_LINE INDENT str += chr ( i + ord ( ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print ( K_String ( s , k ) ) NEW_LINE DEDENT
dp = [ .0 ] * 100001 NEW_LINE dp [ 1 ] = 1. NEW_LINE for i in range ( 2 , 100001 ) : NEW_LINE INDENT a , b , j = .5 , 1 , 1 NEW_LINE while j < i and b > 1e-15 : NEW_LINE INDENT dp [ i ] += b * ( 1 - a ) * ( j + dp [ i - j - 1 ] ) NEW_LINE b *= a ; a /= 2 ; j += 1 NEW_LINE DEDENT dp [ i ] += i * b NEW_LINE DEDENT while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE print ( dp [ n ] ) NEW_LINE DEDENT
import sys NEW_LINE for l in sys . stdin : NEW_LINE INDENT a , b , n = map ( int , l . split ( " ▁ " ) ) NEW_LINE print ( sum ( map ( int , list ( str ( ( a % b ) * 10 ** n // b ) ) ) ) ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE def chk ( k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if A [ i ] <= A [ i - 1 ] : return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT X = [ ( 0 , 0 ) ] NEW_LINE def add ( x , y ) : NEW_LINE INDENT if x <= 0 : return 0 NEW_LINE if x > X [ - 1 ] [ 0 ] : NEW_LINE INDENT X . append ( ( x , 0 if x == y else 1 ) ) NEW_LINE DEDENT elif x == X [ - 1 ] [ 0 ] : NEW_LINE INDENT if X [ - 1 ] [ 1 ] + 1 < k : NEW_LINE INDENT X [ - 1 ] = ( X [ - 1 ] [ 0 ] , X [ - 1 ] [ 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if add ( x - 1 , y ) == 0 : return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while X [ - 1 ] [ 0 ] > x : NEW_LINE INDENT X . pop ( ) NEW_LINE DEDENT if x > X [ - 1 ] [ 0 ] : NEW_LINE INDENT X . append ( ( x , 1 ) ) NEW_LINE DEDENT elif x == X [ - 1 ] [ 0 ] : NEW_LINE INDENT if X [ - 1 ] [ 1 ] + 1 < k : NEW_LINE INDENT X [ - 1 ] = ( X [ - 1 ] [ 0 ] , X [ - 1 ] [ 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if add ( x - 1 , y ) == 0 : return 0 NEW_LINE DEDENT DEDENT DEDENT if X [ - 1 ] [ 0 ] < y : X . append ( ( y , 0 ) ) NEW_LINE return 1 NEW_LINE DEDENT for a in A : NEW_LINE INDENT if add ( a , a ) == 0 : return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT l , r = 0 , 1 << 18 NEW_LINE while r - l > 1 : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if chk ( m ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE
while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT s [ i ] -= b [ i ] NEW_LINE DEDENT DEDENT print ( " Yes " if min ( s ) >= 0 else " No " ) NEW_LINE DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE fre [ a ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE s = "47744" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE DEDENT
def maxZeros ( n ) : NEW_LINE INDENT if ( n == 0 or ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT setBit = 1 NEW_LINE prev = 0 NEW_LINE i = 1 NEW_LINE while ( i < 33 ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT max0 = - 10 ** 9 NEW_LINE cur = prev NEW_LINE for j in range ( i + 1 , 33 ) : NEW_LINE INDENT cur += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT if ( max0 < ( cur - prev - 1 ) ) : NEW_LINE INDENT max0 = cur - prev - 1 NEW_LINE DEDENT prev = cur NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT n = 549 NEW_LINE print ( maxZeros ( n ) ) NEW_LINE
def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 ; num = 1 ; NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num ; NEW_LINE num *= k ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) ; NEW_LINE sumAll = ( n * ( n + 1 ) ) / 2 ; NEW_LINE return ( sumAll - pwrK ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 ; k = 3 ; NEW_LINE print ( getSum ( n , k ) ) ; NEW_LINE DEDENT
def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE D = 8 NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE
def maxSum ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE l = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE print ( * l ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE maxSum ( a , n ) NEW_LINE
MAX = 1000 ; NEW_LINE def replaceSpaces ( string ) : NEW_LINE INDENT string = string . strip ( ) NEW_LINE i = len ( string ) NEW_LINE space_count = string . count ( ' ▁ ' ) NEW_LINE new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return - 1 NEW_LINE DEDENT index = new_length - 1 NEW_LINE string = list ( string ) NEW_LINE for f in range ( i - 2 , new_length - 2 ) : NEW_LINE INDENT string . append ( '0' ) NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT if string [ j ] == ' ▁ ' : NEW_LINE INDENT string [ index ] = '0' NEW_LINE string [ index - 1 ] = '2' NEW_LINE string [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index ] = string [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " Mr ▁ John ▁ Smith ▁ " NEW_LINE s = replaceSpaces ( s ) NEW_LINE print ( s ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE X = input ( ) NEW_LINE D = int ( input ( ) ) NEW_LINE ans = list ( X ) NEW_LINE done = [ False ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if D == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if ans [ i ] == "0" : NEW_LINE INDENT ans [ i ] = "1" NEW_LINE done [ i ] = True NEW_LINE D -= 1 NEW_LINE DEDENT DEDENT for i in range ( N ) [ : : - 1 ] : NEW_LINE INDENT if D == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if ans [ i ] == "1" and not done [ i ] : NEW_LINE INDENT ans [ i ] = "0" NEW_LINE D -= 1 NEW_LINE DEDENT DEDENT print ( " " . join ( ans ) ) NEW_LINE
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r > 0 ) : NEW_LINE INDENT if ( ( m % r ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( l , r ) ) NEW_LINE
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE da = a [ 0 ] NEW_LINE db = a [ 1 ] NEW_LINE if da > db : NEW_LINE INDENT if da == 9 and db == 1 : NEW_LINE INDENT print ( 9 , 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT elif da == db : NEW_LINE INDENT print ( str ( da ) + str ( 0 ) , str ( db ) + str ( 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if db - da != 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( da , db ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( [ min ( [ a [ i + 2 ] - a [ i ] for i in range ( n - 2 ) ] ) ] + [ a [ i + 1 ] - a [ i ] for i in range ( n - 1 ) ] ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( "4" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE num = list ( input ( ) ) NEW_LINE num = sorted ( num ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT sum += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE DEDENT if sum >= k : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while sum < k : NEW_LINE INDENT sum += 9 - ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE x = n NEW_LINE i = 0 NEW_LINE def f ( x , i ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT elif x % k == 0 and B <= ( x - x // k ) * A : NEW_LINE INDENT return f ( x // k , i + B ) NEW_LINE DEDENT elif x % k == 0 : NEW_LINE INDENT return f ( 1 , i + A * ( x - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return f ( x - x % k , i + A * ( x % k ) ) NEW_LINE DEDENT DEDENT print ( f ( x , 0 ) ) NEW_LINE
import math NEW_LINE def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if i < n : dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] - 1 ) NEW_LINE if j < m : dp [ i ] [ j + 1 ] = max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] - 1 ) NEW_LINE if i < n and j < m and s [ i ] == t [ j ] : dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( " % sth ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ " % n , centered_heptagonal_num ( n ) ) NEW_LINE
def missingNum ( arr , n ) : NEW_LINE INDENT minvalue = min ( arr ) NEW_LINE xornum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue = minvalue + 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT arr = [ 13 , 12 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( missingNum ( arr , n ) ) NEW_LINE
def smallestPermute ( n ) : NEW_LINE INDENT res = [ " " ] * ( n + 1 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) NEW_LINE res [ n - 2 ] = chr ( 48 + n ) NEW_LINE res [ n - 3 ] = chr ( 48 + n - 1 ) NEW_LINE DEDENT res = ' ' . join ( res ) NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE print ( smallestPermute ( n ) ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def minOperations ( a , n , K ) : NEW_LINE INDENT Map = defaultdict ( lambda : False ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if Map [ a [ i ] ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT Map [ a [ i ] ] = True NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT b . append ( a [ i ] & K ) NEW_LINE DEDENT Map . clear ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT Map [ b [ i ] ] = True NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if Map [ a [ i ] ] == True : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT Map . clear ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if Map [ b [ i ] ] == True : NEW_LINE INDENT return 2 NEW_LINE DEDENT Map [ b [ i ] ] = True NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT K = 3 NEW_LINE a = [ 1 , 2 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( a , n , K ) ) NEW_LINE DEDENT
def bfs ( i , j ) : NEW_LINE INDENT if a [ i ] [ j ] == " . " : NEW_LINE INDENT a [ i ] [ j ] = " # " NEW_LINE DEDENT res = 1 NEW_LINE wc = 0 NEW_LINE bc = 0 NEW_LINE for dy in range ( - 1 , 2 ) : NEW_LINE INDENT for dx in range ( - 1 , 2 ) : NEW_LINE INDENT if ( dx == 0 and dy != 0 ) or ( dx != 0 and dy == 0 ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT ny = i + dy NEW_LINE nx = j + dx NEW_LINE if 0 <= nx <= w - 1 and 0 <= ny <= h - 1 and a [ ny ] [ nx ] != " # " : NEW_LINE INDENT if a [ ny ] [ nx ] == " . " : NEW_LINE INDENT wct , bct , rest = bfs ( ny , nx ) NEW_LINE wc += wct NEW_LINE bc += bct NEW_LINE res += rest NEW_LINE DEDENT elif a [ ny ] [ nx ] == " W " : NEW_LINE INDENT wc += 1 NEW_LINE DEDENT elif a [ ny ] [ nx ] == " B " : NEW_LINE INDENT bc += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return wc , bc , res NEW_LINE DEDENT import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE wans = 0 NEW_LINE bans = 0 NEW_LINE if w == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ list ( input ( ) ) for _ in range ( h ) ] NEW_LINE for i in range ( w ) : NEW_LINE INDENT for j in range ( h ) : NEW_LINE INDENT if a [ j ] [ i ] == " . " : NEW_LINE INDENT wc , bc , res = bfs ( j , i ) NEW_LINE if wc > 0 and bc == 0 : NEW_LINE INDENT wans += res NEW_LINE DEDENT elif wc == 0 and bc > 0 : NEW_LINE INDENT bans += res NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( bans , wans ) NEW_LINE DEDENT
for x in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a > 59 and 360 % ( 180 - a ) == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import eulerlib , fractions , math NEW_LINE def compute ( ) : NEW_LINE INDENT NUM_COLORS = 7 NEW_LINE BALLS_PER_COLOR = 10 NEW_LINE NUM_PICKED = 20 NEW_LINE DECIMALS = 9 NEW_LINE numerator = [ 0 ] NEW_LINE def explore ( remain , limit , history ) : NEW_LINE INDENT if remain == 0 : NEW_LINE INDENT hist = list ( history ) NEW_LINE while len ( hist ) < NUM_COLORS : NEW_LINE INDENT hist . append ( 0 ) NEW_LINE DEDENT histogram = [ 0 ] * ( BALLS_PER_COLOR + 1 ) NEW_LINE for x in hist : NEW_LINE INDENT histogram [ x ] += 1 NEW_LINE DEDENT count = math . factorial ( NUM_COLORS ) NEW_LINE for x in histogram : NEW_LINE INDENT count = divide_exactly ( count , math . factorial ( x ) ) NEW_LINE DEDENT for x in hist : NEW_LINE INDENT count *= eulerlib . binomial ( BALLS_PER_COLOR , x ) NEW_LINE DEDENT distinctcolors = len ( history ) NEW_LINE numerator [ 0 ] += count * distinctcolors NEW_LINE DEDENT elif len ( history ) < NUM_COLORS : NEW_LINE INDENT for i in range ( min ( limit , remain ) , 0 , - 1 ) : NEW_LINE INDENT history . append ( i ) NEW_LINE explore ( remain - i , i , history ) NEW_LINE history . pop ( ) NEW_LINE DEDENT DEDENT DEDENT explore ( NUM_PICKED , BALLS_PER_COLOR , [ ] ) NEW_LINE denominator = eulerlib . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) NEW_LINE ans = fractions . Fraction ( numerator [ 0 ] , denominator ) NEW_LINE return format_fraction ( ans , DECIMALS ) NEW_LINE DEDENT def format_fraction ( val , digits ) : NEW_LINE INDENT if digits <= 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if val < 0 : NEW_LINE INDENT return " - " + format_fraction ( - val , digits ) NEW_LINE DEDENT s = str ( round ( val * 10 ** digits ) ) . zfill ( digits + 1 ) NEW_LINE return f " { s [ : - digits ] } . { s [ - digits : ] } " NEW_LINE DEDENT def divide_exactly ( x , y ) : NEW_LINE INDENT if x % y != 0 : NEW_LINE INDENT raise ValueError ( " Not ▁ divisible " ) NEW_LINE DEDENT return x // y NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
f = 1 NEW_LINE n , s = map ( int , input ( ) . split ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE h1 , m1 = h , m NEW_LINE if h * 60 + m - s > 0 : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE f = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT g1 = h1 * 60 + m1 NEW_LINE g2 = h * 60 + m NEW_LINE if g2 - g1 > 2 * s + 1 and f == 1 : NEW_LINE INDENT print ( ( g1 + s + 1 ) // 60 , ( g1 + s + 1 ) % 60 ) NEW_LINE f = 0 NEW_LINE DEDENT h1 , m1 = h , m NEW_LINE if i != n - 1 : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT DEDENT if f == 1 : NEW_LINE INDENT g1 = h1 * 60 + m1 NEW_LINE print ( ( g1 + s + 1 ) // 60 , ( g1 + s + 1 ) % 60 ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if b == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( a , a * b , a * b + a ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT r , a = input ( ) . split ( ) NEW_LINE if r == "0" : NEW_LINE INDENT break NEW_LINE DEDENT h = 0 NEW_LINE for x , y in zip ( r , a ) : NEW_LINE INDENT if x == y : NEW_LINE INDENT h += 1 NEW_LINE DEDENT DEDENT b = - h NEW_LINE for x in r : NEW_LINE INDENT if x in a : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT print ( h , b ) NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE MIN = - 100000000 NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE DEDENT
def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE centeredHexagonalSeries ( n ) NEW_LINE DEDENT
target = input ( ) NEW_LINE list_abc = [ " A " , " B " , " C " ] NEW_LINE old = [ ] NEW_LINE new = [ ] NEW_LINE check = [ ] NEW_LINE flag = False NEW_LINE if " ABC " in target : NEW_LINE INDENT old . append ( [ target , [ ] ] ) NEW_LINE DEDENT while old != [ ] and flag == False : NEW_LINE INDENT for i in old : NEW_LINE INDENT if i [ 0 ] == " ABC " : NEW_LINE INDENT check . append ( i [ 1 ] ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT for j in list_abc : NEW_LINE INDENT element = i [ 0 ] . replace ( " ABC " , j ) NEW_LINE if " ABC " in element : NEW_LINE INDENT new . append ( [ element , i [ 1 ] + [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT old = new [ : ] NEW_LINE new = [ ] NEW_LINE DEDENT DEDENT flag = False NEW_LINE for i in check : NEW_LINE INDENT abc = " ABC " NEW_LINE li = i NEW_LINE li . reverse ( ) NEW_LINE for j in li : NEW_LINE INDENT abc = abc . replace ( j , " ABC " ) NEW_LINE DEDENT if abc == target : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT print ( " Yes " if flag == True else " No " ) NEW_LINE
n , m = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE lists = [ ] NEW_LINE sq = 0 NEW_LINE l = k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lists . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sq = lists [ i ] . count ( " B " ) NEW_LINE if sq != 0 : NEW_LINE INDENT sq = ( sq + 1 ) // 2 NEW_LINE l = i NEW_LINE k = lists [ i ] . find ( " B " ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( l + sq , k + sq ) NEW_LINE
def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE
n = 5 NEW_LINE def diagonalsMinMax ( mat ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ i ] [ i ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count = count + 1 NEW_LINE sm = sm + n NEW_LINE n = n - 2 NEW_LINE DEDENT return sm // count NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) // 2 NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( " Yes " ) NEW_LINE else : print ( " No " ) NEW_LINE
from collections import deque NEW_LINE zero = deque ( ) NEW_LINE one = deque ( ) NEW_LINE def getLeftMostZero ( ) : NEW_LINE INDENT if not len ( zero ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zero . popleft ( ) NEW_LINE return 0 NEW_LINE DEDENT def getLeftMostOne ( ) : NEW_LINE INDENT if not len ( one ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one . popleft ( ) NEW_LINE return 1 NEW_LINE DEDENT def getLeftMostElement ( ) : NEW_LINE INDENT if not len ( zero ) and not len ( one ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif not len ( zero ) : NEW_LINE INDENT one . popleft ( ) NEW_LINE return 1 NEW_LINE DEDENT elif not len ( one ) : NEW_LINE INDENT zero . popleft ( ) NEW_LINE return 0 NEW_LINE DEDENT res = 0 if zero [ 0 ] < one [ 0 ] else 1 NEW_LINE if res == 0 : NEW_LINE INDENT zero . popleft ( ) NEW_LINE DEDENT else : NEW_LINE INDENT one . popleft ( ) NEW_LINE DEDENT return res NEW_LINE DEDENT def performQueries ( arr : list , n : int , queries : list , q : int ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT zero . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT one . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT type = queries [ i ] NEW_LINE if type == 1 : NEW_LINE INDENT print ( getLeftMostZero ( ) ) NEW_LINE DEDENT elif type == 2 : NEW_LINE INDENT print ( getLeftMostOne ( ) ) NEW_LINE DEDENT elif type == 3 : NEW_LINE INDENT print ( getLeftMostElement ( ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE queries = [ 1 , 3 , 1 ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( arr , n , queries , q ) NEW_LINE DEDENT
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , "0" , end = " ▁ " ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( "0" , val * y ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 3 ; y = 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True ; NEW_LINE div1 = i NEW_LINE div2 = S // i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S // i , S + 1 , S // i ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False ; NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT
def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE del temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE originalArray ( arr , n ) NEW_LINE
s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = input ( ) NEW_LINE a , b = 0 , 0 NEW_LINE for j in s : NEW_LINE INDENT if j == x [ 0 ] : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif j == x [ 1 ] : NEW_LINE INDENT b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + min ( a , b ) NEW_LINE a , b = 0 , 0 NEW_LINE DEDENT DEDENT ans = ans + min ( a , b ) NEW_LINE DEDENT print ( ans ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT heaters = sorted ( heaters ) + [ float ( ' inf ' ) ] NEW_LINE i = r = 0 NEW_LINE for x in sorted ( houses ) : NEW_LINE INDENT while x >= sum ( heaters [ i : i + 2 ] ) / 2. : NEW_LINE INDENT i += 1 NEW_LINE DEDENT r = max ( r , abs ( heaters [ i ] - x ) ) NEW_LINE DEDENT return r NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE houses = [ 1 , 2 , 3 ] NEW_LINE heaters = [ 2 ] NEW_LINE out = sObj . findRadius ( houses , heaters ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : ( i % 5 != 0 ) and ( not eulerlib . is_prime ( i ) ) and ( ( i - 1 ) % find_least_divisible_repunit ( i ) == 0 ) NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 7 , 2 ) ) , 25 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import pow , floor NEW_LINE res = 0 NEW_LINE def checkRecursive ( num , x , k , n ) : NEW_LINE INDENT global res NEW_LINE if ( x == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT r = floor ( pow ( num , ( 1 / n ) ) ) ; NEW_LINE for i in range ( k + 1 , r + 1 , 1 ) : NEW_LINE INDENT a = x - int ( pow ( i , n ) ) NEW_LINE if ( a >= 0 ) : NEW_LINE INDENT checkRecursive ( num , x - int ( pow ( i , n ) ) , i , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( check ( 10 , 2 ) ) NEW_LINE DEDENT
S = list ( map ( int , input ( ) ) ) NEW_LINE length = len ( S ) - 1 NEW_LINE for bit in range ( 2 ** length ) : NEW_LINE INDENT ans = S [ 0 ] NEW_LINE ope = [ ' + ' if bit & ( 2 ** i ) else ' - ' for i in range ( length ) ] NEW_LINE for i in range ( 1 , length + 1 ) : NEW_LINE INDENT if ope [ i - 1 ] == ' + ' : NEW_LINE INDENT ans += S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans -= S [ i ] NEW_LINE DEDENT DEDENT if ans == 7 : NEW_LINE INDENT print ( ' { } { } { } { } { } { } { } = 7' . format ( S [ 0 ] , ope [ 0 ] , S [ 1 ] , ope [ 1 ] , S [ 2 ] , ope [ 2 ] , S [ 3 ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT
N = int ( input ( ) ) NEW_LINE ABs = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE bsum = 0 NEW_LINE for A , B in ABs : NEW_LINE INDENT bsum += B NEW_LINE DEDENT dp = [ [ - 1 ] * ( bsum + 1 ) for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i , ( A , B ) in enumerate ( ABs ) : NEW_LINE INDENT for j in reversed ( range ( i + 1 ) ) : NEW_LINE INDENT for k in range ( bsum + 1 ) : NEW_LINE INDENT if dp [ j ] [ k ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT nk = min ( bsum , k + 2 * A - B ) NEW_LINE dp [ j + 1 ] [ nk ] = max ( dp [ j + 1 ] [ nk ] , dp [ j ] [ k ] + B ) NEW_LINE DEDENT DEDENT DEDENT answer = [ 0 ] * ( N ) NEW_LINE for j in range ( 1 , N + 1 ) : NEW_LINE INDENT for k in range ( bsum + 1 ) : NEW_LINE INDENT if dp [ j ] [ k ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT answer [ j - 1 ] = max ( answer [ j - 1 ] , dp [ j ] [ k ] + k ) NEW_LINE DEDENT DEDENT print ( * [ a / 2 for a in answer ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if ( n < 10 ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT l = len ( str ( n ) ) - 1 NEW_LINE p = int ( '9' * l ) NEW_LINE t = n - p NEW_LINE s = 0 NEW_LINE while ( t > 0 ) : NEW_LINE INDENT s += t % 10 NEW_LINE t //= 10 NEW_LINE DEDENT print ( s + 9 * l ) NEW_LINE DEDENT
def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE m = 6 NEW_LINE a = 4 NEW_LINE print ( Squares ( n , m , a ) ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n >= 6 and n % m == 0 : print ( ' YES ' ) NEW_LINE else : print ( ' NO ' ) NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j * j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if j * j * j == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 30 NEW_LINE print ( " Count ▁ of ▁ Cubes ▁ is ▁ " , countCubes ( a , b ) ) NEW_LINE DEDENT
from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE aa = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cs_a0 = Counter ( a for i , a in enumerate ( aa ) if i % 2 == 0 ) NEW_LINE cs_a1 = Counter ( a for i , a in enumerate ( aa ) if i % 2 == 1 ) NEW_LINE vs_a0 = sorted ( ( ( v , k ) for k , v in cs_a0 . items ( ) ) , reverse = True ) NEW_LINE vs_a1 = sorted ( ( ( v , k ) for k , v in cs_a1 . items ( ) ) , reverse = True ) NEW_LINE if vs_a0 [ 0 ] [ 1 ] != vs_a1 [ 0 ] [ 1 ] : NEW_LINE INDENT print ( n - vs_a0 [ 0 ] [ 0 ] - vs_a1 [ 0 ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res = 1 << 30 NEW_LINE if len ( vs_a0 ) == 1 and len ( vs_a1 ) == 1 : NEW_LINE INDENT res = n // 2 NEW_LINE DEDENT if len ( vs_a0 ) > 1 : NEW_LINE INDENT res = min ( res , n - vs_a0 [ 1 ] [ 0 ] - vs_a1 [ 0 ] [ 0 ] ) NEW_LINE DEDENT if len ( vs_a1 ) > 1 : NEW_LINE INDENT res = min ( res , n - vs_a0 [ 0 ] [ 0 ] - vs_a1 [ 1 ] [ 0 ] ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def subString ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for len in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( s [ i : len ] ) ; NEW_LINE DEDENT DEDENT DEDENT s = " abcd " ; NEW_LINE subString ( s , len ( s ) ) ; NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c0 = 0 ; c1 = 0 ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and isPrime ( i ) ) : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT if ( arr [ i ] == 1 and isPrime ( i ) ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ 0s ▁ = " , c0 ) ; NEW_LINE print ( " Number ▁ of ▁ 1s ▁ = " , c1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] ; NEW_LINE countPrimePosition ( arr ) ; NEW_LINE DEDENT
def angleextcycquad ( z ) : NEW_LINE INDENT print ( " The ▁ exterior ▁ angle ▁ of ▁ the " , end = " " ) ; NEW_LINE print ( " cyclic ▁ quadrilateral ▁ is ▁ " , end = " " ) ; NEW_LINE print ( z , " ▁ degrees " ) ; NEW_LINE DEDENT z = 48 ; NEW_LINE angleextcycquad ( z ) ; NEW_LINE
def printMinIndexChar ( Str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " , Str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT Str = " geeksforgeeks " NEW_LINE patt = " set " NEW_LINE printMinIndexChar ( Str , patt ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for _ in range ( 0 , n ) : NEW_LINE INDENT a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if a != b : NEW_LINE INDENT print ( " Happy ▁ Alex " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " Poor ▁ Alex " ) NEW_LINE DEDENT
def maxnumber ( n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while n // i > 0 : NEW_LINE INDENT temp = ( n // ( i * 10 ) ) * i + ( n % i ) NEW_LINE i *= 10 NEW_LINE if temp > ans : NEW_LINE INDENT ans = temp NEW_LINE DEDENT DEDENT n = ans NEW_LINE DEDENT return ans ; NEW_LINE DEDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE
N , M = map ( int , input ( ) . split ( ) ) NEW_LINE L = [ 0 ] * ( N * 2 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , l = map ( int , input ( ) . split ( ) ) NEW_LINE for ll in range ( a , a + l ) : NEW_LINE INDENT L [ ll ] = 1 NEW_LINE DEDENT DEDENT for i in range ( N , 2 * N ) : NEW_LINE INDENT L [ i - N ] = max ( L [ i - N ] , L [ i ] ) NEW_LINE DEDENT left = 0 NEW_LINE i = 0 NEW_LINE while L [ i ] == 1 : NEW_LINE INDENT left += 1 NEW_LINE i += 1 NEW_LINE if i == N : NEW_LINE INDENT print ( N , 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT A = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( i , N ) : NEW_LINE INDENT li = L [ i ] NEW_LINE if li == 0 : NEW_LINE INDENT if s != 0 : NEW_LINE INDENT A . append ( s ) NEW_LINE DEDENT s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT if s + left != 0 : NEW_LINE INDENT A . append ( s + left ) NEW_LINE DEDENT A . sort ( reverse = True ) NEW_LINE v = A [ 0 ] NEW_LINE n = 0 NEW_LINE for a in A : NEW_LINE INDENT if a == v : NEW_LINE INDENT n += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( v , n ) NEW_LINE n = 1 NEW_LINE v = a NEW_LINE DEDENT DEDENT print ( v , n ) NEW_LINE
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cntA , sumA = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumA += A [ i ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT if sumA <= 0 : NEW_LINE INDENT cntA += abs ( sumA ) + 1 NEW_LINE sumA += abs ( sumA ) + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if sumA >= 0 : NEW_LINE INDENT cntA += abs ( sumA ) + 1 NEW_LINE sumA -= abs ( sumA ) + 1 NEW_LINE DEDENT DEDENT DEDENT cntB , sumB = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumB += A [ i ] NEW_LINE if i % 2 != 0 : NEW_LINE INDENT if sumB <= 0 : NEW_LINE INDENT cntB += abs ( sumB ) + 1 NEW_LINE sumB += abs ( sumB ) + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if sumB >= 0 : NEW_LINE INDENT cntB += abs ( sumB ) + 1 NEW_LINE sumB -= abs ( sumB ) + 1 NEW_LINE DEDENT DEDENT DEDENT print ( min ( cntA , cntB ) ) NEW_LINE
def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT ans = ans % 100 NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 1 , 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " : ▁ " , get_last_two_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT
binaryNumber = "1001" NEW_LINE s = int ( binaryNumber , 2 ) NEW_LINE print ( s ) NEW_LINE
from math import ceil , floor NEW_LINE def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE a = round ( a , 8 ) NEW_LINE if ( ceil ( a ) == 1 & floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 0.70710678 NEW_LINE m = 0.5 NEW_LINE n = 0.5 NEW_LINE if ( isPossible ( l , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE sum = a [ - 1 ] NEW_LINE neg = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT val = neg + i * ( a [ i ] - a [ i - 1 ] ) NEW_LINE sum -= val NEW_LINE neg = val NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < size and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE return findMissingPositive ( arr [ shift : ] , size - shift ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " , missing ) NEW_LINE
mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] + a [ 1 ] > a [ - 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 2 , n ) NEW_LINE DEDENT DEDENT
def convert12 ( str ) : NEW_LINE INDENT h1 = ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE h2 = ord ( str [ 1 ] ) - ord ( '0' ) ; NEW_LINE hh = h1 * 10 + h2 ; NEW_LINE Meridien = " " ; NEW_LINE if ( hh < 12 ) : NEW_LINE INDENT Meridien = " AM " ; NEW_LINE DEDENT else : NEW_LINE INDENT Meridien = " PM " ; NEW_LINE DEDENT hh %= 12 ; NEW_LINE if ( hh == 0 ) : NEW_LINE INDENT print ( "12" , end = " " ) ; NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( hh , end = " " ) ; NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT print ( " ▁ " + Meridien ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "17:35:20" ; NEW_LINE convert12 ( str ) ; NEW_LINE DEDENT
def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct = ct + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT a = " xaxa " NEW_LINE b = " xaxaxaxa " NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE printknapSack ( W , wt , val , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE q = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = input ( ) . split ( ) NEW_LINE q . append ( a ) NEW_LINE DEDENT for j in q : NEW_LINE INDENT for k in q : NEW_LINE INDENT if k == j : NEW_LINE INDENT continue NEW_LINE DEDENT elif j [ 0 ] == k [ len ( k ) - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE
def indexedSequentialSearch ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 ] * 20 NEW_LINE indices = [ 0 ] * 20 NEW_LINE j , ind = 0 , 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT elements [ ind ] = arr [ i ] NEW_LINE indices [ ind ] = i NEW_LINE ind += 1 NEW_LINE DEDENT if k < elements [ 0 ] : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if k < elements [ i ] : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end = indices [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if k == arr [ i ] : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 1 : NEW_LINE INDENT print ( " Found ▁ at ▁ index " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE indexedSequentialSearch ( arr , n , k ) NEW_LINE DEDENT
def larrgestPalindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit = upper_limit * 10 NEW_LINE upper_limit = upper_limit + 9 NEW_LINE DEDENT lower_limit = 1 + upper_limit // 10 NEW_LINE max_product = 0 NEW_LINE for i in range ( upper_limit , lower_limit - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , lower_limit - 1 , - 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if ( product < max_product ) : NEW_LINE INDENT break NEW_LINE DEDENT number = product NEW_LINE reverse = 0 NEW_LINE while ( number != 0 ) : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number = number // 10 NEW_LINE DEDENT if ( product == reverse and product > max_product ) : NEW_LINE INDENT max_product = product NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT n = 2 NEW_LINE print ( larrgestPalindrome ( n ) ) NEW_LINE
import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE seq = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE dp = [ seq [ 0 ] ] NEW_LINE for num in seq : NEW_LINE INDENT if num > dp [ - 1 ] : NEW_LINE INDENT dp . append ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ bisect . bisect_left ( dp , num ) ] = num NEW_LINE DEDENT DEDENT print ( len ( dp ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if a > 0 : NEW_LINE INDENT a -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT if b > 0 : NEW_LINE INDENT b -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT if c > 0 : NEW_LINE INDENT c -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT cDown = False NEW_LINE if c > 1 : NEW_LINE INDENT if c > 0 and b > 0 : NEW_LINE INDENT c -= 1 NEW_LINE b -= 1 NEW_LINE ans += 1 NEW_LINE cDown = True NEW_LINE DEDENT DEDENT if a > 0 and b > 0 : NEW_LINE INDENT a -= 1 NEW_LINE b -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT if c > 0 and b > 0 and not cDown : NEW_LINE INDENT c -= 1 NEW_LINE b -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT if a > 0 and c > 0 : NEW_LINE INDENT a -= 1 NEW_LINE c -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT if a > 0 and b > 0 and c > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( str ( min ( 7 , ans ) ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE diff = [ abs ( arr [ i ] - arr [ i + 1 ] ) for i in range ( n - 1 ) ] NEW_LINE dp = [ [ 0 , 0 , 0 ] for _ in range ( n - 1 ) ] NEW_LINE dp [ 0 ] [ 1 ] = diff [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 2 ] + diff [ i ] , diff [ i ] ) NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - diff [ i ] NEW_LINE DEDENT print ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] , dp [ n - 2 ] [ 2 ] ) ) NEW_LINE
def maximumXor ( arr : list , n : int ) -> int : NEW_LINE INDENT sForward , sBackward = [ ] , [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while len ( sForward ) > 0 and arr [ i ] < arr [ sForward [ - 1 ] ] : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ sForward [ - 1 ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( i ) NEW_LINE while len ( sBackward ) > 0 and arr [ n - i - 1 ] < arr [ sBackward [ - 1 ] ] : NEW_LINE INDENT ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ - 1 ] ] ) NEW_LINE sBackward . pop ( ) NEW_LINE DEDENT sBackward . append ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumXor ( arr , n ) ) NEW_LINE DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT n = int ( n / 16 ) ; NEW_LINE DEDENT j = i - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = " " ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT DEDENT n = 2545 ; NEW_LINE decToHexa ( n ) ; NEW_LINE
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = [ 0 ] * ( 10 ** 5 ) NEW_LINE for ai in A : NEW_LINE INDENT C [ ai ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ** 5 - 2 ) : NEW_LINE INDENT ans = max ( C [ i ] + C [ i + 1 ] + C [ i + 2 ] , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE if h == w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT mp = { } NEW_LINE for r in range ( h ) : NEW_LINE INDENT s = input ( ) NEW_LINE for c in range ( w ) : NEW_LINE INDENT mp [ s [ c ] ] = [ r , c ] NEW_LINE DEDENT DEDENT s = input ( ) NEW_LINE now = [ 0 , 0 ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT to = mp [ s [ i ] ] NEW_LINE ans += abs ( now [ 0 ] - to [ 0 ] ) + abs ( now [ 1 ] - to [ 1 ] ) + 1 NEW_LINE now = to NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import itertools NEW_LINE import math NEW_LINE import fractions NEW_LINE import functools NEW_LINE import copy NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Hello ▁ World " ) NEW_LINE DEDENT else : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT
def extractMaximum ( ss ) : NEW_LINE INDENT num , res = 0 , 0 NEW_LINE for i in range ( len ( ss ) ) : NEW_LINE INDENT if ss [ i ] >= "0" and ss [ i ] <= "9" : NEW_LINE INDENT num = num * 10 + int ( int ( ss [ i ] ) - 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT ss = "100klh564abc365bg " NEW_LINE print ( extractMaximum ( ss ) ) NEW_LINE
max = 50009 NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( max ) ] NEW_LINE k = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ k ] ; NEW_LINE k += 1 NEW_LINE DEDENT ans = - ( 1e15 ) NEW_LINE index_1 = index_2 = index_3 = - 1 NEW_LINE for l in range ( n + 1 ) : NEW_LINE INDENT index = 0 NEW_LINE vmin = ( 1e15 ) NEW_LINE for r in range ( l , n + 1 ) : NEW_LINE INDENT if ( sum [ r ] < vmin ) : NEW_LINE INDENT vmin = sum [ r ] NEW_LINE index = r NEW_LINE DEDENT if ( sum [ l ] + sum [ r ] - vmin > ans ) : NEW_LINE INDENT ans = sum [ l ] + sum [ r ] - vmin NEW_LINE index_1 = l NEW_LINE index_2 = index NEW_LINE index_3 = r NEW_LINE DEDENT DEDENT DEDENT print ( index_1 , " ▁ " , index_2 , " ▁ " , index_3 ) NEW_LINE DEDENT arr = [ - 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE find_Indices ( arr , n ) NEW_LINE
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printElements ( arr , n ) NEW_LINE DEDENT
def valueofX ( ar , n ) : NEW_LINE INDENT summ = sum ( ar ) NEW_LINE if ( summ % n == 0 ) : NEW_LINE INDENT return summ // n NEW_LINE DEDENT else : NEW_LINE INDENT A = summ // n NEW_LINE B = summ // n + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ( ValueA < ValueB ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 1 , 3 , 7 ] NEW_LINE print ( valueofX ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE z = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = 0 NEW_LINE for i in range ( y ) : NEW_LINE INDENT c = 0 NEW_LINE for j in z : NEW_LINE INDENT if j & ( 1 << i ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c > ( x - c ) : NEW_LINE INDENT a += 1 << i NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE DEDENT
s = list ( input ( ) ) NEW_LINE del s [ - 1 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT del s [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if s [ : int ( len ( s ) / 2 ) ] == s [ int ( len ( s ) / 2 ) : ] : NEW_LINE INDENT print ( len ( s ) ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT del s [ - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 19 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE x = curr ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 9 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT print ( findNth ( 5 ) ) ; NEW_LINE
import itertools NEW_LINE def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in itertools . count ( ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findNth ( 5 ) ) NEW_LINE DEDENT
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 ; NEW_LINE currentSum = 0 NEW_LINE currSum = 0 ; NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N ; NEW_LINE N = N - 1 ; NEW_LINE countElements = countElements + 1 ; NEW_LINE DEDENT return countElements ; NEW_LINE DEDENT N = 5 ; NEW_LINE S = 11 ; NEW_LINE count = countNumber ( N , S ) ; NEW_LINE print ( count ) ; NEW_LINE
def strrmatch ( strr , pattern , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ False for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = True NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE DEDENT elif ( pattern [ j - 1 ] == ' ? ' or strr [ i - 1 ] == pattern [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT strr = " baaabab " NEW_LINE pattern = " * * * * * ba * * * * * ab " NEW_LINE if ( strrmatch ( strr , pattern , len ( strr ) , len ( pattern ) ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def f ( n ) : NEW_LINE INDENT a = set ( ) NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT a . add ( i ) NEW_LINE n //= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n > 1 : a . add ( n ) NEW_LINE return a NEW_LINE DEDENT while 1 : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a | b ) == 0 : break NEW_LINE a , b = f ( a ) , f ( b ) NEW_LINE print ( " a " if 2 * max ( a ) - sum ( a ) > 2 * max ( b ) - sum ( b ) else " b " ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT fac = list ( ) NEW_LINE fac . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac . append ( fac [ i - 1 ] * i ) NEW_LINE DEDENT ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = max ( a ) NEW_LINE hf = 0 NEW_LINE for x in a : NEW_LINE INDENT if abs ( mx - 2 * hf ) > abs ( mx - 2 * x ) : NEW_LINE INDENT hf = x NEW_LINE DEDENT DEDENT print ( mx , hf ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 5 NEW_LINE n = 2 NEW_LINE print ( powGCD ( a , n , b ) ) NEW_LINE DEDENT
def counting_sort ( A , n ) : NEW_LINE INDENT k = max ( A ) NEW_LINE B = [ 0 ] * n NEW_LINE C = [ 0 ] * ( k + 1 ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT C [ A [ j ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT C [ i ] = C [ i ] + C [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT B [ C [ A [ j ] ] - 1 ] = A [ j ] NEW_LINE C [ A [ j ] ] -= 1 NEW_LINE DEDENT return B NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( * counting_sort ( A , n ) , sep = " ▁ " ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( min ( n // 11 , s . count ( '8' ) ) ) NEW_LINE
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 50 NEW_LINE b = 2 NEW_LINE print ( sumOfDigit ( n , b ) ) NEW_LINE
from math import * NEW_LINE def printLargestDivisible ( n , a ) : NEW_LINE INDENT c0 , c5 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT DEDENT c5 = floor ( c5 / 9 ) * 9 NEW_LINE if c0 == 0 : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT elif c5 == 0 : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c5 ) : NEW_LINE INDENT print ( 5 , end = " " ) NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE printLargestDivisible ( n , a ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 ; NEW_LINE Min = ( ( S - S1 ) / math . floor ( S ) ) * 60 ; NEW_LINE return int ( Min ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S , S1 = 30 , 10 ; NEW_LINE print ( numberOfMinutes ( S , S1 ) , " min " ) ; NEW_LINE DEDENT
def fn ( n , m , k , L ) : NEW_LINE INDENT g = min ( L ) NEW_LINE L = [ p - g for p in L ] NEW_LINE op = [ ] NEW_LINE for i in range ( len ( L ) - 1 ) : NEW_LINE INDENT op . append ( L [ i + 1 ] - L [ i ] - 1 ) NEW_LINE DEDENT op . sort ( ) NEW_LINE dist = n NEW_LINE for gt in range ( n - k ) : NEW_LINE INDENT dist += op [ gt ] NEW_LINE DEDENT return ( dist ) NEW_LINE DEDENT a = input ( ) . split ( ) NEW_LINE b = input ( ) . split ( ) NEW_LINE a = [ int ( s ) for s in a ] NEW_LINE b = [ int ( t ) for t in b ] NEW_LINE print ( fn ( a [ 0 ] , a [ 1 ] , a [ 2 ] , b ) ) NEW_LINE
import math NEW_LINE def onesComplement ( n ) : NEW_LINE INDENT number_of_bits = ( int ) ( math . floor ( math . log ( n ) / math . log ( 2 ) ) ) + 1 ; NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n ; NEW_LINE DEDENT n = 22 NEW_LINE print ( onesComplement ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE w_first = w NEW_LINE h_first = h NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif w % 2 == 1 and h % 2 == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if w % 2 == 0 and h % 2 == 1 : NEW_LINE INDENT count = 0 NEW_LINE while w % 2 == 0 : NEW_LINE INDENT w /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if w == 1 : NEW_LINE INDENT num = w_first NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ** count NEW_LINE DEDENT DEDENT elif h % 2 == 0 and w % 2 == 1 : NEW_LINE INDENT count = 0 NEW_LINE while h % 2 == 0 : NEW_LINE INDENT h /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if h == 1 : NEW_LINE INDENT num = h_first NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ** count NEW_LINE DEDENT DEDENT elif h % 2 == 0 and w % 2 == 0 : NEW_LINE INDENT num = 0 NEW_LINE count = 0 NEW_LINE while w % 2 == 0 : NEW_LINE INDENT w /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if w == 1 : NEW_LINE INDENT num1 = w_first NEW_LINE DEDENT else : NEW_LINE INDENT num1 = 2 ** count NEW_LINE DEDENT count = 0 NEW_LINE while h % 2 == 0 : NEW_LINE INDENT h /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if h == 1 : NEW_LINE INDENT num2 = h_first NEW_LINE DEDENT else : NEW_LINE INDENT num2 = 2 ** count NEW_LINE DEDENT num = num1 * num2 NEW_LINE DEDENT if num >= n : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , 2 * x2 - x1 , " , " , 2 * y2 - y1 , " ) " ) ; NEW_LINE DEDENT x1 = 0 ; NEW_LINE y1 = 0 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = 1 ; NEW_LINE findPoint ( x1 , y1 , x2 , y2 ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE n += 1 NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( min ( min ( a , n - a ) , min ( b , n - b ) ) - 1 ) % 3 + 1 ) NEW_LINE DEDENT
import math as mt NEW_LINE def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = " , x , " , ▁ " , " Y ▁ = " , y ) NEW_LINE DEDENT x , y = 12 , 5 NEW_LINE alter ( x , y ) NEW_LINE
import os NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT N = read_int ( ) NEW_LINE V = read_ints ( ) NEW_LINE print ( solve ( N , V ) ) NEW_LINE DEDENT def solve ( N , V ) : NEW_LINE INDENT V . sort ( ) NEW_LINE pos = { } NEW_LINE for i , a in enumerate ( V ) : NEW_LINE INDENT pos [ a ] = i NEW_LINE DEDENT best = 2 NEW_LINE done = [ [ False ] * N for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = V [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if done [ i ] [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT b = V [ j ] NEW_LINE d = b - a NEW_LINE c = 2 NEW_LINE done [ i ] [ j ] = True NEW_LINE k = j NEW_LINE v = b + d NEW_LINE while v in pos : NEW_LINE INDENT done [ k ] [ pos [ v ] ] = True NEW_LINE k = pos [ v ] NEW_LINE c += 1 NEW_LINE v += d NEW_LINE DEDENT best = max ( best , c ) NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT DEBUG = ' DEBUG ' in os . environ NEW_LINE def inp ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE DEDENT def read_int ( ) : NEW_LINE INDENT return int ( inp ( ) ) NEW_LINE DEDENT def read_ints ( ) : NEW_LINE INDENT return [ int ( e ) for e in inp ( ) . split ( ) ] NEW_LINE DEDENT def dprint ( * value , sep = ' ▁ ' , end = ' \n ' ) : NEW_LINE INDENT if DEBUG : NEW_LINE INDENT print ( * value , sep = sep , end = end ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
num = int ( input ( ) ) NEW_LINE for i in range ( num ) : NEW_LINE INDENT lenz = int ( input ( ) ) NEW_LINE text = input ( ) NEW_LINE isExist = False NEW_LINE for j in range ( lenz - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , lenz ) : NEW_LINE INDENT a = text [ j : k + 1 ] . count ( ' a ' ) NEW_LINE b = text [ j : k + 1 ] . count ( ' b ' ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( f " { j + 1 } ▁ { k + 1 } " ) NEW_LINE isExist = True NEW_LINE break NEW_LINE DEDENT DEDENT if isExist : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not isExist : NEW_LINE INDENT print ( " - 1 ▁ - 1" ) NEW_LINE DEDENT DEDENT
mod = 1000000007 NEW_LINE inv2 = 500000004 ; NEW_LINE def modulo ( num ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) - 0 ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a = modulo ( L ) ; NEW_LINE b = modulo ( R ) ; NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; NEW_LINE ret = ( r % mod - l % mod ) ; NEW_LINE if ( ret < 0 ) : NEW_LINE INDENT ret = ret + mod ; NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret % mod ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = "88949273204" ; NEW_LINE R = "98429729474298592" ; NEW_LINE print ( findSum ( L , R ) ) ; NEW_LINE DEDENT
def unsort ( l , r , a , k ) : NEW_LINE INDENT if ( k < 1 or l + 1 == r ) : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE temp = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE unsort ( l , mid , a , k ) NEW_LINE unsort ( mid , r , a , k ) NEW_LINE DEDENT def arrayWithKCalls ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( " NO ▁ SOLUTION " ) NEW_LINE return NEW_LINE DEDENT a = [ 0 for i in range ( n + 2 ) ] NEW_LINE a [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT k -= 1 NEW_LINE unsort ( 0 , n , a , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 17 NEW_LINE arrayWithKCalls ( n , k ) NEW_LINE
import math NEW_LINE def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT return sum / freqSum NEW_LINE DEDENT def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ [ 0 ] for i in range ( 0 , n ) ] NEW_LINE sum = 0 NEW_LINE freqSum = 0 NEW_LINE sd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT sd = math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT lower_limit = [ 50 , 61 , 71 , 86 , 96 ] NEW_LINE upper_limit = [ 60 , 70 , 85 , 95 , 100 ] NEW_LINE freq = [ 9 , 7 , 9 , 12 , 8 ] NEW_LINE n = len ( lower_limit ) NEW_LINE print ( groupedSD ( lower_limit , upper_limit , freq , n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE
def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 10 , 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n , l , r = map ( int , input ( ) . split ( ) ) NEW_LINE k = n // l NEW_LINE if r * k >= n : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def getsum ( x ) : NEW_LINE INDENT return int ( ( x * ( x + 1 ) ) / 2 ) NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( getsum ( ans ) < n or ( getsum ( ans ) - n ) & 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE DEDENT
MAX = 10 NEW_LINE def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - ( 10 ** 7 ) NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if arr1 [ n - 1 ] == arr2 [ m - 1 ] : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE dp = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] for k in range ( MAX ) ] NEW_LINE print ( lcs ( dp , arr1 , n , arr2 , m , k ) ) NEW_LINE DEDENT
from decimal import Decimal , getcontext NEW_LINE getcontext ( ) . prec = 200 NEW_LINE n , d , x = map ( Decimal , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( n ) + 1 ) : NEW_LINE INDENT i = Decimal ( str ( i ) ) NEW_LINE ans += Decimal ( str ( ( int ( n ) - int ( i ) + 1 ) ) ) / Decimal ( str ( i ) ) * ( d + x * Decimal ( str ( int ( n ) * 2 - 1 ) ) / Decimal ( "2" ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def Reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , ( n + 1 ) , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT print ( p , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT N = 25 ; NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT Reverseorder ( N ) ; NEW_LINE DEDENT
def pattern ( min_stars , p_height ) : NEW_LINE INDENT p_space = p_height - 1 NEW_LINE x = 1 NEW_LINE for i in range ( 0 , p_height ) : NEW_LINE INDENT for j in range ( p_space , i , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( 0 , min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for n in range ( ( p_height + p_height - 2 ) , x - 1 , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( 0 , min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT min_stars = min_stars + 2 NEW_LINE x = x + 2 NEW_LINE print ( " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT min_stars = 1 NEW_LINE p_height = 5 NEW_LINE pattern ( min_stars , p_height ) NEW_LINE DEDENT
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT visitors_count = int ( input ( ) ) NEW_LINE minDay = 0 NEW_LINE maxDay = 366 NEW_LINE users = [ ] NEW_LINE for i in range ( visitors_count ) : NEW_LINE INDENT users . append ( input ( ) ) NEW_LINE DEDENT minDay = int ( users [ 0 ] . split ( ) [ 1 ] ) NEW_LINE maxDay = int ( users [ 0 ] . split ( ) [ 2 ] ) NEW_LINE all_users : list = [ ] NEW_LINE for user in users : NEW_LINE INDENT user = user . split ( ) NEW_LINE all_users . append ( [ user [ 0 ] , int ( user [ 1 ] ) , int ( user [ 2 ] ) ] ) NEW_LINE if minDay > int ( user [ 1 ] ) : NEW_LINE INDENT minDay = int ( user [ 1 ] ) NEW_LINE DEDENT if maxDay < int ( user [ 2 ] ) : NEW_LINE INDENT maxDay = int ( user [ 2 ] ) NEW_LINE DEDENT DEDENT dict_cunts = { } NEW_LINE for i in range ( minDay , maxDay + 1 ) : NEW_LINE INDENT for user in all_users : NEW_LINE INDENT if i in range ( user [ 1 ] , user [ 2 ] + 1 ) : NEW_LINE INDENT dict_cunts . setdefault ( i , [ ] ) NEW_LINE dict_cunts [ i ] . append ( user ) NEW_LINE DEDENT DEDENT DEDENT best_match = 0 NEW_LINE for users in dict_cunts . values ( ) : NEW_LINE INDENT males_len = len ( list ( filter ( lambda user : user [ 0 ] == ' M ' , users ) ) ) NEW_LINE males_len_x2 = males_len * 2 NEW_LINE females_len = len ( users ) - males_len NEW_LINE females_len_x2 = females_len * 2 NEW_LINE if ( males_len > females_len or males_len == females_len ) and best_match < females_len_x2 : NEW_LINE INDENT best_match = females_len_x2 NEW_LINE DEDENT elif ( females_len > males_len or males_len == females_len ) and best_match < males_len_x2 : NEW_LINE INDENT best_match = males_len_x2 NEW_LINE DEDENT DEDENT print ( best_match ) NEW_LINE DEDENT
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
import math NEW_LINE MAX = 1000000 NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return round ( pow ( phi , n ) / math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def sumFibonacci ( k ) : NEW_LINE INDENT l = ( k * ( k - 1 ) ) / 2 NEW_LINE r = l + k NEW_LINE sum = calculateSum ( l , r - 1 ) NEW_LINE return sum NEW_LINE DEDENT k = 3 NEW_LINE print ( sumFibonacci ( k ) ) NEW_LINE
def fib ( n ) : NEW_LINE INDENT phi = ( ( 1 + ( 5 ** ( 1 / 2 ) ) ) / 2 ) ; NEW_LINE return round ( ( phi ** n ) / ( 5 ** ( 1 / 2 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 4 , 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE DEDENT
import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 ; NEW_LINE return int ( round ( pow ( phi , n ) / math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE
m , n = map ( int , input ( ) . split ( ) ) NEW_LINE k = list ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a1 , a2 , c , d = input ( ) . split ( ) NEW_LINE for j in range ( int ( a1 ) - 1 , int ( a2 ) ) : NEW_LINE INDENT if k [ j ] == c : NEW_LINE INDENT k [ j ] = d NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( k ) ) NEW_LINE
def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return str1 [ i ] < str2 [ i ] NEW_LINE DEDENT def searchStr ( arr , string , first , last ) : NEW_LINE INDENT if first > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + first ) // 2 NEW_LINE if len ( arr [ mid ] ) == 0 : NEW_LINE INDENT left , right = mid - 1 , mid + 1 NEW_LINE while True : NEW_LINE INDENT if left < first and right > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if right <= last and len ( arr [ right ] ) != 0 : NEW_LINE INDENT mid = right NEW_LINE break NEW_LINE DEDENT if left >= first and len ( arr [ left ] ) != 0 : NEW_LINE INDENT mid = left NEW_LINE break NEW_LINE DEDENT right += 1 NEW_LINE left -= 1 NEW_LINE DEDENT DEDENT if compareStrings ( string , arr [ mid ] ) == 0 : NEW_LINE INDENT return mid NEW_LINE DEDENT if compareStrings ( string , arr [ mid ] ) < 0 : NEW_LINE INDENT return searchStr ( arr , string , mid + 1 , last ) NEW_LINE DEDENT return searchStr ( arr , string , first , mid - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " for " , " " , " " , " " , " geeks " , " ide " , " " , " practice " , " " , " " , " quiz " , " " , " " ] NEW_LINE string = " quiz " NEW_LINE n = len ( arr ) NEW_LINE print ( searchStr ( arr , string , 0 , n - 1 ) ) NEW_LINE DEDENT
a , b = input ( ) . split ( ) ; b = int ( b [ : : - 1 ] ) ; print ( int ( a ) + b ) NEW_LINE
ax , ay = map ( int , input ( ) . split ( ) ) NEW_LINE bx , by = map ( int , input ( ) . split ( ) ) NEW_LINE cx , cy = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 3 ) NEW_LINE print ( bx + cx - ax , by + cy - ay ) NEW_LINE print ( cx + ax - bx , cy + ay - by ) NEW_LINE print ( bx + ax - cx , by + ay - cy ) NEW_LINE
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = " " . join ( sorted ( a ) ) NEW_LINE return sum ( [ 1 for i in range ( n ) if a [ i ] != b [ i ] ] ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while t : NEW_LINE INDENT ans . append ( str ( solve ( ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT print ( " \n " . join ( ans ) ) NEW_LINE
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) ; NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 ; NEW_LINE return ( int ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) ) ; NEW_LINE DEDENT n = 20 ; NEW_LINE print ( sumMultiples ( n ) ) ; NEW_LINE
while True : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE if t == 0 : break NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , f = map ( int , input ( ) . split ( ) ) NEW_LINE t -= f - s NEW_LINE DEDENT if t < 1 : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT DEDENT
def fact ( num ) : NEW_LINE INDENT fact = 1 ; NEW_LINE while ( num > 1 ) : NEW_LINE INDENT fact = fact * num ; NEW_LINE num = num - 1 ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < arr [ k ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT catalan_leftBST = catalan ( s ) NEW_LINE catalan_rightBST = catalan ( n - s - 1 ) NEW_LINE totalBST = catalan_rightBST * catalan_leftBST NEW_LINE print ( totalBST , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def get ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def intput ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT for _ in range ( intput ( ) ) : NEW_LINE INDENT a = get ( ) NEW_LINE if ( a [ 0 ] - a [ 1 ] == 1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE
def get ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def intput ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT for _ in range ( intput ( ) ) : NEW_LINE INDENT a = get ( ) NEW_LINE if ( a [ 1 ] >= a [ 0 ] ) : NEW_LINE INDENT print ( a [ 1 ] - a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( a [ 0 ] - a [ 1 ] ) % 2 == 0 or ( a [ 0 ] + a [ 1 ] ) % 2 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT main ( ) NEW_LINE
def countWays ( n , arr ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in arr : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT no_ways += count [ i - j ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE
while ( True ) : NEW_LINE INDENT L = int ( input ( ) ) NEW_LINE if not L : NEW_LINE INDENT break NEW_LINE DEDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE for _ in range ( 12 ) : NEW_LINE INDENT a += 1 NEW_LINE M , N = map ( int , input ( ) . split ( ) ) NEW_LINE b += M - N NEW_LINE if not c and b >= L : NEW_LINE INDENT c = a NEW_LINE DEDENT DEDENT print ( c if c else " NA " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = input ( ) . split ( " ▁ " ) NEW_LINE a , b , c = int ( a ) , int ( b ) , int ( c ) NEW_LINE a , b , c = sorted ( [ a , b , c ] ) NEW_LINE if c - a <= 2 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * ( c - a - 2 ) ) NEW_LINE DEDENT DEDENT
n , b , d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE waste = 0 NEW_LINE num = 0 NEW_LINE for i in a : NEW_LINE INDENT if i <= b : NEW_LINE INDENT waste += i NEW_LINE DEDENT if waste > d : NEW_LINE INDENT num += 1 NEW_LINE waste = 0 NEW_LINE DEDENT DEDENT print ( num ) NEW_LINE
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( key == arr [ int ( mid ) ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE key = 10 NEW_LINE print ( " Index : " , int ( binarySearch ( arr , 0 , n , key ) ) ) NEW_LINE
def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT
inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n , m , k = inl ( ) NEW_LINE h = set ( inl ( ) ) NEW_LINE b = 1 NEW_LINE if b not in h : NEW_LINE INDENT for _ in range ( k ) : NEW_LINE INDENT u , v = inl ( ) NEW_LINE if b == u or b == v : NEW_LINE INDENT b = u if b == v else v NEW_LINE if { u , v } & h : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( b ) NEW_LINE
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) ; NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findPairs ( arr , n ) ; NEW_LINE DEDENT
import sys NEW_LINE def minBroadcastRange ( houses , towers , n , m ) : NEW_LINE INDENT leftTower = - sys . maxsize - 1 NEW_LINE rightTower = towers [ 0 ] NEW_LINE j , k = 0 , 0 NEW_LINE min_range = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( houses [ j ] < rightTower ) : NEW_LINE INDENT left = houses [ j ] - leftTower NEW_LINE right = rightTower - houses [ j ] NEW_LINE if left < right : NEW_LINE INDENT local_max = left NEW_LINE DEDENT else : NEW_LINE INDENT local_max = right NEW_LINE DEDENT if ( local_max > min_range ) : NEW_LINE INDENT min_range = local_max NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT leftTower = towers [ k ] NEW_LINE if ( k < m - 1 ) : NEW_LINE INDENT k += 1 NEW_LINE rightTower = towers [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT rightTower = sys . maxsize NEW_LINE DEDENT DEDENT DEDENT return min_range NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 12 , 13 , 11 , 80 ] NEW_LINE b = [ 4 , 6 , 15 , 60 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE max = minBroadcastRange ( a , b , n , m ) NEW_LINE print ( max ) NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT num = 100 NEW_LINE divisor = 7 NEW_LINE print ( getRemainder ( num , divisor ) ) NEW_LINE
n , m , z = input ( ) . split ( ) NEW_LINE n , m , z = int ( n ) , int ( m ) , int ( z ) NEW_LINE n1 , m1 = n , m NEW_LINE kill = 0 NEW_LINE calls = [ ] NEW_LINE artists = [ ] NEW_LINE for call in range ( n , z + 1 , n ) : NEW_LINE INDENT calls . append ( call ) NEW_LINE DEDENT for artist in range ( m , z + 1 , m ) : NEW_LINE INDENT artists . append ( artist ) NEW_LINE DEDENT print ( len ( list ( set ( calls ) . intersection ( artists ) ) ) ) NEW_LINE
import sys NEW_LINE _allinput = [ ] NEW_LINE for inp in sys . stdin : NEW_LINE INDENT _allinput += inp . strip ( ) . split ( " ▁ " ) NEW_LINE DEDENT def _input ( ) : NEW_LINE INDENT for put in _allinput : NEW_LINE INDENT yield put NEW_LINE DEDENT DEDENT _obj = _input ( ) ; NEW_LINE def __input ( ) : NEW_LINE INDENT return _obj . __next__ ( ) NEW_LINE DEDENT def nextInt ( ) : NEW_LINE INDENT return int ( __input ( ) ) NEW_LINE DEDENT def check ( lst , L ) : NEW_LINE INDENT tot = 1 NEW_LINE curSum = 0 NEW_LINE for i in lst : NEW_LINE INDENT if curSum + i <= L : NEW_LINE INDENT curSum += i NEW_LINE DEDENT else : NEW_LINE INDENT curSum = i NEW_LINE tot += 1 NEW_LINE DEDENT DEDENT return tot NEW_LINE DEDENT def solve ( lst , m ) : NEW_LINE INDENT l = max ( lst ) NEW_LINE r = 1000000 * m ; NEW_LINE while l != r : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) ; NEW_LINE if check ( lst , mid ) <= m : r = mid NEW_LINE else : l = mid + 1 NEW_LINE DEDENT return l NEW_LINE DEDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT m , n = nextInt ( ) , nextInt ( ) NEW_LINE if m > 0 or n > 0 : NEW_LINE INDENT lst = [ nextInt ( ) for i in range ( 0 , n ) ] NEW_LINE print ( solve ( lst , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT except : NEW_LINE INDENT pass
n , wmax = map ( int , input ( ) . split ( ) ) NEW_LINE U = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT v , w = map ( int , input ( ) . split ( ) ) NEW_LINE u = v / w NEW_LINE U . append ( [ - u , v , w ] ) NEW_LINE DEDENT U . sort ( ) NEW_LINE remains = wmax NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT if remains > U [ i ] [ 2 ] : NEW_LINE INDENT remains -= U [ i ] [ 2 ] NEW_LINE ans += U [ i ] [ 1 ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += U [ i ] [ 1 ] * remains / U [ i ] [ 2 ] NEW_LINE break NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " , getSingle ( arr , n ) ) NEW_LINE
from collections import defaultdict NEW_LINE def maxdiff ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 1 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxdiff ( arr , n ) ) NEW_LINE
import math NEW_LINE import collections NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for a in range ( n ) : NEW_LINE INDENT l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . append ( l1 ) NEW_LINE DEDENT ans = 0 NEW_LINE m1 = [ ] NEW_LINE count = 0 NEW_LINE mini = math . inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( l [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE mini = min ( mini , - l [ i ] [ j ] ) NEW_LINE ans += - l [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT mini = min ( mini , abs ( l [ i ] [ j ] ) ) NEW_LINE ans += abs ( l [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans - 2 * mini ) NEW_LINE DEDENT DEDENT
def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( int ( initial_term + ( i * common_difference ) ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE
def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 15 NEW_LINE print ( countPairs ( n ) ) NEW_LINE
class Solution : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT ans = 0 NEW_LINE char_map = { } NEW_LINE for c in s : NEW_LINE INDENT char_map [ c ] = char_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for c in list ( char_map . keys ( ) ) : NEW_LINE INDENT if char_map [ c ] % 2 == 0 : NEW_LINE INDENT ans += char_map . pop ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += char_map [ c ] // 2 * 2 NEW_LINE DEDENT DEDENT if len ( char_map ) != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " abccccdd " NEW_LINE out = sObj . longestPalindrome ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res /= ( i + 1 ) ; NEW_LINE DEDENT return int ( res ) ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEW_LINE return int ( c / ( n + 1 ) ) ; NEW_LINE DEDENT def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return catalan ( int ( n / 2 ) ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( " Total ▁ possible ▁ expressions ▁ of ▁ length " , n , " is " , findWays ( 6 ) ) ; NEW_LINE
import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def value ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlst ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def inlsts ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( input ( ) ) NEW_LINE def inps ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return input ( ) NEW_LINE def stlst ( ) : return [ i for i in input ( ) . split ( ) ] NEW_LINE def help ( a , b , l ) : NEW_LINE INDENT tot = [ ] NEW_LINE for i in range ( b ) : NEW_LINE INDENT tot . append ( l [ i * a : i * a + a ] ) NEW_LINE DEDENT for i in zip ( * tot ) : NEW_LINE INDENT if sum ( ( i ) ) == b : return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT tot = [ ] NEW_LINE x = instr ( ) NEW_LINE s = [ ] NEW_LINE for i in x : NEW_LINE INDENT if i == ' O ' : s . append ( 0 ) NEW_LINE else : s . append ( 1 ) NEW_LINE DEDENT for i in range ( 1 , 13 ) : NEW_LINE INDENT if 12 % i == 0 : NEW_LINE INDENT if help ( i , 12 // i , s ) : tot . append ( ( 12 // i , i ) ) NEW_LINE DEDENT DEDENT print ( len ( tot ) , end = ' ▁ ' ) NEW_LINE for a , b in sorted ( tot ) : NEW_LINE INDENT print ( f ' { a } x { b } ' , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for i in range ( inp ( ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE ii = lambda : int ( input ( ) ) NEW_LINE mi = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE li = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from collections import defaultdict NEW_LINE d , t , a , b , da , db = mi ( ) NEW_LINE def solve ( ) : NEW_LINE INDENT for i in range ( t ) : NEW_LINE INDENT for j in range ( t ) : NEW_LINE INDENT if a - da * i + b - db * j == d or a - da * i == d or b - db * j == d or d == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( ' NO ' ) NEW_LINE DEDENT solve ( ) NEW_LINE
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE DEDENT
M = 100 NEW_LINE def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 4 ] , [ 7 , 3 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE
MAX = 1000000 NEW_LINE sieve_Prime = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE sieve_count = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( " Count ▁ = " , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_count [ n ] + 1 ) NEW_LINE
N , K , T , U , V , L = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE l = 0 NEW_LINE t = 0 NEW_LINE k = 0 NEW_LINE for _ in range ( N + 1 ) : NEW_LINE INDENT if _ == N : NEW_LINE INDENT d = L NEW_LINE DEDENT else : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE DEDENT length = d - l NEW_LINE l = d NEW_LINE while t > 0 or k > 0 : NEW_LINE INDENT if t > 0 : NEW_LINE INDENT if t * V >= length : NEW_LINE INDENT tmp = ( t * V - length ) / V NEW_LINE ans += t - tmp NEW_LINE t = tmp NEW_LINE if K > k : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = T NEW_LINE DEDENT length = 0 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT length = length - t * V NEW_LINE ans += t NEW_LINE t = 0 NEW_LINE if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE t = T NEW_LINE DEDENT DEDENT DEDENT elif k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE t = T NEW_LINE DEDENT DEDENT if length > 0 : NEW_LINE INDENT ans += length / U NEW_LINE if K > k : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = T NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE prefix = [ 0 ] * n ; NEW_LINE suffix = [ 0 ] * n ; NEW_LINE seen = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if ( i - 1 >= 0 ) else 0 ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT seen = [ 0 ] * len ( seen ) ; NEW_LINE suffix [ n - 1 ] = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababa " ; NEW_LINE print ( waysToSplit ( s ) ) ; NEW_LINE DEDENT
import math NEW_LINE def compute ( ) : NEW_LINE INDENT TURNS = 15 NEW_LINE ways = [ [ 1 ] ] NEW_LINE for i in range ( 1 , TURNS + 1 ) : NEW_LINE INDENT row = [ ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE if j < i : NEW_LINE INDENT temp = ways [ i - 1 ] [ j ] * i NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT temp += ways [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT row . append ( temp ) NEW_LINE DEDENT ways . append ( row ) NEW_LINE DEDENT numer = sum ( ways [ TURNS ] [ i ] for i in range ( TURNS // 2 + 1 , TURNS + 1 ) ) NEW_LINE denom = math . factorial ( TURNS + 1 ) NEW_LINE return str ( denom // numer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE t = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans , cnt = [ ] , [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if t [ i ] == 1 : NEW_LINE INDENT crt = [ i ] NEW_LINE x = a [ i ] NEW_LINE while cnt [ x ] == 1 : NEW_LINE INDENT crt . append ( x ) NEW_LINE x = a [ x ] NEW_LINE DEDENT if len ( crt ) > len ( ans ) : NEW_LINE INDENT ans = crt [ : ] NEW_LINE DEDENT DEDENT DEDENT ans . reverse ( ) NEW_LINE print ( len ( ans ) ) NEW_LINE print ( ' ▁ ' . join ( map ( str , ans ) ) ) NEW_LINE
def merge ( ar1 , ar2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT ar1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE ar2 = [ 2 , 3 , 8 , 13 ] NEW_LINE m = len ( ar1 ) NEW_LINE n = len ( ar2 ) NEW_LINE merge ( ar1 , ar2 , m , n ) NEW_LINE print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " , end = " "  ) NEW_LINE print ( ar1 ) NEW_LINE DEDENT print ( " Second ▁ Array : ▁ " , end = " " ) NEW_LINE print ( ar2 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 237 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE
aa , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ls , sum = [ aa , b , c ] , 0 NEW_LINE ls = sorted ( ls ) NEW_LINE if ls [ 1 ] - ls [ 0 ] < d : sum += ( d - ls [ 1 ] + ls [ 0 ] ) NEW_LINE if ls [ 2 ] - ls [ 1 ] < d : sum += ( d - ls [ 2 ] + ls [ 1 ] ) NEW_LINE print ( sum ) NEW_LINE
dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( ( a + b ) // 2 ) ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 ; b = 16 ; NEW_LINE print ( find_k ( a , b ) ) ; NEW_LINE DEDENT
import numpy as np NEW_LINE N = 101 ; NEW_LINE mod = int ( 1e9 ) + 7 ; NEW_LINE exactsum = np . zeros ( ( N , N , N ) ) ; NEW_LINE exactnum = np . zeros ( ( N , N , N ) ) ; NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 ; NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 1 ; y = 1 ; z = 1 ; NEW_LINE print ( ( getSum ( x , y , z ) % mod ) ) ; NEW_LINE DEDENT
CHARS = 26 NEW_LINE def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq1 = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT freq2 = 0 NEW_LINE count_freq2 = 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if ( freq [ k ] == freq2 ) : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abcbc " NEW_LINE if ( isValidString ( str ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT s = list ( input ( ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if s [ i ] == ' a ' : NEW_LINE INDENT s [ i ] = ' b ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] == ' z ' : NEW_LINE INDENT s [ i ] = ' y ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = ' z ' NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE t -= 1 NEW_LINE DEDENT
def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ inf for i in range ( sizeOfB ) ] for i in range ( 26 ) ] NEW_LINE for i in range ( sizeOfB ) : NEW_LINE INDENT next [ ord ( B [ i ] ) - ord ( ' a ' ) ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( next [ i ] [ j ] == inf ) : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while ( i < sizeOfA ) : NEW_LINE INDENT if ( pos == 0 and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] == inf ) : NEW_LINE INDENT numberOfSubsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif ( pos < sizeOfB and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] < inf ) : NEW_LINE INDENT nextIndex = next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] + 1 NEW_LINE pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = " aacbe " NEW_LINE B = " aceab " NEW_LINE print ( findMinimumSubsequences ( A , B ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT d . append ( max ( i , n - 1 - i ) + max ( j , m - 1 - j ) ) NEW_LINE DEDENT DEDENT d . sort ( ) NEW_LINE print ( ' ▁ ' . join ( map ( str , d ) ) ) NEW_LINE DEDENT
def FindRank ( arr , length ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank = rank + 1 NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 88 , 14 , 69 , 30 , 29 , 89 ] NEW_LINE length = len ( arr ) NEW_LINE FindRank ( arr , length ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import collections NEW_LINE import itertools NEW_LINE import array NEW_LINE import inspect NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def chkprint ( * args ) : NEW_LINE INDENT names = { id ( v ) : k for k , v in inspect . currentframe ( ) . f_back . f_locals . items ( ) } NEW_LINE print ( ' , ▁ ' . join ( names . get ( id ( arg ) , ' ? ? ? ' ) + ' ▁ = ▁ ' + repr ( arg ) for arg in args ) ) NEW_LINE DEDENT def to_bin ( x ) : NEW_LINE INDENT return bin ( x ) [ 2 : ] NEW_LINE DEDENT def li_input ( ) : NEW_LINE INDENT return [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE DEDENT dp = None NEW_LINE def main ( ) : NEW_LINE INDENT N , H = li_input ( ) NEW_LINE S = [ li_input ( ) for _ in range ( N ) ] NEW_LINE ans = 0 NEW_LINE strong_throw = [ ] NEW_LINE maxcut = - 1 NEW_LINE for s in S : NEW_LINE INDENT if s [ 0 ] > maxcut : NEW_LINE INDENT maxcut = s [ 0 ] NEW_LINE DEDENT DEDENT for s in S : NEW_LINE INDENT if s [ 1 ] > maxcut : NEW_LINE INDENT strong_throw . append ( s [ 1 ] ) NEW_LINE DEDENT DEDENT strong_throw . sort ( reverse = True ) NEW_LINE for st in strong_throw : NEW_LINE INDENT H -= st NEW_LINE ans += 1 NEW_LINE if H <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if H > 0 : NEW_LINE INDENT ans += math . ceil ( H / maxcut ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE
import math NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT a , b = input ( ) . split ( " ▁ " ) NEW_LINE print ( math . gcd ( int ( a ) , int ( b ) ) ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT m = 0 NEW_LINE DEDENT
dic = { } NEW_LINE S = list ( input ( ) ) NEW_LINE for s in S : NEW_LINE INDENT if s not in dic : dic [ s ] = 1 NEW_LINE else : dic [ s ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for k in list ( dic . keys ( ) ) : NEW_LINE INDENT if dic [ k ] & 1 : ans += 1 NEW_LINE DEDENT print ( ans >> 1 ) NEW_LINE
import math NEW_LINE def complement ( num ) : NEW_LINE INDENT i = 0 ; NEW_LINE len = 0 ; NEW_LINE comp = 0 ; NEW_LINE temp = num ; NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 ; NEW_LINE num = int ( num / 10 ) ; NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT num = temp ; NEW_LINE comp = math . pow ( 10 , len ) - num ; NEW_LINE return int ( comp ) ; NEW_LINE DEDENT print ( complement ( 25 ) ) ; NEW_LINE print ( complement ( 456 ) ) ; NEW_LINE
import math NEW_LINE def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE
def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT a , b , c = 2 , 4 , 4 NEW_LINE print ( getMinNum ( a , b , c ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE x = 0 NEW_LINE max_num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] == " I " : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT if x > max_num : NEW_LINE INDENT max_num = x NEW_LINE DEDENT DEDENT print ( max_num ) NEW_LINE
from operator import itemgetter NEW_LINE def protect ( N , M ) : NEW_LINE INDENT DP = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT DP . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT DP . sort ( key = itemgetter ( 1 ) ) NEW_LINE nokori = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if M > DP [ N - i - 1 ] [ 0 ] : NEW_LINE INDENT M -= DP [ N - i - 1 ] [ 0 ] NEW_LINE DP . pop ( ) NEW_LINE DEDENT elif M <= DP [ N - i - 1 ] [ 0 ] : NEW_LINE INDENT nokori = ( DP [ N - i - 1 ] [ 0 ] - M ) * DP [ N - i - 1 ] [ 1 ] NEW_LINE M = 0 NEW_LINE DP . pop ( ) NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( len ( DP ) ) : NEW_LINE INDENT nokori += DP [ i ] [ 0 ] * DP [ i ] [ 1 ] NEW_LINE DEDENT print ( nokori ) NEW_LINE DEDENT while True : NEW_LINE INDENT NM = input ( ) . split ( ) NEW_LINE N = int ( NM [ 0 ] ) NEW_LINE M = int ( NM [ 1 ] ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT protect ( N , M ) NEW_LINE DEDENT
from heapq import heapify , heappushpop NEW_LINE N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE L , C , R = A [ : N ] , A [ N : 2 * N ] , A [ 2 * N : ] NEW_LINE F = [ sum ( L ) ] NEW_LINE heapify ( L ) NEW_LINE for c in C : NEW_LINE INDENT F . append ( F [ - 1 ] + c - heappushpop ( L , c ) ) NEW_LINE DEDENT R = [ - r for r in R ] NEW_LINE B = [ sum ( R ) ] NEW_LINE heapify ( R ) NEW_LINE for c in reversed ( C ) : NEW_LINE INDENT B . append ( B [ - 1 ] - c - heappushpop ( R , - c ) ) NEW_LINE DEDENT print ( max ( f + b for f , b in zip ( F , reversed ( B ) ) ) ) NEW_LINE
def countWays ( arr , m , N ) : NEW_LINE INDENT count = [ 0 for i in range ( N + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT arr = [ 1 , 5 , 6 ] NEW_LINE m = len ( arr ) NEW_LINE N = 7 NEW_LINE print ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " , countWays ( arr , m , N ) ) NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] > 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE
def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( " ( " , possibleA , " , " , possibleB , " , " , possibleC , " ) ▁ is ▁ one ▁ such " , " possible ▁ triplet ▁ between " , L , " and " , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Such ▁ Triplet ▁ exists ▁ between " , L , " and " , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE
def conversion ( charSet , str1 ) : NEW_LINE INDENT s2 = " " NEW_LINE for i in str1 : NEW_LINE INDENT s2 += alphabets [ charSet . index ( i ) ] NEW_LINE DEDENT return s2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT alphabets = " abcdefghijklmnopqrstuvwxyz " NEW_LINE charSet = " qwertyuiopasdfghjklzxcvbnm " NEW_LINE str1 = " egrt " NEW_LINE print ( conversion ( charSet , str1 ) ) NEW_LINE DEDENT
s = set ( ) NEW_LINE def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if k == count : NEW_LINE INDENT s . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( " The " , len ( s ) , " distinct ▁ integers ▁ are : " ) NEW_LINE for i in sorted ( s ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 8 , 17 , 5 ] NEW_LINE n , k = len ( a ) , 2 NEW_LINE printDistinctIntegers ( k , a , n ) NEW_LINE DEDENT
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 ; NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT a = str ( l ) ; NEW_LINE b = str ( r ) ; NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = list ( b ) NEW_LINE curr [ i ] = str ( ( ( ord ( curr [ i ] ) - ord ( '0' ) ) - 1 ) + ord ( '0' ) ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ j ] = str ( ord ( '9' ) ) NEW_LINE DEDENT num = 0 NEW_LINE for c in curr : NEW_LINE INDENT num = num * 10 + ( int ( c ) - ord ( '0' ) ) NEW_LINE DEDENT if ( num >= l and product ( ans ) < product ( num ) ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE l , r = 51 , 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE DEDENT
isPrime = [ 1 ] * 100005 NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE
MAX = 25 ; NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 ; sum = 0 ; ans = 0 ; NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] ; f = 0 ; NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 ; NEW_LINE e = e // 2 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem ; NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) ; NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) ; NEW_LINE if ( bits_count [ d ] > n // 2 ) : NEW_LINE INDENT ans = ans + temp ; NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans ; NEW_LINE sum = sum + arr [ d ] ; NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ " " ] NEW_LINE for c in s : NEW_LINE INDENT if a [ - 1 ] == " " and c == ' ▁ ' : NEW_LINE INDENT continue NEW_LINE DEDENT a [ - 1 ] += c ; NEW_LINE if c == ' ? ' or c == ' ! ' or c == ' . ' : NEW_LINE INDENT a . append ( " " ) ; NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE last = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if len ( a [ i ] ) > n : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT add = len ( a [ i ] ) + 1 if i + 1 != len ( a ) else len ( a [ i ] ) NEW_LINE if i == 0 or ( last + add ) > n : NEW_LINE INDENT ans += 1 NEW_LINE last = len ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT last += add NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import collections NEW_LINE def GetMinimumEnergySpent ( n , shortcuts ) : NEW_LINE INDENT energy_spent = [ i for i in range ( n ) ] NEW_LINE queue = collections . deque ( energy_spent ) NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT idx = queue . popleft ( ) NEW_LINE if idx < n - 1 and energy_spent [ idx + 1 ] > energy_spent [ idx ] + 1 : NEW_LINE INDENT energy_spent [ idx + 1 ] = energy_spent [ idx ] + 1 NEW_LINE queue . append ( idx + 1 ) NEW_LINE DEDENT if idx > 0 and energy_spent [ idx - 1 ] > energy_spent [ idx ] + 1 : NEW_LINE INDENT energy_spent [ idx - 1 ] = energy_spent [ idx ] + 1 NEW_LINE queue . append ( idx - 1 ) NEW_LINE DEDENT if energy_spent [ idx ] + 1 < energy_spent [ shortcuts [ idx ] ] : NEW_LINE INDENT energy_spent [ shortcuts [ idx ] ] = energy_spent [ idx ] + 1 NEW_LINE queue . append ( shortcuts [ idx ] ) NEW_LINE DEDENT DEDENT return energy_spent NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE shortcuts = [ int ( k ) - 1 for k in input ( ) . split ( ) ] NEW_LINE energy_spent_str = [ str ( k ) for k in GetMinimumEnergySpent ( n , shortcuts ) ] NEW_LINE print ( ' ▁ ' . join ( energy_spent_str ) ) NEW_LINE DEDENT
def strangeBDParty ( n : int , m : int , k : [ int ] , c : [ int ] ) -> int : NEW_LINE INDENT k . sort ( reverse = True ) NEW_LINE cost = l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l < m and c [ l ] < c [ k [ i ] - 1 ] : NEW_LINE INDENT cost += c [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += c [ k [ i ] - 1 ] NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT rep = int ( input ( ) ) NEW_LINE for _ in range ( rep ) : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( strangeBDParty ( n , m , k , c ) ) NEW_LINE DEDENT
def findMaximumNum ( arr , n ) : NEW_LINE INDENT i = n NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE DEDENT
s = [ * input ( ) ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT l = input ( ) . split ( ) NEW_LINE a = int ( l [ 1 ] ) NEW_LINE b = int ( l [ 2 ] ) + 1 NEW_LINE if l [ 0 ] == ' print ' : NEW_LINE INDENT print ( * s [ a : b ] , sep = ' ' ) NEW_LINE DEDENT elif l [ 0 ] == ' reverse ' : NEW_LINE INDENT s [ a : b ] = reversed ( s [ a : b ] ) NEW_LINE DEDENT elif l [ 0 ] == ' replace ' : NEW_LINE INDENT s [ a : b ] = l [ 3 ] NEW_LINE DEDENT DEDENT
def solve ( A , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2000 ) ] for i in range ( 2000 ) ] NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT for i in range ( - sum , sum + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 10 ** 9 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( - sum , sum + 1 ) : NEW_LINE INDENT dp [ flag ] [ j ] = 10 ** 9 NEW_LINE if ( j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= - sum ) : NEW_LINE INDENT dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] NEW_LINE DEDENT if ( j + A [ i - 1 ] <= sum and j + A [ i - 1 ] >= - sum and dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != 10 ** 9 ) : NEW_LINE INDENT dp [ flag ] [ j ] = min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT flag = flag ^ 1 NEW_LINE DEDENT for i in range ( sum + 1 ) : NEW_LINE INDENT if ( dp [ flag ^ 1 ] [ i ] != 10 ** 9 ) : NEW_LINE INDENT return dp [ flag ^ 1 ] [ i ] NEW_LINE DEDENT DEDENT return n - 1 NEW_LINE DEDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( solve ( arr , n ) ) NEW_LINE
def get_input ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT yield ' ' . join ( input ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT N = list ( get_input ( ) ) NEW_LINE for l in range ( len ( N ) ) : NEW_LINE INDENT Points = [ float ( i ) for i in N [ l ] . split ( ) ] NEW_LINE P = [ ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT P . append ( int ( Points [ i ] * 10 ** 5 ) ) NEW_LINE DEDENT AB = [ P [ 2 ] - P [ 0 ] , P [ 3 ] - P [ 1 ] ] NEW_LINE CD = [ P [ 6 ] - P [ 4 ] , P [ 7 ] - P [ 5 ] ] NEW_LINE if AB [ 0 ] * CD [ 0 ] + AB [ 1 ] * CD [ 1 ] == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def fizz_buzz ( ) : NEW_LINE INDENT c = 1 NEW_LINE while True : NEW_LINE INDENT res = ' ' NEW_LINE if c % 3 == 0 : NEW_LINE INDENT res = res + ' Fizz ' NEW_LINE DEDENT if c % 5 == 0 : NEW_LINE INDENT res = res + ' Buzz ' NEW_LINE DEDENT if res == ' ' : NEW_LINE INDENT yield str ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT yield res NEW_LINE DEDENT c += 1 NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE player = list ( range ( m ) ) NEW_LINE p = 0 NEW_LINE fb = fizz_buzz ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT inp = input ( ) NEW_LINE if len ( player ) > 1 : NEW_LINE INDENT if inp != next ( fb ) : NEW_LINE INDENT del player [ p ] NEW_LINE p = p % len ( player ) NEW_LINE DEDENT else : NEW_LINE INDENT p = ( p + 1 ) % len ( player ) NEW_LINE DEDENT DEDENT DEDENT result = str ( player [ 0 ] + 1 ) NEW_LINE if len ( player ) > 1 : NEW_LINE INDENT for pi in player [ 1 : ] : NEW_LINE INDENT result += ' ▁ ' + str ( pi + 1 ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , min ( b , d ) - max ( a , c ) ) ) NEW_LINE
import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] / mul ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE c = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( a - b , b - c , sep = ' \n ' ) NEW_LINE
from collections import deque NEW_LINE from math import * NEW_LINE import sys NEW_LINE import random NEW_LINE from bisect import * NEW_LINE from functools import reduce NEW_LINE from sys import stdin NEW_LINE import copy NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE left , right = 0 , 0 NEW_LINE i = 0 NEW_LINE while i < n and s [ i ] != ' > ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j = n - 1 NEW_LINE while j >= 0 and s [ j ] != ' < ' : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT print ( min ( i , n - j - 1 ) ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE x = 1 NEW_LINE while math . log2 ( n ) % 1 : NEW_LINE INDENT x += 1 NEW_LINE n -= 2 ** ( int ( math . log2 ( n ) ) ) NEW_LINE DEDENT print ( x ) NEW_LINE
p_speed = int ( input ( ) ) NEW_LINE d_speed = int ( input ( ) ) NEW_LINE time = int ( input ( ) ) NEW_LINE wait = int ( input ( ) ) NEW_LINE distence = int ( input ( ) ) NEW_LINE position_p = time * p_speed NEW_LINE position_d = 0 NEW_LINE counter = 0 NEW_LINE time_counter = 0 NEW_LINE while position_p < distence and d_speed > p_speed : NEW_LINE INDENT time_d = position_p / ( d_speed - p_speed ) NEW_LINE position_p += ( time_d * p_speed ) NEW_LINE if position_p >= distence : NEW_LINE INDENT break NEW_LINE DEDENT t_back = position_p / d_speed + wait NEW_LINE position_p += ( t_back * p_speed ) NEW_LINE counter += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE
current_time = input ( ) NEW_LINE time_duration = input ( ) NEW_LINE current_time_min = int ( current_time [ : 2 ] ) * 60 + int ( current_time [ 3 : ] ) NEW_LINE time_duration_min = int ( time_duration [ : 2 ] ) * 60 + int ( time_duration [ 3 : ] ) NEW_LINE t_min = current_time_min - time_duration_min NEW_LINE if current_time_min < time_duration_min : NEW_LINE INDENT t_min = 24 * 60 - abs ( t_min ) NEW_LINE DEDENT hour = "0" + str ( t_min // 60 ) if t_min // 60 < 10 else str ( t_min // 60 ) NEW_LINE minute = "0" + str ( t_min % 60 ) if t_min % 60 < 10 else str ( t_min % 60 ) NEW_LINE print ( f " { hour } : { minute } " ) NEW_LINE
def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( a [ i ] * a [ i - 1 ] < 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return longest NEW_LINE DEDENT a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestAlternatingSubarray ( a , n ) ) NEW_LINE
def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( " Right - angled ▁ Triangle " ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( " Obtuse - angled ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled ▁ Triangle " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE checkTypeOfTriangle ( a , b , c ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " GFGFG " NEW_LINE n = len ( s ) NEW_LINE countSubsequence ( s , n ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE for cx in range ( 101 ) : NEW_LINE INDENT for cy in range ( 101 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT x , y , h = map ( int , edges [ i ] ) NEW_LINE if h > 0 : NEW_LINE INDENT htop = abs ( x - cx ) + abs ( y - cy ) + h NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT x , y , h = map ( int , edges [ i ] ) NEW_LINE if h == 0 : NEW_LINE INDENT if htop - ( abs ( x - cx ) + abs ( y - cy ) ) > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if h > 0 : NEW_LINE INDENT if htop - ( abs ( x - cx ) + abs ( y - cy ) ) != h : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( cx , cy , htop ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT
from math import floor NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n ) : NEW_LINE INDENT largest = floor ( n ** ( 1 / 3 ) ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 150 NEW_LINE print ( countSteps ( n ) ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE from operator import itemgetter NEW_LINE input = stdin . readline NEW_LINE def solve ( data ) : NEW_LINE INDENT data . sort ( key = itemgetter ( 1 ) ) NEW_LINE top2 = data [ : 2 ] NEW_LINE others = data [ 2 : ] NEW_LINE return top2 , others NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT others_results = [ ] NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT round_results = [ ] NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT id , time = input ( ) . split ( ) NEW_LINE round_results . append ( [ int ( id ) , float ( time ) ] ) NEW_LINE DEDENT top2 , others = solve ( round_results ) NEW_LINE others_results . extend ( others ) NEW_LINE for id , time in top2 : NEW_LINE INDENT print ( ' { } ▁ { } ' . format ( id , time ) ) NEW_LINE DEDENT DEDENT top2 , others = solve ( others_results ) NEW_LINE for id , time in top2 : NEW_LINE INDENT print ( ' { } ▁ { } ' . format ( id , time ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if ( a [ 0 ] == a [ - 1 ] ) : NEW_LINE INDENT x = a . count ( a [ 0 ] ) * ( a . count ( a [ - 1 ] ) - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT x = a . count ( a [ 0 ] ) * a . count ( a [ - 1 ] ) NEW_LINE DEDENT print ( a [ - 1 ] - a [ 0 ] , x ) NEW_LINE
def bitsoncount ( x ) : NEW_LINE INDENT return bin ( x ) . count ( '1' ) NEW_LINE DEDENT def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bitsoncount ( i ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if s % ( ( n + 1 ) * n // 2 ) != 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT s //= ( ( n + 1 ) * n // 2 ) NEW_LINE b = [ a [ ( i + 1 ) % n ] - a [ i ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] -= s NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if b [ i ] > 0 or b [ i ] % n != 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE DEDENT main ( ) NEW_LINE
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == 1 : NEW_LINE INDENT count = 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if s [ j ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if count > max : NEW_LINE INDENT max = count NEW_LINE DEDENT DEDENT DEDENT print ( max ) NEW_LINE
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE for tt in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A , B = [ ] , [ ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT B . append ( abs ( y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT A . append ( abs ( x ) ) NEW_LINE DEDENT DEDENT A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( ( B [ i ] ) * ( B [ i ] ) + ( A [ i ] ) * ( A [ i ] ) ) ** ( 0.5 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 ; NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE
def reduceString ( s , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE steps = 0 ; NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( int ) ( count / 2 ) ; NEW_LINE count = 1 ; NEW_LINE DEDENT DEDENT steps += ( int ) ( count / 2 ) ; NEW_LINE return steps ; NEW_LINE DEDENT s = " geeksforgeeks " ; NEW_LINE l = len ( s ) ; NEW_LINE print ( reduceString ( s , l ) ) ; NEW_LINE
A , B = map ( int , input ( ) . split ( " ▁ " ) ) NEW_LINE if A <= B : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT chain = [ ] NEW_LINE N = A + B NEW_LINE def ask ( i , j ) : NEW_LINE INDENT print ( " ? ▁ % d ▁ % d " % ( i , j ) ) NEW_LINE return input ( ) == ' Y ' NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT if len ( chain ) == 0 : NEW_LINE INDENT chain . append ( i ) NEW_LINE continue NEW_LINE DEDENT last = chain [ - 1 ] NEW_LINE if ask ( last , i ) : NEW_LINE INDENT chain . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT chain . pop ( ) NEW_LINE DEDENT DEDENT main = chain . pop ( ) NEW_LINE ret = [ ( '1' if ask ( main , x ) else '0' ) for x in range ( 0 , N ) ] NEW_LINE print ( " ! ▁ % s " % ( " " . join ( ret ) ) ) NEW_LINE
x , y , a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = [ [ i , j ] for i in range ( a , x + 1 ) for j in range ( b , y + 1 ) if i > j ] NEW_LINE print ( len ( c ) ) ; [ print ( * i ) for i in c ] NEW_LINE
from math import sqrt NEW_LINE mod = 1000000007 NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans , 2 ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19374857 NEW_LINE mod = 17 NEW_LINE print ( calculate_factors ( n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE result = " " NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s [ i ] == " . " : NEW_LINE INDENT result += '0' NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE if s [ i ] == " . " : NEW_LINE INDENT result += '1' NEW_LINE DEDENT else : NEW_LINE INDENT result += '2' NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( result ) NEW_LINE
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE class Type ( Enum ) : NEW_LINE INDENT UNKOWN = 0 NEW_LINE OK = 1 NEW_LINE NOT = 2 NEW_LINE DEDENT class Info : NEW_LINE INDENT def __init__ ( self , arg_a , arg_b , arg_c ) : NEW_LINE INDENT self . work = [ arg_a , arg_b , arg_c ] NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A == 0 and B == 0 and C == 0 : NEW_LINE INDENT break NEW_LINE DEDENT table = [ Type . UNKOWN ] * ( ( A + B + C ) + 1 ) NEW_LINE N = int ( input ( ) ) NEW_LINE info = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , b , c , result = map ( int , input ( ) . split ( ) ) NEW_LINE if result == 1 : NEW_LINE INDENT table [ a ] = Type . OK NEW_LINE table [ b ] = Type . OK NEW_LINE table [ c ] = Type . OK NEW_LINE DEDENT else : NEW_LINE INDENT info . append ( Info ( a , b , c ) ) NEW_LINE DEDENT DEDENT for i in range ( len ( info ) ) : NEW_LINE INDENT count = 0 NEW_LINE tmp = - 1 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT if table [ info [ i ] . work [ k ] ] == Type . OK : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif table [ info [ i ] . work [ k ] ] == Type . UNKOWN : NEW_LINE INDENT tmp = info [ i ] . work [ k ] NEW_LINE DEDENT DEDENT if count != 2 or tmp == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT table [ tmp ] = Type . NOT NEW_LINE DEDENT for i in range ( 1 , ( A + B + C ) + 1 ) : NEW_LINE INDENT if table [ i ] == Type . OK : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif table [ i ] == Type . NOT : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "2" ) NEW_LINE DEDENT DEDENT DEDENT
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT countB [ b [ i ] ] = countB . get ( b [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in countA : NEW_LINE INDENT if x in countB . keys ( ) : NEW_LINE INDENT res += min ( countA [ x ] , countB [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE b = [ 2 , 3 , 4 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( minRemove ( a , b , n , m ) ) NEW_LINE
def count ( l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( i < 10 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = i % 10 NEW_LINE k = i NEW_LINE while ( k >= 10 ) : NEW_LINE INDENT k = k // 10 NEW_LINE DEDENT if ( n == k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return ( cnt ) NEW_LINE DEDENT L = 2 ; R = 60 ; NEW_LINE print ( count ( L , R ) ) NEW_LINE L = 1 ; R = 1000 ; NEW_LINE print ( count ( L , R ) ) NEW_LINE
number = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = 0 NEW_LINE data = { " found " : " NO " , ' first ' : 0 } NEW_LINE for i in range ( 0 , number ) : NEW_LINE INDENT x = int ( arr [ i ] ) NEW_LINE if x == 1 : NEW_LINE INDENT if counter == 0 : NEW_LINE INDENT counter = 1 NEW_LINE DEDENT if data [ ' found ' ] == " yes " : NEW_LINE INDENT y = i - data [ ' first ' ] NEW_LINE counter = counter * y NEW_LINE data [ ' first ' ] = i NEW_LINE DEDENT else : NEW_LINE INDENT data [ ' found ' ] = " yes " NEW_LINE data [ ' first ' ] = i NEW_LINE DEDENT DEDENT DEDENT print ( counter ) NEW_LINE
import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x /= 2 NEW_LINE ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if ( bit ( x / d ) <= bit ( d ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = int ( ( l + r ) / 2 ) NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( check ( l , n ) == False ) : NEW_LINE INDENT return math . floor ( l + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . floor ( l ) NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE
INT_MAX = 100000000 NEW_LINE def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ INT_MAX for i in range ( n ) ] NEW_LINE s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 + i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT s = " aaaaaaaa " NEW_LINE n = len ( s ) NEW_LINE print ( minimalSteps ( s , n ) ) NEW_LINE
def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num / base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] , end = " " ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE
import sys NEW_LINE import itertools NEW_LINE f = sys . stdin NEW_LINE g = itertools . accumulate NEW_LINE n = int ( f . readline ( ) ) NEW_LINE p = list ( map ( int , f . readline ( ) . split ( ) ) ) NEW_LINE c = f . readline ( ) NEW_LINE v = [ - x if y == ' B ' else x for x , y in zip ( p , c ) ] NEW_LINE s = sum ( p [ i ] if c [ i ] == ' B ' else 0 for i in range ( n ) ) NEW_LINE print ( s + max ( 0 , max ( g ( v ) ) , max ( g ( v [ : : - 1 ] ) ) ) ) NEW_LINE
for _ in [ 0 ] * int ( input ( ) ) : NEW_LINE INDENT a , b , c , d , e , f , g , h = map ( float , input ( ) . split ( ) ) NEW_LINE print ( [ ' NO ' , ' YES ' ] [ abs ( ( a - c ) * ( f - h ) - ( e - g ) * ( b - d ) ) < 1e-10 ] ) NEW_LINE DEDENT
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return a ^ b NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE n = 10 NEW_LINE print ( nthXorFib ( n , a , b ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . strip ( ' \n ' ) ) NEW_LINE taro_score = 0 NEW_LINE hanako_score = 0 NEW_LINE for turn in range ( n ) : NEW_LINE INDENT animals = [ animal for animal in sys . stdin . readline ( ) . strip ( ' \n ' ) . split ( ' ▁ ' ) ] NEW_LINE if animals [ 0 ] == animals [ 1 ] : NEW_LINE INDENT taro_score += 1 NEW_LINE hanako_score += 1 NEW_LINE DEDENT elif max ( animals [ 0 ] , animals [ 1 ] ) == animals [ 0 ] : NEW_LINE INDENT taro_score += 3 NEW_LINE DEDENT elif max ( animals [ 0 ] , animals [ 1 ] ) == animals [ 1 ] : NEW_LINE INDENT hanako_score += 3 NEW_LINE DEDENT DEDENT print ( ' % d ▁ % d ' % ( taro_score , hanako_score ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) , end = " \n " ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ( 1 , 3 , 1 , 2 ) ] NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT leftn , leftd , rightn , rightd = stack . pop ( ) NEW_LINE d = leftd + rightd NEW_LINE if d <= 12000 : NEW_LINE INDENT n = leftn + rightn NEW_LINE ans += 1 NEW_LINE stack . append ( ( n , d , rightn , rightd ) ) NEW_LINE stack . append ( ( leftn , leftd , n , d ) ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT ans = 2 ** ( n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE
from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = ( 10 ** d ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT
from math import sqrt , pow NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( pow ( 2 , d ) ) - 1 ; NEW_LINE prime = [ True for i in range ( maxVal + 1 ) ] NEW_LINE sieve ( prime , maxVal ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = 8 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE z = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE z . reverse ( ) NEW_LINE q , w = 0 , 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT q += z [ i ] NEW_LINE if q / ( i + 1 ) >= b : NEW_LINE INDENT w += 1 NEW_LINE DEDENT DEDENT print ( w ) NEW_LINE DEDENT
a = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 , 0 ] ] ) NEW_LINE print ( a [ 1 ] [ 0 ] - a [ 0 ] [ 0 ] + ( 1 if a [ 1 ] [ 1 ] > a [ 0 ] [ 1 ] or ( a [ 1 ] [ 1 ] == a [ 0 ] [ 1 ] and a [ 1 ] [ 2 ] > a [ 0 ] [ 2 ] ) else 0 ) ) NEW_LINE
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE
def countMaxContiguous ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 4 , 3 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countMaxContiguous ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE def cubeSide ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( ( h * r * math . sqrt ( 2 ) ) / ( h + math . sqrt ( 2 ) * r ) ) NEW_LINE return a NEW_LINE DEDENT h = 5 ; r = 6 ; NEW_LINE print ( cubeSide ( h , r ) , " \n " ) NEW_LINE
def pattern ( rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( rows_no - 1 , 0 , - 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows_no = 7 NEW_LINE pattern ( rows_no ) NEW_LINE
from collections import defaultdict , deque NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpls ( ) : return list ( input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE def dsum ( x ) : NEW_LINE INDENT return sum ( map ( int , list ( str ( x ) ) ) ) NEW_LINE DEDENT ans = INF NEW_LINE for a in range ( 1 , N ) : NEW_LINE INDENT b = N - a NEW_LINE ans = min ( ans , dsum ( a ) + dsum ( b ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 2401 ) : NEW_LINE INDENT if ( check_digits ( i ) == 1 ) : NEW_LINE INDENT return ( i ) NEW_LINE DEDENT DEDENT DEDENT N = 2397 NEW_LINE print ( str ( smallest_number ( N ) ) ) NEW_LINE
def triangular_series ( n ) : NEW_LINE INDENT j = 1 NEW_LINE k = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = ' ▁ ' ) NEW_LINE j = j + 1 NEW_LINE k = k + j NEW_LINE DEDENT DEDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE
def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n , m = _input ( ) NEW_LINE lst = list ( _input ( ) ) NEW_LINE l = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] not in l : NEW_LINE INDENT l [ lst [ i ] ] = 1 NEW_LINE DEDENT else : l [ lst [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ lst [ i ] ] > 1 : NEW_LINE INDENT res += n - i - l [ lst [ i ] ] NEW_LINE l [ lst [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += n - i - 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 ; NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( " Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in ▁ Fibonacci ▁ Series ▁ is " , findPosition ( k , n ) ) ; NEW_LINE
def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE print ( [ " First " , " Second " ] [ ( ( s [ 0 ] == s [ - 1 ] ) ^ ( len ( s ) % 2 == 0 ) ) ] ) NEW_LINE DEDENT main ( ) NEW_LINE
def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( countMinimumMoves ( arr , n , K ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b , n ) ) NEW_LINE DEDENT
T , s , q = map ( int , input ( ) . split ( ) ) NEW_LINE v = ( q - 1 ) / q NEW_LINE tm = 1 NEW_LINE t = s / ( 1 - v ) NEW_LINE while ( T - s ) / v - t > 0 : NEW_LINE INDENT if ( T - s ) / v - t < 1e-10 : NEW_LINE INDENT break NEW_LINE DEDENT tm += 1 NEW_LINE s += v * t NEW_LINE t = s / ( 1 - v ) NEW_LINE DEDENT print ( tm ) NEW_LINE
a = int ( input ( ) ) NEW_LINE print ( ( a - 2 ) ** 2 ) NEW_LINE
def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT hs = dict ( ) NEW_LINE for j in range ( len ( mat [ i ] ) ) : NEW_LINE INDENT hs [ mat [ i ] [ j ] ] = 1 NEW_LINE DEDENT if ( len ( hs ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] NEW_LINE print ( countIdenticalRows ( mat ) ) NEW_LINE
def createSorted ( a : list , n : int ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if len ( b ) == 0 : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start = 0 NEW_LINE end = len ( b ) - 1 NEW_LINE pos = 0 NEW_LINE while start <= end : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if b [ mid ] == a [ j ] : NEW_LINE INDENT b . insert ( max ( 0 , mid + 1 ) , a [ j ] ) NEW_LINE break NEW_LINE DEDENT elif b [ mid ] > a [ j ] : NEW_LINE INDENT pos = end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = start = mid + 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT pos = start NEW_LINE b . insert ( max ( 0 , pos ) , a [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 4 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE DEDENT
def countTotalDistinct ( string ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE items = set ( ) ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " " ; NEW_LINE ans = set ( ) ; NEW_LINE for j in range ( i , len ( string ) ) : NEW_LINE INDENT temp = temp + string [ j ] ; NEW_LINE ans . add ( string [ j ] ) ; NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) ; NEW_LINE cnt += len ( ans ) ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ABCA " ; NEW_LINE print ( countTotalDistinct ( string ) ) ; NEW_LINE DEDENT
import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = ( int ) ( math . log10 ( n ) ) NEW_LINE n = ( int ) ( n / pow ( 10 , digits ) ) NEW_LINE return n ; NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 ; NEW_LINE print ( firstDigit ( n ) , end = " ▁ " ) NEW_LINE print ( lastDigit ( n ) ) NEW_LINE
def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) ; NEW_LINE return ; NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) ; NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] ; NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE removeZeros ( a , n ) ; NEW_LINE
def find_maxm ( arr , n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in mpp ) : NEW_LINE INDENT mpp . update ( { arr [ i ] : mpp [ arr [ i ] ] + 1 } ) NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for value , freq in mpp . items ( ) : NEW_LINE INDENT if ( value == freq ) : NEW_LINE INDENT ans = max ( ans , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 2 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maxm ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def check ( x ) : NEW_LINE INDENT b = n NEW_LINE r = 0 NEW_LINE y = 0 NEW_LINE D = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT D [ b ] += 1 NEW_LINE if a [ i ] < x : NEW_LINE INDENT r += D [ b ] NEW_LINE b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b -= 1 NEW_LINE r -= D [ b ] NEW_LINE DEDENT y += r NEW_LINE DEDENT return y NEW_LINE DEDENT alpha = sorted ( a ) NEW_LINE l , r = 0 , n NEW_LINE m , c = n // 2 , n * ( n + 1 ) // 2 NEW_LINE while True : NEW_LINE INDENT if check ( alpha [ m ] ) <= c // 2 : NEW_LINE INDENT if m == n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT elif check ( alpha [ m + 1 ] ) > c // 2 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT l , m = m , ( m + r ) // 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m , r = ( m + l ) // 2 , m + 1 NEW_LINE DEDENT DEDENT print ( alpha [ m ] ) NEW_LINE
def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 35 NEW_LINE print ( sumOfDigitsTwoParts ( N ) ) NEW_LINE DEDENT
from sys import stdin NEW_LINE readlines = stdin . readlines NEW_LINE badge = [ ' AAA ' , ' AA ' , ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' NA ' ] NEW_LINE limit = { 500 : [ 35.50 , 37.50 , 40.00 , 43.00 , 50.00 , 55.00 , 70.00 , float ( ' inf ' ) ] , 1000 : [ 71.00 , 77.00 , 83.00 , 89.00 , 105.00 , 116.00 , 148.00 , float ( ' inf ' ) ] } NEW_LINE def rank ( time , limit ) : NEW_LINE INDENT for i , l in enumerate ( limit ) : NEW_LINE INDENT if time < l : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT for line in readlines ( ) : NEW_LINE INDENT t500 , t1000 = map ( float , line . split ( ) ) NEW_LINE print ( badge [ max ( rank ( t500 , limit [ 500 ] ) , rank ( t1000 , limit [ 1000 ] ) ) ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , r , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( abs ( n - r ) , r - 1 ) + max ( abs ( m - c ) , c - 1 ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE flag = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] - a [ i - 1 ] > 1 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math ; NEW_LINE def cal_sin ( n ) : NEW_LINE INDENT accuracy = 0.0001 ; NEW_LINE n = n * ( 3.142 / 180.0 ) ; NEW_LINE x1 = n ; NEW_LINE sinx = n ; NEW_LINE sinval = math . sin ( n ) ; NEW_LINE i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i + 1 ) ; NEW_LINE x1 = - x1 * n * n / denominator ; NEW_LINE sinx = sinx + x1 ; NEW_LINE i = i + 1 ; NEW_LINE if ( accuracy <= abs ( sinval - sinx ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT print ( round ( sinx ) ) ; NEW_LINE DEDENT n = 90 ; NEW_LINE cal_sin ( n ) ; NEW_LINE
def multiply ( array , n ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = pro * array [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT array = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( array ) NEW_LINE print ( multiply ( array , n ) ) NEW_LINE
l = [ 0 for _ in range ( 64 ) ] NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT query = list ( input ( ) . split ( ) ) NEW_LINE order = query [ 0 ] NEW_LINE if order == "0" : NEW_LINE INDENT print ( 1 if l [ int ( query [ 1 ] ) ] else 0 ) NEW_LINE DEDENT elif order == "1" : NEW_LINE INDENT l [ int ( query [ 1 ] ) ] = 1 NEW_LINE DEDENT elif order == "2" : NEW_LINE INDENT l [ int ( query [ 1 ] ) ] = 0 NEW_LINE DEDENT elif order == "3" : NEW_LINE INDENT l [ int ( query [ 1 ] ) ] ^= 1 NEW_LINE DEDENT elif order == "4" : NEW_LINE INDENT print ( 1 if all ( l ) else 0 ) NEW_LINE DEDENT elif order == "5" : NEW_LINE INDENT print ( 1 if any ( l ) else 0 ) NEW_LINE DEDENT elif order == "6" : NEW_LINE INDENT print ( 1 if not any ( l ) else 0 ) NEW_LINE DEDENT elif order == "7" : NEW_LINE INDENT print ( sum ( l ) ) NEW_LINE DEDENT elif order == "8" : NEW_LINE INDENT tmp = 0 NEW_LINE for i in reversed ( range ( 64 ) ) : NEW_LINE INDENT tmp += l [ i ] * 2 ** i NEW_LINE DEDENT print ( tmp ) NEW_LINE DEDENT DEDENT
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] ; NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE pares = 0 NEW_LINE bolo = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT camada = input ( ) NEW_LINE bolo . append ( camada ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT contador = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if bolo [ i ] [ j ] == ' C ' : NEW_LINE INDENT contador += 1 NEW_LINE DEDENT DEDENT pares += ( ( contador * ( contador - 1 ) ) // 2 ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT contador = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if bolo [ i ] [ j ] == ' C ' : NEW_LINE INDENT contador += 1 NEW_LINE DEDENT DEDENT pares += ( ( contador * ( contador - 1 ) ) // 2 ) NEW_LINE DEDENT print ( pares ) NEW_LINE
def findMinIndex ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return findMinIndex ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMinIndex ( arr , mid + 1 , high ) NEW_LINE DEDENT def binary_search ( arr , l , h , x ) : NEW_LINE INDENT while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if ( arr [ mid ] <= x ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT def countEleLessThanOrEqual ( arr , n , x ) : NEW_LINE INDENT min_index = findMinIndex ( arr , 0 , n - 1 ) NEW_LINE if ( x <= arr [ n - 1 ] ) : NEW_LINE INDENT return ( binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ) NEW_LINE DEDENT if ( ( min_index - 1 ) >= 0 and x <= arr [ min_index - 1 ] ) : NEW_LINE INDENT return ( n - min_index + binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT arr = [ 6 , 10 , 12 , 15 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 14 NEW_LINE print ( " Count ▁ = ▁ " , end = " " ) NEW_LINE print ( countEleLessThanOrEqual ( arr , n , x ) ) NEW_LINE
def f ( x , y ) : NEW_LINE INDENT v = y - 2 * x * x + 1 ; NEW_LINE return v ; NEW_LINE DEDENT def predict ( x , y , h ) : NEW_LINE INDENT y1p = y + h * f ( x , y ) ; NEW_LINE return y1p ; NEW_LINE DEDENT def correct ( x , y , x1 , y1 , h ) : NEW_LINE INDENT e = 0.00001 ; NEW_LINE y1c = y1 ; NEW_LINE while ( abs ( y1c - y1 ) > e ) : NEW_LINE INDENT y1 = y1c ; NEW_LINE y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) ; NEW_LINE DEDENT return y1c ; NEW_LINE DEDENT def printFinalValues ( x , xn , y , h ) : NEW_LINE INDENT while ( x < xn ) : NEW_LINE INDENT x1 = x + h ; NEW_LINE y1p = predict ( x , y , h ) ; NEW_LINE y1c = correct ( x , y , x1 , y1p , h ) ; NEW_LINE x = x1 ; NEW_LINE y = y1c ; NEW_LINE DEDENT print ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = " , int ( x ) , " is ▁ : " , " { : . 4 f } " . format ( y ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 0 ; y = 0.5 ; NEW_LINE xn = 1 ; NEW_LINE h = 0.2 ; NEW_LINE printFinalValues ( x , xn , y , h ) ; NEW_LINE DEDENT
def D_Pattern ( string , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( j == 1 or ( ( i == 0 or i == n - 1 ) and ( j > 1 and j < n - 2 ) ) or ( j == n - 2 and i != 0 and i != n - 1 ) ) : NEW_LINE INDENT string = string + " * " NEW_LINE DEDENT else : NEW_LINE INDENT string = string + " ▁ " NEW_LINE DEDENT DEDENT string = string + " \n " NEW_LINE DEDENT return ( string ) ; NEW_LINE DEDENT string = " " ; NEW_LINE n = 9 NEW_LINE print ( D_Pattern ( string , n ) ) ; NEW_LINE
def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position , 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE j = first_y_position + 1 NEW_LINE while ( second_y_position > 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 7 NEW_LINE kthString ( n , k ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE C [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def count_of_subarrays ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N - 1 , N ) ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE print ( count_of_subarrays ( N ) ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def productExceptSelf ( self , nums ) : NEW_LINE INDENT ans = [ 1 ] * len ( nums ) NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( len ( nums ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT  if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 ] NEW_LINE out = sObj . productExceptSelf ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ : k ] NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : k ] + s [ i ] NEW_LINE if ( lexMax < currStr ) : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if ( lexMin > currStr ) : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE getSmallestAndLargest ( str1 , k ) NEW_LINE DEDENT
m = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 ] * m NEW_LINE class struct : NEW_LINE INDENT def __init__ ( self , value , idx ) : NEW_LINE INDENT self . value = value NEW_LINE self . idx = idx NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT b [ i ] = struct ( b [ i ] , i ) NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE b . sort ( key = lambda x : x . value ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT d [ b [ i ] . idx ] = a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT print ( d [ i ] , ' ' , end = ' ' ) NEW_LINE DEDENT
INT_BITS = 32 NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT maxInd = index NEW_LINE maxEle = - 2147483648 NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT if ( ( set [ j ] & ( 1 << i ) ) != 0 and set [ j ] > maxEle ) : NEW_LINE INDENT maxEle = set [ j ] NEW_LINE maxInd = j NEW_LINE DEDENT DEDENT if ( maxEle == - 2147483648 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = set [ index ] NEW_LINE set [ index ] = set [ maxInd ] NEW_LINE set [ maxInd ] = temp NEW_LINE maxInd = index NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( j != maxInd and ( set [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT set [ j ] = set [ j ] ^ set [ maxInd ] NEW_LINE DEDENT DEDENT index = index + 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res ^ set [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT set = [ 9 , 8 , 5 ] NEW_LINE n = len ( set ) NEW_LINE print ( " Max ▁ subset ▁ XOR ▁ is ▁ " , end = " " ) NEW_LINE print ( maxSubarrayXOR ( set , n ) ) NEW_LINE
input ( ) NEW_LINE b = input ( ) . split ( ) NEW_LINE print ( max ( map ( b . count , b ) ) , len ( set ( b ) ) ) NEW_LINE
def partition ( arr , si , ei ) : NEW_LINE INDENT x = arr [ ei ] NEW_LINE i = ( si - 1 ) NEW_LINE for j in range ( si , ei ) : NEW_LINE INDENT if ( arr [ j ] <= x ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ ei ] = arr [ ei ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , si , ei ) : NEW_LINE INDENT pi = 0 NEW_LINE if ( si < ei ) : NEW_LINE INDENT pi = partition ( arr , si , ei ) NEW_LINE quickSort ( arr , si , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , ei ) NEW_LINE DEDENT DEDENT def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum , min_sum = 0 , 10 ** 9 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " , end = " " ) NEW_LINE return NEW_LINE DEDENT quickSort ( arr , l , r ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are " , arr [ min_l ] , " and " , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT count_map = { } NEW_LINE for c in s : NEW_LINE INDENT count_map [ c ] = count_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for i , c in enumerate ( s ) : NEW_LINE INDENT if count_map [ c ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT  if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " leetcode " NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
from queue import Queue NEW_LINE def checkStackPermutation ( ip , op , n ) : NEW_LINE INDENT Input = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Input . put ( ip [ i ] ) NEW_LINE DEDENT output = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . put ( op [ i ] ) NEW_LINE DEDENT tempStack = [ ] NEW_LINE while ( not Input . empty ( ) ) : NEW_LINE INDENT ele = Input . queue [ 0 ] NEW_LINE Input . get ( ) NEW_LINE if ( ele == output . queue [ 0 ] ) : NEW_LINE INDENT output . get ( ) NEW_LINE while ( len ( tempStack ) != 0 ) : NEW_LINE INDENT if ( tempStack [ - 1 ] == output . queue [ 0 ] ) : NEW_LINE INDENT tempStack . pop ( ) NEW_LINE output . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT tempStack . append ( ele ) NEW_LINE DEDENT DEDENT return ( Input . empty ( ) and len ( tempStack ) == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Input = [ 1 , 2 , 3 ] NEW_LINE output = [ 2 , 1 , 3 ] NEW_LINE n = 3 NEW_LINE if ( checkStackPermutation ( Input , output , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE s = defaultdict ( list ) NEW_LINE t = defaultdict ( list ) NEW_LINE S = list ( input ( ) ) NEW_LINE T = list ( input ( ) ) NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if T [ i ] not in s [ S [ i ] ] : NEW_LINE INDENT s [ S [ i ] ] . append ( T [ i ] ) NEW_LINE if len ( s [ S [ i ] ] ) >= 2 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT DEDENT if S [ i ] not in t [ T [ i ] ] : NEW_LINE INDENT t [ T [ i ] ] . append ( S [ i ] ) NEW_LINE if len ( t [ T [ i ] ] ) >= 2 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT DEDENT if i == len ( S ) - 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , d = 30 , 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE t = int ( input ( ) ) NEW_LINE for testcases in range ( t ) : NEW_LINE INDENT a , b , c , r = map ( int , input ( ) . split ( ) ) NEW_LINE MINC = c - r NEW_LINE MAXC = c + r NEW_LINE if a == b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT if a <= c <= b : NEW_LINE INDENT print ( max ( 0 , MINC - a ) + max ( 0 , b - MAXC ) ) NEW_LINE DEDENT elif c < a : NEW_LINE INDENT print ( min ( b - a , max ( 0 , b - MAXC ) ) ) NEW_LINE DEDENT elif c > b : NEW_LINE INDENT print ( min ( b - a , max ( 0 , MINC - a ) ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a >= c >= b : NEW_LINE INDENT print ( max ( 0 , MINC - b ) + max ( 0 , a - MAXC ) ) NEW_LINE DEDENT elif c < b : NEW_LINE INDENT print ( min ( a - b , max ( 0 , a - MAXC ) ) ) NEW_LINE DEDENT elif c > a : NEW_LINE INDENT print ( min ( a - b , max ( 0 , MINC - b ) ) ) NEW_LINE DEDENT DEDENT DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , s , t = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE print ( n - min ( s , t ) + 1 ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 10 ; NEW_LINE K = 2 ; NEW_LINE print ( findSum ( N , K ) ) ; NEW_LINE
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in a : NEW_LINE INDENT print ( 1 + ( ( 4 * i * ( i + 1 ) ) // math . gcd ( 4 * i , i + 1 ) ) // ( i + 1 ) ) NEW_LINE DEDENT
PI = 3.14 NEW_LINE from math import pow , sqrt NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 4 NEW_LINE d = 5 NEW_LINE print ( find_area ( r , d ) ) NEW_LINE DEDENT
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return s / n ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE s = 11 ; NEW_LINE print ( int ( minimumNumbers ( n , s ) ) ) ; NEW_LINE
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for end in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' i ' , ' a ' , ' e ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isSatisfied ( st , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) == False and isVowel ( st [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) and isVowel ( st [ i - 1 ] ) == False and isVowel ( st [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = " acaba " NEW_LINE n = len ( st ) NEW_LINE if ( isSatisfied ( st , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT n = 6 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def expect ( m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE i = m NEW_LINE while ( i ) : NEW_LINE INDENT ans += ( pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) ) * i NEW_LINE i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m , n = 6 , 3 NEW_LINE print ( expect ( m , n ) ) NEW_LINE DEDENT
def ProdOfPrimes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT n = 10 NEW_LINE print ( ProdOfPrimes ( n ) ) NEW_LINE
import datetime NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for y in range ( 1901 , 2001 ) for m in range ( 1 , 13 ) if datetime . date ( y , m , 1 ) . weekday ( ) == 6 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
class Date : NEW_LINE INDENT def __init__ ( self , d , m , y ) : NEW_LINE INDENT self . d = d NEW_LINE self . m = m NEW_LINE self . y = y NEW_LINE DEDENT DEDENT monthDays = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE def countLeapYears ( d ) : NEW_LINE INDENT years = d . y NEW_LINE if ( d . m <= 2 ) : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT return int ( years / 4 - years / 100 + years / 400 ) NEW_LINE DEDENT def getDifference ( dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 365 + dt1 . d NEW_LINE for i in range ( 0 , dt1 . m - 1 ) : NEW_LINE INDENT n1 += monthDays [ i ] NEW_LINE DEDENT n1 += countLeapYears ( dt1 ) NEW_LINE n2 = dt2 . y * 365 + dt2 . d NEW_LINE for i in range ( 0 , dt2 . m - 1 ) : NEW_LINE INDENT n2 += monthDays [ i ] NEW_LINE DEDENT n2 += countLeapYears ( dt2 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT dt1 = Date ( 1 , 2 , 2000 ) NEW_LINE dt2 = Date ( 1 , 2 , 2004 ) NEW_LINE print ( " Difference ▁ between ▁ two ▁ dates ▁ is " , getDifference ( dt1 , dt2 ) ) NEW_LINE
st = set ( ) NEW_LINE def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT st . add ( num ) NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num * 10 + a > num ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( i + 1 , 10 , 1 ) : NEW_LINE INDENT generateNumbers ( n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( " The ▁ numbers ▁ are : " , end = " ▁ " ) NEW_LINE l = list ( st ) NEW_LINE print ( l ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE printNumbers ( n ) NEW_LINE DEDENT
n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE t = ( n * k * t ) // 100 NEW_LINE for i in range ( n ) : print ( min ( max ( 0 , t - i * k ) , k ) , end = ' ▁ ' ) NEW_LINE
from collections import defaultdict NEW_LINE def main ( n , m ) : NEW_LINE INDENT d = defaultdict ( int ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT M = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for num , i in enumerate ( M ) : NEW_LINE INDENT if num == 0 : continue NEW_LINE d [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 10 ** 20 NEW_LINE for key , value in d . items ( ) : NEW_LINE INDENT if value > m : NEW_LINE INDENT ans = key NEW_LINE m = value NEW_LINE DEDENT elif value == m : NEW_LINE INDENT ans = min ( ans , key ) NEW_LINE DEDENT DEDENT if ans == 10 ** 20 : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT while 1 : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT main ( n , m ) NEW_LINE DEDENT
def getOddOccurrence ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for element in arr : NEW_LINE INDENT res = res ^ element NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEW_LINE print ( " % d " % getOddOccurrence ( arr ) ) NEW_LINE
import sys NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT if ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = 2 * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE x = 1 << 31 + 1 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE DEDENT
from math import * NEW_LINE def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] , isPrime [ 1 ] = False , False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ False ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = int ( n / i ) NEW_LINE if ( isPrime [ i ] & isPrime [ x ] and x != i and x * i == n ) : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ found " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 39 ; NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = " , gcd ( a , b ) ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = " , gcd ( a , b ) ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = " , gcd ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = " , gcd ( a , b ) ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = " , gcd ( a , b ) ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = " , gcd ( a , b ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT SIZE_LIMIT = 1000000 NEW_LINE TYPE_LIMIT = 10 NEW_LINE type = [ 0 ] * ( SIZE_LIMIT + 1 ) NEW_LINE for n in range ( 3 , SIZE_LIMIT // 4 + 2 ) : NEW_LINE INDENT for m in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT tiles = n * n - m * m NEW_LINE if tiles > SIZE_LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT type [ tiles ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( 1 for t in type if 1 <= t <= TYPE_LIMIT ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE S = input ( ) NEW_LINE s = list ( S ) NEW_LINE stack = [ ] NEW_LINE pos = [ ] NEW_LINE check0 = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT j = len ( s ) - i - 1 NEW_LINE stack . append ( [ j , int ( s [ j ] ) ] ) NEW_LINE if s [ j ] == "0" : NEW_LINE INDENT if check0 == 0 : NEW_LINE INDENT if not pos : NEW_LINE INDENT stack . pop ( ) NEW_LINE pos . append ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT if pos [ - 1 ] - j > 1 : NEW_LINE INDENT stack . pop ( ) NEW_LINE pos . append ( j ) NEW_LINE DEDENT DEDENT if stack : NEW_LINE INDENT if stack [ - 1 ] [ 1 ] == 0 : NEW_LINE INDENT check0 = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if check0 == 1 : NEW_LINE INDENT if s [ j ] == "1" : NEW_LINE INDENT if pos [ - 1 ] - j > 1 : NEW_LINE INDENT stack . pop ( ) NEW_LINE pos . append ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT stack2 = [ ] NEW_LINE check = 0 NEW_LINE for i in range ( 0 , len ( stack ) - 1 ) : NEW_LINE INDENT if stack [ i ] [ 1 ] < stack [ i + 1 ] [ 1 ] : NEW_LINE INDENT check = 1 NEW_LINE DEDENT DEDENT if check == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( not ( N & 1 ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT N = 14 NEW_LINE print ( maxZeros ( N ) ) NEW_LINE
def getLongestSeq ( a , n ) : NEW_LINE INDENT maxIdx = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currIdx = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if a [ k ] > 0 : NEW_LINE INDENT currLen += 1 NEW_LINE if currLen == 1 : NEW_LINE INDENT currIdx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if currLen > maxLen : NEW_LINE INDENT maxLen = currLen NEW_LINE maxIdx = currIdx NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT DEDENT if maxLen > 0 : NEW_LINE INDENT print ( ' Index ▁ : ' , maxIdx , ' ▁ , Length ▁ : ' , maxLen , ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ positive ▁ sequence ▁ detected . " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE getLongestSeq ( arr , n ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = None NEW_LINE self . down = None NEW_LINE DEDENT DEDENT def construct ( arr , i , j , m , n ) : NEW_LINE INDENT if ( i > n - 1 or j > m - 1 ) : NEW_LINE INDENT return None NEW_LINE DEDENT temp = Node ( arr [ i ] [ j ] ) NEW_LINE temp . data = arr [ i ] [ j ] NEW_LINE temp . right = construct ( arr , i , j + 1 , m , n ) NEW_LINE temp . down = construct ( arr , i + 1 , j , m , n ) NEW_LINE return temp NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT Dp = head NEW_LINE while ( Dp ) : NEW_LINE INDENT Rp = Dp NEW_LINE while ( Rp ) : NEW_LINE INDENT print ( Rp . data , end = " ▁ " ) NEW_LINE Rp = Rp . right NEW_LINE DEDENT print ( ) NEW_LINE Dp = Dp . down NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE m , n = 3 , 3 NEW_LINE head = construct ( arr , 0 , 0 , m , n ) NEW_LINE display ( head ) NEW_LINE DEDENT
import math NEW_LINE N = int ( input ( ) ) NEW_LINE nums = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE def is_prime ( num ) : NEW_LINE INDENT if num < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT num_sqrt = math . floor ( math . sqrt ( num ) ) NEW_LINE for prime in range ( 2 , num_sqrt + 1 ) : NEW_LINE INDENT if num % prime == 0 : NEW_LINE INDENT return False NEW_LINE break NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT print ( len ( [ n for n in nums if is_prime ( n ) ] ) ) NEW_LINE
def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 ; NEW_LINE findNthTerm ( N ) ; NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a == b == c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE print ( " Yes " if isRectangle ( a , b , c , d ) else " No " ) NEW_LINE
import math ; NEW_LINE def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE an = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m ; NEW_LINE DEDENT value = [ 0 ] * m ; NEW_LINE cur = an ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i ; NEW_LINE DEDENT cur = ( cur * an ) % m ; NEW_LINE DEDENT cur = b ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE
import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT
from math import * NEW_LINE def Probability ( sum , times ) : NEW_LINE INDENT favorable , total , probability = 0.0 , 36.0 , 0 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT if ( ( i + j ) == sum ) : NEW_LINE INDENT favorable += 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = gcd ( int ( favorable ) , int ( total ) ) NEW_LINE favorable = favorable / gcd1 NEW_LINE total = total / gcd1 NEW_LINE probability = pow ( total , times ) NEW_LINE return int ( probability ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum , times = 7 , 7 NEW_LINE print ( "1" , " / " , Probability ( sum , times ) ) NEW_LINE DEDENT
K , N = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 998244353 NEW_LINE def inved ( a ) : NEW_LINE INDENT x , y , u , v , k , l = 1 , 0 , 0 , 1 , a , mod NEW_LINE while l != 0 : NEW_LINE INDENT x , y , u , v = u , v , x - u * ( k // l ) , y - v * ( k // l ) NEW_LINE k , l = l , k % l NEW_LINE DEDENT return x % mod NEW_LINE DEDENT X = [ 0 for i in range ( 2 * K - 1 ) ] NEW_LINE frac = [ 1 ] NEW_LINE for i in range ( N + K ) : NEW_LINE INDENT frac . append ( ( ( i + 1 ) * frac [ i ] ) % mod ) NEW_LINE DEDENT invf = [ ] NEW_LINE for i in range ( N + K + 1 ) : NEW_LINE INDENT invf . append ( inved ( frac [ i ] ) ) NEW_LINE DEDENT for k in range ( 2 , K + 2 ) : NEW_LINE INDENT S = 0 NEW_LINE sign = 1 NEW_LINE l = k // 2 NEW_LINE for m in range ( min ( l + 1 , N // 2 + 1 ) ) : NEW_LINE INDENT prod = ( sign * ( frac [ l ] * frac [ N + K - 2 * m - 1 ] ) ) % mod NEW_LINE prod *= ( invf [ m ] * invf [ l - m ] ) % mod NEW_LINE prod %= mod NEW_LINE prod *= ( invf [ N - 2 * m ] * invf [ K - 1 ] ) % mod NEW_LINE prod %= mod NEW_LINE S += prod NEW_LINE S %= mod NEW_LINE sign *= - 1 NEW_LINE DEDENT X [ k - 2 ] , X [ 2 * K - k ] = S , S NEW_LINE DEDENT for i in range ( 2 * K - 1 ) : NEW_LINE INDENT print ( X [ i ] ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = list ( input ( ) . split ( ) ) NEW_LINE if a [ 1 ] == ' BTC ' : NEW_LINE INDENT c += float ( a [ 0 ] ) * 380000.0 NEW_LINE DEDENT else : NEW_LINE INDENT c += float ( a [ 0 ] ) NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE num1 = 5 NEW_LINE num2 = 4 NEW_LINE print ( getCount ( arr , n , num1 , num2 ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( min ( a [ i + 1 ] - a [ i ] for i in range ( n - 1 ) ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 for x in range ( n + 1 ) ] NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def largestGCD1Subset ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if ( currentGCD == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestGCD1Subset ( A , n ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT divisors = [ 2 ] * ( 10 ** 7 + 1 ) NEW_LINE for i in range ( 2 , ( len ( divisors ) + 1 ) // 2 ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisors ) , i ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( ( 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) for i in range ( 2 , len ( divisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT
def findEncryptedArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE findEncryptedArray ( arr , N ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT min__ = secondMax = arr [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT min__ = secondMax = arr [ 1 ] NEW_LINE DEDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT max__ = secondMin = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max__ = secondMin = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max__ ) : NEW_LINE INDENT secondMax = max__ NEW_LINE max__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min__ ) : NEW_LINE INDENT secondMin = min__ NEW_LINE min__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max__ - secondMin , secondMax - min__ ) NEW_LINE return diff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE from math import sqrt NEW_LINE read = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def factor ( a , b ) : NEW_LINE INDENT ret = set ( ) NEW_LINE i = 2 NEW_LINE while i <= sqrt ( max ( a , b ) ) : NEW_LINE INDENT while a % i == 0 : NEW_LINE INDENT ret . add ( i ) NEW_LINE a //= i NEW_LINE DEDENT while b % i == 0 : NEW_LINE INDENT ret . add ( i ) NEW_LINE b //= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if a >= 2 : NEW_LINE INDENT ret . add ( a ) NEW_LINE DEDENT if b >= 2 : NEW_LINE INDENT ret . add ( b ) NEW_LINE DEDENT return ret NEW_LINE DEDENT def test ( a , b , s ) : NEW_LINE INDENT ret = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if a % i == 0 or b % i == 0 : NEW_LINE INDENT ret . add ( i ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT n = int ( read ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , read ( ) . split ( ) ) NEW_LINE a . append ( x ) ; b . append ( y ) ; NEW_LINE DEDENT f = factor ( a [ 0 ] , b [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT f = test ( a [ i ] , b [ i ] , f ) NEW_LINE DEDENT if len ( f ) == 0 : NEW_LINE INDENT write ( " - 1 \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in f : NEW_LINE INDENT write ( str ( i ) + ' \n ' ) NEW_LINE break NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT stars = defaultdict ( int ) NEW_LINE for s in map ( int , input ( ) . split ( ) ) : NEW_LINE INDENT stars [ s ] += 1 NEW_LINE DEDENT half_n = n // 2 NEW_LINE for i , s in stars . items ( ) : NEW_LINE INDENT if s > half_n : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ▁ COLOR ' ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( num ) ) NEW_LINE
n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE weights = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT weights . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT prices = [ ] NEW_LINE for i in range ( d - 1 ) : NEW_LINE INDENT prices . append ( [ weights [ i + 1 ] [ j ] - weights [ i ] [ j ] for j in range ( n ) ] ) NEW_LINE DEDENT bag = x NEW_LINE for i in range ( d - 1 ) : NEW_LINE INDENT dp = [ False for i in range ( bag + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( bag ) : NEW_LINE INDENT if weights [ i ] [ j ] + k < bag + 1 and dp [ k ] is not False : NEW_LINE INDENT dp [ k + weights [ i ] [ j ] ] = max ( dp [ k + weights [ i ] [ j ] ] , dp [ k ] + prices [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT bag += max ( dp [ : bag + 1 ] ) NEW_LINE DEDENT print ( bag ) NEW_LINE
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE stones = [ int ( x ) for x in input ( ) . split ( " ▁ " , n ) ] NEW_LINE total1 = [ 0 ] * ( len ( stones ) + 1 ) NEW_LINE for i in range ( 1 , len ( stones ) + 1 ) : NEW_LINE INDENT total1 [ i ] = stones [ i - 1 ] + total1 [ i - 1 ] NEW_LINE DEDENT total2 = [ 0 ] * ( len ( stones ) + 1 ) NEW_LINE stones . sort ( ) NEW_LINE for i in range ( 1 , len ( stones ) + 1 ) : NEW_LINE INDENT total2 [ i ] = stones [ i - 1 ] + total2 [ i - 1 ] NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT x = [ int ( x ) for x in input ( ) . split ( " ▁ " , 3 ) ] NEW_LINE if x [ 0 ] == 1 : NEW_LINE INDENT print ( total1 [ x [ 2 ] ] - total1 [ x [ 1 ] - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( total2 [ x [ 2 ] ] - total2 [ x [ 1 ] - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT solve ( ) NEW_LINE
def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return int ( ( el2 - el1 ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE el3 = st [ 2 ] NEW_LINE if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT
import math NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE m = int ( math . sqrt ( k ) ) + 1 NEW_LINE i = 2 NEW_LINE while i <= m and k > 1 : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT u = 0 NEW_LINE v = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k //= i NEW_LINE v += 1 NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return r NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT
def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print ( " Given ▁ point ▁ lies ▁ inside " " ▁ the ▁ rectangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Given ▁ point ▁ does ▁ not ▁ lie " " ▁ on ▁ the ▁ rectangle " ) NEW_LINE DEDENT DEDENT
N = 1000 NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += int ( ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ) NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if ( freq [ j ] > 0 and ( freq [ int ( ( i + j ) / 2 ) ] > 0 ) ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def getAvg ( x , n , sum ) : NEW_LINE INDENT sum = sum + x ; NEW_LINE return float ( sum ) / n ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( arr [ i ] , i + 1 , sum ) ; NEW_LINE sum = avg * ( i + 1 ) ; NEW_LINE print ( " Average ▁ of ▁ " , end = " " ) ; NEW_LINE print ( i + 1 , end = " " ) ; NEW_LINE print ( " ▁ numbers ▁ is ▁ " , end = " " ) ; NEW_LINE print ( avg ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE
MAX = 10000 NEW_LINE s = set ( ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX ) NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 100 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT product = product * p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT if n in s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isEuclid ( n ) == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if isEuclid ( n ) == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
line1 = input ( ) . split ( ) NEW_LINE line2 = input ( ) . split ( ) NEW_LINE n = int ( line1 [ 0 ] ) NEW_LINE b = int ( line1 [ 1 ] ) NEW_LINE l1 = [ ] NEW_LINE for i in line2 : NEW_LINE INDENT l1 . append ( int ( i ) ) NEW_LINE DEDENT l2 = [ ] NEW_LINE num_of_cuts = 0 NEW_LINE for i in range ( len ( l1 ) ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT num_of_odds = 0 NEW_LINE num_of_evens = 0 NEW_LINE for j in l1 [ : i ] : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT num_of_evens += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_of_odds += 1 NEW_LINE DEDENT DEDENT if num_of_evens == num_of_odds : NEW_LINE INDENT l2 . append ( abs ( l1 [ i ] - l1 [ i - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT l2 . sort ( ) NEW_LINE for i in l2 : NEW_LINE INDENT if i <= b : NEW_LINE INDENT num_of_cuts += 1 NEW_LINE b -= i NEW_LINE DEDENT DEDENT print ( num_of_cuts ) NEW_LINE
def maxOperations ( str ) : NEW_LINE INDENT i , g , gk , gks = 0 , 0 , 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' g ' ) : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif ( str [ i ] == ' k ' ) : NEW_LINE INDENT if ( g > 0 ) : NEW_LINE INDENT g -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' s ' ) : NEW_LINE INDENT if ( gk > 0 ) : NEW_LINE INDENT gk -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " ggkssk " NEW_LINE print ( maxOperations ( a ) ) NEW_LINE DEDENT
a = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( a - 1 ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ i + 1 ] ) > 1 : NEW_LINE INDENT c += abs ( arr [ i ] - arr [ i + 1 ] ) - 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE students = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE students [ a - 1 ] . append ( b - 1 ) NEW_LINE students [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT seen = [ ] NEW_LINE bench = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i not in seen : NEW_LINE INDENT seen . append ( i ) NEW_LINE if len ( students [ i ] ) == 0 or len ( students [ i ] ) == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT root = i NEW_LINE prev = - 1 NEW_LINE curr = i NEW_LINE Finished = False NEW_LINE clen = 1 NEW_LINE while not Finished : NEW_LINE INDENT seen . append ( curr ) NEW_LINE if len ( students [ curr ] ) == 1 : NEW_LINE INDENT Finished = True NEW_LINE DEDENT else : NEW_LINE INDENT if root in students [ curr ] and root != prev : NEW_LINE INDENT Finished = True NEW_LINE if clen % 2 == 1 : NEW_LINE INDENT bench += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if students [ curr ] [ 0 ] != prev : NEW_LINE INDENT prev = curr NEW_LINE clen += 1 NEW_LINE curr = students [ curr ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT prev = curr NEW_LINE curr = students [ curr ] [ 1 ] NEW_LINE clen += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if ( n - bench ) % 2 == 1 : NEW_LINE INDENT print ( bench + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( bench ) NEW_LINE DEDENT
def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( " K ' th ▁ smallest ▁ element ▁ is " , kthSmallest ( arr , n , k ) ) NEW_LINE DEDENT
for d in ' ▁ ' * int ( input ( ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE * a , = map ( int , input ( ) . split ( ) ) NEW_LINE b = sorted ( a ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if b [ i ] == a [ i ] : b [ i ] , b [ i + 1 ] = b [ i + 1 ] , b [ i ] NEW_LINE DEDENT if n == 1 : b = [ - 1 ] NEW_LINE elif b [ - 1 ] == a [ - 1 ] : b [ - 1 ] , b [ - 2 ] = b [ - 2 ] , b [ - 1 ] NEW_LINE print ( * b ) NEW_LINE DEDENT
import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = " PPPPNNPPPNPPNPN " NEW_LINE assert 0 <= START_NUM < END_NUM NEW_LINE assert 1 <= len ( CROAK_SEQ ) NEW_LINE NUM_JUMPS = len ( CROAK_SEQ ) - 1 NEW_LINE NUM_TRIALS = 2 ** NUM_JUMPS NEW_LINE globalnumerator = 0 NEW_LINE isprime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_NUM , END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialnumerator = 1 NEW_LINE if isprime [ pos ] == ( CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( j >> k ) & 1 == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT DEDENT globalnumerator += trialnumerator NEW_LINE DEDENT DEDENT globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ** NUM_JUMPS * 3 ** len ( CROAK_SEQ ) NEW_LINE ans = fractions . Fraction ( globalnumerator , globaldenominator ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import radians , cos , sin , asin , sqrt NEW_LINE def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = radians ( lon1 ) NEW_LINE lon2 = radians ( lon2 ) NEW_LINE lat1 = radians ( lat1 ) NEW_LINE lat2 = radians ( lat2 ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 NEW_LINE c = 2 * asin ( sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT lat1 = 53.32055555555556 NEW_LINE lat2 = 53.31861111111111 NEW_LINE lon1 = - 1.7297222222222221 NEW_LINE lon2 = - 1.6997222222222223 NEW_LINE print ( distance ( lat1 , lat2 , lon1 , lon2 ) , " K . M " ) NEW_LINE
def centeredOctahedral ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE DEDENT
class measure : NEW_LINE INDENT def __init__ ( self , init , station_count ) : NEW_LINE INDENT self . init = init NEW_LINE self . station_count = station_count NEW_LINE DEDENT def clockwise ( self , pos ) : NEW_LINE INDENT return ( self . station_count - self . init + pos ) % self . station_count NEW_LINE DEDENT def anticlockwise ( self , pos ) : NEW_LINE INDENT return ( self . station_count + self . init - pos ) % self . station_count NEW_LINE DEDENT DEDENT import sys NEW_LINE from bisect import bisect NEW_LINE f = sys . stdin NEW_LINE n , _ , init = map ( int , f . readline ( ) . split ( ) ) NEW_LINE d = sorted ( list ( map ( int , f ) ) ) NEW_LINE m = measure ( init , n ) NEW_LINE dist = [ ] NEW_LINE n_pos = bisect ( d , init ) if d [ 0 ] < init < d [ - 1 ] else 0 NEW_LINE dist . append ( m . anticlockwise ( d [ n_pos ] ) ) NEW_LINE p_pos = n_pos - 1 NEW_LINE dist . append ( m . clockwise ( d [ p_pos ] ) ) NEW_LINE for di , dj in zip ( d , d [ - 1 : ] + d [ : - 1 ] ) : NEW_LINE INDENT dist . append ( m . anticlockwise ( di ) * 2 + m . clockwise ( dj ) ) NEW_LINE dist . append ( m . anticlockwise ( di ) + 2 * m . clockwise ( dj ) ) NEW_LINE DEDENT print ( min ( dist ) * 100 ) NEW_LINE
import math NEW_LINE def SumDivPrime ( A , n ) : NEW_LINE INDENT max_val = max ( A ) + 1 NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( math . sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ A [ i ] ] : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ A [ i ] ] and sum % A [ i ] == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE SumDivPrime ( A , n ) NEW_LINE
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( str ( arr [ i % n ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 3 ; NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 4 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE
def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x / 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE
for _ in [ 0 ] * int ( input ( ) ) : y = input ( ) ; print ( ' cryeadn ' [ int ( y ) % 3 < 1 and ( not { * y } & { * '2468' } ) < y . count ( '0' ) : : 2 ] ) NEW_LINE
dp = [ [ - 1 for i in range ( 8101 ) ] for i in range ( 901 ) ] NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or a < 0 or b < 0 or a > 900 or b > 8100 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 0 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = ans NEW_LINE return ans NEW_LINE DEDENT def printSmallestNumber ( a , b ) : NEW_LINE INDENT for i in range ( 901 ) : NEW_LINE INDENT for j in range ( 8101 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE k = minimumNumberOfDigits ( a , b ) NEW_LINE if ( k == - 1 or k > 100 ) : NEW_LINE INDENT print ( - 1 , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( a > 0 and b > 0 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 18 NEW_LINE b = 162 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE DEDENT
N = 5005 NEW_LINE n , k = 0 , 0 NEW_LINE gr = [ [ ] for i in range ( N ) ] NEW_LINE d = [ [ 0 for i in range ( 505 ) ] for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( v , par ) : NEW_LINE INDENT global ans NEW_LINE d [ v ] [ 0 ] = 1 NEW_LINE for i in gr [ v ] : NEW_LINE INDENT if ( i != par ) : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ v ] [ j ] += d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 5 NEW_LINE k = 2 NEW_LINE Add_edge ( 1 , 2 ) NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 3 , 4 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE dfs ( 1 , 0 ) NEW_LINE print ( ans ) NEW_LINE
def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 ; NEW_LINE dp = [ 0 ] * 10 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 ; NEW_LINE tmp //= 10 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE locMax = 1 ; NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 ; NEW_LINE tmp //= 10 ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 ; NEW_LINE locMax = max ( locMax , dp [ d ] ) ; NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax ; NEW_LINE DEDENT DEDENT length = max ( length , locMax ) ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT input ( ) NEW_LINE print ( len ( set ( list ( input ( ) . split ( ) ) ) . intersection ( set ( list ( input ( ) . split ( ) ) ) ) ) ) NEW_LINE DEDENT
def totalPrimeFactors ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( ( n % 2 ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE while ( ( n % 2 ) == 0 ) : NEW_LINE INDENT n //= 2 ; NEW_LINE DEDENT DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE while ( ( n % i ) == 0 ) : NEW_LINE INDENT n //= i ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT if ( L % G != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT div = int ( L / G ) ; NEW_LINE return ( 1 << totalPrimeFactors ( div ) ) ; NEW_LINE DEDENT G = 2 ; NEW_LINE L = 12 ; NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD " , G , " & ▁ LCM " , L , end = " " ) ; NEW_LINE print ( " ▁ = " , countPairs ( G , L ) ) ; NEW_LINE
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N / a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * sum NEW_LINE print ( " Sum ▁ of ▁ multiples ▁ of ▁ " , a , " ▁ up ▁ to ▁ " , N , " ▁ = ▁ " , ans ) NEW_LINE DEDENT calculate_sum ( 7 , 49 ) NEW_LINE
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE n , m , k = int ( line [ 0 ] ) , int ( line [ 1 ] ) , int ( line [ 2 ] [ 2 : ] ) NEW_LINE skills = { } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE skills [ line [ 0 ] ] = int ( line [ 1 ] ) NEW_LINE DEDENT new_skills = [ input ( ) for _ in range ( m ) ] NEW_LINE count = 0 NEW_LINE delete = [ ] NEW_LINE for key , value in skills . items ( ) : NEW_LINE INDENT value = int ( k * value / 100 ) NEW_LINE if value < 100 : NEW_LINE INDENT delete . append ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT skills [ key ] = value NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for key in delete : NEW_LINE INDENT del skills [ key ] NEW_LINE DEDENT for skill in new_skills : NEW_LINE INDENT if skill not in skills . keys ( ) : NEW_LINE INDENT skills [ skill ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT skills = dict ( sorted ( skills . items ( ) ) ) NEW_LINE print ( count ) NEW_LINE for key , value in skills . items ( ) : NEW_LINE INDENT print ( key , value , sep = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT
def next ( arr , target ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = len ( arr ) - 1 ; NEW_LINE ans = - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid ; NEW_LINE end = mid - 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] ; NEW_LINE print ( next ( arr , 8 ) ) ; NEW_LINE DEDENT
word = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " ] NEW_LINE def printWordsWithoutIfSwitch ( n ) : NEW_LINE INDENT digits = [ 0 for i in range ( 10 ) ] NEW_LINE dc = 0 NEW_LINE while True : NEW_LINE INDENT digits [ dc ] = n % 10 NEW_LINE n = n // 10 NEW_LINE dc += 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( dc - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( word [ digits [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 350 NEW_LINE printWordsWithoutIfSwitch ( n ) NEW_LINE
from sys import stdin , stdout NEW_LINE int_in = lambda : int ( stdin . readline ( ) ) NEW_LINE arr_in = lambda : [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE mat_in = lambda rows : [ arr_in ( ) for _ in range ( rows ) ] NEW_LINE str_in = lambda : stdin . readline ( ) . strip ( ) NEW_LINE out = lambda o : stdout . write ( " { } \n " . format ( o ) ) NEW_LINE arr_out = lambda o : out ( " ▁ " . join ( map ( str , o ) ) ) NEW_LINE bool_out = lambda o : out ( " YES " if o else " NO " ) NEW_LINE tests = lambda : range ( 1 , int_in ( ) + 1 ) NEW_LINE case_out = lambda i , o : out ( " Case ▁ # { } : ▁ { } " . format ( i , o ) ) NEW_LINE def solve ( n , k , m , a ) : NEW_LINE INDENT sa = sorted ( a ) NEW_LINE prefix_sum = [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum . append ( sa [ i ] + prefix_sum [ - 1 ] ) NEW_LINE DEDENT best = 0 NEW_LINE for i in range ( min ( n , m + 1 ) ) : NEW_LINE INDENT total_power = prefix_sum [ n ] - prefix_sum [ i ] NEW_LINE remaining_heros = len ( sa ) - i NEW_LINE max_that_can_be_added = min ( m - i , remaining_heros * k ) NEW_LINE best = max ( best , ( total_power + max_that_can_be_added ) / remaining_heros ) NEW_LINE DEDENT return best NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k , m = arr_in ( ) NEW_LINE a = arr_in ( ) NEW_LINE out ( solve ( n , k , m , a ) ) NEW_LINE DEDENT
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min = 0 NEW_LINE max = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = " a + c " NEW_LINE s2 = " + + b " NEW_LINE solve ( s1 , s2 ) NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE s = 2 NEW_LINE print ( " Total ▁ Ways ▁ = ▁ " , TotalWays ( n , s , k ) ) NEW_LINE DEDENT
def countEvenOdd ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem % 2 == 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT print ( " Even ▁ count ▁ : ▁ " , even_count ) NEW_LINE print ( " \n Odd ▁ count ▁ : ▁ " , odd_count ) NEW_LINE if ( even_count % 2 == 0 and odd_count % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 2335453 ; NEW_LINE t = countEvenOdd ( n ) ; NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from itertools import accumulate NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE books = [ [ ] for _ in range ( 10 ) ] NEW_LINE while n : NEW_LINE INDENT c , g = map ( int , input ( ) . split ( ) ) NEW_LINE books [ g - 1 ] . append ( c ) NEW_LINE n -= 1 NEW_LINE DEDENT books_acc = [ [ 0 ] + list ( accumulate ( c + i * 2 for i , c in enumerate ( sorted ( q , reverse = True ) ) ) ) for q in books ] NEW_LINE def memoize ( f ) : NEW_LINE INDENT memo = [ [ - 1 ] * ( k + 1 ) for _ in range ( 10 ) ] NEW_LINE def main ( x , y ) : NEW_LINE INDENT if x > 9 : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = memo [ x ] [ y ] NEW_LINE if result < 0 : NEW_LINE INDENT result = memo [ x ] [ y ] = f ( x , y ) NEW_LINE DEDENT return result NEW_LINE DEDENT return main NEW_LINE DEDENT @ memoize NEW_LINE def combi ( g , remain ) : NEW_LINE INDENT book_acc = list ( books_acc [ g ] ) NEW_LINE salable = min ( remain + 1 , len ( book_acc ) ) NEW_LINE return max ( [ book_acc [ i ] + combi ( g + 1 , remain - i ) for i in range ( salable ) ] , default = 0 ) NEW_LINE DEDENT print ( combi ( 0 , k ) ) NEW_LINE
def findmin ( p , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] [ 0 ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] [ 1 ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] [ 1 ] <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( [ a , b , c , d ] ) NEW_LINE DEDENT p = [ [ 1 , 1 ] , [ 2 , 2 ] , [ - 1 , - 1 ] , [ - 2 , 2 ] ] NEW_LINE n = len ( p ) NEW_LINE print ( findmin ( p , n ) ) NEW_LINE
from math import sqrt NEW_LINE def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE prime_factors = { } NEW_LINE for i in range ( 2 , int ( sqrt ( P ) + 1 ) ) : NEW_LINE INDENT while ( P % i == 0 ) : NEW_LINE INDENT if i not in prime_factors : NEW_LINE INDENT prime_factors [ i ] = 0 NEW_LINE DEDENT prime_factors [ i ] += 1 NEW_LINE P //= i NEW_LINE DEDENT DEDENT if ( P != 1 ) : NEW_LINE INDENT prime_factors [ P ] += 1 NEW_LINE DEDENT for key , value in prime_factors . items ( ) : NEW_LINE INDENT ans *= pow ( key , value // N ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , P = 3 , 24 NEW_LINE print ( maxGCD ( N , P ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE k , * b = map ( int , input ( ) . split ( ) ) NEW_LINE t = sum ( 1 << i for i in b ) NEW_LINE for i in range ( 1 << k ) : NEW_LINE INDENT tmp = 0 NEW_LINE rs = [ ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if i & ( 1 << j ) != 0 : NEW_LINE INDENT tmp |= 1 << b [ j ] NEW_LINE rs . append ( b [ j ] ) NEW_LINE DEDENT DEDENT print ( str ( tmp ) + " : " , * rs ) NEW_LINE DEDENT
def generateDivisors ( curIndex , curDivisor , arr ) : NEW_LINE INDENT if ( curIndex == len ( arr ) ) : NEW_LINE INDENT print ( curDivisor , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT for i in range ( arr [ curIndex ] [ 0 ] + 1 ) : NEW_LINE INDENT generateDivisors ( curIndex + 1 , curDivisor , arr ) NEW_LINE curDivisor *= arr [ curIndex ] [ 1 ] NEW_LINE DEDENT DEDENT def findDivisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( [ count , i ] ) NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT arr . append ( [ 1 , n ] ) NEW_LINE DEDENT curIndex = 0 NEW_LINE curDivisor = 1 NEW_LINE generateDivisors ( curIndex , curDivisor , arr ) NEW_LINE DEDENT n = 6 NEW_LINE findDivisors ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ 0 for _ in range ( 1000010 ) ] NEW_LINE dp = [ 0 for _ in range ( 1000010 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l [ a ] = b NEW_LINE DEDENT if l [ 0 ] > 0 : NEW_LINE INDENT dp [ 0 ] = 1 NEW_LINE DEDENT mx = 0 NEW_LINE for i in range ( 1 , 1000010 ) : NEW_LINE INDENT if ( l [ i ] == 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( l [ i ] >= i ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - l [ i ] - 1 ] + 1 ; NEW_LINE DEDENT DEDENT if ( dp [ i ] > mx ) : NEW_LINE INDENT mx = dp [ i ] NEW_LINE DEDENT DEDENT print ( n - mx ) NEW_LINE
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT
def convert ( s ) : NEW_LINE INDENT convertStr = " " NEW_LINE l = len ( s ) NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT if i + 1 < l : NEW_LINE INDENT word = s [ i ] NEW_LINE sequenceNum = 1 NEW_LINE j = i + 1 NEW_LINE while j < l : NEW_LINE INDENT if ( word == s [ j ] ) : NEW_LINE INDENT sequenceNum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT convertStr += str ( sequenceNum ) + word NEW_LINE i = i + sequenceNum - 1 NEW_LINE DEDENT else : NEW_LINE INDENT convertStr += "1" + str ( s [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return convertStr NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = convert ( s ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 for _ in range ( 100007 ) ] NEW_LINE ans = 0 NEW_LINE for i in a : NEW_LINE INDENT for j in range ( 2 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if i % j == 0 : NEW_LINE INDENT d [ i ] = max ( d [ i ] , d [ i // j ] + 1 , d [ j ] + 1 ) NEW_LINE DEDENT DEDENT d [ i ] = max ( d [ i ] , 1 ) NEW_LINE for j in range ( 2 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if i % j == 0 : NEW_LINE INDENT d [ i // j ] = d [ i ] NEW_LINE d [ j ] = d [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , d [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def initializeDiffArray ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE D [ 0 ] = A [ 0 ] ; D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT return D NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE D = initializeDiffArray ( A ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) ; NEW_LINE exit . sort ( ) ; NEW_LINE guests_in = 1 ; NEW_LINE max_guests = 1 ; NEW_LINE time = arrl [ 0 ] ; NEW_LINE i = 1 ; NEW_LINE j = 0 ; NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in = guests_in + 1 ; NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in ; NEW_LINE time = arrl [ i ] ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT guests_in = guests_in - 1 ; NEW_LINE j = j + 1 ; NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " , max_guests , " at ▁ time " , time ) NEW_LINE DEDENT arrl = [ 1 , 2 , 10 , 5 , 5 ] ; NEW_LINE exit = [ 4 , 5 , 12 , 9 , 12 ] ; NEW_LINE n = len ( arrl ) ; NEW_LINE findMaxGuests ( arrl , exit , n ) ; NEW_LINE
def lcs ( x , y , pre_lcs , pre_lcs_len ) : NEW_LINE INDENT pm = dict ( ( zip ( ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' , [ 0 ] * 26 ) ) ) NEW_LINE for c in pm : NEW_LINE INDENT for i , xc in enumerate ( x ) : NEW_LINE INDENT if c == xc : NEW_LINE INDENT pm [ c ] |= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT V = ( 1 << len ( x ) ) - 1 NEW_LINE rec = [ ] NEW_LINE for yc in y : NEW_LINE INDENT V = ( ( V + ( V & pm [ yc ] ) ) | ( V & ~ pm [ yc ] ) ) NEW_LINE rec . append ( bin ( V ) [ - len ( x ) : ] ) NEW_LINE DEDENT lcs_len = bin ( V ) [ - len ( x ) : ] . count ( '0' ) NEW_LINE if lcs_len > pre_lcs_len : NEW_LINE INDENT rx = x [ : : - 1 ] NEW_LINE lcs = ' ' NEW_LINE idx = 0 NEW_LINE for v , yc in zip ( rec [ : : - 1 ] , reversed ( y ) ) : NEW_LINE INDENT idx = v . find ( '0' , idx ) NEW_LINE if yc == rx [ idx ] : NEW_LINE INDENT lcs += yc NEW_LINE if len ( lcs ) == lcs_len : NEW_LINE INDENT return ( lcs [ : : - 1 ] , lcs_len ) NEW_LINE DEDENT idx += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT return ( pre_lcs , pre_lcs_len ) NEW_LINE DEDENT DEDENT from sys import stdin NEW_LINE def solve ( ) : NEW_LINE INDENT file_input = stdin NEW_LINE ans_out = [ ] NEW_LINE for s in file_input : NEW_LINE INDENT s = s . rstrip ( ) NEW_LINE if s [ 0 ] == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT s_len = len ( s ) NEW_LINE sep = s_len // 2 NEW_LINE ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , ' ' , 0 ) NEW_LINE while sep > ans_len : NEW_LINE INDENT ans , ans_len = lcs ( s [ : - sep ] , s [ - sep : ] , ans , ans_len ) NEW_LINE sep -= 1 NEW_LINE ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , ans , ans_len ) NEW_LINE DEDENT ans_out . append ( ans ) NEW_LINE DEDENT print ( * ans_out , sep = ' \n ' ) NEW_LINE DEDENT solve ( ) NEW_LINE
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( "1 / " , end = " " ) NEW_LINE print ( calcFunction ( n , r ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( sqrt ( x ) ) ; NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 ; k = 2 ; NEW_LINE isPerfectSquare ( n + k ) ; NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) * N + i for i in range ( N ) ] NEW_LINE A . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT d = ( A [ i ] % N ) % 2 NEW_LINE if d % 2 != i % 2 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt // 2 ) NEW_LINE
def get ( l : list ) -> str : NEW_LINE INDENT l . sort ( ) NEW_LINE for i in l : NEW_LINE INDENT if i + 1 in l and i + 2 in l : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT return " NO " NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = input ( ) . split ( ) NEW_LINE lst = [ int ( x ) for x in lst ] NEW_LINE print ( get ( lst ) ) NEW_LINE DEDENT
import math NEW_LINE def is_sankaku ( v ) : NEW_LINE INDENT x = ( math . sqrt ( 8 * v + 1 ) - 1 ) / 2 NEW_LINE return x == int ( x ) NEW_LINE DEDENT def check ( lst ) : NEW_LINE INDENT for i , v in enumerate ( lst ) : NEW_LINE INDENT if v != i + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT elif i == len ( lst ) - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT while 1 : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if not is_sankaku ( sum ( lst ) ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT result = - 1 NEW_LINE for count in range ( 10000 ) : NEW_LINE INDENT if check ( lst ) : NEW_LINE INDENT result = count NEW_LINE break NEW_LINE DEDENT spam = len ( lst ) NEW_LINE lst = [ x - 1 for x in lst if x - 1 > 0 ] NEW_LINE lst . append ( spam ) NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def accumulate ( s ) : NEW_LINE INDENT acc = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT acc += ord ( s [ i ] ) - 48 ; NEW_LINE DEDENT return acc ; NEW_LINE DEDENT def isDivisible ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE if ( s [ n - 1 ] != '5' and s [ n - 1 ] != '0' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT sum = accumulate ( s ) ; NEW_LINE return ( sum % 3 == 0 ) ; NEW_LINE DEDENT s = "15645746327462384723984023940239" ; NEW_LINE if isDivisible ( s ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT s = "15645746327462384723984023940235" ; NEW_LINE if isDivisible ( s ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT def find_sum ( limit ) : NEW_LINE INDENT for a in itertools . count ( 1 ) : NEW_LINE INDENT if a * a >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for b in reversed ( range ( 1 , a ) ) : NEW_LINE INDENT if ( a + b ) % 2 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a + b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE for c in itertools . count ( eulerlib . sqrt ( y ) + 1 ) : NEW_LINE INDENT z = c * c - y NEW_LINE if z >= zlimit : NEW_LINE INDENT break NEW_LINE DEDENT if issquare [ x + z ] and issquare [ x - z ] and issquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT DEDENT DEDENT DEDENT return None NEW_LINE DEDENT sumlimit = 10 NEW_LINE while True : NEW_LINE INDENT issquare = [ False ] * sumlimit NEW_LINE for i in range ( eulerlib . sqrt ( len ( issquare ) - 1 ) + 1 ) : NEW_LINE INDENT issquare [ i * i ] = True NEW_LINE DEDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is not None : NEW_LINE INDENT sum = sumlimit NEW_LINE break NEW_LINE DEDENT sumlimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is None : NEW_LINE INDENT return str ( sumlimit ) NEW_LINE DEDENT sumlimit = sum NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = " " NEW_LINE for l in range ( n - k + 1 ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE for r in range ( l , l + k ) : NEW_LINE INDENT if ( isVowel ( s [ r ] ) == True ) : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT DEDENT ans += ( str ) ( countVowels * countConsonants ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT
import bisect NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return abs ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE T = input ( ) NEW_LINE if S [ 0 ] != T [ 0 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if len ( S ) == len ( T ) : NEW_LINE INDENT if S == T : NEW_LINE INDENT print ( len ( S ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT gcd1 = gcd ( len ( S ) , len ( T ) ) NEW_LINE lcm = len ( S ) * len ( T ) // gcd1 NEW_LINE SS = [ ] NEW_LINE TT = [ ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < N : NEW_LINE INDENT SS . append ( i * lcm // N + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT while j < M : NEW_LINE INDENT TT . append ( j * lcm // M + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT ind = 0 NEW_LINE ind_max = j - 1 NEW_LINE for i , v in enumerate ( SS ) : NEW_LINE INDENT ind = bisect . bisect_left ( TT , v , ind , j ) NEW_LINE if ind == j : NEW_LINE INDENT break NEW_LINE DEDENT if TT [ ind ] == v : NEW_LINE INDENT if S [ i ] == T [ ind ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( lcm ) NEW_LINE
from sys import stdin NEW_LINE input = lambda : stdin . readline ( ) [ : - 1 ] NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE black = [ [ False ] * ( n + 10 ) for i in range ( n + 10 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT x , y = map ( lambda x : int ( x ) + 5 , input ( ) . split ( ) ) NEW_LINE black [ x ] [ y ] = True NEW_LINE for lx in range ( x - 2 , x + 1 ) : NEW_LINE INDENT for ly in range ( y - 2 , y + 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for dx in range ( 3 ) : NEW_LINE INDENT for dy in range ( 3 ) : NEW_LINE INDENT cnt += black [ lx + dx ] [ ly + dy ] NEW_LINE DEDENT DEDENT if cnt == 9 : NEW_LINE INDENT print ( i ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE
import sys , math , os , bisect NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT def grid_length ( n , grid ) : NEW_LINE INDENT L = 0 NEW_LINE for row in grid : NEW_LINE INDENT L = max ( L , max ( [ len ( _ ) for _ in row . split ( '0' ) ] ) ) NEW_LINE DEDENT for c in range ( n ) : NEW_LINE INDENT col = ' ' . join ( [ grid [ r ] [ c ] for r in range ( n ) ] ) NEW_LINE L = max ( L , max ( [ len ( _ ) for _ in col . split ( '0' ) ] ) ) NEW_LINE DEDENT for row in range ( - n , 2 * n ) : NEW_LINE INDENT diag = ' ' . join ( [ grid [ row + c ] [ c ] for c in range ( n ) if 0 <= row + c < n ] ) NEW_LINE L = max ( L , max ( [ len ( _ ) for _ in diag . split ( '0' ) ] ) ) NEW_LINE diag = ' ' . join ( [ grid [ row - c ] [ c ] for c in range ( n ) if 0 <= row - c < n ] ) NEW_LINE L = max ( L , max ( [ len ( _ ) for _ in diag . split ( '0' ) ] ) ) NEW_LINE DEDENT return L NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT grid = [ input ( ) . strip ( ) for _ in range ( n ) ] NEW_LINE print ( grid_length ( n , grid ) ) NEW_LINE DEDENT
import math NEW_LINE def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
from collections import defaultdict NEW_LINE def maxLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT length = 0 NEW_LINE if ( arr [ i ] - 1 ) in um and length < um [ arr [ i ] - 1 ] : NEW_LINE INDENT length = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if arr [ i ] in um and length < um [ arr [ i ] ] : NEW_LINE INDENT length = um [ arr [ i ] ] NEW_LINE DEDENT if ( arr [ i ] + 1 ) in um and length < um [ arr [ i ] + 1 ] : NEW_LINE INDENT length = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = length + 1 NEW_LINE if maxLen < um [ arr [ i ] ] : NEW_LINE INDENT maxLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ length ▁ subsequence ▁ = " , maxLenSub ( arr , n ) ) NEW_LINE DEDENT
arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE def rearrange ( n ) : NEW_LINE INDENT global arr NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = int ( ( n - 1 ) / 2 ) NEW_LINE while ( currIdx > 0 ) : NEW_LINE INDENT count = currIdx NEW_LINE swapIdx = currIdx NEW_LINE while ( count > 0 ) : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE swapIdx = swapIdx + 1 NEW_LINE count = count - 1 NEW_LINE DEDENT currIdx = currIdx - 1 NEW_LINE DEDENT DEDENT n = len ( arr ) NEW_LINE rearrange ( n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT
import sys NEW_LINE from heapq import * NEW_LINE r = sys . stdin . readline NEW_LINE def g ( n , E , S , G ) : NEW_LINE INDENT F = [ 1e7 ] * - ~ n ; F [ S ] = 0 NEW_LINE H = [ ( 0 , S ) ] NEW_LINE while H : NEW_LINE INDENT c , u = heappop ( H ) NEW_LINE if u == G : return c NEW_LINE for f , v in E [ u ] : NEW_LINE INDENT t = c + f NEW_LINE if t < F [ v ] : NEW_LINE INDENT F [ v ] = t NEW_LINE heappush ( H , ( t , v ) ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def s ( ) : NEW_LINE INDENT for e in iter ( r , '0 ▁ 0 \n ' ) : NEW_LINE INDENT n , k = map ( int , e . split ( ) ) NEW_LINE E = [ [ ] for _ in [ 0 ] * - ~ n ] NEW_LINE for _ in [ 0 ] * k : NEW_LINE INDENT f = r ( ) NEW_LINE if '0' == f [ 0 ] : print ( g ( n , E , * map ( int , f [ 2 : ] . split ( ) ) ) ) NEW_LINE else : NEW_LINE INDENT c , d , e = map ( int , f [ 2 : ] . split ( ) ) NEW_LINE E [ c ] += [ ( e , d ) ] ; E [ d ] += [ ( e , c ) ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if ' _ _ main _ _ ' == __name__ : s ( ) NEW_LINE
def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , vowels ) NEW_LINE print ( " Consonant : " , consonant ) NEW_LINE print ( " Digit : " , digit ) NEW_LINE print ( " Special ▁ Character : " , specialChar ) NEW_LINE DEDENT str = " geeks ▁ for ▁ geeks121" NEW_LINE countCharacterType ( str ) NEW_LINE
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT l = 50 NEW_LINE b = 20 NEW_LINE h = 10 NEW_LINE print ( increaseInVol ( l , b , h ) , " % " ) NEW_LINE
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i = i + 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = head . prev NEW_LINE new_node . next = head NEW_LINE head . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last NEW_LINE while ( curr . prev != last ) : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( " Forward ▁ direction : ▁ " , end = " " ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = " ▁ " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( " Backward ▁ direction : ▁ " , end = " " ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = " ▁ " ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print ( " Current ▁ list : " ) NEW_LINE display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print ( " \n Reversed ▁ list : " ) NEW_LINE display ( head ) NEW_LINE DEDENT
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT DIGITS = 100 NEW_LINE MULTIPLIER = 100 ** DIGITS NEW_LINE ans = sum ( sum ( int ( c ) for c in str ( eulerlib . sqrt ( i * MULTIPLIER ) ) [ : DIGITS ] ) for i in range ( 100 ) if eulerlib . sqrt ( i ) ** 2 != i ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Pythagoras " + " ▁ Triplet ▁ exists " ) ; NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = n * n / 4 ; NEW_LINE print ( " Pythagoras ▁ Triplets " + " ▁ exist ▁ i . e . ▁ " , end = " " ) ; NEW_LINE print ( int ( n ) , " ▁ " , int ( var - 1 ) , " ▁ " , int ( var + 1 ) ) ; NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = n * n + 1 ; NEW_LINE print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " , end = " " ) ; NEW_LINE print ( int ( n ) , " ▁ " , int ( var / 2 - 1 ) , " ▁ " , int ( var / 2 ) ) ; NEW_LINE DEDENT DEDENT n = 22 ; NEW_LINE evaluate ( n ) ; NEW_LINE
abx = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def d ( a , b ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return a // b NEW_LINE DEDENT DEDENT a = d ( abx [ 0 ] - 1 , abx [ 2 ] ) NEW_LINE b = d ( abx [ 1 ] , abx [ 2 ] ) NEW_LINE print ( b - a ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 for i in range ( K ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE DEDENT
print ( input ( ) . replace ( " , " , " ▁ " ) ) NEW_LINE
import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE lst = list ( _input ( ) ) NEW_LINE if lst [ 0 ] != lst [ - 1 ] : print ( n - 1 ) NEW_LINE else : NEW_LINE INDENT i = 1 NEW_LINE while i < n and lst [ i ] == lst [ 0 ] : i += 1 NEW_LINE j = n - 2 NEW_LINE while j >= 0 and lst [ j ] == lst [ 0 ] : j -= 1 NEW_LINE print ( max ( n - i - 1 , j ) ) NEW_LINE DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ " + str ( countSubarrays ( arr , n ) ) ) NEW_LINE
SIZE = 26 NEW_LINE def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( " { } " . format ( str_ [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( countGreater ( arr , n , k ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 1 : print ( 2 ** n % 1000000 ) NEW_LINE else : NEW_LINE INDENT dp = [ [ [ 0 ] * ( n + 1 ) for _ in range ( 3 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for y in range ( n ) : NEW_LINE INDENT for x in range ( 3 ) : NEW_LINE INDENT for slide_limit in range ( y + 1 ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT dp [ y + 1 ] [ 0 ] [ slide_limit ] += dp [ y ] [ 0 ] [ slide_limit ] NEW_LINE dp [ y + 1 ] [ 1 ] [ y + 1 ] += dp [ y ] [ 0 ] [ slide_limit ] NEW_LINE dp [ y + 1 ] [ 2 ] [ y + 1 ] += dp [ y ] [ 0 ] [ slide_limit ] * ( y - slide_limit + 1 ) NEW_LINE DEDENT if x == 1 : NEW_LINE INDENT dp [ y + 1 ] [ 0 ] [ y + 1 ] += dp [ y ] [ 1 ] [ slide_limit ] NEW_LINE dp [ y + 1 ] [ 1 ] [ slide_limit ] += dp [ y ] [ 1 ] [ slide_limit ] NEW_LINE dp [ y + 1 ] [ 2 ] [ y + 1 ] += dp [ y ] [ 1 ] [ slide_limit ] NEW_LINE DEDENT if x == 2 : NEW_LINE INDENT dp [ y + 1 ] [ 0 ] [ y + 1 ] += dp [ y ] [ 2 ] [ slide_limit ] * ( y - slide_limit + 1 ) NEW_LINE dp [ y + 1 ] [ 1 ] [ y + 1 ] += dp [ y ] [ 2 ] [ slide_limit ] NEW_LINE dp [ y + 1 ] [ 2 ] [ slide_limit ] += dp [ y ] [ 2 ] [ slide_limit ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ( sum ( [ sum ( line ) for line in dp [ n ] ] ) + sum ( [ dp [ n ] [ 0 ] [ slide_limit ] * ( n - slide_limit ) for slide_limit in range ( n + 1 ) ] ) ) % 1000000 ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = " , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( " b ▁ = " , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c , d = 0 , 10 ** 9 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > c : NEW_LINE INDENT c = a NEW_LINE DEDENT if b < d : NEW_LINE INDENT d = b NEW_LINE DEDENT DEDENT if c <= d : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c - d ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE x = set ( s ) NEW_LINE if ' X ' in x : NEW_LINE INDENT ans . append ( s ) NEW_LINE DEDENT DEDENT ans2 = [ ] NEW_LINE a = zip ( * ans ) NEW_LINE for i in a : NEW_LINE INDENT x = set ( i ) NEW_LINE if ' X ' in x : NEW_LINE INDENT ans2 . append ( i ) NEW_LINE DEDENT DEDENT def f ( ) : NEW_LINE INDENT for i in ans2 : NEW_LINE INDENT if ' . ' in i : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT return " YES " NEW_LINE DEDENT print ( f ( ) ) NEW_LINE
INF = 10 ** 10 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def solve ( A , B , C ) : NEW_LINE INDENT A = A [ : : - 1 ] NEW_LINE B = B [ : : - 1 ] NEW_LINE C = C [ : : - 1 ] NEW_LINE before = [ 1 , 0 , 0 ] NEW_LINE N = len ( A ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp = [ 0 ] * 3 NEW_LINE s = 0 NEW_LINE if i == N - 1 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT for j in range ( 3 ) : NEW_LINE INDENT for a in range ( s , 10 ) : NEW_LINE INDENT if A [ i ] != ' ? ' and int ( A [ i ] ) != a : NEW_LINE INDENT continue NEW_LINE DEDENT for b in range ( s , 10 ) : NEW_LINE INDENT if B [ i ] != ' ? ' and int ( B [ i ] ) != b : NEW_LINE INDENT continue NEW_LINE DEDENT for c in range ( s , 10 ) : NEW_LINE INDENT if C [ i ] != ' ? ' and int ( C [ i ] ) != c : NEW_LINE INDENT continue NEW_LINE DEDENT if ( j + a + b ) % 10 != c : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ ( j + a + b ) // 10 ] += before [ j ] NEW_LINE dp [ ( j + a + b ) // 10 ] %= MOD NEW_LINE DEDENT DEDENT DEDENT DEDENT before = dp NEW_LINE DEDENT ans = before [ 0 ] NEW_LINE print ( ans ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT A = input ( ) NEW_LINE if A == '0' : NEW_LINE INDENT return NEW_LINE DEDENT B = input ( ) NEW_LINE C = input ( ) NEW_LINE solve ( A , B , C ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT test = int ( input ( ) ) NEW_LINE move = 0 NEW_LINE while test != 1 : NEW_LINE INDENT if test % 6 == 0 : NEW_LINE INDENT test = test / 6 NEW_LINE move += 1 NEW_LINE DEDENT elif test % 3 == 0 : NEW_LINE INDENT test = test * 2 NEW_LINE move += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( move ) NEW_LINE DEDENT DEDENT
import collections NEW_LINE def minIncrementForUnique ( A ) : NEW_LINE INDENT count = collections . Counter ( A ) NEW_LINE taken = [ ] NEW_LINE ans = 0 NEW_LINE for x in range ( 100000 ) : NEW_LINE INDENT if count [ x ] >= 2 : NEW_LINE INDENT taken . extend ( [ x ] * ( count [ x ] - 1 ) ) NEW_LINE DEDENT elif taken and count [ x ] == 0 : NEW_LINE INDENT ans += x - taken . pop ( ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 3 , 2 , 1 , 2 , 1 , 7 ] NEW_LINE print ( minIncrementForUnique ( A ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE n -= 1 NEW_LINE if n < 0 : NEW_LINE INDENT n = 0 NEW_LINE DEDENT print ( ( 3 ** ( n ) ) % 1000003 ) NEW_LINE
import numpy as np NEW_LINE MOD = ( int ) ( 1e9 + 7 ) NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 13 ) ) ; NEW_LINE dp [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j ; NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 ; NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; NEW_LINE dp [ i + 1 ] [ rem ] %= MOD ; NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ? 44" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( modulo_13 ( s , n ) ) ; NEW_LINE DEDENT
from math import gcd NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // c ; NEW_LINE y = b // d - ( a - 1 ) // d ; NEW_LINE k = ( c * d ) // gcd ( c , d ) ; NEW_LINE z = b // k - ( a - 1 ) // k ; NEW_LINE return ( b - a + 1 - x - y + z ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 ; b = 50 ; c = 4 ; d = 6 ; NEW_LINE print ( countNums ( a , b , c , d ) ) ; NEW_LINE DEDENT
import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 123 ; NEW_LINE printSubstrings ( n ) ; NEW_LINE DEDENT
def NthCharacter ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( c < 10 ) : NEW_LINE INDENT s += chr ( 48 + c ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " NEW_LINE dup = c NEW_LINE while ( dup > 0 ) : NEW_LINE INDENT s1 += chr ( ( dup % 10 ) + 48 ) NEW_LINE dup //= 10 NEW_LINE DEDENT s1 = " " . join ( reversed ( s1 ) ) NEW_LINE s += s1 NEW_LINE DEDENT c += 1 NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE print ( NthCharacter ( n ) ) NEW_LINE DEDENT
def days ( y , m , d ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , y ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT cnt += 200 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 195 NEW_LINE DEDENT DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT if y % 3 == 0 : NEW_LINE INDENT cnt += 20 NEW_LINE DEDENT else : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT cnt += 19 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 20 NEW_LINE DEDENT DEDENT DEDENT cnt += d - 1 NEW_LINE return cnt NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT y , m , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( days ( 1000 , 1 , 1 ) - days ( y , m , d ) ) NEW_LINE DEDENT
def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimeFrequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = { } NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT mp . setdefault ( s [ i ] , 0 ) NEW_LINE mp [ s [ i ] ] += 1 NEW_LINE DEDENT for i in mp . keys ( ) : NEW_LINE INDENT if ( check_prime ( mp [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE print ( countPrimeFrequent ( s ) ) NEW_LINE
from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( a ) and j < len ( b ) : NEW_LINE INDENT if a [ i ] <= b [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( len ( a ) - i ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 for i in range ( n + 1 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = fractions . Fraction ( 15499 , 94744 ) NEW_LINE totient = 1 NEW_LINE denominator = 1 NEW_LINE p = 2 NEW_LINE while True : NEW_LINE INDENT totient *= p - 1 NEW_LINE denominator *= p NEW_LINE while True : NEW_LINE INDENT p += 1 NEW_LINE if eulerlib . is_prime ( p ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if fractions . Fraction ( totient , denominator ) < TARGET : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numer = i * totient NEW_LINE denom = i * denominator NEW_LINE if fractions . Fraction ( numer , denom - 1 ) < TARGET : NEW_LINE INDENT return str ( denom ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE path = input ( ) NEW_LINE coord = set ( [ ( 0 , 0 ) ] ) ; temp = ( 0 , 0 ) NEW_LINE for c in path : NEW_LINE INDENT if c == ' L ' : temp = ( temp [ 0 ] , temp [ 1 ] - 1 ) NEW_LINE elif c == ' R ' : temp = ( temp [ 0 ] , temp [ 1 ] + 1 ) NEW_LINE elif c == ' U ' : temp = ( temp [ 0 ] - 1 , temp [ 1 ] ) NEW_LINE else : temp = ( temp [ 0 ] + 1 , temp [ 1 ] ) NEW_LINE if temp in coord : print ( ' BUG ' ) ; exit ( ) NEW_LINE coord . add ( temp ) NEW_LINE DEDENT coord . remove ( ( 0 , 0 ) ) NEW_LINE que = deque ( [ ( 0 , 0 ) ] ) NEW_LINE while que : NEW_LINE INDENT if len ( que ) > 1 : print ( ' BUG ' ) ; exit ( ) NEW_LINE i , j = que . popleft ( ) NEW_LINE for p , q in ( i + 1 , j ) , ( i - 1 , j ) , ( i , j + 1 ) , ( i , j - 1 ) : NEW_LINE INDENT if ( p , q ) in coord : NEW_LINE INDENT coord . remove ( ( p , q ) ) NEW_LINE que += ( p , q ) , NEW_LINE DEDENT DEDENT DEDENT print ( ' OK ' ) NEW_LINE
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( n ) : NEW_LINE INDENT if isPrime ( n ) and isPrime ( n - 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 13 NEW_LINE if isPossible ( n ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " , str ( int ( countDyckPaths ( n ) ) ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n <= 30 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE if ( n == 40 or n == 36 or n == 44 ) : NEW_LINE INDENT print ( "6 ▁ 10 ▁ 15 ▁ " , n - 31 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "6 ▁ 10 ▁ 14" , n - 30 ) NEW_LINE DEDENT DEDENT DEDENT
from fractions import gcd NEW_LINE from functools import reduce NEW_LINE def solve ( string ) : NEW_LINE INDENT n , * a = map ( int , string . split ( ) ) NEW_LINE return str ( reduce ( gcd , a ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( solve ( " \n " . join ( [ input ( ) , input ( ) ] ) ) ) NEW_LINE DEDENT
import copy NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , 14 ) : NEW_LINE INDENT x = copy . copy ( a ) NEW_LINE n = a [ i ] // 14 NEW_LINE r = a [ i ] % 14 NEW_LINE x [ i ] = 0 NEW_LINE for j in range ( 0 , 14 ) : NEW_LINE INDENT x [ j ] += n NEW_LINE DEDENT if r >= 13 - i : NEW_LINE INDENT for j in range ( i + 1 , 14 ) : NEW_LINE INDENT x [ j ] += 1 NEW_LINE DEDENT for j in range ( 0 , r - 13 + i ) : NEW_LINE INDENT x [ j ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( i + 1 , i + 1 + r ) : NEW_LINE INDENT x [ j ] += 1 NEW_LINE DEDENT DEDENT summ = 0 NEW_LINE for j in x : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT summ += j NEW_LINE DEDENT DEDENT ans = max ( ans , summ ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE DEDENT
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT d = 1.73 * a ; NEW_LINE return d ; NEW_LINE DEDENT a = 9 ; NEW_LINE print ( hexDiagonal ( a ) ) ; NEW_LINE
def translate ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j += 2 NEW_LINE st [ i ] = ' C ' NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j == l - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE DEDENT st [ i ] = ' ▁ ' NEW_LINE st [ l - 1 ] = ' ▁ ' NEW_LINE DEDENT st = list ( " helloABworldABGfG " ) NEW_LINE translate ( st ) NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) NEW_LINE print ( ' ' . join ( st ) ) NEW_LINE
def translate ( st ) : NEW_LINE INDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( st [ i - 1 ] == ' A ' and st [ i ] == ' B ' ) : NEW_LINE INDENT st [ i - 1 ] = ' C ' NEW_LINE for j in range ( i , len ( st ) - 1 ) : NEW_LINE INDENT st [ j ] = st [ j + 1 ] NEW_LINE DEDENT st [ len ( st ) - 1 ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT st = list ( " helloABworldABGfG " ) NEW_LINE translate ( st ) NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) NEW_LINE print ( ' ' . join ( st ) ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 2000 NEW_LINE count = 2 NEW_LINE for ring in itertools . count ( 2 ) : NEW_LINE INDENT if all ( map ( eulerlib . is_prime , ( ring * 6 - 1 , ring * 6 + 1 , ring * 12 + 5 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if all ( map ( eulerlib . is_prime , ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = min ( n , m ) NEW_LINE li = [ ] NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT x1 = pow ( i , 2 ) NEW_LINE for j in range ( x + 1 ) : NEW_LINE INDENT y1 = pow ( j , 2 ) NEW_LINE if ( x1 + j == n and i + y1 == m ) : NEW_LINE INDENT li . append ( ( i , j ) ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( li ) ) NEW_LINE
def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while ( n ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT n = 2346 NEW_LINE Digits ( n ) NEW_LINE
def solve ( d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , max ( d2 , d3 ) ) NEW_LINE sum = ( d1 + d2 + d3 ) NEW_LINE if ( 2 * maxx > sum or sum % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = d1 NEW_LINE y2 = 0 NEW_LINE x3 = ( d1 + d2 - d3 ) // 2 NEW_LINE y3 = ( d2 + d3 - d1 ) // 2 NEW_LINE print ( " ( " , x1 , " , " , y1 , " ) , ▁ ( " , x2 , " , " , y2 , " ) ▁ and ▁ ( " , x3 , " , " , y3 , " ) " ) NEW_LINE DEDENT d1 = 3 NEW_LINE d2 = 4 NEW_LINE d3 = 5 NEW_LINE solve ( d1 , d2 , d3 ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def distributingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 6 , 3 NEW_LINE string = " aacaab " NEW_LINE if ( distributingBalls ( k , n , string ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE ctr = 0 NEW_LINE for i in S : NEW_LINE INDENT if i == ' T ' : NEW_LINE INDENT ctr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ctr -= 1 NEW_LINE DEDENT if ctr > N // 3 or ctr < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' YES ' if ctr == N // 3 else ' NO ' ) NEW_LINE DEDENT
e = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e . sort ( ) NEW_LINE frag = True NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT if e [ 0 ] != e [ i ] : NEW_LINE INDENT frag = False NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 5 , 8 ) : NEW_LINE INDENT if e [ 4 ] != e [ i ] : NEW_LINE INDENT frag = False NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 9 , 12 ) : NEW_LINE INDENT if e [ 8 ] != e [ i ] : NEW_LINE INDENT frag = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( " yes " if frag else " no " ) NEW_LINE
import sys NEW_LINE R = 4 NEW_LINE C = 4 NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 ; NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] == 0 ) and arr [ mid ] == 1 ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( arr [ mid ] == 0 ) : NEW_LINE INDENT return first ( arr , ( mid + 1 ) , high ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr , low , ( mid - 1 ) ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT def rowWith0s ( mat ) : NEW_LINE INDENT row_index = 0 ; max = - ( sys . maxsize - 1 ) ; NEW_LINE min_row_index = 0 ; min = sys . maxsize ; NEW_LINE for i in range ( R ) : NEW_LINE INDENT index = first ( mat [ i ] , 0 , C - 1 ) ; NEW_LINE cntZeroes = 0 ; NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT cntZeroes = C ; NEW_LINE DEDENT else : NEW_LINE INDENT cntZeroes = index ; NEW_LINE DEDENT if ( max < cntZeroes ) : NEW_LINE INDENT max = cntZeroes ; NEW_LINE max_row_index = i ; NEW_LINE DEDENT if ( min > cntZeroes ) : NEW_LINE INDENT min = cntZeroes ; NEW_LINE min_row_index = i ; NEW_LINE DEDENT DEDENT print ( " Row ▁ with ▁ min ▁ 0s : " , min_row_index + 1 ) ; NEW_LINE print ( " Row ▁ with ▁ max ▁ 0s : " , max_row_index + 1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 ] ] ; NEW_LINE rowWith0s ( mat ) ; NEW_LINE DEDENT
import math NEW_LINE def bitAtGivenPosSetOrUnset ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( bitAtGivenPosSetOrUnset ( n , k ) ) : NEW_LINE INDENT print ( " Set " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unset " ) NEW_LINE DEDENT
n = int ( input ( ' ' ) ) NEW_LINE s = list ( input ( ' ' ) ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT k = n // 4 NEW_LINE a = s . count ( ' A ' ) NEW_LINE b = s . count ( ' G ' ) NEW_LINE c = s . count ( ' C ' ) NEW_LINE d = s . count ( ' T ' ) NEW_LINE if a > k or b > k or c > k or d > k : NEW_LINE INDENT print ( ' = = = ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( k - a ) : NEW_LINE INDENT s [ s . index ( ' ? ' ) ] = ' A ' NEW_LINE DEDENT for j in range ( k - b ) : NEW_LINE INDENT s [ s . index ( ' ? ' ) ] = ' G ' NEW_LINE DEDENT for m in range ( k - c ) : NEW_LINE INDENT s [ s . index ( ' ? ' ) ] = ' C ' NEW_LINE DEDENT for t in range ( k - d ) : NEW_LINE INDENT s [ s . index ( ' ? ' ) ] = ' T ' NEW_LINE DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' = = = ' ) NEW_LINE DEDENT
mv = ( ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE t1 , t2 , t3 = input ( ) . split ( ) NEW_LINE s , t , b = ord ( t1 ) - ord ( ' A ' ) , ord ( t2 ) - ord ( ' A ' ) , ord ( t3 ) - ord ( ' A ' ) NEW_LINE f = [ [ [ 0.0 for a in range ( 3 ) ] for c in range ( 3 ) ] for r in range ( 17 ) ] NEW_LINE f [ 0 ] [ s // 3 ] [ s % 3 ] = 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for r in range ( 3 ) : NEW_LINE INDENT for c in range ( 3 ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT r2 , c2 = r + mv [ i ] [ 0 ] , c + mv [ i ] [ 1 ] NEW_LINE if r2 < 0 or r2 >= 3 or c2 < 0 or c2 >= 3 or 3 * r2 + c2 == b : NEW_LINE INDENT r2 , c2 = r , c NEW_LINE DEDENT f [ j ] [ r2 ] [ c2 ] += f [ j - 1 ] [ r ] [ c ] / 4 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( f [ n ] [ t // 3 ] [ t % 3 ] ) NEW_LINE DEDENT
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE result = set ( ) NEW_LINE for x in range ( 31 ) : NEW_LINE INDENT for y in range ( 20 ) : NEW_LINE INDENT v = 2 ** x * 3 ** y NEW_LINE if l <= v <= r : NEW_LINE INDENT result . add ( v ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( result ) ) NEW_LINE
N , K = map ( int , open ( 0 ) ) ; L = 1 NEW_LINE for i in range ( N ) : L += min ( L , K ) NEW_LINE print ( L ) NEW_LINE
def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 , sum2 , mul1 , mul2 = 0 , 0 , 1 , 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if arePermutations ( a , b , n , m ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT present [ i ] = 0 NEW_LINE DEDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( 0 , l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " characters " NEW_LINE str2 = " alphabets " NEW_LINE findAndPrintUncommonChars ( str1 , str2 ) NEW_LINE DEDENT
def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT x = 1 ; NEW_LINE y = 1 ; NEW_LINE circle_x = 0 ; NEW_LINE circle_y = 1 ; NEW_LINE rad = 2 ; NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( " Inside " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) ; NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT Sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return Sum NEW_LINE DEDENT sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) NEW_LINE return min ( Sum , sumAfterOperation ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT nth = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT n = 5 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25000000 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT def run ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE tail = Node ( None ) NEW_LINE node = tail NEW_LINE for _ in range ( n ) : NEW_LINE INDENT command = input ( ) NEW_LINE if command . startswith ( '0' ) : NEW_LINE INDENT nn = Node ( int ( command [ 2 : ] ) ) NEW_LINE nn . prev , nn . next = node . prev , node NEW_LINE if node . prev is not None : NEW_LINE INDENT node . prev . next = nn NEW_LINE DEDENT node . prev = nn NEW_LINE node = node . prev NEW_LINE DEDENT elif command . startswith ( '1' ) : NEW_LINE INDENT i = int ( command [ 2 : ] ) NEW_LINE if i > 0 : NEW_LINE INDENT for _ in range ( i ) : NEW_LINE INDENT node = node . next NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for _ in range ( - i ) : NEW_LINE INDENT node = node . prev NEW_LINE DEDENT DEDENT DEDENT elif command . startswith ( '2' ) : NEW_LINE INDENT p , n = node . prev , node . next NEW_LINE node . prev , node . next = None , None NEW_LINE node = n NEW_LINE if p is None : NEW_LINE INDENT n . prev = None NEW_LINE DEDENT else : NEW_LINE INDENT n . prev , p . next = p , n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT raise ValueError ( ' invalid ▁ command ' ) NEW_LINE DEDENT DEDENT st = [ ] NEW_LINE node = tail . prev NEW_LINE while node is not None : NEW_LINE INDENT st . append ( node . value ) NEW_LINE node = node . prev NEW_LINE DEDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st . pop ( ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT run ( ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . rstrip ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE common = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a = s [ n - 1 - i : ] NEW_LINE b = s [ : i + 1 ] NEW_LINE if ( a == b ) : NEW_LINE INDENT common = i + 1 NEW_LINE continue NEW_LINE DEDENT DEDENT ans = ( n ) + ( k - 1 ) * ( n - common ) NEW_LINE final = s NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT final += ( s [ common : ] ) NEW_LINE DEDENT print ( final ) NEW_LINE
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def prInorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT prInorder ( node . left ) NEW_LINE print ( node . data , end = " ▁ " ) NEW_LINE prInorder ( node . right ) NEW_LINE DEDENT def constructBinaryTreeUtil ( pre , preM , preIndex , l , h , size ) : NEW_LINE INDENT if ( preIndex >= size or l > h ) : NEW_LINE INDENT return None , preIndex NEW_LINE DEDENT root = newNode ( pre [ preIndex ] ) NEW_LINE preIndex += 1 NEW_LINE if ( l == h ) : NEW_LINE INDENT return root , preIndex NEW_LINE DEDENT i = 0 NEW_LINE for i in range ( l , h + 1 ) : NEW_LINE INDENT if ( pre [ preIndex ] == preM [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i <= h ) : NEW_LINE INDENT root . left , preIndex = constructBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) NEW_LINE root . right , preIndex = constructBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) NEW_LINE DEDENT return root , preIndex NEW_LINE DEDENT def constructBinaryTree ( root , pre , preMirror , size ) : NEW_LINE INDENT preIndex = 0 NEW_LINE preMIndex = 0 NEW_LINE root , x = constructBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) NEW_LINE prInorder ( root ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT preOrder = [ 1 , 2 , 4 , 5 , 3 , 6 , 7 ] NEW_LINE preOrderMirror = [ 1 , 3 , 7 , 6 , 2 , 5 , 4 ] NEW_LINE size = 7 NEW_LINE root = newNode ( 0 ) NEW_LINE constructBinaryTree ( root , preOrder , preOrderMirror , size ) NEW_LINE DEDENT
no_of_chars = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " this ▁ is ▁ a ▁ test ▁ string " NEW_LINE pat = " tist " NEW_LINE print ( " Smallest ▁ window ▁ is ▁ : ▁ " ) NEW_LINE print ( findSubString ( string , pat ) ) NEW_LINE DEDENT
import math NEW_LINE def tri ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return math . fabs ( ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) / 2 NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 , x , y = map ( float , input ( ) . split ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT abc = tri ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE abp = tri ( x1 , y1 , x2 , y2 , x , y ) NEW_LINE acp = tri ( x1 , y1 , x3 , y3 , x , y ) NEW_LINE bcp = tri ( x2 , y2 , x3 , y3 , x , y ) NEW_LINE x , y = int ( abc * pow ( 10 , 5 ) ) , int ( ( abp + acp + bcp ) * pow ( 10 , 5 ) ) NEW_LINE print ( " YES " if x >= y else " NO " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT x . append ( input ( ) ) NEW_LINE DEDENT if n > m : print ( ' YES ' ) NEW_LINE elif n < m : print ( ' NO ' ) NEW_LINE elif n == m : NEW_LINE INDENT if len ( set ( x ) ) % 2 != 0 : print ( ' YES ' ) NEW_LINE else : print ( ' NO ' ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a // 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE
a = [ 0 ] * 4 NEW_LINE b = [ 0 ] * 2 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE del a [ 0 ] NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT b [ i ] = int ( input ( ) ) NEW_LINE DEDENT b . sort ( ) NEW_LINE del b [ 0 ] NEW_LINE print ( sum ( a ) + sum ( b ) ) NEW_LINE
def result ( n : int , a : list ) -> int : NEW_LINE INDENT valid_min = 15 NEW_LINE if a [ 0 ] > valid_min : NEW_LINE INDENT return valid_min NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= valid_min : NEW_LINE INDENT valid_min = 15 + a [ i ] NEW_LINE DEDENT DEDENT return 90 if valid_min >= 90 else valid_min NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( result ( n , a ) ) NEW_LINE DEDENT
def memo ( index , evenSum , oddSum , tight ) : NEW_LINE INDENT if index == len ( v ) : NEW_LINE INDENT if evenSum > oddSum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 : NEW_LINE INDENT return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] NEW_LINE DEDENT limit = v [ index ] if tight else 9 NEW_LINE ans = 0 NEW_LINE for d in range ( limit + 1 ) : NEW_LINE INDENT currTight = 0 NEW_LINE if d == v [ index ] : NEW_LINE INDENT currTight = tight NEW_LINE DEDENT if d % 2 != 0 : NEW_LINE INDENT ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) NEW_LINE DEDENT DEDENT dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT def countNum ( n ) : NEW_LINE INDENT global dp , v NEW_LINE v . clear ( ) NEW_LINE num = [ ] NEW_LINE while n : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT v . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( 180 ) ] for j in range ( 180 ) ] for k in range ( 18 ) ] NEW_LINE return memo ( 0 , 0 , 0 , 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT dp = [ ] NEW_LINE v = [ ] NEW_LINE L = 2 NEW_LINE R = 10 NEW_LINE print ( countNum ( R ) - countNum ( L - 1 ) ) NEW_LINE DEDENT
lst = [ ] NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT lst += [ list ( map ( int , input ( ) . split ( ) ) ) ] NEW_LINE DEDENT total = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT total += lst [ i ] [ j ] NEW_LINE DEDENT DEDENT total = total // 3 NEW_LINE flag = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT a = lst [ 0 ] [ i % 3 ] + lst [ 1 ] [ ( i + 1 ) % 3 ] + lst [ 2 ] [ ( i + 2 ) % 3 ] NEW_LINE if a != total : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT a = lst [ 0 ] [ 0 ] + lst [ 1 ] [ 2 ] + lst [ 2 ] [ 1 ] NEW_LINE if a != total : NEW_LINE INDENT flag = False NEW_LINE DEDENT a = lst [ 1 ] [ 1 ] + lst [ 0 ] [ 2 ] + lst [ 2 ] [ 0 ] NEW_LINE if a != total : NEW_LINE INDENT flag = False NEW_LINE DEDENT a = lst [ 2 ] [ 2 ] + lst [ 1 ] [ 0 ] + lst [ 0 ] [ 1 ] NEW_LINE if a != total : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE diff = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE arr = [ ] NEW_LINE arr . append ( diff [ 0 ] ) NEW_LINE flag = False NEW_LINE for i in range ( 1 , len ( diff ) ) : NEW_LINE INDENT x = arr [ i - 1 ] + diff [ i ] NEW_LINE y = arr [ i - 1 ] - diff [ i ] NEW_LINE if y >= 0 and x != y : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( x ) NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in arr : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] ; NEW_LINE x = 10 ; NEW_LINE n = len ( arr ) ; NEW_LINE result = search ( arr , n , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index " , result ) ; NEW_LINE DEDENT
N , C = map ( int , input ( ) . split ( ) ) NEW_LINE XV = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE RIGHTSUM = [ 0 ] NEW_LINE for x , v in XV : NEW_LINE INDENT RIGHTSUM . append ( RIGHTSUM [ - 1 ] + v ) NEW_LINE DEDENT LEFTSUM = [ 0 ] NEW_LINE for x , v in XV [ : : - 1 ] : NEW_LINE INDENT LEFTSUM . append ( LEFTSUM [ - 1 ] + v ) NEW_LINE DEDENT RIGHT = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT RIGHT . append ( RIGHTSUM [ i + 1 ] - XV [ i ] [ 0 ] ) NEW_LINE DEDENT LEFT = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT LEFT . append ( LEFTSUM [ i + 1 ] - ( C - XV [ - i - 1 ] [ 0 ] ) ) NEW_LINE DEDENT RIGHTMAX = [ RIGHT [ 0 ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT RIGHTMAX . append ( max ( RIGHTMAX [ i - 1 ] , RIGHT [ i ] ) ) NEW_LINE DEDENT LEFTMAX = [ LEFT [ 0 ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT LEFTMAX . append ( max ( LEFTMAX [ i - 1 ] , LEFT [ i ] ) ) NEW_LINE DEDENT ANS = max ( max ( RIGHT ) , max ( LEFT ) , 0 ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ANS < ( RIGHTSUM [ i + 1 ] - XV [ i ] [ 0 ] * 2 ) + LEFTMAX [ N - i - 2 ] : NEW_LINE INDENT ANS = RIGHTSUM [ i + 1 ] - XV [ i ] [ 0 ] * 2 + LEFTMAX [ N - i - 2 ] NEW_LINE DEDENT if ANS < LEFTSUM [ i + 1 ] - ( C - XV [ - i - 1 ] [ 0 ] ) * 2 + RIGHTMAX [ N - i - 2 ] : NEW_LINE INDENT ANS = LEFTSUM [ i + 1 ] - ( C - XV [ - i - 1 ] [ 0 ] ) * 2 + RIGHTMAX [ N - i - 2 ] NEW_LINE DEDENT DEDENT print ( ANS ) NEW_LINE
def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def unsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 * 8 - 1 ) ) - 1 NEW_LINE num = toggleBitsFromLToR ( num , l , r ) NEW_LINE return ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( unsetBitsInGivenRange ( n , l , r ) ) NEW_LINE
def MinStep ( a , n ) : NEW_LINE INDENT positive = 0 ; NEW_LINE negative = 0 ; NEW_LINE zero = 0 ; NEW_LINE step = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 ; NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 ; NEW_LINE step = step + ( - 1 - a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 ; NEW_LINE step = step + ( a [ i ] - 1 ) ; NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT step = step + zero ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT step = step + zero ; NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 ; NEW_LINE DEDENT DEDENT return step ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , - 2 , - 1 , - 3 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinStep ( a , n ) ) ; NEW_LINE DEDENT
import math NEW_LINE import sys NEW_LINE from collections import deque , OrderedDict , defaultdict NEW_LINE import heapq , re NEW_LINE from collections import Counter NEW_LINE def inp ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def mpp ( ) : return map ( int , inp ( ) . split ( ) ) NEW_LINE def lis ( ) : return list ( mpp ( ) ) NEW_LINE def yn ( n ) : NEW_LINE INDENT if n : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT def cd ( s ) : NEW_LINE INDENT return ord ( s ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT def fn ( s , n , a , b ) : NEW_LINE INDENT if s [ a - 1 ] == s [ b - 1 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n , a , b = mpp ( ) NEW_LINE s = inp ( ) NEW_LINE print ( fn ( s , n , a , b ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) [ : n ] NEW_LINE v . sort ( ) NEW_LINE print ( v [ n - 1 ] + v [ n - 2 ] ) NEW_LINE DEDENT
from math import gcd NEW_LINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) ; NEW_LINE dy = abs ( y2 - y1 ) ; NEW_LINE ans = dx + dy - gcd ( dx , dy ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 = 1 ; y1 = 1 ; x2 = 4 ; y2 = 3 ; NEW_LINE noOfSquares ( x1 , y1 , x2 , y2 ) ; NEW_LINE DEDENT
def get_maximum ( s , a ) : NEW_LINE INDENT s = list ( s ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) NEW_LINE j += 1 NEW_LINE DEDENT return " " . join ( s ) ; NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1337" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print ( get_maximum ( s , a ) ) NEW_LINE DEDENT
MAX_DIGITS = 20 ; NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) >= 8 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( n / 10 ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if ( isOctal ( n ) == False ) else 10 NEW_LINE octal = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal . append ( n % divide ) NEW_LINE n = int ( n / divide ) NEW_LINE DEDENT j = len ( octal ) - 1 NEW_LINE k = 0 NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 97 ; NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
num = int ( input ( ) ) NEW_LINE num = input ( ) NEW_LINE list_is = [ ] NEW_LINE for i in num : NEW_LINE INDENT list_is . append ( int ( i ) ) NEW_LINE DEDENT list_is1 = list_is [ : len ( list_is ) // 2 ] NEW_LINE list_is2 = list_is [ len ( list_is ) // 2 : ] NEW_LINE sum1 = sum ( list_is1 ) NEW_LINE sum2 = sum ( list_is2 ) NEW_LINE condition = False NEW_LINE for i in list_is : NEW_LINE INDENT if i == 4 or i == 7 : NEW_LINE INDENT condition = True NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT condition = False NEW_LINE break NEW_LINE DEDENT DEDENT if condition == True : NEW_LINE INDENT if sum1 == sum2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE midValue = arr [ mid ] NEW_LINE if ( mid == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , midValue ) NEW_LINE left = binarySearch ( arr , low , leftindex ) NEW_LINE if ( left >= 0 ) : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , midValue ) NEW_LINE right = binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Fixed ▁ Point ▁ is " , binarySearch ( arr , 0 , n - 1 ) ) NEW_LINE arr1 = [ - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 ] NEW_LINE n1 = len ( arr ) NEW_LINE print ( " Fixed ▁ Point ▁ is " , binarySearch ( arr1 , 0 , n1 - 1 ) ) NEW_LINE DEDENT
MAX = 10000 ; NEW_LINE prodDig = [ 0 ] * MAX ; NEW_LINE def getDigitProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] ; NEW_LINE DEDENT prod = ( int ( x % 10 ) * getDigitProduct ( int ( x / 10 ) ) ) ; NEW_LINE prodDig [ x ] = prod ; NEW_LINE return prod ; NEW_LINE DEDENT def findSeed ( n ) : NEW_LINE INDENT res = [ ] ; NEW_LINE for i in range ( 1 , int ( n / 2 + 2 ) ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " NO ▁ seed ▁ exists " ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 138 ; NEW_LINE findSeed ( n ) ; NEW_LINE
N , K = map ( int , input ( ) . split ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE answer = 10 ** 18 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT left , right = i , i + K - 1 NEW_LINE al , ar = abs ( X [ left ] ) , abs ( X [ right ] ) NEW_LINE if X [ left ] * X [ right ] >= 0 : NEW_LINE INDENT answer = min ( answer , max ( al , ar ) ) NEW_LINE DEDENT else : NEW_LINE INDENT answer = min ( answer , al * 2 + ar , al + ar * 2 ) NEW_LINE DEDENT DEDENT print ( answer ) NEW_LINE
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( n , mid ) NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( mid * mid * mid ) > n ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE print ( " Cubic ▁ root ▁ of " , n , " is " , round ( cubicRoot ( n ) , 6 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT kmax = max ( a ) + m NEW_LINE while m > 0 : NEW_LINE INDENT a . sort ( ) NEW_LINE m -= 1 NEW_LINE a [ 0 ] += 1 NEW_LINE DEDENT kmin = max ( a ) NEW_LINE print ( kmin , kmax ) NEW_LINE
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 = x1 + m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prod = prod * num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result = result + rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( " x ▁ is ▁ " , findMinX ( num , rem , k ) ) NEW_LINE
def findMaxOR ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE maxOR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( maxOR | arr [ i ] ) > maxOR ) : NEW_LINE INDENT maxOR = maxOR | arr [ i ] ; NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxOR ( arr , n ) ) NEW_LINE DEDENT
def seriessum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriessum ( n ) ) NEW_LINE
def aliquotSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sm = sm + i NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT n = 12 NEW_LINE print ( aliquotSum ( n ) ) NEW_LINE
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE
def fifthPowerSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i * i * i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 6 NEW_LINE print ( fifthPowerSum ( n ) ) NEW_LINE
def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE
def seriessum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriessum ( n ) ) NEW_LINE
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) NEW_LINE DEDENT return summ NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE
import math NEW_LINE def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
from math import floor NEW_LINE def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum = sum + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE N = floor ( n / 2 ) NEW_LINE for base in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT sum = sum + solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT
import math NEW_LINE isPrime = [ True ] * 110001 NEW_LINE primes = [ ] ; NEW_LINE def eratos ( n ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT j = 2 * i NEW_LINE while j <= n : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j = j + i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , 110000 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT DEDENT eratos ( 110000 ) NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT p = int ( input ( ) ) NEW_LINE if p == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , p ) : NEW_LINE INDENT ans += primes [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
print ( bin ( 4 ) . count ( '1' ) ) ; NEW_LINE print ( bin ( 15 ) . count ( '1' ) ) ; NEW_LINE
INT_MAX = 2147483647 NEW_LINE def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 2 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if i >= n or j >= n : NEW_LINE INDENT break NEW_LINE DEDENT cost [ i ] [ j ] = INT_MAX NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT c = 0 NEW_LINE if ( r > i ) : NEW_LINE INDENT c += cost [ i ] [ r - 1 ] NEW_LINE DEDENT if ( r < j ) : NEW_LINE INDENT c += cost [ r + 1 ] [ j ] NEW_LINE DEDENT c += sum ( freq , i , j ) NEW_LINE if ( c < cost [ i ] [ j ] ) : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT def sum ( freq , i , j ) : NEW_LINE INDENT s = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT s += freq [ k ] NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT keys = [ 10 , 12 , 20 ] NEW_LINE freq = [ 34 , 8 , 50 ] NEW_LINE n = len ( keys ) NEW_LINE print ( " Cost ▁ of ▁ Optimal ▁ BST ▁ is " , optimalSearchTree ( keys , freq , n ) ) NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT x = 1 NEW_LINE y = 5 NEW_LINE z = 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] - 1 ] = i NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res += abs ( b [ i ] - b [ i - 1 ] ) NEW_LINE DEDENT print ( res ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def maxcoefficientvalue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n / 2 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , int ( ( n + 1 ) / 2 ) ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; NEW_LINE print ( maxcoefficientvalue ( n ) ) ; NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT s = " abaebio " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT ( W , H ) = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE persimmon = [ [ 0 for j in range ( 100 ) ] for i in range ( 100 ) ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT ( x , y ) = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE persimmon [ x ] [ y ] = 1 NEW_LINE DEDENT cumsum = [ [ 0 for j in range ( 100 ) ] for i in range ( 100 ) ] NEW_LINE for x in range ( 1 , 100 ) : NEW_LINE INDENT for y in range ( 1 , 100 ) : NEW_LINE INDENT cumsum [ x ] [ y ] = cumsum [ x - 1 ] [ y ] + cumsum [ x ] [ y - 1 ] - cumsum [ x - 1 ] [ y - 1 ] + persimmon [ x ] [ y ] NEW_LINE DEDENT DEDENT ( S , T ) = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE max_persimmon = 0 NEW_LINE for x in range ( S , W + 1 ) : NEW_LINE INDENT for y in range ( T , H + 1 ) : NEW_LINE INDENT max_persimmon = max ( max_persimmon , cumsum [ x ] [ y ] + cumsum [ x - S ] [ y - T ] - cumsum [ x ] [ y - T ] - cumsum [ x - S ] [ y ] ) NEW_LINE DEDENT DEDENT print ( max_persimmon ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j + 1 == M : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " for " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Present ▁ at ▁ index ▁ " + str ( res ) ) NEW_LINE DEDENT DEDENT
def angleOncirCumference ( z ) : NEW_LINE INDENT return ( z / 2 ) ; NEW_LINE DEDENT angle = 65 ; NEW_LINE z = angleOncirCumference ( angle ) ; NEW_LINE print ( " The ▁ angle ▁ is " , ( z ) , " degrees " ) ; NEW_LINE
def countSubarraysof1and0 ( a , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE number1 = 0 NEW_LINE number0 = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number1 += ( ( count1 ) * ( count1 + 1 ) / 2 ) NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE count0 = 0 NEW_LINE DEDENT DEDENT if ( count1 ) : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) / 2 NEW_LINE DEDENT if ( count0 ) : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE DEDENT print ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : " , int ( number0 ) ) NEW_LINE print ( " Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : " , int ( number1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countSubarraysof1and0 ( a , n ) NEW_LINE DEDENT
def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT
def printPermutation ( n , k ) : NEW_LINE INDENT mx = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = " ▁ " ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 5 , 3 NEW_LINE if K >= N - 1 : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = [ sum ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE a = l [ 0 ] NEW_LINE l . sort ( reverse = True ) NEW_LINE print ( l . index ( a ) + 1 ) NEW_LINE
def is_member ( List , key ) : NEW_LINE INDENT for i in range ( 0 , len ( List ) ) : NEW_LINE INDENT if key == List [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def overlap ( List1 , List2 ) : NEW_LINE INDENT for key in List1 : NEW_LINE INDENT if is_member ( List2 , key ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = ' geeksforgeeks ' NEW_LINE s2 = ' geeks ' NEW_LINE List1 = list ( s1 ) NEW_LINE List2 = list ( s2 ) NEW_LINE yes_or_no = str ( overlap ( List1 , List2 ) ) NEW_LINE if ( yes_or_no ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if i > t : NEW_LINE INDENT break NEW_LINE DEDENT n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if n * ( a - b ) > ( c + d ) or n * ( a + b ) < ( c - d ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE
N = 3 NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( maxPathSum ( tri , 2 , 2 ) ) NEW_LINE
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if isHeap ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > int ( ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) - 1 NEW_LINE if isHeap ( arr , 0 , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
V = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE P = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT P . append ( ( V [ 0 ] , V [ 1 ] ) ) NEW_LINE V = V [ 2 : ] NEW_LINE DEDENT A , B , C = P NEW_LINE for i in range ( 1 , 3 ) : NEW_LINE INDENT x , y = P [ i ] NEW_LINE x0 , y0 = P [ 0 ] NEW_LINE P [ i ] = x - x0 , y - y0 NEW_LINE DEDENT a , b = P [ 1 ] NEW_LINE c , d = P [ 2 ] NEW_LINE if a * d - b * c == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT def dist ( A , B ) : NEW_LINE INDENT x = A [ 0 ] - B [ 0 ] NEW_LINE y = A [ 1 ] - B [ 1 ] NEW_LINE return x ** 2 + y ** 2 NEW_LINE DEDENT print ( " YES " if dist ( A , B ) == dist ( B , C ) else " NO " ) NEW_LINE
import sys NEW_LINE def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDel ( arr , n ) ) ; NEW_LINE DEDENT
def count ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = dict ( ) NEW_LINE while x % y != 0 : NEW_LINE INDENT x %= y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT res = count ( 1 , 2 ) NEW_LINE print ( " INF " ) if res == - 1 else print ( res ) NEW_LINE res = count ( 5 , 3 ) NEW_LINE print ( " INF " ) if res == - 1 else print ( res ) NEW_LINE res = count ( 3 , 5 ) NEW_LINE print ( " INF " ) if res == - 1 else print ( res ) NEW_LINE DEDENT
def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT arr = [ 40 , 50 , 90 ] ; NEW_LINE n = 3 NEW_LINE if ( isPossibleToMakeDivisible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE graph = [ [ ] for _ in range ( N ) ] NEW_LINE Par = [ - 1 ] * N NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if a != 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT continue NEW_LINE DEDENT Par [ i ] = a - 1 NEW_LINE graph [ a - 1 ] . append ( i ) NEW_LINE DEDENT qs = [ ] NEW_LINE stack = [ 0 ] NEW_LINE Depth = [ - 1 ] * N NEW_LINE Depth [ 0 ] = 0 NEW_LINE while stack : NEW_LINE INDENT p = stack . pop ( ) NEW_LINE for np in graph [ p ] : NEW_LINE INDENT Depth [ np ] = Depth [ p ] + 1 NEW_LINE stack . append ( np ) NEW_LINE DEDENT qs . append ( ( Depth [ p ] , p ) ) NEW_LINE DEDENT qs . sort ( reverse = True ) NEW_LINE checked = [ False ] * N NEW_LINE for d , s in qs : NEW_LINE INDENT if d <= K : break NEW_LINE if checked [ s ] : continue NEW_LINE for _ in range ( K - 1 ) : NEW_LINE INDENT s = Par [ s ] NEW_LINE DEDENT que = [ s ] NEW_LINE checked [ s ] = True NEW_LINE while que : NEW_LINE INDENT qq = [ ] NEW_LINE for p in que : NEW_LINE INDENT for np in graph [ p ] : NEW_LINE INDENT if not checked [ np ] : NEW_LINE INDENT checked [ np ] = True NEW_LINE qq . append ( np ) NEW_LINE DEDENT DEDENT DEDENT que = qq NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( j ** 3 , i + 1 ) : NEW_LINE INDENT if ( j ** 3 == i ) : NEW_LINE INDENT print ( j ** 3 , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT a = 1 ; b = 100 NEW_LINE print ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : ▁ " ) NEW_LINE printCubes ( a , b ) NEW_LINE
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( n , " moduo " , d , " is " , getModulo ( n , d ) ) NEW_LINE
try : NEW_LINE INDENT N , d = map ( int , input ( ) . split ( ) ) NEW_LINE nums = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE nums . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if abs ( nums [ i ] - nums [ j ] ) <= d : NEW_LINE INDENT ans = max ( ans , j - i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( N - ans ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT a = ord ( s [ - 1 ] ) - ord ( ' a ' ) NEW_LINE n = int ( s [ : - 1 ] ) NEW_LINE od = [ 4 , 5 , 6 , 3 , 2 , 1 ] NEW_LINE ad = [ 0 , 7 , 0 , 7 ] NEW_LINE c = 16 NEW_LINE ktmp = ( n - 1 ) // 4 NEW_LINE ttmp = ( n - 1 ) % 4 NEW_LINE ans = ktmp * 16 + ad [ ttmp ] + od [ a ] NEW_LINE return ans NEW_LINE DEDENT s = input ( ) NEW_LINE print ( solve ( s ) ) NEW_LINE
def isPerfectCube ( x ) : NEW_LINE INDENT cr = int ( x ** ( 1 / 3 ) ) ; NEW_LINE return ( cr * cr * cr == x ) ; NEW_LINE DEDENT def canBePerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 ; K = 1 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 5 ; K = 4 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 7 ; K = 2 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE test = s + t NEW_LINE if ( s == t ) : NEW_LINE INDENT print ( len ( s ) ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) [ : : - 1 ] : NEW_LINE INDENT test = s [ 0 : - i ] + t NEW_LINE if ( test [ : n ] == s and test [ - n : ] == t ) : NEW_LINE INDENT print ( len ( test ) ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT print ( len ( s + t ) ) NEW_LINE
from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def DFSUtil ( self , v , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( v , end = ' ▁ ' ) NEW_LINE for i in self . graph [ v ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT self . DFSUtil ( i , visited ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited = [ False ] * ( max ( self . graph ) + 1 ) NEW_LINE self . DFSUtil ( v , visited ) NEW_LINE DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . DFS ( 2 ) NEW_LINE
import math NEW_LINE def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ int ( digit ) ] += 1 NEW_LINE val = val // 10 NEW_LINE DEDENT return ; NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq_count = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = math . pow ( x , i ) NEW_LINE countDigits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = " NO " NEW_LINE a . sort ( reverse = True ) NEW_LINE while a and not a [ - 1 ] ^ 1 : NEW_LINE INDENT a . pop ( ) NEW_LINE DEDENT a . reverse ( ) NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT if 2 * a [ i ] > a [ i + 1 ] and a [ i ] ^ a [ i + 1 ] : NEW_LINE INDENT ans = " YES " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE print ( max ( 0 , N - 2 ) ) NEW_LINE DEDENT
a = input ; print ( " IO ▁ hb , e ▁ cmoym ▁ ek ▁ etyhbeo ▁ agrudy ! . " [ int ( a ( ) ) > len ( set ( a ( ) . split ( ) [ 1 : ] + a ( ) . split ( ) [ 1 : ] ) ) : : 2 ] ) NEW_LINE
m , n = 6 , 4 ; NEW_LINE def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( linearCheck ( mat , row ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE while n : NEW_LINE INDENT p = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE s = sum ( l ) NEW_LINE if s % p == 0 : NEW_LINE INDENT for i in range ( p ) : NEW_LINE INDENT if l [ i ] > s // p : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE time = 0 NEW_LINE sum_t = sum ( t ) NEW_LINE velo_cap = [ float ( " inf " ) ] * ( 2 * sum_t + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT start_t = time NEW_LINE goal_t = time + 2 * t [ i ] NEW_LINE for s in range ( 0 , 2 * sum_t + 1 ) : NEW_LINE INDENT if s < start_t : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] + ( start_t - s ) ) NEW_LINE DEDENT elif s < goal_t : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] + ( s - goal_t ) ) NEW_LINE DEDENT DEDENT time += 2 * t [ i ] NEW_LINE DEDENT for s in range ( 2 * sum_t + 1 ) : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * sum_t - s , s ) NEW_LINE DEDENT print ( sum ( velo_cap ) / 4 - ( velo_cap [ 0 ] + velo_cap [ - 1 ] ) / 8 ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
from math import * NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
from math import * NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) - 2 * n + 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE c = abs ( x ) + abs ( y ) NEW_LINE if x > 0 and y > 0 : NEW_LINE INDENT print ( 0 , c , c , 0 ) NEW_LINE DEDENT if x < 0 and y > 0 : NEW_LINE INDENT print ( - c , 0 , 0 , c ) NEW_LINE DEDENT if x > 0 and y < 0 : NEW_LINE INDENT print ( 0 , - c , c , 0 ) NEW_LINE DEDENT if x < 0 and y < 0 : NEW_LINE INDENT print ( - c , 0 , 0 , - c ) NEW_LINE DEDENT
s = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE l = len ( s ) NEW_LINE substr = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT for k in range ( K ) : NEW_LINE INDENT substr . append ( s [ i : i + k + 1 ] ) NEW_LINE if i + k + 1 >= l : break NEW_LINE DEDENT DEDENT substr = list ( set ( substr ) ) NEW_LINE substr . sort ( ) NEW_LINE print ( substr [ K - 1 ] ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . memo = [ ] NEW_LINE self . memo . append ( 0 ) NEW_LINE self . memo . append ( 1 ) NEW_LINE DEDENT def fib ( self , N ) : NEW_LINE INDENT if N < len ( self . memo ) : NEW_LINE INDENT return self . memo [ N ] NEW_LINE DEDENT for i in range ( len ( self . memo ) , N + 1 ) : NEW_LINE INDENT self . memo . append ( self . memo [ i - 1 ] + self . memo [ i - 2 ] ) NEW_LINE DEDENT return self . memo [ N ] NEW_LINE DEDENT DEDENT  if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 2 NEW_LINE out = sObj . fib ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
import io , os , sys NEW_LINE from collections import Counter NEW_LINE t = int ( input ( ) ) NEW_LINE def GO_LIFE ( ) : NEW_LINE INDENT a = list ( input ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE p = Counter ( a ) NEW_LINE n = len ( a ) NEW_LINE ok = 0 NEW_LINE for i in b : NEW_LINE INDENT if p [ i ] == 0 : NEW_LINE INDENT ok = 1 NEW_LINE DEDENT DEDENT if b != sorted ( b ) or ok == 1 : NEW_LINE INDENT for i in sorted ( a ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT a . sort ( ) NEW_LINE q1 = [ ] NEW_LINE q2 = [ ] NEW_LINE q = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == ' c ' : NEW_LINE INDENT q += [ i ] NEW_LINE DEDENT if a [ i ] == ' b ' : NEW_LINE INDENT q1 . insert ( 0 , i ) NEW_LINE DEDENT DEDENT i , j = 0 , 0 NEW_LINE while j < len ( q1 ) and i < len ( q ) : NEW_LINE INDENT a [ q [ i ] ] , a [ q1 [ j ] ] = a [ q1 [ j ] ] , a [ q [ i ] ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in a : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT while t > 0 : NEW_LINE INDENT GO_LIFE ( ) NEW_LINE t -= 1 NEW_LINE DEDENT
PI = 3.142 ; NEW_LINE def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) ; NEW_LINE res = 1 ; NEW_LINE sign = 1 ; NEW_LINE fact = 1 ; NEW_LINE pow = 1 ; NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 ; NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; NEW_LINE pow = pow * x * x ; NEW_LINE res = res + sign * pow / fact ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT x = 50 ; NEW_LINE n = 5 ; NEW_LINE print ( round ( cosXSertiesSum ( x , 5 ) , 6 ) ) ; NEW_LINE
def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = int ( i ) ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( " Yes : " , integerI , " , " , integerI + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT
def multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE sum = dig0 + dig1 NEW_LINE if ( K == 2 ) : NEW_LINE INDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum += temp NEW_LINE numberofGroups = ( K - 3 ) // 4 NEW_LINE remNumberofDigits = ( K - 3 ) % 4 NEW_LINE sum += ( numberofGroups * 20 ) NEW_LINE for i in range ( remNumberofDigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT K = 5 NEW_LINE dig0 = 3 NEW_LINE dig1 = 4 NEW_LINE if ( multipleOfThree ( K , dig0 , dig1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE total = sum ( a ) NEW_LINE b . sort ( ) NEW_LINE print ( ' YES ' if total <= b [ - 1 ] + b [ - 2 ] else ' NO ' ) NEW_LINE
def countOcc ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 0 , len ( s ) - 3 ) : NEW_LINE INDENT c , l , a , p = 0 , 0 , 0 , 0 NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT if s [ j ] == ' c ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif s [ j ] == ' l ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif s [ j ] == ' a ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif s [ j ] == ' p ' : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT if c == 1 and l == 1 and a == 1 and p == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " clapc " NEW_LINE print ( countOcc ( s . lower ( ) ) ) NEW_LINE DEDENT
import math NEW_LINE def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return math . floor ( x / y ) ; NEW_LINE DEDENT return math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; NEW_LINE DEDENT x = 100 ; NEW_LINE y = 19 ; NEW_LINE print ( countSteps ( x , y ) ) ; NEW_LINE
import math as mt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = mt . sqrt ( x ) NEW_LINE return ( ( sr - mt . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSunnyNum ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 3 NEW_LINE if ( isSunnyNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) NEW_LINE DEDENT P = 3 NEW_LINE B = 4 NEW_LINE H = 5 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE d = { } NEW_LINE for _ in [ 0 ] * n : NEW_LINE INDENT k , v = input ( ) . strip ( ) . split ( ) NEW_LINE d [ k ] = v NEW_LINE DEDENT for _ in [ 0 ] * int ( input ( ) ) : NEW_LINE INDENT e = input ( ) . strip ( ) NEW_LINE print ( d [ e ] if e in d else e , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
from bisect import bisect as upper_bound NEW_LINE def getCount ( v , n ) : NEW_LINE INDENT v = sorted ( v ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upper_bound ( v , v [ i ] - 1 ) NEW_LINE if ( tmp == v [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT n = 4 NEW_LINE v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE v . append ( 3 ) NEW_LINE v . append ( 4 ) NEW_LINE print ( getCount ( v , n ) ) NEW_LINE
def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val /= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val /= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 106 NEW_LINE if ( isEqual ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
m = 1000000007 NEW_LINE from sys import stdin NEW_LINE f_i = stdin NEW_LINE N = int ( f_i . readline ( ) ) NEW_LINE n_type = [ ' ' ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = f_i . readline ( ) . rstrip ( ) NEW_LINE n_type [ i ] = t NEW_LINE DEDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT s , t = map ( int , f_i . readline ( ) . split ( ) ) NEW_LINE s -= 1 NEW_LINE t -= 1 NEW_LINE adj [ s ] . append ( t ) NEW_LINE DEDENT from itertools import combinations NEW_LINE def prod ( nums ) : NEW_LINE INDENT p = 1 NEW_LINE for n in nums : NEW_LINE INDENT p *= n NEW_LINE DEDENT return p NEW_LINE DEDENT import sys NEW_LINE sys . setrecursionlimit ( 4000 ) NEW_LINE def dfs ( node ) : NEW_LINE INDENT nt = n_type [ node ] NEW_LINE chld = adj [ node ] NEW_LINE if nt == ' E ' : NEW_LINE INDENT if chld : NEW_LINE INDENT return prod ( map ( dfs , chld ) ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT elif nt == ' E ? ' : NEW_LINE INDENT if chld : NEW_LINE INDENT return ( prod ( map ( dfs , chld ) ) + 1 ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT elif nt == ' A ' : NEW_LINE INDENT return sum ( map ( dfs , chld ) ) % m NEW_LINE DEDENT elif nt == ' A ? ' : NEW_LINE INDENT return ( sum ( map ( dfs , chld ) ) + 1 ) % m NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE c_s = tuple ( map ( dfs , chld ) ) NEW_LINE for i in range ( 1 , len ( chld ) + 1 ) : NEW_LINE INDENT for vals in combinations ( c_s , i ) : NEW_LINE INDENT cnt += prod ( vals ) NEW_LINE DEDENT DEDENT if len ( nt ) == 1 : NEW_LINE INDENT return cnt % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt + 1 ) % m NEW_LINE DEDENT DEDENT DEDENT print ( dfs ( 0 ) ) NEW_LINE
n = int ( input ( ' ' ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( l [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT x = abs ( l [ 0 ] - l [ 1 ] ) NEW_LINE m1 , m2 = min ( l ) , max ( l ) NEW_LINE print ( ( m1 + m2 ) // 2 ) NEW_LINE DEDENT
x = list ( input ( ) . split ( ) ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT x [ i ] = int ( x [ i ] ) NEW_LINE DEDENT a = x [ 0 ] NEW_LINE b = x [ 1 ] NEW_LINE print ( min ( x ) , end = " ▁ " ) NEW_LINE if abs ( a - b ) >= 2 : NEW_LINE INDENT print ( abs ( a - b ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE q = n // m NEW_LINE r = n % m NEW_LINE a = [ q ] * m NEW_LINE for i in range ( r ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeks " ; NEW_LINE s2 = " forgeeks " ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT
def countSubSeq ( i , Sum , cnt , a , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( Sum == 0 and cnt > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , Sum , cnt , a , n ) NEW_LINE ans += countSubSeq ( i + 1 , Sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT a = [ - 1 , 2 , - 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubSeq ( 0 , 0 , 0 , a , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE in_str = input ( ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT index = int ( n // 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = int ( n // 2 ) NEW_LINE DEDENT def func ( in_str , index , n ) : NEW_LINE INDENT j = 0 NEW_LINE in_list = [ i for i in in_str ] NEW_LINE out_list = [ None ] * n NEW_LINE while ( len ( in_list ) > 0 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT out_list [ index ] = in_list [ 0 ] NEW_LINE in_list . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT if ( index - j >= 0 ) : NEW_LINE INDENT out_list [ index - j ] = in_list [ 0 ] NEW_LINE in_list . pop ( 0 ) NEW_LINE DEDENT if ( index + j < n ) : NEW_LINE INDENT out_list [ index + j ] = in_list [ 0 ] NEW_LINE in_list . pop ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( index + j < n ) : NEW_LINE INDENT out_list [ index + j ] = in_list [ 0 ] NEW_LINE in_list . pop ( 0 ) NEW_LINE DEDENT if ( index - j >= 0 ) : NEW_LINE INDENT out_list [ index - j ] = in_list [ 0 ] NEW_LINE in_list . pop ( 0 ) NEW_LINE DEDENT DEDENT DEDENT j += 1 NEW_LINE DEDENT return out_list NEW_LINE DEDENT out_str = func ( in_str , index , n ) NEW_LINE print ( * out_str , sep = " " ) NEW_LINE
a , n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE check_list = [ ] NEW_LINE i = 0 NEW_LINE if a == 0 : i = 1 NEW_LINE while ( i + a ) ** n < m : NEW_LINE INDENT check_list . append ( ( i + a ) ** n ) NEW_LINE i += 1 NEW_LINE DEDENT for x in check_list : NEW_LINE INDENT xl = [ int ( i ) for i in list ( str ( x ) ) ] NEW_LINE y = sum ( xl ) NEW_LINE if x == ( y + a ) ** n : count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE
def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) ; NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) ; NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) ; NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ; NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) ; NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( " Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ " , pivotedBinarySearch ( arr1 , n , key ) ) NEW_LINE
n = int ( input ( ) ) + 1 NEW_LINE d = 1000000007 NEW_LINE g = [ [ 1 ] * n for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT g [ i ] [ 0 ] = g [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i + 1 ) : g [ i ] [ j ] = ( g [ i ] [ j - 1 ] + g [ i - 1 ] [ j - 1 ] ) % d NEW_LINE DEDENT print ( ( g [ - 1 ] [ - 1 ] - g [ - 1 ] [ 0 ] ) % d ) NEW_LINE
from sys import stdin NEW_LINE from collections import defaultdict , deque NEW_LINE answer = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = sorted ( a ) NEW_LINE d = { x : i for i , x in enumerate ( a ) } NEW_LINE visited = [ 0 ] * n NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT seq = [ i ] NEW_LINE visited [ i ] = 1 NEW_LINE hold = a [ i ] NEW_LINE while hold != b [ seq [ - 1 ] ] : NEW_LINE INDENT z = d [ b [ seq [ - 1 ] ] ] NEW_LINE visited [ z ] = 1 NEW_LINE seq . append ( z ) NEW_LINE DEDENT answer . append ( ' ▁ ' . join ( map ( str , [ len ( seq ) ] + [ x + 1 for x in seq ] ) ) ) NEW_LINE DEDENT print ( len ( answer ) ) NEW_LINE print ( ' \n ' . join ( answer ) ) NEW_LINE
vector = ( ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ) NEW_LINE def make_guruguru ( d ) : NEW_LINE INDENT lst = [ [ " # " ] * ( d + 4 ) ] NEW_LINE for _ in range ( d + 2 ) : NEW_LINE INDENT lst . append ( [ " # " ] + [ " ▁ " ] * ( d + 2 ) + [ " # " ] ) NEW_LINE DEDENT lst . append ( [ " # " ] * ( d + 4 ) ) NEW_LINE x , y = 2 , d + 1 NEW_LINE lst [ y ] [ x ] = " # " NEW_LINE direct = 0 NEW_LINE vx , vy = vector [ 0 ] NEW_LINE cnt = 1 NEW_LINE while True : NEW_LINE INDENT while lst [ y + vy * 2 ] [ x + vx * 2 ] == " ▁ " : NEW_LINE INDENT lst [ y + vy ] [ x + vx ] = " # " NEW_LINE y += vy NEW_LINE x += vx NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt <= 1 : NEW_LINE INDENT break NEW_LINE DEDENT direct = ( direct + 1 ) % 4 NEW_LINE vx , vy = vector [ direct ] NEW_LINE cnt = 0 NEW_LINE DEDENT for y in range ( 2 , d + 2 ) : NEW_LINE INDENT print ( " " . join ( lst [ y ] [ 2 : - 2 ] ) ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE make_guruguru ( int ( input ( ) ) ) NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT print ( ) NEW_LINE make_guruguru ( int ( input ( ) ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 << 10 ) for j in range ( i , 1 << 10 ) if eulerlib . popcount ( i ) == eulerlib . popcount ( j ) == 6 and is_arrangement_valid ( i , j ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_arrangement_valid ( a , b ) : NEW_LINE INDENT if test_bit ( a , 6 ) or test_bit ( a , 9 ) : NEW_LINE INDENT a |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT if test_bit ( b , 6 ) or test_bit ( b , 9 ) : NEW_LINE INDENT b |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT return all ( ( ( test_bit ( a , c ) and test_bit ( b , d ) ) or ( test_bit ( a , d ) and test_bit ( b , c ) ) ) for ( c , d ) in SQUARES ) NEW_LINE DEDENT def test_bit ( x , i ) : NEW_LINE INDENT return ( ( x >> i ) & 1 ) != 0 NEW_LINE DEDENT SQUARES = [ ( i ** 2 // 10 , i ** 2 % 10 ) for i in range ( 1 , 10 ) ] NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT info = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for j in info [ 2 : ] : NEW_LINE INDENT a [ i ] [ j - 1 ] = 1 NEW_LINE DEDENT DEDENT for v in a : NEW_LINE INDENT print ( * v ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = [ i for i in input ( ) ] NEW_LINE a . append ( x ) NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( m - 1 ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT x = set ( [ a [ i ] [ j ] , a [ i + 1 ] [ j ] , a [ i ] [ j + 1 ] , a [ i + 1 ] [ j + 1 ] ] ) NEW_LINE if x == { ' a ' , ' f ' , ' c ' , ' e ' } : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE
from typing import List , Tuple NEW_LINE from collections import defaultdict , deque , namedtuple NEW_LINE from heapq import heappush as push , heappop as pop NEW_LINE import sys NEW_LINE INF = ( int ) ( 1e9 + 7 ) NEW_LINE sys . setrecursionlimit ( INF ) NEW_LINE def alternatingCurrent ( wires ) : NEW_LINE INDENT stk = [ ] NEW_LINE for upperWire in wires : NEW_LINE INDENT if stk and stk [ - 1 ] == upperWire : NEW_LINE INDENT stk . pop ( ) NEW_LINE continue NEW_LINE DEDENT stk . append ( upperWire ) NEW_LINE DEDENT if stk : NEW_LINE INDENT return ' No ' NEW_LINE DEDENT return ' Yes ' NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT wires = input ( ) NEW_LINE print ( alternatingCurrent ( wires ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import deque NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE class BipartiteMatching : NEW_LINE INDENT def __init__ ( self , n , m ) : NEW_LINE INDENT self . n = n NEW_LINE self . m = m NEW_LINE self . edges = [ set ( ) for _ in range ( n ) ] NEW_LINE self . match1 = [ - 1 ] * n NEW_LINE self . match2 = [ - 1 ] * m NEW_LINE DEDENT def dfs ( self , v , visited ) : NEW_LINE INDENT for u in self . edges [ v ] : NEW_LINE INDENT if u in visited : NEW_LINE INDENT continue NEW_LINE DEDENT visited . add ( u ) NEW_LINE if self . match2 [ u ] == - 1 or self . dfs ( self . match2 [ u ] , visited ) : NEW_LINE INDENT self . match2 [ u ] = v NEW_LINE self . match1 [ v ] = u NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def add ( self , a , b ) : NEW_LINE INDENT self . edges [ a ] . add ( b ) NEW_LINE DEDENT def whois1 ( self , a ) : NEW_LINE INDENT return self . match1 [ a ] NEW_LINE DEDENT def whois2 ( self , a ) : NEW_LINE INDENT return self . match2 [ a ] NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT return sum ( self . dfs ( i , set ( ) ) for i in range ( self . n ) ) NEW_LINE DEDENT DEDENT N , M , E = MAP ( ) NEW_LINE bm = BipartiteMatching ( N , M ) NEW_LINE for i in range ( E ) : NEW_LINE INDENT x , y = MAP ( ) NEW_LINE bm . add ( x , y ) NEW_LINE DEDENT print ( bm . solve ( ) ) NEW_LINE
MAX = 100 NEW_LINE def countMountains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for i in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( ( i == 0 ) or ( j == 0 ) or ( i == n + 1 ) or ( j == n + 1 ) ) : NEW_LINE INDENT A [ i ] [ j ] = float ( ' - inf ' ) NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE n = 3 NEW_LINE print ( countMountains ( a , n ) ) NEW_LINE
from math import sqrt ; NEW_LINE N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ input ( ) for i in range ( n ) ] NEW_LINE a = [ 0 ] * m NEW_LINE num = 1 NEW_LINE def alloc ( x ) : NEW_LINE INDENT global num NEW_LINE x = int ( x . split ( ) [ 1 ] ) NEW_LINE for i in range ( m - x + 1 ) : NEW_LINE INDENT if a [ i : i + x ] == [ 0 ] * x : NEW_LINE INDENT a [ i : i + x ] = [ num ] * x NEW_LINE print ( num ) NEW_LINE num += 1 NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NULL ' ) NEW_LINE DEDENT def erase ( x ) : NEW_LINE INDENT x = int ( x . split ( ) [ 1 ] ) NEW_LINE if x not in a or x < 1 : NEW_LINE INDENT print ( ' ILLEGAL _ ERASE _ ARGUMENT ' ) NEW_LINE DEDENT for i , j in enumerate ( a ) : NEW_LINE INDENT if j == x : NEW_LINE INDENT a [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT def defragment ( x ) : NEW_LINE INDENT global a NEW_LINE a = [ i for i in a if i != 0 ] NEW_LINE a += [ 0 ] * ( m - len ( a ) ) NEW_LINE DEDENT f = { ' alloc ' : alloc , ' erase ' : erase , ' defragment ' : defragment } NEW_LINE for i in s : NEW_LINE INDENT f [ i . split ( ) [ 0 ] ] ( i ) NEW_LINE DEDENT
import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) ; NEW_LINE A = len / ( 2 * math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) ) NEW_LINE
MAX = 256 ; NEW_LINE def lastNonRepeating ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = string [ i ] ; NEW_LINE if ( freq [ ord ( ch ) ] == 1 ) : NEW_LINE INDENT return ( " " + ch ) ; NEW_LINE DEDENT DEDENT return " - 1" ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksForGeeks " ; NEW_LINE n = len ( string ) ; NEW_LINE print ( lastNonRepeating ( string , n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE minx = 1000000000 NEW_LINE maxy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE minx = min ( minx , x ) NEW_LINE maxy = max ( maxy , y ) NEW_LINE a . append ( [ x , y ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == minx and a [ i ] [ 1 ] == maxy : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT def BooleRule ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = ( ( b - a ) / n ) NEW_LINE sum = 0 NEW_LINE bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT lowlimit = 0 NEW_LINE upplimit = 4 NEW_LINE print ( " f ( x ) ▁ = " , round ( BooleRule ( 0 , 4 ) , 4 ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 256 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 3 ; NEW_LINE ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) ; NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 3 ; NEW_LINE ans = findLen ( arr , 0 , 0 , n , m ) ; NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT
while 1 : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE R = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE def dfs_max ( cur , pre ) : NEW_LINE INDENT _max = - R [ cur ] [ pre ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if R [ cur ] [ i ] > 0 and i != pre : NEW_LINE INDENT _max = max ( _max , dfs_max ( i , cur ) + R [ cur ] [ i ] ) NEW_LINE DEDENT DEDENT return _max NEW_LINE DEDENT total = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a , b , t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE R [ a ] [ b ] = t NEW_LINE R [ b ] [ a ] = t NEW_LINE total += ( t * 2 ) NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT spam = [ x for x in R [ i ] if x > 0 ] NEW_LINE if ( len ( spam ) <= 1 ) : NEW_LINE INDENT total -= ( spam [ 0 ] * 2 ) NEW_LINE DEDENT DEDENT print ( ( total - dfs_max ( 1 , 0 ) ) ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE def aaa ( n ) : NEW_LINE INDENT if int ( n ) > N : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 if set ( str ( int ( n ) ) ) == { '7' , '5' , '3' } else 0 NEW_LINE for i in '753' : NEW_LINE INDENT ans += aaa ( n + i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( aaa ( '0' ) ) NEW_LINE
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minDiff ( arr , n , k ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE def load_balls ( ) : NEW_LINE INDENT LINE_NUM , TOTAL = 0 , 0 NEW_LINE balls = [ ] NEW_LINE i = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT line = line . strip ( ) NEW_LINE LINE_NUM += 1 NEW_LINE if LINE_NUM == 1 : NEW_LINE INDENT TOTAL = int ( line . strip ( ) ) NEW_LINE continue NEW_LINE DEDENT balls . append ( [ int ( i ) for i in line . split ( " ▁ " ) ] ) NEW_LINE if LINE_NUM == TOTAL + 1 : break NEW_LINE DEDENT return balls NEW_LINE DEDENT class VesselClass : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . tmp = [ ] NEW_LINE self . left = [ 0 ] NEW_LINE self . right = [ 0 ] NEW_LINE DEDENT def fill ( self , balls : list ) : NEW_LINE INDENT self . tmp = balls NEW_LINE DEDENT def DFS ( self ) : NEW_LINE INDENT if len ( self . tmp ) == 0 : print ( " YES " ) NEW_LINE elif self . left [ - 1 ] < self . tmp [ 0 ] : NEW_LINE INDENT self . left . append ( self . tmp [ 0 ] ) NEW_LINE self . tmp . pop ( 0 ) NEW_LINE self . DFS ( ) NEW_LINE DEDENT elif self . right [ - 1 ] < self . tmp [ 0 ] : NEW_LINE INDENT self . right . append ( self . tmp [ 0 ] ) NEW_LINE self . tmp . pop ( 0 ) NEW_LINE self . DFS ( ) NEW_LINE DEDENT else : print ( " NO " ) NEW_LINE DEDENT DEDENT balls_list = load_balls ( ) NEW_LINE for balls in balls_list : NEW_LINE INDENT Vessel = VesselClass ( ) NEW_LINE Vessel . fill ( balls ) NEW_LINE Vessel . DFS ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE def solve ( x ) : NEW_LINE INDENT y = 0 NEW_LINE j = 1 NEW_LINE while y < x : NEW_LINE INDENT y += j NEW_LINE if y == x : NEW_LINE INDENT return ( j ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if y - x == 1 : NEW_LINE INDENT return ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( j - 1 ) NEW_LINE DEDENT DEDENT for i in range ( t ) : NEW_LINE INDENT i = int ( input ( ) ) NEW_LINE print ( solve ( i ) ) NEW_LINE DEDENT
def Mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm // n NEW_LINE DEDENT def meanAbsoluteDeviation ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsoluteDeviation ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE primes = eulerlib . list_primes ( 100 ) NEW_LINE def count ( primeindex , product ) : NEW_LINE INDENT if primeindex == len ( primes ) : NEW_LINE INDENT return 1 if product <= LIMIT else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE while product <= LIMIT : NEW_LINE INDENT result += count ( primeindex + 1 , product ) NEW_LINE product *= primes [ primeindex ] NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT return str ( count ( 0 , 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( int ( math . log2 ( r ) ) , - 1 , - 1 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) : NEW_LINE INDENT if ( x > r ) or ( x + ( 1 << i ) - 1 < l ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x ^ ( 1 << i ) ) <= r : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT n = 7 NEW_LINE l = 2 NEW_LINE r = 23 NEW_LINE print ( " The ▁ output ▁ is " , maximumXOR ( n , l , r ) ) NEW_LINE
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ True ] * ( N + 5 ) ; NEW_LINE i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE
def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ 2 : ] NEW_LINE bit = bit [ : : - 1 ] NEW_LINE zero = 0 ; NEW_LINE for i in range ( len ( bit ) ) : NEW_LINE INDENT if ( bit [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE case_1 = a + b + c NEW_LINE case_2 = a + a + b + b NEW_LINE case_3 = a + c + c + a NEW_LINE case_4 = b + c + c + b NEW_LINE print ( min ( case_1 , case_2 , case_3 , case_4 ) ) NEW_LINE
for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE result = 0 NEW_LINE c = 0 NEW_LINE while c < n - 1 : NEW_LINE INDENT if p [ c ] > p [ c + 1 ] : NEW_LINE INDENT result += 1 NEW_LINE c += 1 NEW_LINE DEDENT c += 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE s = ' ' NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - 97 NEW_LINE sum = sum + ord ( Q [ pos ] ) - 48 NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT P = " abcde " NEW_LINE Q = "12345678912345678912345678" NEW_LINE K = 5 NEW_LINE N = len ( P ) NEW_LINE print ( distinctSubstring ( P , Q , K , N ) ) NEW_LINE
import sys NEW_LINE def makeEven ( arr , n ) : NEW_LINE INDENT first_e_i = - 1 NEW_LINE last_e_i = - 1 NEW_LINE last_n_i = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( int ( arr [ i ] ) % 2 == 0 and int ( arr [ i ] ) < int ( arr [ last_n_i ] ) ) : NEW_LINE INDENT first_e_i = i NEW_LINE break NEW_LINE DEDENT if int ( arr [ i ] ) % 2 == 0 : NEW_LINE INDENT last_e_i = i NEW_LINE DEDENT DEDENT if first_e_i != - 1 : NEW_LINE INDENT ( arr [ first_e_i ] , arr [ last_n_i ] ) = ( arr [ last_n_i ] , arr [ first_e_i ] ) NEW_LINE return arr NEW_LINE DEDENT if first_e_i == - 1 and last_e_i != - 1 : NEW_LINE INDENT ( arr [ last_e_i ] , arr [ last_n_i ] ) = ( arr [ last_n_i ] , arr [ last_e_i ] ) NEW_LINE return arr NEW_LINE DEDENT return arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = "1356425" NEW_LINE result = " " . join ( makeEven ( list ( string ) , len ( list ( string ) ) ) ) NEW_LINE print ( result ) NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if j * i <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE findDivisors ( n ) NEW_LINE DEDENT
a = input ( ) NEW_LINE b = input ( ) NEW_LINE numOf0 = [ 0 for i in range ( len ( b ) + 1 ) ] NEW_LINE numOf1 = [ 0 for i in range ( len ( b ) + 1 ) ] NEW_LINE r = 0 NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT numOf0 [ i ] = numOf0 [ i - 1 ] + ( b [ i ] == '0' ) NEW_LINE numOf1 [ i ] = numOf1 [ i - 1 ] + ( b [ i ] == '1' ) NEW_LINE DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT r += ( numOf1 [ len ( b ) - len ( a ) + i ] - numOf1 [ i - 1 ] ) if a [ i ] == '0' else ( numOf0 [ len ( b ) - len ( a ) + i ] - numOf0 [ i - 1 ] ) NEW_LINE DEDENT print ( r ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def printDistinct ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE index = [ n for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ord ( Str [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 and x != ' ▁ ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index = sorted ( index ) NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if index [ i ] == n : NEW_LINE INDENT break NEW_LINE DEDENT print ( Str [ index [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT Str = " GeeksforGeeks " NEW_LINE printDistinct ( Str ) NEW_LINE
import math NEW_LINE def calculate ( x , k , m ) : NEW_LINE INDENT result = x ; NEW_LINE k = k - 1 ; NEW_LINE while ( k ) : NEW_LINE INDENT result = math . pow ( result , x ) ; NEW_LINE if ( result > m ) : NEW_LINE INDENT result = result % m ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE DEDENT return int ( result ) ; NEW_LINE DEDENT x = 5 ; NEW_LINE k = 2 ; NEW_LINE m = 3 ; NEW_LINE print ( calculate ( x , k , m ) ) ; NEW_LINE
def converthenumber ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE res = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT res += s [ i ] ; NEW_LINE DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 18720 ; NEW_LINE converthenumber ( n ) ; NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for a in range ( 26 ) : NEW_LINE INDENT c = chr ( a + ord ( ' a ' ) ) NEW_LINE if c not in s : NEW_LINE INDENT print ( c ) NEW_LINE return NEW_LINE DEDENT DEDENT for a in range ( 26 ) : NEW_LINE INDENT c1 = chr ( a + ord ( ' a ' ) ) NEW_LINE for b in range ( 26 ) : NEW_LINE INDENT c2 = chr ( b + ord ( ' a ' ) ) NEW_LINE c = c1 + c2 NEW_LINE if c not in s : NEW_LINE INDENT print ( c ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT for a in range ( 26 ) : NEW_LINE INDENT c1 = chr ( a + ord ( ' a ' ) ) NEW_LINE for b in range ( 26 ) : NEW_LINE INDENT c2 = chr ( b + ord ( ' a ' ) ) NEW_LINE c4 = c1 + c2 NEW_LINE for d in range ( 26 ) : NEW_LINE INDENT c3 = chr ( d + ord ( ' a ' ) ) NEW_LINE c = c4 + c3 NEW_LINE if c not in s : NEW_LINE INDENT print ( c ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT t = int ( input ( ) ) NEW_LINE while t != 0 : NEW_LINE INDENT t -= 1 NEW_LINE solve ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) ; l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = set ( l ) NEW_LINE l1 = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : l1 . append ( max ( i , len ( a ) ) ) NEW_LINE print ( * l1 ) NEW_LINE DEDENT
def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE rowmajorSum = sn ( n , an ) ; NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ list ( input ( ) ) for _ in range ( h ) ] NEW_LINE ans = 0 NEW_LINE ci = [ 0 for _ in range ( w ) ] NEW_LINE for i in range ( h - 1 , - 1 , - 1 ) : NEW_LINE INDENT co = 0 NEW_LINE for j in range ( w - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] [ j ] == ' J ' : NEW_LINE INDENT ans += co * ci [ j ] NEW_LINE DEDENT elif s [ i ] [ j ] == ' O ' : NEW_LINE INDENT co += 1 NEW_LINE DEDENT elif s [ i ] [ j ] == ' I ' : NEW_LINE INDENT ci [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( n // i ) % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( ( i * i == n ) and ( i % k == 0 ) ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 12 , 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = chr ( 48 + X ) * N NEW_LINE res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N // 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N // 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE print ( findModuloByM ( X , N , M ) ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even_p = [ x for x in p if x % 2 == 0 ] NEW_LINE odd_p = [ x for x in p if x % 2 != 0 ] NEW_LINE even_q = [ x for x in q if x % 2 == 0 ] NEW_LINE odd_q = [ x for x in q if x % 2 != 0 ] NEW_LINE print ( len ( even_q ) * len ( even_p ) + len ( odd_q ) * len ( odd_p ) ) NEW_LINE DEDENT
import sys NEW_LINE def findMaxDiff ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT min_val = sys . maxsize NEW_LINE max_val = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] - i ) > max_val ) : NEW_LINE INDENT max_val = a [ i ] - i NEW_LINE DEDENT if ( ( a [ i ] - i ) < min_val ) : NEW_LINE INDENT min_val = a [ i ] - i NEW_LINE DEDENT DEDENT return ( max_val - min_val ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE h = ' # ' NEW_LINE f = [ [ h ] * ( n + 2 ) ] NEW_LINE a = f + [ [ * ( h + input ( ) + h ) ] for _ in [ 0 ] * n ] + f * 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i + 1 ] [ j + 1 ] > h : NEW_LINE INDENT for k , l in ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , 2 ) , ( 3 , 1 ) : NEW_LINE INDENT if a [ i + k ] [ j + l ] == h : print ( ' NO ' ) ; exit ( ) NEW_LINE a [ i + k ] [ j + l ] = h NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' YES ' ) NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT m = 3 NEW_LINE n = 3 NEW_LINE print ( numberOfPaths ( m , n ) ) NEW_LINE
m = int ( input ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if ( s % n == 0 ) : NEW_LINE INDENT if ( s // n in a ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) & 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) | n ) NEW_LINE DEDENT def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return allBitsAreSet ( num ) NEW_LINE DEDENT def bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT if ( isKthBitSet ( n , r ) ) : NEW_LINE INDENT num = n NEW_LINE left_shift = r NEW_LINE DEDENT else : NEW_LINE INDENT num = setKthBit ( n , ( r + 1 ) ) NEW_LINE left_shift = r + 1 NEW_LINE DEDENT num = num & ( ( 1 << left_shift ) - 1 ) NEW_LINE num = num >> ( l - 1 ) NEW_LINE return bitsAreInAltOrder ( num ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * factorial ( n - 1 ) ; NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ) ; NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return ( nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ) ; NEW_LINE DEDENT n , x , y = 5 , 4 , 2 ; NEW_LINE print ( int ( NumberOfWays ( n , x , y ) ) ) ; NEW_LINE
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE result = " " NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geek " , " geezer " ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT
from statistics import median NEW_LINE from fractions import gcd NEW_LINE from itertools import combinations NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE import bisect NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10000000 ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def readInts ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A = readInts ( ) NEW_LINE A = sorted ( A ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( A ) - 2 , len ( A ) - 2 * n - 1 , - 2 ) : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE A . append ( a ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT now = 0 NEW_LINE nex = A [ 0 ] NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nex = A [ nex - 1 ] NEW_LINE count += 1 NEW_LINE DEDENT if nex == 2 : NEW_LINE INDENT print ( count ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE
def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT a , b = b , a + b NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( " Element " , i , " occurs " , freq [ i ] , " times " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 7 - 1 ) NEW_LINE minnumer = 1 NEW_LINE mindenom = 0 NEW_LINE for ( i , tot ) in enumerate ( totients [ 2 : ] , 2 ) : NEW_LINE INDENT if i * mindenom < minnumer * tot and sorted ( str ( i ) ) == sorted ( str ( tot ) ) : NEW_LINE INDENT minnumer = i NEW_LINE mindenom = totients [ i ] NEW_LINE DEDENT DEDENT return str ( minnumer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE DEDENT
import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum += m . log ( a [ i ] ) NEW_LINE DEDENT x = m . exp ( _sum / n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE
from math import gcd NEW_LINE def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT lcm = int ( ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectSq = int ( lcm ) NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm /= 2 NEW_LINE DEDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT minPerfectSq *= 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm /= i NEW_LINE DEDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT minPerfectSq *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectSq NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectSquare ( arr , n ) ) NEW_LINE DEDENT
def subarrayCount ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE fast , slow = 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT fast += 1 NEW_LINE DEDENT else : NEW_LINE INDENT length = fast - slow + 1 NEW_LINE result += length * ( length - 1 ) // 2 ; NEW_LINE fast = i NEW_LINE slow = i NEW_LINE DEDENT DEDENT if ( fast != slow ) : NEW_LINE INDENT length = fast - slow + 1 NEW_LINE result += length * ( length - 1 ) // 2 ; NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subarrayCount ( arr , n ) ) NEW_LINE DEDENT
ans = [ ] NEW_LINE def solve ( n ) : NEW_LINE INDENT f = s = 0 NEW_LINE fs = True NEW_LINE if n & 1 : NEW_LINE INDENT n -= 1 NEW_LINE fs = False NEW_LINE DEDENT while n : NEW_LINE INDENT if n == 4 : NEW_LINE INDENT f += 3 NEW_LINE s += 1 NEW_LINE n = 0 NEW_LINE DEDENT elif ( n // 2 ) & 1 : NEW_LINE INDENT f += n // 2 NEW_LINE s += 1 NEW_LINE n = ( n // 2 ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT f += 1 NEW_LINE s += 1 NEW_LINE n -= 2 NEW_LINE DEDENT DEDENT ans . append ( [ s + 1 , f ] [ fs ] ) NEW_LINE DEDENT coins = [ ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT coins . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in coins : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT solve ( i ) NEW_LINE DEDENT DEDENT print ( ' \n ' . join ( map ( str , ans ) ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( a ) , max ( a ) , sum ( a ) ) NEW_LINE
from collections import defaultdict NEW_LINE MAX_CHARS = 256 NEW_LINE def findSubString ( strr ) : NEW_LINE INDENT n = len ( strr ) NEW_LINE if n <= 1 : NEW_LINE INDENT return strr NEW_LINE DEDENT dist_count = len ( set ( [ x for x in strr ] ) ) NEW_LINE curr_count = defaultdict ( lambda : 0 ) NEW_LINE count = 0 NEW_LINE start = 0 NEW_LINE min_len = n NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ strr [ j ] ] += 1 NEW_LINE if curr_count [ strr [ j ] ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist_count : NEW_LINE INDENT while curr_count [ strr [ start ] ] > 1 : NEW_LINE INDENT if curr_count [ strr [ start ] ] > 1 : NEW_LINE INDENT curr_count [ strr [ start ] ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str ( strr [ start_index : start_index + min_len ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Smallest ▁ window ▁ containing ▁ " " all ▁ distinct ▁ characters ▁ is : ▁ { } " . format ( findSubString ( " aabcbcdbca " ) ) ) NEW_LINE DEDENT
def concentration ( water , suger ) : NEW_LINE INDENT return 100 * suger / ( water + suger ) NEW_LINE DEDENT WATER_A , WATER_B , SUGER_C , SUGER_D , MELT_PER_100 , LIMIT = map ( int , input ( ) . split ( ) ) NEW_LINE WATER_A *= 100 NEW_LINE WATER_B *= 100 NEW_LINE MELT_PERCENT_LIMIT = concentration ( 100 , MELT_PER_100 ) NEW_LINE wa = wb = sc = sd = 0 NEW_LINE water_set = set ( ) NEW_LINE while wa * WATER_A <= LIMIT : NEW_LINE INDENT while wb * WATER_B <= LIMIT : NEW_LINE INDENT water = wa * WATER_A + wb * WATER_B NEW_LINE if water <= LIMIT : NEW_LINE INDENT water_set . add ( water ) NEW_LINE DEDENT wb += 1 NEW_LINE DEDENT wb = 0 NEW_LINE wa += 1 NEW_LINE DEDENT suger_set = set ( ) NEW_LINE while sc * SUGER_C <= LIMIT : NEW_LINE INDENT while sd * SUGER_D <= LIMIT : NEW_LINE INDENT suger = sc * SUGER_C + sd * SUGER_D NEW_LINE if suger <= LIMIT : NEW_LINE INDENT suger_set . add ( suger ) NEW_LINE DEDENT sd += 1 NEW_LINE DEDENT sd = 0 NEW_LINE sc += 1 NEW_LINE DEDENT ans_suger_water = 0 NEW_LINE ans_suger = 0 NEW_LINE max_concentration = 0 NEW_LINE for water in water_set : NEW_LINE INDENT for suger in suger_set : NEW_LINE INDENT if not ( 0 < water + suger <= LIMIT ) : NEW_LINE INDENT continue NEW_LINE DEDENT suger_precent = concentration ( water , suger ) NEW_LINE if max_concentration <= suger_precent <= MELT_PERCENT_LIMIT : NEW_LINE INDENT max_concentration = suger_precent NEW_LINE ans_suger_water = water + suger NEW_LINE ans_suger = suger NEW_LINE DEDENT DEDENT DEDENT print ( ans_suger_water , ans_suger ) NEW_LINE
import sys NEW_LINE f = sys . stdin NEW_LINE lines = [ list ( map ( int , line . split ( ' , ' ) ) ) for line in f ] NEW_LINE for i in range ( 1 , len ( lines ) // 2 + 1 ) : NEW_LINE INDENT for j in range ( len ( lines [ i ] ) ) : NEW_LINE INDENT lines [ i ] [ j ] += max ( lines [ i - 1 ] [ max ( j - 1 , 0 ) : min ( j + 1 , len ( lines [ i - 1 ] ) ) ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( lines ) // 2 + 1 , len ( lines ) ) : NEW_LINE INDENT for j in range ( len ( lines [ i ] ) ) : NEW_LINE INDENT lines [ i ] [ j ] += max ( lines [ i - 1 ] [ j : j + 2 ] ) NEW_LINE DEDENT DEDENT print ( lines [ - 1 ] [ 0 ] ) NEW_LINE
def countPairs ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT odd_pairs = odd * ( n - 1 ) NEW_LINE even_pairs = even * ( n - 1 ) NEW_LINE print ( odd_pairs ) NEW_LINE print ( even_pairs ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE countPairs ( arr , n ) NEW_LINE DEDENT
h = int ( input ( ) ) NEW_LINE for x in range ( h ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = min ( m , b ) NEW_LINE m -= s NEW_LINE b -= s NEW_LINE while a % 10 == 0 : NEW_LINE INDENT b += 1 NEW_LINE a = a // 10 NEW_LINE DEDENT while n % 10 == 0 : NEW_LINE INDENT m += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT h = str ( a ) NEW_LINE k = str ( n ) NEW_LINE if len ( h ) + b > len ( k ) + m : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif len ( h ) + b < len ( k ) + m : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if h > k : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif h < k : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT DEDENT DEDENT
numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE columns = numbers [ 0 ] NEW_LINE rows = numbers [ 1 ] NEW_LINE counter = - 1 NEW_LINE data = { } NEW_LINE stop = 0 NEW_LINE for i in range ( 0 , columns ) : NEW_LINE INDENT x = input ( ) NEW_LINE g = " not " NEW_LINE s = ' not ' NEW_LINE count = 0 NEW_LINE for j in range ( 0 , rows ) : NEW_LINE INDENT if x [ j ] == " S " : NEW_LINE INDENT if g == " found " : NEW_LINE INDENT counter = count + 1 ; NEW_LINE if not f " { counter } " in data : NEW_LINE INDENT data [ f " { counter } " ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stop = 1 NEW_LINE DEDENT break NEW_LINE DEDENT elif x [ j ] == ' G ' : NEW_LINE INDENT g = ' found ' NEW_LINE count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( - 1 if len ( data ) == 0 or stop == 1 else len ( data ) ) NEW_LINE
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 ; back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE DEDENT mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE
def MinCostTree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ 2 ** 32 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( st [ - 1 ] <= arr [ i ] ) : NEW_LINE INDENT x = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE ans += x * min ( st [ - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCostTree ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = list ( str ( input ( ) ) ) NEW_LINE t = list ( str ( input ( ) ) ) NEW_LINE dic_s = { } NEW_LINE dic_t = { } NEW_LINE for i in range ( 97 , 97 + 26 ) : NEW_LINE INDENT dic_s [ chr ( i ) ] = 0 NEW_LINE dic_t [ chr ( i ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dic_s [ s [ i ] ] += 1 NEW_LINE dic_t [ t [ i ] ] += 1 NEW_LINE DEDENT if dic_s != dic_t : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT target = i + s [ i : ] . index ( t [ i ] ) NEW_LINE c . append ( target - 1 ) NEW_LINE s [ target - 1 ] , s [ target ] = s [ target ] , s [ target - 1 ] NEW_LINE DEDENT DEDENT c = [ el + 1 for el in c ] NEW_LINE print ( len ( c ) ) NEW_LINE for el in c : NEW_LINE INDENT print ( el , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def findEquation ( a , b ) : NEW_LINE INDENT summ = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ^ 2 ▁ - ▁ ( " , summ , " x ) ▁ + ▁ ( " , product , " ) ▁ = ▁ 0" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE findEquation ( a , b ) NEW_LINE
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 ; NEW_LINE b = - 2 * y1 ; NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; NEW_LINE print ( " x ^ 2 ▁ + ▁ ( " , a , " x ) ▁ + ▁ " , end = " " ) ; NEW_LINE print ( " y ^ 2 ▁ + ▁ ( " , b , " y ) ▁ = ▁ " , end = " " ) ; NEW_LINE print ( c , " . " ) ; NEW_LINE DEDENT x1 = 2 ; NEW_LINE y1 = - 3 ; NEW_LINE r = 8 ; NEW_LINE circle_equation ( x1 , y1 , r ) ; NEW_LINE
def unique_combination ( l , sum , K , local , A ) : NEW_LINE INDENT if ( sum == K ) : NEW_LINE INDENT print ( " { " , end = " " ) NEW_LINE for i in range ( len ( local ) ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( local [ i ] , end = " " ) NEW_LINE if ( i != len ( local ) - 1 ) : NEW_LINE INDENT print ( " , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " } " ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) , 1 ) : NEW_LINE INDENT if ( sum + A [ i ] > K ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 1 and A [ i ] == A [ i - 1 ] and i > l ) : NEW_LINE INDENT continue NEW_LINE DEDENT local . append ( A [ i ] ) NEW_LINE unique_combination ( i + 1 , sum + A [ i ] , K , local , A ) NEW_LINE local . remove ( local [ len ( local ) - 1 ] ) NEW_LINE DEDENT DEDENT def Combination ( A , K ) : NEW_LINE INDENT A . sort ( reverse = False ) NEW_LINE local = [ ] NEW_LINE unique_combination ( 0 , 0 , K , local , A ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] NEW_LINE K = 8 NEW_LINE Combination ( A , K ) NEW_LINE DEDENT
import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE prices = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( bisect . bisect_right ( prices , int ( input ( ) ) ) ) NEW_LINE DEDENT
z = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE def f ( x ) : NEW_LINE INDENT for i in range ( 1 , 26 , 2 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT a = ' ' . join ( z [ ( z . index ( c ) * i + j ) % 26 ] if c in z else c for c in x ) NEW_LINE if ' that ' in a or ' this ' in a : return a NEW_LINE DEDENT DEDENT DEDENT for _ in [ 0 ] * int ( input ( ) ) : print ( f ( input ( ) ) ) NEW_LINE
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) ; NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( n % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return True if ( ( n - 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( ( n + 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) == True ) : NEW_LINE INDENT print ( " Odd " , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " , end = " ▁ " ) ; NEW_LINE DEDENT
while 1 : NEW_LINE INDENT d , e = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ ] NEW_LINE for i in range ( 0 , 101 ) : NEW_LINE INDENT for j in range ( 0 , 101 ) : NEW_LINE INDENT data . append ( ( abs ( ( ( i * i + j * j ) ** 0.5 ) - e ) , i , j ) ) NEW_LINE DEDENT DEDENT for p in sorted ( data ) : NEW_LINE INDENT if p [ 1 ] + p [ 2 ] == d : NEW_LINE INDENT print ( p [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) ; NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) ; NEW_LINE dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) ; NEW_LINE DEDENT elif ( n >= 3 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) ; NEW_LINE dp [ 1 ] = max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ; NEW_LINE dp [ 2 ] = max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) ; NEW_LINE i = 3 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , - 2 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( max_sum ( arr , n ) ) ; NEW_LINE DEDENT
sentence = input ( ) NEW_LINE start , letter = - 1 , str ( ) NEW_LINE while True : NEW_LINE INDENT if ( sentence [ start ] != ' ▁ ' ) and ( sentence [ start ] != ' ? ' ) : NEW_LINE INDENT letter = sentence [ start ] NEW_LINE break NEW_LINE DEDENT start -= 1 NEW_LINE DEDENT if letter . lower ( ) in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' , ' y ' ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mini NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE DEDENT
def find_longest ( node ) : NEW_LINE INDENT global visited NEW_LINE visited [ node ] = True NEW_LINE if node not in graph : NEW_LINE INDENT return 1 NEW_LINE DEDENT max_child = 0 NEW_LINE for i in graph [ node ] : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT max_child = max ( max_child , find_longest ( i ) ) NEW_LINE DEDENT return max_child + 1 NEW_LINE DEDENT def dfs ( node ) : NEW_LINE INDENT vis = [ 0 for i in range ( len ( FF ) ) ] NEW_LINE vis [ node ] = 1 NEW_LINE size = 1 NEW_LINE tmp = node NEW_LINE while True : NEW_LINE INDENT tmp = FF [ tmp ] NEW_LINE if tmp == node : NEW_LINE INDENT return size NEW_LINE DEDENT if vis [ tmp ] == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT vis [ tmp ] = 1 NEW_LINE size += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT visited = [ ] NEW_LINE graph = { } NEW_LINE Q = int ( input ( ) ) NEW_LINE for q in range ( Q ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE FF = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE FF . insert ( 0 , - 1 ) NEW_LINE graph = { } NEW_LINE visited = [ False for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , len ( FF ) ) : NEW_LINE INDENT if FF [ i ] not in graph : NEW_LINE INDENT graph [ FF [ i ] ] = [ ] NEW_LINE DEDENT graph [ FF [ i ] ] . append ( i ) NEW_LINE DEDENT double = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i == FF [ FF [ i ] ] and not visited [ i ] : NEW_LINE INDENT visited [ i ] = True NEW_LINE visited [ FF [ i ] ] = True NEW_LINE dou = find_longest ( i ) + find_longest ( FF [ i ] ) NEW_LINE double += dou NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT double = max ( double , dfs ( i ) ) NEW_LINE DEDENT DEDENT print ( " Case ▁ # { } : ▁ { } " . format ( q + 1 , double ) ) NEW_LINE DEDENT
def SellingPrice ( CP , PP ) : NEW_LINE INDENT Pdecimal = 1 + ( PP / 100 ) NEW_LINE res = Pdecimal * CP NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for c in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE seq = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE posis = [ None ] * ( n + 1 ) NEW_LINE for u in range ( 0 , n ) : NEW_LINE INDENT posis [ seq [ u ] ] = u NEW_LINE DEDENT print ( 1 , end = " " ) NEW_LINE l = posis [ 1 ] ; NEW_LINE r = posis [ 1 ] NEW_LINE for num in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( posis [ num ] < l ) : l = posis [ num ] NEW_LINE if ( posis [ num ] > r ) : r = posis [ num ] NEW_LINE print ( 1 if num == r - l + 1 else 0 , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
import math NEW_LINE def f ( b : int , n : int ) -> int : NEW_LINE INDENT if b > n : NEW_LINE INDENT return n NEW_LINE DEDENT return f ( b , n // b ) + ( n % b ) NEW_LINE DEDENT def digit_sum ( n : int , s : int ) -> int : NEW_LINE INDENT if n == s : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT sqrt = math . sqrt ( n ) NEW_LINE sqrt = math . ceil ( sqrt ) NEW_LINE for b in range ( 2 , sqrt + 1 ) : NEW_LINE INDENT if f ( b , n ) == s : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT for p in range ( sqrt , 0 , - 1 ) : NEW_LINE INDENT if ( n - s ) % p : NEW_LINE INDENT continue NEW_LINE DEDENT b = ( n - s ) // p + 1 NEW_LINE if b < 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if f ( b , n ) == s : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = int ( input ( ) ) NEW_LINE ans = digit_sum ( n , s ) NEW_LINE print ( ans ) NEW_LINE DEDENT
m , b = map ( int , input ( ) . split ( ) ) NEW_LINE maximum = 0 NEW_LINE for y in range ( b + 1 ) : NEW_LINE INDENT sum = ( m * ( b - y ) + y ) * ( m * ( b - y ) + 1 ) * ( y + 1 ) // 2 NEW_LINE if maximum <= sum : NEW_LINE INDENT maximum = sum NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT print ( maximum ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = int ( input ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; p = 0 NEW_LINE for i in range ( x - 2 ) : NEW_LINE INDENT if a [ i ] in a [ i + 2 : ] : NEW_LINE INDENT p = 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ' YES ' if p != 0 else ' NO ' ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) [ : n ] NEW_LINE ls = { } NEW_LINE for c in s : NEW_LINE INDENT ls [ c ] = c NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT x , y = input ( ) . split ( ) [ : 2 ] NEW_LINE if x not in ls : NEW_LINE INDENT ls [ x ] = x NEW_LINE DEDENT if y not in ls : NEW_LINE INDENT ls [ y ] = y NEW_LINE DEDENT ls [ x ] , ls [ y ] = ls [ y ] , ls [ x ] NEW_LINE DEDENT ans = { } NEW_LINE for c , v in ls . items ( ) : NEW_LINE INDENT ans [ v ] = c NEW_LINE DEDENT print ( " " . join ( [ ans [ c ] for c in s ] ) ) NEW_LINE
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 ; NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeks " ; NEW_LINE ch = ' e ' ; NEW_LINE N = 2 ; NEW_LINE print ( findNthOccur ( string , ch , N ) ) ; NEW_LINE DEDENT
from collections import Counter NEW_LINE def most_frequent ( List ) : NEW_LINE INDENT occurence_count = Counter ( List ) NEW_LINE return occurence_count . most_common ( 1 ) [ 0 ] [ 0 ] NEW_LINE DEDENT list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE o = 0 NEW_LINE a1 = [ ] NEW_LINE b = most_frequent ( list ) NEW_LINE for num in list : NEW_LINE INDENT if num == b : NEW_LINE INDENT o = o + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a1 . append ( num ) NEW_LINE DEDENT DEDENT if o == 6 : NEW_LINE INDENT print ( ' Elephant ' ) NEW_LINE DEDENT if o == 5 : NEW_LINE INDENT print ( ' Bear ' ) NEW_LINE DEDENT if o == 4 : NEW_LINE INDENT if a1 [ 0 ] == a1 [ 1 ] : NEW_LINE INDENT print ( ' Elephant ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Bear ' ) NEW_LINE DEDENT DEDENT if 4 > o : NEW_LINE INDENT print ( ' Alien ' ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT // ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) // 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT // i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT // ( i + 1 ) , LIMIT // i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE s = 0 NEW_LINE mx = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT if i < n - 1 : NEW_LINE INDENT mx = max ( mx , a [ i ] + a [ i + 1 ] ) NEW_LINE DEDENT s += a [ i ] NEW_LINE if i % 2 == k % 2 : NEW_LINE INDENT tmp = ( k - i ) // 2 NEW_LINE if tmp <= z : NEW_LINE INDENT ans = max ( ans , s + mx * tmp ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = - 1 , - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT s = r + 1 NEW_LINE for i in range ( l , s ) : NEW_LINE INDENT if arr [ i ] == s : NEW_LINE INDENT s -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( l + 1 , r + 1 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE a_start = [ x [ 0 ] * 60 + x [ 1 ] for x in lst ] NEW_LINE a_end = [ x [ 2 ] * 60 + x [ 3 ] for x in lst ] NEW_LINE h_start = [ x [ 4 ] * 60 + x [ 5 ] for x in lst ] NEW_LINE h_end = [ x [ 6 ] * 60 + x [ 7 ] for x in lst ] NEW_LINE b_start = [ x [ 8 ] * 60 + x [ 9 ] for x in lst ] NEW_LINE b_end = [ x [ 10 ] * 60 + x [ 11 ] for x in lst ] NEW_LINE def make_sets ( start , end ) : NEW_LINE INDENT sets = [ ] NEW_LINE member = [ ] NEW_LINE for i in range ( 1440 ) : NEW_LINE INDENT upd = False NEW_LINE for j in range ( n ) : NEW_LINE INDENT if start [ j ] == i : NEW_LINE INDENT member . append ( j ) NEW_LINE upd = True NEW_LINE DEDENT if end [ j ] == i - 1 : NEW_LINE INDENT member . remove ( j ) NEW_LINE upd = True NEW_LINE DEDENT DEDENT if upd : NEW_LINE INDENT sets . append ( set ( member ) ) NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT a_sets = make_sets ( a_start , a_end ) NEW_LINE h_sets = make_sets ( h_start , h_end ) NEW_LINE b_sets = make_sets ( b_start , b_end ) NEW_LINE ans = 0 NEW_LINE for s1 in a_sets : NEW_LINE INDENT for s2 in h_sets : NEW_LINE INDENT for s3 in b_sets : NEW_LINE INDENT ans = max ( ans , len ( s1 & s2 & s3 ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def get_two_int ( ) : NEW_LINE INDENT two_int = input ( ) . split ( ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT two_int [ i ] = int ( two_int [ i ] ) NEW_LINE DEDENT return two_int NEW_LINE DEDENT def distribute_stone ( candidate_num , stone_num ) : NEW_LINE INDENT bowl_stone = stone_num NEW_LINE candidate_list = [ 0 ] * candidate_num NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT order = i % candidate_num NEW_LINE if bowl_stone != 0 : NEW_LINE INDENT candidate_list [ order ] += 1 NEW_LINE bowl_stone -= 1 NEW_LINE DEDENT elif bowl_stone == 0 and candidate_list [ order ] == stone_num : NEW_LINE INDENT return order NEW_LINE DEDENT else : NEW_LINE INDENT bowl_stone = candidate_list [ order ] NEW_LINE candidate_list [ order ] = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT while True : NEW_LINE INDENT candidate_num , stone_num = get_two_int ( ) NEW_LINE if candidate_num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT order = distribute_stone ( candidate_num , stone_num ) NEW_LINE print ( order ) NEW_LINE DEDENT DEDENT
def count_two_idx ( A , q ) : NEW_LINE INDENT ans = 0 NEW_LINE left = 0 NEW_LINE csum = 0 NEW_LINE for right in range ( N ) : NEW_LINE INDENT csum += A [ right ] NEW_LINE while csum > q : NEW_LINE INDENT csum -= A [ left ] NEW_LINE left += 1 NEW_LINE DEDENT ans += right - left + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT N , M = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for q in X : NEW_LINE INDENT print ( count_two_idx ( A , q ) ) NEW_LINE DEDENT
a = int ( input ( ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE d = abs ( b - c ) NEW_LINE if d % 10 != 0 : NEW_LINE INDENT print ( d // 10 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d // 10 ) NEW_LINE DEDENT DEDENT
maxSize = 100005 NEW_LINE isFib = [ False ] * ( maxSize ) NEW_LINE prefix = [ 0 ] * maxSize NEW_LINE def digitSum ( num ) : NEW_LINE INDENT s = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT s = s + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def generateFibonacci ( ) : NEW_LINE INDENT global isFib NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr < maxSize ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp < maxSize : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def precompute ( k ) : NEW_LINE INDENT generateFibonacci ( ) NEW_LINE global prefix NEW_LINE for i in range ( 1 , maxSize ) : NEW_LINE INDENT sum = digitSum ( i ) NEW_LINE if ( isFib [ sum ] == True and sum % k == 0 ) : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , maxSize ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def performQueries ( k , q , query ) : NEW_LINE INDENT precompute ( k ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE cnt = prefix [ r ] - prefix [ l - 1 ] NEW_LINE print ( cnt ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT query = [ [ 1 , 11 ] , [ 5 , 15 ] , [ 2 , 24 ] ] NEW_LINE k = 2 NEW_LINE q = len ( query ) NEW_LINE performQueries ( k , q , query ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x1 , y1 = map ( int , input ( ) . split ( ) ) ; x2 , y2 = map ( int , input ( ) . split ( ) ) ; x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE alpha = 0 NEW_LINE if y1 == y2 and y3 < y1 : alpha += abs ( x1 - x2 ) NEW_LINE if y2 == y3 and y1 < y2 : alpha += abs ( x2 - x3 ) NEW_LINE if y3 == y1 and y2 < y3 : alpha += abs ( x3 - x1 ) NEW_LINE print ( alpha ) NEW_LINE DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ l - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = " " + chr ( N ) NEW_LINE res_str = " " NEW_LINE sum = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT while ( len ( res_str ) < sum ) : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ 0 : sum ] NEW_LINE DEDENT if ( isPalindrome ( res_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10101 NEW_LINE if ( createStringAndCheckPalindrome ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE soots = [ " S " , " H " , " C " , " D " ] NEW_LINE sootlist = [ ] NEW_LINE numlist = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT soot , num = map ( str , input ( ) . split ( ) ) NEW_LINE sootlist . append ( soot ) NEW_LINE numlist . append ( int ( num ) ) NEW_LINE DEDENT ans_sootlist = [ ] NEW_LINE ans_numlist = [ ] NEW_LINE for soot in soots : NEW_LINE INDENT for num in range ( 1 , 14 ) : NEW_LINE INDENT flag = 0 NEW_LINE for s , n in zip ( sootlist , numlist ) : NEW_LINE INDENT if soot == s and num == n : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans_sootlist . append ( soot ) NEW_LINE ans_numlist . append ( num ) NEW_LINE DEDENT DEDENT DEDENT for soot , num in zip ( ans_sootlist , ans_numlist ) : NEW_LINE INDENT print ( soot , num ) NEW_LINE DEDENT
def sum_even_and_even_index ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 5 , 6 , 12 , 1 , 18 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ of ▁ even ▁ numbers ▁ at ▁ " , " even ▁ indices ▁ is ▁ " , sum_even_and_even_index ( arr , n ) ) NEW_LINE
from itertools import groupby NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT ans = " YES " NEW_LINE for k , g in groupby ( input ( ) ) : NEW_LINE INDENT if len ( list ( g ) ) == 1 : NEW_LINE INDENT ans = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) NEW_LINE fl = 1 ; NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n ; NEW_LINE DEDENT if ( fl == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] ; NEW_LINE arr_size = len ( arr ) ; NEW_LINE printDuplicates ( arr , arr_size ) ; NEW_LINE
print ( sum ( 1 / ( i + 1 ) for i in range ( int ( input ( ) ) ) ) ) NEW_LINE
def Sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 ; NEW_LINE print ( Sum ( n ) ) NEW_LINE DEDENT
def maxHandshake ( n ) : NEW_LINE INDENT return int ( ( n * ( n - 1 ) ) / 2 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( maxHandshake ( n ) ) NEW_LINE
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 ; NEW_LINE print ( Max_Sum ( n ) ) ; NEW_LINE DEDENT
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 ; NEW_LINE DEDENT DEDENT n = 20 ; NEW_LINE print ( possibleways ( n ) ) ; NEW_LINE
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 21 ; NEW_LINE print ( CountSetBits ( n ) ) ; NEW_LINE DEDENT
def summ ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( summ ( m , n ) ) NEW_LINE
def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return int ( sum * ( sum + 1 ) / 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( " SUM ( " , n , " , ▁ " , m , " ) : " , SUM ( n , m ) ) NEW_LINE
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE print ( maxLCM ( n ) ) ; NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE
def cntWays ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT n = 18 NEW_LINE print ( cntWays ( n ) ) NEW_LINE
def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; NEW_LINE find_composite_nos ( n ) ; NEW_LINE DEDENT
def findThirdDigit ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if n and 1 else 6 NEW_LINE DEDENT n = 7 NEW_LINE print ( findThirdDigit ( n ) ) NEW_LINE
def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; NEW_LINE DEDENT DEDENT n = 2 ; NEW_LINE print ( sum ( n ) ) ; NEW_LINE
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 48 NEW_LINE print ( highestPowerOf2 ( n ) ) NEW_LINE DEDENT
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE
S = input ( ) NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT if chr ( i ) not in list ( S ) : NEW_LINE INDENT print ( chr ( i ) ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' None ' ) NEW_LINE
n = int ( input ( ) ) NEW_LINE array = input ( ) . split ( ) NEW_LINE a = 0 NEW_LINE while a < n : NEW_LINE INDENT array [ a ] = int ( array [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT smallest = min ( array ) NEW_LINE array . sort ( ) NEW_LINE i = 1 NEW_LINE t_or_f = True NEW_LINE while i < n : NEW_LINE INDENT if array [ i ] / smallest != int ( array [ i ] / smallest ) : NEW_LINE INDENT t_or_f = False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if t_or_f == True : NEW_LINE INDENT print ( smallest ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
print ( " ABC " if int ( input ( ) ) < 1200 else " ARC " ) NEW_LINE
import sys NEW_LINE def skip_spaces ( ) : NEW_LINE INDENT c = ' ▁ ' NEW_LINE while c . isspace ( ) : NEW_LINE INDENT c = sys . stdin . read ( 1 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def skip_nonspaces ( ) : NEW_LINE INDENT c = ' _ ' NEW_LINE while c != ' ' and not c . isspace ( ) : NEW_LINE INDENT c = sys . stdin . read ( 1 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def read_zeros ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT c = skip_spaces ( ) NEW_LINE if c == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT yield c == '0' NEW_LINE if skip_nonspaces ( ) == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def dists ( ) : NEW_LINE INDENT first = True NEW_LINE k = 0 NEW_LINE for z in read_zeros ( ) : NEW_LINE INDENT if z : NEW_LINE INDENT if first : NEW_LINE INDENT yield from range ( k , 0 , - 1 ) NEW_LINE first = False NEW_LINE DEDENT else : NEW_LINE INDENT h = k // 2 NEW_LINE yield from range ( h + 1 ) NEW_LINE yield from range ( k - h - 1 , 0 , - 1 ) NEW_LINE DEDENT k = 0 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT yield from range ( k ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT skip_spaces ( ) NEW_LINE skip_nonspaces ( ) NEW_LINE first = True NEW_LINE for d in dists ( ) : NEW_LINE INDENT if first : NEW_LINE INDENT first = False NEW_LINE print ( d , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ' , d , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT main ( ) NEW_LINE
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE print ( " Minimum ▁ of ▁ 3 ▁ numbers ▁ is " , smallest ( x , y , z ) ) NEW_LINE
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE sum = a + b * 5 + c * 10 + d * 50 + e * 100 + f * 500 NEW_LINE print ( 1 if sum >= 1000 else 0 ) NEW_LINE
m , r = map ( int , input ( ) . split ( ) ) NEW_LINE res , sq2 = 0 , ( 2 ** .5 ) NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res += 2 + sq2 + 2 * sq2 * ( i - 1 ) + ( i - 1 ) * i NEW_LINE DEDENT res = ( res + m ) * 2 * r NEW_LINE print ( res / ( m * m ) ) NEW_LINE
from math import * NEW_LINE def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( b ** ( 1. / 3. ) ) - ceil ( a ** ( 1. / 3. ) ) + 1 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 28 NEW_LINE print ( " Count ▁ of ▁ cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE
from heapq import heappush , heappop NEW_LINE INF = 10 ** 20 NEW_LINE def search ( item_lst , d ) : NEW_LINE INDENT visited = { } NEW_LINE visited [ ( 0 , 0 ) ] = True NEW_LINE que = [ ] NEW_LINE heappush ( que , ( 0 , 0 , 0 ) ) NEW_LINE while que : NEW_LINE INDENT score , a , e = heappop ( que ) NEW_LINE for da , de in item_lst [ e ] : NEW_LINE INDENT na = a + da NEW_LINE if na >= d : NEW_LINE INDENT print ( score + 1 ) NEW_LINE return True NEW_LINE DEDENT ne = e + de NEW_LINE if ne > 100 : NEW_LINE INDENT ne = 100 NEW_LINE DEDENT if ( na , ne ) not in visited : NEW_LINE INDENT visited [ ( na , ne ) ] = True NEW_LINE heappush ( que , ( score + 1 , na , ne ) ) NEW_LINE DEDENT DEDENT DEDENT print ( " NA " ) NEW_LINE return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT d , n = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT item_lst = [ [ ] for _ in range ( 101 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , e , r = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( r , 101 ) : NEW_LINE INDENT item_lst [ i ] . append ( ( a , e ) ) NEW_LINE DEDENT DEDENT search ( item_lst , d ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT triangle = 0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT triangle += i NEW_LINE if num_divisors ( triangle ) > 500 : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT DEDENT DEDENT def num_divisors ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE result = sum ( 2 for i in range ( 1 , end + 1 ) if n % i == 0 ) NEW_LINE if end ** 2 == n : NEW_LINE INDENT result -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findDelta ( a , b , c , d ) : NEW_LINE INDENT return int ( ( b * c - a * d ) / ( d - c ) ) ; NEW_LINE DEDENT a = 3 ; b = 9 ; NEW_LINE c = 3 ; d = 5 ; NEW_LINE print ( " \u0394 X ▁ = ▁ { } " . format ( findDelta ( a , b , c , d ) ) ) ; NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT n = 74 NEW_LINE findPrimePair ( n ) NEW_LINE
def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 ; NEW_LINE multiply = 1 ; NEW_LINE while ( x % 10 > 0 ) : NEW_LINE INDENT remainder = x % 10 ; NEW_LINE if ( remainder == d1 ) : NEW_LINE INDENT result = ( result + d2 * multiply ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = ( result + remainder * multiply ) ; NEW_LINE DEDENT multiply *= 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT x = 645 ; NEW_LINE d1 = 6 ; NEW_LINE d2 = 5 ; NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) ; NEW_LINE
def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \ \ " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT
import sys NEW_LINE def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT m = [ 0 ] * 1000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ arr [ i ] ] NEW_LINE m [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT twice_count += m [ sum - arr [ i ] ] NEW_LINE if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return int ( twice_count / 2 ) NEW_LINE DEDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is " , getPairsCount ( arr , n , sum ) ) NEW_LINE
def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE remaining_sum = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] ; NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE p = abs ( a - b ) NEW_LINE q = p + x NEW_LINE if q >= n - 1 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] = int ( input ( ) ) NEW_LINE DEDENT s = sorted ( s ) NEW_LINE t = sum ( s ) NEW_LINE if t % 10 != 0 : NEW_LINE INDENT print ( t ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT t = sum ( s [ : i ] ) + sum ( s [ i + 1 : ] ) NEW_LINE if t % 10 != 0 : NEW_LINE INDENT print ( t ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT print ( 0 ) NEW_LINE
from collections import deque NEW_LINE from math import * NEW_LINE import sys NEW_LINE import random NEW_LINE from bisect import * NEW_LINE from functools import reduce NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = sys . maxsize NEW_LINE for color in range ( 1 , 101 ) : NEW_LINE INDENT i = 0 NEW_LINE day = 0 NEW_LINE while i < n : NEW_LINE INDENT if i < n and arr [ i ] != color : NEW_LINE INDENT i += k NEW_LINE day += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT res = min ( res , day ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = sqrt ( n ) NEW_LINE range__ = int ( ( n / sq ) + 1 ) NEW_LINE count = [ 0 for i in range ( range__ ) ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1 NEW_LINE DEDENT selected_block = range__ - 1 NEW_LINE for i in range ( 0 , range__ - 1 , 1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = { i : 0 for i in range ( n ) } NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE if ( m [ arr [ i ] ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 , 5 , 4 ] NEW_LINE n = 5 NEW_LINE print ( " One ▁ of ▁ the ▁ numbers ▁ repeated ▁ in ▁ the ▁ array ▁ is : " , findRepeatingNumber ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return int ( maxPrime ) NEW_LINE DEDENT n = 15 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE n = 25698751364526 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in l : NEW_LINE INDENT count += i % 2 NEW_LINE DEDENT print ( min ( count , n - count ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE num_0 = 0 NEW_LINE num_1 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == "0" : NEW_LINE INDENT num_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_1 += 1 NEW_LINE DEDENT DEDENT print ( min ( num_0 , num_1 ) * 2 ) NEW_LINE
def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , " , ▁ " , j , " , ▁ " , k , sep = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ Triplet " ) NEW_LINE DEDENT n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE
import math NEW_LINE def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
def indexOfFirstOne ( arr , low , high ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( arr [ mid ] == 1 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return mid NEW_LINE DEDENT def posOfFirstOne ( arr ) : NEW_LINE INDENT l = 0 NEW_LINE h = 1 NEW_LINE while ( arr [ h ] == 0 ) : NEW_LINE INDENT l = h NEW_LINE h = 2 * h NEW_LINE DEDENT return indexOfFirstOne ( arr , l , h ) NEW_LINE DEDENT arr = [ 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE print ( " Index ▁ = ▁ " , posOfFirstOne ( arr ) ) NEW_LINE
import math NEW_LINE import os NEW_LINE import random NEW_LINE import re NEW_LINE import sys NEW_LINE from math import gcd NEW_LINE from math import sqrt NEW_LINE n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( n // 3 * 2 ) NEW_LINE DEDENT elif n < 3 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 3 * 2 + 1 ) NEW_LINE DEDENT
while ( True ) : NEW_LINE INDENT n = float ( input ( ) ) NEW_LINE if n < 0 : break NEW_LINE if int ( n * 16 ) - n * 16 : print ( " NA " ) ; continue NEW_LINE else : NEW_LINE INDENT s = bin ( int ( n * 16 ) ) [ 2 : ] . zfill ( 12 ) NEW_LINE print ( s [ : - 4 ] + " . " + s [ - 4 : ] ) NEW_LINE DEDENT DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE rem = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE sum = sum + rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT n = 43 ; NEW_LINE print ( " x ▁ = ▁ " , findX ( n ) ) ; NEW_LINE
def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE P = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE editorial ( N , P ) NEW_LINE DEDENT def editorial ( N , P ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT a = [ 0 ] * ( N + 1 ) NEW_LINE for i , p in enumerate ( P ) : NEW_LINE INDENT a [ p ] = i NEW_LINE DEDENT tmp = 1 NEW_LINE max_len = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT tmp += 1 NEW_LINE max_len = max ( max_len , tmp ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = 1 NEW_LINE DEDENT DEDENT ans = N - max_len NEW_LINE print ( ans ) NEW_LINE DEDENT def WA ( N , P ) : NEW_LINE INDENT tmp = 0 NEW_LINE ans = 0 NEW_LINE for i , p in enumerate ( P ) : NEW_LINE INDENT if i == 0 or P [ i - 1 ] + 1 == p : NEW_LINE INDENT tmp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , tmp ) NEW_LINE tmp = 1 NEW_LINE DEDENT DEDENT print ( N - ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( 7 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a - b ) NEW_LINE DEDENT
def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT L , R = R , L NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) ; NEW_LINE
import os , sys , io , math NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE n = IN ( ) NEW_LINE l = I ( ) NEW_LINE f = 1 NEW_LINE l . sort ( ) NEW_LINE c = 0 NEW_LINE for i in l : NEW_LINE INDENT if i > c : c += 1 NEW_LINE DEDENT print ( c + 1 ) NEW_LINE
RO = sorted ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) [ - 1 ] NEW_LINE PO = sorted ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) [ - 1 ] NEW_LINE PI = sorted ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) [ 0 ] NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( pow ( pow ( RO , 2 ) / ( ( ( A * PI ) / ( B * PO ) ) + 1 ) , 0.5 ) ) NEW_LINE
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 3 NEW_LINE lterm = 1 NEW_LINE rterm = num * num + 1 NEW_LINE for i in range ( num , - 1 , - 1 ) : NEW_LINE INDENT for space in range ( num , i - 1 , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( str ( lterm ) + " * " , end = " " ) NEW_LINE lterm += 1 NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( rterm , end = " " ) NEW_LINE if j < i : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT rterm += 1 NEW_LINE DEDENT rterm = rterm - ( i - 1 ) * 2 - 1 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def findPerm ( n , differences ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( 0 ) NEW_LINE x = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = differences [ i ] NEW_LINE x = x + diff NEW_LINE ans . append ( x ) NEW_LINE DEDENT anss = ans NEW_LINE ans = sorted ( ans ) NEW_LINE flag = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = ans [ i ] - ans [ i - 1 ] NEW_LINE if ( res != 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT mpp = dict ( ) NEW_LINE j = 1 NEW_LINE value_at_index = [ ] NEW_LINE for x in ans : NEW_LINE INDENT mpp [ x ] = j NEW_LINE j += 1 NEW_LINE DEDENT for x in anss : NEW_LINE INDENT value_at_index . append ( mpp [ x ] ) NEW_LINE DEDENT for x in value_at_index : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT differences = [ ] NEW_LINE differences . append ( 2 ) NEW_LINE differences . append ( - 3 ) NEW_LINE differences . append ( 2 ) NEW_LINE n = len ( differences ) + 1 NEW_LINE findPerm ( n , differences ) NEW_LINE
import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE count += 1 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i <= math . sqrt ( n ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n / i ; NEW_LINE count += 1 ; NEW_LINE DEDENT i = i + 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return ( count ) ; NEW_LINE DEDENT def printKAlmostPrimes ( k , n ) : NEW_LINE INDENT i = 1 ; NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( num , end = " " ) ; NEW_LINE print ( " ▁ " , end = " " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT num += 1 ; NEW_LINE DEDENT return ; NEW_LINE DEDENT n = 10 ; NEW_LINE k = 2 ; NEW_LINE print ( " First ▁ " + str ( n ) + " ▁ " + str ( k ) + " - almost ▁ prime ▁ numbers : " ) ; NEW_LINE printKAlmostPrimes ( k , n ) ; NEW_LINE
def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT X = input ( ) NEW_LINE if X == '0' : break NEW_LINE r = ' ' NEW_LINE minus = False NEW_LINE if X [ 0 ] == ' - ' : NEW_LINE INDENT minus = True NEW_LINE X = X [ 1 : ] NEW_LINE DEDENT kuri = 0 NEW_LINE idx = len ( X ) - 1 NEW_LINE while idx >= 0 : NEW_LINE INDENT a = int ( X [ idx ] ) NEW_LINE if minus : NEW_LINE INDENT r = str ( ( 10 - a - kuri ) % 10 ) + r NEW_LINE kuri = 0 if kuri + a == 0 else 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( ( kuri + a ) % 10 ) + r NEW_LINE kuri = ( kuri + a ) // 10 NEW_LINE DEDENT minus = not minus NEW_LINE if idx == 0 and kuri > 0 : NEW_LINE INDENT X = '0' + X NEW_LINE DEDENT else : NEW_LINE INDENT idx -= 1 NEW_LINE DEDENT DEDENT r = str ( kuri ) + r NEW_LINE print ( int ( r ) ) NEW_LINE DEDENT
import math ; NEW_LINE def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT m = - 5 ; n = 3 ; NEW_LINE print ( normal ( m , n ) ) ; NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans . append ( h * ( ( i / n ) ** 0.5 ) ) NEW_LINE DEDENT print ( * ans ) NEW_LINE
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 65 NEW_LINE print ( countBits ( i ) ) NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( h * w - ( a * b * ( ( h // a ) * ( w // b ) ) ) ) NEW_LINE
from bisect import bisect_left as bl NEW_LINE n = int ( input ( ) ) NEW_LINE tlst = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) NEW_LINE max_t = tlst [ - 1 ] NEW_LINE divisors = [ i for i in range ( 1 , max_t + 1 ) if max_t % i == 0 ] NEW_LINE ans = 0 NEW_LINE for t in tlst : NEW_LINE INDENT ind = bl ( divisors , t ) NEW_LINE ans += divisors [ ind ] - t NEW_LINE DEDENT print ( ans ) NEW_LINE
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT arr2 = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] % k NEW_LINE DEDENT max_length = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT current_length = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr2 [ j ] == arr2 [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE i += 1 NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) ; print ( m - 1 if n - m + 1 <= m and n != 1 else m + 1 if n != 1 else 1 ) NEW_LINE
def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " NEW_LINE n = len ( s ) NEW_LINE print ( " YES " if isHeterogram ( s , n ) else " NO " ) NEW_LINE
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT arr = list ( range ( 10 ) ) NEW_LINE temp = itertools . islice ( itertools . permutations ( arr ) , 999999 , None ) NEW_LINE return " " . join ( str ( x ) for x in next ( temp ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 , y1 , x2 , y2 = 0 , 0 , 10 , 8 NEW_LINE x , y = 1 , 5 NEW_LINE if FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from sys import maxsize as INT_MAX NEW_LINE MX = 2001 NEW_LINE OFF = 1000 NEW_LINE class point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def countPoints ( n : int , points : list ) -> int : NEW_LINE INDENT minx = [ INT_MAX ] * MX NEW_LINE miny = [ INT_MAX ] * MX NEW_LINE maxx = [ 0 ] * MX NEW_LINE maxy = [ 0 ] * MX NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT points [ i ] . x += OFF NEW_LINE points [ i ] . y += OFF NEW_LINE x = points [ i ] . x NEW_LINE y = points [ i ] . y NEW_LINE minx [ y ] = min ( minx [ y ] , x ) NEW_LINE maxx [ y ] = max ( maxx [ y ] , x ) NEW_LINE miny [ x ] = min ( miny [ x ] , y ) NEW_LINE maxy [ x ] = max ( maxy [ x ] , y ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = points [ i ] . x NEW_LINE y = points [ i ] . y NEW_LINE if ( x > minx [ y ] and x < maxx [ y ] ) : NEW_LINE INDENT if ( y > miny [ x ] and y < maxy [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT points = [ point ( 0 , 0 ) , point ( 0 , 1 ) , point ( 1 , 0 ) , point ( 0 , - 1 ) , point ( - 1 , 0 ) ] NEW_LINE n = len ( points ) NEW_LINE print ( countPoints ( n , points ) ) NEW_LINE DEDENT
X_low , Y_up = map ( int , input ( ) . split ( ) ) NEW_LINE value = X_low NEW_LINE cnt = 0 NEW_LINE while ( value <= Y_up ) : NEW_LINE INDENT cnt += 1 NEW_LINE value *= 2 NEW_LINE DEDENT print ( cnt ) NEW_LINE
sticks = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ; NEW_LINE def countSticks ( string , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ ord ( string [ i ] ) - ord ( '0' ) ] ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "56" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countSticks ( string , n ) ) ; NEW_LINE DEDENT
T = int ( input ( ) ) NEW_LINE for t in range ( 0 , T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ctr = 0 NEW_LINE maxi = max ( a ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if a [ i ] < a [ i - 1 ] and a [ i - 1 ] > a [ i - 2 ] : NEW_LINE INDENT ctr += 1 NEW_LINE if i != n - 1 : NEW_LINE INDENT a [ i ] = max ( a [ i - 1 ] , a [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( ctr ) NEW_LINE for item in a : NEW_LINE INDENT print ( item , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def command ( brr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 ; res = arr [ 0 ] ; curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE
MAX = 26 ; NEW_LINE def maxLength ( str , len ) : NEW_LINE INDENT res = 0 ; NEW_LINE lastPos = [ 0 ] * MAX ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT lastPos [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT C = ord ( str [ i ] ) - ord ( ' a ' ) ; NEW_LINE if ( lastPos [ C ] != - 1 ) : NEW_LINE INDENT res = max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; NEW_LINE DEDENT lastPos [ C ] = i ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geeksforgeeks " ; NEW_LINE len = len ( str ) ; NEW_LINE print ( maxLength ( str , len ) ) ; NEW_LINE DEDENT
MAX = 1000000 NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 ; NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k != 1 ) : NEW_LINE INDENT return j ; NEW_LINE DEDENT DEDENT DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2795 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 59173 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1922 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5041 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Odd_Sum ( n ) : NEW_LINE INDENT total = ( n + 1 ) // 2 NEW_LINE odd = total * total NEW_LINE return odd NEW_LINE DEDENT def Even_Sum ( n ) : NEW_LINE INDENT total = n // 2 NEW_LINE even = total * ( total + 1 ) NEW_LINE return even NEW_LINE DEDENT def sumLtoR ( L , R ) : NEW_LINE INDENT odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) NEW_LINE even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT L = 1 ; R = 5 NEW_LINE print ( sumLtoR ( L , R ) ) NEW_LINE
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 ; upCost = 30 NEW_LINE lowQuant = 5 ; upQuant = 12 ; r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def Log2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return false ; NEW_LINE DEDENT return ( math . log10 ( x ) / math . log10 ( 2 ) ) ; NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( Log2 ( n ) ) == math . floor ( Log2 ( n ) ) ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def longLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len1 + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Longest ▁ length ▁ subsequence ▁ = " , longLenSub ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n ; NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE DEDENT
def f3 ( n ) : NEW_LINE INDENT a = b = c = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c = ( a + b + c + 1 ) % 100000007 , a , b NEW_LINE DEDENT return a NEW_LINE DEDENT def f5 ( n ) : NEW_LINE INDENT a = b = c = d = e = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c , d , e = ( a + b + c + d + e + 1 ) % 100000007 , a , b , c , d NEW_LINE DEDENT return a NEW_LINE DEDENT while 1 : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : break NEW_LINE ans = 1 NEW_LINE num = " _ " NEW_LINE cnt = 1 NEW_LINE for n in s + " _ " : NEW_LINE INDENT if n == num : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if num in "80" : NEW_LINE INDENT ans = ans * f3 ( cnt ) % 100000007 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * f5 ( cnt ) % 100000007 NEW_LINE DEDENT num = n NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE
n = input ( ) . strip ( ) NEW_LINE l = len ( n ) NEW_LINE x = [ 0 ] * l NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT x [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x [ i ] = x [ i - 1 ] NEW_LINE DEDENT if n [ i ] == n [ i + 1 ] : NEW_LINE INDENT x [ i ] += 1 ; NEW_LINE DEDENT DEDENT for m in range ( int ( input ( ) ) ) : NEW_LINE INDENT y , z = map ( int , input ( ) . split ( ) ) NEW_LINE if y == 1 : NEW_LINE INDENT print ( x [ z - 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x [ z - 2 ] - x [ y - 2 ] ) NEW_LINE DEDENT DEDENT
def solve ( ) : NEW_LINE INDENT from sys import stdin NEW_LINE f_i = stdin NEW_LINE def rec ( i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT tray = cups [ n - i ] NEW_LINE if tray == ' A ' : NEW_LINE INDENT return rec ( i - 1 ) NEW_LINE DEDENT elif tray == ' B ' : NEW_LINE INDENT return 2 * 3 ** ( i - 1 ) - 1 - rec ( i - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return rec ( i - 1 ) + 2 * 3 ** ( i - 1 ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n , m = map ( int , f_i . readline ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT cups = [ None ] * n NEW_LINE for tray in ' ABC ' : NEW_LINE INDENT itr = map ( int , f_i . readline ( ) . split ( ) ) NEW_LINE next ( itr ) NEW_LINE for i in itr : NEW_LINE INDENT cups [ i - 1 ] = tray NEW_LINE DEDENT DEDENT num = rec ( n ) NEW_LINE ans = min ( num , 3 ** n - 1 - num ) NEW_LINE if ans <= m : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT solve ( ) NEW_LINE
MAX = 100000 NEW_LINE def prints ( g1 , a , g2 , b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT print ( g1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " and ▁ " , end = " " ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( g2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT def checksum ( g1 , a , g2 , b ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( 0 , a , 1 ) : NEW_LINE INDENT x += g1 [ i ] NEW_LINE DEDENT for i in range ( b ) : NEW_LINE INDENT x -= g2 [ i ] NEW_LINE DEDENT return ( x == 0 ) NEW_LINE DEDENT def formgroups ( arr , x , g1 , a , g2 , b , n ) : NEW_LINE INDENT if ( x == n ) : NEW_LINE INDENT if ( checksum ( g1 , a , g2 , b ) ) : NEW_LINE INDENT prints ( g1 , a , g2 , b ) NEW_LINE DEDENT return NEW_LINE DEDENT g1 [ a ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) NEW_LINE g2 [ b ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 9 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE g1 = [ 0 for i in range ( MAX ) ] NEW_LINE g2 = [ 0 for i in range ( MAX ) ] NEW_LINE formgroups ( arr , 0 , g1 , 0 , g2 , 0 , n ) NEW_LINE DEDENT
def cutRibbon ( ) : NEW_LINE INDENT arr = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE length = arr [ 0 ] NEW_LINE arr = sorted ( arr [ 1 : 4 ] , reverse = False ) NEW_LINE if ( length % arr [ 0 ] == 0 ) : NEW_LINE INDENT print ( int ( length / arr [ 0 ] ) ) NEW_LINE return NEW_LINE DEDENT ans = 0 NEW_LINE if ( arr [ 0 ] == arr [ 1 ] ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( int ( length / arr [ 2 ] ) + 1 ) : NEW_LINE INDENT check = length - i * arr [ 2 ] NEW_LINE if ( check >= 0 and check % arr [ 0 ] == 0 ) : NEW_LINE INDENT k = int ( check / arr [ 0 ] ) NEW_LINE ans = max ( ans , k + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( int ( length / arr [ 2 ] ) + 1 ) : NEW_LINE INDENT for j in range ( int ( length / arr [ 1 ] ) + 1 ) : NEW_LINE INDENT check = length - i * arr [ 2 ] - j * arr [ 1 ] NEW_LINE if ( check >= 0 and check % arr [ 0 ] == 0 ) : NEW_LINE INDENT k = int ( check / arr [ 0 ] ) NEW_LINE ans = max ( ans , k + i + j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT cutRibbon ( ) NEW_LINE
def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( vec [ i ] == 1 ) : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( vec [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = [ 0 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE n = len ( input ) NEW_LINE print ( maxSubseq ( input , n ) ) NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT for j in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , - 1 , 0 , 0 ] , [ - 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( countPaths ( maze ) ) NEW_LINE DEDENT
import math NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True ; NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( 0 , int ( math . sqrt ( N ) ) , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if ( c > int ( math . sqrt ( N ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( not isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT print ( " Prime ▁ Number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Prime ▁ Number " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 121 NEW_LINE isPrime ( N ) NEW_LINE DEDENT
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE a = x2 - x1 NEW_LINE b = y2 - y1 NEW_LINE print ( x2 - b , y2 + a , x1 - b , y1 + a ) NEW_LINE
def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is " , lps ( seq , 0 , n - 1 ) ) NEW_LINE DEDENT
def findLength ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT st = "123123" NEW_LINE print ( " Length ▁ of ▁ the ▁ substring ▁ is " , findLength ( st , len ( st ) ) ) NEW_LINE
def prints ( a , n , ind ) : NEW_LINE INDENT i = ind NEW_LINE while i < n + ind : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = len ( a ) ; NEW_LINE prints ( a , n , 3 ) ; NEW_LINE
def prints ( a , n , ind ) : NEW_LINE INDENT b = [ None ] * 2 * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT b [ i ] = b [ n + i ] = a [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT i = ind NEW_LINE while i < n + ind : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) ; NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = len ( a ) ; NEW_LINE prints ( a , n , 3 ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE e = 0 NEW_LINE o = 0 NEW_LINE for i in input ( ) . strip ( ) . split ( ' * ' ) : NEW_LINE INDENT l = len ( i ) NEW_LINE e += l // 2 NEW_LINE o += l % 2 NEW_LINE DEDENT print ( min ( o + e + min ( e , a , b ) , b + a ) ) NEW_LINE DEDENT solve ( ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ [ ] for _ in [ 0 ] * n ] NEW_LINE def f ( i , x ) : NEW_LINE INDENT print ( ' . ' * x + a [ i ] ) NEW_LINE for j in b [ i ] : NEW_LINE INDENT f ( j , x + 1 ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT c = int ( input ( ) ) NEW_LINE a += [ input ( ) ] NEW_LINE if c != 0 : b [ c - 1 ] += [ i ] NEW_LINE DEDENT f ( 0 , 0 ) NEW_LINE
v1 , v2 = map ( int , input ( ) . split ( ) ) NEW_LINE t , d = map ( int , input ( ) . split ( ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( t ) : NEW_LINE INDENT sum += min ( v1 + d * i , v2 + d * ( t - i - 1 ) ) NEW_LINE DEDENT print ( sum ) NEW_LINE
n = int ( input ( ) ) NEW_LINE Sherlock = list ( input ( ) ) NEW_LINE Moriarty = sorted ( list ( input ( ) ) ) NEW_LINE copySherlock = [ digit for digit in Sherlock ] NEW_LINE copyMoriarty = [ digit for digit in Moriarty ] NEW_LINE minHits = 0 NEW_LINE maxHits = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if Moriarty [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if Moriarty [ j ] >= Sherlock [ i ] : NEW_LINE INDENT Moriarty [ j ] = - 1 NEW_LINE Sherlock [ i ] = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if Moriarty [ i ] != - 1 : NEW_LINE INDENT minHits += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if copyMoriarty [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if copyMoriarty [ j ] > copySherlock [ i ] : NEW_LINE INDENT maxHits += 1 NEW_LINE copyMoriarty [ j ] = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( minHits ) NEW_LINE print ( maxHits ) NEW_LINE
import numpy as np NEW_LINE a = np . vectorize ( int ) ( input ( ) . split ( ) ) NEW_LINE cnt2 = np . vectorize ( lambda x : int ( ( np . max ( a ) - x ) / 2 ) ) ( a ) NEW_LINE cnt1 = np . max ( a ) - a - 2 * cnt2 NEW_LINE print ( sum ( cnt2 ) + [ 0 , 2 , 1 ] [ sum ( cnt1 ) ] ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( j + 1 ) : NEW_LINE INDENT if k == 0 or k == j : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE print ( ) NEW_LINE bin ( 3 ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( x for x in range ( 1000 ) if ( x % 3 == 0 or x % 5 == 0 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
input ( ) NEW_LINE S = input ( ) NEW_LINE A = S . count NEW_LINE print ( '1 ▁ ' * A ( ' n ' ) + '0 ▁ ' * A ( ' z ' ) ) NEW_LINE
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b * 2 - a ) NEW_LINE
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while n > 0 : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE DEDENT
def productDiagonals ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] ; NEW_LINE product = product * arr [ i ] [ n - i - 1 ] ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT product = product // arr [ n // 2 ] [ n // 2 ] ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 7 , 4 , 2 ] , [ 2 , 2 , 2 , 1 ] ] ; NEW_LINE print ( productDiagonals ( arr1 , 4 ) ) ; NEW_LINE arr2 = [ [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 2 , 1 , 2 , 1 , 2 ] ] ; NEW_LINE print ( productDiagonals ( arr2 , 5 ) ) ; NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE dic = { 0 : 0 , 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 , 6 : 0 , 7 : 0 , 8 : 0 , 9 : 0 } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c = int ( input ( ) ) NEW_LINE dic [ c ] += 1 NEW_LINE DEDENT for v in dic . values ( ) : NEW_LINE INDENT print ( ' * ' * v if v != 0 else ' - ' ) NEW_LINE DEDENT DEDENT
def getSecondMostFreq ( str ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first , second = 0 , 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] > count [ first ] : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return chr ( second ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE res = getSecondMostFreq ( str ) NEW_LINE if res != ' \ 0' : NEW_LINE INDENT print ( " Second ▁ most ▁ frequent ▁ char ▁ is " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ second ▁ most ▁ frequent ▁ character " ) NEW_LINE DEDENT DEDENT
a = [ 0 ] * 4001 NEW_LINE for i in range ( 2001 ) : a [ i ] = a [ 4000 - i ] = ( i + 3 ) * ( i + 2 ) * ( i + 1 ) // 6 - 4 * a [ i - 1001 ] * ( i > 999 ) NEW_LINE while 1 : NEW_LINE INDENT try : print ( a [ int ( input ( ) ) ] ) NEW_LINE except : break NEW_LINE DEDENT
def mySort ( arr , n ) : NEW_LINE INDENT arr1 = arr [ : n // 2 ] NEW_LINE arr2 = arr [ n // 2 : ] NEW_LINE arr1 . sort ( ) NEW_LINE arr2 . sort ( reverse = True ) NEW_LINE return arr1 + arr2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE arr = mySort ( arr , n ) NEW_LINE print ( " Modified ▁ Array ▁ : ▁ " ) NEW_LINE print ( arr ) NEW_LINE DEDENT
def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return flip if ( flip <= p + q ) else - 1 NEW_LINE DEDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p = 2 NEW_LINE q = 4 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , round ( sum ( n ) , 6 ) ) NEW_LINE
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr ) NEW_LINE oddArr = oddArr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] == False ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] == True ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def isSubtree ( self , s , t ) : NEW_LINE INDENT s_res = self . preorder ( s , True ) NEW_LINE t_res = self . preorder ( t , True ) NEW_LINE return t_res in s_res NEW_LINE DEDENT def preorder ( self , root , isLeft ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT if isLeft : NEW_LINE INDENT return " lnull " NEW_LINE DEDENT else : NEW_LINE INDENT return " rnull " NEW_LINE DEDENT DEDENT return " # " + str ( root . val ) + " ▁ " + self . preorder ( root . left , True ) + " ▁ " + self . preorder ( root . right , False ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 5 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 2 ) NEW_LINE subRoot = TreeNode ( 4 ) NEW_LINE subRoot . left = TreeNode ( 1 ) NEW_LINE subRoot . right = TreeNode ( 2 ) NEW_LINE out = sObj . isSubtree ( root , subRoot ) NEW_LINE print ( out ) NEW_LINE DEDENT
M = 1001 ; NEW_LINE MOD = 998244353 ; NEW_LINE dp = [ [ - 1 ] * M ] * M NEW_LINE def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] ; NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) ; NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; NEW_LINE dp [ idx ] [ diff ] = ans % MOD ; NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 0 NEW_LINE print ( M * solve ( 2 , 0 , N , M , K ) ) NEW_LINE DEDENT
import eulerlib , math NEW_LINE def compute ( ) : NEW_LINE INDENT NUM_SPHERES = 21 NEW_LINE sphereradii = [ ( i + 30 ) * 1000 for i in range ( NUM_SPHERES ) ] NEW_LINE minlength = [ [ None ] * ( 2 ** NUM_SPHERES ) for _ in range ( NUM_SPHERES ) ] NEW_LINE def find_minimum_length ( currentsphereindex , setofspheres ) : NEW_LINE INDENT if setofspheres & ( 1 << currentsphereindex ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if minlength [ currentsphereindex ] [ setofspheres ] is None : NEW_LINE INDENT if eulerlib . popcount ( setofspheres ) == 1 : NEW_LINE INDENT result = sphereradii [ currentsphereindex ] NEW_LINE DEDENT else : NEW_LINE INDENT result = float ( " inf " ) NEW_LINE newsetofspheres = setofspheres ^ ( 1 << currentsphereindex ) NEW_LINE for i in range ( NUM_SPHERES ) : NEW_LINE INDENT if newsetofspheres & ( 1 << i ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT temp = math . sqrt ( ( sphereradii [ i ] + sphereradii [ currentsphereindex ] - 50000 ) * 200000 ) NEW_LINE temp += find_minimum_length ( i , newsetofspheres ) NEW_LINE result = min ( temp , result ) NEW_LINE DEDENT DEDENT minlength [ currentsphereindex ] [ setofspheres ] = result NEW_LINE DEDENT return minlength [ currentsphereindex ] [ setofspheres ] NEW_LINE DEDENT ans = min ( ( find_minimum_length ( i , ( 1 << NUM_SPHERES ) - 1 ) + sphereradii [ i ] ) for i in range ( NUM_SPHERES ) ) NEW_LINE return str ( int ( round ( ans ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t . sort ( ) NEW_LINE a , b = t [ 0 ] ** 2 + t [ 1 ] ** 2 , t [ 2 ] ** 2 NEW_LINE if a == b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = int ( input ( ) ) NEW_LINE p = int ( input ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE s = l / ( p + q ) NEW_LINE x = p * s NEW_LINE print ( x ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( l [ n ] - l [ n - 1 ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE t = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if - t [ i ] in freq : NEW_LINE INDENT ans += freq [ - t [ i ] ] NEW_LINE DEDENT if t [ i ] in freq : NEW_LINE INDENT freq [ t [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ t [ i ] ] = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
pya = int ( input ( ) ) NEW_LINE arre = [ ] NEW_LINE while pya : NEW_LINE INDENT pya -= 1 NEW_LINE arre . append ( input ( ) . lower ( ) ) NEW_LINE DEDENT oString = input ( ) NEW_LINE lowString = oString . lower ( ) NEW_LINE letter1 = input ( ) [ 0 ] . lower ( ) NEW_LINE letter2 = ' a ' if letter1 . lower ( ) != ' a ' else ' b ' NEW_LINE valid = [ 0 for i in range ( len ( oString ) ) ] NEW_LINE setcito = set ( ) NEW_LINE for x in arre : NEW_LINE INDENT if lowString . find ( x ) >= 0 : NEW_LINE INDENT wat = 0 NEW_LINE while True : NEW_LINE INDENT index = lowString . find ( x , wat ) NEW_LINE if index < 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( index , index + len ( x ) ) : NEW_LINE INDENT setcito . add ( i ) NEW_LINE DEDENT wat = index + 1 NEW_LINE DEDENT DEDENT DEDENT oString = list ( oString ) NEW_LINE for i in setcito : NEW_LINE INDENT letter = letter1 if lowString [ i ] != letter1 else letter2 NEW_LINE oString [ i ] = letter if oString [ i ] . islower ( ) else letter . upper ( ) NEW_LINE DEDENT for x in oString : NEW_LINE INDENT print ( x , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE
import sys NEW_LINE import math NEW_LINE from fractions import gcd NEW_LINE from itertools import accumulate NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return a * b // gcd ( a , b ) NEW_LINE DEDENT def combination_count ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) NEW_LINE DEDENT def permutations_count ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) // math . factorial ( n - r ) NEW_LINE DEDENT big_prime = 1000000007 NEW_LINE N = int ( sys . stdin . readline ( ) ) NEW_LINE S = list ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE Wn = [ 0 ] * N NEW_LINE En = [ 0 ] * N NEW_LINE Wc = 0 NEW_LINE Ec = 0 NEW_LINE for i , s in enumerate ( S ) : NEW_LINE INDENT if s == " W " : NEW_LINE INDENT Wc += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Ec += 1 NEW_LINE DEDENT Wn [ i ] = Wc NEW_LINE En [ i ] = Ec NEW_LINE DEDENT ans = 10 ** 10 NEW_LINE Wn = [ 0 ] + Wn NEW_LINE En = [ 0 ] + En NEW_LINE for i , ( w , e ) in enumerate ( zip ( Wn [ 1 : : ] , En [ 1 : : ] ) ) : NEW_LINE INDENT ans = min ( Wn [ i ] + En [ N ] - En [ i + 1 ] , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE chips = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE for num in chips : NEW_LINE INDENT if num % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT print ( min ( even , odd ) ) NEW_LINE
from math import sqrt , ceil NEW_LINE N = 10100000 NEW_LINE temp = [ True ] * ( N + 1 ) NEW_LINE temp [ 0 ] = temp [ 1 ] = False NEW_LINE for i in range ( 2 , ceil ( sqrt ( N + 1 ) ) ) : NEW_LINE INDENT if temp [ i ] : NEW_LINE INDENT temp [ i + i : : i ] = [ False ] * ( len ( temp [ i + i : : i ] ) ) NEW_LINE DEDENT DEDENT quadruplet = [ True , False , True , False , False , False , True , False , True ] NEW_LINE while True : NEW_LINE INDENT try : n = int ( input ( ) ) NEW_LINE except : break NEW_LINE for i in range ( n , 9 , - 1 ) : NEW_LINE INDENT if temp [ i ] and temp [ i - 8 : i + 1 ] == quadruplet : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = [ ] NEW_LINE s = 0 NEW_LINE l = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] != 1 : NEW_LINE INDENT s = s + a [ i ] NEW_LINE t = i + 1 - l NEW_LINE p = s - 1 * t NEW_LINE if p % 2 == 0 : NEW_LINE INDENT r . append ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l = l + 1 NEW_LINE if len ( r ) == 0 : NEW_LINE INDENT r . append ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT q = r [ - 1 ] NEW_LINE r . append ( q ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( r ) ) : NEW_LINE INDENT print ( r [ i ] ) NEW_LINE DEDENT
def powerOfTwo ( n ) : NEW_LINE INDENT return ( not ( n & n - 1 ) ) NEW_LINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = 9 NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 ; vert = 1 NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT m = 6 ; n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return math . gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( not ( p % a ) and math . gcd ( a , p // a ) == G ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " , G , end = " " ) NEW_LINE print ( " ▁ & ▁ LCM ▁ " , L , end = " " ) NEW_LINE print ( " ▁ = ▁ " , countPairs ( G , L ) ) NEW_LINE DEDENT
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for x in range ( 3 ) ] for y in range ( 3 ) ] ; NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 ; NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return a ; NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; NEW_LINE DEDENT power ( F , int ( n / 2 ) ) ; NEW_LINE F = multiply ( F , F ) ; NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT F = multiply ( F , M ) ; NEW_LINE DEDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; NEW_LINE DEDENT def findNthTerm ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; NEW_LINE return power ( F , n - 2 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( " F ( 5 ) ▁ is " , findNthTerm ( n ) ) ; NEW_LINE
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT broken_num = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if ( nums [ i ] > nums [ i + 1 ] ) : NEW_LINE INDENT broken_num += 1 NEW_LINE if broken_num >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] ) : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT  if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossibility ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( array [ i ] > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if ( sum > mid ) : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if ( count <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += array [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( check ( mid , array , n , K ) ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( array ) NEW_LINE K = 3 NEW_LINE print ( solve ( array , n , K ) ) NEW_LINE DEDENT
from collections import Counter NEW_LINE while True : NEW_LINE INDENT m , n = ( int ( s ) for s in input ( ) . split ( ) ) NEW_LINE if not m : NEW_LINE INDENT break NEW_LINE DEDENT objs = [ int ( input ( ) , 2 ) for i in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( 1 << m ) for i in range ( 1 << m ) ] NEW_LINE bits = [ 1 << i for i in range ( m ) ] NEW_LINE for mask in reversed ( range ( 1 << m ) ) : NEW_LINE INDENT s = Counter ( obj & mask for obj in objs ) NEW_LINE for masked , value in s . items ( ) : NEW_LINE INDENT if value > 1 : NEW_LINE INDENT dp [ mask ] [ masked ] = min ( max ( dp [ mask | b ] [ masked ] , dp [ mask | b ] [ masked | b ] ) + 1 for b in bits if not b & mask ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ 0 ] ) NEW_LINE DEDENT
test = int ( input ( ) ) NEW_LINE for i in range ( test ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE c = ( min ( a , b ) * 2 ) ** 2 NEW_LINE d = ( max ( a , b ) ** 2 ) NEW_LINE print ( max ( c , d ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = " YES " NEW_LINE zero = [ ] NEW_LINE temp = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] == 0 : NEW_LINE INDENT zero . append ( a [ i ] ) NEW_LINE continue NEW_LINE DEDENT x = a [ i ] - b [ i ] NEW_LINE if temp == - 1 : NEW_LINE INDENT temp = x NEW_LINE DEDENT if x < 0 or x != temp : NEW_LINE INDENT ans = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT if n == len ( zero ) : NEW_LINE INDENT temp = max ( zero ) NEW_LINE DEDENT for i in zero : NEW_LINE INDENT if i <= temp : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE t -= 1 NEW_LINE DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) ; NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT N = "735" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE
a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE list = [ ] NEW_LINE for i in range ( a [ 0 ] ) : NEW_LINE INDENT list . append ( [ ] ) NEW_LINE DEDENT for i in range ( a [ 1 ] ) : NEW_LINE INDENT cmd = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if cmd [ 0 ] == 0 : NEW_LINE INDENT list [ cmd [ 1 ] ] . append ( cmd [ 2 ] ) NEW_LINE DEDENT elif cmd [ 0 ] == 1 : NEW_LINE INDENT maped = map ( str , list [ cmd [ 1 ] ] ) NEW_LINE output = " ▁ " . join ( maped ) NEW_LINE print ( output ) NEW_LINE DEDENT elif cmd [ 0 ] == 2 : NEW_LINE INDENT list [ cmd [ 1 ] ] = [ ] NEW_LINE DEDENT DEDENT
n = input ( ) NEW_LINE num = input ( ) . split ( ) NEW_LINE even = 0 NEW_LINE for i in num : NEW_LINE INDENT if int ( i ) % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if even == 1 : NEW_LINE INDENT for i in num : NEW_LINE INDENT if int ( i ) % 2 == 0 : NEW_LINE INDENT print ( num . index ( i ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in num : NEW_LINE INDENT if int ( i ) % 2 == 1 : NEW_LINE INDENT print ( num . index ( i ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE X = " abcd " ; NEW_LINE Y = " bcde " ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE while a : n , a = a , n % a NEW_LINE DEDENT print ( [ ' No ' , ' Yes ' ] [ n == 1 ] ) NEW_LINE
def isPrime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True if ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return true NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
from math import sqrt NEW_LINE def isPrime ( x ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT return 3 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 ; NEW_LINE print ( minimumCost ( n ) ) ; NEW_LINE DEDENT
def snoob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT rightOne = x & - ( x ) NEW_LINE nextHigherOneBit = x + int ( rightOne ) NEW_LINE rightOnesPattern = x ^ int ( nextHigherOneBit ) NEW_LINE rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) NEW_LINE rightOnesPattern = int ( rightOnesPattern ) >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT x = 156 NEW_LINE print ( " Next ▁ higher ▁ number ▁ with ▁ " + " same ▁ number ▁ of ▁ set ▁ bits ▁ is " , snoob ( x ) ) NEW_LINE
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i // j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE result = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinLength ( arr , n ) ) ; NEW_LINE
INT_MAX = 99999999999 NEW_LINE def getLevenstein ( inpt ) : NEW_LINE INDENT revInput = inpt [ : : - 1 ] NEW_LINE n = len ( inpt ) NEW_LINE dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if inpt [ i - 1 ] == revInput [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = INT_MAX NEW_LINE i , j = n , 0 NEW_LINE while i >= 0 : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if i < n : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT inpt = " myfirstgeekarticle " NEW_LINE print ( getLevenstein ( inpt ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT LIMIT = 12000 NEW_LINE minsumproduct = [ None ] * ( LIMIT + 1 ) NEW_LINE def factorize ( n , remain , maxfactor , sum , terms ) : NEW_LINE INDENT if remain == 1 : NEW_LINE INDENT if sum > n : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT terms += n - sum NEW_LINE if terms <= LIMIT and ( minsumproduct [ terms ] is None or n < minsumproduct [ terms ] ) : NEW_LINE INDENT minsumproduct [ terms ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , maxfactor + 1 ) : NEW_LINE INDENT if remain % i == 0 : NEW_LINE INDENT factor = i NEW_LINE factorize ( n , remain // factor , min ( factor , maxfactor ) , sum + factor , terms + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , LIMIT * 2 + 1 ) : NEW_LINE INDENT factorize ( i , i , i , 0 , 0 ) NEW_LINE DEDENT ans = sum ( set ( minsumproduct [ 2 : ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE fact , fact_inv , inv = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) NEW_LINE def main ( ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i % MOD NEW_LINE DEDENT fact_inv [ N ] = pow ( fact [ N ] , MOD - 2 , MOD ) NEW_LINE for i in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT fact_inv [ i ] = fact_inv [ i + 1 ] * ( i + 1 ) % MOD NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT inv [ i ] = fact_inv [ i ] * fact [ i - 1 ] % MOD NEW_LINE DEDENT b , s = [ 0 ] * N , [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s [ i ] = ( s [ i - 1 ] + inv [ i ] ) % MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT b [ i ] = ( s [ i + 1 ] + s [ N - i ] - 1 ) % MOD NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = ( ans + a [ i ] * b [ i ] ) % MOD NEW_LINE DEDENT ans = ans * fact [ N ] % MOD NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . items = [ ] NEW_LINE DEDENT def isEmpty ( self ) : NEW_LINE INDENT return self . items == [ ] NEW_LINE DEDENT def add ( self , item ) : NEW_LINE INDENT self . items . append ( item ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT return self . items . pop ( 0 ) NEW_LINE DEDENT def front ( self ) : NEW_LINE INDENT return self . items [ 0 ] NEW_LINE DEDENT def printQueue ( self ) : NEW_LINE INDENT for i in self . items : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT def reverseQueue ( q ) : NEW_LINE INDENT if ( q . isEmpty ( ) ) : NEW_LINE INDENT return NEW_LINE DEDENT data = q . front ( ) ; NEW_LINE q . pop ( ) ; NEW_LINE reverseQueue ( q ) NEW_LINE q . add ( data ) NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . add ( 56 ) NEW_LINE q . add ( 27 ) NEW_LINE q . add ( 30 ) NEW_LINE q . add ( 45 ) NEW_LINE q . add ( 85 ) NEW_LINE q . add ( 92 ) NEW_LINE q . add ( 58 ) NEW_LINE q . add ( 80 ) NEW_LINE q . add ( 90 ) NEW_LINE q . add ( 100 ) NEW_LINE reverseQueue ( q ) NEW_LINE q . printQueue ( ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE c = 0 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT c += 1 NEW_LINE if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min = MAX + 2 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 if ( max == - 1 ) else ( max - min ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( arr , n ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Difference ▁ is ▁ " , res ) NEW_LINE DEDENT DEDENT
def find ( x , par_lst ) : NEW_LINE INDENT if par_lst [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT root = find ( par_lst [ x ] , par_lst ) NEW_LINE par_lst [ x ] = root NEW_LINE return root NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE edges = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b , d = map ( int , input ( ) . split ( " , " ) ) NEW_LINE edges . append ( ( d // 100 - 1 , a , b ) ) NEW_LINE DEDENT edges . sort ( ) NEW_LINE par_lst = [ i for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for d , a , b in edges : NEW_LINE INDENT par_a = find ( a , par_lst ) NEW_LINE par_b = find ( b , par_lst ) NEW_LINE if par_a != par_b : NEW_LINE INDENT par_lst [ par_a ] = par_b NEW_LINE ans += d NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
li = [ ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , 371 ) : NEW_LINE INDENT temp = [ ] NEW_LINE p , q = i , i NEW_LINE count = 0 NEW_LINE while p != 0 : NEW_LINE INDENT p //= 10 NEW_LINE count += 1 NEW_LINE DEDENT if count == 1 : NEW_LINE INDENT li . append ( i ) NEW_LINE DEDENT if count == 2 : NEW_LINE INDENT temp = [ ] NEW_LINE while q != 0 : NEW_LINE INDENT x = q % 10 NEW_LINE q //= 10 NEW_LINE temp . append ( x ) NEW_LINE DEDENT li = li + temp [ : : - 1 ] NEW_LINE DEDENT if count == 3 : NEW_LINE INDENT temp = [ ] NEW_LINE while q != 0 : NEW_LINE INDENT x = q % 10 NEW_LINE q //= 10 NEW_LINE temp . append ( x ) NEW_LINE DEDENT li = li + temp [ : : - 1 ] NEW_LINE DEDENT DEDENT li . pop ( ) NEW_LINE li . pop ( ) NEW_LINE n = int ( input ( ' ' ) ) NEW_LINE print ( li [ n - 1 ] ) NEW_LINE
def distinctSubstring ( P , N ) : NEW_LINE INDENT S = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * 26 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE if ( freq [ pos ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S [ s ] = 1 NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubstring ( S , N ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( ( n - k ) % ( k - 1 ) == 0 ) : NEW_LINE INDENT ans = ( n - k ) // ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n - k ) // ( k - 1 ) + 1 NEW_LINE DEDENT print ( ans + 1 ) NEW_LINE
import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) NEW_LINE def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = INT_MAX ; NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) ; NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT temp . append ( a [ j ] ) ; NEW_LINE DEDENT DEDENT maxDiff = INT_MIN ; NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT DEDENT return minDiff ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE k = 2 ; NEW_LINE a = [ 3 , 7 , 8 , 10 , 14 ] ; NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) ; NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] ; NEW_LINE i = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 5 , 9 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE difference ( arr , n ) ; NEW_LINE DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; NEW_LINE i = 1 NEW_LINE while ( i <= K // 2 and i != ( K - i ) ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K - i ] NEW_LINE i += 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) / 2 ) ; NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE
def f ( a ) : NEW_LINE INDENT for x in [ ' b ' , ' w ' ] : NEW_LINE INDENT if a [ 0 : : 4 ] . count ( x ) == 3 or a [ 2 : 7 : 2 ] . count ( x ) == 3 : return x NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if a [ i * 3 : i * 3 + 3 ] . count ( x ) == 3 or a [ i : : 3 ] . count ( x ) == 3 : return x NEW_LINE DEDENT DEDENT return ' NA ' NEW_LINE DEDENT while 1 : NEW_LINE INDENT a = list ( input ( ) ) NEW_LINE if len ( a ) == 1 : break NEW_LINE a += list ( input ( ) ) + list ( input ( ) ) NEW_LINE print ( f ( a ) ) NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " , maxOnesIndex ( arr , n ) ) NEW_LINE
def minimumX ( n , k ) : NEW_LINE INDENT ans = 10 ** 18 NEW_LINE for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans = min ( ans , i + ( n / i ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , k = 4 , 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n , k = 5 , 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE b >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT a = 10123465234878998 ; NEW_LINE b = 65746311545646431 ; NEW_LINE m = 10005412336548794 ; NEW_LINE print ( moduloMultiplication ( a , b , m ) ) ; NEW_LINE
def searchnode ( i , u , path ) : NEW_LINE INDENT r = 1 NEW_LINE u [ i ] = 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if path [ i ] [ j ] and ( not u [ j ] ) : NEW_LINE INDENT r += searchnode ( j , u , path ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : break NEW_LINE strs = list ( map ( lambda x : [ x [ 0 ] , x [ - 1 ] ] , [ input ( ) for i in range ( n ) ] ) ) NEW_LINE ss , ee = [ 0 ] * 26 , [ 0 ] * 26 NEW_LINE path = [ [ 0 ] * 26 for _ in range ( 27 ) ] NEW_LINE u = [ 0 ] * 26 NEW_LINE for s , e in strs : NEW_LINE INDENT ss [ ord ( s ) - ord ( ' a ' ) ] += 1 NEW_LINE ee [ ord ( e ) - ord ( ' a ' ) ] += 1 NEW_LINE path [ ord ( s ) - ord ( ' a ' ) ] [ ord ( e ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if [ 1 for s1 , e1 in zip ( ss , ee ) if s1 - e1 ] : NEW_LINE INDENT print ( " NG " ) NEW_LINE continue NEW_LINE DEDENT print ( " OK " if len ( [ 1 for s in ss if s ] ) == searchnode ( ord ( s ) - ord ( ' a ' ) , u , path ) else " NG " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ma = max ( a ) NEW_LINE mai = a . index ( ma ) NEW_LINE mi = min ( a ) NEW_LINE mii = a . index ( mi ) NEW_LINE ans = [ ] NEW_LINE if abs ( ma ) >= abs ( mi ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] += ma NEW_LINE ans . append ( ( mai + 1 , i + 1 ) ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] += a [ i - 1 ] NEW_LINE ans . append ( ( i , i + 1 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] += mi NEW_LINE ans . append ( ( mii + 1 , i + 1 ) ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] += a [ i + 1 ] NEW_LINE ans . append ( ( i + 2 , i + 1 ) ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : print ( * i ) NEW_LINE
def checkPalindrome ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE length -= 1 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if string [ i ] != string [ length ] : NEW_LINE INDENT return False NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printSolution ( partitions ) : NEW_LINE INDENT for i in range ( len ( partitions ) ) : NEW_LINE INDENT for j in range ( len ( partitions [ i ] ) ) : NEW_LINE INDENT print ( partitions [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def addStrings ( v , s , temp , index ) : NEW_LINE INDENT length = len ( s ) NEW_LINE string = " " NEW_LINE current = temp [ : ] NEW_LINE if index == 0 : NEW_LINE INDENT temp = [ ] NEW_LINE DEDENT for i in range ( index , length ) : NEW_LINE INDENT string += s [ i ] NEW_LINE if checkPalindrome ( string ) : NEW_LINE INDENT temp . append ( string ) NEW_LINE if i + 1 < length : NEW_LINE INDENT addStrings ( v , s , temp [ : ] , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( temp ) NEW_LINE DEDENT temp = current NEW_LINE DEDENT DEDENT DEDENT def partition ( s , v ) : NEW_LINE INDENT temp = [ ] NEW_LINE addStrings ( v , s , temp [ : ] , 0 ) NEW_LINE printSolution ( v ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " NEW_LINE partitions = [ ] NEW_LINE partition ( s , partitions ) NEW_LINE DEDENT
MOD = 100000007 NEW_LINE def dp ( n , k ) : NEW_LINE INDENT if tbl [ n ] [ k ] : return tbl [ n ] [ k ] NEW_LINE if ( k << 1 ) > n : k = n - k NEW_LINE if k == 0 : ans = 1 NEW_LINE elif k == 1 : ans = n NEW_LINE else : ans = dp ( n - 1 , k ) + dp ( n - 1 , k - 1 ) NEW_LINE tbl [ n ] [ k ] = ans % MOD NEW_LINE return tbl [ n ] [ k ] NEW_LINE DEDENT tbl = [ [ 0 for j in range ( 1001 ) ] for i in range ( 1001 ) ] NEW_LINE k = 0 NEW_LINE r , c , a1 , a2 , b1 , b2 = map ( int , input ( ) . split ( ) ) NEW_LINE dr = abs ( a1 - b1 ) NEW_LINE if dr > r - dr : dr = r - dr NEW_LINE if ( dr << 1 ) == r : k += 1 NEW_LINE dc = abs ( a2 - b2 ) NEW_LINE if dc > c - dc : dc = c - dc NEW_LINE if ( dc << 1 ) == c : k += 1 NEW_LINE print ( ( dp ( dr + dc , min ( dr , dc ) ) << k ) % MOD ) NEW_LINE
from collections import defaultdict NEW_LINE def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT numCount = [ 0 ] * ( k + 1 ) NEW_LINE for p in M : NEW_LINE INDENT if p <= k : NEW_LINE INDENT i = 1 NEW_LINE while p * i <= k : NEW_LINE INDENT numCount [ p * i ] += M [ p ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm , length = 0 , 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if numCount [ i ] > length : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if lcm == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM ▁ = ▁ { 0 } , ▁ Length ▁ = ▁ { 1 } " . format ( lcm , length ) ) NEW_LINE print ( " Indexes ▁ = ▁ " , end = " " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if lcm % arr [ i ] == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 14 NEW_LINE arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findSubsequence ( arr , n , k ) NEW_LINE DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = ( min ( odd1 , even2 ) + min ( odd2 , even1 ) ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 80 , 100 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , size ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE
MAX = 26 NEW_LINE def minimumAddition ( str1 , Len ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( Len ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT str1 = " geeksforgeeks " NEW_LINE Len = len ( str1 ) NEW_LINE print ( minimumAddition ( str1 , Len ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + min ( 10 - abs ( int ( a [ i ] ) - int ( b [ i ] ) ) , abs ( int ( a [ i ] ) - int ( b [ i ] ) ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
MAX = 32 NEW_LINE pow2 = [ 0 for i in range ( MAX ) ] NEW_LINE visited = [ False for i in range ( MAX ) ] NEW_LINE ans = [ ] NEW_LINE def power_2 ( ) : NEW_LINE INDENT an = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pow2 [ i ] = an NEW_LINE an *= 2 NEW_LINE DEDENT DEDENT def countSetBits ( x ) : NEW_LINE INDENT setBits = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE setBits += 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT point = 0 NEW_LINE value = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( visited [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT value += ( 1 << i ) NEW_LINE DEDENT num = num // 2 NEW_LINE DEDENT DEDENT ans . append ( value ) NEW_LINE DEDENT def solve ( n , k ) : NEW_LINE INDENT ans . append ( k ) NEW_LINE countk = countSetBits ( k ) NEW_LINE if ( pow2 [ countk ] < n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( pow2 [ countk ] - 1 ) : NEW_LINE INDENT add ( i ) NEW_LINE count += 1 NEW_LINE if ( count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE k = 5 NEW_LINE power_2 ( ) NEW_LINE solve ( n , k ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT isprimecache = eulerlib . list_primality ( 1000 ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for pratyush in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , r = map ( int , input ( ) . split ( ) ) NEW_LINE a = min ( r , n - 1 ) NEW_LINE ans = int ( ( a * ( a + 1 ) ) // 2 ) NEW_LINE if a != r : ans += 1 NEW_LINE print ( ans ) NEW_LINE DEDENT
import math as mt NEW_LINE MAX = 100001 NEW_LINE isPrime = [ 0 for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , mt . ceil ( mt . sqrt ( MAX ) ) ) : NEW_LINE INDENT if ( isPrime [ p ] == 0 ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if ( cnt1 > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 ) and ( isPrime [ a [ i ] + 1 ] == 0 ) ) : NEW_LINE INDENT print ( cnt1 + 1 ) NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT print ( a [ i ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT if ( cnt1 >= 2 ) : NEW_LINE INDENT print ( cnt1 ) NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( a [ i ] , " ▁ " , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT sieve ( ) NEW_LINE A = [ 2 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE findSubset ( A , n ) NEW_LINE
n , r , t = map ( int , input ( ) . split ( ) ) NEW_LINE speed = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE point = [ 0 ] * n NEW_LINE bottle = [ 0 ] * r NEW_LINE for i in range ( n ) : NEW_LINE INDENT point [ i ] = ( point [ i ] + speed [ i ] ) % r NEW_LINE bottle [ point [ i ] ] += 1 NEW_LINE DEDENT for _ in range ( t - 1 ) : NEW_LINE INDENT nums = [ 0 ] * r NEW_LINE for i in range ( n ) : NEW_LINE INDENT bottle [ point [ i ] ] -= 1 NEW_LINE point [ i ] = ( point [ i ] + speed [ i ] ) % r NEW_LINE nums [ point [ i ] ] += 1 NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT if bottle [ i ] < nums [ i ] : NEW_LINE INDENT bottle [ i ] = nums [ i ] NEW_LINE DEDENT bottle [ i ] += nums [ i ] NEW_LINE DEDENT DEDENT print ( sum ( bottle ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( input ( ) . replace ( ' Hoshino ' , ' Hoshina ' ) ) NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE mid = int ( mid ) NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) ; NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , 0 , n - 1 ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT if i + 1 > m : NEW_LINE INDENT ans = m NEW_LINE break NEW_LINE DEDENT m -= i + 1 NEW_LINE i += 1 NEW_LINE i %= n NEW_LINE DEDENT print ( ans ) NEW_LINE
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE print ( " YES " ) if ( modularSum ( arr , n , m ) ) else print ( " NO " ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( a [ b : e ] . count ( k ) ) NEW_LINE DEDENT
N , x = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE INF = ( 1 << 42 ) - 1 NEW_LINE cum = [ [ INF ] * N for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT cum [ i ] [ j ] = min ( cum [ i ] [ j - 1 ] , A [ j ] ) NEW_LINE DEDENT DEDENT ans = INF NEW_LINE for k in range ( N ) : NEW_LINE INDENT score = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if j - k >= 0 : NEW_LINE INDENT score += cum [ j - k ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT score += min ( cum [ 0 ] [ j ] , cum [ ( j - k ) % N ] [ - 1 ] ) NEW_LINE DEDENT DEDENT ans = min ( ans , k * x + score ) NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT d , w = map ( int , input ( ) . split ( ) ) NEW_LINE if d + w == 0 : break NEW_LINE pond = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] NEW_LINE ans = 0 NEW_LINE for left in range ( w - 1 ) : NEW_LINE INDENT for right in range ( w - 1 , left + 1 , - 1 ) : NEW_LINE INDENT for top in range ( d - 1 ) : NEW_LINE INDENT for under in range ( d - 1 , top + 1 , - 1 ) : NEW_LINE INDENT outh = 10 NEW_LINE outh = min ( outh , min ( pond [ top ] [ left : right + 1 ] ) ) NEW_LINE outh = min ( outh , min ( pond [ under ] [ left : right + 1 ] ) ) NEW_LINE zpond = list ( zip ( * pond ) ) NEW_LINE outh = min ( outh , min ( zpond [ left ] [ top : under ] ) ) NEW_LINE outh = min ( outh , min ( zpond [ right ] [ top : under ] ) ) NEW_LINE pondh = 0 NEW_LINE for i in range ( top + 1 , under ) : NEW_LINE INDENT pondh = max ( pondh , max ( pond [ i ] [ left + 1 : right ] ) ) NEW_LINE DEDENT if pondh < outh : NEW_LINE INDENT cap = outh * ( under - top - 1 ) * ( right - left - 1 ) - sum ( sum ( pond [ i ] [ left + 1 : right ] ) for i in range ( top + 1 , under ) ) NEW_LINE ans = max ( cap , ans ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
num , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE arr = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE different = set ( ) NEW_LINE temp = 0 NEW_LINE arr . sort ( ) NEW_LINE for x in arr : NEW_LINE INDENT if ( x % k != 0 or not x // k in different ) : NEW_LINE INDENT different . add ( x ) NEW_LINE DEDENT temp = max ( len ( different ) , temp ) NEW_LINE DEDENT print ( temp ) NEW_LINE
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE
def solve ( i , tight , sum_so_far , Sum , number , length ) : NEW_LINE INDENT if i == length : NEW_LINE INDENT if sum_so_far == Sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = dp [ i ] [ tight ] [ sum_so_far ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE for currdigit in range ( 0 , 10 ) : NEW_LINE INDENT currdigitstr = str ( currdigit ) NEW_LINE if not tight and currdigitstr > number [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT ntight = tight or currdigitstr < number [ i ] NEW_LINE nsum_so_far = sum_so_far + currdigit NEW_LINE ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , length ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT count , Sum = 0 , 4 NEW_LINE number = "100" NEW_LINE dp = [ [ [ - 1 for i in range ( 162 ) ] for j in range ( 2 ) ] for k in range ( 18 ) ] NEW_LINE print ( solve ( 0 , 0 , 0 , Sum , number , len ( number ) ) ) NEW_LINE DEDENT
total = 0 NEW_LINE num_cases = int ( input ( ) ) NEW_LINE for i in range ( num_cases ) : NEW_LINE INDENT line = input ( ) NEW_LINE if sum ( [ int ( x ) for x in line . split ( ) ] ) >= 2 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE
class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenOddLevelDifference ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while ( size > 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . left . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 7 ) NEW_LINE result = evenOddLevelDifference ( root ) NEW_LINE print ( " Difference ▁ between ▁ sums ▁ is " , result ) NEW_LINE DEDENT
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count ) : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE DEDENT return int ( number ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE
def printLastOccurrence ( a , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 7 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ a [ i ] ] == i ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE printLastOccurrence ( a , n ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if max ( s ) < 2 : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT else : NEW_LINE INDENT t = s . count ( 0 ) NEW_LINE print ( n - t + 1 ) NEW_LINE DEDENT DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE
import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE DEDENT index = 0 NEW_LINE mp = dict ( ) NEW_LINE for itr in sorted ( s ) : NEW_LINE INDENT index += 1 NEW_LINE mp [ itr ] = index NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT def query ( BIT , index , n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT ans = max ( ans , BIT [ index ] ) NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def update ( BIT , index , n ) : NEW_LINE INDENT x = query ( BIT , index - 1 , n ) NEW_LINE value = x + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def findLISLength ( arr , n ) : NEW_LINE INDENT coordinateCompression ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT update ( BIT , arr [ i ] , n ) NEW_LINE DEDENT ans = query ( BIT , n , n ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ans = findLISLength ( arr , n ) NEW_LINE print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ [ ] for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT a [ j ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT ans = False NEW_LINE for j in range ( 5 ) : NEW_LINE INDENT for k in range ( 5 ) : NEW_LINE INDENT if k != j : NEW_LINE INDENT cnt1 = 0 NEW_LINE cnt2 = 0 NEW_LINE cntno = 0 NEW_LINE for z in range ( n ) : NEW_LINE INDENT if a [ z ] [ j ] == 1 : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT if a [ z ] [ k ] == 1 : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT if a [ z ] [ j ] == 0 and a [ z ] [ k ] == 0 : NEW_LINE INDENT cntno += 1 NEW_LINE DEDENT DEDENT if cnt1 >= n // 2 and cnt2 >= n // 2 and cntno == 0 : NEW_LINE INDENT ans = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ans : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE innerlen = BASE ** CONSECUTIVE NEW_LINE ways = [ [ 1 ] + [ 0 ] * ( innerlen - 1 ) ] NEW_LINE for digits in range ( 1 , DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT newrow = [ ] NEW_LINE for prefix in range ( innerlen ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextdigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % ( BASE ** ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] NEW_LINE DEDENT DEDENT newrow . append ( sum ) NEW_LINE DEDENT ways . append ( newrow ) NEW_LINE DEDENT ans = ways [ - 1 ] [ 0 ] - ways [ - 2 ] [ 0 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) for c in str ( n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
arr = [ input ( ) , input ( ) , input ( ) , input ( ) ] NEW_LINE exit = False NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if exit : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( 3 ) : NEW_LINE INDENT countw = 0 NEW_LINE countb = 0 NEW_LINE if arr [ i ] [ j ] == " # " : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if arr [ i + 1 ] [ j ] == " # " : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if arr [ i ] [ j + 1 ] == " # " : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if arr [ i + 1 ] [ j + 1 ] == " # " : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if countw >= 3 or countb >= 3 : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not exit : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( len ( matrix ) - 1 ) : NEW_LINE INDENT for c in range ( len ( matrix [ 0 ] ) - 1 ) : NEW_LINE INDENT if matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT  if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 2 , 3 ] , [ 9 , 5 , 1 , 2 ] ] NEW_LINE out = sObj . isToeplitzMatrix ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = 0 NEW_LINE for s in itertools . count ( 1 , 2 ) : NEW_LINE INDENT if s * s > ( LIMIT + 1 ) // 3 : NEW_LINE INDENT break NEW_LINE DEDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , t , L , b = ( int ( s ) for s in input ( ) . split ( ) ) NEW_LINE if ( n , t , L , b ) == ( 0 , 0 , 0 , 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT loses = [ int ( input ( ) ) for i in range ( L ) ] NEW_LINE backs = [ int ( input ( ) ) for i in range ( b ) ] NEW_LINE dp = [ [ 0. ] * n + [ 1. ] for i in range ( 3 ) ] NEW_LINE stops = list ( range ( n + 1 ) ) + list ( reversed ( range ( n - 5 , n ) ) ) NEW_LINE for i in reversed ( range ( t ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i % 3 ] [ j ] = sum ( dp [ ( i + 2 ) % 3 ] [ d ] if d in loses else dp [ ( i + 1 ) % 3 ] [ 0 ] if d in backs else dp [ ( i + 1 ) % 3 ] [ d ] for d in stops [ j + 1 : j + 7 ] ) / 6 NEW_LINE DEDENT DEDENT print ( ' { : . 6f } ' . format ( dp [ 0 ] [ 0 ] ) ) NEW_LINE DEDENT
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd_count , even_count , odd_sum = 0 , 0 , 0 NEW_LINE for i in arr : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT odd_sum += i NEW_LINE odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT if odd_sum % 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif odd_count > 0 and even_count > 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff / K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE
def countWords ( str , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abc " NEW_LINE l = len ( str ) NEW_LINE print ( countWords ( str , l ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE s = sum ( l ) NEW_LINE if s % 2 == 0 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in l : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT print ( s - i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE i += 1 ; NEW_LINE current = int ( pow ( i , 2 ) ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = 0 ; NEW_LINE secondMax = 0 ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 0 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( arr [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ; NEW_LINE print ( countPairs ( arr ) ) ; NEW_LINE
def findHypotenuse ( side1 , side2 ) : NEW_LINE INDENT h = ( ( ( side1 * side1 ) + ( side2 * side2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE return h ; NEW_LINE DEDENT side1 = 3 ; NEW_LINE side2 = 4 ; NEW_LINE print ( findHypotenuse ( side1 , side2 ) ) ; NEW_LINE
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " & " , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE
def solve ( n , nums ) : NEW_LINE INDENT maxIndex = nums . index ( max ( nums ) ) NEW_LINE minIndex = nums . index ( min ( nums ) ) NEW_LINE ans = float ( ' INF ' ) NEW_LINE ans = min ( ans , max ( maxIndex , minIndex ) + 1 ) NEW_LINE ans = min ( ans , n - min ( maxIndex , minIndex ) ) NEW_LINE ans = min ( ans , maxIndex + 1 + n - minIndex ) NEW_LINE ans = min ( ans , minIndex + 1 + n - maxIndex ) NEW_LINE return ans NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for T in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE nums = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE print ( solve ( n , nums ) ) NEW_LINE DEDENT
import sys , io , math NEW_LINE from tokenize import Triple NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE days = [ 28 , 30 , 31 ] NEW_LINE week = [ ' monday ' , ' tuesday ' , ' wednesday ' , ' thursday ' , ' friday ' , ' saturday ' , ' sunday ' ] NEW_LINE a = IS ( ) NEW_LINE b = IS ( ) NEW_LINE for index , name in enumerate ( week ) : NEW_LINE INDENT if name == a : NEW_LINE INDENT ind = index NEW_LINE DEDENT DEDENT flag = False NEW_LINE for mo in days : NEW_LINE INDENT if week [ ( ind + mo ) % 7 ] == b : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
kolvomest = int ( input ( ) ) NEW_LINE k = 0 NEW_LINE spisok = [ ] NEW_LINE for stroka in range ( kolvomest ) : NEW_LINE INDENT ryad = input ( ) NEW_LINE if ' OO ' in ryad and k == 0 : NEW_LINE INDENT k = 1 NEW_LINE ryad = ryad . replace ( ' OO ' , ' + + ' , 1 ) NEW_LINE DEDENT spisok . append ( ryad ) NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE for stroka in range ( kolvomest ) : NEW_LINE INDENT print ( spisok [ stroka ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def prList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( temp . data , end = " - > " ) NEW_LINE temp = temp . next NEW_LINE while ( temp != head ) : NEW_LINE INDENT print ( temp . data , end = " - > " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( head . data ) NEW_LINE DEDENT def deleteK ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while True : NEW_LINE INDENT if ( curr . next == head and curr == head ) : NEW_LINE INDENT break NEW_LINE DEDENT prList ( head ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if ( curr == head ) : NEW_LINE INDENT prev = head NEW_LINE while ( prev . next != head ) : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif ( curr . next == head ) : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT DEDENT def insertNode ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = Node ( x ) NEW_LINE if ( head == None ) : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while ( temp1 . next != head ) : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertNode ( head , 1 ) NEW_LINE head = insertNode ( head , 2 ) NEW_LINE head = insertNode ( head , 3 ) NEW_LINE head = insertNode ( head , 4 ) NEW_LINE head = insertNode ( head , 5 ) NEW_LINE head = insertNode ( head , 6 ) NEW_LINE head = insertNode ( head , 7 ) NEW_LINE head = insertNode ( head , 8 ) NEW_LINE head = insertNode ( head , 9 ) NEW_LINE k = 4 NEW_LINE deleteK ( head , k ) NEW_LINE DEDENT
def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) / x ) ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT
n = input ( ) . split ( ) NEW_LINE n [ 0 ] = int ( n [ 0 ] ) NEW_LINE n [ 1 ] = int ( n [ 1 ] ) NEW_LINE n [ 2 ] = int ( n [ 2 ] ) NEW_LINE n . sort ( ) NEW_LINE print ( ( n [ 1 ] - n [ 0 ] ) + ( n [ 2 ] - n [ 1 ] ) ) NEW_LINE
from math import gcd NEW_LINE def cntSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = gcd ( curr_gcd , arr [ j ] ) ; NEW_LINE ans += ( curr_gcd == 1 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubArr ( arr , n ) ) ; NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( Str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( Str [ i ] ) and prime [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT Str = " geeksforgeeks " ; NEW_LINE n = len ( Str ) NEW_LINE if ( isVowelPrime ( Str , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "2553432" NEW_LINE print ( minStepToDeleteString ( str ) ) NEW_LINE DEDENT
limit = 1000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE n = 11 NEW_LINE print ( position [ n ] ) NEW_LINE DEDENT
DP_s = 9 NEW_LINE def getNumMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for i in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( ln ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
DP_s = 9 NEW_LINE def getNumMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for i in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( ln ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l , r = 1 , 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT
def test ( ) : NEW_LINE INDENT nrow , ncol = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ ] NEW_LINE val = 100000000000 NEW_LINE lr , lc = 0 , 0 NEW_LINE for row_id in range ( nrow ) : NEW_LINE INDENT temp = list ( input ( ) ) NEW_LINE arr . append ( [ ] ) NEW_LINE for col_id in range ( ncol ) : NEW_LINE INDENT if temp [ col_id ] == " R " : NEW_LINE INDENT temp2 = row_id + col_id NEW_LINE arr [ row_id ] . append ( temp2 ) NEW_LINE if temp2 < val : NEW_LINE INDENT val = temp2 NEW_LINE lr , lc = row_id , col_id NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr [ row_id ] . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( lr ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if max ( temp ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( nrow ) : NEW_LINE INDENT for j in range ( lc ) : NEW_LINE INDENT if arr [ i ] [ j ] > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT num_test_cases = int ( input ( ) ) NEW_LINE for test_case in range ( num_test_cases ) : NEW_LINE INDENT val = test ( ) NEW_LINE if val : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def findArea ( r ) : NEW_LINE INDENT PI = 3.142 NEW_LINE return PI * ( r * r ) ; NEW_LINE DEDENT print ( " Area ▁ is ▁ % .6f " % findArea ( 5 ) ) ; NEW_LINE
( n , k ) = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ 0 ] * n NEW_LINE for i in map ( int , input ( ) . split ( ) ) : NEW_LINE INDENT s [ i - 1 ] = 1 NEW_LINE DEDENT e = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT ( x , y ) = ( int ( s ) - 1 for s in input ( ) . split ( ) ) NEW_LINE e [ x ] . append ( y ) NEW_LINE e [ y ] . append ( x ) NEW_LINE DEDENT q = [ 0 ] NEW_LINE fa = [ - 1 ] * n NEW_LINE fa [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = q [ i ] NEW_LINE for y in e [ x ] : NEW_LINE INDENT if fa [ y ] == - 1 : NEW_LINE INDENT fa [ y ] = x NEW_LINE q . append ( y ) NEW_LINE DEDENT DEDENT DEDENT dp = [ 0 ] * n NEW_LINE k2 = k * 2 NEW_LINE for x in reversed ( q ) : NEW_LINE INDENT for y in e [ x ] : NEW_LINE INDENT if fa [ y ] == x : NEW_LINE INDENT i = s [ y ] NEW_LINE s [ x ] += i NEW_LINE dp [ x ] += dp [ y ] + ( k2 - i if i > k else i ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] ) NEW_LINE
def nthTerm ( N ) : NEW_LINE INDENT return ( abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE DEDENT
V = 4 NEW_LINE def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT graph = [ [ 0 , 1 , 1 , 1 , ] , [ 0 , 0 , 0 , 1 , ] , [ 0 , 0 , 0 , 1 , ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE u = 0 ; v = 3 ; k = 2 NEW_LINE print ( countwalks ( graph , u , v , k ) ) NEW_LINE
from math import log10 , floor NEW_LINE def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return floor ( x ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findDigits ( 4 , 16 ) ) NEW_LINE print ( findDigits ( 5 , 8 ) ) NEW_LINE print ( findDigits ( 12 , 16 ) ) NEW_LINE print ( findDigits ( 19 , 13 ) ) NEW_LINE DEDENT
class Bit ( object ) : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . N = N NEW_LINE self . bit = [ 0 ] * ( N + 1 ) NEW_LINE DEDENT def add ( self , a : int , w : int ) : NEW_LINE INDENT x : int = a NEW_LINE while x <= self . N : NEW_LINE INDENT self . bit [ x ] += w NEW_LINE x += x & - x NEW_LINE DEDENT DEDENT def sum ( self , a : int ) : NEW_LINE INDENT ret : int = 0 NEW_LINE x : int = a NEW_LINE while x > 0 : NEW_LINE INDENT ret += self . bit [ x ] NEW_LINE x -= x & - x NEW_LINE DEDENT return ret NEW_LINE DEDENT def range_sum ( self , x , y ) : NEW_LINE INDENT ret1 = self . sum ( y ) NEW_LINE ret2 = self . sum ( x - 1 ) NEW_LINE return ret1 - ret2 NEW_LINE DEDENT DEDENT N , q = input ( ) . split ( ) NEW_LINE N = int ( N ) NEW_LINE q = int ( q ) NEW_LINE bit = Bit ( N ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT mode , x , y = input ( ) . rstrip ( ) . split ( ) NEW_LINE if mode == "0" : NEW_LINE INDENT bit . add ( int ( x ) , int ( y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = bit . range_sum ( int ( x ) , int ( y ) ) NEW_LINE print ( ret ) NEW_LINE DEDENT DEDENT
mod = 10 ** 9 + 7 NEW_LINE n = int ( input ( ) ) NEW_LINE def nth_bit ( d ) : NEW_LINE INDENT return ( n >> d ) & 1 NEW_LINE DEDENT dp = [ [ 0 , 0 , 0 ] for _ in range ( 61 ) ] NEW_LINE dp [ - 1 ] [ 0 ] = 1 NEW_LINE for d in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT for s in range ( 3 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT s2 = min ( 2 , 2 * s + nth_bit ( d ) - k ) NEW_LINE if s2 >= 0 : NEW_LINE INDENT dp [ d ] [ s2 ] += dp [ d + 1 ] [ s ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( dp [ 0 ] ) % mod NEW_LINE print ( ans ) NEW_LINE
from functools import lru_cache NEW_LINE @ lru_cache ( maxsize = 1 << 10 ) NEW_LINE def solve ( p , q , a , n ) : NEW_LINE INDENT def _solve ( num , dem , d , m , s ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if d == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if num * a // m < dem : NEW_LINE INDENT return 0 NEW_LINE DEDENT return sum ( ( _solve ( num * i - dem , dem * i , d - 1 , m * i , i ) for i in range ( s , min ( dem * n // num , a // m ) + 1 ) ) , 0 ) NEW_LINE DEDENT return _solve ( p , q , n , 1 , 1 ) NEW_LINE DEDENT ans = [ ] NEW_LINE while True : NEW_LINE INDENT p , q , a , n = map ( int , input ( ) . split ( ) ) NEW_LINE if p == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans . append ( solve ( p , q , a , n ) ) NEW_LINE DEDENT print ( * ans , sep = " \n " ) NEW_LINE
def binary_conversion ( s , m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT temp = m % 2 NEW_LINE s += str ( temp ) NEW_LINE m = m // 2 NEW_LINE DEDENT return s [ : : - 1 ] NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT s = " " NEW_LINE s = binary_conversion ( s , m ) NEW_LINE s1 = " " NEW_LINE for x in range ( n ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == "1" : NEW_LINE INDENT s1 += "10" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += "01" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = " " NEW_LINE DEDENT e = ord ( s [ i ] ) NEW_LINE r = ord ( '0' ) NEW_LINE return e - r NEW_LINE DEDENT m , n , i = 5 , 2 , 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE
def countSubSets ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT even_count = len ( us ) NEW_LINE return pow ( 2 , even_count ) - 1 NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ subsets ▁ = " , countSubSets ( arr , n ) ) NEW_LINE
MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) // 2 if ( n & 1 ) else n // 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT
def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 ; NEW_LINE sum = 0 ; NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w ; NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w ; NEW_LINE DEDENT sum = pow ( 10 , n - 2 ) ; NEW_LINE sum = ( x * sum ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE w = 4 ; NEW_LINE print ( findNumbers ( n , w ) ) ; NEW_LINE
def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " ab2c3" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE return int ( n * ( n + 1 ) / 2 ) ; NEW_LINE DEDENT s = " abcde " ; NEW_LINE print ( countNonEmptySubstr ( s ) ) ; NEW_LINE