def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ; NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : " , calculateSquareSum ( n ) ) ; NEW_LINE
start , end , k = input ( ) , input ( ) , int ( input ( ) ) NEW_LINE n , mod = len ( end ) , 10 ** 9 + 7 NEW_LINE dp = [ 1 , 0 ] NEW_LINE psum = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT dp [ 0 ] = psum - dp [ 0 ] NEW_LINE dp [ 1 ] = psum - dp [ 1 ] NEW_LINE psum = ( dp [ 0 ] + ( ( n - 1 ) * dp [ 1 ] ) % mod ) % mod NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if start [ i : ] + start [ : i ] == end : NEW_LINE INDENT if i == 0 : ans += dp [ 0 ] NEW_LINE else : ans += dp [ 1 ] NEW_LINE DEDENT DEDENT print ( ans % mod ) NEW_LINE
import sys NEW_LINE from operator import itemgetter NEW_LINE def solve ( data ) : NEW_LINE INDENT result = [ ] NEW_LINE for name , win , lose , draw in data : NEW_LINE INDENT score = win * 3 + draw * 1 NEW_LINE result . append ( [ name , score ] ) NEW_LINE DEDENT result . sort ( key = itemgetter ( 1 ) , reverse = True ) NEW_LINE return result NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT first_data_set = True NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT name , win , lose , draw = input ( ) . split ( ) NEW_LINE data . append ( [ name , int ( win ) , int ( lose ) , int ( draw ) ] ) NEW_LINE DEDENT result = solve ( data ) NEW_LINE if first_data_set : NEW_LINE INDENT first_data_set = False NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE DEDENT for r in result : NEW_LINE INDENT print ( ' , ' . join ( map ( str , r ) ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE lights = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if lights [ i - 1 ] == 1 and lights [ i ] == 0 and lights [ i + 1 ] == 1 : NEW_LINE INDENT lights [ i + 1 ] = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT return c - ' A ' + 10 NEW_LINE DEDENT DEDENT def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( strr , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( strr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 37 ) : NEW_LINE INDENT if ( toDeci ( strr [ i ] , j ) == x ) : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( counter == n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT x = 16 NEW_LINE strr = [ "10000" , "20" , "16" ] NEW_LINE checkCorrespond ( strr , x ) NEW_LINE
n = int ( input ( ) ) NEW_LINE li = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE res = [ n ] NEW_LINE p = n // 10 NEW_LINE i = 1 NEW_LINE while p > 0 : NEW_LINE INDENT rem = p % 10 NEW_LINE p //= 10 NEW_LINE j = li . index ( rem ) NEW_LINE if j == 0 : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT j = li [ j - 1 ] NEW_LINE res . append ( p * 10 ** ( i + 1 ) + j * 10 ** i + int ( '9' * i ) ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT maxsum = 0 NEW_LINE maxi = 0 NEW_LINE def getsum ( n ) : NEW_LINE INDENT res = 0 NEW_LINE while n > 0 : NEW_LINE INDENT res += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT for i in res : NEW_LINE INDENT if getsum ( i ) > maxsum : NEW_LINE INDENT maxsum = getsum ( i ) NEW_LINE maxi = i NEW_LINE DEDENT DEDENT print ( maxi ) NEW_LINE
def solve ( ) : NEW_LINE INDENT n , m , k = input ( ) . split ( " ▁ " ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = " NO " NEW_LINE i = len ( a ) - 1 NEW_LINE j = len ( b ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if a [ i ] > b [ j ] : NEW_LINE INDENT ans = " YES " NEW_LINE print ( ans ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT if len ( a ) > len ( b ) : NEW_LINE INDENT ans = " YES " NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT main ( ) NEW_LINE
import heapq NEW_LINE tbl = [ ] NEW_LINE N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE tbl . append ( ( a , b ) ) NEW_LINE DEDENT tbl . sort ( ) NEW_LINE Q = [ ] NEW_LINE ans = s = sz = 0 NEW_LINE for t in tbl : NEW_LINE INDENT s += t [ 0 ] NEW_LINE heapq . heappush ( Q , ( t [ 1 ] , t [ 0 ] ) ) NEW_LINE sz += 1 NEW_LINE while sz and sz * Q [ 0 ] [ 0 ] < s : NEW_LINE INDENT s -= Q [ 0 ] [ 1 ] NEW_LINE heapq . heappop ( Q ) NEW_LINE sz -= 1 NEW_LINE DEDENT if sz > ans : ans = sz NEW_LINE DEDENT print ( ans ) NEW_LINE
def maxDivide ( a , b ) : NEW_LINE INDENT while a % b == 0 : NEW_LINE INDENT a = a / b NEW_LINE DEDENT return a NEW_LINE DEDENT def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return 1 if no == 1 else 0 NEW_LINE DEDENT def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while n > count : NEW_LINE INDENT i += 1 NEW_LINE if isUgly ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT no = getNthUglyNo ( 150 ) NEW_LINE print ( ( " 150th ▁ ugly ▁ " + " no . ▁ is ▁ " + str ( no ) ) ) NEW_LINE
import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE lst = list ( _input ( ) ) NEW_LINE fi = la = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = int ( s [ i ] ) NEW_LINE if lst [ k - 1 ] > k : NEW_LINE INDENT if fi == - 1 : fi = i NEW_LINE else : la = i NEW_LINE DEDENT elif lst [ k - 1 ] == k : NEW_LINE INDENT if fi != - 1 : la = i NEW_LINE DEDENT else : NEW_LINE INDENT if fi != - 1 : la = i - 1 ; break NEW_LINE DEDENT DEDENT if fi == la and fi == - 1 : print ( s ) NEW_LINE else : NEW_LINE INDENT print ( s [ : fi ] , end = ' ' ) NEW_LINE if la == - 1 : la = n - 1 NEW_LINE for i in range ( fi , la + 1 ) : NEW_LINE INDENT print ( lst [ int ( s [ i ] ) - 1 ] , end = ' ' ) NEW_LINE DEDENT print ( s [ la + 1 : ] ) NEW_LINE DEDENT
from math import ceil , sqrt NEW_LINE def perfectSquares ( l , r ) : NEW_LINE INDENT number = ceil ( sqrt ( l ) ) ; NEW_LINE n2 = number * number ; NEW_LINE number = ( number * 2 ) + 1 ; NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " ▁ " ) ; NEW_LINE n2 = n2 + number ; NEW_LINE number += 2 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 2 ; r = 24 ; NEW_LINE perfectSquares ( l , r ) ; NEW_LINE DEDENT
import math NEW_LINE def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = math . sqrt ( prod ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if root in freq : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
from itertools import combinations_with_replacement as cwr NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE c_lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for t in cwr ( ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) , n ) : NEW_LINE INDENT out = " " NEW_LINE cost = 0 NEW_LINE for n in t : NEW_LINE INDENT cost += c_lst [ n ] NEW_LINE out += str ( n ) NEW_LINE DEDENT if cost <= m : NEW_LINE INDENT print ( out ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 ] * 101 NEW_LINE for i in l : NEW_LINE INDENT c [ i ] += 1 NEW_LINE DEDENT n1 , n2 = 0 , 0 NEW_LINE i = 0 NEW_LINE while i < len ( l ) and c [ i ] >= 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT n1 = i NEW_LINE while i < len ( l ) and c [ i ] >= 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT n2 = i NEW_LINE print ( n1 + n2 ) NEW_LINE DEDENT
n , s = open ( 0 ) ; print ( min ( sum ( abs ( x - c ** i ) for i , x in enumerate ( sorted ( map ( int , s . split ( ) ) ) ) ) for c in range ( 2 + 9 ** 6 // int ( n ) ** 2 ) ) ) NEW_LINE
s = input ( ) NEW_LINE def uniq ( iii ) : NEW_LINE INDENT tmp = 0 NEW_LINE for jj in range ( 1 , len ( s ) ) : NEW_LINE INDENT bb = { } NEW_LINE for ii in iii : NEW_LINE INDENT bb . setdefault ( s [ ii - jj ] , [ ] ) . append ( ii ) NEW_LINE DEDENT tmp = max ( tmp , sum ( 1 for vvv in bb . values ( ) if len ( vvv ) == 1 ) ) NEW_LINE DEDENT return tmp NEW_LINE DEDENT aa = { } NEW_LINE for ii , ss in enumerate ( s ) : NEW_LINE INDENT aa . setdefault ( ss , [ ] ) . append ( ii ) NEW_LINE DEDENT ans = 0 NEW_LINE for iii in aa . values ( ) : NEW_LINE INDENT ans += uniq ( iii ) NEW_LINE DEDENT print ( ans / len ( s ) ) NEW_LINE
def countIntervals ( arr , V , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE if ( V >= li and V <= ri ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] NEW_LINE V = 7 NEW_LINE N = len ( arr ) NEW_LINE print ( ( countIntervals ( arr , V , N ) ) ) NEW_LINE DEDENT
def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE
def length ( str ) : NEW_LINE INDENT count = 0 ; NEW_LINE flag = False ; NEW_LINE length = len ( str ) - 1 ; NEW_LINE while ( length != 0 ) : NEW_LINE INDENT if ( str [ length ] == ' ▁ ' ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT length -= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT str = " Geeks ▁ for ▁ Geeks " ; NEW_LINE print ( " The ▁ length ▁ of ▁ last ▁ word ▁ is " , length ( str ) ) ; NEW_LINE
from math import pi , cos , sin NEW_LINE r , _x , _y , n = map ( int , input ( ) . split ( ) ) NEW_LINE _m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y = _x / r , _y / r NEW_LINE m = sum ( _m ) NEW_LINE t = [ 0.0 ] * ( n + 1 ) NEW_LINE _t = 0 NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT _t += _m [ i ] / m * 2 * pi NEW_LINE t [ i + 1 ] = _t NEW_LINE a . append ( int ( ( 1 + ( ( sin ( t [ i ] ) * y - cos ( t [ i ] ) * x ) + ( x * cos ( t [ i + 1 ] ) - y * sin ( t [ i + 1 ] ) ) ) / ( t [ i + 1 ] - t [ i ] ) ) * 100 ) ) NEW_LINE DEDENT print ( * a ) NEW_LINE
def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE num = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = num [ i ] NEW_LINE if ( x < 0 or x ** 0.5 % 1 != 0 ) : NEW_LINE INDENT print ( x ) NEW_LINE break NEW_LINE DEDENT DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( m * ( m + 1 ) // 2 ) NEW_LINE DEDENT elif m == 1 : NEW_LINE INDENT print ( n * ( n + 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT p = m * ( m - 1 ) // 2 NEW_LINE q = n * ( n + 1 ) // 2 NEW_LINE q *= m NEW_LINE print ( p + q ) NEW_LINE DEDENT DEDENT
from bisect import bisect as upper_bound NEW_LINE from bisect import bisect_left as lower_bound NEW_LINE from math import floor NEW_LINE N = 1000005 NEW_LINE MAX = 10 ** 18 NEW_LINE powers = [ ] NEW_LINE squares = dict ( ) NEW_LINE s = dict ( ) NEW_LINE def powersPrecomputation ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT squares [ i * i ] = 1 NEW_LINE if ( i not in squares . keys ( ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = i NEW_LINE while ( i * i <= ( MAX // temp ) ) : NEW_LINE INDENT temp *= ( i * i ) NEW_LINE s [ temp ] = 1 NEW_LINE DEDENT DEDENT for x in s : NEW_LINE INDENT powers . append ( x ) NEW_LINE DEDENT DEDENT def calculateAnswer ( L , R ) : NEW_LINE INDENT powersPrecomputation ( ) NEW_LINE perfectSquares = floor ( ( R ) ** ( .5 ) ) - floor ( ( L - 1 ) ** ( .5 ) ) NEW_LINE high = upper_bound ( powers , R ) NEW_LINE low = lower_bound ( powers , L ) NEW_LINE perfectPowers = perfectSquares + ( high - low ) NEW_LINE ans = ( R - L + 1 ) - perfectPowers NEW_LINE return ans NEW_LINE DEDENT L = 13 NEW_LINE R = 20 NEW_LINE print ( calculateAnswer ( L , R ) ) NEW_LINE
import numpy as np NEW_LINE import sys NEW_LINE dp = np . zeros ( ( 1000 , 1000 ) ) NEW_LINE def sum ( a , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT ans = ( ans + a [ m ] ) % 100 NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( a , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def intialize ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 40 , 60 , 20 ] NEW_LINE n = len ( a ) NEW_LINE intialize ( n ) NEW_LINE print ( int ( solve ( a , 0 , n - 1 ) ) ) NEW_LINE DEDENT
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT def getSuccessor ( arr , k , n ) : NEW_LINE INDENT p = k - 1 NEW_LINE while ( arr [ p ] == n and 0 <= p < k ) : NEW_LINE INDENT p -= 1 NEW_LINE DEDENT if ( p < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr [ p ] = arr [ p ] + 1 NEW_LINE i = p + 1 NEW_LINE while ( i < k ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT while ( 1 ) : NEW_LINE INDENT printArray ( arr , k ) NEW_LINE if ( getSuccessor ( arr , k , n ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT n = 3 NEW_LINE k = 2 NEW_LINE printSequences ( n , k ) NEW_LINE
import sys NEW_LINE rhombus = rectangle = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b , c = map ( int , line . split ( " , " ) ) NEW_LINE if c ** 2 == a ** 2 + b ** 2 : NEW_LINE INDENT rectangle += 1 NEW_LINE DEDENT elif a == b : NEW_LINE INDENT rhombus += 1 NEW_LINE DEDENT DEDENT print ( rectangle ) NEW_LINE print ( rhombus ) NEW_LINE
from collections import defaultdict NEW_LINE def maxValue ( a , n ) : NEW_LINE INDENT first = defaultdict ( lambda : 0 ) NEW_LINE last = defaultdict ( lambda : 0 ) NEW_LINE pr = [ None ] * n NEW_LINE pr [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pr [ i ] = pr [ i - 1 ] + a [ i ] NEW_LINE if first [ a [ i ] ] == 0 : NEW_LINE INDENT first [ a [ i ] ] = i NEW_LINE DEDENT last [ a [ i ] ] = i NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT start = first [ a [ i ] ] NEW_LINE end = last [ a [ i ] ] NEW_LINE ans = max ( ans , pr [ end ] - pr [ start - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 2 , 4 , 18 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxValue ( arr , n ) ) NEW_LINE DEDENT
def getPairs ( a , n ) : NEW_LINE INDENT visited1 = set ( ) NEW_LINE un = [ 0 ] * n NEW_LINE un [ n - 1 ] = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] in visited1 ) : NEW_LINE INDENT un [ i - 1 ] = count NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE un [ i - 1 ] = count NEW_LINE DEDENT visited1 . add ( a [ i ] ) NEW_LINE DEDENT visited2 = set ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] in visited2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT answer += un [ i ] NEW_LINE visited2 . add ( a [ i ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT a = [ 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( getPairs ( a , n ) ) NEW_LINE
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ABAB " NEW_LINE if ( isTwoAlter ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT n = 5223 NEW_LINE findRemainder ( n ) NEW_LINE
name = [ ' Sheldon ' , ' Leonard ' , ' Penny ' , ' Rajesh ' , ' Howard ' ] NEW_LINE n = int ( input ( ) ) NEW_LINE p = 0 NEW_LINE if n <= 5 : NEW_LINE INDENT print ( name [ n % 5 - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while 5 * ( 2 ** p ) <= n : NEW_LINE INDENT n -= ( 5 * ( 2 ** p ) ) NEW_LINE p += 1 NEW_LINE DEDENT res = n // ( 2 ** p ) NEW_LINE print ( name [ res ] ) NEW_LINE DEDENT
def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE k = 2 NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( findSumofEle ( arr1 , m , arr2 , n , k ) ) NEW_LINE
def CountWays ( n , flag ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE if flag == False and n > 1 : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) + CountWays ( n - 2 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n , False ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE class GFG : NEW_LINE INDENT def MaxSumDifference ( a , n ) : NEW_LINE INDENT np . sort ( a ) ; NEW_LINE j = 0 NEW_LINE finalSequence = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT finalSequence [ j ] = a [ i ] NEW_LINE finalSequence [ j + 1 ] = a [ n - i - 1 ] NEW_LINE j = j + 2 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT finalSequence [ n - 1 ] = a [ n / 2 ] NEW_LINE DEDENT MaximumSum = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) NEW_LINE DEDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) ; NEW_LINE print ( MaximumSum ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( a ) NEW_LINE GFG . MaxSumDifference ( a , n ) ; NEW_LINE
def reverse ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE rev = rev * 10 + d ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return ( n == reverse ( n ) ) ; NEW_LINE DEDENT def countDigits ( n ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE c += 1 ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT def countPalinDigits ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += countDigits ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT arr = [ 121 , 56 , 434 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPalinDigits ( arr , n ) ) ; NEW_LINE
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE DEDENT else : NEW_LINE INDENT length += 1 NEW_LINE DEDENT max1 = max ( max1 , length + 1 ) NEW_LINE DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " synapse " NEW_LINE print ( lenoflongestnonpalindrome ( s ) ) NEW_LINE DEDENT
R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , k = R ( ) ; a = [ * R ( ) ] ; i = 0 \n while ▁ k ▁ and ▁ i < n : d = min ( a [ i ] , k ) ; a [ i ] - = d ; a [ -1 ] + = d ; k - = d ; i + = 1 \n print ( * a ) \n ' ) NEW_LINE
def ellipse ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , b = 5 , 3 NEW_LINE print ( ellipse ( l , b ) ) NEW_LINE DEDENT
from collections import Counter NEW_LINE def inpl ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = Counter ( A ) NEW_LINE if C [ - 2 ] % 2 == 0 : NEW_LINE INDENT ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] NEW_LINE print ( len ( ans ) ) NEW_LINE if len ( ans ) : NEW_LINE INDENT print ( * ans , sep = " \n " ) NEW_LINE DEDENT DEDENT elif C [ - 1 ] > 0 : NEW_LINE INDENT ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] + [ A . index ( - 1 ) + 1 ] NEW_LINE print ( len ( ans ) ) NEW_LINE if len ( ans ) : NEW_LINE INDENT print ( * sorted ( ans ) , sep = " \n " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d = N - A [ : : - 1 ] . index ( - 2 ) NEW_LINE ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] NEW_LINE del ans [ ans . index ( d ) ] NEW_LINE print ( len ( ans ) ) NEW_LINE if len ( ans ) : NEW_LINE INDENT print ( * ans , sep = " \n " ) NEW_LINE DEDENT DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( " After ▁ exchange ▁ " ) NEW_LINE print ( " x ▁ is ▁ : " , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( " x ▁ is ▁ : " , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE
r = int ( input ( ) ) NEW_LINE k = [ 0 ] * ( r + 1 ) NEW_LINE for x in range ( 2 , r + 1 ) : NEW_LINE INDENT if k [ x ] == 0 : NEW_LINE INDENT for y in range ( 2 * x , r + 1 , x ) : NEW_LINE INDENT k [ y ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( k . count ( 2 ) ) NEW_LINE
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 , x2 , x3 = 1 , 3 , 6 NEW_LINE y1 , y2 , y3 = 2 , - 4 , - 7 NEW_LINE x = round ( ( x1 + x2 + x3 ) / 3 , 2 ) NEW_LINE y = round ( ( y1 + y2 + y3 ) / 3 , 2 ) NEW_LINE print ( " Centroid ▁ = " , " ( " , " { : . 2 f } " . format ( x ) , " , " , y , " ) " ) NEW_LINE DEDENT
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def count_ ( count , e ) : NEW_LINE INDENT hash = [ False ] * 10 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT if ( hash [ e % 10 ] == False ) : NEW_LINE INDENT count [ e % 10 ] += 1 NEW_LINE DEDENT hash [ e % 10 ] = True NEW_LINE e //= 10 NEW_LINE DEDENT DEDENT def find_subsequence ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_ ( count , arr [ i ] ) NEW_LINE DEDENT longest = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT longest = max ( count [ i ] , longest ) NEW_LINE DEDENT print ( longest ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 11 , 12 , 23 , 74 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE find_subsequence ( arr , n ) NEW_LINE DEDENT
from math import sqrt NEW_LINE MAXN = 1000001 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT k = int ( sqrt ( MAXN ) ) NEW_LINE for i in range ( 3 , k , 1 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def countSubArray ( arr , n ) : NEW_LINE INDENT ind = [ - 1 for i in range ( MAXN ) ] NEW_LINE count = 0 NEW_LINE last_ind = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT while ( arr [ i ] > 1 ) : NEW_LINE INDENT div = spf [ arr [ i ] ] NEW_LINE last_ind = max ( last_ind , ind [ div ] ) NEW_LINE ind [ div ] = i + 1 NEW_LINE arr [ i ] = int ( arr [ i ] / div ) NEW_LINE DEDENT count += i - last_ind + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sieve ( ) NEW_LINE arr = [ 2 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubArray ( arr , n ) ) NEW_LINE arr1 = [ 2 , 3 , 5 , 15 , 7 , 2 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countSubArray ( arr1 , n1 ) ) NEW_LINE DEDENT
N = 3 ; NEW_LINE def multiply ( mat , res ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] = 0 ; NEW_LINE for k in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return res ; NEW_LINE DEDENT def InvolutoryMatrix ( mat ) : NEW_LINE INDENT res = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] ; NEW_LINE res = multiply ( mat , res ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j and res [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( i != j and res [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT mat = [ [ 1 , 0 , 0 ] , [ 0 , - 1 , 0 ] , [ 0 , 0 , - 1 ] ] ; NEW_LINE if ( InvolutoryMatrix ( mat ) ) : NEW_LINE INDENT print ( " Involutory ▁ Matrix " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Involutory ▁ Matrix " ) ; NEW_LINE DEDENT
def first ( n ) : NEW_LINE INDENT a = n NEW_LINE c = 1 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT a //= 10 NEW_LINE c = c * 10 NEW_LINE DEDENT c = c // 10 NEW_LINE fi = n // c NEW_LINE return fi NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if n in [ 2 , 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def check ( n , k ) : NEW_LINE INDENT l = n % 10 NEW_LINE f = first ( n ) NEW_LINE lp = prime ( l ) NEW_LINE fp = prime ( f ) NEW_LINE if ( lp and fp ) : NEW_LINE INDENT if ( l + f < k ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT n = 322223 NEW_LINE k = 10 NEW_LINE check ( n , k ) NEW_LINE n = 62531561 NEW_LINE k = 15 NEW_LINE check ( n , k ) NEW_LINE
import math NEW_LINE def lengthSquare ( X , Y ) : NEW_LINE INDENT xDiff = X [ 0 ] - Y [ 0 ] NEW_LINE yDiff = X [ 1 ] - Y [ 1 ] NEW_LINE return xDiff * xDiff + yDiff * yDiff NEW_LINE DEDENT def printAngle ( A , B , C ) : NEW_LINE INDENT a2 = lengthSquare ( B , C ) NEW_LINE b2 = lengthSquare ( A , C ) NEW_LINE c2 = lengthSquare ( A , B ) NEW_LINE a = math . sqrt ( a2 ) ; NEW_LINE b = math . sqrt ( b2 ) ; NEW_LINE c = math . sqrt ( c2 ) ; NEW_LINE alpha = math . acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) ; NEW_LINE betta = math . acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) ; NEW_LINE gamma = math . acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) ; NEW_LINE alpha = alpha * 180 / math . pi ; NEW_LINE betta = betta * 180 / math . pi ; NEW_LINE gamma = gamma * 180 / math . pi ; NEW_LINE print ( " alpha ▁ : ▁ { : . 1f } " . format ( alpha ) ) NEW_LINE print ( " betta ▁ : ▁ { : . 1f } " . format ( betta ) ) NEW_LINE print ( " gamma ▁ : ▁ { : . 1f } " . format ( gamma ) ) NEW_LINE DEDENT A = ( 0 , 0 ) NEW_LINE B = ( 0 , 1 ) NEW_LINE C = ( 1 , 0 ) NEW_LINE printAngle ( A , B , C ) ; NEW_LINE
t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE array_input = input ( ) . split ( ) NEW_LINE if len ( array_input ) == 1 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT array = [ int ( x ) for x in array_input ] NEW_LINE max_value = max ( array ) NEW_LINE e = 0 NEW_LINE x = array [ - 1 ] NEW_LINE while True : NEW_LINE INDENT for i in array [ : : - 1 ] : NEW_LINE INDENT if i > x : NEW_LINE INDENT e += 1 NEW_LINE x = i NEW_LINE DEDENT if i == max_value : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == max_value : NEW_LINE INDENT ans . append ( e ) NEW_LINE break NEW_LINE DEDENT if e == 0 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT t -= 1 NEW_LINE DEDENT print ( * ans , sep = " \n " ) NEW_LINE
INT_MIN = - 100000000 NEW_LINE def maxEvenSum ( arr , n ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( pos_sum % 2 == 0 ) : NEW_LINE INDENT return pos_sum NEW_LINE DEDENT ans = INT_MIN ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT ans = max ( ans , pos_sum - arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , pos_sum + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT a = [ - 2 , 2 , - 3 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxEvenSum ( a , n ) ) NEW_LINE
def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfArray ( arr , n ) ) NEW_LINE DEDENT
TEN = 10 NEW_LINE def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * TEN NEW_LINE freqB = [ 0 ] * TEN NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = 240 NEW_LINE b = 204 NEW_LINE if ( areAnagrams ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( evenFib ( n ) ) NEW_LINE
from math import log2 , ceil NEW_LINE def minOperations ( N ) : NEW_LINE INDENT x = log2 ( N ) NEW_LINE ans = ceil ( x ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( minOperations ( N ) ) NEW_LINE DEDENT
t = a = 1 NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT T , A = map ( int , input ( ) . split ( ) ) ; n = max ( - ( - t // T ) , - ( - a // A ) ) ; t = n * T ; a = n * A NEW_LINE DEDENT print ( t + a ) NEW_LINE
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) // 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == c and b == d ) : NEW_LINE INDENT print ( a , a + 1 ) NEW_LINE DEDENT elif ( a == c ) : NEW_LINE INDENT print ( a , a + 1 ) NEW_LINE DEDENT elif ( b == d ) : NEW_LINE INDENT print ( b - 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a , c ) NEW_LINE DEDENT DEDENT
from collections import deque NEW_LINE N = 3 NEW_LINE m = { 8 : { 7 , 5 } , 7 : { 8 , 6 , 4 } , 6 : { 7 , 3 } , 5 : { 8 , 4 , 2 } , 4 : { 7 , 5 , 3 , 1 } , 3 : { 6 , 4 , 0 } , 2 : { 5 , 1 } , 1 : { 4 , 2 , 0 } , 0 : { 3 , 1 } } NEW_LINE goal = 123456780 NEW_LINE def g ( i , j , a ) : NEW_LINE INDENT t = a // ( 10 ** j ) % 10 NEW_LINE return a - t * ( 10 ** j ) + t * ( 10 ** i ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT MAP = " " . join ( input ( ) . replace ( " ▁ " , " " ) for _ in range ( N ) ) NEW_LINE zero = 8 - MAP . find ( "0" ) NEW_LINE start = int ( MAP ) NEW_LINE if start == goal : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = deque ( [ ( 0 , start , zero , 1 ) , ( 0 , goal , 0 , 0 ) ] ) NEW_LINE TABLE = { start : ( 1 , 0 ) , goal : ( 0 , 0 ) } NEW_LINE while dp : NEW_LINE INDENT cnt , M , yx , flg = dp . popleft ( ) NEW_LINE cnt += 1 NEW_LINE for nyx in m [ yx ] : NEW_LINE INDENT key = g ( yx , nyx , M ) NEW_LINE if key in TABLE : NEW_LINE INDENT if TABLE [ key ] [ 0 ] != flg : NEW_LINE INDENT return TABLE [ key ] [ 1 ] + cnt NEW_LINE DEDENT continue NEW_LINE DEDENT TABLE [ key ] = ( flg , cnt ) NEW_LINE dp . append ( ( cnt , key , nyx , flg ) ) NEW_LINE DEDENT DEDENT DEDENT def MAIN ( ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT MAIN ( ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LENGTH = 20 NEW_LINE BASE = 10 NEW_LINE MODULUS = 10 ** 9 NEW_LINE MAX_SQR_DIGIT_SUM = ( BASE - 1 ) ** 2 * LENGTH NEW_LINE sqsum = [ ] NEW_LINE count = [ ] NEW_LINE for i in range ( LENGTH + 1 ) : NEW_LINE INDENT sqsum . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE count . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE if i == 0 : NEW_LINE INDENT count [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( BASE ) : NEW_LINE INDENT for k in itertools . count ( ) : NEW_LINE INDENT index = k + j ** 2 NEW_LINE if index > MAX_SQR_DIGIT_SUM : NEW_LINE INDENT break NEW_LINE DEDENT sqsum [ i ] [ index ] = ( sqsum [ i ] [ index ] + sqsum [ i - 1 ] [ k ] + pow ( BASE , i - 1 , MODULUS ) * j * count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE count [ i ] [ index ] = ( count [ i ] [ index ] + count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( sqsum [ LENGTH ] [ i ** 2 ] for i in range ( 1 , eulerlib . sqrt ( MAX_SQR_DIGIT_SUM ) ) ) NEW_LINE return f " { ans % MODULUS : 09 } " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def resolve ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE ans = set ( ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT q , x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if q == 0 : NEW_LINE INDENT ans . add ( x ) NEW_LINE print ( len ( ans ) ) NEW_LINE DEDENT elif q == 1 : NEW_LINE INDENT if x in ans : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x in ans : NEW_LINE INDENT ans . remove ( x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT resolve ( ) NEW_LINE
MAX = 10000002 NEW_LINE prime = [ 0 ] * ( MAX ) NEW_LINE MAX_sqrt = int ( MAX ** ( 0.5 ) ) NEW_LINE prime_count = [ 0 ] * ( MAX ) NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , MAX_sqrt ) : NEW_LINE INDENT if prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT if prime [ j ] == 0 : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ i ] == 0 : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def numberOfDivisorsOfProduct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while temp != 1 : NEW_LINE INDENT prime_count [ prime [ temp ] ] += 1 NEW_LINE temp = temp // prime [ temp ] NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , len ( prime_count ) ) : NEW_LINE INDENT ans = ans * ( prime_count [ i ] + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numberOfDivisorsOfProduct ( arr , n ) ) NEW_LINE DEDENT
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT digitSum = digitSum + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT temp = ( int ) ( digitSum ) NEW_LINE reverseDigitSum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE reverseDigitSum = reverseDigitSum * 10 + rem NEW_LINE temp = temp // 10 NEW_LINE DEDENT number = digitSum * reverseDigitSum NEW_LINE return number NEW_LINE DEDENT num = 1729 NEW_LINE x = ( check ( num ) ) NEW_LINE if ( num == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def _sum ( arr , n ) : NEW_LINE INDENT return ( sum ( arr ) ) NEW_LINE DEDENT arr = [ ] NEW_LINE arr = [ 12 , 3 , 4 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE ans = _sum ( arr , n ) NEW_LINE print ( ' Sum ▁ of ▁ given ▁ array ▁ is ' , ans ) NEW_LINE
def ways ( n ) : NEW_LINE INDENT first = 2 ; NEW_LINE second = 3 ; NEW_LINE res = 0 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second ; NEW_LINE first = second ; NEW_LINE second = res ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT n = 7 ; NEW_LINE print ( " Total ▁ ways ▁ are : " , ways ( n ) ) ; NEW_LINE
import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , R , h ) : NEW_LINE INDENT return 1 / 3 * pi * h * ( r * r + R * R + r * R ) NEW_LINE DEDENT def curved_surface_area ( r , R , l ) : NEW_LINE INDENT return pi * l * ( R + r ) NEW_LINE DEDENT def total_surface_area ( r , R , l , h ) : NEW_LINE INDENT return pi * l * ( R + r ) + pi * ( r * r + R * R ) NEW_LINE DEDENT small_radius = 3 NEW_LINE big_radius = 8 NEW_LINE slant_height = 13 NEW_LINE height = 12 NEW_LINE print ( " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " , end = ' ' ) NEW_LINE print ( " { : . 3 f } " . format ( volume ( small_radius , big_radius , height ) ) ) NEW_LINE print ( " Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum " + " ▁ of ▁ Cone ▁ : ▁ " , end = ' ' ) NEW_LINE print ( " { : . 3 f } " . format ( curved_surface_area ( small_radius , big_radius , slant_height ) ) ) NEW_LINE print ( " Total ▁ Surface ▁ Area ▁ Of ▁ Frustum " + " ▁ of ▁ Cone ▁ : ▁ " , end = ' ' ) NEW_LINE print ( " { : . 3 f } " . format ( total_surface_area ( small_radius , big_radius , slant_height , height ) ) ) NEW_LINE
def digitSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 ; NEW_LINE while ( n // divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 ; NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor ; NEW_LINE trailing = n % 10 ; NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = ( n % divisor ) // 10 ; NEW_LINE divisor = divisor // 100 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def isDigitSumPalindrome ( n ) : NEW_LINE INDENT sum = digitSum ( n ) ; NEW_LINE if ( isPalindrome ( sum ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 56 ; NEW_LINE if ( isDigitSumPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE z = 1 NEW_LINE while ( z <= t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( "15" ) NEW_LINE DEDENT elif ( n > 6 and n % 2 != 0 ) : NEW_LINE INDENT n = n + 1 NEW_LINE print ( n // 2 * 5 ) NEW_LINE DEDENT elif ( n >= 6 and n % 2 == 0 ) : NEW_LINE INDENT print ( n // 2 * 5 ) NEW_LINE DEDENT z = z + 1 NEW_LINE DEDENT
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 ; NEW_LINE return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT your_rank = 805 ; NEW_LINE total_students = 97481 ; NEW_LINE print ( " { : . 3 f } " . format ( getPercentile ( your_rank , total_students ) ) ) ; NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 17 NEW_LINE if ( isPrime ( n ) and ( n % 16 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( isPrime ( n ) and ( n % 4 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE if ( isPrime ( n ) and isPowerOfTwo ( n * 3 - 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE maxx = max ( a , b , c ) NEW_LINE if a == b == c == maxx : print ( "1 ▁ 1 ▁ 1" ) NEW_LINE else : NEW_LINE INDENT if c == b == maxx : print ( maxx - a + 1 , 1 , 1 ) NEW_LINE else : NEW_LINE INDENT if a == c == maxx : print ( 1 , maxx - b + 1 , 1 ) NEW_LINE else : NEW_LINE INDENT if a == b == maxx : print ( 1 , 1 , maxx - c + 1 ) NEW_LINE else : NEW_LINE INDENT if a == maxx : print ( 0 , maxx - b + 1 , maxx - c + 1 ) NEW_LINE if b == maxx : print ( maxx - a + 1 , 0 , maxx - c + 1 ) NEW_LINE if c == maxx : print ( maxx - a + 1 , maxx - b + 1 , 0 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT countOfOne += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "10010" NEW_LINE K = 1 NEW_LINE print ( countOfSubstringWithKOnes ( s , K ) ) NEW_LINE DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT arr1 = [ 2 , 3 , 6 , 7 , 9 ] NEW_LINE arr2 = [ 1 , 4 , 8 , 10 ] NEW_LINE k = 5 ; NEW_LINE print ( kth ( arr1 , arr2 , 5 , 4 , k ) ) NEW_LINE
MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE def preCalculate ( string , n ) : NEW_LINE INDENT freq [ ord ( string [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ord ( ch ) ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ord ( ch ) ] [ r ] - freq [ ord ( ch ) ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def firstNonRepeating ( string , n , l , r ) : NEW_LINE INDENT t = [ " " ] * 2 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if getFrequency ( ch , l , r ) == 1 : NEW_LINE INDENT t [ 0 ] = ch NEW_LINE return t [ 0 ] NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksForGeeks " NEW_LINE n = len ( string ) NEW_LINE queries = [ ( 0 , 3 ) , ( 2 , 3 ) , ( 5 , 12 ) ] NEW_LINE q = len ( queries ) NEW_LINE preCalculate ( string , n ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( firstNonRepeating ( string , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT
MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( 256 ) ] for j in range ( 1000 ) ] NEW_LINE def preCalculate ( string , n ) : NEW_LINE INDENT freq [ ord ( string [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ord ( ch ) ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ord ( ch ) ] [ r ] - freq [ ord ( ch ) ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def lastNonRepeating ( string , n , l , r ) : NEW_LINE INDENT for i in range ( r , l - 1 , - 1 ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if getFrequency ( ch , l , r ) == 1 : NEW_LINE INDENT return ch NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksForGeeks " NEW_LINE n = len ( string ) NEW_LINE queries = [ ( 2 , 9 ) , ( 2 , 3 ) , ( 0 , 12 ) ] NEW_LINE q = len ( queries ) NEW_LINE preCalculate ( string , n ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( lastNonRepeating ( string , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT
def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A , B = 10 , 15 NEW_LINE divide ( A , B ) NEW_LINE DEDENT
import random NEW_LINE permutation = [ ] NEW_LINE def printPermutation ( ) : NEW_LINE INDENT for i in permutation : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT def give_random_number ( l , r ) : NEW_LINE INDENT x = random . randint ( l , r ) NEW_LINE return x NEW_LINE DEDENT def generate_random_permutation ( l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return NEW_LINE DEDENT n = give_random_number ( l , r ) NEW_LINE permutation . append ( n ) NEW_LINE generate_random_permutation ( l , n - 1 ) NEW_LINE generate_random_permutation ( n + 1 , r ) NEW_LINE DEDENT l = 5 NEW_LINE r = 15 NEW_LINE generate_random_permutation ( l , r ) NEW_LINE printPermutation ( ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 1 : print ( n * ( n - 1 ) // 2 ) NEW_LINE else : print ( ( n - 1 ) + ( n - d - 1 ) * n - ( ( n - d - 1 ) * ( n + d - 2 ) // 2 ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT counter = 0 NEW_LINE flag = True NEW_LINE while m > n : NEW_LINE INDENT if ( m / 2 ) % n == 0 : NEW_LINE INDENT m /= 2 NEW_LINE counter += 1 NEW_LINE DEDENT elif ( m / 3 ) % n == 0 : NEW_LINE INDENT m /= 3 NEW_LINE counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter if flag else - 1 ) NEW_LINE DEDENT
from random import randint NEW_LINE def fin_st ( l_i , st , l , rules ) : NEW_LINE INDENT dict_a = { " R " : l [ 0 ] , " P " : l [ 1 ] , " S " : l [ 2 ] } NEW_LINE fin_str = ' ' NEW_LINE for i in st : NEW_LINE INDENT if dict_a [ rules [ i ] ] > 0 : NEW_LINE INDENT fin_str += rules [ i ] NEW_LINE dict_a [ rules [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = randint ( 0 , len ( l_i ) - 1 ) NEW_LINE fin_str += l_i [ t ] NEW_LINE del l_i [ t ] NEW_LINE DEDENT DEDENT return fin_str NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE st = input ( ) NEW_LINE rules = { " S " : " R " , " P " : " S " , " R " : " P " } NEW_LINE dict_a = { " R " : a , " P " : b , " S " : c } NEW_LINE dict_b = { " R " : 0 , " P " : 0 , " S " : 0 } NEW_LINE for i in st : NEW_LINE INDENT dict_b [ i ] += 1 NEW_LINE DEDENT wins = 0 NEW_LINE for i in dict_b : NEW_LINE INDENT if dict_a [ rules [ i ] ] >= dict_b [ i ] : NEW_LINE INDENT wins += dict_b [ i ] NEW_LINE dict_a [ rules [ i ] ] -= dict_b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT wins += dict_a [ rules [ i ] ] NEW_LINE dict_a [ rules [ i ] ] = 0 NEW_LINE DEDENT DEDENT if round ( n / 2 + 1e-9 ) <= wins : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE print ( fin_st ( [ " R " ] * dict_a [ ' R ' ] + [ " P " ] * dict_a [ ' P ' ] + [ " S " ] * dict_a [ " S " ] , st , [ a , b , c ] , rules ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
n , m = input ( ) . split ( ) NEW_LINE color = ' # Black & White ' NEW_LINE for i in range ( int ( n ) ) : NEW_LINE INDENT x = input ( ) . split ( ) NEW_LINE for j in range ( int ( m ) ) : NEW_LINE INDENT if x [ j ] != ' B ' and x [ j ] != ' G ' and x [ j ] != ' W ' : NEW_LINE INDENT color = ' # Color ' NEW_LINE DEDENT DEDENT DEDENT print ( color ) NEW_LINE
def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B / 2 ) ; NEW_LINE y = ( y * y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A ; NEW_LINE y = ( y * exponent ( A , B - 1 ) ) ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE
s = input ( ) NEW_LINE print ( s [ : : 2 ] ) NEW_LINE
pref = [ 0 ] * 100001 NEW_LINE def checkPalindrome ( num ) : NEW_LINE INDENT strr = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] ) NEW_LINE DEDENT def printSumPalindromic ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT Q = 2 NEW_LINE arr = [ [ 10 , 13 ] , [ 12 , 21 ] ] NEW_LINE printSumPalindromic ( arr , Q ) NEW_LINE
import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) NEW_LINE write = lambda x : sys . stdout . write ( x + " \n " ) NEW_LINE n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = 10 ** 9 + 7 NEW_LINE def fs ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT s . add ( i ) NEW_LINE s . add ( n // i ) NEW_LINE DEDENT DEDENT l = sorted ( list ( s ) ) NEW_LINE return l NEW_LINE DEDENT ds = fs ( n ) NEW_LINE m = len ( ds ) NEW_LINE nums = [ None ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT val = pow ( k , ( ds [ i ] + 1 ) // 2 , M ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ds [ i ] % ds [ j ] == 0 : NEW_LINE INDENT val -= nums [ j ] NEW_LINE val %= M NEW_LINE DEDENT DEDENT nums [ i ] = val % M NEW_LINE DEDENT ans = 0 NEW_LINE inv2 = pow ( 2 , M - 2 , M ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ds [ i ] % 2 == 0 : NEW_LINE INDENT ans += ds [ i ] * nums [ i ] * inv2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ds [ i ] * nums [ i ] NEW_LINE DEDENT ans %= M NEW_LINE DEDENT print ( ans % M ) NEW_LINE
N = 3 ; NEW_LINE def interchangeDiagonals ( array ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i != N / 2 ) : NEW_LINE INDENT temp = array [ i ] [ i ] ; NEW_LINE array [ i ] [ i ] = array [ i ] [ N - i - 1 ] ; NEW_LINE array [ i ] [ N - i - 1 ] = temp ; NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( array [ i ] [ j ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT array = [ 4 , 5 , 6 ] , [ 1 , 2 , 3 ] , [ 7 , 8 , 9 ] ; NEW_LINE interchangeDiagonals ( array ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT l . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE DEDENT def m ( s , a , b , c ) : NEW_LINE INDENT capa = int ( s // c ) NEW_LINE free = int ( capa // a ) NEW_LINE return ( capa + b * free ) NEW_LINE DEDENT for i in l : NEW_LINE INDENT print ( m ( i [ 0 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ) ) NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE prime = [ True ] * 100002 ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def superpower ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE superPower = 0 ; NEW_LINE factor = 0 ; NEW_LINE i = 2 ; NEW_LINE while ( n > 1 and i <= MAX ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT factor = 0 ; NEW_LINE while ( n % i == 0 and n > 1 ) : NEW_LINE INDENT factor += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( superPower < factor ) : NEW_LINE INDENT superPower = factor ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return superPower ; NEW_LINE DEDENT n = 256 ; NEW_LINE print ( superpower ( n ) ) ; NEW_LINE
def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if end == len ( arr ) : NEW_LINE INDENT return NEW_LINE DEDENT elif start > end : NEW_LINE INDENT return printSubArrays ( arr , 0 , end + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start : end + 1 ] ) NEW_LINE return printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE if ( n == 0 or num [ 0 ] == '0' ) : NEW_LINE INDENT return true NEW_LINE DEDENT if ( ( n % 3 ) == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( ( n % 3 ) == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - 48 ) * 100 NEW_LINE group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 NEW_LINE group += ( ord ( num [ i + 2 ] ) - 48 ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = "1998" NEW_LINE n = len ( num ) NEW_LINE if ( isDivisible999 ( num ) ) : NEW_LINE INDENT print ( " Divisible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ divisible " ) NEW_LINE DEDENT DEDENT
I = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , k = I ( ) NEW_LINE print ( max ( 0 , 2 * n * k - n - 2 * sum ( [ * I ( ) ] ) ) ) NEW_LINE
from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a / i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( " { : . 3 f } " . format ( sumOfSeries ( a , n ) ) ) NEW_LINE
def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT
def numberSequence ( n ) : NEW_LINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEW_LINE return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( numberSequence ( n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def digitProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n ) : NEW_LINE INDENT prod = prod * ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return prod NEW_LINE DEDENT def printMultiplicativePrimes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ digitProduct ( i ) ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE printMultiplicativePrimes ( n ) NEW_LINE DEDENT
def minMoves ( arr , n ) : NEW_LINE INDENT expectedItem = n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == expectedItem ) : NEW_LINE INDENT expectedItem -= 1 NEW_LINE DEDENT DEDENT return expectedItem NEW_LINE DEDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMoves ( arr , n ) ) NEW_LINE
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 ; NEW_LINE a2 = 2 ; NEW_LINE r = 2 ; NEW_LINE d = 1 ; NEW_LINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( " Sum ▁ = " , int ( calculateSum ( n ) ) ) NEW_LINE
def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 ; j = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] in str2 : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT print ( " No . ▁ of ▁ matching ▁ characters ▁ are : " , c ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " aabcddekll12 @ " ; NEW_LINE str2 = " bb2211@55k " ; NEW_LINE count ( str1 , str2 ) ; NEW_LINE DEDENT
def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = 10 ** 9 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT a , b , c , k = 3 , 2 , 4 , 15 NEW_LINE print ( MinimumX ( a , b , c , k ) ) NEW_LINE
def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT n = 52 NEW_LINE print ( minLettersNeeded ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE k1 = k NEW_LINE s = input ( ) NEW_LINE A = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT sch = 0 NEW_LINE otv = ' ' NEW_LINE while A [ sch ] != 0 and len ( otv ) != k1 : NEW_LINE INDENT if sch < n // k1 : NEW_LINE INDENT otv += chr ( sch + ord ( ' a ' ) ) * ( max ( 0 , k - A [ sch ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT k = min ( k , A [ sch ] ) NEW_LINE sch += 1 NEW_LINE DEDENT otv += chr ( sch + ord ( ' a ' ) ) * ( k1 - len ( otv ) ) NEW_LINE print ( otv [ : : - 1 ] ) NEW_LINE DEDENT
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE vasya = max ( ( b * 3 ) / 10 , b - ( b / 250 ) * d ) NEW_LINE Misha = max ( ( a * 3 ) / 10 , a - ( a / 250 ) * c ) NEW_LINE if vasya == Misha : NEW_LINE INDENT print ( " Tie " ) NEW_LINE DEDENT elif vasya > Misha : NEW_LINE INDENT print ( " Vasya " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Misha " ) NEW_LINE DEDENT
import sys NEW_LINE a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE if a <= 8 and b <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " : ( " ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= b : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT def primes ( n ) : NEW_LINE INDENT is_prime = [ True ] * ( n + 1 ) NEW_LINE is_prime [ 0 ] = is_prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT is_prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return [ i for i in range ( n + 1 ) if is_prime [ i ] ] NEW_LINE DEDENT prime_list = primes ( 100000 ) NEW_LINE solvers = [ [ ] for _ in range ( 100001 ) ] NEW_LINE for p in prime_list : NEW_LINE INDENT for i in range ( p , 100001 , p ) : NEW_LINE INDENT solvers [ i ] . append ( p ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE a_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE parent = [ i for i in range ( 100001 ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT if x == parent [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT parent [ x ] = find ( parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT for i , v in enumerate ( a_list ) : NEW_LINE INDENT p_rep = find ( min ( solvers [ v ] ) ) NEW_LINE for s in solvers [ v ] : NEW_LINE INDENT parent [ find ( s ) ] = p_rep NEW_LINE DEDENT parent [ find ( v ) ] = p_rep NEW_LINE DEDENT dic = defaultdict ( set ) NEW_LINE for i , v in enumerate ( a_list ) : NEW_LINE INDENT dic [ find ( v ) ] . add ( i ) NEW_LINE DEDENT a_list . sort ( ) NEW_LINE for i , v in enumerate ( a_list ) : NEW_LINE INDENT if i not in dic [ find ( v ) ] : NEW_LINE INDENT print ( 0 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def ways ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT temp = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE test = " " NEW_LINE for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT test += s [ k ] NEW_LINE if ( test < temp ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ k ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += dp [ i ] [ n - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " aabc " NEW_LINE n = len ( s ) NEW_LINE print ( ways ( s , n ) ) NEW_LINE
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( 2 ** n - 1 ) NEW_LINE DEDENT
def isOdd ( arr , n ) : NEW_LINE INDENT flag = 0 ; flag1 = 0 ; sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE if ( arr [ i ] % 2 == 0 and flag == 0 ) : NEW_LINE INDENT flag = 1 ; NEW_LINE l = arr [ i ] ; NEW_LINE DEDENT if ( arr [ i ] % 2 != 0 and flag1 == 0 ) : NEW_LINE INDENT r = arr [ i ] ; NEW_LINE flag1 = 1 ; NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag1 == 1 and flag == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 4 , 4 , 5 , 1 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE res = isOdd ( arr , n ) ; NEW_LINE if ( res ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
for nt in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if 2 * k == n : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT ans = " NO " NEW_LINE if s [ 0 : k ] == s [ n - k : ] [ : : - 1 ] : NEW_LINE INDENT ans = " YES " NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import math NEW_LINE def maxCommonFactors ( a , b ) : NEW_LINE INDENT gcd = math . gcd ( a , b ) NEW_LINE ans = 1 ; NEW_LINE i = 2 NEW_LINE while ( i * i <= gcd ) : NEW_LINE INDENT if ( gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( gcd % i == 0 ) : NEW_LINE INDENT gcd = gcd // i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = 12 NEW_LINE b = 18 NEW_LINE print ( maxCommonFactors ( a , b ) ) NEW_LINE
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaa " NEW_LINE if allCharactersSame ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE r = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( b ) NEW_LINE n = max ( c ) NEW_LINE if m > n : NEW_LINE INDENT r . append ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( " NO " ) NEW_LINE DEDENT DEDENT for i in range ( len ( r ) ) : NEW_LINE INDENT print ( r [ i ] ) NEW_LINE DEDENT
def printUnsorted ( arr , n ) : NEW_LINE INDENT e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE exit ( ) NEW_LINE DEDENT e = n - 1 NEW_LINE while e > 0 : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT e -= 1 NEW_LINE DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= e + 1 : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies ▁ between ▁ the ▁ indices ▁ % d ▁ and ▁ % d " % ( s , e ) ) NEW_LINE DEDENT arr = [ 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printUnsorted ( arr , arr_size ) NEW_LINE
_ = input ( ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE best = 0 NEW_LINE curr = 0 NEW_LINE last = 0 NEW_LINE for v in l : NEW_LINE INDENT if v >= last : NEW_LINE INDENT curr += 1 NEW_LINE if curr > best : NEW_LINE INDENT best = curr NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr = 1 NEW_LINE DEDENT last = v NEW_LINE DEDENT print ( best ) NEW_LINE
d , l = map ( int , input ( ) . split ( ) ) NEW_LINE print ( d // l + d % l ) NEW_LINE
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT st = "99333" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT st = "1332" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def letterCasePermutation ( self , S ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( " " ) NEW_LINE for c in S : NEW_LINE INDENT n = len ( ans ) NEW_LINE if c . isalpha ( ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ans . append ( ans [ i ] ) NEW_LINE ans [ i ] += c . lower ( ) NEW_LINE ans [ n + i ] += c . upper ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ans [ i ] += c NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE S = " a1b2" NEW_LINE out = sObj . letterCasePermutation ( S ) NEW_LINE print ( out ) NEW_LINE DEDENT
import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countDigits ( n ) ) ; NEW_LINE
from math import sqrt , floor NEW_LINE def isPerfectSquare ( N ) : NEW_LINE INDENT sr = sqrt ( N ) NEW_LINE return ( sr - floor ( sr ) ) == 0 NEW_LINE DEDENT def BetrothedNumbers ( n , m ) : NEW_LINE INDENT Sum1 = 1 NEW_LINE Sum2 = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT Sum1 += i NEW_LINE DEDENT else : NEW_LINE INDENT Sum1 += i + n / i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , int ( sqrt ( m ) ) + 1 , 1 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT if ( isPerfectSquare ( m ) ) : NEW_LINE INDENT Sum2 += i NEW_LINE DEDENT else : NEW_LINE INDENT Sum2 += i + ( m / i ) NEW_LINE DEDENT DEDENT DEDENT if ( ( n + 1 == Sum2 ) and ( m + 1 == Sum1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9504 NEW_LINE M = 20734 NEW_LINE BetrothedNumbers ( N , M ) NEW_LINE DEDENT
import array NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 40000000 NEW_LINE totient = list_totients ( LIMIT - 1 ) NEW_LINE totientchainlen = array . array ( " L " , [ 0 , 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( totientchainlen ) , len ( totient ) ) : NEW_LINE INDENT chainlen = totientchainlen [ totient [ i ] ] + 1 NEW_LINE totientchainlen . append ( chainlen ) NEW_LINE if chainlen == 25 and totient [ i ] == i - 1 : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def list_totients ( n ) : NEW_LINE INDENT assert n < ( 1 << 32 ) NEW_LINE result = array . array ( " L " , range ( n + 1 ) ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if result [ i ] == i : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT result [ j ] = result [ j ] // i * ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE ans = 0 NEW_LINE b = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] in b ) == False : NEW_LINE INDENT ans += 1 NEW_LINE b . add ( a [ i ] ) NEW_LINE DEDENT elif ( a [ i ] + 1 in b ) == False : NEW_LINE INDENT ans += 1 NEW_LINE b . add ( a [ i ] + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
case = 1 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT jpeg = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE n1 = n - 1 NEW_LINE px , cur = [ 0 , 0 ] , 1 NEW_LINE while px [ 0 ] < n : NEW_LINE INDENT i , j = px NEW_LINE jpeg [ i ] [ j ] = cur NEW_LINE odd = ( i + j ) % 2 NEW_LINE if px [ not odd ] == n1 : NEW_LINE INDENT px [ odd ] += 1 NEW_LINE DEDENT elif not px [ odd ] : NEW_LINE INDENT px [ not odd ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT px [ not odd ] += 1 NEW_LINE px [ odd ] -= 1 NEW_LINE DEDENT cur += 1 NEW_LINE DEDENT print ( ' Case ▁ { } : ' . format ( case ) ) NEW_LINE for row in jpeg : NEW_LINE INDENT print ( ' ' . join ( ' { : > 3 } ' . format ( pixel ) for pixel in row ) ) NEW_LINE DEDENT case += 1 NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 30 , 10 , 9 , 3 , 35 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findGreatest ( arr , n ) ) NEW_LINE DEDENT
def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = 0 NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT k = k ^ arr [ i ] NEW_LINE DEDENT result = result + k NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( s [ i ] , s [ i + 1 ] , sep = " " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE
MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * MAX NEW_LINE countTW = [ 0 ] * MAX NEW_LINE for i in range ( M ) : NEW_LINE INDENT ( countP [ ord ( pat [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( " Found ▁ at ▁ Index " , ( i - M ) ) NEW_LINE DEDENT ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i - M ] ) ] ) -= 1 NEW_LINE DEDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( " Found ▁ at ▁ Index " , N - M ) NEW_LINE DEDENT DEDENT txt = " BACDGABCDA " NEW_LINE pat = " ABCD " NEW_LINE search ( pat , txt ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE N , M = map ( int , readline ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N -= 1 NEW_LINE M -= 1 NEW_LINE X = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE CX = [ x2 - x1 for x1 , x2 in zip ( X , X [ 1 : ] ) ] NEW_LINE CX = [ CX [ i ] * ( N - i ) * ( i + 1 ) for i in range ( N ) ] NEW_LINE Y = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE CY = [ y2 - y1 for y1 , y2 in zip ( Y , Y [ 1 : ] ) ] NEW_LINE CY = [ CY [ j ] * ( M - j ) * ( j + 1 ) for j in range ( M ) ] NEW_LINE print ( sum ( CX ) % MOD * sum ( CY ) % MOD ) NEW_LINE
fib = [ 0 , 1 , 1 ] NEW_LINE for i in range ( 3 , 51 ) : NEW_LINE INDENT fib . append ( fib [ - 1 ] + fib [ - 2 ] ) NEW_LINE DEDENT for i in range ( 1 , 51 ) : NEW_LINE INDENT fib [ i ] += fib [ i - 1 ] NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ 0 ] * n NEW_LINE left = m NEW_LINE last = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ i ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT size = n - j NEW_LINE if size == 1 : NEW_LINE INDENT perms = 1 NEW_LINE DEDENT else : NEW_LINE INDENT perms = fib [ size - 1 ] + 1 NEW_LINE DEDENT if perms >= left : NEW_LINE INDENT ans [ i ] = j NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT left -= perms NEW_LINE DEDENT DEDENT nlast = ans [ i ] NEW_LINE t = i + 1 NEW_LINE while ( t < n and ans [ t - 1 ] != last + 1 ) : NEW_LINE INDENT ans [ t ] = ans [ t - 1 ] - 1 NEW_LINE t += 1 NEW_LINE DEDENT last = nlast NEW_LINE DEDENT print ( * ans ) NEW_LINE
size = [ ' S ' , ' M ' , ' L ' , ' XL ' , ' XXL ' ] NEW_LINE n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT w = size . index ( input ( ) ) NEW_LINE fit = [ size [ w ] ] NEW_LINE x = 1 NEW_LINE while x < 5 : NEW_LINE INDENT if w + x < 5 : NEW_LINE INDENT fit . append ( size [ w + x ] ) NEW_LINE DEDENT if w - x >= 0 : NEW_LINE INDENT fit . append ( size [ w - x ] ) NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT for e in fit : NEW_LINE INDENT if n [ size . index ( e ) ] : NEW_LINE INDENT n [ size . index ( e ) ] -= 1 NEW_LINE print ( e ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) NEW_LINE if _ != t - 1 : NEW_LINE INDENT input ( ) NEW_LINE DEDENT flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > x : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( ' YES ' if flag else ' NO ' ) NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE w = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT w . append ( " ( " * ( n - i ) + " ) " * ( n - i ) + " ( ) " * i ) NEW_LINE DEDENT return " \n " . join ( w ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while t : NEW_LINE INDENT ans . append ( str ( solve ( ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT print ( " \n " . join ( ans ) ) NEW_LINE
def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT a = 80 ; b = 70 ; c = 100 ; d = 110 ; NEW_LINE if ( Valid ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Valid ▁ quadilateral " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid ▁ quadilateral " ) ; NEW_LINE DEDENT
import math NEW_LINE n , R , r = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT if r <= R : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT lhs = 2 * r * r / ( 1 - math . cos ( 2 * math . pi / n ) ) NEW_LINE rhs = ( R - r ) * ( R - r ) NEW_LINE if float ( ' % .9f ' % lhs ) <= rhs : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math as mt NEW_LINE MAX = 100001 NEW_LINE prime = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE countdiv = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX + 1 ) ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] NEW_LINE countdiv [ div ] += 1 NEW_LINE ans = max ( ans , countdiv [ div ] ) NEW_LINE while ( element % div == 0 ) : NEW_LINE INDENT element = element // div NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 10 , 15 , 7 , 25 , 9 , 35 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abacsddaa " NEW_LINE n = len ( s ) NEW_LINE query = [ 9 , 3 , 2 ] NEW_LINE Q = len ( query ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT pos = query [ i ] NEW_LINE print ( Count ( s , pos ) ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if b >= a : NEW_LINE INDENT print ( b ) NEW_LINE continue NEW_LINE DEDENT if c <= d : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT a -= b NEW_LINE dif = c - d NEW_LINE print ( b + ( a + dif - 1 ) // dif * c ) NEW_LINE DEDENT
from collections import OrderedDict NEW_LINE def printDuplicates ( arr ) : NEW_LINE INDENT myDict = { } NEW_LINE for ele in arr : NEW_LINE INDENT try : NEW_LINE INDENT myDict [ ele ] += 1 NEW_LINE DEDENT except : NEW_LINE INDENT myDict [ ele ] = 1 NEW_LINE DEDENT DEDENT for item in dict ( sorted ( myDict . items ( ) ) ) : NEW_LINE INDENT if ( myDict [ item ] > 1 ) : NEW_LINE INDENT print ( item , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT list = [ 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 ] NEW_LINE printDuplicates ( list ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( " YES " if c % 2 == 0 else " NO " ) NEW_LINE
import sys NEW_LINE def findMissingUtil ( arr , low , high , diff ) : NEW_LINE INDENT if ( high <= low ) : NEW_LINE INDENT return sys . maxsize ; NEW_LINE DEDENT mid = int ( low + ( high - low ) / 2 ) ; NEW_LINE if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) ; NEW_LINE DEDENT if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) ; NEW_LINE DEDENT if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissingUtil ( arr , mid + 1 , high , diff ) ; NEW_LINE DEDENT return findMissingUtil ( arr , low , mid - 1 , diff ) ; NEW_LINE DEDENT def findMissing ( arr , n ) : NEW_LINE INDENT diff = int ( ( arr [ n - 1 ] - arr [ 0 ] ) / n ) ; NEW_LINE return findMissingUtil ( arr , 0 , n - 1 , diff ) ; NEW_LINE DEDENT arr = [ 2 , 4 , 8 , 10 , 12 , 14 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " The ▁ missing ▁ element ▁ is " , findMissing ( arr , n ) ) ; NEW_LINE
def findPair ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE first = - 1 NEW_LINE second = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT print ( " n ▁ = " , first , " and ▁ r ▁ = " , second ) NEW_LINE DEDENT arr = [ 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE findPair ( arr , n ) NEW_LINE
import os , sys , io , math NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE n = IN ( ) NEW_LINE l = I ( ) NEW_LINE inf = pow ( 10 , 9 ) + 1 NEW_LINE t , c = 0 , inf NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT d = 0 NEW_LINE for j in l : d += min ( abs ( ( i - 1 ) - j ) , abs ( i - j ) , abs ( ( i + 1 ) - j ) ) NEW_LINE if c > d : t , c = i , d NEW_LINE DEDENT print ( t , c ) NEW_LINE
c = { "1" : " " , "2" : " k " , "3" : " s " , "4" : " t " , "5" : " n " , "6" : " h " , "7" : " m " , "8" : " y " , "9" : " r " , "0" : " w " } NEW_LINE m = { " T " : " a " , " L " : " i " , " U " : " u " , " R " : " e " , " D " : " o " } NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( 0 , len ( s ) , 2 ) : NEW_LINE INDENT com = s [ i : i + 2 ] NEW_LINE if com == "0U " : ans += " nn " NEW_LINE else : ans += c [ com [ 0 ] ] + m [ com [ 1 ] ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE tot = a + 2 * b + 3 * c NEW_LINE if tot % 2 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
import math ; NEW_LINE def powmod ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE value = [ 0 ] * m ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT value [ powmod ( a , i * n , m ) ] = i ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT cur = ( powmod ( a , j , m ) * b ) % m ; NEW_LINE if ( value [ cur ] ) : NEW_LINE INDENT ans = value [ cur ] * n - j ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE
def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT l = 8 NEW_LINE w = 4 NEW_LINE c = Circumference ( l , w ) NEW_LINE print ( " Circumference ▁ of ▁ a " + " ▁ rectangle ▁ is " , c ) NEW_LINE
import math NEW_LINE def edgeDisjoint ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = math . floor ( n / 2 ) NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( int ( edgeDisjoint ( n ) ) ) NEW_LINE DEDENT
def solve ( n , a , k ) : NEW_LINE INDENT leader = 0 NEW_LINE size = n NEW_LINE p = list ( range ( 1 , n + 1 ) ) NEW_LINE res = [ ] NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT j = ( leader + a [ i ] ) % size NEW_LINE res . append ( p [ j ] ) NEW_LINE p . pop ( j ) NEW_LINE size -= 1 NEW_LINE leader = j % size NEW_LINE DEDENT print ( * res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE solve ( n , a , k ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
sum = [ 0 for i in range ( 1000005 ) ] NEW_LINE def toInt ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( " Divisible ▁ by ▁ 3" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ divisible ▁ by ▁ 3" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = "12468236544" NEW_LINE prepareSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT LIMIT = 100000 NEW_LINE rads = [ 0 ] + [ 1 ] * LIMIT NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT data = sorted ( ( rad , i ) for ( i , rad ) in enumerate ( rads ) ) NEW_LINE return str ( data [ 10000 ] [ 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] NEW_LINE for xi in x : NEW_LINE INDENT val = xi % 14 NEW_LINE if xi > 14 and val <= 6 and val > 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m > n * 2 : NEW_LINE INDENT print ( n + ( m - n * 2 ) // 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m // 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import deque NEW_LINE def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' ▁ ' ) ; NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE small = min ( a , b ) NEW_LINE large = max ( a , b ) NEW_LINE for i in range ( 1 , min ( small , large // 2 ) ) : NEW_LINE INDENT if a % i == 0 and b % i == 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE small = min ( a , b , c ) NEW_LINE large = max ( a , b , c ) NEW_LINE for i in range ( 1 , min ( small , large // 2 ) ) : NEW_LINE INDENT if a % i == 0 and b % i == 0 and c % i == 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT
for i in range ( 9 ) : NEW_LINE INDENT name , a , p = map ( str , input ( ) . split ( ) ) NEW_LINE print ( name , int ( a ) + int ( p ) , int ( a ) * 200 + int ( p ) * 300 ) NEW_LINE DEDENT
def dot ( a , b ) : return a [ 0 ] * b [ 0 ] + a [ 1 ] * b [ 1 ] NEW_LINE def projection ( a , b ) : return [ x * dot ( a , b ) / dot ( a , a ) for x in a ] NEW_LINE x1 , y1 , x2 , y2 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ x2 - x1 , y2 - y1 ] NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT x , y = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ x - x1 , y - y1 ] NEW_LINE c = projection ( a , b ) NEW_LINE print ( c [ 0 ] + x1 , c [ 1 ] + y1 ) NEW_LINE DEDENT
xp1 , yp1 , xp2 , yp2 = map ( int , input ( ) . split ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE if xp1 == xp2 : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' { : . 10f } ' . format ( 2 * xp1 - x0 ) , ' { : . 10f } ' . format ( y0 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = float ( ( yp2 - yp1 ) / ( xp2 - xp1 ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE x = a * ( ( y0 - yp1 ) - a * ( x0 - xp1 ) ) / ( 1 + a ** 2 ) + x0 NEW_LINE y = ( a * ( a * y0 + x0 - xp1 ) + yp1 ) / ( 1 + a ** 2 ) NEW_LINE print ( ' { : . 10f } ' . format ( 2 * x - x0 ) , ' { : . 10f } ' . format ( 2 * y - y0 ) ) NEW_LINE DEDENT DEDENT
def printInitials ( string : str ) : NEW_LINE INDENT length = len ( string ) NEW_LINE string . strip ( ) NEW_LINE t = " " NEW_LINE for i in range ( length ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ch != ' ▁ ' : NEW_LINE INDENT t += ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t [ 0 ] . upper ( ) + " . ▁ " , end = " " ) NEW_LINE t = " " NEW_LINE DEDENT DEDENT temp = " " NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT temp += t [ 0 ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += t [ j ] . lower ( ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ishita ▁ bhuiya " NEW_LINE printInitials ( string ) NEW_LINE DEDENT
def max_sum ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = max ( 0 , arr [ 0 ] ) ; NEW_LINE i = 1 ; NEW_LINE while ( i < k ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = k ; NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , - 2 , 4 , 3 , 1 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 4 ; NEW_LINE print ( max_sum ( arr , n , k ) ) ; NEW_LINE DEDENT
s = " " NEW_LINE k = int ( input ( ) ) NEW_LINE x = 1 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT if s [ k - 1 ] != " " : NEW_LINE INDENT print ( s [ k - 1 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT s += str ( x ) NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 21 NEW_LINE b = 5 NEW_LINE print ( countX ( a , b ) ) NEW_LINE DEDENT
def sol ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE t , w = { } , { } NEW_LINE p , q = set ( ) , set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT l , r , d = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if l in w : w [ l ] . add ( ( r , d ) ) NEW_LINE else : w [ l ] = { ( r , d ) } NEW_LINE p . add ( l ) NEW_LINE q . add ( r ) NEW_LINE DEDENT s = p - q NEW_LINE chk = set ( ) NEW_LINE if len ( s ) == 0 : NEW_LINE INDENT print ( [ " No " , " Yes " ] [ m == 0 ] ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in s : NEW_LINE INDENT chk . add ( ( i , 0 ) ) NEW_LINE while len ( chk ) : NEW_LINE INDENT x = chk . pop ( ) NEW_LINE if x [ 0 ] in w : NEW_LINE INDENT for j in w [ x [ 0 ] ] : NEW_LINE INDENT if ( i , j [ 0 ] ) in t and t [ ( i , j [ 0 ] ) ] != t [ ( i , x [ 0 ] ) ] + j [ 1 ] : NEW_LINE INDENT print ( " No " ) NEW_LINE exit ( ) NEW_LINE DEDENT elif ( i , j [ 0 ] ) not in t : NEW_LINE INDENT t [ ( i , j [ 0 ] ) ] = x [ 1 ] + j [ 1 ] NEW_LINE chk . add ( ( j [ 0 ] , x [ 1 ] + j [ 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( " Yes " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sol ( ) NEW_LINE DEDENT
a = input ( ) . split ( ) NEW_LINE len_a = int ( a [ 0 ] ) NEW_LINE len_b = int ( a [ 1 ] ) NEW_LINE a = input ( ) . split ( ) NEW_LINE k = int ( a [ 0 ] ) NEW_LINE m = int ( a [ 1 ] ) NEW_LINE array_a = input ( ) . split ( ) NEW_LINE array_b = input ( ) . split ( ) NEW_LINE a = 0 NEW_LINE while a < len_a : NEW_LINE INDENT array_a [ a ] = int ( array_a [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT a = 0 NEW_LINE while a < len_b : NEW_LINE INDENT array_b [ a ] = int ( array_b [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT if array_a [ k - 1 ] < array_b [ len_b - m ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT elif a == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( " { 0 : . 5f } " . format ( - c / b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT root1 = ( - b + ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a ) NEW_LINE root2 = ( - b - ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a ) NEW_LINE if root1 == root2 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( " { 0 : . 5f } " . format ( root1 ) ) NEW_LINE DEDENT elif type ( root1 ) == complex and type ( root2 ) == complex : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif type ( root1 ) == complex : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( " { 0 : . 5f } " . format ( root2 ) ) NEW_LINE DEDENT elif type ( root2 ) == complex : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( " { 0 : . 5f } " . format ( root1 ) ) NEW_LINE DEDENT elif root1 > root2 : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( " { 0 : . 5f } " . format ( root2 ) ) NEW_LINE print ( " { 0 : . 5f } " . format ( root1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( " { 0 : . 5f } " . format ( root1 ) ) NEW_LINE print ( " { 0 : . 5f } " . format ( root2 ) ) NEW_LINE DEDENT DEDENT
def average ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum / n ; NEW_LINE DEDENT arr = [ 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( average ( arr , n ) ) NEW_LINE
def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT DEDENT def isKSortedArray ( arr , n , k ) : NEW_LINE INDENT aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT aux [ i ] = arr [ i ] NEW_LINE DEDENT aux . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT j = binarySearch ( aux , 0 , n - 1 , arr [ i ] ) NEW_LINE if ( abs ( i - j ) > k ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( " Is ▁ it ▁ a ▁ k ▁ sorted ▁ array ? : " , isKSortedArray ( arr , n , k ) ) NEW_LINE DEDENT
def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT result = 0.0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( resultOfAllSubsets ( arr , N ) ) NEW_LINE
import math NEW_LINE def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT product *= 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT product = product * i NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT n = 44 NEW_LINE print ( int ( productPrimeFactors ( n ) ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] < 0 : NEW_LINE INDENT m += 1 NEW_LINE l [ i ] = - l [ i ] NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT l [ i ] = - l [ i ] NEW_LINE DEDENT r = l . copy ( ) NEW_LINE r . sort ( ) NEW_LINE if r == l : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE j = 0 NEW_LINE for i in l : NEW_LINE INDENT while l [ j ] < i : NEW_LINE INDENT if i <= k + l [ j ] : n -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE elif ( int ( y % 2 ) == 0 ) : NEW_LINE INDENT return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT DEDENT x = 2 ; y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE
import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 3 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return dp [ i ] [ val ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "201220211" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 for i in range ( 3 ) ] for i in range ( n ) ] NEW_LINE val = charVal ( s , 0 ) NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) NEW_LINE DEDENT
def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE
import math NEW_LINE CONVERT = 10000 NEW_LINE def f ( nums , power , k ) : NEW_LINE INDENT for i in range ( power ) : NEW_LINE INDENT nums [ nums . index ( min ( nums ) ) ] += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for n in nums : NEW_LINE INDENT ans *= n / CONVERT NEW_LINE DEDENT return ans NEW_LINE DEDENT def logs ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return - 100000 NEW_LINE DEDENT return math . log ( x ) NEW_LINE DEDENT def logadd ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return a + logs ( 1 + math . exp ( b - a ) ) NEW_LINE DEDENT def p ( nums , K ) : NEW_LINE INDENT store = [ ] NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT store . append ( [ 0 ] * len ( nums ) ) NEW_LINE DEDENT for k in range ( K + 1 ) : NEW_LINE INDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT store [ k ] [ i ] = 0 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT store [ k ] [ i ] = - 100000 NEW_LINE DEDENT else : NEW_LINE INDENT store [ k ] [ i ] = logadd ( store [ k - 1 ] [ i - 1 ] + logs ( nums [ i ] ) , store [ k ] [ i - 1 ] + logs ( 1 - nums [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT return store [ K ] [ len ( nums ) - 1 ] NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE power = float ( input ( ) ) NEW_LINE power *= CONVERT NEW_LINE power = round ( power ) NEW_LINE starts = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( starts ) ) : NEW_LINE INDENT starts [ i ] = round ( starts [ i ] * CONVERT ) NEW_LINE DEDENT ans = f ( starts , power , k ) NEW_LINE print ( " Case ▁ # % s : ▁ % s " % ( case , ans ) ) NEW_LINE DEDENT
def printArray ( A , n , K ) : NEW_LINE INDENT minEle = 10 ** 9 NEW_LINE maxEle = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minEle = min ( minEle , A [ i ] ) NEW_LINE maxEle = max ( maxEle , A [ i ] ) NEW_LINE DEDENT if ( K != 0 ) : NEW_LINE INDENT if ( K % 2 == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = maxEle - A [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = A [ i ] - minEle NEW_LINE DEDENT DEDENT DEDENT for i in A : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) NEW_LINE printArray ( arr , N , K ) NEW_LINE DEDENT
p = [ ] NEW_LINE for i in range ( 2 , 1121 ) : NEW_LINE INDENT for j in range ( 2 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if not i % j : break NEW_LINE DEDENT else : p += [ i ] NEW_LINE DEDENT dp = [ [ 0 ] * 1121 for _ in range ( 15 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for x , y in enumerate ( p ) : NEW_LINE INDENT for i in range ( min ( x + 1 , 14 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( y , 1121 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - y ] NEW_LINE DEDENT DEDENT DEDENT while 1 : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE print ( dp [ k ] [ n ] ) NEW_LINE DEDENT
MAX = 64 ; NEW_LINE def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i ; NEW_LINE lbit = ( L >> i ) & 1 ; NEW_LINE rbit = ( R >> i ) & 1 ; NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 ; NEW_LINE break ; NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 4 ; R = 5 ; NEW_LINE print ( maxOR ( L , R ) ) ; NEW_LINE DEDENT
from itertools import product NEW_LINE variables = set ( list ( " abcdefghijk " ) ) NEW_LINE def formula ( S , X , i ) : NEW_LINE INDENT if S [ i ] == " T " : NEW_LINE INDENT return 1 , i + 1 NEW_LINE DEDENT elif S [ i ] == " F " : NEW_LINE INDENT return 0 , i + 1 NEW_LINE DEDENT elif S [ i ] in variables : NEW_LINE INDENT return X [ S [ i ] ] , i + 1 NEW_LINE DEDENT elif S [ i ] == " - " : NEW_LINE INDENT i += 1 NEW_LINE that , i = formula ( S , X , i ) NEW_LINE return ( not that ) , i NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE this , i = formula ( S , X , i ) NEW_LINE op = S [ i ] NEW_LINE i += 1 NEW_LINE that , i = formula ( S , X , i ) NEW_LINE i += 1 NEW_LINE if op == " * " : NEW_LINE INDENT return this & that , i NEW_LINE DEDENT elif op == " + " : NEW_LINE INDENT return this | that , i NEW_LINE DEDENT elif op == " @ " : NEW_LINE INDENT return ( not this ) | that , i NEW_LINE DEDENT else : NEW_LINE INDENT raise NEW_LINE DEDENT DEDENT DEDENT S = input ( ) NEW_LINE T , F = 1 , 0 NEW_LINE while S != " # " : NEW_LINE INDENT S = S . replace ( " - > " , " @ " ) NEW_LINE while " - - " in S : NEW_LINE INDENT S = S . replace ( " - - " , " " ) NEW_LINE DEDENT L , R = S . split ( " = " ) NEW_LINE for v in range ( 2 ** 11 ) : NEW_LINE INDENT X = { } NEW_LINE for a , x in zip ( list ( " abcdefghijk " ) , format ( v , " b " ) . zfill ( 11 ) ) : NEW_LINE INDENT X [ a ] = int ( x ) NEW_LINE DEDENT l , _ = formula ( L , X , 0 ) NEW_LINE r , _ = formula ( R , X , 0 ) NEW_LINE if int ( l ) != int ( r ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT S = input ( ) NEW_LINE DEDENT
def findSplit ( arr , n ) : NEW_LINE INDENT preSum = 0 NEW_LINE ind1 = - 1 NEW_LINE ind2 = - 1 NEW_LINE S = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT if ( S % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT S1 = S / 3 NEW_LINE S2 = 2 * S1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum += arr [ i ] NEW_LINE if ( preSum % S1 == 0 and ind1 == - 1 ) : NEW_LINE INDENT ind1 = i NEW_LINE DEDENT elif ( preSum % S2 == 0 ) : NEW_LINE INDENT ind2 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind1 != - 1 and ind2 != - 1 ) : NEW_LINE INDENT print ( " ( { } , ▁ { } ) " . format ( ind1 , ind2 ) ) NEW_LINE return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 0 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( findSplit ( arr , n ) == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT
def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 ; NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K // 2 ] * cnt [ K // 2 ] * cnt [ K // 2 ] ) ; NEW_LINE return rslt NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; K = 2 ; NEW_LINE print ( NoofTriplets ( N , K ) ) ; NEW_LINE DEDENT
def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = " ▁ " ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEW_LINE
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; NEW_LINE DEDENT DEDENT return dp [ W ] ; NEW_LINE DEDENT val = [ 7 , 8 , 4 ] ; NEW_LINE wt = [ 3 , 8 , 6 ] ; NEW_LINE W = 10 ; n = 3 ; NEW_LINE print ( KnapSack ( val , wt , n , W ) ) ; NEW_LINE
import math as mt NEW_LINE def twoEggDrop ( k ) : NEW_LINE INDENT return mt . ceil ( ( - 1.0 + mt . sqrt ( 1 + 8 * k ) ) / 2 ) NEW_LINE DEDENT k = 100 NEW_LINE print ( twoEggDrop ( k ) ) NEW_LINE
import math NEW_LINE def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( nextPerfectSquare ( N ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a // b , a % b , " % .9f " % ( a / b ) ) NEW_LINE
import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare / 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( " Not ▁ possiblen " ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) / 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT
n = 3 NEW_LINE MAX = 60 NEW_LINE dp = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE v = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE m = 5 NEW_LINE print ( findCount ( mat , n - 1 , n - 1 , m ) ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT A , B , P = map ( int , readline ( ) . split ( ) ) NEW_LINE if A == B == P == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT N = ( B - A + 1 ) NEW_LINE data = [ 0 ] * ( N + 1 ) NEW_LINE def get ( k ) : NEW_LINE INDENT s = 0 NEW_LINE while k : NEW_LINE INDENT s += data [ k ] NEW_LINE k -= k & - k NEW_LINE DEDENT return s % P NEW_LINE DEDENT * V , = range ( A , B + 1 ) NEW_LINE V . sort ( key = str ) NEW_LINE for v in V : NEW_LINE INDENT k = v + 1 - A NEW_LINE x = get ( k ) + 1 NEW_LINE while k <= N : NEW_LINE INDENT data [ k ] += x NEW_LINE k += k & - k NEW_LINE DEDENT DEDENT write ( " % d \n " % ( get ( N ) % P ) ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
def findNormal ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if ( y == ( 2 * x - x * x ) ) : NEW_LINE INDENT if ( dif < 0 ) : NEW_LINE INDENT print ( str ( 0 - dif ) + " y ▁ = ▁ " + " x " + str ( ( 0 - x ) + ( y * dif ) ) ) NEW_LINE DEDENT elif ( dif > 0 ) : NEW_LINE INDENT print ( str ( dif ) + " y ▁ = ▁ " + " - x + " + str ( x + dif * y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ = " , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE x = 2 NEW_LINE y = 0 NEW_LINE findNormal ( A , x , y ) NEW_LINE DEDENT
def pattern ( ) : NEW_LINE INDENT k = 0 NEW_LINE spaces = 1 NEW_LINE n = 7 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT spaces = spaces + 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT spaces = spaces - 4 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT spaces = spaces - 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT pattern ( ) NEW_LINE
import math NEW_LINE def answer ( n ) : NEW_LINE INDENT m = 2 ; NEW_LINE ans = 1 ; NEW_LINE r = 1 ; NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT m = m + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT print ( answer ( 7 ) ) ; NEW_LINE
def next_permutation ( L ) : NEW_LINE INDENT n = len ( L ) NEW_LINE i = n - 2 NEW_LINE while i >= 0 and L [ i ] >= L [ i + 1 ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT j = i + 1 NEW_LINE while j < n and L [ j ] > L [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT j -= 1 NEW_LINE L [ i ] , L [ j ] = L [ j ] , L [ i ] NEW_LINE left = i + 1 NEW_LINE right = n - 1 NEW_LINE while left < right : NEW_LINE INDENT L [ left ] , L [ right ] = L [ right ] , L [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def nPermute ( string , n ) : NEW_LINE INDENT string = list ( string ) NEW_LINE new_string = [ ] NEW_LINE string . sort ( ) NEW_LINE j = 2 NEW_LINE while next_permutation ( string ) : NEW_LINE INDENT new_string = string NEW_LINE if j == n : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( ' ' . join ( new_string ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GEEKSFORGEEKS " NEW_LINE n = 100 NEW_LINE nPermute ( string , n ) NEW_LINE DEDENT
import sys , math , copy NEW_LINE HUGE = 2147483647 NEW_LINE HUGEL = 9223372036854775807 NEW_LINE ABC = " abcdefghijklmnopqrstuvwxyz " NEW_LINE def main ( ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE su = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT line = input ( ) NEW_LINE su += line . count ( " # " ) NEW_LINE DEDENT print ( " Possible " if su == h + w - 1 else " Impossible " ) NEW_LINE DEDENT main ( ) NEW_LINE
def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE return str ( sum ( count_ways ( LENGTH , i ) for i in range ( 2 , 5 ) ) ) NEW_LINE DEDENT def count_ways ( length , m ) : NEW_LINE INDENT ways = [ 1 ] + [ 0 ] * length NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += ways [ n - 1 ] NEW_LINE if n >= m : NEW_LINE INDENT ways [ n ] += ways [ n - m ] NEW_LINE DEDENT DEDENT return ways [ - 1 ] - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT k = - 10 ** 9 NEW_LINE r = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = max ( k , arr [ i ] ) NEW_LINE r = min ( r , arr [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = k - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < n and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for i in range ( k - r ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT return flag == 0 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( check ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp // 10 NEW_LINE DEDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( isPrime [ n % mod ] != True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , " is ▁ left ▁ truncatable ▁ prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ left ▁ truncatable ▁ prime " ) NEW_LINE DEDENT
def minReplacement ( s , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if i % 2 == 0 and s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i % 2 == 1 and s [ i ] == '0' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , length - ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1100" NEW_LINE length = len ( s ) NEW_LINE print ( minReplacement ( s , length ) ) NEW_LINE DEDENT
def right_left ( a , n ) : NEW_LINE INDENT total = dict . fromkeys ( a , 0 ) ; NEW_LINE left = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in total : NEW_LINE INDENT total [ a [ i ] ] = 1 NEW_LINE DEDENT total [ a [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( total [ a [ i ] ] - 1 - ( 2 * left [ a [ i ] ] ) , end = " ▁ " ) ; NEW_LINE left [ a [ i ] ] += 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 2 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE right_left ( a , n ) ; NEW_LINE DEDENT
from sys import stdin NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in stdin . readline ( ) . split ( ' ▁ ' ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - 1 - i ) : NEW_LINE INDENT if ( A [ j ] > A [ j + 1 ] ) : NEW_LINE INDENT A [ j ] , A [ j + 1 ] = ( A [ j + 1 ] , A [ j ] ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' ▁ ' . join ( map ( str , A ) ) ) NEW_LINE print ( cnt ) NEW_LINE
def countPattern ( n , pat ) : NEW_LINE INDENT pattern_int = 0 NEW_LINE power_two = 1 NEW_LINE all_ones = 0 NEW_LINE i = len ( pat ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT current_bit = ord ( pat [ i ] ) - ord ( '0' ) NEW_LINE pattern_int += ( power_two * current_bit ) NEW_LINE all_ones = all_ones + power_two NEW_LINE power_two = power_two * 2 NEW_LINE i -= 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n != 0 and n >= pattern_int ) : NEW_LINE INDENT if ( ( n & all_ones ) == pattern_int ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 500 NEW_LINE pat = "10" NEW_LINE print ( countPattern ( n , pat ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( " ▁ " ) ] NEW_LINE a = [ int ( u ) for u in input ( ) . split ( " ▁ " ) ] NEW_LINE hash_a = [ 0 for i in range ( n + 2 ) ] NEW_LINE counters = [ 0 for i in range ( 2 * m ) ] NEW_LINE collector = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT hash_a [ a [ i ] ] += 1 NEW_LINE counters [ hash_a [ a [ i ] ] ] += 1 NEW_LINE if counters [ hash_a [ a [ i ] ] ] == n : NEW_LINE INDENT collector . append ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT collector . append ( "0" ) NEW_LINE DEDENT DEDENT print ( " " . join ( collector ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT num = n - 1 ; NEW_LINE num = 2 * ( 4 ** num ) ; NEW_LINE num = num // 3 ; NEW_LINE return num ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE print ( findNumber ( n ) ) ; NEW_LINE DEDENT
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT print ( multiply ( 5 , - 11 ) ) NEW_LINE
sz = 1000 NEW_LINE fib = set ( ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT prev , curr , length = 0 , 1 , 2 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( length <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE length += 1 NEW_LINE DEDENT DEDENT def printArray ( arr , length ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def removeFibonacci ( arr , length ) : NEW_LINE INDENT fibonacci ( ) NEW_LINE for i in fib : NEW_LINE INDENT if i in arr : NEW_LINE INDENT arr . remove ( i ) NEW_LINE length -= 1 NEW_LINE DEDENT DEDENT printArray ( arr , length ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 ] NEW_LINE length = len ( arr ) NEW_LINE removeFibonacci ( arr , length ) NEW_LINE DEDENT
import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j = j - 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ] NEW_LINE i = i + 2 NEW_LINE j = j - 2 NEW_LINE DEDENT arr_f = [ ] NEW_LINE arr_s = [ ] NEW_LINE for i in range ( int ( ( n + 1 ) / 2 ) ) : NEW_LINE INDENT arr_f . append ( arr [ i ] ) NEW_LINE DEDENT i = int ( ( n + 1 ) / 2 ) NEW_LINE while ( i < n ) : NEW_LINE INDENT arr_s . append ( arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT arr_f . sort ( ) NEW_LINE arr_s . sort ( reverse = True ) NEW_LINE for i in arr_s : NEW_LINE INDENT arr_f . append ( i ) NEW_LINE DEDENT return arr_f NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE arr = bitonicGenerator ( arr , n ) NEW_LINE print ( arr ) NEW_LINE
n = 5 NEW_LINE def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumSimple ( mat , k ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( m + n - 1 ) NEW_LINE if n == 1 and m == 1 : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i , 1 ) NEW_LINE DEDENT for i in range ( 2 , m + 1 ) : NEW_LINE INDENT print ( 1 , i ) NEW_LINE DEDENT DEDENT
v = [ 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 2 , 1 , 1 , 2 , 0 , 1 , 0 , 0 ] NEW_LINE n = int ( input ( ) ) NEW_LINE a = 1 if n == 0 else 0 NEW_LINE while n > 0 : NEW_LINE INDENT a += v [ n % 16 ] NEW_LINE n //= 16 NEW_LINE DEDENT print ( a ) NEW_LINE
def numOfWhiteHats ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT diffFreq = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT diffFreq += 1 NEW_LINE DEDENT DEDENT if ( diffFreq == 1 and freq [ n - 1 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( diffFreq == 1 and freq [ 0 ] == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( diffFreq != 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for k in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( freq [ k ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( freq [ k - 1 ] == k and freq [ k ] + k == n ) : NEW_LINE INDENT return freq [ k - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfWhiteHats ( arr , n ) ) NEW_LINE
def canBeBalanced ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count_1 = min ( count_1 , count ) NEW_LINE DEDENT if ( count_1 >= - 1 and count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s = " ( ) ) ( ) ( " NEW_LINE n = len ( s ) NEW_LINE if ( canBeBalanced ( s , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE cur = [ 0 for i in range ( 20 ) ] NEW_LINE counts = { 0 : cur . copy ( ) } NEW_LINE for i in range ( 1 , 200001 ) : NEW_LINE INDENT b = bin ( i ) NEW_LINE for j in range ( len ( b ) - 2 ) : NEW_LINE INDENT if b [ - j - 1 ] == '1' : cur [ j ] += 1 NEW_LINE DEDENT counts [ i ] = cur . copy ( ) NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE ar = counts [ r ] NEW_LINE al = counts [ l - 1 ] NEW_LINE cc = [ ar [ i ] - al [ i ] for i in range ( len ( ar ) ) ] NEW_LINE print ( r - l + 1 - max ( cc ) ) NEW_LINE DEDENT
def minInt ( str1 ) : NEW_LINE INDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] >= 5 ) : NEW_LINE INDENT str1 [ i ] = ( 9 - str1 [ i ] ) NEW_LINE DEDENT DEDENT if ( str1 [ 0 ] == 0 ) : NEW_LINE INDENT str1 [ 0 ] = 9 NEW_LINE DEDENT temp = " " NEW_LINE for i in str1 : NEW_LINE INDENT temp += str ( i ) NEW_LINE DEDENT return temp NEW_LINE DEDENT str1 = "589" NEW_LINE str1 = [ int ( i ) for i in str1 ] NEW_LINE print ( minInt ( str1 ) ) NEW_LINE
MAX = 100001 ; NEW_LINE prefix = [ 0 ] * MAX ; NEW_LINE def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 1 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i ; NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] ; NEW_LINE DEDENT DEDENT def sumOddFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) ; NEW_LINE DEDENT sieve_modified ( ) ; NEW_LINE l = 6 ; NEW_LINE r = 10 ; NEW_LINE print ( sumOddFactors ( l , r ) ) ; NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( " YES " ) if n % 4 == 0 else print ( " NO " ) NEW_LINE DEDENT
h , l = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( h * h + l * l ) / ( 2 * h ) - h ) NEW_LINE
import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT digits = 0 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) ; NEW_LINE DEDENT return math . floor ( digits ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 5 ) ) ; NEW_LINE print ( findDigits ( 10 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE
from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) / sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( " { : . 6 f } " . format ( largestCube ( r ) ) ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1 NEW_LINE for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i ; NEW_LINE path //= ( i - n + 1 ) ; NEW_LINE DEDENT return path ; NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) ; NEW_LINE
def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE mem = set ( ) NEW_LINE base = ord ( " a " ) - 1 NEW_LINE mod1 = 1000000007 NEW_LINE mod2 = 2147483647 NEW_LINE h1 = [ 0 ] NEW_LINE h2 = [ 0 ] NEW_LINE for c in s : NEW_LINE INDENT h1 . append ( ( h1 [ - 1 ] * 27 + ord ( c ) - base ) % mod1 ) NEW_LINE h2 . append ( ( h2 [ - 1 ] * 27 + ord ( c ) - base ) % mod2 ) NEW_LINE DEDENT pow_mem1 = { 0 : 1 } NEW_LINE pow_mem2 = { 0 : 1 } NEW_LINE def my_pow1 ( x ) : NEW_LINE INDENT if x in pow_mem1 : return pow_mem1 [ x ] NEW_LINE pow_mem1 [ x ] = my_pow1 ( x - 1 ) * 27 % mod1 NEW_LINE return pow_mem1 [ x ] NEW_LINE DEDENT def my_pow2 ( x ) : NEW_LINE INDENT if x in pow_mem2 : return pow_mem2 [ x ] NEW_LINE pow_mem2 [ x ] = my_pow2 ( x - 1 ) * 27 % mod2 NEW_LINE return pow_mem2 [ x ] NEW_LINE DEDENT left = right = 1 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT com = input ( ) NEW_LINE if com == " L + + " : NEW_LINE INDENT left += 1 NEW_LINE DEDENT if com == " L - - " : NEW_LINE INDENT left -= 1 NEW_LINE DEDENT if com == " R + + " : NEW_LINE INDENT right += 1 NEW_LINE DEDENT if com == " R - - " : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT x = ( h1 [ right ] - h1 [ left - 1 ] * my_pow1 ( right - left + 1 ) ) % mod1 NEW_LINE y = ( h2 [ right ] - h2 [ left - 1 ] * my_pow2 ( right - left + 1 ) ) % mod2 NEW_LINE mem . add ( ( x , y ) ) NEW_LINE DEDENT print ( len ( mem ) ) NEW_LINE DEDENT main ( ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def maxOfRightElement ( root ) : NEW_LINE INDENT res = - 999999 NEW_LINE if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT res = root . right . data NEW_LINE DEDENT return max ( maxOfRightElement ( root . right ) , res , maxOfRightElement ( root . left ) ) NEW_LINE DEDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 6 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( maxOfRightElement ( root ) ) NEW_LINE
def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n ; l = 1 ; NEW_LINE brr [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] ; NEW_LINE l += 1 ; NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( brr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 12 , 9 , 10 , 2 , 13 , 14 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE removeElements ( arr , n ) ; NEW_LINE DEDENT
def minSteps ( arr , N ) : NEW_LINE INDENT s = [ ] ; NEW_LINE s . append ( ( 0 , - 1 ) ) ; NEW_LINE maxStepsToeliminate = - 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT stepsToeliminate = 1 ; NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT if ( arr [ s [ - 1 ] [ 0 ] ] >= arr [ i ] ) : NEW_LINE INDENT stepsToeliminate = max ( stepsToeliminate , s [ - 1 ] [ 1 ] + 1 ) ; NEW_LINE s . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT stepsToeliminate = - 1 ; NEW_LINE DEDENT maxStepsToeliminate = max ( maxStepsToeliminate , stepsToeliminate ) ; NEW_LINE s . append ( ( i , stepsToeliminate ) ) ; NEW_LINE DEDENT print ( 0 if ( maxStepsToeliminate < 0 ) else maxStepsToeliminate ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 7 , 5 ] ; NEW_LINE size = len ( arr ) ; NEW_LINE minSteps ( arr , size ) ; NEW_LINE DEDENT
m = int ( input ( ) . split ( " ▁ " ) [ 1 ] ) NEW_LINE lookup_table = { } NEW_LINE for _ in range ( m ) : NEW_LINE INDENT word_one , word_two = input ( ) . split ( " ▁ " ) NEW_LINE min_word = min ( word_one , word_two , key = len ) NEW_LINE lookup_table [ word_one ] = min_word NEW_LINE lookup_table [ word_two ] = min_word NEW_LINE DEDENT final_sentence = input ( ) . split ( " ▁ " ) NEW_LINE print ( " ▁ " . join ( [ lookup_table [ word ] for word in final_sentence ] ) ) NEW_LINE
def check ( H , S ) : NEW_LINE INDENT return H * H >= 4 * S NEW_LINE DEDENT def findPairs ( H , n , S , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if check ( H [ i ] , S [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT H = [ 1 , 6 , 4 ] NEW_LINE n = len ( H ) NEW_LINE S = [ 23 , 3 , 42 , 14 ] NEW_LINE m = len ( S ) NEW_LINE print ( findPairs ( H , n , S , m ) ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE def Print3Smallest ( arr , n ) : NEW_LINE INDENT firstmin = MAX NEW_LINE secmin = MAX NEW_LINE thirdmin = MAX NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < firstmin : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = firstmin NEW_LINE firstmin = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < secmin : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < thirdmin : NEW_LINE INDENT thirdmin = arr [ i ] NEW_LINE DEDENT DEDENT print ( " First ▁ min ▁ = " , firstmin ) NEW_LINE print ( " Second ▁ min ▁ = " , secmin ) NEW_LINE print ( " Third ▁ min ▁ = " , thirdmin ) NEW_LINE DEDENT arr = [ 4 , 9 , 1 , 32 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE Print3Smallest ( arr , n ) NEW_LINE
s = input ( ) NEW_LINE s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE s3 = [ ] NEW_LINE s4 = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 4 == 0 : NEW_LINE INDENT s1 . append ( s [ i ] ) NEW_LINE DEDENT elif i % 4 == 1 : NEW_LINE INDENT s2 . append ( s [ i ] ) NEW_LINE DEDENT elif i % 4 == 2 : NEW_LINE INDENT s3 . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s4 . append ( s [ i ] ) NEW_LINE DEDENT DEDENT if ' R ' in s1 : NEW_LINE INDENT ls_R = s1 NEW_LINE DEDENT elif ' R ' in s2 : NEW_LINE INDENT ls_R = s2 NEW_LINE DEDENT elif ' R ' in s3 : NEW_LINE INDENT ls_R = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_R = s4 NEW_LINE DEDENT if ' B ' in s1 : NEW_LINE INDENT ls_B = s1 NEW_LINE DEDENT elif ' B ' in s2 : NEW_LINE INDENT ls_B = s2 NEW_LINE DEDENT elif ' B ' in s3 : NEW_LINE INDENT ls_B = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_B = s4 NEW_LINE DEDENT if ' Y ' in s1 : NEW_LINE INDENT ls_Y = s1 NEW_LINE DEDENT elif ' Y ' in s2 : NEW_LINE INDENT ls_Y = s2 NEW_LINE DEDENT elif ' Y ' in s3 : NEW_LINE INDENT ls_Y = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_Y = s4 NEW_LINE DEDENT if ' G ' in s1 : NEW_LINE INDENT ls_G = s1 NEW_LINE DEDENT elif ' G ' in s2 : NEW_LINE INDENT ls_G = s2 NEW_LINE DEDENT elif ' G ' in s3 : NEW_LINE INDENT ls_G = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_G = s4 NEW_LINE DEDENT print ( ls_R . count ( ' ! ' ) , ls_B . count ( ' ! ' ) , ls_Y . count ( ' ! ' ) , ls_G . count ( ' ! ' ) ) NEW_LINE
def dayofweek ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= m < 3 NEW_LINE return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) NEW_LINE DEDENT day = dayofweek ( 30 , 8 , 2010 ) NEW_LINE print ( day ) NEW_LINE
def powerNumbers ( n ) : NEW_LINE INDENT v = set ( ) ; NEW_LINE v . add ( 1 ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i * i <= n ) : NEW_LINE INDENT j = i * i ; NEW_LINE v . add ( j ) ; NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT v . add ( j * i ) ; NEW_LINE j = j * i ; NEW_LINE DEDENT DEDENT DEDENT return len ( v ) ; NEW_LINE DEDENT print ( powerNumbers ( 50 ) ) ; NEW_LINE
def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n / 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isDivisibleBy10 ( bin , n ) : NEW_LINE INDENT if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT posFromRight = n - i - 1 NEW_LINE if ( posFromRight % 4 == 1 ) : NEW_LINE INDENT sum = sum + 2 NEW_LINE DEDENT elif ( posFromRight % 4 == 2 ) : NEW_LINE INDENT sum = sum + 4 NEW_LINE DEDENT elif ( posFromRight % 4 == 3 ) : NEW_LINE INDENT sum = sum + 8 NEW_LINE DEDENT elif ( posFromRight % 4 == 0 ) : NEW_LINE INDENT sum = sum + 6 NEW_LINE DEDENT DEDENT DEDENT if ( sum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isDivisibleBy20 ( bin , n ) : NEW_LINE INDENT if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return false NEW_LINE DEDENT return isDivisibleBy10 ( bin , n - 1 ) NEW_LINE DEDENT bin = [ '1' , '0' , '1' , '0' , '0' , '0' ] NEW_LINE n = len ( bin ) NEW_LINE if ( isDivisibleBy20 ( bin , n - 1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 100 NEW_LINE x , y = 51 , 100 NEW_LINE halfsquare ( n , x , y ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while ( a != 0 ) : NEW_LINE INDENT c = a ; NEW_LINE a = b % a ; NEW_LINE b = c ; NEW_LINE DEDENT return b ; NEW_LINE DEDENT def forbenius ( X , Y ) : NEW_LINE INDENT if ( gcd ( X , Y ) != 1 ) : NEW_LINE INDENT print ( " NA " ) ; NEW_LINE return ; NEW_LINE DEDENT A = ( X * Y ) - ( X + Y ) ; NEW_LINE N = ( X - 1 ) * ( Y - 1 ) // 2 ; NEW_LINE print ( " Largest ▁ Amount ▁ = " , A ) ; NEW_LINE print ( " Total ▁ Count ▁ = " , N ) ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 5 ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE X = 5 ; NEW_LINE Y = 10 ; NEW_LINE print ( " " ) ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE print ( " Array ▁ after ▁ sorting ▁ : ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n ; NEW_LINE print ( " m ▁ = " , m ) ; NEW_LINE print ( " c ▁ = " , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT head = None NEW_LINE def push ( head_ref , new_data ) : NEW_LINE INDENT global head NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE head = head_ref NEW_LINE DEDENT def productOfLastN_NodesUtil ( head , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT st = [ ] NEW_LINE prod = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT st . append ( head . data ) NEW_LINE head = head . next NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 1 NEW_LINE prod *= st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT return prod NEW_LINE DEDENT head = None NEW_LINE push ( head , 12 ) NEW_LINE push ( head , 4 ) NEW_LINE push ( head , 8 ) NEW_LINE push ( head , 6 ) NEW_LINE push ( head , 10 ) NEW_LINE n = 2 NEW_LINE print ( productOfLastN_NodesUtil ( head , n ) ) NEW_LINE
def modExp ( a , b ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( int ( b ) & 1 ) : NEW_LINE INDENT result = result * a NEW_LINE DEDENT a = a * a NEW_LINE b /= 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def check ( num ) : NEW_LINE INDENT if ( num & 1 or num < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( num % 4 == 0 ) : NEW_LINE INDENT return modExp ( num / 4 , 4 ) NEW_LINE DEDENT elif ( num % 6 == 0 ) : NEW_LINE INDENT return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) NEW_LINE DEDENT elif ( num % 10 == 0 ) : NEW_LINE INDENT return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 10 NEW_LINE print ( int ( check ( num ) ) ) NEW_LINE DEDENT
def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT res = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) : NEW_LINE INDENT res = ( arr [ i ] - arr [ j ] - i + j ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , i , j = 0 , 0 , 0 , 0 NEW_LINE print ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) NEW_LINE a = int ( input ( ) ) NEW_LINE print ( " Enter ▁ upper ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( " Prime ▁ numbers ▁ between " , a , " and " , b , " are : ▁ " , end = " " ) NEW_LINE if ( a == 1 ) : NEW_LINE INDENT print ( a ) NEW_LINE a += 1 NEW_LINE if ( b >= 2 ) : NEW_LINE INDENT print ( a ) NEW_LINE a += 1 NEW_LINE DEDENT DEDENT if ( a == 2 ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT if ( a % 2 == 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT for i in range ( a , b + 1 , 2 ) : NEW_LINE INDENT flag = 1 NEW_LINE j = 2 NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , i , j , flag = 0 , 0 , 0 , 0 , 0 NEW_LINE print ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) NEW_LINE a = int ( input ( ) ) NEW_LINE print ( " Enter ▁ upper ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( " Prime ▁ numbers ▁ between " , a , " and " , b , " are : ▁ " , end = " " ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = 1 NEW_LINE for j in range ( 2 , i // 2 + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT
MAX = 100 NEW_LINE def smallestInRow ( mat , n , m ) : NEW_LINE INDENT print ( " { " , end = " ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT minm = mat [ i ] [ 0 ] NEW_LINE for j in range ( 1 , m , 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < minm ) : NEW_LINE INDENT minm = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( minm , end = " , ▁ " ) NEW_LINE DEDENT print ( " } " ) NEW_LINE DEDENT def smallestInCol ( mat , n , m ) : NEW_LINE INDENT print ( " { " , end = " ▁ " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT minm = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( mat [ j ] [ i ] < minm ) : NEW_LINE INDENT minm = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT print ( minm , end = " , ▁ " ) NEW_LINE DEDENT print ( " } " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE mat = [ [ 2 , 1 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 4 , 9 ] ] ; NEW_LINE print ( " Minimum ▁ element ▁ of ▁ each ▁ row ▁ is " , end = " ▁ " ) NEW_LINE smallestInRow ( mat , n , m ) NEW_LINE print ( " Minimum ▁ element ▁ of ▁ each ▁ column ▁ is " , end = " ▁ " ) NEW_LINE smallestInCol ( mat , n , m ) NEW_LINE DEDENT
def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT
def dfs ( v , k , s ) : NEW_LINE INDENT if k == K : NEW_LINE INDENT return 1 if s == S else 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( v + 1 , N + 1 ) : NEW_LINE INDENT res += dfs ( i , k + 1 , s + i ) NEW_LINE DEDENT return res NEW_LINE DEDENT while True : NEW_LINE INDENT N , K , S = map ( int , input ( ) . split ( ) ) NEW_LINE if not N : NEW_LINE INDENT break NEW_LINE DEDENT print ( dfs ( 0 , 0 , 0 ) ) NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( countP ( 3 , 2 ) ) NEW_LINE DEDENT
def check ( ) : NEW_LINE INDENT mat = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT mat . append ( list ( input ( ) ) ) NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < len ( mat ) ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ( mat [ 2 - i ] [ 2 - j ] ) ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT check ( ) NEW_LINE
def calculate ( N ) : NEW_LINE INDENT length = len ( N ) NEW_LINE l = int ( ( length ) / 2 ) NEW_LINE count = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT s = N [ 0 : 0 + i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE try : NEW_LINE INDENT if s [ 0 ] == '0' or t [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT continue NEW_LINE DEDENT if s == t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = str ( "2202200" ) NEW_LINE print ( calculate ( N ) ) NEW_LINE
N , Q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = max ( C ) + 1 NEW_LINE t1 = [ 0 ] * ( M ) NEW_LINE for v in C : NEW_LINE INDENT t1 [ v ] = 1 NEW_LINE DEDENT t2 = [ 0 ] * ( M ) NEW_LINE v = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if t1 [ i ] : NEW_LINE INDENT v = i NEW_LINE DEDENT t2 [ i ] = v NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE n_v = M - 1 NEW_LINE m = 0 NEW_LINE while n_v != 0 : NEW_LINE INDENT amr = n_v % t NEW_LINE m = max ( m , amr ) NEW_LINE tmp = n_v - m - 1 NEW_LINE if tmp <= 0 : break NEW_LINE n_v = t2 [ tmp ] NEW_LINE DEDENT print ( m ) NEW_LINE DEDENT
def printIndices ( n , a ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] [ 1 ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT def printPermutations ( n , a , k ) : NEW_LINE INDENT arr = [ [ 0 , 0 ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ 0 ] = a [ i ] NEW_LINE arr [ i ] [ 1 ] = i NEW_LINE DEDENT arr . sort ( reverse = False ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] == arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < k ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( k - 1 ) : NEW_LINE INDENT printIndices ( n , arr ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ j ] [ 0 ] == arr [ j - 1 ] [ 0 ] ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = temp NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT printIndices ( n , arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 3 , 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE printPermutations ( n , a , k ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( n ** ( 0.5 ) ) NEW_LINE prime = [ i for i in range ( limit + 1 ) ] NEW_LINE i = 2 NEW_LINE while i * i <= limit : NEW_LINE INDENT if prime [ i ] == i : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if prime [ j ] == j : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if p * q == i and q != 1 and p != q : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif prime [ i ] == i : NEW_LINE INDENT if i ** 8 <= n : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT
for s in [ * open ( 0 ) ] [ 1 : ] : n , m , k = map ( int , s . split ( ) ) ; print ( ( min ( m , n // k ) * k - m ) // ( k - 1 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE ans = [ 0 ] * n NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT cnt = 0 NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if b [ j ] == a [ i ] : NEW_LINE INDENT ans [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans [ a [ i ] - 1 ] += cnt NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT
def smallestPoss ( s , n ) : NEW_LINE INDENT ans = " " ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; NEW_LINE K = "325343273113434" ; NEW_LINE print ( smallestPoss ( K , N ) ) ; NEW_LINE DEDENT
list1 = [ ] NEW_LINE for x in range ( 0 , 10 ) : NEW_LINE INDENT for y in range ( 0 , 10 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 0 , ( 2 ** i ) + 1 ) : NEW_LINE INDENT bn = bin ( j ) NEW_LINE bn = bn [ 2 : ] NEW_LINE c = bn . zfill ( i ) NEW_LINE temp = c . replace ( "0" , str ( x ) ) NEW_LINE res = temp . replace ( "1" , str ( y ) ) NEW_LINE list1 . append ( int ( res ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT list1 = sorted ( list ( set ( list1 ) ) ) NEW_LINE inp1 = int ( input ( ) ) NEW_LINE ans = - 1 NEW_LINE for x in range ( len ( list1 ) ) : NEW_LINE INDENT if int ( list1 [ x ] ) <= inp1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def return_palindrome ( s : str , c : str , i : int ) : NEW_LINE INDENT new_s = s [ : i ] + c + s [ i : ] NEW_LINE if new_s == new_s [ : : - 1 ] : NEW_LINE INDENT return new_s NEW_LINE DEDENT else : NEW_LINE INDENT return " NA " NEW_LINE DEDENT DEDENT s = input ( ) NEW_LINE found = False NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT for c in " abcdefghijklmnopqrstuvwxyz " : NEW_LINE INDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT palindrome = return_palindrome ( s , c , i ) NEW_LINE if palindrome != " NA " : NEW_LINE INDENT print ( palindrome ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if not found : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 1000000 ) NEW_LINE for n in range ( 5 , len ( primes ) , 2 ) : NEW_LINE INDENT rem = n * primes [ n - 1 ] * 2 NEW_LINE if rem > 10000000000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
necklace = input ( ) NEW_LINE strings = necklace . count ( ' - ' ) NEW_LINE pearls = necklace . count ( ' o ' ) NEW_LINE if pearls == 0 : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT elif strings == 0 : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT elif ( strings % pearls ) == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT graph = [ [ ] for _ in range ( 51 ) ] NEW_LINE for start in range ( 51 ) : NEW_LINE INDENT for cost in range ( 1 , 51 ) : NEW_LINE INDENT if start % cost == 0 : NEW_LINE INDENT graph [ 0 ] . append ( ( cost , start ) ) NEW_LINE DEDENT DEDENT DEDENT for end in range ( 1 , 51 ) : NEW_LINE INDENT for cost in range ( end + 1 , 51 ) : NEW_LINE INDENT start = end + cost NEW_LINE while start <= 50 : NEW_LINE INDENT graph [ end ] . append ( ( cost , start ) ) NEW_LINE start += cost NEW_LINE DEDENT DEDENT DEDENT use = 0 NEW_LINE for l in reversed ( range ( 1 , 52 ) ) : NEW_LINE INDENT for a , b in zip ( A , B ) : NEW_LINE INDENT ok = False NEW_LINE q = [ b ] NEW_LINE checked = [ False ] * 51 NEW_LINE checked [ b ] = True NEW_LINE while q : NEW_LINE INDENT qq = [ ] NEW_LINE for p in q : NEW_LINE INDENT if p == a : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT for cost , np in graph [ p ] : NEW_LINE INDENT if not checked [ np ] and ( cost < l or use & ( 1 << cost ) ) : NEW_LINE INDENT checked [ np ] = True NEW_LINE qq . append ( np ) NEW_LINE DEDENT DEDENT DEDENT if ok : break NEW_LINE q = qq NEW_LINE DEDENT if not ok : NEW_LINE INDENT if l == 51 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT use |= ( 1 << l ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return use NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Trie : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = Node ( 0 ) NEW_LINE DEDENT def insert ( self , pre_xor ) : NEW_LINE INDENT self . temp = self . root NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT val = pre_xor & ( 1 << i ) NEW_LINE if val : NEW_LINE INDENT if not self . temp . right : NEW_LINE INDENT self . temp . right = Node ( 0 ) NEW_LINE DEDENT self . temp = self . temp . right NEW_LINE DEDENT if not val : NEW_LINE INDENT if not self . temp . left : NEW_LINE INDENT self . temp . left = Node ( 0 ) NEW_LINE DEDENT self . temp = self . temp . left NEW_LINE DEDENT DEDENT self . temp . data = pre_xor NEW_LINE DEDENT def query ( self , xor ) : NEW_LINE INDENT self . temp = self . root NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT val = xor & ( 1 << i ) NEW_LINE if val : NEW_LINE INDENT if self . temp . left : NEW_LINE INDENT self . temp = self . temp . left NEW_LINE DEDENT elif self . temp . right : NEW_LINE INDENT self . temp = self . temp . right NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . temp . right : NEW_LINE INDENT self . temp = self . temp . right NEW_LINE DEDENT elif self . temp . left : NEW_LINE INDENT self . temp = self . temp . left NEW_LINE DEDENT DEDENT DEDENT return xor ^ self . temp . data NEW_LINE DEDENT def maxSubArrayXOR ( self , n , Arr ) : NEW_LINE INDENT self . insert ( 0 ) NEW_LINE result = - float ( ' inf ' ) NEW_LINE pre_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_xor = pre_xor ^ Arr [ i ] NEW_LINE self . insert ( pre_xor ) NEW_LINE result = max ( result , self . query ( pre_xor ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 8 , 1 , 2 , 12 ] NEW_LINE n = len ( Arr ) NEW_LINE trie = Trie ( ) NEW_LINE print ( " Max ▁ subarray ▁ XOR ▁ is ▁ " + str ( trie . maxSubArrayXOR ( n , Arr ) ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = a . index ( 1 ) + 1 NEW_LINE y = a . index ( n ) + 1 NEW_LINE print ( max ( abs ( n - x ) , abs ( n - y ) , abs ( 1 - x ) , abs ( 1 - y ) ) ) NEW_LINE
def sumSubarrayMins ( A , n ) : NEW_LINE INDENT left , right = [ None ] * n , [ None ] * n NEW_LINE s1 , s2 = [ ] , [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s1 ) > 0 and s1 [ - 1 ] [ 0 ] > A [ i ] : NEW_LINE INDENT cnt += s1 [ - 1 ] [ 1 ] NEW_LINE s1 . pop ( ) NEW_LINE DEDENT s1 . append ( [ A [ i ] , cnt ] ) NEW_LINE left [ i ] = cnt NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] > A [ i ] : NEW_LINE INDENT cnt += s2 [ - 1 ] [ 1 ] NEW_LINE s2 . pop ( ) NEW_LINE DEDENT s2 . append ( [ A [ i ] , cnt ] ) NEW_LINE right [ i ] = cnt NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += A [ i ] * left [ i ] * right [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 3 , 1 , 2 , 4 ] NEW_LINE n = len ( A ) NEW_LINE print ( sumSubarrayMins ( A , n ) ) NEW_LINE DEDENT
def isValid ( n , d ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE sum = digit ; NEW_LINE if ( digit == d ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE if ( digit == d or digit <= sum ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += digit ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printGoodNumber ( L , R , d ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isValid ( i , d ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT L = 410 ; NEW_LINE R = 520 ; NEW_LINE d = 3 ; NEW_LINE printGoodNumber ( L , R , d ) ; NEW_LINE
N = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def nthprimedigitsnumber ( n ) : NEW_LINE INDENT len = 1 ; NEW_LINE prev_count = 0 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_count = ( prev_count + math . pow ( 4 , len ) ) ; NEW_LINE if ( prev_count < n and curr_count >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT len += 1 ; NEW_LINE prev_count = curr_count ; NEW_LINE DEDENT for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if ( prev_count + pow ( 4 , len - i ) < n ) : NEW_LINE INDENT prev_count += pow ( 4 , len - i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( j == 1 ) : NEW_LINE INDENT print ( "2" , end = " " ) ; NEW_LINE DEDENT elif ( j == 2 ) : NEW_LINE INDENT print ( "3" , end = " " ) ; NEW_LINE DEDENT elif ( j == 3 ) : NEW_LINE INDENT print ( "5" , end = " " ) ; NEW_LINE DEDENT elif ( j == 4 ) : NEW_LINE INDENT print ( "7" , end = " " ) ; NEW_LINE DEDENT break ; NEW_LINE DEDENT DEDENT DEDENT print ( ) ; NEW_LINE DEDENT nthprimedigitsnumber ( 10 ) ; NEW_LINE nthprimedigitsnumber ( 21 ) ; NEW_LINE
num_lines = int ( input ( ) ) NEW_LINE for iii in range ( num_lines ) : NEW_LINE INDENT s = input ( ) NEW_LINE low_idx = 0 NEW_LINE high_idx = 0 NEW_LINE lowest_amount = - 1 NEW_LINE counts = [ 0 , 0 , 0 ] NEW_LINE counts [ int ( s [ 0 ] ) - 1 ] += 1 NEW_LINE is_valid = True NEW_LINE while ( counts [ 0 ] == 0 or counts [ 1 ] == 0 or counts [ 2 ] == 0 ) : NEW_LINE INDENT high_idx += 1 NEW_LINE if ( high_idx >= len ( s ) ) : NEW_LINE INDENT is_valid = False NEW_LINE break NEW_LINE DEDENT counts [ int ( s [ high_idx ] ) - 1 ] += 1 NEW_LINE DEDENT if ( not is_valid ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ( high_idx >= 2 ) NEW_LINE lowest_amount = high_idx NEW_LINE while ( low_idx != len ( s ) - 1 ) : NEW_LINE INDENT if ( is_valid ) : NEW_LINE INDENT counts [ int ( s [ low_idx ] ) - 1 ] -= 1 NEW_LINE if ( counts [ int ( s [ low_idx ] ) - 1 ] == 0 ) : NEW_LINE INDENT is_valid = False NEW_LINE DEDENT low_idx += 1 NEW_LINE if ( is_valid ) : NEW_LINE INDENT lowest_amount = min ( lowest_amount , high_idx - low_idx ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( high_idx == len ( s ) - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT high_idx += 1 NEW_LINE counts [ int ( s [ high_idx ] ) - 1 ] += 1 NEW_LINE if ( counts [ int ( s [ high_idx ] ) - 1 ] == 1 ) : NEW_LINE INDENT is_valid = True NEW_LINE DEDENT DEDENT DEDENT print ( lowest_amount + 1 ) NEW_LINE DEDENT DEDENT s = """ STRNEWLINE c [ ?7l [ 2J [ 0mSeaBIOS ▁ ( version ▁ rel - 1.13.0-48 - gd9c812dda519 - prebuilt . qemu . org ) STRNEWLINE STRNEWLINE STRNEWLINE iPXE ▁ ( http : / / ipxe . org ) ▁ 00:03.0 ▁ CA00 ▁ PCI2.10 ▁ PnP ▁ PMM + 07F8F290 + 07EEF290 ▁ CA00 STRNEWLINE Press ▁ Ctrl - B ▁ to ▁ configure ▁ iPXE ▁ ( PCI ▁ 00:03.0 ) . . . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ STRNEWLINE STRNEWLINE STRNEWLINE Booting ▁ from ▁ Hard ▁ Disk . . . xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx STRNEWLINE xxxxxxxxxxxxxxxxxxxxxxxxxx STRNEWLINE | ▁ What ▁ just ▁ happened ? ▁ Why ▁ am ▁ I ▁ here ? STRNEWLINE | ▁ Discovering ▁ my ▁ identity ▁ and ▁ features STRNEWLINE | ▁ ▁ ▁ ▁ ▁ CPUID : ▁ AuthenticAMD STRNEWLINE | ▁ ▁ ▁ ▁ ▁ has ▁ SSE3 STRNEWLINE | ▁ ▁ ▁ ▁ ▁ has ▁ MONITOR / MWAIT STRNEWLINE | ▁ ▁ ▁ ▁ ▁ running ▁ on ▁ hypervisor STRNEWLINE | ▁ totalProcs ▁ 4 STRNEWLINE | ▁ memSize ▁ 0x7fd0000 ▁ 127MB STRNEWLINE | ▁ localAPIC ▁ fee00000 STRNEWLINE | ▁ ioAPIC ▁ fec00000 STRNEWLINE | ▁ heap ▁ range ▁ 0x100000 ▁ 0x600000 STRNEWLINE | ▁ switched ▁ to ▁ new ▁ UART STRNEWLINE instantiating ▁ block ▁ cahce STRNEWLINE | ▁ pitInit ▁ freq ▁ 1000Hz STRNEWLINE | ▁ pitInit ▁ divider ▁ 59659 STRNEWLINE | ▁ APIT ▁ running ▁ at ▁ 1000116744Hz STRNEWLINE | ▁ APIT ▁ counter = 1000116 ▁ for ▁ 1000Hz STRNEWLINE | ▁ initialize ▁ 1 STRNEWLINE | ▁ reset ▁ 1 STRNEWLINE | ▁ ▁ ▁ ▁ ▁ ▁ eip : 0x8000 STRNEWLINE | ▁ initialize ▁ 2 STRNEWLINE | ▁ reset ▁ 2 STRNEWLINE | ▁ ▁ ▁ ▁ ▁ ▁ eip : 0x8000 STRNEWLINE | ▁ 1 ▁ enabling ▁ interrupts , ▁ I ' m ▁ scared STRNEWLINE | ▁ initialize ▁ 3 STRNEWLINE | ▁ reset ▁ 3 STRNEWLINE | ▁ ▁ ▁ ▁ ▁ ▁ eip : 0x8000 STRNEWLINE | ▁ 2 ▁ enabling ▁ interrupts , ▁ I ' m ▁ scared STRNEWLINE | ▁ 0 ▁ enabling ▁ interrupts , ▁ I ' m ▁ scared STRNEWLINE | ▁ 3 ▁ enabling ▁ interrupts , ▁ I ' m ▁ scared STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 2 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 3 STRNEWLINE instantiating ▁ this ▁ guy STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 4 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 10 STRNEWLINE * * * ▁ block ▁ size ▁ is ▁ 1024 STRNEWLINE * * * ▁ inode ▁ size ▁ is ▁ 128 STRNEWLINE * * * ▁ looking ▁ at ▁ / STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ directory STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1290 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1291 STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 7 ▁ entries STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 4 ▁ links STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 14 STRNEWLINE * * * ▁ looking ▁ at ▁ / hello STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ file STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 23 ▁ bytes STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 1 ▁ links STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1380 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1381 STRNEWLINE * * * ▁ you ▁ can ▁ read ▁ files STRNEWLINE STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 13 STRNEWLINE * * * ▁ looking ▁ at ▁ / goodbye STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ symbolic ▁ link STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ link ▁ size ▁ is ▁ 5 STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ ▁ = > ▁ hello STRNEWLINE * * * ▁ looking ▁ at ▁ / not _ there STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ does ▁ not ▁ exist STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 13 STRNEWLINE * * * ▁ looking ▁ at ▁ / fotunes STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ file STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 26637 ▁ bytes STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 1 ▁ links STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1348 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1349 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1364 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1365 STRNEWLINE " Oh , ▁ that ' s ▁ the ▁ name ▁ of ▁ the ▁ song , ▁ is ▁ it ? " ▁ Alice ▁ said STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 10 STRNEWLINE * * * ▁ looking ▁ at ▁ / . STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ directory STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 7 ▁ entries STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 4 ▁ links STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 10 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 10 STRNEWLINE * * * ▁ looking ▁ at ▁ / . . STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ directory STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 7 ▁ entries STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 4 ▁ links STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 10 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 12 STRNEWLINE * * * ▁ looking ▁ at ▁ / data STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ directory STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1316 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1317 STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 4 ▁ entries STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 2 ▁ links STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 10 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 12 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 13 STRNEWLINE * * * ▁ looking ▁ at ▁ / data / data . txt STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ file STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 33 ▁ bytes STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 1 ▁ links STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1318 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1319 STRNEWLINE * * * ▁ this ▁ is ▁ nice STRNEWLINE * * * ▁ we ▁ can ▁ read STRNEWLINE STRNEWLINE * * * ▁ STRNEWLINE * * * ▁ w STRNEWLINE * * * ▁ we STRNEWLINE * * * ▁ we ▁ STRNEWLINE * * * ▁ we ▁ c STRNEWLINE * * * ▁ we ▁ ca STRNEWLINE * * * ▁ we ▁ can STRNEWLINE * * * ▁ we ▁ can ▁ STRNEWLINE * * * ▁ we ▁ can ▁ r STRNEWLINE * * * ▁ we ▁ can ▁ re STRNEWLINE * * * ▁ we ▁ can ▁ rea STRNEWLINE * * * ▁ we ▁ can ▁ read STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 13 STRNEWLINE * * * ▁ looking ▁ at ▁ / data / panic . txt STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ is ▁ a ▁ file STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ contains ▁ 1736 ▁ bytes STRNEWLINE * * * ▁ ▁ ▁ ▁ ▁ ▁ has ▁ 1 ▁ links STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1320 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1321 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1322 STRNEWLINE STRNEWLINE ! ! ! ! READING ▁ SECTOR ▁ 1323 STRNEWLINE * * * ▁ Don ' t ▁ panic STRNEWLINE * * * ▁ STRNEWLINE STRNEWLINE shutdown STRNEWLINE """ NEW_LINE
from itertools import zip_longest as zl NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m - n * 2 <= 0 : NEW_LINE INDENT wind = list ( range ( 1 , m + 1 ) ) NEW_LINE prh = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT man = range ( 1 , m + 1 ) NEW_LINE wind = list ( man [ : n * 2 ] ) NEW_LINE prh = list ( man [ n * 2 : ] ) NEW_LINE DEDENT for a , b in zl ( prh , wind , fillvalue = ' ' ) : NEW_LINE INDENT print ( str ( a ) + ' ▁ ' + str ( b ) , end = ' ▁ ' ) NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 , 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 632 NEW_LINE print ( maxAND ( L , R ) ) NEW_LINE DEDENT
def Minimum_Operations ( a , n ) : NEW_LINE INDENT np = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT np [ i ] = np [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT np [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT ans = min ( ans , pos + np [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ - 1 , 0 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Minimum_Operations ( a , n ) ) NEW_LINE
import math NEW_LINE import itertools NEW_LINE import sys NEW_LINE import copy NEW_LINE A , B , K = map ( int , input ( ) . split ( ) ) NEW_LINE if B - A < K * 2 : NEW_LINE INDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( A , A + K ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT for i in range ( B - K + 1 , B + 1 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE lst , row , col = [ ] , [ ] , [ ] NEW_LINE ans = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT z = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst . append ( z ) NEW_LINE row . append ( sum ( z ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT z = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT z . append ( lst [ j ] [ i ] ) NEW_LINE DEDENT col . append ( sum ( z ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if col [ i ] > row [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT converted = "01" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % ( negBase ) NEW_LINE n = int ( n / negBase ) NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( ( - 1 ) * negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE DEDENT
a = sorted ( [ int ( j ) for j in input ( ) . split ( ) ] ) NEW_LINE cost = 0 NEW_LINE for j in range ( len ( a ) - 1 ) : NEW_LINE INDENT cost += abs ( a [ j ] - a [ j + 1 ] ) NEW_LINE DEDENT print ( cost ) NEW_LINE
def RSF ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT x = n ; NEW_LINE l = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE l += 1 ; NEW_LINE DEDENT a = [ 0 ] * l ; NEW_LINE i = l - 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT a [ i ] = x % 10 ; NEW_LINE x = x // 10 ; NEW_LINE i -= 1 ; NEW_LINE DEDENT for j in range ( 0 , l - 1 ) : NEW_LINE INDENT n = n * 10 + abs ( a [ j ] - a [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return n ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 614 ; NEW_LINE ans = RSF ( n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT
import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT newNode = Node ( data ) NEW_LINE newNode . next = head NEW_LINE head = newNode NEW_LINE return head NEW_LINE DEDENT def circular ( head ) : NEW_LINE INDENT start = head NEW_LINE while ( head . next is not None ) : NEW_LINE INDENT head = head . next NEW_LINE DEDENT head . next = start NEW_LINE return start NEW_LINE DEDENT def displayList ( node ) : NEW_LINE INDENT start = node NEW_LINE while ( node . next is not start ) : NEW_LINE INDENT print ( " { } ▁ " . format ( node . data ) , end = " " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " { } ▁ " . format ( node . data ) , end = " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 14 ) NEW_LINE head = push ( head , 13 ) NEW_LINE head = push ( head , 22 ) NEW_LINE head = push ( head , 17 ) NEW_LINE circular ( head ) NEW_LINE print ( " Display ▁ List : " ) NEW_LINE displayList ( head ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE S = "5F3Z - 2e - 9 - w " NEW_LINE K = 4 NEW_LINE out = sObj . licenseKeyFormatting ( S , K ) NEW_LINE print ( out ) NEW_LINE DEDENT
import math NEW_LINE EPS = 1E-15 ; NEW_LINE def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( arr [ i ] ) + EPS ; NEW_LINE DEDENT xl = ( sum / n + EPS ) ; NEW_LINE res = math . pow ( 10.0 , xl ) + EPS ; NEW_LINE return float ( math . ceil ( res + EPS ) ) ; NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 10 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinValue ( arr , n ) ) ; NEW_LINE
import math NEW_LINE def digitalRoot ( num ) : NEW_LINE INDENT if ( num == "0" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT ans = ( ans + int ( num [ i ] ) ) % 9 NEW_LINE DEDENT if ( ans == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return ans % 9 NEW_LINE DEDENT DEDENT num = "65785412" NEW_LINE print ( digitalRoot ( num ) ) NEW_LINE
n1 , n2 = map ( int , ( input ( ) . split ( ) ) ) NEW_LINE sequence = [ ] NEW_LINE found = False NEW_LINE def change ( num , seq , n2 ) : NEW_LINE INDENT if num == n2 : NEW_LINE INDENT global found , sequence NEW_LINE found = True NEW_LINE sequence = seq . copy ( ) NEW_LINE return NEW_LINE DEDENT if num > n2 : NEW_LINE INDENT return NEW_LINE DEDENT change ( num * 2 , seq + [ num * 2 ] , n2 ) NEW_LINE change ( ( num * 10 ) + 1 , seq + [ ( num * 10 ) + 1 ] , n2 ) NEW_LINE DEDENT change ( n1 , [ n1 ] , n2 ) NEW_LINE if found : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( len ( sequence ) ) NEW_LINE for n in sequence : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def k_sum ( a , n , k ) : NEW_LINE INDENT r , sum = 0 , 0 ; NEW_LINE ans = 0 ; NEW_LINE for l in range ( n ) : NEW_LINE INDENT while ( sum < k ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ r ] ; NEW_LINE r += 1 ; NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans += n - r + 1 ; NEW_LINE sum -= a [ l ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT a = [ 6 , 1 , 2 , 7 ] ; k = 10 ; NEW_LINE n = len ( a ) ; NEW_LINE print ( k_sum ( a , n , k ) ) ; NEW_LINE
def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT strr = " gfg " NEW_LINE print ( getChar ( strr ) ) NEW_LINE
def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT A = [ 1 , 2 , 3 ] ; NEW_LINE B = [ 4 , 5 , 6 ] ; NEW_LINE n = 3 ; NEW_LINE m = len ( A ) ; NEW_LINE print ( sumNth ( A , B , m , n ) ) ; NEW_LINE
def odd_even ( n ) : NEW_LINE INDENT odd_indexes = [ ] NEW_LINE even_indexes = [ ] NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if i % 2 == 0 : odd_indexes . append ( n [ i ] ) NEW_LINE else : even_indexes . append ( n [ i ] ) NEW_LINE DEDENT for i in sorted ( odd_indexes ) : print ( i , end = " ▁ " ) NEW_LINE for i in sorted ( even_indexes ) : print ( i , end = " ▁ " ) NEW_LINE DEDENT n = [ 3 , 2 , 7 , 6 , 8 ] NEW_LINE odd_even ( n ) NEW_LINE
def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = " ▁ " ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE
def fillPrefixSum ( arr , n , prefixSum ) : NEW_LINE INDENT prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 10 , 4 , 16 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE prefixSum = [ 0 for i in range ( n + 1 ) ] NEW_LINE fillPrefixSum ( arr , n , prefixSum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( prefixSum [ i ] , end = " ▁ " ) NEW_LINE DEDENT
from math import sqrt , atan2 , cos , sin NEW_LINE while ( 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT x1 , y1 , x2 , y2 , xq , yq = [ float ( i ) for i in input ( ) . split ( " , " ) ] NEW_LINE r = sqrt ( ( xq - x1 ) ** 2 + ( yq - y1 ) ** 2 ) NEW_LINE th1 = atan2 ( y2 - y1 , x2 - x1 ) NEW_LINE th2 = atan2 ( yq - y1 , xq - x1 ) NEW_LINE th3 = - ( th2 - th1 ) + th1 NEW_LINE print ( " { : . 6f } ▁ { : . 6f } " . format ( x1 + r * cos ( th3 ) , y1 + r * sin ( th3 ) ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE bit = [ int ( j ) for j in input ( ) . split ( ) ] NEW_LINE low = n * ( n - 1 ) - 2 * k * n NEW_LINE maxvalue = low NEW_LINE for ni in range ( 2 , n + 1 ) : NEW_LINE INDENT a = max ( int ( low // ni ) + 1 , 1 ) NEW_LINE if a < ni : NEW_LINE INDENT for nj in range ( a , ni ) : NEW_LINE INDENT maxvalue = max ( maxvalue , ni * nj - k * ( bit [ nj - 1 ] | bit [ ni - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( maxvalue ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def commonCharacters ( strings , n ) : NEW_LINE INDENT prim = [ True ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False ] * MAX_CHAR NEW_LINE for j in range ( len ( strings [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT prim [ i ] = sec [ i ] NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( " % c ▁ " % ( i + ord ( ' a ' ) ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT strings = [ " geeksforgeeks " , " gemkstones " , " acknowledges " , " aguelikes " ] NEW_LINE n = len ( strings ) NEW_LINE commonCharacters ( strings , n ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 ] NEW_LINE out = sObj . findDisappearedNumbers ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
import sys NEW_LINE def findMaxValue ( ) : NEW_LINE INDENT res = 2 ; NEW_LINE fact = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 or fact > sys . maxsize ) : NEW_LINE INDENT break ; NEW_LINE DEDENT res += 1 ; NEW_LINE fact = fact * res ; NEW_LINE DEDENT return res - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Maximum ▁ value ▁ of ▁ integer : " , findMaxValue ( ) ) ; NEW_LINE DEDENT
def swap ( dice , i , j , k , l ) : NEW_LINE INDENT x = dice [ l ] NEW_LINE dice [ l ] = dice [ k ] NEW_LINE dice [ k ] = dice [ j ] NEW_LINE dice [ j ] = dice [ i ] NEW_LINE dice [ i ] = x NEW_LINE return dice NEW_LINE DEDENT def Sroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 1 , 5 , 4 ) NEW_LINE return dice NEW_LINE DEDENT def Eroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 2 , 5 , 3 ) NEW_LINE return dice NEW_LINE DEDENT def Wroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 3 , 5 , 2 ) NEW_LINE return dice NEW_LINE DEDENT def Nroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 4 , 5 , 1 ) NEW_LINE return dice NEW_LINE DEDENT dice1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dice2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE top = dice1 [ 0 ] NEW_LINE fro = dice1 [ 1 ] NEW_LINE for j in range ( 0 , 8 ) : NEW_LINE INDENT if ( fro == dice2 [ 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j == 3 ) : NEW_LINE INDENT dice2 = Eroll ( dice2 ) NEW_LINE DEDENT dice2 = Sroll ( dice2 ) NEW_LINE DEDENT while ( top != dice2 [ 0 ] ) : NEW_LINE INDENT dice2 = Eroll ( dice2 ) NEW_LINE DEDENT if ( dice1 [ 2 ] == dice2 [ 2 ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT t = set ( ) NEW_LINE for x in map ( int , s . split ( ) ) : t |= { ( x , - x ) [ x in t ] } NEW_LINE print ( len ( t ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def primesieve ( prime ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( 650 ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , 651 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sum_sqsum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE sqsum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT x = n % 10 ; NEW_LINE sum += x ; NEW_LINE sqsum += x * x ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return ( sum , sqsum ) ; NEW_LINE DEDENT def countnumber ( L , R ) : NEW_LINE INDENT prime = [ True ] * 651 ; NEW_LINE primesieve ( prime ) ; NEW_LINE cnt = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT digit = sum_sqsum ( i ) ; NEW_LINE if ( prime [ digit [ 0 ] ] and prime [ digit [ 1 ] ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 10 ; NEW_LINE R = 20 ; NEW_LINE print ( countnumber ( L , R ) ) ; NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT print ( list ( s ) , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT INDEX = 124 NEW_LINE stream = ( i for i in itertools . count ( 1 , 2 ) if not has_tribonacci_multiple ( i ) ) NEW_LINE ans = next ( itertools . islice ( stream , INDEX - 1 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_tribonacci_multiple ( i ) : NEW_LINE INDENT seen = set ( ) NEW_LINE a , b , c = 1 , 1 , 1 NEW_LINE while True : NEW_LINE INDENT key = ( a , b , c ) NEW_LINE if key in seen : NEW_LINE INDENT return False NEW_LINE DEDENT seen . add ( key ) NEW_LINE if a % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT a , b , c = b , c , ( a + b + c ) % i NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( " x ▁ = ▁ " + str ( i ) + " , ▁ y ▁ = ▁ " + str ( int ( ( n - ( i * a ) ) / b ) ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE n = 7 NEW_LINE solution ( a , b , n ) NEW_LINE
import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if max ( x , y ) <= 8 : NEW_LINE INDENT if pow ( x , y ) < pow ( y , x ) : NEW_LINE INDENT ans = " < " NEW_LINE DEDENT elif pow ( x , y ) > pow ( y , x ) : NEW_LINE INDENT ans = " > " NEW_LINE DEDENT else : NEW_LINE INDENT ans = " = " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x < y : NEW_LINE INDENT ans = " > " if x ^ 1 else " < " NEW_LINE DEDENT elif x > y : NEW_LINE INDENT ans = " < " if y ^ 1 else " > " NEW_LINE DEDENT else : NEW_LINE INDENT ans = " = " NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 0 : print ( 0 ) NEW_LINE else : NEW_LINE INDENT s = input ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i - 1 ] == ' x ' and s [ i ] == ' x ' : break NEW_LINE ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE G = [ list ( map ( lambda x : x == ' # ' , input ( ) . strip ( ) ) ) for _ in range ( H ) ] NEW_LINE Takahashi = [ [ False ] * W for _ in range ( H ) ] NEW_LINE Aoki = [ [ False ] * W for _ in range ( H ) ] NEW_LINE for h in range ( H ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT if w == 0 : NEW_LINE INDENT Takahashi [ h ] [ w ] = True NEW_LINE DEDENT elif not h & 1 : NEW_LINE INDENT Aoki [ h ] [ w ] = True NEW_LINE DEDENT if w == W - 1 : NEW_LINE INDENT Aoki [ h ] [ w ] = True NEW_LINE DEDENT elif h & 1 : NEW_LINE INDENT Takahashi [ h ] [ w ] = True NEW_LINE DEDENT if G [ h ] [ w ] : NEW_LINE INDENT Takahashi [ h ] [ w ] = True NEW_LINE Aoki [ h ] [ w ] = True NEW_LINE DEDENT DEDENT DEDENT print ( ' \n ' . join ( [ ' ' . join ( [ ' # ' if s else ' . ' for s in Takahashi [ i ] ] ) for i in range ( H ) ] ) ) NEW_LINE print ( ' ' ) NEW_LINE print ( ' \n ' . join ( [ ' ' . join ( [ ' # ' if s else ' . ' for s in Aoki [ i ] ] ) for i in range ( H ) ] ) ) NEW_LINE
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for x in range ( 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT if ( n - x ) % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if k >= 2 * n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif k > n : NEW_LINE INDENT print ( ( 2 * n - k + 1 ) // 2 ) NEW_LINE DEDENT elif k == n : NEW_LINE INDENT print ( ( n - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k - 1 ) // 2 ) NEW_LINE DEDENT
import math NEW_LINE def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 25 NEW_LINE checkCollision ( a , b , c , x , y , radius ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE def f ( m ) : NEW_LINE INDENT global n NEW_LINE global k NEW_LINE total = m * k - ( m * ( m - 1 ) ) // 2 NEW_LINE total -= ( m - 1 ) NEW_LINE return total >= n NEW_LINE DEDENT if ( ( k * ( k + 1 ) ) // 2 - ( k - 1 ) < n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT r = k NEW_LINE l = 0 NEW_LINE while ( r > ( l + 1 ) ) : NEW_LINE INDENT m = ( r + l ) // 2 NEW_LINE if ( f ( m ) == 0 ) : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE DEDENT
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = [ 0 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = ' ' NEW_LINE INF = 10 ** 4 NEW_LINE dp = [ [ 0 , 0 ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if dp [ i ] [ 1 ] + l [ a [ j ] ] != i + l [ a [ j ] ] or i + l [ a [ j ] ] > n : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + l [ a [ j ] ] ] [ 0 ] = max ( dp [ i ] [ 0 ] + 1 , dp [ i + l [ a [ j ] ] ] [ 0 ] ) NEW_LINE dp [ i + l [ a [ j ] ] ] [ 1 ] = dp [ i ] [ 1 ] + l [ a [ j ] ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : dp [ i ] [ 0 ] = - INF if dp [ i ] [ 0 ] == 0 else dp [ i ] [ 0 ] NEW_LINE a . sort ( reverse = True ) NEW_LINE i = n NEW_LINE while i > 0 : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if i >= l [ a [ j ] ] and dp [ i - l [ a [ j ] ] ] [ 0 ] + 1 == dp [ i ] [ 0 ] : NEW_LINE INDENT res += str ( a [ j ] ) NEW_LINE i -= l [ a [ j ] ] NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT
num = 1 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT x0 , y0 = map ( float , input ( ) . split ( ) ) NEW_LINE prx , pry = x0 , y0 NEW_LINE area = 0 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT x , y = map ( float , input ( ) . split ( ) ) NEW_LINE area += ( prx * y - x * pry ) NEW_LINE prx , pry = x , y NEW_LINE DEDENT area += ( prx * y0 - x0 * pry ) NEW_LINE area /= 2 NEW_LINE print ( num , abs ( area ) ) NEW_LINE num += 1 NEW_LINE input ( ) NEW_LINE DEDENT
a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = b [ 0 ] NEW_LINE for j in b : NEW_LINE INDENT if j > c : NEW_LINE INDENT c = j NEW_LINE DEDENT DEDENT m = 0 NEW_LINE for k in b : NEW_LINE INDENT m += ( c - k ) NEW_LINE DEDENT print ( m ) NEW_LINE
for j in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE k = 0 NEW_LINE k = ( 23 - a ) * 60 + ( 60 - b ) NEW_LINE print ( k ) NEW_LINE DEDENT
def bar ( a , b , c ) : NEW_LINE INDENT x = ( a + b + c ) / 3 NEW_LINE return x NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT m , e , j = map ( int , input ( ) . split ( ) ) NEW_LINE y = ( m + e ) / 2 NEW_LINE x = bar ( m , e , j ) NEW_LINE if ( m == 100 or e == 100 or j == 100 ) or y >= 90 or x >= 80 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif x >= 70 : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif x >= 50 : NEW_LINE INDENT if m >= 80 or e >= 80 : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT DEDENT DEDENT
n_computers , k_participants = map ( int , input ( ) . split ( ) ) NEW_LINE kps = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( sorted ( kps , reverse = True ) [ : k_participants ] ) ) NEW_LINE
from collections import defaultdict NEW_LINE def balance_is_realizable ( imbalance , x , balance ) : NEW_LINE INDENT if imbalance >= 0 : NEW_LINE INDENT return ( x - balance ) >= 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( x - balance ) <= 0 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x = tuple ( int ( o ) for o in input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE balances_to_occurrences = defaultdict ( int ) NEW_LINE imbalance = 0 NEW_LINE s = 0 NEW_LINE for char in string : NEW_LINE INDENT if char == '0' : NEW_LINE INDENT imbalance += 1 NEW_LINE DEDENT else : NEW_LINE INDENT imbalance -= 1 NEW_LINE DEDENT balances_to_occurrences [ imbalance ] += 1 NEW_LINE DEDENT if imbalance == 0 : NEW_LINE INDENT if ( x in balances_to_occurrences or x == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for balance , occurrences in balances_to_occurrences . items ( ) : NEW_LINE INDENT if ( x - balance ) % imbalance == 0 and balance_is_realizable ( imbalance , x , balance ) : NEW_LINE INDENT s += occurrences NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , len ( arr ) - 1 , key ) NEW_LINE if i != - 1 : NEW_LINE INDENT print ( " Index : ▁ % d " % i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Key ▁ not ▁ found " ) NEW_LINE DEDENT
def fillWithFreq ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fillWithFreq ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def convert_To_Len_th_base ( n , arr , Len , L ) : NEW_LINE INDENT for i in range ( L ) : NEW_LINE INDENT print ( arr [ n % Len ] , end = " " ) NEW_LINE n //= Len NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printf ( arr , Len , L ) : NEW_LINE INDENT for i in range ( pow ( Len , L ) ) : NEW_LINE INDENT convert_To_Len_th_base ( i , arr , Len , L ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE Len = len ( arr ) NEW_LINE L = 2 NEW_LINE printf ( arr , Len , L ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = dict ( ) NEW_LINE maxi = 0 NEW_LINE maxv = 0 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - 1 in d : NEW_LINE INDENT d [ a - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a - 1 ] = 1 NEW_LINE DEDENT if b - 1 in d : NEW_LINE INDENT d [ b - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ b - 1 ] = 1 NEW_LINE DEDENT if d [ a - 1 ] > maxv : NEW_LINE INDENT maxv = d [ a - 1 ] NEW_LINE maxi = a - 1 NEW_LINE DEDENT if d [ b - 1 ] > maxv : NEW_LINE INDENT maxv = d [ b - 1 ] NEW_LINE maxi = b - 1 NEW_LINE DEDENT DEDENT if m + 1 == n : NEW_LINE INDENT if maxv == m : NEW_LINE INDENT print ( ' star ▁ topology ' ) NEW_LINE DEDENT elif maxv == 2 : NEW_LINE INDENT print ( ' bus ▁ topology ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' unknown ▁ topology ' ) NEW_LINE DEDENT DEDENT elif m == n : NEW_LINE INDENT if maxv == 2 : NEW_LINE INDENT print ( ' ring ▁ topology ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' unknown ▁ topology ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' unknown ▁ topology ' ) NEW_LINE DEDENT
import math NEW_LINE def max_gcd ( n , p ) : NEW_LINE INDENT count = 0 ; NEW_LINE gcd = 1 ; NEW_LINE while ( p % 2 == 0 ) : NEW_LINE INDENT p >>= 1 ; NEW_LINE count = count + 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( 2 , count // n ) ; NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( p ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( p % i == 0 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE p = p // i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( i , count // n ) ; NEW_LINE DEDENT DEDENT if ( p > 2 ) : NEW_LINE INDENT gcd = gcd * pow ( p , 1 // n ) ; NEW_LINE DEDENT return gcd ; NEW_LINE DEDENT n = 3 ; NEW_LINE p = 80 ; NEW_LINE print ( max_gcd ( n , p ) ) ; NEW_LINE
from math import ceil , floor NEW_LINE def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEW_LINE breadth = int ( floor ( perimeter / 4 ) ) NEW_LINE return length * breadth NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 38 NEW_LINE print ( " Maximum ▁ Area ▁ = " , maxArea ( n ) ) NEW_LINE DEDENT
def solution ( n , arr ) : NEW_LINE INDENT ans = 0 NEW_LINE num_of_ones = 0 NEW_LINE num_of_twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT num_of_ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_of_twos += 1 NEW_LINE DEDENT DEDENT min_val = min ( num_of_ones , num_of_twos ) NEW_LINE diff = num_of_ones - min_val NEW_LINE if diff >= 3 : NEW_LINE INDENT ans = diff // 3 NEW_LINE DEDENT return min_val + ans NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE arr = [ int ( x ) for x in input ( ) . strip ( ) . split ( " ▁ " ) ] NEW_LINE print ( solution ( n , arr ) ) NEW_LINE
import bisect NEW_LINE ans = 0 NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE B = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE C = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE C . sort ( ) NEW_LINE for b in B : NEW_LINE INDENT a = bisect . bisect_left ( A , b ) NEW_LINE c = N - bisect . bisect_right ( C , b ) NEW_LINE ans += a * c NEW_LINE DEDENT print ( ans ) NEW_LINE
def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE
def solve ( arr , n ) : NEW_LINE INDENT k = len ( arr ) NEW_LINE mp = [ False for i in range ( n + 2 ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT mp [ arr [ i ] ] = True NEW_LINE DEDENT leftSegment = arr [ 0 ] - 1 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT leftSegment = max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) NEW_LINE DEDENT rightSegment = n - arr [ k - 1 ] NEW_LINE maxSegment = max ( leftSegment , rightSegment ) ; NEW_LINE tim = 0 NEW_LINE if ( maxSegment & 1 ) : NEW_LINE INDENT tim = ( maxSegment // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT tim = maxSegment // 2 NEW_LINE DEDENT return tim NEW_LINE DEDENT N = 5 NEW_LINE arr = [ 1 , 4 ] NEW_LINE print ( solve ( arr , N ) ) NEW_LINE
def findCombinationsUtil ( arr , index , n , red_num ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE if ( red_num < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( red_num == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for itr in s : NEW_LINE INDENT sum = sum + ( itr ) NEW_LINE DEDENT if ( sum == n ) : NEW_LINE INDENT for i in s : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT if ( index == 0 ) : NEW_LINE INDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev = arr [ index - 1 ] NEW_LINE DEDENT for k in range ( prev , n + 1 , 1 ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , n , red_num - k ) NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( n + 1 ) ] NEW_LINE findCombinationsUtil ( a , 0 , n , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE findCombinations ( n ) NEW_LINE DEDENT
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 3 , 1 , 2 ] NEW_LINE M , K = 3 , 4 NEW_LINE N = len ( A ) NEW_LINE print ( KthMinValAfterMconcatenate ( A , N , M , K ) ) NEW_LINE DEDENT
from math import log2 NEW_LINE n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE queue = [ [ n , 0 ] ] NEW_LINE maxn = 10e4 NEW_LINE red = lambda x : x * 2 NEW_LINE blue = lambda x : x - 1 NEW_LINE memoized_values = set ( ) NEW_LINE while queue : NEW_LINE INDENT current_n , buttons_pressed = queue . pop ( 0 ) NEW_LINE if current_n == m : NEW_LINE INDENT print ( buttons_pressed ) NEW_LINE break NEW_LINE DEDENT if blue ( current_n ) not in memoized_values and blue ( current_n ) > 0 : NEW_LINE INDENT memoized_values . add ( blue ( current_n ) ) NEW_LINE queue . append ( [ blue ( current_n ) , buttons_pressed + 1 ] ) NEW_LINE DEDENT if red ( current_n ) not in memoized_values and red ( current_n ) <= maxn : NEW_LINE INDENT memoized_values . add ( red ( current_n ) ) NEW_LINE queue . append ( [ red ( current_n ) , buttons_pressed + 1 ] ) NEW_LINE DEDENT DEDENT
from math import * NEW_LINE def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n ) : NEW_LINE INDENT c += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT return int ( pow ( 2 , c ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE DEDENT
n , x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE somatorioA = sum ( a ) NEW_LINE if x == ( somatorioA + n - 1 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , 21 ) : NEW_LINE INDENT ans *= i // fractions . gcd ( i , ans ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT costPrice , sellingPrice = 1500 , 2000 NEW_LINE if sellingPrice == costPrice : NEW_LINE INDENT print ( " No ▁ profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT elif sellingPrice > costPrice : NEW_LINE INDENT print ( Profit ( costPrice , sellingPrice ) , " Profit ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Loss ( costPrice , sellingPrice ) , " Loss ▁ " ) NEW_LINE DEDENT DEDENT
n , a , b = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE if ( b > 0 ) : NEW_LINE INDENT if ( b % n == 0 ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a + b % n > n ) : NEW_LINE INDENT print ( a + b % n - n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b % n ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( b % n == 0 ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a + b % n > n ) : NEW_LINE INDENT print ( a + b % n - n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b % n ) NEW_LINE DEDENT DEDENT DEDENT
s = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while ( s != 1 and s != 2 and s != 4 ) : NEW_LINE INDENT if s % 2 == 0 : NEW_LINE INDENT s = s / 2 NEW_LINE DEDENT else : NEW_LINE INDENT s = 3 * s + 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( i + 3 ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in a : NEW_LINE INDENT if i < m // n : NEW_LINE INDENT ans += i NEW_LINE DEDENT else : NEW_LINE INDENT ans += m // n NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
pr = [ ] NEW_LINE prime = [ 1 for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 6 NEW_LINE sieve ( N ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = i NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( n + ans + ( k - 1 ) * 2 ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N < 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( N & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = 5 NEW_LINE s = sqrt ( N ) NEW_LINE while ( curr <= s ) : NEW_LINE INDENT if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 2 NEW_LINE if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 4 NEW_LINE DEDENT return True NEW_LINE DEDENT def check ( s , p , prefix_sum , n ) : NEW_LINE INDENT satisfies = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + s - 1 >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT x = prefix_sum [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT if ( prefix_sum [ i + s - 1 ] - x < p ) : NEW_LINE INDENT satisfies = False NEW_LINE DEDENT DEDENT return satisfies NEW_LINE DEDENT def minimumWindowSize ( x , y , p ) : NEW_LINE INDENT prefix_sum = [ 0 ] * ( y - x + 1 ) NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT prefix_sum [ i - x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , y - x + 1 ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT low = 1 NEW_LINE high = y - x + 1 NEW_LINE while ( high - low > 1 ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( check ( mid , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT if ( check ( low , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT return low NEW_LINE DEDENT return high NEW_LINE DEDENT x = 12 NEW_LINE y = 42 NEW_LINE p = 3 NEW_LINE print ( minimumWindowSize ( x , y , p ) ) NEW_LINE
from math import sqrt NEW_LINE def checkPerfectSquare ( n ) : NEW_LINE INDENT d = sqrt ( n ) NEW_LINE if d * d == n : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectSquare ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def compress ( self , chars ) : NEW_LINE INDENT anchor = write = 0 NEW_LINE for read , c in enumerate ( chars ) : NEW_LINE INDENT if read + 1 == len ( chars ) or chars [ read + 1 ] != c : NEW_LINE INDENT chars [ write ] = chars [ anchor ] NEW_LINE write += 1 NEW_LINE if read > anchor : NEW_LINE INDENT for digit in str ( read - anchor + 1 ) : NEW_LINE INDENT chars [ write ] = digit NEW_LINE write += 1 NEW_LINE DEDENT DEDENT anchor = read + 1 NEW_LINE DEDENT DEDENT return write NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE chars = [ ' a ' , ' a ' , ' b ' , ' b ' , ' c ' , ' c ' , ' c ' ] NEW_LINE out = sObj . compress ( chars ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return ; NEW_LINE DEDENT l = l + 1 ; NEW_LINE r = r - 1 ; NEW_LINE DEDENT print ( " Yes " ) NEW_LINE return ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) ; NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def countSubstringsUtil ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE mp = dict . fromkeys ( s , 0 ) ; NEW_LINE n = len ( s ) ; NEW_LINE start = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ s [ i ] ] += 1 ; NEW_LINE while ( mp [ ' a ' ] > 0 and mp [ ' e ' ] > 0 and mp [ ' i ' ] > 0 and mp [ ' o ' ] > 0 and mp [ ' u ' ] > 0 ) : NEW_LINE INDENT count += n - i ; NEW_LINE mp [ s [ start ] ] -= 1 ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countSubstrings ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE temp = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT temp += s [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT temp = " " ; NEW_LINE DEDENT DEDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aeouisddaaeeiouua " ; NEW_LINE print ( countSubstrings ( s ) ) ; NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ - 1 ] + [ ord ( c ) - ord ( '0' ) for c in input ( ) ] + [ - 1 ] NEW_LINE for _ in range ( k ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ - 1 ] + a [ L : R + 1 ] + [ - 1 ] NEW_LINE ans , dp , p = [ 0 ] * 10 , 1 , 1 NEW_LINE c = b [ p ] NEW_LINE while c != - 1 : NEW_LINE INDENT if c == 12 : NEW_LINE INDENT p -= 1 NEW_LINE dp = - 1 NEW_LINE if b [ p ] == 12 or b [ p ] == 14 : b . pop ( p + 1 ) NEW_LINE DEDENT elif c == 14 : NEW_LINE INDENT dp = 1 NEW_LINE if b [ p + 1 ] == 12 or b [ p + 1 ] == 14 : NEW_LINE INDENT b . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT b . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT b [ p ] -= 1 NEW_LINE DEDENT p += dp NEW_LINE if c == 0 and dp == 1 : p -= 1 NEW_LINE ans [ c ] += 1 NEW_LINE DEDENT c = b [ p ] NEW_LINE DEDENT print ( * ans ) NEW_LINE DEDENT
def setAllBitsAfterMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return n NEW_LINE DEDENT def toggle ( n ) : NEW_LINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEW_LINE return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE
class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def inv_interpolate ( d : list , n : int , y : float ) -> float : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xi = d [ i ] . x NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT xi = ( xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ) NEW_LINE DEDENT DEDENT x += xi NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = [ Data ( 1.27 , 2.3 ) , Data ( 2.25 , 2.95 ) , Data ( 2.5 , 3.5 ) , Data ( 3.6 , 5.1 ) ] NEW_LINE n = 4 NEW_LINE y = 4.5 NEW_LINE print ( " Value ▁ of ▁ x ▁ at ▁ y ▁ = ▁ 4.5 ▁ : " , round ( inv_interpolate ( d , n , y ) , 5 ) ) NEW_LINE DEDENT
def findElement ( arr , n ) : NEW_LINE INDENT prefixMul = [ ] NEW_LINE prefixMul . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixMul . append ( prefixMul [ i - 1 ] * arr [ i ] ) NEW_LINE DEDENT suffixMul = [ None for i in range ( 0 , n ) ] NEW_LINE suffixMul [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if prefixMul [ i ] == suffixMul [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findElement ( arr , n ) ) NEW_LINE
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE n = 5 NEW_LINE print ( numberOfDays ( a , b , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE p = input ( ) NEW_LINE i = 1 NEW_LINE while ( i < m and ( p [ i - 1 ] > p [ i ] or ( i > 1 and p [ i ] == p [ i - 1 ] ) ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( p [ : i ] + p [ i - 1 : : - 1 ] ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def solve ( health , n ) : NEW_LINE INDENT currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT currentgcd = gcd ( currentgcd , health [ i ] ) NEW_LINE DEDENT return currentgcd NEW_LINE DEDENT health = [ 4 , 6 , 8 , 12 ] NEW_LINE n = len ( health ) NEW_LINE print ( solve ( health , n ) ) NEW_LINE
def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( int ( squarearea ( r ) ) ) NEW_LINE DEDENT
class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFSUtil ( self , s , visited ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT s = stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = " ▁ " ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( self . adj [ s ] ) : NEW_LINE INDENT if ( not visited [ self . adj [ s ] [ i ] ] ) : NEW_LINE INDENT stack . append ( self . adj [ s ] [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT def DFS ( self ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE for i in range ( self . V ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT self . DFSUtil ( i , visited ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( 5 ) NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 2 , 1 ) NEW_LINE g . addEdge ( 3 , 4 ) NEW_LINE g . addEdge ( 4 , 0 ) NEW_LINE print ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal " ) NEW_LINE g . DFS ( ) NEW_LINE DEDENT
class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( self . V ) ] NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = ' ▁ ' ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for node in self . adj [ s ] : NEW_LINE INDENT if ( not visited [ node ] ) : NEW_LINE INDENT stack . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( 5 ) ; NEW_LINE g . addEdge ( 1 , 0 ) ; NEW_LINE g . addEdge ( 0 , 2 ) ; NEW_LINE g . addEdge ( 2 , 1 ) ; NEW_LINE g . addEdge ( 0 , 3 ) ; NEW_LINE g . addEdge ( 1 , 4 ) ; NEW_LINE print ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal " ) NEW_LINE g . DFS ( 0 ) NEW_LINE
def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) == 2 and s [ 0 ] == s [ 1 ] : NEW_LINE INDENT print ( 1 , 2 ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] or s [ i + 1 ] == s [ i + 2 ] or s [ i ] == s [ i + 2 ] : NEW_LINE INDENT print ( i + 1 , i + 3 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 , - 1 ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = " ▁ " ) , NEW_LINE print ( f [ 2 ] , end = " ▁ " ) , NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEW_LINE print ( f [ i ] , end = " ▁ " ) , NEW_LINE DEDENT DEDENT n = 13 NEW_LINE sequence ( n ) NEW_LINE
n , p , q , r = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE prefixMax = list ( ) NEW_LINE pM = l [ 0 ] * p NEW_LINE for i in l : NEW_LINE INDENT if ( i * p > pM ) : NEW_LINE INDENT pM = i * p NEW_LINE DEDENT prefixMax . append ( pM ) NEW_LINE DEDENT suffixMax = list ( ) NEW_LINE sM = l [ n - 1 ] * r NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( l [ j ] * r > sM ) : NEW_LINE INDENT sM = l [ j ] * r NEW_LINE DEDENT suffixMax . append ( sM ) NEW_LINE DEDENT suffixMax = suffixMax [ : : - 1 ] NEW_LINE mM = l [ 0 ] * q NEW_LINE maxValue = - 2 ** 64 + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = prefixMax [ i ] + l [ i ] * q + suffixMax [ i ] NEW_LINE if ( sum > maxValue ) : NEW_LINE INDENT maxValue = sum NEW_LINE DEDENT DEDENT print ( maxValue ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 22 ) if len ( str ( i ** j ) ) == j ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE print ( math . sqrt ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = int ( math . log10 ( nthElement ) ) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( findNth ( 5 ) ) NEW_LINE DEDENT
def per ( a , b ) : NEW_LINE INDENT return ( float ( a + b ) ) NEW_LINE DEDENT def area ( s ) : NEW_LINE INDENT return ( float ( s / 2 ) ) NEW_LINE DEDENT a = 7 NEW_LINE b = 8 NEW_LINE s = 10 NEW_LINE print ( per ( a , b ) ) NEW_LINE print ( area ( s ) ) NEW_LINE
def isBinary ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT temp = n % 10 NEW_LINE if temp != 0 and temp != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isBinary ( a [ i ] ) == True : NEW_LINE INDENT s += str ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT cout << " - 1 \n " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE DEDENT
def calculateAND ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if p * p >= max_val : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] != 1 ) : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return ( S1 & S2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateAND ( arr , n ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT books = [ ] NEW_LINE read_t = 0 NEW_LINE write_t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r , w = map ( int , input ( ) . split ( ) ) NEW_LINE read_t += r NEW_LINE write_t += w NEW_LINE books . append ( ( r , w ) ) NEW_LINE DEDENT books = sorted ( books ) NEW_LINE if books [ - 1 ] [ 0 ] <= read_t // 2 : NEW_LINE INDENT print ( read_t + write_t ) NEW_LINE continue NEW_LINE DEDENT sukima = books [ - 1 ] [ 0 ] - ( read_t - books [ - 1 ] [ 0 ] ) NEW_LINE dp = [ [ 0 for i in range ( sukima + 1 ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , sukima + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - books [ i - 1 ] [ 1 ] ] + books [ i - 1 ] [ 1 ] if j - books [ i - 1 ] [ 1 ] >= 0 else 0 ) NEW_LINE DEDENT DEDENT print ( read_t + write_t + sukima - dp [ - 1 ] [ - 1 ] ) NEW_LINE DEDENT
def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ 0 ] * ( l + 1 ) NEW_LINE close = [ 0 ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " NEW_LINE print ( findIndex ( str ) ) NEW_LINE
def sumOfDigit ( K ) : NEW_LINE INDENT sod = 0 NEW_LINE while ( K ) : NEW_LINE INDENT sod = sod + K % 10 NEW_LINE K = K // 10 NEW_LINE DEDENT return sod NEW_LINE DEDENT def totalNumbersWithSpecificDifference ( N , diff ) : NEW_LINE INDENT low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid - sumOfDigit ( mid ) < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ( N - high ) NEW_LINE DEDENT N = 13 NEW_LINE diff = 2 NEW_LINE print ( totalNumbersWithSpecificDifference ( N , diff ) ) NEW_LINE
def numOfsubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = arr [ i ] NEW_LINE sum = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT product *= arr [ j ] NEW_LINE sum += arr [ j ] NEW_LINE DEDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfsubarrays ( arr , n ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 5 + 10 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def resolve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE import math NEW_LINE def make_prime_list_2 ( num ) : NEW_LINE INDENT if num < 2 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT prime_list = [ i for i in range ( num + 1 ) ] NEW_LINE prime_list [ 1 ] = 0 NEW_LINE num_sqrt = math . sqrt ( num ) NEW_LINE for prime in prime_list : NEW_LINE INDENT if prime == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if prime > num_sqrt : NEW_LINE INDENT break NEW_LINE DEDENT for non_prime in range ( 2 * prime , num , prime ) : NEW_LINE INDENT prime_list [ non_prime ] = 0 NEW_LINE DEDENT DEDENT return [ prime for prime in prime_list if prime != 0 ] NEW_LINE DEDENT def prime_factorization_2 ( num ) : NEW_LINE INDENT if num <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT num_sqrt = math . floor ( math . sqrt ( num ) ) NEW_LINE prime_list = make_prime_list_2 ( num_sqrt ) NEW_LINE dict_counter = { } NEW_LINE for prime in prime_list : NEW_LINE INDENT while num % prime == 0 : NEW_LINE INDENT if prime in dict_counter : NEW_LINE INDENT dict_counter [ prime ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict_counter [ prime ] = 1 NEW_LINE DEDENT num //= prime NEW_LINE DEDENT DEDENT if num != 1 : NEW_LINE INDENT if num in dict_counter : NEW_LINE INDENT dict_counter [ num ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict_counter [ num ] = 1 NEW_LINE DEDENT DEDENT return dict_counter NEW_LINE DEDENT DEDENT d = prime_factorization_2 ( n ) NEW_LINE val = 1 NEW_LINE for v in d . values ( ) : NEW_LINE INDENT val *= ( v + 1 ) NEW_LINE DEDENT print ( len ( d ) , val - 1 ) NEW_LINE DEDENT resolve ( ) NEW_LINE
def line2int ( linea ) : NEW_LINE INDENT temp = " " NEW_LINE for i in linea : NEW_LINE INDENT if i == " ▁ " : NEW_LINE INDENT if temp != " " : NEW_LINE INDENT val1 = int ( temp ) NEW_LINE temp = " " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = temp + i NEW_LINE DEDENT DEDENT val2 = int ( temp ) NEW_LINE return ( val1 , val2 ) NEW_LINE DEDENT ( n , m ) = line2int ( input ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT minN = maxN = n NEW_LINE DEDENT else : NEW_LINE INDENT minN = n - m * 2 NEW_LINE if minN < 0 : minN = 0 NEW_LINE i = 1 NEW_LINE while m > 0 : NEW_LINE INDENT m = m - i NEW_LINE i = i + 1 NEW_LINE DEDENT maxN = n - i NEW_LINE DEDENT print ( minN , maxN ) NEW_LINE
def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a , b , c = 2 , 10 , 3 NEW_LINE print ( getMaxNum ( a , b , c ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE inches = round ( n / 3 ) NEW_LINE feet = inches // 12 NEW_LINE inches = inches % 12 NEW_LINE print ( feet , inches ) NEW_LINE
def HailstoneNumbers ( N , c ) : NEW_LINE INDENT print ( N , end = " ▁ " ) ; NEW_LINE if ( N == 1 and c == 0 ) : NEW_LINE INDENT return c ; NEW_LINE DEDENT elif ( N == 1 and c != 0 ) : NEW_LINE INDENT c = c + 1 ; NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT c = c + 1 ; NEW_LINE c = HailstoneNumbers ( int ( N / 2 ) , c ) ; NEW_LINE DEDENT elif ( N % 2 != 0 ) : NEW_LINE INDENT c = c + 1 ; NEW_LINE c = HailstoneNumbers ( 3 * N + 1 , c ) ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT N = 7 ; NEW_LINE x = HailstoneNumbers ( N , 0 ) ; NEW_LINE print ( " \n Number ▁ of ▁ Steps : ▁ " + str ( x ) ) ; NEW_LINE
class Solution : NEW_LINE INDENT def binaryGap ( self , n ) : NEW_LINE INDENT current = 1 NEW_LINE last1 = - 1 NEW_LINE out = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT if last1 >= 1 : NEW_LINE INDENT out = max ( out , current - last1 ) NEW_LINE DEDENT last1 = current NEW_LINE DEDENT current += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT return out NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 22 NEW_LINE out = sObj . binaryGap ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
x = int ( input ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE M , c = 60 * h + m , 0 NEW_LINE while '7' not in str ( M // 60 ) + str ( M % 60 ) : NEW_LINE INDENT c += 1 ; M -= x NEW_LINE if M < 0 : M += 1440 NEW_LINE DEDENT print ( c ) NEW_LINE
def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( maxTeams ( n , m ) ) NEW_LINE DEDENT
def binomialCoefficient ( n , k ) : NEW_LINE INDENT if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res / ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoefficient ( 2 * n , n ) NEW_LINE return int ( c / ( n + 1 ) ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res /= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEW_LINE return int ( c / ( n + 1 ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( catalan ( n ) ) ; NEW_LINE
NO_OF_CHARS = 256 NEW_LINE def toMutable ( string ) : NEW_LINE INDENT List = [ ] NEW_LINE for i in string : NEW_LINE INDENT List . append ( i ) NEW_LINE DEDENT return List NEW_LINE DEDENT def toString ( List ) : NEW_LINE INDENT return ' ' . join ( List ) NEW_LINE DEDENT def removeDups ( string ) : NEW_LINE INDENT bin_hash = [ 0 ] * NO_OF_CHARS NEW_LINE ip_ind = 0 NEW_LINE res_ind = 0 NEW_LINE temp = ' ' NEW_LINE mutableString = toMutable ( string ) NEW_LINE while ip_ind != len ( mutableString ) : NEW_LINE INDENT temp = mutableString [ ip_ind ] NEW_LINE if bin_hash [ ord ( temp ) ] == 0 : NEW_LINE INDENT bin_hash [ ord ( temp ) ] = 1 NEW_LINE mutableString [ res_ind ] = mutableString [ ip_ind ] NEW_LINE res_ind += 1 NEW_LINE DEDENT ip_ind += 1 NEW_LINE DEDENT return toString ( mutableString [ 0 : res_ind ] ) NEW_LINE DEDENT string = " geeksforgeeks " NEW_LINE print ( removeDups ( string ) , end = " " ) NEW_LINE
import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] // m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE
days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = "2019-01-09" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n + 1 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n - 2 ) ] + [ n , n - 2 , n - 1 ] NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT
cnt = 0 NEW_LINE graph = [ 0 ] * 100 NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT graph [ i ] = [ ] NEW_LINE DEDENT weight = [ "0" ] * 100 NEW_LINE def isPalindrome ( x ) : NEW_LINE INDENT n = len ( x ) NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE INDENT if x [ i ] != x [ n - 1 - i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT global cnt NEW_LINE x = weight [ node ] NEW_LINE if ( isPalindrome ( x ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT for to in graph [ node ] : NEW_LINE INDENT if to == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT weight [ 0 ] = " " NEW_LINE weight [ 1 ] = " abc " NEW_LINE weight [ 2 ] = " aba " NEW_LINE weight [ 3 ] = " bcb " NEW_LINE weight [ 4 ] = " moh " NEW_LINE weight [ 5 ] = " aa " NEW_LINE graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 2 ] . append ( 3 ) NEW_LINE graph [ 2 ] . append ( 4 ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE print ( cnt ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT F = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE fl = min ( F ) ; fr = max ( F ) NEW_LINE G = { i for i in range ( 1 , 14 ) } - F - { 7 } NEW_LINE gl = min ( G ) ; gr = max ( G ) NEW_LINE memo = { } NEW_LINE def dfs ( s , t , u ) : NEW_LINE INDENT if ( s , t , u ) in memo : NEW_LINE INDENT return memo [ s , t , u ] NEW_LINE DEDENT T = [ G , F ] [ u ] NEW_LINE res = 0 NEW_LINE if s - 1 in T : NEW_LINE INDENT if s - 1 <= [ gl , fl ] [ u ] and [ gr , fr ] [ u ] <= t : NEW_LINE INDENT res = 1 NEW_LINE DEDENT else : NEW_LINE INDENT res |= dfs ( s - 1 , t , u ^ 1 ) ^ 1 NEW_LINE DEDENT DEDENT if t + 1 in T : NEW_LINE INDENT if s <= [ gl , fl ] [ u ] and [ gr , fr ] [ u ] <= t + 1 : NEW_LINE INDENT res = 1 NEW_LINE DEDENT else : NEW_LINE INDENT res |= dfs ( s , t + 1 , u ^ 1 ) ^ 1 NEW_LINE DEDENT DEDENT if s - 1 not in T and t + 1 not in T : NEW_LINE INDENT res = dfs ( s , t , u ^ 1 ) ^ 1 NEW_LINE DEDENT memo [ s , t , u ] = res NEW_LINE return res NEW_LINE DEDENT print ( [ " no " , " yes " ] [ dfs ( 7 , 7 , 1 ) ] ) NEW_LINE DEDENT
from sys import stdin , stdout NEW_LINE import math NEW_LINE n = int ( stdin . readline ( ) . strip ( ) ) NEW_LINE reserved = 1 NEW_LINE maxspeed = 1 NEW_LINE while True : NEW_LINE INDENT if reserved + maxspeed * 3 > n : NEW_LINE INDENT break NEW_LINE DEDENT maxspeed *= 3 NEW_LINE reserved += maxspeed * 2 NEW_LINE DEDENT ans = 1 NEW_LINE n -= 1 NEW_LINE i = 3 NEW_LINE while i < maxspeed : NEW_LINE INDENT ans += 2 NEW_LINE n -= i * 2 NEW_LINE i *= 3 NEW_LINE DEDENT n -= maxspeed NEW_LINE i = maxspeed NEW_LINE while i : NEW_LINE INDENT ans += n // i NEW_LINE n -= n // i * i NEW_LINE i //= 3 NEW_LINE DEDENT stdout . writelines ( str ( ans + 1 ) + ' \n ' ) NEW_LINE
def predictFeature ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT if ' S ' in ( a , b ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return ' S ' NEW_LINE DEDENT if ' T ' in ( a , b ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return ' T ' NEW_LINE DEDENT return ' E ' NEW_LINE DEDENT DEDENT def hyperSet ( n , k , l ) : NEW_LINE INDENT d = { } NEW_LINE for x in l : NEW_LINE INDENT if x not in d : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT w = ' ' NEW_LINE for x in range ( k ) : NEW_LINE INDENT w += predictFeature ( l [ i ] [ x ] , l [ j ] [ x ] ) NEW_LINE DEDENT if w in d : NEW_LINE INDENT c = 0 NEW_LINE if w == l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if w == l [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT ans += d [ w ] - c NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans // 6 NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE DEDENT print ( hyperSet ( n , k , l ) ) NEW_LINE
lx , ly = [ 4 , 2 ] , [ 2 , 4 ] NEW_LINE dx = [ - 1 , 0 , 1 , 0 ] NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE while 1 : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 and h == 0 : break NEW_LINE xs , ys = map ( int , input ( ) . split ( ) ) NEW_LINE xg , yg = map ( int , input ( ) . split ( ) ) NEW_LINE f = [ [ 0 for i in range ( 102 ) ] for j in range ( 102 ) ] NEW_LINE s = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c , d , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE for p in range ( lx [ d ] ) : NEW_LINE INDENT for q in range ( ly [ d ] ) : NEW_LINE INDENT f [ y + q ] [ x + p ] = c NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE if f [ ys ] [ xs ] > 0 and f [ ys ] [ xs ] == f [ yg ] [ xg ] : NEW_LINE INDENT c = f [ ys ] [ xs ] NEW_LINE s . append ( [ xs , ys ] ) NEW_LINE while len ( s ) > 0 : NEW_LINE INDENT x , y = s . pop ( ) NEW_LINE if x == xg and y == yg : NEW_LINE INDENT ans = 1 ; break ; NEW_LINE DEDENT for k in range ( 4 ) : NEW_LINE INDENT if f [ y + dy [ k ] ] [ x + dx [ k ] ] == c : NEW_LINE INDENT s . append ( [ x + dx [ k ] , y + dy [ k ] ] ) NEW_LINE f [ y + dy [ k ] ] [ x + dx [ k ] ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " OK " if ans == 1 else " NG " ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return int ( ( a * b ) / gcd ( a , b ) ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return int ( ( a * b ) / gcd ( a , b ) ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT False NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n //= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n //= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE K = 1 NEW_LINE N = len ( arr ) NEW_LINE print ( min_sum ( N , K , arr ) ) NEW_LINE DEDENT
class ListNode : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . val = v NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = 2 NEW_LINE head = None ; NEW_LINE lastNode = None ; NEW_LINE for num in nums : NEW_LINE INDENT lnn = ListNode ( num ) ; NEW_LINE if ( head == None ) : NEW_LINE INDENT head = lnn NEW_LINE lastNode = lnn NEW_LINE DEDENT else : NEW_LINE INDENT lastNode . next = lnn NEW_LINE lastNode = lnn NEW_LINE DEDENT DEDENT out = sObj . removeNthFromEnd ( head , n ) ; NEW_LINE while ( out . next != None ) : NEW_LINE INDENT print ( str ( out . val ) + " ▁ - - > ▁ " , end = " " ) NEW_LINE out = out . next NEW_LINE DEDENT print ( str ( out . val ) + " ▁ - - > ▁ end " ) NEW_LINE DEDENT
def findMaxLenEven ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE currlen = 0 NEW_LINE maxlen = 0 NEW_LINE st = - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT currlen = 0 NEW_LINE DEDENT else : NEW_LINE INDENT currlen += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT if ( st == - 1 ) : NEW_LINE INDENT print ( " trie " ) NEW_LINE return " - 1" NEW_LINE DEDENT return str [ st : st + maxlen ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " this ▁ is ▁ a ▁ test ▁ string " NEW_LINE print ( findMaxLenEven ( str ) ) NEW_LINE DEDENT
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 7 , 9 , 10 ] NEW_LINE s = 16 NEW_LINE print ( pairsInSortedRotated ( arr , 6 , s ) ) NEW_LINE
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def getPassingCars ( A , n ) : NEW_LINE INDENT countOne = 0 ; result = 0 NEW_LINE while n >= 1 : NEW_LINE INDENT if A [ n - 1 ] == 1 : NEW_LINE INDENT countOne += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += countOne NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = next ( itertools . filterfalse ( test_goldbach , itertools . count ( 9 , 2 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def test_goldbach ( n ) : NEW_LINE INDENT if n % 2 == 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in itertools . count ( 1 ) : NEW_LINE INDENT k = n - 2 * i * i NEW_LINE if k <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif eulerlib . is_prime ( k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT x = min ( k - l [ i + 1 ] , 0 ) NEW_LINE m += ( l [ i ] + x ) NEW_LINE if m < 0 : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinRemoval ( arr , n ) ) NEW_LINE DEDENT
def find ( n ) : NEW_LINE INDENT arr = [ ' ' ] * ( n + 1 ) ; NEW_LINE size = 1 ; NEW_LINE m = 1 ; NEW_LINE while ( size <= n ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( i < m and ( size + i ) <= n ) : NEW_LINE INDENT arr [ size + i ] = "3" + arr [ size - m + i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( i < m and ( size + m + i ) <= n ) : NEW_LINE INDENT arr [ size + m + i ] = "4" + arr [ size - m + i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT m = m << 1 ; NEW_LINE size = size + m ; NEW_LINE DEDENT print ( arr [ n ] ) ; NEW_LINE DEDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT find ( i ) ; NEW_LINE DEDENT
def maxValue ( a , b ) : NEW_LINE INDENT b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT x = " " . join ( ai ) NEW_LINE return x NEW_LINE DEDENT a = "1234" NEW_LINE b = "4321" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE
import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] ; b = [ ] NEW_LINE res = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT i , j = _input ( ) NEW_LINE if i < 0 : a . append ( ( - i , j ) ) NEW_LINE elif i > 0 : b . append ( ( i , j ) ) NEW_LINE else : res += j NEW_LINE DEDENT a . sort ( ) ; b . sort ( ) NEW_LINE la = len ( a ) ; lb = len ( b ) NEW_LINE if la > lb + 1 : la = lb + 1 NEW_LINE elif lb > la + 1 : lb = la + 1 NEW_LINE for i in range ( la ) : res += a [ i ] [ 1 ] NEW_LINE for i in range ( lb ) : res += b [ i ] [ 1 ] NEW_LINE print ( res ) NEW_LINE
import math NEW_LINE def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = ( float ) ( math . pow ( product , ( 1 / n ) ) ) NEW_LINE return ( float ) ( gm ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' { 0 : . 6f } ' . format ( geometricMean ( arr , n ) ) ) NEW_LINE
def display ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = i NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( j , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countXorPair ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE def Square ( n , i , j ) : NEW_LINE INDENT mid = ( i + j ) / 2 ; NEW_LINE mul = mid * mid ; NEW_LINE if ( ( mul == n ) or ( abs ( mul - n ) < 0.00001 ) ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( mul < n ) : NEW_LINE INDENT return Square ( n , mid , j ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return Square ( n , i , mid ) ; NEW_LINE DEDENT DEDENT def findSqrt ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE found = False ; NEW_LINE while ( found == False ) : NEW_LINE INDENT if ( i * i == n ) : NEW_LINE INDENT print ( i ) ; NEW_LINE found = True ; NEW_LINE DEDENT elif ( i * i > n ) : NEW_LINE INDENT res = Square ( n , i - 1 , i ) ; NEW_LINE print ( " { 0 : . 5f } " . format ( res ) ) NEW_LINE found = True NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE findSqrt ( n ) ; NEW_LINE DEDENT
from itertools import permutations as pm NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE fact9 = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for hand in pm ( l2 , 9 ) : NEW_LINE INDENT score1 = 0 NEW_LINE score2 = 0 NEW_LINE for i , j in zip ( l1 , hand ) : NEW_LINE INDENT if i < j : NEW_LINE INDENT score2 += ( i + j ) NEW_LINE DEDENT else : NEW_LINE INDENT score1 += ( i + j ) NEW_LINE DEDENT DEDENT if score1 < score2 : NEW_LINE INDENT ans2 += 1 NEW_LINE DEDENT elif score1 > score2 : NEW_LINE INDENT ans1 += 1 NEW_LINE DEDENT DEDENT print ( ans1 / fact9 , ans2 / fact9 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r ; NEW_LINE combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; NEW_LINE DEDENT def combinationUtil ( arr , data , start , end , index , r ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT i = start ; NEW_LINE while ( i <= end and end - i + 1 >= r - index ) : NEW_LINE INDENT data [ index ] = arr [ i ] ; NEW_LINE combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE r = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE printCombination ( arr , n , r ) ; NEW_LINE
def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 ; NEW_LINE print ( bitwiseAndOdd ( n ) ) ; NEW_LINE DEDENT
def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if y == ( 2 * x - x * x ) : NEW_LINE INDENT if dif < 0 : NEW_LINE INDENT print ( " y ▁ = ▁ " + str ( dif ) + " x " + str ( ( x * dif ) + ( y ) ) ) NEW_LINE DEDENT elif dif > 0 : NEW_LINE INDENT print ( " y ▁ = ▁ " + str ( dif ) + " x + " + str ( - x * dif + y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A , x , y = 2 , 2 , 0 NEW_LINE findTangent ( A , x , y ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE while n : NEW_LINE INDENT s = int ( input ( ) ) NEW_LINE a = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = max ( a ) - min ( a ) NEW_LINE print ( c ) NEW_LINE n -= 1 NEW_LINE DEDENT
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = "43262488612" NEW_LINE print ( " Rotations : " , countRotationsDivBy8 ( n ) ) NEW_LINE DEDENT
def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT
from queue import Queue NEW_LINE def interLeaveQueue ( q ) : NEW_LINE INDENT if ( q . qsize ( ) % 2 != 0 ) : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE DEDENT s = [ ] NEW_LINE halfSize = int ( q . qsize ( ) / 2 ) NEW_LINE for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 11 ) NEW_LINE q . put ( 12 ) NEW_LINE q . put ( 13 ) NEW_LINE q . put ( 14 ) NEW_LINE q . put ( 15 ) NEW_LINE q . put ( 16 ) NEW_LINE q . put ( 17 ) NEW_LINE q . put ( 18 ) NEW_LINE q . put ( 19 ) NEW_LINE q . put ( 20 ) NEW_LINE interLeaveQueue ( q ) NEW_LINE length = q . qsize ( ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT print ( q . queue [ 0 ] , end = " ▁ " ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT
def solve ( ) : NEW_LINE INDENT n , s , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 0 , k + 1 ) : NEW_LINE INDENT if s - i >= 1 and not s - i in a : NEW_LINE INDENT print ( i ) ; NEW_LINE break NEW_LINE DEDENT if s + i <= n and not s + i in a : NEW_LINE INDENT print ( i ) ; NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert False NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
from fractions import gcd NEW_LINE def findRatio ( m , n ) : NEW_LINE INDENT Am = m - 5 NEW_LINE An = n - 5 NEW_LINE numerator = Am // ( gcd ( Am , An ) ) NEW_LINE denominator = An // ( gcd ( Am , An ) ) NEW_LINE print ( numerator , ' / ' , denominator ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 20 NEW_LINE findRatio ( m , n ) NEW_LINE DEDENT
import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 50000000 ) ) ; NEW_LINE print ( findDigits ( 1000000000 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE
def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while power <= n : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT n = 11 ; k = 2 NEW_LINE print ( find_sum ( n , k ) ) NEW_LINE
import math NEW_LINE def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 5 , 8 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ( int ) ( FirstDigit ( arr , n ) ) ) NEW_LINE
def findSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( findSum ( arr , n , k ) ) NEW_LINE DEDENT
numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE data = { ' dept ' : 0 } NEW_LINE def change_count ( index ) : NEW_LINE INDENT dif = data [ f ' { index } ' ] [ ' owes ' ] - data [ f ' { index } ' ] [ ' have ' ] NEW_LINE if dif <= 0 : NEW_LINE INDENT data [ ' dept ' ] -= data [ f ' { index } ' ] [ ' count ' ] NEW_LINE data [ f ' { index } ' ] [ ' count ' ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT data [ ' dept ' ] += dif - data [ f ' { index } ' ] [ ' count ' ] NEW_LINE data [ f ' { index } ' ] [ ' count ' ] = dif NEW_LINE DEDENT DEDENT for i in range ( 0 , numbers [ 1 ] ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for z in range ( 0 , 2 ) : NEW_LINE INDENT if not f " { x [ z ] } " in data . keys ( ) : NEW_LINE INDENT data [ f ' { x [ z ] } ' ] = { " owes " : 0 , " have " : 0 , " count " : 0 } NEW_LINE DEDENT DEDENT data [ f " { x [ 0 ] } " ] [ ' owes ' ] += x [ 2 ] NEW_LINE data [ f " { x [ 1 ] } " ] [ ' have ' ] += x [ 2 ] NEW_LINE change_count ( x [ 0 ] ) NEW_LINE change_count ( x [ 1 ] ) NEW_LINE DEDENT print ( data [ ' dept ' ] ) NEW_LINE
while True : NEW_LINE INDENT ( n , m ) = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT b . append ( int ( input ( ) ) ) NEW_LINE DEDENT a_sum = sum ( a ) NEW_LINE b_sum = sum ( b ) NEW_LINE target = a_sum - b_sum NEW_LINE found = False NEW_LINE for ai in a : NEW_LINE INDENT for bi in b : NEW_LINE INDENT if ( ai - bi ) * 2 == target : NEW_LINE INDENT print ( ai , bi ) NEW_LINE found = True NEW_LINE DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if found == False : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def fixedPoint ( self , A ) : NEW_LINE INDENT l , h = 0 , len ( A ) - 1 NEW_LINE while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if A [ mid ] < mid : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT elif A [ mid ] > mid : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE A = [ - 10 , - 5 , 0 , 3 , 7 ] NEW_LINE out = sObj . fixedPoint ( A ) ; NEW_LINE print ( out ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE edges = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT edges . append ( list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += min ( edges [ i ] [ j ] , edges [ j ] [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
CHARS = 26 NEW_LINE def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " bcadeh " NEW_LINE str2 = " hea " NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT
from math import sin NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( " { : . 3 f } " . format ( polyarea ( n , r ) ) ) NEW_LINE DEDENT
from xml . etree . ElementPath import prepare_parent NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = ' YES ' NEW_LINE m = { } NEW_LINE m2 = { } NEW_LINE for i in s : NEW_LINE INDENT if i not in m : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] += 1 NEW_LINE DEDENT DEDENT if len ( m ) == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE continue NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in m2 : NEW_LINE INDENT m2 [ s [ i ] ] = [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m2 [ s [ i ] ] . append ( i ) NEW_LINE DEDENT DEDENT for i in m2 : NEW_LINE INDENT for j in range ( len ( m2 [ i ] ) - 1 ) : NEW_LINE INDENT if abs ( m2 [ i ] [ j ] - m2 [ i ] [ j + 1 ] ) < len ( m ) : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT b = 3 NEW_LINE s = 4 NEW_LINE print ( surfaceArea ( b , s ) ) NEW_LINE DEDENT
def count ( s , Len ) : NEW_LINE INDENT global MAX NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE Sum = [ 0 ] * MAX NEW_LINE dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE Sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ Sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i - 2 >= 0 : NEW_LINE INDENT dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = dprev * 10 + dig NEW_LINE if ( value % 8 == 0 ) and ( value % 3 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if i - 3 >= 0 : NEW_LINE INDENT dprev2 = int ( s [ i - 3 ] ) - 48 NEW_LINE dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = ( dprev2 * 100 + dprev * 10 + dig ) NEW_LINE if value % 8 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans += ( i - 2 ) NEW_LINE ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT MAX = 1000 NEW_LINE Str = "6564525600" NEW_LINE Len = len ( Str ) NEW_LINE print ( count ( Str , Len ) ) NEW_LINE
def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= maxm ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = max ( a ) ; NEW_LINE prime = [ 0 ] * ( maxm + 1 ) ; NEW_LINE sieve ( maxm , prime ) ; NEW_LINE countPrimes = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 ; NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes ; NEW_LINE pairswith1Prime = nonPrimes * countPrimes ; NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) // 2 ; NEW_LINE return pairswith1Prime + pairsWith2Primes ; NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPair ( arr , n ) ) ; NEW_LINE
I = input NEW_LINE n = int ( I ( ) ) NEW_LINE s = I ( ) NEW_LINE print ( sum ( 2 > len ( set ( s [ i - 3 : i ] ) ) for i in range ( n , len ( s ) , n ) ) ) NEW_LINE
def sortString ( str ) : NEW_LINE INDENT str = ' ' . join ( sorted ( str ) ) NEW_LINE print ( str ) NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE sortString ( s ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT print ( n ) NEW_LINE c = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT l [ c ] , l [ c + 1 ] = l [ c + 1 ] , l [ c ] NEW_LINE c += 1 NEW_LINE DEDENT for each in l : NEW_LINE INDENT print ( each , end = ' ▁ ' ) NEW_LINE DEDENT i += 1 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def printNumber ( n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE while ( n ) : NEW_LINE INDENT count [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( count [ i ] * i ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3225 NEW_LINE printNumber ( n ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE arr [ i ] = 1 ; NEW_LINE DEDENT return max ( arr ) ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE print ( n ) NEW_LINE