import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . Arrays NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE pg = PrimeNumberGenerator ( ) NEW_LINE while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if pg . isPrime ( n ) : NEW_LINE INDENT print 0 NEW_LINE continue NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT if pg . isPrime ( i ) : NEW_LINE INDENT begin = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT while i < 2000000 : NEW_LINE INDENT if pg . isPrime ( i ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print end - begin NEW_LINE DEDENT DEDENT DEDENT class PrimeNumberGenerator ( object ) : NEW_LINE INDENT N = 2000000 NEW_LINE isPrime = [ None ] * N + 1 NEW_LINE def __init__ ( self ) : NEW_LINE INDENT Arrays . fill ( self . isPrime , True ) NEW_LINE self . isPrime [ 0 ] = False NEW_LINE self . isPrime [ 1 ] = False NEW_LINE limit = ( Math . sqrt ( self . N ) ) NEW_LINE i = 2 NEW_LINE while i <= limit : NEW_LINE INDENT if self . isPrime [ i ] == False : NEW_LINE INDENT continue NEW_LINE DEDENT while j <= N : NEW_LINE INDENT self . isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def isPrime ( self , index ) : NEW_LINE INDENT return self . isPrime [ index ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE @ classmethod NEW_LINE def countFreq ( cls , str_ , freq , len ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len : NEW_LINE INDENT freq [ str_ . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def canMakePalindrome ( cls , freq , len ) : NEW_LINE INDENT count_odd = 0 NEW_LINE i = 0 NEW_LINE while i < MAX_CHAR : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if len % 2 == 0 : NEW_LINE INDENT if count_odd > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if count_odd != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def findOddAndRemoveItsFreq ( cls , freq ) : NEW_LINE INDENT odd_str = " " NEW_LINE i = 0 NEW_LINE while i < MAX_CHAR : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_str = odd_str + ( ( i + ' a ' ) ) NEW_LINE return odd_str NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return odd_str NEW_LINE DEDENT @ classmethod NEW_LINE def findPalindromicString ( cls , str_ ) : NEW_LINE INDENT len = len ( str_ ) NEW_LINE freq = [ None ] * MAX_CHAR NEW_LINE cls . countFreq ( str_ , freq , len ) NEW_LINE if not cls . canMakePalindrome ( freq , len ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " NEW_LINE DEDENT odd_str = cls . findOddAndRemoveItsFreq ( freq ) NEW_LINE front_str = " " NEW_LINE rear_str = " ▁ " NEW_LINE i = 0 NEW_LINE while i < MAX_CHAR : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT while j <= freq [ i ] / 2 : NEW_LINE INDENT temp = temp + ch NEW_LINE j += 1 NEW_LINE DEDENT front_str = front_str + temp NEW_LINE rear_str = temp + rear_str NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( front_str + odd_str + rear_str ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " malayalam " NEW_LINE print cls . findPalindromicString ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def count9s ( cls , number ) : NEW_LINE INDENT n = number . length NEW_LINE d = [ None ] * 9 NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( number [ i ] - '0' ) == 0 : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ( number [ i ] - '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print cls . count9s ( "01809" . toCharArray ( ) ) NEW_LINE print cls . count9s ( "1809" . toCharArray ( ) ) NEW_LINE print cls . count9s ( "4189" . toCharArray ( ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE s = [ ] NEW_LINE while True : NEW_LINE __n_0 = n NEW_LINE n -= 1 NEW_LINE INDENT if n == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT while __n_0 > 0 : NEW_LINE INDENT while i < 7 : NEW_LINE INDENT print ( a [ i ] ^ s [ m ] [ i ] , + ( " \n " if i == 6 else " " ) ) NEW_LINE i += 1 NEW_LINE DEDENT a = s [ m ] . clone ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def mul_table ( cls , N , i ) : NEW_LINE INDENT if i > 10 : NEW_LINE INDENT return NEW_LINE DEDENT print N + " ▁ * ▁ " + i + " ▁ = ▁ " + N * i NEW_LINE cls . mul_table ( N , i + 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 8 NEW_LINE cls . mul_table ( N , 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class close_to_n_divisible_m ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def closestNumber ( cls , n , m ) : NEW_LINE INDENT q = n / m NEW_LINE n1 = m * q NEW_LINE n2 = ( m * ( q + 1 ) ) if ( n * m ) > 0 else ( m * ( q - 1 ) ) NEW_LINE if Math . abs ( n - n1 ) < Math . abs ( n - n2 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 13 NEW_LINE m = 4 NEW_LINE print cls . closestNumber ( n , m ) NEW_LINE n = - 15 NEW_LINE m = 6 NEW_LINE print cls . closestNumber ( n , m ) NEW_LINE n = 0 NEW_LINE m = 8 NEW_LINE print cls . closestNumber ( n , m ) NEW_LINE n = 18 NEW_LINE m = - 7 NEW_LINE print cls . closestNumber ( n , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE close_to_n_divisible_m . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def compute_lps ( cls , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ None ] * n NEW_LINE len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s . charAt ( i ) == s . charAt ( len ) : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if len != 0 : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT @ classmethod NEW_LINE def Longestsubstring ( cls , s ) : NEW_LINE INDENT lps = cls . compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if lps [ n - 1 ] == 0 : NEW_LINE INDENT print - 1 NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if lps [ i ] == lps [ n - 1 ] : NEW_LINE INDENT print s . substring ( 0 , lps [ i ] ) NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if lps [ lps [ n - 1 ] - 1 ] == 0 : NEW_LINE INDENT print - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print s . substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " fixprefixsuffix " NEW_LINE cls . Longestsubstring ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class IS ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT IS ( ) . runapp ( ) NEW_LINE DEDENT def runapp ( self ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE n = scan . nextInt ( ) NEW_LINE d = scan . nextInt ( ) NEW_LINE sequence = [ None ] * n NEW_LINE step = 0 NEW_LINE store = int ( ) NEW_LINE x = 0 NEW_LINE while x < n : NEW_LINE INDENT sequence [ x ] = scan . nextInt ( ) NEW_LINE x += 1 NEW_LINE DEDENT y = 0 NEW_LINE while y < n - 1 : NEW_LINE INDENT while sequence [ y + 1 ] <= sequence [ y ] : NEW_LINE INDENT if sequence [ y + 1 ] == sequence [ y ] : NEW_LINE INDENT sequence [ y + 1 ] = sequence [ y + 1 ] + d NEW_LINE step = step + 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff = - diff NEW_LINE store = ( diff / d ) + 1 NEW_LINE step = step + store NEW_LINE sequence [ y + 1 ] = sequence [ y + 1 ] + ( d * store ) NEW_LINE DEDENT DEDENT y += 1 NEW_LINE DEDENT System . out . printf ( " % d " , step ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE IS . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def checkIfPowerIsolated ( cls , num ) : NEW_LINE INDENT input = num NEW_LINE count = 0 NEW_LINE factor = [ None ] * num + 1 NEW_LINE if num % 2 == 0 : NEW_LINE INDENT while num % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE num /= 2 NEW_LINE DEDENT factor [ 2 ] = count NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= num : NEW_LINE INDENT count = 0 NEW_LINE while num % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE num /= i NEW_LINE DEDENT if count > 0 : NEW_LINE INDENT factor [ i ] = count NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if num > 1 : NEW_LINE INDENT factor [ num ] = 1 NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while i < num + 1 : NEW_LINE INDENT if factor [ i ] > 0 : NEW_LINE INDENT product = product * factor [ i ] * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if product == input : NEW_LINE INDENT print " Power - isolated ▁ Integer \n " , NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ a ▁ Power - isolated ▁ Integer \n " , NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . checkIfPowerIsolated ( 12 ) NEW_LINE cls . checkIfPowerIsolated ( 18 ) NEW_LINE cls . checkIfPowerIsolated ( 35 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE s = sc . next ( ) . toCharArray ( ) NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while i < s . length : NEW_LINE INDENT if len % 2 == 0 and s [ i ] == ' A ' or len % 2 == 1 and s [ i ] == ' Z ' : NEW_LINE INDENT len += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT len /= 2 NEW_LINE if len == 0 : NEW_LINE INDENT print - 1 NEW_LINE DEDENT else : NEW_LINE INDENT while i < len : NEW_LINE INDENT sb . append ( " AZ " ) NEW_LINE i += 1 NEW_LINE DEDENT print sb . __str__ ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE k = sc . nextInt ( ) NEW_LINE a = sc . next ( ) NEW_LINE if k > n / 2 : NEW_LINE INDENT while k < n : NEW_LINE INDENT print " RIGHT " NEW_LINE k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while k > 1 : NEW_LINE INDENT print " LEFT " NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT if k == 1 : NEW_LINE INDENT while i < len ( a ) : NEW_LINE INDENT print " PRINT ▁ " + a . charAt ( i ) NEW_LINE if ( i + 1 ) < len ( a ) : NEW_LINE INDENT print " RIGHT " NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while i >= 0 : NEW_LINE INDENT print " PRINT ▁ " + a . charAt ( i ) NEW_LINE if ( i - 1 ) >= 0 : NEW_LINE INDENT print " LEFT " NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def Subtract ( cls , a , b ) : NEW_LINE INDENT c = int ( ) NEW_LINE c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE print cls . Subtract ( a , b ) NEW_LINE a = 9 NEW_LINE b = 7 NEW_LINE print cls . Subtract ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class InfiniteSequence ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE n1 = Long . parseLong ( br . readLine ( ) ) NEW_LINE n = ( ( ( Math . sqrt ( 1 + ( 8 * n1 ) ) - 1 ) / 2 ) ) NEW_LINE ans = n1 - ( ( ( n + 1 ) * n ) / 2 ) NEW_LINE print ans if ( ans != 0 , else n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE InfiniteSequence . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def nextZero ( cls , i , occurrences ) : NEW_LINE INDENT while i < occurrences . length : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def getModifiedString ( cls , str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE if n > 26 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT ch = str_ . toCharArray ( ) NEW_LINE i = int ( ) NEW_LINE occurrences = [ None ] * 26 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT index = cls . nextZero ( 0 , occurrences ) NEW_LINE while i < n : NEW_LINE INDENT if occurrences [ ch [ i ] - ' a ' ] > 1 : NEW_LINE INDENT occurrences [ ch [ i ] - ' a ' ] -= 1 NEW_LINE ch [ i ] = ( ( ' a ' + index ) ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return String . valueOf ( ch ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arr ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE print cls . getModifiedString ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Arrays NEW_LINE import java . util . Comparator NEW_LINE import java . util . Scanner NEW_LINE class Ada ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE dp = [ None ] * n + 1 NEW_LINE pre = [ None ] * n + 1 NEW_LINE prevSum = dp [ 1 ] = 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if i != 1 : NEW_LINE INDENT pre [ i ] = ( pre [ i - 1 ] + pre [ i ] ) % m NEW_LINE dp [ i ] = ( prevSum + pre [ i ] ) % m NEW_LINE prevSum = ( prevSum + dp [ i ] ) % m NEW_LINE DEDENT while j <= n : NEW_LINE INDENT pre [ j ] = ( pre [ j ] + dp [ i ] ) % m NEW_LINE if r <= n : NEW_LINE INDENT pre [ r ] = ( ( pre [ r ] - dp [ i ] ) % m + m ) % m NEW_LINE DEDENT j = p * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print dp [ n ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Ada . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Deque NEW_LINE import java . util . LinkedList NEW_LINE class SlidingWindow ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printMax ( cls , arr , n , k ) : NEW_LINE INDENT Qi = LinkedList ( ) NEW_LINE i = int ( ) NEW_LINE while i < k : NEW_LINE INDENT while not Qi . isEmpty ( ) and arr [ i ] >= arr [ Qi . peekLast ( ) ] : NEW_LINE Qi . addLast ( i ) NEW_LINE i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT print arr [ Qi . peek ( , ] + " ▁ " ) NEW_LINE while ( not Qi . isEmpty ( ) ) and Qi . peek ( ) <= i - k : NEW_LINE while ( not Qi . isEmpty ( ) ) and arr [ i ] >= arr [ Qi . peekLast ( ) ] : NEW_LINE Qi . addLast ( i ) NEW_LINE i += 1 NEW_LINE DEDENT print arr [ Qi . peek ( ) ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 12 , 1 , 78 , 90 , 57 , 89 , 56 ] NEW_LINE k = 3 NEW_LINE cls . printMax ( arr , arr . length , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE SlidingWindow . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isValid ( cls , str_ , len ) : NEW_LINE INDENT i = 1 NEW_LINE while i < len : NEW_LINE INDENT if str_ . charAt ( i ) == str_ . charAt ( i - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = "0110" NEW_LINE len = len ( str_ ) NEW_LINE if cls . isValid ( str_ , len ) : NEW_LINE INDENT print " Valid " NEW_LINE DEDENT else : NEW_LINE INDENT print " Invalid " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Random NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def lehmann ( cls , n , t ) : NEW_LINE INDENT rand = Random ( ) NEW_LINE a = rand . nextInt ( n - 3 ) + 2 NEW_LINE e = ( n - 1 ) / 2 NEW_LINE while t > 0 : NEW_LINE INDENT if ( result % n ) == 1 or ( result % n ) == ( n - 1 ) : NEW_LINE INDENT a = rand . nextInt ( n - 3 ) + 2 NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 13 NEW_LINE t = 10 NEW_LINE if n == 2 : NEW_LINE INDENT print " ▁ 2 ▁ is ▁ Prime . " NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT print n + " ▁ is ▁ Composite " NEW_LINE DEDENT else : NEW_LINE INDENT if flag == 1 : NEW_LINE INDENT print n + " ▁ may ▁ be ▁ Prime . " NEW_LINE DEDENT else : NEW_LINE INDENT print n + " ▁ is ▁ Composite . " NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class sub ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE num = in_ . nextInt ( ) NEW_LINE __num_0 = num NEW_LINE num -= 1 NEW_LINE while __num_0 > 0 : NEW_LINE INDENT while a != 0 and b != 0 : NEW_LINE INDENT if a >= b : NEW_LINE INDENT res += a / b NEW_LINE a %= b NEW_LINE DEDENT else : NEW_LINE INDENT res += b / a NEW_LINE b %= a NEW_LINE DEDENT DEDENT print res NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE sub . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT N = 3 NEW_LINE @ classmethod NEW_LINE def MaxTraceSub ( cls , mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT while j < N : NEW_LINE INDENT while r < N and s < N : NEW_LINE INDENT trace += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = Math . max ( trace , max_trace ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max_trace NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT mat = [ ] NEW_LINE print cls . MaxTraceSub ( mat ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while sc . hasNext ( ) : NEW_LINE INDENT if xaMax < xbMin or xbMax < xaMin or yaMax < ybMin or ybMax < yaMin : NEW_LINE INDENT print " NO " NEW_LINE DEDENT else : NEW_LINE INDENT print " YES " NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class ArrayElimination ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE t = scan . nextInt ( ) NEW_LINE tt = 0 NEW_LINE while tt < t : NEW_LINE INDENT while i < n : NEW_LINE INDENT arr [ i ] = scan . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT while j < 32 : NEW_LINE INDENT if bitwiseAnd > 0 : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i <= n : NEW_LINE INDENT while j < 32 : NEW_LINE INDENT if bit [ j ] % i != 0 : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if possible : NEW_LINE INDENT print i + " ▁ " , NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print NEW_LINE tt += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE ArrayElimination . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printArray ( cls , N , arr ) : NEW_LINE INDENT i = 0 NEW_LINE while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT @ classmethod NEW_LINE def replacedArray ( cls , N , arr ) : NEW_LINE INDENT pos_sum = int ( ) NEW_LINE neg_sum = int ( ) NEW_LINE i = int ( ) NEW_LINE j = int ( ) NEW_LINE diff = int ( ) NEW_LINE pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE while i >= 0 : NEW_LINE INDENT diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) NEW_LINE if arr [ i ] > 0 : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] NEW_LINE DEDENT arr [ i ] = Math . abs ( diff ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE cls . replacedArray ( N , arr ) NEW_LINE cls . printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE cls . replacedArray ( N , arr1 ) NEW_LINE cls . printArray ( N , arr1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printArray ( cls , N , arr ) : NEW_LINE INDENT i = 0 NEW_LINE while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT @ classmethod NEW_LINE def replacedArray ( cls , N , arr ) : NEW_LINE INDENT pos_sum = int ( ) NEW_LINE neg_sum = int ( ) NEW_LINE i = int ( ) NEW_LINE j = int ( ) NEW_LINE diff = int ( ) NEW_LINE while i < N : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE while j < N : NEW_LINE INDENT if arr [ j ] > 0 : NEW_LINE INDENT pos_sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) NEW_LINE arr [ i ] = Math . abs ( diff ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE cls . replacedArray ( N , arr ) NEW_LINE cls . printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE cls . replacedArray ( N , arr1 ) NEW_LINE cls . printArray ( N , arr1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class _96B ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE number = in_ . nextLong ( ) NEW_LINE ans = - 1 NEW_LINE value = 0 NEW_LINE mask = 2 NEW_LINE while value < number : NEW_LINE INDENT for c in s . toCharArray ( ) : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT DEDENT if zeros != len ( s ) - zeros : NEW_LINE INDENT continue NEW_LINE DEDENT s = s . replace ( '0' , '4' ) NEW_LINE s = s . replace ( '1' , '7' ) NEW_LINE value = Long . parseLong ( s ) NEW_LINE DEDENT print value NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE _96B . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT N = 12 NEW_LINE ofs = [ ] NEW_LINE def del_ ( self , map , y , x ) : NEW_LINE INDENT map [ y ] [ x ] = False NEW_LINE i = 0 NEW_LINE while i < 4 : NEW_LINE INDENT if 0 <= ny and ny < N and 0 <= nx and nx < N : NEW_LINE INDENT if map [ ny ] [ nx ] : NEW_LINE INDENT self . del_ ( map , ny , nx ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def solve ( self , map ) : NEW_LINE INDENT c = 0 NEW_LINE y = 0 NEW_LINE while y < N : NEW_LINE INDENT while x < N : NEW_LINE INDENT if map [ y ] [ x ] : NEW_LINE INDENT c += 1 NEW_LINE self . del_ ( map , y , x ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def io ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while sc . hasNext ( ) : NEW_LINE INDENT while i < N : NEW_LINE INDENT str_ [ i ] = sc . nextLine ( ) . toCharArray ( ) NEW_LINE i += 1 NEW_LINE DEDENT while y < N : NEW_LINE INDENT while x < N : NEW_LINE INDENT map [ y ] [ x ] = str_ [ y ] [ x ] == '1' NEW_LINE x += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT print self . solve ( map ) NEW_LINE if sc . hasNext ( ) : NEW_LINE INDENT sc . nextLine ( ) NEW_LINE DEDENT DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . io ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def arraySortedOrNot ( cls , arr , n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = arr . length NEW_LINE if cls . arraySortedOrNot ( arr , n ) : NEW_LINE INDENT print " Yes \n " , NEW_LINE DEDENT else : NEW_LINE INDENT print " No \n " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class candies ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < a : NEW_LINE INDENT x [ i ] = in_ . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( x ) NEW_LINE while i < a : NEW_LINE INDENT s += Math . abs ( x [ i ] - x [ 0 ] ) NEW_LINE i += 1 NEW_LINE DEDENT print s NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE candies . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT def fib ( self , f ) : NEW_LINE INDENT f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while i <= 59 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT def findLastDigit ( self , n ) : NEW_LINE INDENT f = [ None ] * 60 NEW_LINE self . fib ( f ) NEW_LINE index = ( ( n % 60 L ) ) NEW_LINE return f [ index ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = long ( ) NEW_LINE ob = GFG ( ) NEW_LINE n = 1 NEW_LINE print ob . findLastDigit ( n ) NEW_LINE n = 61 NEW_LINE print ob . findLastDigit ( n ) NEW_LINE n = 7 NEW_LINE print ob . findLastDigit ( n ) NEW_LINE n = 67 NEW_LINE print ob . findLastDigit ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countEleLessThanOrEqual ( cls , arr1 , arr2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < m : NEW_LINE INDENT while j < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print count + " ▁ " , NEW_LINE i += 1 NEW_LINE DEDENT return m NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE cls . countEleLessThanOrEqual ( arr1 , arr2 , arr1 . length , arr2 . length ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class NewClass ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE name1 = in_ . next ( ) NEW_LINE name2 = in_ . next ( ) NEW_LINE print name1 + " ▁ " + name2 NEW_LINE n = in_ . nextInt ( ) NEW_LINE while True : NEW_LINE INDENT if s1 == name1 : NEW_LINE INDENT name1 = s2 NEW_LINE DEDENT if s1 == name2 : NEW_LINE INDENT name2 = s2 NEW_LINE DEDENT print name1 + " ▁ " + name2 NEW_LINE n -= 1 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE NewClass . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE import java . util . TreeSet NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE p = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) - 1 NEW_LINE p [ a [ i ] ] = i NEW_LINE i += 1 NEW_LINE DEDENT x = TreeSet ( ) NEW_LINE l = [ None ] * n NEW_LINE r = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT x . add ( p [ i ] ) NEW_LINE if x . first ( ) == p [ i ] : NEW_LINE INDENT l [ i ] = p [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l [ i ] = p [ i ] - lower NEW_LINE DEDENT if x . last ( ) == p [ i ] : NEW_LINE INDENT r [ i ] = n - p [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT r [ i ] = high - p [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT ans += ( l [ i ] ) * r [ i ] * ( i + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class LPS ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def max ( cls , x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT @ classmethod NEW_LINE def lps ( cls , seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE i = int ( ) NEW_LINE j = int ( ) NEW_LINE cl = int ( ) NEW_LINE L = [ None ] * n NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while cl <= n : NEW_LINE INDENT while i < n - cl + 1 : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if seq . charAt ( i ) == seq . charAt ( j ) and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif seq . charAt ( i ) == seq . charAt ( j ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT cl += 1 NEW_LINE DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + cls . lps ( seq ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printConsecutive ( cls , last , first ) : NEW_LINE INDENT __first_0 = first NEW_LINE first += 1 NEW_LINE print __first_0 , NEW_LINE x = first NEW_LINE while x <= last : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def findConsecutive ( cls , N ) : NEW_LINE INDENT last = 1 NEW_LINE while last < N : NEW_LINE INDENT while first < last : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT System . out . printf ( N + " ▁ = ▁ " ) NEW_LINE cls . printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT first += 1 NEW_LINE DEDENT last += 1 NEW_LINE DEDENT print " - 1" , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 12 NEW_LINE cls . findConsecutive ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isAlphabaticOrder ( cls , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT c [ i ] = s . charAt ( i ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( c ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " aabbbcc " NEW_LINE if cls . isAlphabaticOrder ( s ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printKMax ( cls , arr , n , k ) : NEW_LINE INDENT j = int ( ) NEW_LINE max = int ( ) NEW_LINE i = 0 NEW_LINE while i <= n - k : NEW_LINE INDENT max = arr [ i ] NEW_LINE while j < k : NEW_LINE INDENT if arr [ i + j ] > max : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print max + " ▁ " , NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE k = 3 NEW_LINE cls . printKMax ( arr , arr . length , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT






import java . util . Scanner NEW_LINE class FileName ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE str_ = sc . next ( ) NEW_LINE count = 0 NEW_LINE total = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT if str_ . charAt ( i ) == ' x ' : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT count = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT print total NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE FileName . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if num [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT while i < num . length : NEW_LINE INDENT if num [ i ] == ' A ' : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if A > B : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT print A + " ▁ " + B NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longestSubArray ( cls , arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if isZeroPresent : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = arr . length NEW_LINE print cls . longestSubArray ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE @ classmethod NEW_LINE def max_distinct_char ( cls , str_ , n ) : NEW_LINE INDENT count = [ None ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT count [ str_ . charAt ( i ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE i = 0 NEW_LINE while i < NO_OF_CHARS : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max_distinct NEW_LINE DEDENT @ classmethod NEW_LINE def smallesteSubstr_maxDistictChar ( cls , str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE max_distinct = cls . max_distinct_char ( str_ , n ) NEW_LINE minl = n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT if i < j : NEW_LINE INDENT subs = str_ . substring ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT subs = str_ . substring ( j , i ) NEW_LINE DEDENT if subs_lenght < minl and max_distinct == sub_distinct_char : NEW_LINE INDENT minl = subs_lenght NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return minl NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " AABBBCBB " NEW_LINE len = cls . smallesteSubstr_maxDistictChar ( str_ ) NEW_LINE print " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : ▁ " + len NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findNumberOfEvenCells ( cls , n , q , size ) : NEW_LINE INDENT row = [ None ] * n NEW_LINE col = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < size : NEW_LINE INDENT row [ x - 1 ] += 1 NEW_LINE col [ y - 1 ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT r1 = 0 NEW_LINE r2 = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if row [ i ] % 2 == 0 : NEW_LINE INDENT r1 += 1 NEW_LINE DEDENT if row [ i ] % 2 == 1 : NEW_LINE INDENT r2 += 1 NEW_LINE DEDENT if col [ i ] % 2 == 0 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if col [ i ] % 2 == 1 : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT count = r1 * c1 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 2 NEW_LINE q = [ ] NEW_LINE size = q . length NEW_LINE print cls . findNumberOfEvenCells ( n , q , size ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class BinaryStr ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT bf = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE t = Integer . valueOf ( bf . readLine ( ) ) NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT while j <= n - 1 : NEW_LINE INDENT arr2 [ j ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT while j <= n - 1 : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT arr2 [ j ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT arr2 [ j ] = '1' NEW_LINE DEDENT j += 1 NEW_LINE DEDENT while j <= n - 1 : NEW_LINE INDENT if arr [ j ] == arr2 [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT while k <= n - 1 : NEW_LINE INDENT if arr [ k ] == arr2 [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT cur += 1 NEW_LINE j = k - 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = Math . min ( ans , cur ) NEW_LINE while j <= n - 1 : NEW_LINE INDENT if j % 2 == 1 : NEW_LINE INDENT arr2 [ j ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT arr2 [ j ] = '1' NEW_LINE DEDENT j += 1 NEW_LINE DEDENT cur = 0 NEW_LINE while j <= n - 1 : NEW_LINE INDENT if arr [ j ] == arr2 [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT while k <= n - 1 : NEW_LINE INDENT if arr [ k ] == arr2 [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT cur += 1 NEW_LINE j = k - 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = Math . min ( ans , cur ) NEW_LINE print ans NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE BinaryStr . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class GrowTheTree ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE nums = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT nums [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( nums ) NEW_LINE firstHalf = 0 NEW_LINE secondHalf = 0 NEW_LINE length = n / 2 NEW_LINE i = 0 NEW_LINE while i < length : NEW_LINE INDENT firstHalf += nums [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i = length NEW_LINE while i < n : NEW_LINE INDENT secondHalf += nums [ i ] NEW_LINE i += 1 NEW_LINE DEDENT result = ( firstHalf * firstHalf ) + ( secondHalf * secondHalf ) NEW_LINE print result NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GrowTheTree . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find ( cls , dividend , divisor , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return [ None ] * NEW_LINE DEDENT mid = start + ( end - start ) / 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if n > divisor : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif n < 0 : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if n == divisor : NEW_LINE INDENT mid += 1 NEW_LINE n = 0 NEW_LINE DEDENT return [ None ] * NEW_LINE DEDENT return cls . find ( dividend , divisor , start , end ) NEW_LINE DEDENT @ classmethod NEW_LINE def divide ( cls , dividend , divisor ) : NEW_LINE INDENT return cls . find ( dividend , divisor , 1 , dividend ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT dividend = 10 NEW_LINE divisor = 3 NEW_LINE ans = cls . divide ( dividend , divisor ) NEW_LINE print ans [ 0 ] + " , ▁ " , NEW_LINE print ans [ 1 ] + " \n " , NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class MP3 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE diskSize = in_ . nextInt ( ) * 8 NEW_LINE sounds = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sounds [ i ] = in_ . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( sounds ) NEW_LINE distinctVals = [ None ] * n NEW_LINE distinctAmt = [ None ] * n NEW_LINE k = - 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE k += 1 NEW_LINE INDENT if i == 0 or sounds [ i ] > sounds [ i - 1 ] : NEW_LINE INDENT distinctVals [ k ] = sounds [ i ] NEW_LINE distinctAmt [ k ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT distinctAmt [ k ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT k += 1 NEW_LINE answer = n NEW_LINE currAmt = distinctAmt [ 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < k : NEW_LINE INDENT while j < i or ( j < k - 1 and n * lg ( j + 1 - i + 1 ) <= diskSize ) : NEW_LINE INDENT j += 1 NEW_LINE currAmt += distinctAmt [ j ] NEW_LINE DEDENT answer = Math . min ( answer , n - currAmt ) NEW_LINE i += 1 NEW_LINE DEDENT print answer NEW_LINE DEDENT @ classmethod NEW_LINE def lg ( cls , n ) : NEW_LINE INDENT res = 0 NEW_LINE while n > ( 1 << res ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE MP3 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def towerOfHanoi ( cls , n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod NEW_LINE return NEW_LINE DEDENT cls . towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + aux_rod2 NEW_LINE print " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod NEW_LINE print " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + aux_rod2 + " ▁ to ▁ rod ▁ " + to_rod NEW_LINE cls . towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE cls . towerOfHanoi ( n , ' A ' , ' D ' , ' B ' , ' C ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import NEW_LINE import java . util . StringTokenizer NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT r = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE n = r . readLine ( ) NEW_LINE res = " " NEW_LINE i = 0 NEW_LINE while i < len ( n ) : NEW_LINE INDENT if n . charAt ( i ) == ' > ' : NEW_LINE INDENT res += "1000" NEW_LINE DEDENT elif n . charAt ( i ) == ' < ' : NEW_LINE INDENT res += "1001" NEW_LINE DEDENT elif n . charAt ( i ) == ' + ' : NEW_LINE INDENT res += "1010" NEW_LINE DEDENT elif n . charAt ( i ) == ' - ' : NEW_LINE INDENT res += "1011" NEW_LINE DEDENT elif n . charAt ( i ) == ' . ' : NEW_LINE INDENT res += "1100" NEW_LINE DEDENT elif n . charAt ( i ) == ' , ' : NEW_LINE INDENT res += "1101" NEW_LINE DEDENT elif n . charAt ( i ) == ' [ ' : NEW_LINE INDENT res += "1110" NEW_LINE DEDENT elif n . charAt ( i ) == ' ] ' : NEW_LINE INDENT res += "1111" NEW_LINE DEDENT i += 1 NEW_LINE DEDENT k = 0 NEW_LINE m = 0 NEW_LINE i = len ( res ) - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT m += ( ( ( Math . pow ( 2 , k ) % 1000003 ) * y ) ) % 1000003 NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT print m % 1000003 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE D = sc . nextInt ( ) NEW_LINE G = sc . nextInt ( ) NEW_LINE p = [ None ] * D NEW_LINE c = [ None ] * D NEW_LINE i = 0 NEW_LINE while i < D : NEW_LINE INDENT p [ i ] = sc . nextInt ( ) NEW_LINE c [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT min = 1001 NEW_LINE count = 0 NEW_LINE ans = 0 NEW_LINE a = 4 NEW_LINE i = 0 NEW_LINE while i < Math . pow ( 2 , D ) : NEW_LINE INDENT while j < N : NEW_LINE INDENT if bit . charAt ( j ) == '1' : NEW_LINE INDENT count += p [ j ] * ( j + 1 ) * 100 + c [ j ] NEW_LINE ans += p [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if count < G : NEW_LINE INDENT while j >= 0 : NEW_LINE INDENT if bit . charAt ( j ) == '0' : NEW_LINE INDENT while count < G and l > 0 : NEW_LINE INDENT count += ( j + 1 ) * 100 NEW_LINE ans += 1 NEW_LINE l -= 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT if count >= G : NEW_LINE INDENT min = Math . min ( ans , min ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 0 NEW_LINE i += 1 NEW_LINE DEDENT print min NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Application ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE n = scan . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < a : NEW_LINE INDENT k += scan . nextInt ( ) NEW_LINE j += 1 NEW_LINE DEDENT if b == k : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Application . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countSetBits ( cls , n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return bitCount NEW_LINE DEDENT @ classmethod NEW_LINE def countSetBitsUtil ( cls , x ) : NEW_LINE INDENT if x <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if x % 2 == 0 else 1 ) + cls . countSetBitsUtil ( x / 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE print " Total ▁ set ▁ bit ▁ count ▁ is ▁ " , NEW_LINE print cls . countSetBits ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxSubArraySum ( cls , a , size ) : NEW_LINE INDENT max_so_far = Integer . MIN_VALUE NEW_LINE max_ending_here = 0 NEW_LINE i = 0 NEW_LINE while i < size : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT @ classmethod NEW_LINE def minPossibleSum ( cls , a , n , x ) : NEW_LINE INDENT mxSum = cls . maxSubArraySum ( a , n ) NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum += a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT sum = sum - mxSum + mxSum / x NEW_LINE print sum + " \n " , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 3 NEW_LINE X = 2 NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE cls . minPossibleSum ( A , N , X ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import java . util . ArrayList NEW_LINE import java . util . StringTokenizer NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = FastScanner ( ) NEW_LINE out = PrintWriter ( System . out ) NEW_LINE t = int ( ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT n = sc . nextInt ( ) NEW_LINE while i <= n : NEW_LINE INDENT arr [ i ] = sc . nextInt ( ) NEW_LINE indexOf [ arr [ i ] ] = i NEW_LINE i += 1 NEW_LINE DEDENT while e >= 1 : NEW_LINE INDENT if ind >= least : NEW_LINE INDENT continue NEW_LINE DEDENT while j < least : NEW_LINE INDENT j += 1 NEW_LINE DEDENT least = ind NEW_LINE e -= 1 NEW_LINE DEDENT for e in ans : NEW_LINE INDENT out . print_ ( e + " ▁ " ) NEW_LINE DEDENT out . println ( ) NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT class FastScanner ( object ) : NEW_LINE INDENT br = BufferedReader ( ) NEW_LINE st = StringTokenizer ( ) NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st == None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return Double . parseDouble ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT str_ = " " NEW_LINE try : NEW_LINE INDENT str_ = br . readLine ( ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT return str_ NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def line ( cls , x0 , y0 ) : NEW_LINE INDENT c = ( ( 2 * y0 * x0 ) ) NEW_LINE print String . format ( " % .1f " , y0 ) + " x " + " ▁ + ▁ " + String . format ( " % .1f " , x0 ) + " y ▁ = ▁ " + String . format ( " % .1f " , c ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE cls . line ( x0 , y0 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findMajority ( cls , arr , n ) : NEW_LINE INDENT return arr [ n / 2 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = arr . length NEW_LINE print cls . findMajority ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Test . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . FileReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . math . BigDecimal NEW_LINE import java . math . BigInteger NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE import java . util . Comparator NEW_LINE import java . util . HashMap NEW_LINE import java . util . HashSet NEW_LINE import java . util . List NEW_LINE import java . util . PriorityQueue NEW_LINE import java . util . Stack NEW_LINE class Solution ( object ) : NEW_LINE INDENT nodeColors = [ ] NEW_LINE visited = [ ] NEW_LINE neighborstring = [ ] NEW_LINE startIndices = [ ] NEW_LINE edgesToPrint = [ ] NEW_LINE mod = 998244353 NEW_LINE parents = [ ] NEW_LINE cycleSet = HashSet ( ) NEW_LINE neighborPriority = [ ] NEW_LINE minPointsToEnterRoom = [ ] NEW_LINE maxPointsToEnterRoom = [ ] NEW_LINE pointOfEachRoom = [ ] NEW_LINE neighbors = [ ] NEW_LINE memo = [ ] NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT bufferedReader = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE count = Integer . parseInt ( bufferedReader . readLine ( ) ) NEW_LINE pos = 0 NEW_LINE i = 0 NEW_LINE while i < count : NEW_LINE INDENT if s [ 1 ] == " South " : NEW_LINE INDENT pos += no NEW_LINE if pos > 20000 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif s [ 1 ] == " North " : NEW_LINE INDENT pos -= no NEW_LINE if pos < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if pos == 0 or pos == 20000 : NEW_LINE INDENT pos = 1 NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if pos == 0 : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Solution . main ( sys . argv ) NEW_LINE DEDENT





class LCS_3Strings ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def lcsOf3 ( cls , X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ None ] * m + 1 NEW_LINE i = 0 NEW_LINE while i <= m : NEW_LINE INDENT while j <= n : NEW_LINE INDENT while k <= o : NEW_LINE INDENT if i == 0 or j == 0 or k == 0 : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) and X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT X = " AGGT12" NEW_LINE Y = "12TXAYB " NEW_LINE Z = "12XBA " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print " Length ▁ of ▁ LCS ▁ is ▁ " + cls . lcsOf3 ( X , Y , Z , m , n , o ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE LCS_3Strings . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isSpiltPossible ( cls , n , a ) : NEW_LINE INDENT sum = 0 NEW_LINE c1 = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum += a [ i ] NEW_LINE if a [ i ] == 1 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( sum / 2 ) % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if c1 > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if cls . isSpiltPossible ( n , a ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class JohnyLikesNumbers ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = java . util . Scanner ( System . in_ ) NEW_LINE n = input . nextInt ( ) NEW_LINE k = input . nextInt ( ) NEW_LINE print ( n / k + 1 ) * k NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE JohnyLikesNumbers . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Scanner NEW_LINE import java . util . Stack NEW_LINE class Main ( object ) : NEW_LINE INDENT h = int ( ) NEW_LINE w = int ( ) NEW_LINE c = int ( ) NEW_LINE ans = int ( ) NEW_LINE count = int ( ) NEW_LINE color_order = [ ] NEW_LINE map = [ ] NEW_LINE tmp = [ ] NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while sc . hasNext ( ) : NEW_LINE INDENT while i < ns . length : NEW_LINE INDENT if len ( ns [ i ] ) > 1 : NEW_LINE INDENT stack . push ( Double . parseDouble ( ns [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if sw == '0' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '1' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '2' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '3' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '4' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '5' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '6' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '7' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '8' : NEW_LINE INDENT pass NEW_LINE DEDENT elif sw == '9' : NEW_LINE INDENT stack . push ( Double . parseDouble ( ns [ i ] ) ) NEW_LINE DEDENT elif sw == ' + ' : NEW_LINE INDENT stack . push ( x + y ) NEW_LINE DEDENT elif sw == ' - ' : NEW_LINE INDENT stack . push ( y - x ) NEW_LINE DEDENT elif sw == ' * ' : NEW_LINE INDENT stack . push ( y * x ) NEW_LINE DEDENT elif sw == ' / ' : NEW_LINE INDENT stack . push ( y / x ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT System . out . printf ( " % .6f \n " , cls . ans ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countNonIncreasing ( cls , arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if arr [ i + 1 ] >= arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) NEW_LINE len = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] NEW_LINE n = arr . length NEW_LINE print cls . countNonIncreasing ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . io . BufferedReader NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT INFINITY = Integer . MAX_VALUE / 2 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE N = Integer . parseInt ( br . readLine ( ) ) NEW_LINE K = [ None ] * N NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT while j < N : NEW_LINE INDENT K [ i ] [ j ] = INFINITY NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT m = Integer . parseInt ( br . readLine ( ) ) NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT K [ a ] [ b ] = Integer . parseInt ( str_ [ 2 ] ) NEW_LINE K [ b ] [ a ] = Integer . parseInt ( str_ [ 3 ] ) NEW_LINE i += 1 NEW_LINE DEDENT str_ = br . readLine ( ) . split ( " , " ) NEW_LINE start = Integer . parseInt ( str_ [ 0 ] ) - 1 NEW_LINE goal = Integer . parseInt ( str_ [ 1 ] ) - 1 NEW_LINE V = Integer . parseInt ( str_ [ 2 ] ) NEW_LINE P = Integer . parseInt ( str_ [ 3 ] ) NEW_LINE k = 0 NEW_LINE while k < N : NEW_LINE INDENT while i < N : NEW_LINE INDENT while j < N : NEW_LINE INDENT if K [ i ] [ j ] > K [ i ] [ k ] + K [ k ] [ j ] : NEW_LINE INDENT K [ i ] [ j ] = K [ i ] [ k ] + K [ k ] [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT print V - P - K [ start ] [ goal ] - K [ goal ] [ start ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE r1 = input . nextInt ( ) NEW_LINE r2 = input . nextInt ( ) NEW_LINE c1 = input . nextInt ( ) NEW_LINE c2 = input . nextInt ( ) NEW_LINE d1 = input . nextInt ( ) NEW_LINE d2 = input . nextInt ( ) NEW_LINE if ( c1 + c2 - r1 - r2 ) != 0 or ( d1 + d2 - r1 - r2 ) != 0 : NEW_LINE INDENT print - 1 , NEW_LINE DEDENT else : NEW_LINE INDENT for gem in box : NEW_LINE INDENT if gem > 9 or gem < 1 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( x == y ) or ( x == z ) or ( x == t ) or ( y == z ) or ( y == t ) or ( z == t ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT System . out . printf ( " % d ▁ % d % n % d ▁ % d " , x , y , z , t ) NEW_LINE DEDENT else : NEW_LINE INDENT print - 1 , NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE import java . util . SortedSet NEW_LINE import java . util . TreeSet NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < n : NEW_LINE INDENT a [ i ] = Integer . parseInt ( scan . next ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT while j < m : NEW_LINE INDENT w [ j ] = Integer . parseInt ( scan . next ( ) ) NEW_LINE j += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT if not bJust : NEW_LINE INDENT if commonAdditions == None : NEW_LINE INDENT commonAdditions = additions NEW_LINE DEDENT else : NEW_LINE INDENT commonAdditions . retainAll ( additions ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if commonAdditions == None : NEW_LINE INDENT print 0 NEW_LINE DEDENT else : NEW_LINE INDENT if len ( commonAdditions ) > 0 : NEW_LINE INDENT print commonAdditions . first ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print - 1 NEW_LINE DEDENT DEDENT DEDENT scan . close ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def calcNearestWeight ( cls , x , w , i , sum , additions ) : NEW_LINE INDENT if x == sum : NEW_LINE INDENT return True NEW_LINE DEDENT if i == w . length : NEW_LINE INDENT additions . add ( Math . abs ( x - sum ) ) NEW_LINE return False NEW_LINE DEDENT if cls . calcNearestWeight ( x , w , i + 1 , sum , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT if cls . calcNearestWeight ( x , w , i + 1 , sum + w [ i ] , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT return cls . calcNearestWeight ( x , w , i + 1 , sum - w [ i ] , additions ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT TEN = 10 NEW_LINE @ classmethod NEW_LINE def digitSum ( cls , n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % TEN NEW_LINE n /= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def getNthTerm ( cls , n ) : NEW_LINE INDENT sum = cls . digitSum ( n ) NEW_LINE if sum % TEN == 0 : NEW_LINE INDENT return ( n * cls . TEN ) NEW_LINE DEDENT extra = cls . TEN - ( sum % TEN ) NEW_LINE return ( ( n * cls . TEN ) + extra ) NEW_LINE DEDENT @ classmethod NEW_LINE def firstNTerms ( cls , n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 10 NEW_LINE cls . firstNTerms ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def power ( cls , x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while a > 0 : NEW_LINE INDENT if ( a & 1 ) > 0 : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def breakInteger ( cls , N ) : NEW_LINE INDENT if N == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if N == 3 : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if N % 3 == 0 : NEW_LINE INDENT maxProduct = power ( 3 , N / 3 ) NEW_LINE DEDENT elif N % 3 == 1 : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) NEW_LINE DEDENT elif N % 3 == 2 : NEW_LINE INDENT maxProduct = 2 * power ( 3 , N / 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT maxProduct = cls . breakInteger ( 10 ) NEW_LINE print maxProduct NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT def eulerPhiTable ( self , n ) : NEW_LINE INDENT res = [ None ] * n + 1 NEW_LINE p = [ None ] * n + 1 NEW_LINE Arrays . fill ( p , True ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE i = 0 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 2 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT N = 1000000 NEW_LINE f = self . eulerPhiTable ( N ) NEW_LINE res = [ None ] * N + 1 NEW_LINE res [ 1 ] = 2 NEW_LINE i = 2 NEW_LINE while i <= N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT sc = Scanner ( System . in_ ) NEW_LINE T = sc . nextInt ( ) NEW_LINE __T_0 = T NEW_LINE T -= 1 NEW_LINE while __T_0 != 0 : NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . LinkedList NEW_LINE import java . util . Queue NEW_LINE class NonReapatingCQueue ( object ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE @ classmethod NEW_LINE def firstNonRepeating ( cls , str_ ) : NEW_LINE INDENT charCount = [ None ] * MAX_CHAR NEW_LINE q = LinkedList ( ) NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT q . add ( ch ) NEW_LINE charCount [ ch - ' a ' ] += 1 NEW_LINE while not q . isEmpty ( ) : NEW_LINE INDENT if charCount [ q . peek ( ) - ' a ' ] > 1 : NEW_LINE INDENT q . remove ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print q . peek ( , + " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if q . isEmpty ( ) : NEW_LINE INDENT print - 1 + " ▁ " , NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " aabc " NEW_LINE cls . firstNonRepeating ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE NonReapatingCQueue . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE import java . util . ArrayList NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE def run ( self ) : NEW_LINE INDENT exp = self . sc . next ( ) NEW_LINE calc ( exp ) NEW_LINE DEDENT def calc ( self , exp ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = Integer . parseInt ( exp . substring ( 0 , 1 ) ) NEW_LINE temp = ans2 NEW_LINE i = 0 NEW_LINE while i < len ( exp ) / 2 : NEW_LINE INDENT if e == " + " : NEW_LINE INDENT ans2 += k NEW_LINE ans1 += temp NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT ans2 *= k NEW_LINE temp *= k NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans1 += temp NEW_LINE bob_ans = self . sc . nextInt ( ) NEW_LINE output = " " NEW_LINE if bob_ans == ans1 : NEW_LINE INDENT if bob_ans == ans2 : NEW_LINE INDENT output = " U " NEW_LINE DEDENT else : NEW_LINE INDENT output = " M " NEW_LINE DEDENT DEDENT elif bob_ans == ans2 : NEW_LINE INDENT output = " L " NEW_LINE DEDENT else : NEW_LINE INDENT output = " I " NEW_LINE DEDENT print output NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT one = [ " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " ] NEW_LINE ten = [ " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " ] NEW_LINE @ classmethod NEW_LINE def numToWords ( cls , n , s ) : NEW_LINE INDENT str_ = " " NEW_LINE if n > 19 : NEW_LINE INDENT str_ += ten [ n / 10 ] + one [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT str_ += one [ n ] NEW_LINE DEDENT if n != 0 : NEW_LINE INDENT str_ += s NEW_LINE DEDENT return str_ NEW_LINE DEDENT @ classmethod NEW_LINE def convertToWords ( cls , n ) : NEW_LINE INDENT out = " " NEW_LINE out += numToWords ( ( ( n / 10000000 ) ) , " crore ▁ " ) NEW_LINE out += numToWords ( ( ( ( n / 100000 ) % 100 ) ) , " lakh ▁ " ) NEW_LINE out += numToWords ( ( ( ( n / 1000 ) % 100 ) ) , " thousand ▁ " ) NEW_LINE out += numToWords ( ( ( ( n / 100 ) % 10 ) ) , " hundred ▁ " ) NEW_LINE if n > 100 and n % 100 > 0 : NEW_LINE INDENT out += " and ▁ " NEW_LINE DEDENT out += numToWords ( ( ( n % 100 ) ) , " " ) NEW_LINE return out NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 438237764 NEW_LINE print cls . convertToWords ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def flipSign ( cls , a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = 1 if a < 0 else - 1 NEW_LINE while a != 0 : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE DEDENT @ classmethod NEW_LINE def areDifferentSign ( cls , a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def sub ( cls , a , b ) : NEW_LINE INDENT return a + cls . flipSign ( b ) NEW_LINE DEDENT @ classmethod NEW_LINE def mul ( cls , a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return cls . mul ( b , a ) NEW_LINE DEDENT sum = 0 NEW_LINE i = Math . abs ( b ) NEW_LINE while i > 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT sum = flipSign ( sum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def division ( cls , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT raise ArithmeticException ( ) NEW_LINE DEDENT quotient = 0 NEW_LINE dividend = int ( ) NEW_LINE divisor = cls . flipSign ( Math . abs ( b ) ) NEW_LINE while dividend >= Math . abs ( divisor ) : NEW_LINE INDENT dividend += divisor NEW_LINE DEDENT if cls . areDifferentSign ( a , b ) : NEW_LINE INDENT quotient = flipSign ( quotient ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print " Subtraction ▁ is ▁ " + cls . sub ( 4 , - 2 ) NEW_LINE print " Product ▁ is ▁ " + cls . mul ( - 9 , 6 ) NEW_LINE try : NEW_LINE INDENT print " Division ▁ is ▁ " + cls . division ( 8 , 2 ) NEW_LINE DEDENT except ArithmeticException as e : NEW_LINE INDENT print " Exception ▁ : - ▁ Divide ▁ by ▁ 0" NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def factorial ( cls , n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE while n / i != n : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = 5 NEW_LINE print " Factorial ▁ of ▁ " + num + " ▁ is ▁ " + cls . factorial ( 5 ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def CntDivbyX ( cls , arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( number % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = arr . length NEW_LINE x = 2 NEW_LINE print cls . CntDivbyX ( arr , n , x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class B272 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE N = in_ . nextInt ( ) NEW_LINE stat = [ None ] * 30 NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT stat [ Integer . bitCount ( a ) ] += 1 NEW_LINE n += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for count in stat : NEW_LINE INDENT answer += count * ( count - 1 ) NEW_LINE DEDENT answer /= 2 NEW_LINE print answer NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE B272 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def CountSubSet ( cls , arr , n , X ) : NEW_LINE INDENT N = ( Math . pow ( 2 , n ) ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT while j < n : NEW_LINE INDENT if ( i & ( 1 << j ) ) != 0 : NEW_LINE INDENT if arr [ j ] == X : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 4 , 5 , 6 , 7 ] NEW_LINE X = 5 NEW_LINE n = arr . length NEW_LINE print cls . CountSubSet ( arr , n , X ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT n = 5 NEW_LINE @ classmethod NEW_LINE def FindMaxProduct ( cls , arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE result = int ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT if ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 1 ) <= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ ] NEW_LINE print cls . FindMaxProduct ( arr , cls . n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def smallestIndexsum ( cls , arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while i >= 0 and arr [ i ] % 2 == 1 : NEW_LINE sum = 0 NEW_LINE j = 0 NEW_LINE while j <= i : NEW_LINE INDENT j += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] NEW_LINE n = arr . length NEW_LINE print cls . smallestIndexsum ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT








class PellNumber ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def pell ( cls , n ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * cls . pell ( n - 1 ) + cls . pell ( n - 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE print cls . pell ( n ) NEW_LINE DEDENT DEDENT





class GFG ( object ) : NEW_LINE INDENT MAX = 26 NEW_LINE @ classmethod NEW_LINE def updateFreq ( cls , str_ , freq ) : NEW_LINE INDENT len = len ( str_ ) NEW_LINE i = 0 NEW_LINE while i < len : NEW_LINE INDENT freq [ str_ . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def maxCount ( cls , str_ , patt ) : NEW_LINE INDENT strFreq = [ None ] * MAX NEW_LINE cls . updateFreq ( str_ , strFreq ) NEW_LINE pattFreq = [ None ] * MAX NEW_LINE cls . updateFreq ( patt , pattFreq ) NEW_LINE ans = Integer . MAX_VALUE NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT if pattFreq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans = Math . min ( ans , strFreq [ i ] / pattFreq [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE patt = " geeks " NEW_LINE print cls . maxCount ( str_ , patt ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class A354 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE N = in_ . nextInt ( ) NEW_LINE L = in_ . nextInt ( ) NEW_LINE R = in_ . nextInt ( ) NEW_LINE QL = in_ . nextInt ( ) NEW_LINE QR = in_ . nextInt ( ) NEW_LINE W = [ None ] * N NEW_LINE sum = [ None ] * N + 1 NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT W [ n ] = in_ . nextInt ( ) NEW_LINE sum [ n + 1 ] = sum [ n ] + W [ n ] NEW_LINE n += 1 NEW_LINE DEDENT min = Long . MAX_VALUE NEW_LINE firstR = 0 NEW_LINE while firstR <= N : NEW_LINE INDENT cand += llCount * QL NEW_LINE cand += rrCount * QR NEW_LINE min = Math . min ( cand , min ) NEW_LINE firstR += 1 NEW_LINE DEDENT print min NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A354 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def wastedWater ( cls , V , M , N ) : NEW_LINE INDENT wasted_amt = float ( ) NEW_LINE amt_per_min = float ( ) NEW_LINE time_to_fill = float ( ) NEW_LINE amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT V = float ( ) NEW_LINE M = float ( ) NEW_LINE N = float ( ) NEW_LINE V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print cls . wastedWater ( V , M , N ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print cls . wastedWater ( V , M , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxSubStr ( cls , str_ , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE cnt = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if str_ . charAt ( i ) == '0' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if count0 == count1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if count0 != count1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = "0100110101" NEW_LINE n = len ( str_ ) NEW_LINE print cls . maxSubStr ( str_ , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findS ( cls , s ) : NEW_LINE INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while sum < s : NEW_LINE INDENT sum += n NEW_LINE if sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = 15 NEW_LINE n = cls . findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT else : NEW_LINE INDENT print n NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE @ classmethod NEW_LINE def countStrings ( cls , N ) : NEW_LINE INDENT i = int ( ) NEW_LINE j = int ( ) NEW_LINE dp = [ None ] * N + 1 NEW_LINE while i < N + 1 : NEW_LINE INDENT while j < 3 : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE while i <= N : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE i += 1 NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 3 NEW_LINE print cls . countStrings ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longest_subseq ( cls , n , k , s ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE max_length = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < upper + 1 : NEW_LINE INDENT dp [ i ] = Math . max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT max_length [ curr ] = Math . max ( dp [ i ] , max_length [ curr ] ) NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in dp : NEW_LINE INDENT ans = Math . max ( i , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE print cls . longest_subseq ( n , k , s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longestFibonacciSubarray ( cls , n , a ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = Integer . MIN_VALUE NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] + a [ i - 2 ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = Math . max ( mx , len ) NEW_LINE i += 1 NEW_LINE DEDENT return mx NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print cls . longestFibonacciSubarray ( n , a ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check ( cls , s ) : NEW_LINE INDENT freq = [ None ] * 10 NEW_LINE r = int ( ) NEW_LINE i = int ( ) NEW_LINE while i < 10 : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT while s != 0 : NEW_LINE INDENT r = s % 10 NEW_LINE s = ( ( s / 10 ) ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE while i < 10 : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if xor__ == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = 122233 NEW_LINE if cls . check ( s ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import java . nio . charset . MalformedInputException NEW_LINE import java . util . StringTokenizer NEW_LINE import java . util . Arrays NEW_LINE class Cv ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = FastScanner ( ) NEW_LINE sc = Scanner ( System . in_ ) NEW_LINE out = PrintWriter ( System . out ) NEW_LINE n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE g = m NEW_LINE f = 0 NEW_LINE sum = 0 NEW_LINE arr = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT arr [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if m <= sum : NEW_LINE INDENT f += sum / m NEW_LINE sum %= m NEW_LINE DEDENT out . print_ ( f + " ▁ " ) NEW_LINE f -= f NEW_LINE i += 1 NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT class FastScanner ( object ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE st = StringTokenizer ( " " ) NEW_LINE def next ( self ) : NEW_LINE INDENT while not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT str_ = " " NEW_LINE try : NEW_LINE INDENT str_ = br . readLine ( ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT return str_ NEW_LINE DEDENT def nextByte ( self ) : NEW_LINE INDENT return Byte . parseByte ( self . next ( ) ) NEW_LINE DEDENT def nextShort ( self ) : NEW_LINE INDENT return Short . parseShort ( self . next ( ) ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return java . lang . Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return Double . parseDouble ( self . next ( ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Cv . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAXN = 1000005 NEW_LINE even = [ None ] * MAXN NEW_LINE odd = [ None ] * MAXN NEW_LINE @ classmethod NEW_LINE def precompute ( cls , arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT cls . odd [ i ] = 1 NEW_LINE DEDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT cls . even [ i ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT cls . even [ i ] = even [ i ] + even [ i - 1 ] NEW_LINE cls . odd [ i ] = odd [ i ] + odd [ i - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def isOdd ( cls , L , R ) : NEW_LINE INDENT cnt = cls . odd [ R ] NEW_LINE if L > 0 : NEW_LINE INDENT cnt -= odd [ L - 1 ] NEW_LINE DEDENT if cnt == R - L + 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def performQueries ( cls , a , n , q , m ) : NEW_LINE INDENT cls . precompute ( a , n ) NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT if cls . isOdd ( L , R ) : NEW_LINE INDENT print " Odd " NEW_LINE DEDENT else : NEW_LINE INDENT print " Even " NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] NEW_LINE n = a . length NEW_LINE q = [ ] NEW_LINE m = q . length NEW_LINE cls . performQueries ( a , n , q , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . StringTokenizer NEW_LINE class pre422 ( object ) : NEW_LINE INDENT class FastReader ( object ) : NEW_LINE INDENT br = BufferedReader ( ) NEW_LINE st = StringTokenizer ( ) NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st == None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return Double . parseDouble ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT str_ = " " NEW_LINE try : NEW_LINE INDENT str_ = br . readLine ( ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT return str_ NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT obj = cls . FastReader ( ) NEW_LINE s = [ None ] * 1000 NEW_LINE n = 1 NEW_LINE while n <= 1000 : NEW_LINE INDENT while i <= 1000 : NEW_LINE INDENT while j <= 1000 : NEW_LINE INDENT if ( n - i * 3 - j * 5 ) % 7 == 0 and ( n - i * 3 - j * 5 ) / 7 >= 0 : NEW_LINE INDENT s [ n - 1 ] = ( i + " ▁ " + j + " ▁ " + ( n - i * 3 - j * 5 ) / 7 ) NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT s [ n - 1 ] = " - 1" NEW_LINE DEDENT n += 1 NEW_LINE DEDENT tc = obj . nextInt ( ) NEW_LINE __tc_0 = tc NEW_LINE tc -= 1 NEW_LINE while __tc_0 != 0 : NEW_LINE INDENT print s [ n - 1 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE pre422 . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import java . util . StringTokenizer NEW_LINE class BusesBetweenCities ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE pw = PrintWriter ( System . out ) NEW_LINE st = StringTokenizer ( br . readLine ( ) ) NEW_LINE a = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE tA = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE st = StringTokenizer ( br . readLine ( ) ) NEW_LINE b = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE tB = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE timing = br . readLine ( ) NEW_LINE hrs = Integer . parseInt ( timing . substring ( 0 , 2 ) ) NEW_LINE mins = Integer . parseInt ( timing . substring ( 3 ) ) NEW_LINE simDeparture = hrs * 60 + mins NEW_LINE simArrival = simDeparture + tA NEW_LINE counter = 0 NEW_LINE i = 300 NEW_LINE while i < 1440 : NEW_LINE INDENT if busDeparture >= simArrival or simDeparture >= busArrival : NEW_LINE INDENT continue NEW_LINE DEDENT counter += 1 NEW_LINE i += b NEW_LINE DEDENT pw . println ( counter ) NEW_LINE pw . flush ( ) NEW_LINE pw . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE BusesBetweenCities . main ( sys . argv ) NEW_LINE DEDENT
import java . util . ArrayList NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE n = input . nextInt ( ) NEW_LINE out = 3 NEW_LINE good = True NEW_LINE playing = ArrayList ( ) NEW_LINE playing . add ( 1 ) NEW_LINE playing . add ( 2 ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if win == out : NEW_LINE INDENT good = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT while j <= 3 : NEW_LINE INDENT if win != j and out != j : NEW_LINE INDENT replace = j NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT while j < len ( playing ) : NEW_LINE INDENT if playing . get ( j ) == replace : NEW_LINE INDENT index = j NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT playing . remove ( index ) NEW_LINE playing . add ( out ) NEW_LINE out = replace NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if good : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def times ( cls , steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT steps = [ 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 ] NEW_LINE n = steps . length NEW_LINE print cls . times ( steps , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def smallest ( cls , s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE i = 0 NEW_LINE while i < l - 1 : NEW_LINE INDENT if s . charAt ( i ) > s . charAt ( i + 1 ) : NEW_LINE INDENT while j < l : NEW_LINE INDENT if i != j : NEW_LINE INDENT ans += s . charAt ( j ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = s . substring ( 0 , l - 1 ) NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " abcda " NEW_LINE print cls . smallest ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE a = sc . nextInt ( ) NEW_LINE b = sc . nextInt ( ) NEW_LINE g = [ 0 , 0 , 2 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE if g [ a ] == g [ b ] : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def nthPalindrome ( cls , n , k ) : NEW_LINE INDENT temp = ( k / 2 ) if ( k & 1 ) != 0 else ( k / 2 - 1 ) NEW_LINE palindrome = ( Math . pow ( 10 , temp ) ) NEW_LINE palindrome += n - 1 NEW_LINE print palindrome , NEW_LINE if ( k & 1 ) > 0 : NEW_LINE INDENT palindrome /= 10 NEW_LINE DEDENT while palindrome > 0 : NEW_LINE INDENT print palindrome % 10 , NEW_LINE palindrome /= 10 NEW_LINE DEDENT print " " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " , NEW_LINE cls . nthPalindrome ( n , k ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " , NEW_LINE cls . nthPalindrome ( n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE p1 = input . nextInt ( ) NEW_LINE p2 = input . nextInt ( ) NEW_LINE p3 = input . nextInt ( ) NEW_LINE p4 = input . nextInt ( ) NEW_LINE a = input . nextInt ( ) NEW_LINE b = input . nextInt ( ) NEW_LINE i = int ( ) NEW_LINE min = Math . min ( Math . min ( p1 , p2 ) , Math . min ( p3 , p4 ) ) NEW_LINE c = 0 NEW_LINE while i <= b : NEW_LINE INDENT if i < min : NEW_LINE INDENT c += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print c NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class p033 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p033 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE d = 10 NEW_LINE while d < 100 : NEW_LINE INDENT while n < d : NEW_LINE INDENT if n1 == d0 and n0 * d == n * d1 or n0 == d1 and n1 * d == n * d0 : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT n += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT return Integer . toString ( denom / Library . gcd ( numer , denom ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p033 . main ( sys . argv ) NEW_LINE DEDENT






class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printPaths ( cls , input , R , C ) : NEW_LINE INDENT i = 0 NEW_LINE while i < C : NEW_LINE INDENT dfs ( input , " " , 0 , i , R , C ) NEW_LINE print NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def dfs ( cls , input , res , i , j , R , C ) : NEW_LINE INDENT if i == R : NEW_LINE INDENT print res + " ▁ " , NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE k = 0 NEW_LINE while k < C : NEW_LINE INDENT cls . dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = [ ] NEW_LINE R = input . length NEW_LINE C = input [ 0 ] . length NEW_LINE cls . printPaths ( input , R , C ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE num = Integer . parseInt ( sc . nextLine ( ) ) NEW_LINE line = sc . nextLine ( ) NEW_LINE hotel = [ None ] * 10 NEW_LINE i = 0 NEW_LINE while i < num : NEW_LINE INDENT if actual == ' L ' : NEW_LINE INDENT while pos < 10 and bb == True : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if actual == ' R ' : NEW_LINE INDENT while pos >= 0 and bb == True : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT pos -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT hotel [ pos ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT res = StringBuilder ( ) NEW_LINE for x in hotel : NEW_LINE INDENT res . append ( x ) NEW_LINE DEDENT print res . __str__ ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def hollowSquare ( cls , rows ) : NEW_LINE INDENT i = int ( ) NEW_LINE j = int ( ) NEW_LINE while i <= rows : NEW_LINE INDENT if i == 1 or i == rows : NEW_LINE INDENT while j <= rows : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while j <= rows : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT print " \n " , NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def solidSquare ( cls , rows ) : NEW_LINE INDENT i = int ( ) NEW_LINE j = int ( ) NEW_LINE while i <= rows : NEW_LINE INDENT while j <= rows : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print " \n " , NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def printPattern ( cls , rows ) : NEW_LINE INDENT print " Solid ▁ Square : \n " , NEW_LINE cls . solidSquare ( rows ) NEW_LINE print " \n Hollow ▁ Square : \n " , NEW_LINE cls . hollowSquare ( rows ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT rows = 5 NEW_LINE cls . printPattern ( rows ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE data = [ None ] * n + 1 NEW_LINE maxLen = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT data [ i ] [ 0 ] = in_ . nextInt ( ) NEW_LINE data [ i ] [ 1 ] = in_ . nextInt ( ) NEW_LINE maxLen += data [ i ] [ 0 ] NEW_LINE i += 1 NEW_LINE DEDENT in_ . close ( ) NEW_LINE dp = [ None ] * maxLen + 1 NEW_LINE Arrays . fill ( dp , 10000 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j >= data [ i ] [ 0 ] : NEW_LINE INDENT dp [ j ] = Math . min ( dp [ j ] , dp [ j - data [ i ] [ 0 ] ] + data [ i ] [ 1 ] ) NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = maxLen NEW_LINE while i >= 0 : NEW_LINE INDENT if maxLen - i >= dp [ i ] : NEW_LINE INDENT print maxLen - i NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findLargest ( cls , arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return gcd NEW_LINE DEDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT return a if b == 0 else cls . __gcd ( b , a % b ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = arr . length NEW_LINE print cls . findLargest ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findWinner ( cls , n ) : NEW_LINE INDENT if ( n - 1 ) % 6 == 0 : NEW_LINE INDENT print " Second ▁ Player ▁ wins ▁ the ▁ game " NEW_LINE DEDENT else : NEW_LINE INDENT print " First ▁ Player ▁ wins ▁ the ▁ game " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 7 NEW_LINE cls . findWinner ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class A ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE cs = [ ' P ' , ' R ' , ' S ' ] NEW_LINE dp = [ None ] * 3 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . dp [ 0 ] [ 0 ] = " P " NEW_LINE cls . dp [ 1 ] [ 0 ] = " R " NEW_LINE cls . dp [ 2 ] [ 0 ] = " S " NEW_LINE i = 1 NEW_LINE while i < dp [ 0 ] . length : NEW_LINE INDENT while j < 3 : NEW_LINE INDENT cls . dp [ j ] [ i ] = dp [ j ] [ i - 1 ] + dp [ ( j + 1 ) % 3 ] [ i - 1 ] NEW_LINE if o . compareTo ( cls . dp [ j ] [ i ] ) < 0 : NEW_LINE INDENT cls . dp [ j ] [ i ] = o NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT T = cls . sc . nextInt ( ) NEW_LINE i = 1 NEW_LINE while i <= T : NEW_LINE INDENT print " Case ▁ # " + i + " : ▁ " , NEW_LINE print solve ( ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def solve ( cls ) : NEW_LINE INDENT N = cls . sc . nextInt ( ) NEW_LINE R = cls . sc . nextInt ( ) NEW_LINE P = cls . sc . nextInt ( ) NEW_LINE S = cls . sc . nextInt ( ) NEW_LINE ret = None NEW_LINE i = 0 NEW_LINE while i < 3 : NEW_LINE INDENT for ch in dp [ i ] [ N ] . toCharArray ( ) : NEW_LINE INDENT if ch == ' P ' : NEW_LINE INDENT c [ 0 ] += 1 NEW_LINE DEDENT if ch == ' R ' : NEW_LINE INDENT c [ 1 ] += 1 NEW_LINE DEDENT if ch == ' S ' : NEW_LINE INDENT c [ 2 ] += 1 NEW_LINE DEDENT DEDENT if c [ 0 ] == P and c [ 1 ] == R and c [ 2 ] == S : NEW_LINE INDENT ret = dp [ i ] [ N ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return " IMPOSSIBLE " if ret == None else ret NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A . main ( sys . argv ) NEW_LINE DEDENT

class RepeatElement ( object ) : NEW_LINE INDENT def printRepeating ( self , arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE x = int ( ) NEW_LINE y = int ( ) NEW_LINE D = int ( ) NEW_LINE n = size - 2 NEW_LINE i = int ( ) NEW_LINE while i < size : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT S = S - n * ( n + 1 ) / 2 NEW_LINE P = P / fact ( n ) NEW_LINE D = ( Math . sqrt ( S * S - 4 * P ) ) NEW_LINE x = ( D + S ) / 2 NEW_LINE y = ( S - D ) / 2 NEW_LINE print " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : ▁ " , NEW_LINE print x + " ▁ & ▁ " + y , NEW_LINE print NEW_LINE DEDENT def fact ( self , n ) : NEW_LINE INDENT return 1 if ( n == 0 ) else n * self . fact ( n - 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT repeat = RepeatElement ( ) NEW_LINE arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = arr . length NEW_LINE repeat . printRepeating ( arr , arr_size ) NEW_LINE DEDENT DEDENT

import java . io . IOException NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE x = [ None ] * n NEW_LINE y = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT x [ i ] = sc . nextDouble ( ) NEW_LINE y [ i ] = sc . nextDouble ( ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE __cnt_0 = cnt NEW_LINE cnt += 1 NEW_LINE INDENT while j < n : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT deg [ __cnt_0 ] = ( Math . atan2 ( y [ j ] - y [ i ] , x [ j ] - x [ i ] ) ) NEW_LINE j += 1 NEW_LINE DEDENT Arrays . sort ( deg ) NEW_LINE while j < n - 2 : NEW_LINE INDENT ans = Math . max ( ans , deg [ ( j + 1 ) % ( n - 1 ) ] - deg [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans = Math . max ( ans , Math . PI * 2 + deg [ 0 ] - deg [ n - 2 ] ) NEW_LINE ans = ans - Math . PI NEW_LINE if ans <= 0 : NEW_LINE INDENT print 0 NEW_LINE DEDENT else : NEW_LINE INDENT print String . format ( " % .20f " , ans / ( 2 * Math . PI ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def tr ( self , * objects ) : NEW_LINE INDENT print Arrays . deepToString ( objects ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class test247 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE j = 0 NEW_LINE while j < t : NEW_LINE INDENT while i < n : NEW_LINE INDENT a [ i ] = in_ . nextLong ( ) NEW_LINE i += 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT max = a [ 0 ] * a [ 1 ] NEW_LINE DEDENT while i < n - 1 : NEW_LINE INDENT if a [ i - 1 ] > a [ i + 1 ] : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] > max : NEW_LINE INDENT max = a [ i ] * a [ i - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] * a [ i + 1 ] > max : NEW_LINE INDENT max = a [ i ] * a [ i + 1 ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print max NEW_LINE j += 1 NEW_LINE DEDENT in_ . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE test247 . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigInteger NEW_LINE class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def FindLCM ( cls , a , b ) : NEW_LINE INDENT return ( a * b ) / BigInteger ( a + " " ) . gcd ( BigInteger ( b + " " ) ) . intValue ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def rangeDivisor ( cls , m , n , a , b ) : NEW_LINE INDENT lcm = cls . FindLCM ( a , b ) NEW_LINE a_divisor = n / a - ( m - 1 ) / a NEW_LINE b_divisor = n / b - ( m - 1 ) / b NEW_LINE common_divisor = n / lcm - ( m - 1 ) / lcm NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT m = 3 NEW_LINE n = 11 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print cls . rangeDivisor ( m , n , a , b ) NEW_LINE m = 11 NEW_LINE n = 1000000 NEW_LINE a = 6 NEW_LINE b = 35 NEW_LINE print cls . rangeDivisor ( m , n , a , b ) NEW_LINE DEDENT DEDENT



import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT N = int ( ) NEW_LINE min = int ( ) NEW_LINE cnt = int ( ) NEW_LINE a = [ None ] * 180 NEW_LINE b = [ None ] * 45 NEW_LINE alreadyA = [ ] NEW_LINE alreadyB = [ ] NEW_LINE cnt = 0 NEW_LINE i = 1 NEW_LINE t = tetrahedral ( i ) NEW_LINE i = 0 NEW_LINE i = 1 NEW_LINE t = tetrahedral ( i ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cin = Scanner ( System . in_ ) NEW_LINE Arrays . fill ( cls . alreadyA , 0 ) NEW_LINE Arrays . fill ( cls . alreadyB , 0 ) NEW_LINE cls . a ( ) NEW_LINE while True : NEW_LINE INDENT cls . N = cin . nextInt ( ) NEW_LINE if cls . N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT cls . cnt = 0 NEW_LINE cls . min = Integer . MAX_VALUE NEW_LINE print cls . alreadyA [ cls . N ] , NEW_LINE print " ▁ " + cls . alreadyB [ cls . N ] NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def a ( cls ) : NEW_LINE INDENT i = 1 NEW_LINE while i < 1000000 : NEW_LINE INDENT while j < 180 and cls . a [ j ] <= i : NEW_LINE INDENT mina = Math . min ( 1 + alreadyA [ i - a [ j ] ] , mina ) NEW_LINE if cls . a [ j ] % 2 == 1 : NEW_LINE INDENT minb = Math . min ( 1 + alreadyB [ i - a [ j ] ] , minb ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT cls . alreadyA [ i ] = mina NEW_LINE cls . alreadyB [ i ] = minb NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def tetrahedral ( cls , a ) : NEW_LINE INDENT return ( a * ( a + 1 ) * ( a + 2 ) ) / 6 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countOfLetters ( cls , str_ ) : NEW_LINE INDENT letter = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT if ( str_ . charAt ( i ) >= ' A ' and str_ . charAt ( i ) <= ' Z ' ) or ( str_ . charAt ( i ) >= ' a ' and str_ . charAt ( i ) <= ' z ' ) : NEW_LINE INDENT letter += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return letter NEW_LINE DEDENT @ classmethod NEW_LINE def countOfNumbers ( cls , str_ ) : NEW_LINE INDENT number = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT if str_ . charAt ( i ) >= '0' and str_ . charAt ( i ) <= '9' : NEW_LINE INDENT number += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT @ classmethod NEW_LINE def check ( cls , str_ ) : NEW_LINE INDENT if cls . countOfLetters ( str_ ) == countOfNumbers ( str_ ) : NEW_LINE INDENT print " Yes \n " , NEW_LINE DEDENT else : NEW_LINE INDENT print " No \n " , NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " GeeKs01324" NEW_LINE cls . check ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE box = [ None ] * 10 NEW_LINE i = 0 NEW_LINE while scan . hasNext ( ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT i -= 1 NEW_LINE print box [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT box [ i ] = n NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . ArrayDeque NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while sc . hasNext ( ) : NEW_LINE INDENT if x == 1 or x == 2 * N - 1 : NEW_LINE INDENT print " No " NEW_LINE break NEW_LINE DEDENT print " Yes " NEW_LINE deq . add ( x ) NEW_LINE while low != 0 or high != 2 * N : NEW_LINE INDENT if low == 0 : NEW_LINE INDENT deq . push ( high ) NEW_LINE deq . add ( high + 1 ) NEW_LINE high += 2 NEW_LINE DEDENT elif high == 2 * N : NEW_LINE INDENT deq . add ( low ) NEW_LINE deq . push ( low - 1 ) NEW_LINE low -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT deq . push ( low ) NEW_LINE low -= 1 NEW_LINE deq . add ( high ) NEW_LINE high += 1 NEW_LINE DEDENT DEDENT for s in deq : NEW_LINE INDENT print s NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 100001 NEW_LINE perfectDiv = [ None ] * MAX NEW_LINE @ classmethod NEW_LINE def precomputeCounts ( cls ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i < MAX : NEW_LINE INDENT while j < MAX : NEW_LINE INDENT j += i * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def countPerfectDivisors ( cls , n ) : NEW_LINE INDENT return cls . perfectDiv [ n ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + cls . countPerfectDivisors ( n ) NEW_LINE n = 12 NEW_LINE print " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + cls . countPerfectDivisors ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT






class GFG ( object ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ None ] * MAX + 1 NEW_LINE @ classmethod NEW_LINE def SieveOfEratosthenes ( cls ) : NEW_LINE INDENT i = 0 NEW_LINE while i < prime . length : NEW_LINE INDENT cls . prime [ i ] = True NEW_LINE i += 1 NEW_LINE DEDENT cls . prime [ 1 ] = False NEW_LINE cls . prime [ 0 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if cls . prime [ p ] == True : NEW_LINE INDENT while i <= MAX : NEW_LINE INDENT cls . prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def SumOfKthPrimes ( cls , arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if cls . prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = arr . length NEW_LINE k = 2 NEW_LINE cls . SumOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ None ] * MAX + 1 NEW_LINE @ classmethod NEW_LINE def SieveOfEratosthenes ( cls ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= MAX : NEW_LINE INDENT i += 1 NEW_LINE DEDENT cls . prime [ 1 ] = False NEW_LINE cls . prime [ 0 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if cls . prime [ p ] == True : NEW_LINE INDENT while i <= MAX : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def solve ( cls , arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if cls . prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE cls . solve ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ None ] * MAX + 1 NEW_LINE @ classmethod NEW_LINE def SieveOfEratosthenes ( cls ) : NEW_LINE INDENT cls . prime [ 1 ] = True NEW_LINE cls . prime [ 0 ] = True NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if cls . prime [ p ] == False : NEW_LINE INDENT while i <= MAX : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def productOfKthPrimes ( cls , arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if not cls . prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print product NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ None ] * NEW_LINE cls . productOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE next = Node ( ) NEW_LINE def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def printList ( cls , node ) : NEW_LINE INDENT while node != None : NEW_LINE INDENT print node . data + " ▁ - > ▁ " , NEW_LINE node = node . next NEW_LINE DEDENT print " NULL " NEW_LINE DEDENT @ classmethod NEW_LINE def cntNodes ( cls , node ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cls . cntNodes ( node . next ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def updateList ( cls , head , m ) : NEW_LINE INDENT cnt = cls . cntNodes ( head ) NEW_LINE if cnt != m and m < cnt : NEW_LINE INDENT while skip > 0 : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE skip -= 1 NEW_LINE DEDENT prev . next = None NEW_LINE head = curr NEW_LINE while curr . next != None : NEW_LINE curr . next = tempHead NEW_LINE DEDENT cls . printList ( head ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT head = cls . Node ( 4 ) NEW_LINE head . next = Node ( 5 ) NEW_LINE head . next . next = Node ( 6 ) NEW_LINE head . next . next . next = Node ( 1 ) NEW_LINE head . next . next . next . next = Node ( 2 ) NEW_LINE head . next . next . next . next . next = Node ( 3 ) NEW_LINE m = 3 NEW_LINE cls . updateList ( head , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE ans = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT ans [ i ] = in_ . nextLong ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( ans ) NEW_LINE count = ans [ n - 1 ] NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ans [ i ] < ans [ i + 1 ] : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT while ans [ i ] >= ans [ i + 1 ] : NEW_LINE INDENT ans [ i ] -= 1 NEW_LINE DEDENT if ans [ i ] > 0 : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT print count NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . StringTokenizer NEW_LINE class Main ( object ) : NEW_LINE INDENT class FastReader ( object ) : NEW_LINE INDENT br = BufferedReader ( ) NEW_LINE st = StringTokenizer ( ) NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st == None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return Double . parseDouble ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT str_ = " " NEW_LINE try : NEW_LINE INDENT str_ = br . readLine ( ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT return str_ NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT reader = cls . FastReader ( ) NEW_LINE num = reader . nextInt ( ) NEW_LINE __num_0 = num NEW_LINE num -= 1 NEW_LINE while __num_0 > 0 : NEW_LINE INDENT while i < n * k : NEW_LINE INDENT arr [ i ] = reader . nextLong ( ) NEW_LINE i += 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT skip = n / 2 NEW_LINE while i <= k : NEW_LINE INDENT sum += arr [ start - skip - 1 ] NEW_LINE start = start - skip - 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT skip = n / 2 + 1 NEW_LINE while i <= k : NEW_LINE INDENT sum += arr [ start - skip ] NEW_LINE start = start - skip NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print sum NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printArray ( cls , arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def removeMin ( cls , arr , n ) : NEW_LINE INDENT i = int ( ) NEW_LINE minVal = arr [ 0 ] NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def removeFromMax ( cls , arr , n ) : NEW_LINE INDENT i = int ( ) NEW_LINE maxVal = arr [ 0 ] NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def modifyArray ( cls , arr , n , k ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT cls . removeMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT cls . removeFromMax ( arr , n ) NEW_LINE DEDENT cls . printArray ( arr , n ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = arr . length NEW_LINE k = 2 NEW_LINE cls . modifyArray ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find_Centroid ( cls , v ) : NEW_LINE INDENT ans = [ None ] * 2 NEW_LINE n = v . length NEW_LINE signedArea = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE i += 1 NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT vp = [ ] NEW_LINE ans = cls . find_Centroid ( vp ) NEW_LINE print String . format ( " % .3f " , ans [ 0 ] ) + " ▁ " + String . format ( " % .3f " , ans [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class App ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT color = " blue " NEW_LINE locked = False NEW_LINE in_ = Scanner ( System . in_ ) NEW_LINE lines = in_ . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < lines : NEW_LINE INDENT if " lock " == next . intern ( ) : NEW_LINE INDENT locked = True NEW_LINE continue NEW_LINE DEDENT if " unlock " == next . intern ( ) : NEW_LINE INDENT locked = False NEW_LINE continue NEW_LINE DEDENT if locked : NEW_LINE INDENT continue NEW_LINE DEDENT color = next NEW_LINE i += 1 NEW_LINE DEDENT print color NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE App . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class geeksforgeeks ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minOperations ( cls , ar , k ) : NEW_LINE INDENT Arrays . sort ( ar ) NEW_LINE opsNeeded = 0 NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT opsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = opsNeeded NEW_LINE i = k NEW_LINE while i < ar . length : NEW_LINE INDENT opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = Math . min ( ans , opsNeeded ) NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 1 , 9 , 100 ] NEW_LINE n = arr . length NEW_LINE k = 3 NEW_LINE print cls . minOperations ( arr , k ) NEW_LINE DEDENT DEDENT






import java . util . Scanner NEW_LINE class test251 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT if a . length >= 3 : NEW_LINE INDENT while j < a . length : NEW_LINE INDENT if a [ j ] == '1' : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if z > o : NEW_LINE INDENT print o NEW_LINE DEDENT elif o > z : NEW_LINE INDENT print z NEW_LINE DEDENT else : NEW_LINE INDENT print z - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT in_ . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE test251 . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = arr . length NEW_LINE totalCount = 0 NEW_LINE i = 0 NEW_LINE while i < length - 2 : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT while j < length - 1 : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT while k < length : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " + totalCount NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def finalNum ( cls , arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT result = __gcd ( result , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT return a if b == 0 else cls . __gcd ( b , a % b ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = arr . length NEW_LINE print cls . finalNum ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE input = sc . next ( ) . toCharArray ( ) NEW_LINE result = 0 NEW_LINE p = 0 NEW_LINE g = 1 NEW_LINE i = 1 NEW_LINE while i < input . length : NEW_LINE INDENT if input [ i ] == ' g ' : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT result += 1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE result -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print result NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT






class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxOR ( cls , arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = arr . length NEW_LINE print cls . maxOR ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def setBitNumber ( cls , n ) : NEW_LINE INDENT k = ( ( Math . log ( n ) / Math . log ( 2 ) ) ) NEW_LINE return ( ( Math . pow ( 2 , k ) ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT n = 273 NEW_LINE print cls . setBitNumber ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def subsetPairNotDivisibleByK ( cls , arr , N , K ) : NEW_LINE INDENT f = [ None ] * K NEW_LINE Arrays . fill ( f , 0 ) NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT f [ K / 2 ] = Math . min ( f [ K / 2 ] , 1 ) NEW_LINE DEDENT res = Math . min ( f [ 0 ] , 1 ) NEW_LINE i = 1 NEW_LINE while i <= K / 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = arr . length NEW_LINE K = 3 NEW_LINE print cls . subsetPairNotDivisibleByK ( arr , N , K ) NEW_LINE DEDENT DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printRoots ( cls , a , b , c ) : NEW_LINE INDENT print 1 + " , ▁ " + c / ( a * 1.0 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = - 5 NEW_LINE cls . printRoots ( a , b , c ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT N = 4 NEW_LINE @ classmethod NEW_LINE def MaximumDecimalValue ( cls , mat , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE if mat [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] [ i ] = ( ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = ( ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT mat = [ ] NEW_LINE print cls . MaximumDecimalValue ( mat , 4 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE o = int ( ) NEW_LINE g = int ( ) NEW_LINE x = 0 NEW_LINE n = long ( ) NEW_LINE borrow = 0 NEW_LINE o = sc . nextInt ( ) NEW_LINE n = sc . nextLong ( ) NEW_LINE g = sc . nextInt ( ) NEW_LINE i = 1 NEW_LINE while i <= g : NEW_LINE INDENT x = x + i * o NEW_LINE i += 1 NEW_LINE DEDENT borrow = x - n NEW_LINE if borrow <= 0 : NEW_LINE INDENT print 0 NEW_LINE DEDENT else : NEW_LINE INDENT print borrow NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPrime ( cls , k ) : NEW_LINE INDENT if k <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 2 NEW_LINE while i < k : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def check ( cls , num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE i = 2 NEW_LINE while i < k : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT if num % k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def findCount ( cls , a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if not cls . isPrime ( k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT while i <= b : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ans == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print cls . findCount ( a , b , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT maxn = 16 NEW_LINE @ classmethod NEW_LINE def precompute ( cls ) : NEW_LINE INDENT dp = [ None ] * maxn NEW_LINE arr = [ 4 , 6 , 9 ] NEW_LINE i = 0 NEW_LINE while i < maxn : NEW_LINE INDENT i += 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < maxn : NEW_LINE INDENT while k < 3 : NEW_LINE INDENT if i >= j and dp [ i - j ] != - 1 : NEW_LINE INDENT dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return dp NEW_LINE DEDENT @ classmethod NEW_LINE def Maximum_Summands ( cls , dp , n ) : NEW_LINE INDENT if n < maxn : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 12 NEW_LINE dp = cls . precompute ( ) NEW_LINE print cls . Maximum_Summands ( dp , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countSquares ( cls , n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE print " Count ▁ of ▁ squares ▁ is ▁ " + cls . countSquares ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . HashMap NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE a = [ None ] * n + 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT sum = [ None ] * n + 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum [ i ] = a [ i ] + sum [ i - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT map = HashMap ( ) NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT map . put ( sum [ i ] % m , 0 ) NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT map . put ( sum [ i ] % m , x + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE if map . containsKey ( 0 l ) : NEW_LINE INDENT ans = map . get ( 0 l ) NEW_LINE DEDENT for i in map . keySet ( ) : NEW_LINE INDENT if map . get ( i ) >= 2 : NEW_LINE INDENT while j > 1 : NEW_LINE INDENT ans += j - 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT print ans NEW_LINE DEDENT DEDENT class Pair ( Comparable ) : NEW_LINE INDENT from_ = int ( ) NEW_LINE end = int ( ) NEW_LINE num = int ( ) NEW_LINE bango = int ( ) NEW_LINE def compareTo ( self , other ) : NEW_LINE INDENT otherpair = Pair ( other ) NEW_LINE return self . from_ - otherpair . from_ NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def Loss ( cls , SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) ) / ( 100 * 100 - P * P ) NEW_LINE print " Loss ▁ = ▁ " + String . format ( " % .3f " , loss ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT SP = 2400 NEW_LINE P = 30 NEW_LINE cls . Loss ( SP , P ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE m = in_ . nextInt ( ) NEW_LINE x = in_ . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT a [ in_ . nextInt ( ) ] = 1 NEW_LINE i += 1 NEW_LINE DEDENT ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE i = x NEW_LINE while i > 0 : NEW_LINE INDENT ans1 += a [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT i = x NEW_LINE while i < n : NEW_LINE INDENT ans2 += a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print Math . min ( ans1 , ans2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class A1138_SushiForTwo ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE n = scanner . nextInt ( ) NEW_LINE len = 1 NEW_LINE prev = 0 NEW_LINE oneSeq = 0 NEW_LINE twoSeq = 0 NEW_LINE __n_0 = n NEW_LINE n -= 1 NEW_LINE while __n_0 > 0 : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT if prev == 1 : NEW_LINE INDENT oneSeq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT oneSeq = 1 NEW_LINE DEDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if prev == 2 : NEW_LINE INDENT twoSeq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT twoSeq = 1 NEW_LINE DEDENT prev = 2 NEW_LINE DEDENT if Math . min ( oneSeq , twoSeq ) > len : NEW_LINE INDENT len = Math . min ( oneSeq , twoSeq ) NEW_LINE DEDENT DEDENT print len * 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A1138_SushiForTwo . main ( sys . argv ) NEW_LINE DEDENT
class p092 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p092 ( ) . run ( ) NEW_LINE DEDENT LIMIT = Library . pow ( 10 , 7 ) NEW_LINE def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while i < LIMIT : NEW_LINE INDENT if isClass89 ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Integer . toString ( count ) NEW_LINE DEDENT @ classmethod NEW_LINE def isClass89 ( cls , x ) : NEW_LINE INDENT while True : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT elif x == 89 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT x = nextNumber ( x ) NEW_LINE DEDENT DEDENT DEDENT @ classmethod NEW_LINE def nextNumber ( cls , x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += ( x % 10 ) * ( x % 10 ) NEW_LINE x /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p092 . main ( sys . argv ) NEW_LINE DEDENT


import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Collections NEW_LINE import java . util . StringTokenizer NEW_LINE class AntonAndLines ( object ) : NEW_LINE INDENT eps = 10e-9 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE n = Integer . parseInt ( br . readLine ( ) ) NEW_LINE st = StringTokenizer ( br . readLine ( ) ) NEW_LINE start = Double . parseDouble ( st . nextToken ( ) ) NEW_LINE end = Double . parseDouble ( st . nextToken ( ) ) NEW_LINE first = ArrayList ( ) NEW_LINE second = ArrayList ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT st = StringTokenizer ( br . readLine ( ) ) NEW_LINE first . add ( Pair ( i + 1 , y1 , y2 ) ) NEW_LINE second . add ( Pair ( i + 1 , y2 , y1 ) ) NEW_LINE i += 1 NEW_LINE DEDENT Collections . sort ( first ) NEW_LINE Collections . sort ( second ) NEW_LINE i = 0 NEW_LINE while i < len ( first ) : NEW_LINE INDENT if first . get ( i ) . id != second . get ( i ) . id : NEW_LINE INDENT print " YES " NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " NO " NEW_LINE DEDENT class Pair ( Comparable , Pair ) : NEW_LINE INDENT x1 = float ( ) NEW_LINE x2 = float ( ) NEW_LINE id = int ( ) NEW_LINE def __init__ ( self , i , a , b ) : NEW_LINE INDENT super ( Pair , self ) . __init__ ( ) NEW_LINE self . x1 = a NEW_LINE self . x2 = b NEW_LINE self . id = i NEW_LINE DEDENT def compareTo ( self , o ) : NEW_LINE INDENT return ( Double ( self . x1 ) ) . compareTo ( o . x1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE AntonAndLines . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE t = sc . nextInt ( ) NEW_LINE s = [ None ] * n NEW_LINE d = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT s [ i ] = sc . nextInt ( ) NEW_LINE d [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT print solve ( s , d , t ) NEW_LINE sc . close ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls , s , d , t ) : NEW_LINE INDENT minTime = Integer . MAX_VALUE NEW_LINE result = - 1 NEW_LINE i = 0 NEW_LINE while i < s . length : NEW_LINE INDENT if time < minTime : NEW_LINE INDENT minTime = time NEW_LINE result = i + 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def divideToCeil ( cls , x , y ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return x / y + ( 0 if x % y == 0 else 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sumOfAP ( cls , a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print cls . sumOfAP ( a , d , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find3Numbers ( cls , arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE i = int ( ) NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] <= small : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif arr [ i ] <= large : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT print " No ▁ such ▁ triplet ▁ found " NEW_LINE return NEW_LINE DEDENT j = 0 NEW_LINE while j <= i : NEW_LINE INDENT if arr [ j ] < large : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print small + " ▁ " + large + " ▁ " + arr [ i ] NEW_LINE return NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = arr . length NEW_LINE cls . find3Numbers ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findPairCount ( cls , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ None ] * K NEW_LINE rem [ 0 ] = N / K NEW_LINE i = 1 NEW_LINE while i < K : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 NEW_LINE while i < K / 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 NEW_LINE while i <= K / 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 10 NEW_LINE K = 4 NEW_LINE print cls . findPairCount ( N , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < a . length : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT print " YES " if solve ( a ) else " NO " NEW_LINE sc . close ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls , a ) : NEW_LINE INDENT sum = Arrays . stream ( a ) . asLongStream ( ) . sum ( ) NEW_LINE max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) NEW_LINE return sum % 2 == 0 and max * 2 <= sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE @ classmethod NEW_LINE def fib ( cls , n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return cls . f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = ( Math . round ( fn * PHI ) ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 9 NEW_LINE print n + " th ▁ Fibonacci ▁ Number ▁ = ▁ " + cls . fib ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def kthSmallest ( cls , n , k ) : NEW_LINE INDENT return ( 2 * k ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 8 NEW_LINE k = 4 NEW_LINE print cls . kthSmallest ( n , k , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . math . BigInteger NEW_LINE import java . util . Scanner NEW_LINE class A30 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE A = in_ . nextInt ( ) NEW_LINE B = in_ . nextInt ( ) NEW_LINE N = in_ . nextInt ( ) NEW_LINE bigA = BigInteger . valueOf ( A ) NEW_LINE bigB = BigInteger . valueOf ( B ) NEW_LINE x = - 1000 NEW_LINE while x <= 1000 : NEW_LINE INDENT if BigInteger . valueOf ( x ) . pow ( N ) . multiply ( bigA ) == bigB : NEW_LINE INDENT print x NEW_LINE return NEW_LINE DEDENT x += 1 NEW_LINE DEDENT print " No ▁ solution " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A30 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def nextPowerOf2 ( cls , n ) : NEW_LINE INDENT count = 0 NEW_LINE if n != 0 and ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT @ classmethod NEW_LINE def removeElement ( cls , n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = cls . nextPowerOf2 ( n ) NEW_LINE if n == a or n == a - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == a - 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE print cls . removeElement ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class NumTh ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def Choose ( cls , n , k ) : NEW_LINE INDENT res = 1 NEW_LINE i = n NEW_LINE while i >= n - k + 1 : NEW_LINE INDENT res *= i NEW_LINE res /= k - n + i NEW_LINE i -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE N = sc . nextInt ( ) NEW_LINE P = sc . nextInt ( ) NEW_LINE Even = 0 NEW_LINE Odd = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT if A % 2 == 0 : NEW_LINE INDENT Even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Odd += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if Odd == 0 : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT print ( 1 ) << Even NEW_LINE DEDENT else : NEW_LINE INDENT print 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) << ( ( N - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sumOfDigits ( cls , x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x / 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def countNumbers ( cls , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE i = l NEW_LINE while i <= r : NEW_LINE INDENT if i % 2 == 0 and cls . sumOfDigits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT l = 1000 NEW_LINE r = 6000 NEW_LINE print cls . countNumbers ( l , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findGreater ( cls , a , b ) : NEW_LINE INDENT x = ( a ) * ( ( Math . log ( ( ( b ) ) ) ) ) NEW_LINE y = ( b ) * ( ( Math . log ( ( ( a ) ) ) ) ) NEW_LINE if y > x : NEW_LINE INDENT print " a ^ b ▁ is ▁ greater " NEW_LINE DEDENT elif y < x : NEW_LINE INDENT print " b ^ a ▁ is ▁ greater " NEW_LINE DEDENT else : NEW_LINE INDENT print " Both ▁ are ▁ equal " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 3 NEW_LINE b = 5 NEW_LINE c = 2 NEW_LINE d = 4 NEW_LINE cls . findGreater ( a , b ) NEW_LINE cls . findGreater ( c , d ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def bitsAreInAltPatrnInGivenTRange ( cls , n , l , r ) : NEW_LINE INDENT num = int ( ) NEW_LINE prev = int ( ) NEW_LINE curr = int ( ) NEW_LINE num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE i = 1 NEW_LINE while i <= ( r - l ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if curr == prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if cls . bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . IOException NEW_LINE import java . util . Scanner NEW_LINE class eugene ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE k = sc . nextInt ( ) NEW_LINE arr = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT res = StringBuffer ( ) NEW_LINE o = 0 NEW_LINE e = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < k : NEW_LINE INDENT if ( r - l + 1 ) % 2 == 1 : NEW_LINE INDENT res . append ( "0 \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( r - l + 1 ) / 2 <= o and ( r - l + 1 ) / 2 <= e : NEW_LINE INDENT res . append ( "1 \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( "0 \n " ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print res , NEW_LINE sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE eugene . main ( sys . argv ) NEW_LINE DEDENT







import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE k = sc . nextInt ( ) NEW_LINE x = sc . nextLong ( ) NEW_LINE y = sc . nextLong ( ) NEW_LINE sum = 0 NEW_LINE if n > k : NEW_LINE INDENT sum += x * k NEW_LINE sum += y * ( n - k ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += x * n NEW_LINE DEDENT print sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while sc . hasNext ( ) : NEW_LINE INDENT if x == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def count ( cls , num ) : NEW_LINE INDENT sum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT sum += num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE k = int ( ) NEW_LINE i = 1 NEW_LINE mo = 19 NEW_LINE k = in_ . nextInt ( ) NEW_LINE while i != k : NEW_LINE INDENT mo += 1 NEW_LINE if 10 == count ( mo ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print mo NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ None ] * MAX NEW_LINE @ classmethod NEW_LINE def sieve ( cls ) : NEW_LINE INDENT Arrays . fill ( cls . prime , True ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if cls . prime [ p ] == True : NEW_LINE INDENT while i < MAX : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def printPrimeQuad ( cls , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n - 7 : NEW_LINE INDENT if cls . prime [ i ] and cls . prime [ i + 2 ] and cls . prime [ i + 6 ] and cls . prime [ i + 8 ] : NEW_LINE INDENT print i + " ▁ " + ( i + 2 ) + " ▁ " + ( i + 6 ) + " ▁ " + ( i + 8 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 20 NEW_LINE cls . sieve ( ) NEW_LINE cls . printPrimeQuad ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 1000 NEW_LINE @ classmethod NEW_LINE def maxSubsequenceSubstring ( cls , x , y , n , m ) : NEW_LINE INDENT dp = [ None ] * MAX NEW_LINE i = 0 NEW_LINE while i <= m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= m : NEW_LINE INDENT while j <= n : NEW_LINE INDENT if x [ j - 1 ] == y [ i - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 1 NEW_LINE while i <= m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = " ABCD " . toCharArray ( ) NEW_LINE y = " BACDBDCD " . toCharArray ( ) NEW_LINE n = x . length NEW_LINE m = y . length NEW_LINE print cls . maxSubsequenceSubstring ( x , y , n , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT MAX = 1000 NEW_LINE sequence = [ None ] * MAX NEW_LINE @ classmethod NEW_LINE def vanEckSequence ( cls ) : NEW_LINE INDENT i = 0 NEW_LINE while i < MAX - 1 : NEW_LINE INDENT cls . sequence [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < MAX - 1 : NEW_LINE INDENT while j >= 0 : NEW_LINE INDENT if cls . sequence [ j ] == sequence [ i ] : NEW_LINE INDENT cls . sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def getNthTerm ( cls , n ) : NEW_LINE INDENT return cls . sequence [ n ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . vanEckSequence ( ) NEW_LINE n = 6 NEW_LINE print cls . getNthTerm ( n ) NEW_LINE n = 100 NEW_LINE print cls . getNthTerm ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 100000 NEW_LINE sequence = [ None ] * MAX + 1 NEW_LINE @ classmethod NEW_LINE def vanEckSequence ( cls ) : NEW_LINE INDENT i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT cls . sequence [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT while j >= 0 : NEW_LINE INDENT if cls . sequence [ j ] == sequence [ i ] : NEW_LINE INDENT cls . sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def getCount ( cls , n ) : NEW_LINE INDENT count = 1 NEW_LINE i = n - 1 NEW_LINE while cls . sequence [ i + 1 ] != 0 : NEW_LINE INDENT count += 1 NEW_LINE i = i - sequence [ i + 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print cls . getCount ( n ) NEW_LINE n = 11 NEW_LINE print cls . getCount ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 100000 NEW_LINE sequence = [ None ] * MAX + 1 NEW_LINE @ classmethod NEW_LINE def vanEckSequence ( cls ) : NEW_LINE INDENT i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT cls . sequence [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT while j >= 0 : NEW_LINE INDENT if cls . sequence [ j ] == sequence [ i ] : NEW_LINE INDENT cls . sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def getCount ( cls , n ) : NEW_LINE INDENT nthTerm = cls . sequence [ n - 1 ] NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if cls . sequence [ i ] == nthTerm : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print cls . getCount ( n ) NEW_LINE n = 11 NEW_LINE print cls . getCount ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return cls . __gcd ( a - b , b ) NEW_LINE DEDENT return cls . __gcd ( a , b - a ) NEW_LINE DEDENT @ classmethod NEW_LINE def findValue ( cls , x , y , z ) : NEW_LINE INDENT g = cls . __gcd ( y , z ) NEW_LINE return ( x * g ) / cls . __gcd ( x , g ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 30 NEW_LINE y = 40 NEW_LINE z = 400 NEW_LINE print cls . findValue ( x , y , z , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE c1 = sc . next ( ) NEW_LINE c2 = sc . next ( ) NEW_LINE if c1 . charAt ( 0 ) == len ( c2 . charAt ( c2 ) - 1 ) and c2 . charAt ( 0 ) == len ( c1 . charAt ( c1 ) - 1 ) and c1 . charAt ( 1 ) == c2 . charAt ( 1 ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def negProdSubArr ( cls , arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( positive * negative ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = arr . length NEW_LINE print cls . negProdSubArr ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def negProdSubArr ( cls , arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( positive * negative ) NEW_LINE DEDENT @ classmethod NEW_LINE def posProdSubArr ( cls , arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 NEW_LINE cntNeg = cls . negProdSubArr ( arr , n ) NEW_LINE return ( total - cntNeg ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = arr . length NEW_LINE print cls . posProdSubArr ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minRemove ( cls , arr , n ) : NEW_LINE INDENT LIS = [ None ] * n NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT while j < i : NEW_LINE INDENT if arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) : NEW_LINE INDENT LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT len = Math . max ( len , LIS [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return n - len NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = arr . length NEW_LINE print cls . minRemove ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . math . BigInteger NEW_LINE class p056 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p056 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT max = 0 NEW_LINE a = 1 NEW_LINE while a < 100 : NEW_LINE INDENT while b < 100 : NEW_LINE INDENT max = Math . max ( digitSum ( pow ) , max ) NEW_LINE b += 1 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT return Integer . toString ( max ) NEW_LINE DEDENT @ classmethod NEW_LINE def digitSum ( cls , n ) : NEW_LINE INDENT sum = 0 NEW_LINE s = n . __str__ ( ) NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p056 . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countWindowDistinct ( cls , win , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT while j < i : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == i : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return dist_count NEW_LINE DEDENT @ classmethod NEW_LINE def countDistinct ( cls , arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - k : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE cls . countDistinct ( arr , arr . length , k ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def evenNumSubstring ( cls , str_ ) : NEW_LINE INDENT len = len ( str_ ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < len : NEW_LINE INDENT if temp % 2 == 0 : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = "1234" NEW_LINE print cls . evenNumSubstring ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class solution ( object ) : NEW_LINE INDENT max = 4 NEW_LINE @ classmethod NEW_LINE def countWays ( cls , index , cnt , dp , n , m , k ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE return dp [ index ] [ cnt ] = ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 2 NEW_LINE dp = [ None ] * n + 1 NEW_LINE i = 0 NEW_LINE while i < n + 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print m * cls . countWays ( 1 , 0 , dp , n , m , k ) NEW_LINE DEDENT DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class PashaAndHamsters ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT is_ = InputStreamReader ( System . in_ ) NEW_LINE br = BufferedReader ( is_ ) NEW_LINE dims = br . readLine ( ) . split ( " ▁ " ) NEW_LINE total = Integer . parseInt ( dims [ 0 ] ) NEW_LINE at = Integer . parseInt ( dims [ 1 ] ) NEW_LINE pt = Integer . parseInt ( dims [ 2 ] ) NEW_LINE vals = [ None ] * total NEW_LINE as_ = br . readLine ( ) . split ( " ▁ " ) NEW_LINE i = 0 NEW_LINE while i < as_ . length : NEW_LINE INDENT vals [ x - 1 ] = True NEW_LINE i += 1 NEW_LINE DEDENT sb = StringBuffer ( ) NEW_LINE i = 0 NEW_LINE while i < total : NEW_LINE INDENT sb . append ( ( "1" if vals [ i ] else "2" ) + " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print sb NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE PashaAndHamsters . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def reverseArray ( cls , arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n / 2 : NEW_LINE INDENT swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def swap ( cls , arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE return arr NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = arr . length NEW_LINE cls . reverseArray ( arr , n ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT print arr [ i ] + " ▁ " , NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printSeriesSum ( cls , N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while cnt < N : NEW_LINE INDENT if flag == True : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * 3 / 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 8 NEW_LINE cls . printSeriesSum ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE line = str ( ) NEW_LINE T = sc . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < T : NEW_LINE INDENT h /= gcd NEW_LINE w /= gcd NEW_LINE if h == w : NEW_LINE INDENT print "1 ▁ 0" NEW_LINE DEDENT elif h % 2 == 0 or w % 2 == 0 : NEW_LINE INDENT print "1 ▁ 1" NEW_LINE DEDENT else : NEW_LINE INDENT a = ( h * w ) / 2 + 1 NEW_LINE b = ( h * w ) / 2 NEW_LINE print a + " ▁ " + b NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def gcd ( cls , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return cls . gcd ( b , a % b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def getMaxLength ( cls , arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while start < n and arr [ start ] == 1 : NEW_LINE INDENT preCnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while end >= 0 and arr [ end ] == 1 : NEW_LINE INDENT suffCnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE result = 0 NEW_LINE i = start NEW_LINE while i <= end : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT midCnt += 1 NEW_LINE result = Math . max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Math . max ( result , preCnt + suffCnt ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ None ] * NEW_LINE n = arr . length NEW_LINE print cls . getMaxLength ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = Scanner ( System . in_ ) NEW_LINE d = s . nextInt ( ) NEW_LINE n = s . nextInt ( ) NEW_LINE temp = [ None ] * d NEW_LINE a = [ None ] * n NEW_LINE b = [ None ] * n NEW_LINE c = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < d : NEW_LINE INDENT temp [ i ] = s . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = s . nextInt ( ) NEW_LINE b [ i ] = s . nextInt ( ) NEW_LINE c [ i ] = s . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT dp = [ None ] * d NEW_LINE i = 0 NEW_LINE while i < d : NEW_LINE INDENT while j < n : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] <= temp [ 0 ] and b [ i ] >= temp [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < d : NEW_LINE INDENT while j < n : NEW_LINE INDENT if a [ j ] <= temp [ i ] and b [ j ] >= temp [ i ] : NEW_LINE INDENT while k < n : NEW_LINE INDENT if dp [ i - 1 ] [ k ] < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( c [ j ] - c [ k ] ) ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT ans = Math . max ( ans , dp [ d - 1 ] [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sqroot ( cls , s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE i = ( ( s ) ) NEW_LINE while i > 0 : NEW_LINE INDENT while j < i : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if pSq > 0 : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT d = s - pSq NEW_LINE P = d / ( 2.0 * N ) NEW_LINE A = N + P NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) NEW_LINE return sqrt_of_s NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = 9.2345 NEW_LINE sqroot_of_num = cls . sqroot ( num ) NEW_LINE print " Square ▁ root ▁ of ▁ " + num + " ▁ = ▁ " + Math . round ( sqroot_of_num * 100000.0 ) / 100000.0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT INF = 100.0 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if r == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < n : NEW_LINE INDENT while j < xr + 20 : NEW_LINE INDENT field [ j ] = Math . max ( field [ j ] , h ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < field . length : NEW_LINE INDENT minTime = Math . min ( minTime , crossTime ( i - 20 , field [ i ] , r ) ) NEW_LINE minTime = Math . min ( minTime , crossTime ( i + 1 - 20 , field [ i ] , r ) ) NEW_LINE i += 1 NEW_LINE DEDENT print minTime NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def crossTime ( cls , x , y , r ) : NEW_LINE INDENT d = ( Math . pow ( - 2 * ( y + r ) , 2 ) ) - 4 * ( x * x + y * y + 2 * y * r ) NEW_LINE if d <= 0 : NEW_LINE INDENT return cls . INF NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def printHeight ( cls , field ) : NEW_LINE INDENT i = 0 NEW_LINE while i < field . length : NEW_LINE INDENT print ( i - 20 ) + " - " + ( ( i - 20 ) + 1 ) + " : ▁ " + field [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE num = int ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT while read ( ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def read ( cls ) : NEW_LINE INDENT if cls . sc . hasNextInt ( ) : NEW_LINE INDENT cls . num = sc . nextInt ( ) NEW_LINE DEDENT if cls . num == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls ) : NEW_LINE INDENT table = [ 0 , 1 , 2 , 3 , 5 , 7 , 8 , 9 ] NEW_LINE s = Integer . toOctalString ( cls . num ) NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT print table [ num2 ] , NEW_LINE i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT







import java . util . ArrayList NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE n = input . nextInt ( ) NEW_LINE k = input . nextInt ( ) NEW_LINE x = input . nextInt ( ) NEW_LINE arr = ArrayList ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT arr . add ( input . nextInt ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT i = len ( arr ) - k NEW_LINE while i < len ( arr ) : NEW_LINE INDENT arr . set ( i , x ) NEW_LINE i += 1 NEW_LINE DEDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT sum += arr . get ( i ) NEW_LINE i += 1 NEW_LINE DEDENT print sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . BufferedWriter NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . OutputStreamWriter NEW_LINE class PA_TrickySum ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT reader = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE writer = BufferedWriter ( OutputStreamWriter ( System . out ) ) NEW_LINE t = Integer . parseInt ( reader . readLine ( ) ) NEW_LINE sum = 0 NEW_LINE valu = 0 NEW_LINE result = 0 NEW_LINE p = 0 NEW_LINE while p < t : NEW_LINE INDENT sum = n1 * ( n1 + 1 ) / 2 NEW_LINE while i < n1 + 1 : NEW_LINE INDENT valu += i NEW_LINE i = ( i ) * 2 NEW_LINE DEDENT result = sum - ( valu * 2 ) NEW_LINE writer . write ( " " + result ) NEW_LINE writer . newLine ( ) NEW_LINE valu = 0 NEW_LINE p += 1 NEW_LINE DEDENT writer . newLine ( ) NEW_LINE writer . flush ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE PA_TrickySum . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT bin = [ "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" ] NEW_LINE @ classmethod NEW_LINE def maxFreq ( cls , s ) : NEW_LINE INDENT binary = " " NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT binary += bin [ s . charAt ( i ) - '0' ] NEW_LINE i += 1 NEW_LINE DEDENT binary = binary . substring ( 0 , len ( binary ) - 1 ) NEW_LINE count = 1 NEW_LINE prev = - 1 NEW_LINE i = int ( ) NEW_LINE j = 0 NEW_LINE while i >= 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT octal = "13" NEW_LINE print cls . maxFreq ( octal ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isVowel ( cls , c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT @ classmethod NEW_LINE def encryptString ( cls , s , n , k ) : NEW_LINE INDENT cv = [ None ] * n NEW_LINE cc = [ None ] * n NEW_LINE if cls . isVowel ( s [ 0 ] ) : NEW_LINE INDENT cv [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + ( 1 if isVowel ( s [ i ] ) == True else 0 ) NEW_LINE cc [ i ] = cc [ i - 1 ] + ( 0 if isVowel ( s [ i ] ) == True else 1 ) NEW_LINE i += 1 NEW_LINE DEDENT ans = " " NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += String . valueOf ( prod ) NEW_LINE i = k NEW_LINE while i < s . length : NEW_LINE INDENT prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) NEW_LINE ans += String . valueOf ( prod ) NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print cls . encryptString ( s . toCharArray ( , , n , k ) + " \n " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def harmonicMean ( cls , arr , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE frequency_sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + ( freq [ i ] ) / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ( frequency_sum / sum ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = num . length NEW_LINE print String . format ( " % .4f " , cls . harmonicMean ( num , freq , n ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class Solution ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return cls . __gcd ( a - b , b ) NEW_LINE DEDENT return cls . __gcd ( a , b - a ) NEW_LINE DEDENT @ classmethod NEW_LINE def lcm ( cls , a , b ) : NEW_LINE INDENT return ( a / cls . __gcd ( a , b ) * b ) NEW_LINE DEDENT @ classmethod NEW_LINE def getMinValue ( cls , c ) : NEW_LINE INDENT ans = Integer . MAX_VALUE NEW_LINE i = 1 NEW_LINE while i <= Math . sqrt ( c ) : NEW_LINE INDENT if c % i == 0 and cls . lcm ( i , c / i ) == c : NEW_LINE INDENT ans = Math . min ( ans , Math . max ( i , c / i ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT c = 6 NEW_LINE print cls . getMinValue ( c ) NEW_LINE DEDENT DEDENT



class Fibonacci ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findIndex ( cls , n ) : NEW_LINE INDENT fibo = 2.078087 F * ( Math . log ( n ) ) + 1.672276 F NEW_LINE return Math . round ( fibo ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 21 NEW_LINE print cls . findIndex ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Fibonacci . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def normalSieve ( cls , n ) : NEW_LINE INDENT prime = [ None ] * n / 2 NEW_LINE Arrays . fill ( prime , False ) NEW_LINE i = 3 NEW_LINE while i * i < n : NEW_LINE INDENT if prime [ i / 2 ] == False : NEW_LINE INDENT while j < n : NEW_LINE INDENT j += i * 2 NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT print "2 ▁ " , NEW_LINE i = 3 NEW_LINE while i < n : NEW_LINE INDENT i += 2 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 100 NEW_LINE cls . normalSieve ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Word ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE word = in_ . next ( ) NEW_LINE uppercase = 0 NEW_LINE lowercase = 0 NEW_LINE i = 0 NEW_LINE while i < len ( word ) : NEW_LINE INDENT if Character . isUpperCase ( ch ) : NEW_LINE INDENT uppercase += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lowercase += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if uppercase > lowercase : NEW_LINE INDENT print word . toUpperCase ( ) NEW_LINE DEDENT elif lowercase > uppercase : NEW_LINE INDENT print word . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print word . lower ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Word . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isSubArray ( cls , A , B , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if A [ i ] == B [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE if j == m : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arr ) : NEW_LINE INDENT A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] NEW_LINE n = A . length NEW_LINE B = [ 3 , 0 , 5 , 1 ] NEW_LINE m = B . length NEW_LINE if cls . isSubArray ( A , B , n , m ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def calculateSum ( cls , n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE k = 3 NEW_LINE print cls . calculateSum ( n , k , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) . useDelimiter ( " [ , \n ] " ) NEW_LINE sum = 0 NEW_LINE n = 0 NEW_LINE total = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT sum += value * amount NEW_LINE total += amount NEW_LINE n += 1 NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print sum NEW_LINE print Math . round ( ( total ) / n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




import java . math . BigInteger NEW_LINE class p013 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p013 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = BigInteger . ZERO NEW_LINE for num in NUMBERS : NEW_LINE INDENT sum = sum . add ( BigInteger ( num ) ) NEW_LINE DEDENT return sum . __str__ ( ) . substring ( 0 , 10 ) NEW_LINE DEDENT NUMBERS = [ "37107287533902102798797998220837590246510135740250" , "46376937677490009712648124896970078050417018260538" , "74324986199524741059474233309513058123726617309629" , "91942213363574161572522430563301811072406154908250" , "23067588207539346171171980310421047513778063246676" , "89261670696623633820136378418383684178734361726757" , "28112879812849979408065481931592621691275889832738" , "44274228917432520321923589422876796487670272189318" , "47451445736001306439091167216856844588711603153276" , "70386486105843025439939619828917593665686757934951" , "62176457141856560629502157223196586755079324193331" , "64906352462741904929101432445813822663347944758178" , "92575867718337217661963751590579239728245598838407" , "58203565325359399008402633568948830189458628227828" , "80181199384826282014278194139940567587151170094390" , "35398664372827112653829987240784473053190104293586" , "86515506006295864861532075273371959191420517255829" , "71693888707715466499115593487603532921714970056938" , "54370070576826684624621495650076471787294438377604" , "53282654108756828443191190634694037855217779295145" , "36123272525000296071075082563815656710885258350721" , "45876576172410976447339110607218265236877223636045" , "17423706905851860660448207621209813287860733969412" , "81142660418086830619328460811191061556940512689692" , "51934325451728388641918047049293215058642563049483" , "62467221648435076201727918039944693004732956340691" , "15732444386908125794514089057706229429197107928209" , "55037687525678773091862540744969844508330393682126" , "18336384825330154686196124348767681297534375946515" , "80386287592878490201521685554828717201219257766954" , "78182833757993103614740356856449095527097864797581" , "16726320100436897842553539920931837441497806860984" , "48403098129077791799088218795327364475675590848030" , "87086987551392711854517078544161852424320693150332" , "59959406895756536782107074926966537676326235447210" , "69793950679652694742597709739166693763042633987085" , "41052684708299085211399427365734116182760315001271" , "65378607361501080857009149939512557028198746004375" , "35829035317434717326932123578154982629742552737307" , "94953759765105305946966067683156574377167401875275" , "88902802571733229619176668713819931811048770190271" , "25267680276078003013678680992525463401061632866526" , "36270218540497705585629946580636237993140746255962" , "24074486908231174977792365466257246923322810917141" , "91430288197103288597806669760892938638285025333403" , "34413065578016127815921815005561868836468420090470" , "23053081172816430487623791969842487255036638784583" , "11487696932154902810424020138335124462181441773470" , "63783299490636259666498587618221225225512486764533" , "67720186971698544312419572409913959008952310058822" , "95548255300263520781532296796249481641953868218774" , "76085327132285723110424803456124867697064507995236" , "37774242535411291684276865538926205024910326572967" , "23701913275725675285653248258265463092207058596522" , "29798860272258331913126375147341994889534765745501" , "18495701454879288984856827726077713721403798879715" , "38298203783031473527721580348144513491373226651381" , "34829543829199918180278916522431027392251122869539" , "40957953066405232632538044100059654939159879593635" , "29746152185502371307642255121183693803580388584903" , "41698116222072977186158236678424689157993532961922" , "62467957194401269043877107275048102390895523597457" , "23189706772547915061505504953922979530901129967519" , "86188088225875314529584099251203829009407770775672" , "11306739708304724483816533873502340845647058077308" , "82959174767140363198008187129011875491310547126581" , "97623331044818386269515456334926366572897563400500" , "42846280183517070527831839425882145521227251250327" , "55121603546981200581762165212827652751691296897789" , "32238195734329339946437501907836945765883352399886" , "75506164965184775180738168837861091527357929701337" , "62177842752192623401942399639168044983993173312731" , "32924185707147349566916674687634660915035914677504" , "99518671430235219628894890102423325116913619626622" , "73267460800591547471830798392868535206946944540724" , "76841822524674417161514036427982273348055556214818" , "97142617910342598647204516893989422179826088076852" , "87783646182799346313767754307809363333018982642090" , "10848802521674670883215120185883543223812876952786" , "71329612474782464538636993009049310363619763878039" , "62184073572399794223406235393808339651327408011116" , "66627891981488087797941876876144230030984490851411" , "60661826293682836764744779239180335110989069790714" , "85786944089552990653640447425576083659976645795096" , "66024396409905389607120198219976047599490197230297" , "64913982680032973156037120041377903785566085089252" , "16730939319872750275468906903707539413042652315011" , "94809377245048795150954100921645863754710598436791" , "78639167021187492431995700641917969777599028300699" , "15368713711936614952811305876380278410754449733078" , "40789923115535562561142322423255033685442488917353" , "44889911501440648020369068063960672322193204149535" , "41503128880339536053299340368006977710650566631954" , "81234880673210146739058568557934581403627822703280" , "82616570773948327592232845941706525094512325230608" , "22918802058777319719839450180888072429661980811197" , "77158542502016545090413245809786882778948721859617" , "72107838435069186155435662884062257473692284509516" , "20849603980134001723930671666823555245252804609722" , "53503534226472524250874054075591789781264330331690" ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p013 . main ( sys . argv ) NEW_LINE DEDENT


import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . math . BigInteger NEW_LINE class Main ( object ) : NEW_LINE INDENT BIG_NUM = 2000000000 NEW_LINE MOD = 1000000007 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE try : NEW_LINE INDENT print ans NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT






class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT hex_map = "0123456789abcdef " NEW_LINE if num == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT res = " " NEW_LINE while num != 0 and len ( res ) < 8 : NEW_LINE INDENT res = hex_map . charAt ( num & 15 ) + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . toHex ( n ) NEW_LINE print out NEW_LINE DEDENT DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE n = scan . nextInt ( ) NEW_LINE count = scan . nextInt ( ) NEW_LINE printIsland ( n , count ) NEW_LINE DEDENT @ classmethod NEW_LINE def printIsland ( cls , n , count ) : NEW_LINE INDENT a = ( n + 1 ) / 2 NEW_LINE b = n / 2 NEW_LINE max = a * a + b * b NEW_LINE if count > max : NEW_LINE INDENT print " NO " NEW_LINE return NEW_LINE DEDENT print " YES " NEW_LINE sb = StringBuilder ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT if ( i + j ) % 2 == 0 and count > 0 : NEW_LINE INDENT sb . append ( ' L ' ) NEW_LINE count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT sb . append ( ' S ' ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT sb . append ( " \n " ) NEW_LINE i += 1 NEW_LINE DEDENT print sb NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longestString ( cls , str1 , str2 ) : NEW_LINE INDENT count1 = [ None ] * 26 NEW_LINE count2 = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ str1 . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ str2 . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = " " NEW_LINE i = 0 NEW_LINE while i < 26 : NEW_LINE INDENT while j <= Math . min ( count1 [ i ] , count2 [ i ] ) : NEW_LINE INDENT result += ( ( ' a ' + i ) ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str1 = " geeks " NEW_LINE str2 = " cake " NEW_LINE cls . longestString ( str1 , str2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def msb ( cls , x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( x >> ( ret + 1 ) ) != 0 : NEW_LINE return ret NEW_LINE DEDENT @ classmethod NEW_LINE def xorRange ( cls , l , r ) : NEW_LINE INDENT max_bit = cls . msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i <= max_bit : NEW_LINE INDENT if ( l / mul ) * mul == ( r / mul ) * mul : NEW_LINE INDENT if ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE continue NEW_LINE DEDENT if ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if odd_c != 0 : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE i += 1 NEW_LINE DEDENT zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 NEW_LINE if l % 2 == 1 and r % 2 == 1 : NEW_LINE INDENT zero_bit_cnt += 1 NEW_LINE DEDENT if zero_bit_cnt % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT l = 1 NEW_LINE r = 4 NEW_LINE print cls . xorRange ( l , r , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def q1 ( cls , s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print " Yes " NEW_LINE return NEW_LINE DEDENT if s . charAt ( i ) == ' a ' : NEW_LINE INDENT cls . q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def q2 ( cls , s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print " No " NEW_LINE return NEW_LINE DEDENT if s . charAt ( i ) == ' a ' : NEW_LINE INDENT cls . q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cls . q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def q3 ( cls , s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print " Yes " NEW_LINE return NEW_LINE DEDENT if s . charAt ( i ) == ' a ' : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cls . q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def q4 ( cls , s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print " No " NEW_LINE return NEW_LINE DEDENT if s . charAt ( i ) == ' a ' : NEW_LINE INDENT cls . q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cls . q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def q0 ( cls , s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print " No " NEW_LINE return NEW_LINE DEDENT if s . charAt ( i ) == ' a ' : NEW_LINE INDENT cls . q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cls . q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " abbaabb " NEW_LINE cls . q0 ( s , 0 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findTime ( cls , T , K ) : NEW_LINE INDENT minutes = ( ( T . charAt ( 0 ) - '0' ) * 10 + T . charAt ( 1 ) - '0' ) * 60 + ( ( T . charAt ( 3 ) - '0' ) * 10 + T . charAt ( 4 ) - '0' ) NEW_LINE minutes += K NEW_LINE hour = ( minutes / 60 ) % 24 NEW_LINE min = minutes % 60 NEW_LINE if hour < 10 : NEW_LINE INDENT print "0" + hour + " : " , NEW_LINE DEDENT else : NEW_LINE INDENT print hour + " : " , NEW_LINE DEDENT if min < 10 : NEW_LINE INDENT print "0" + min NEW_LINE DEDENT else : NEW_LINE INDENT print min NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT T = "21:39" NEW_LINE K = 43 NEW_LINE cls . findTime ( T , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def min ( cls , x , y , z ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return x if ( x < z ) else z NEW_LINE DEDENT else : NEW_LINE INDENT return y if ( y < z ) else z NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def minCost ( cls , cost , m , n ) : NEW_LINE INDENT if n < 0 or m < 0 : NEW_LINE INDENT return Integer . MAX_VALUE NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + cls . min ( cls . minCost ( cost , m - 1 , n - 1 ) , cls . minCost ( cost , m - 1 , n ) , cls . minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cost = [ ] NEW_LINE print cls . minCost ( cost , 2 , 2 , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countNumbersWith4 ( cls , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = ( Math . log10 ( n ) ) NEW_LINE a = [ None ] * d + 2 NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while i <= d : NEW_LINE INDENT i += 1 NEW_LINE DEDENT p = ( Math . ceil ( Math . pow ( 10 , d ) ) ) NEW_LINE msd = n / p NEW_LINE if msd == 4 : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if msd > 4 : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + cls . countNumbersWith4 ( n % p ) NEW_LINE DEDENT return ( msd ) * a [ d ] + cls . countNumbersWith4 ( n % p ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 328 NEW_LINE print " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + n + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ " + cls . countNumbersWith4 ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class _250B ( Runnable ) : NEW_LINE INDENT in_ = BufferedReader ( ) NEW_LINE def solve ( self ) : NEW_LINE INDENT sb = StringBuilder ( ) NEW_LINE i = 0 NEW_LINE n = nextInt ( ) NEW_LINE while i < n : NEW_LINE INDENT if s [ k ] . isEmpty ( ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if s [ m ] . isEmpty ( ) : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT while j <= m : NEW_LINE INDENT if s [ j ] . isEmpty ( ) : NEW_LINE INDENT while l <= lim : NEW_LINE INDENT sb . append ( "0000" ) NEW_LINE if l < lim : NEW_LINE INDENT sb . append ( ' : ' ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while l < 4 : NEW_LINE INDENT sb . append ( '0' ) NEW_LINE l += 1 NEW_LINE DEDENT sb . append ( s [ j ] ) NEW_LINE DEDENT if j < m : NEW_LINE INDENT sb . append ( ' : ' ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT sb . append ( ' \n ' ) NEW_LINE i += 1 NEW_LINE DEDENT return sb NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT _250B ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT self . in_ = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE print self . solve ( , ) NEW_LINE self . in_ . close ( ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT System . exit ( 0 ) NEW_LINE DEDENT DEDENT def nextToken ( self ) : NEW_LINE INDENT return self . in_ . readLine ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . nextToken ( ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE _250B . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPrime ( cls , n ) : NEW_LINE INDENT flag = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if flag == 1 else False ) NEW_LINE DEDENT @ classmethod NEW_LINE def isPerfectSquare ( cls , x ) : NEW_LINE INDENT sr = Math . sqrt ( x ) NEW_LINE return ( ( sr - Math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT @ classmethod NEW_LINE def countInterestingPrimes ( cls , n ) : NEW_LINE INDENT answer = 0 NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT if cls . isPrime ( i ) : NEW_LINE INDENT while j * j * j * j <= i : NEW_LINE INDENT if cls . isPerfectSquare ( i - j * j * j * j ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 10 NEW_LINE print cls . countInterestingPrimes ( N , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findNum ( cls , div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = div . length NEW_LINE print cls . findNum ( div , rem , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class ShortestKingPath ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE s = in_ . next ( ) NEW_LINE s1 = in_ . next ( ) NEW_LINE c = s . toCharArray ( ) NEW_LINE c1 = s1 . toCharArray ( ) NEW_LINE diff = c1 [ 0 ] - c [ 0 ] NEW_LINE dif = c1 [ 1 ] - c [ 1 ] NEW_LINE n = Math . abs ( diff ) NEW_LINE m = Math . abs ( dif ) NEW_LINE ans = " " NEW_LINE while diff != 0 or dif != 0 : NEW_LINE INDENT if diff > 0 : NEW_LINE INDENT ans += " R " NEW_LINE diff -= 1 NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT ans += " L " NEW_LINE diff += 1 NEW_LINE DEDENT if dif > 0 : NEW_LINE INDENT ans += " U " NEW_LINE dif -= 1 NEW_LINE DEDENT if dif < 0 : NEW_LINE INDENT ans += " D " NEW_LINE dif += 1 NEW_LINE DEDENT ans += " \n " NEW_LINE DEDENT print Math . max ( n , m ) NEW_LINE print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE ShortestKingPath . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Scanner NEW_LINE class InterceptedMessage ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE totalFirstFiles = scanner . nextInt ( ) NEW_LINE totalSecondFiles = scanner . nextInt ( ) NEW_LINE firstFiles = [ None ] * totalFirstFiles NEW_LINE secondFiles = [ None ] * totalSecondFiles NEW_LINE i = 0 NEW_LINE while i < totalFirstFiles : NEW_LINE INDENT firstFiles [ i ] = scanner . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < totalSecondFiles : NEW_LINE INDENT secondFiles [ i ] = scanner . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT print interceptedMessage ( firstFiles , secondFiles ) NEW_LINE DEDENT @ classmethod NEW_LINE def interceptedMessage ( cls , firstFiles , secondFiles ) : NEW_LINE INDENT maxFiles = 0 NEW_LINE firstPointer = 0 NEW_LINE secondPointer = 0 NEW_LINE hasFinished = False NEW_LINE tempFirstNumber = 0 NEW_LINE tempSecondNumber = 0 NEW_LINE while not hasFinished : NEW_LINE INDENT if firstPointer == 0 and secondPointer == 0 : NEW_LINE INDENT tempFirstNumber += firstFiles [ firstPointer ] NEW_LINE tempSecondNumber += secondFiles [ secondPointer ] NEW_LINE DEDENT if tempFirstNumber == tempSecondNumber : NEW_LINE INDENT maxFiles += 1 NEW_LINE firstPointer += 1 NEW_LINE secondPointer += 1 NEW_LINE if firstPointer > firstFiles . length - 1 and secondPointer > secondFiles . length - 1 : NEW_LINE INDENT break NEW_LINE DEDENT tempFirstNumber = firstFiles [ firstPointer ] NEW_LINE tempSecondNumber = secondFiles [ secondPointer ] NEW_LINE DEDENT elif tempFirstNumber < tempSecondNumber : NEW_LINE INDENT firstPointer += 1 NEW_LINE tempFirstNumber += firstFiles [ firstPointer ] NEW_LINE DEDENT else : NEW_LINE INDENT secondPointer += 1 NEW_LINE tempSecondNumber += secondFiles [ secondPointer ] NEW_LINE DEDENT DEDENT return maxFiles NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE InterceptedMessage . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if op == " ? " : NEW_LINE INDENT break NEW_LINE DEDENT if op == " + " : NEW_LINE INDENT print a + b NEW_LINE DEDENT if op == " - " : NEW_LINE INDENT print a - b NEW_LINE DEDENT if op == " * " : NEW_LINE INDENT print a * b NEW_LINE DEDENT if op == " / " : NEW_LINE INDENT print a / b NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find_Area ( cls , a ) : NEW_LINE INDENT R = a * ( ( 2.0 - Math . sqrt ( 2 ) ) ) NEW_LINE area = ( ( ( 3.14 * R * R ) / 2.0 ) ) NEW_LINE return area NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 4 NEW_LINE print " ▁ Area ▁ of ▁ semicircle ▁ = ▁ " + String . format ( " % .4f " , cls . find_Area ( a ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findQuadruples ( cls , a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 0 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = a . length NEW_LINE print cls . findQuadruples ( a , b , c , d , x , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class test223 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE j = 0 NEW_LINE while j < t : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT print "2" NEW_LINE DEDENT elif x == 2 : NEW_LINE INDENT print "1" NEW_LINE DEDENT elif x % 3 == 0 : NEW_LINE INDENT print x / 3 NEW_LINE DEDENT else : NEW_LINE INDENT print x / 3 + 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT in_ . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE test223 . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sumOfSubstrings ( cls , num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ None ] * n NEW_LINE sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' NEW_LINE res = sumofdigit [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = "1234" NEW_LINE print cls . sumOfSubstrings ( num ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class p071 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p071 ( ) . run ( ) NEW_LINE DEDENT LIMIT = 1000000 NEW_LINE def run ( self ) : NEW_LINE INDENT maxN = 0 NEW_LINE maxD = 1 NEW_LINE d = 1 NEW_LINE while d <= LIMIT : NEW_LINE INDENT if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if ( n ) * maxD > ( maxN ) * d : NEW_LINE INDENT maxN = n NEW_LINE maxD = d NEW_LINE DEDENT d += 1 NEW_LINE DEDENT return Integer . toString ( maxN ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p071 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT c = [ None ] * 100 NEW_LINE @ classmethod NEW_LINE def coef ( cls , n ) : NEW_LINE INDENT cls . c [ 0 ] = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT cls . c [ 1 + i ] = 1 NEW_LINE while j > 0 : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def isPrime ( cls , n ) : NEW_LINE INDENT cls . coef ( n ) NEW_LINE cls . c [ 0 ] += 1 NEW_LINE cls . c [ n ] -= 1 NEW_LINE i = n NEW_LINE __i_0 = i NEW_LINE i -= 1 NEW_LINE while ( __i_0 ) > 0 and cls . c [ i ] % n == 0 : NEW_LINE INDENT pass NEW_LINE DEDENT return i < 0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 37 NEW_LINE if cls . isPrime ( n ) : NEW_LINE INDENT print " Prime " NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ Prime " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def count_greater ( cls , arr , n ) : NEW_LINE INDENT min = Integer . MAX_VALUE NEW_LINE counter = 0 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT if arr [ i ] <= min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = arr . length NEW_LINE print cls . count_greater ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT leer = Scanner ( System . in_ ) NEW_LINE casos = int ( ) NEW_LINE x = int ( ) NEW_LINE y = int ( ) NEW_LINE conta = 0 NEW_LINE cont = 0 NEW_LINE casos = leer . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < casos : NEW_LINE INDENT x = leer . nextInt ( ) NEW_LINE y = leer . nextInt ( ) NEW_LINE if x > 0 : NEW_LINE INDENT conta += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cont += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if conta > 1 and cont > 1 : NEW_LINE INDENT print " No " NEW_LINE DEDENT else : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findUniquePair ( cls , arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) > 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] NEW_LINE n = a . length NEW_LINE cls . findUniquePair ( a , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . StringTokenizer NEW_LINE class ValeraX ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cs = CustomScanner ( ) NEW_LINE n = cs . nextInt ( ) NEW_LINE xch = ' \u0000' NEW_LINE nxch = ' \u0000' NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT xch = line . charAt ( 0 ) NEW_LINE nxch = line . charAt ( 1 ) NEW_LINE DEDENT if xch == nxch : NEW_LINE INDENT print " NO " NEW_LINE return NEW_LINE DEDENT while j < n : NEW_LINE INDENT if j == i or j == n - i - 1 : NEW_LINE INDENT if line . charAt ( j ) != xch : NEW_LINE INDENT print " NO " NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if line . charAt ( j ) != nxch : NEW_LINE INDENT print " NO " NEW_LINE return NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " YES " NEW_LINE DEDENT class CustomScanner ( object ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE st = StringTokenizer ( " " ) NEW_LINE def next ( self ) : NEW_LINE INDENT while not self . st . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def readArray ( self , n ) : NEW_LINE INDENT a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE ValeraX . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT doIt ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def doIt ( cls ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE while n != - 1 : NEW_LINE INDENT while i < n : NEW_LINE INDENT rad += Math . atan ( 1 / hyp ) NEW_LINE hyp = Math . sqrt ( hyp * hyp + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT print hyp * Math . cos ( rad ) NEW_LINE print hyp * Math . sin ( rad ) NEW_LINE n = sc . nextInt ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printKMissing ( cls , arr , n , k ) : NEW_LINE INDENT Arrays . sort ( arr ) NEW_LINE i = 0 NEW_LINE while i < n and arr [ i ] <= 0 : NEW_LINE count = 0 NEW_LINE curr = 1 NEW_LINE while count < k and i < n : NEW_LINE INDENT if arr [ i ] != curr : NEW_LINE INDENT print curr + " ▁ " , NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT curr += 1 NEW_LINE DEDENT while count < k : NEW_LINE INDENT print curr + " ▁ " , NEW_LINE curr += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 ] NEW_LINE n = arr . length NEW_LINE k = 3 NEW_LINE cls . printKMissing ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def checkIfStartsWithCapital ( cls , str_ ) : NEW_LINE INDENT if str_ . charAt ( 0 ) >= ' A ' and str_ . charAt ( 0 ) <= ' Z ' : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def check ( cls , str_ ) : NEW_LINE INDENT if cls . checkIfStartsWithCapital ( str_ ) == 1 : NEW_LINE INDENT print " Accepted " NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ Accepted " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " GeeksforGeeks " NEW_LINE cls . check ( str_ ) NEW_LINE str_ = " geeksforgeeks " NEW_LINE cls . check ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def getAvg ( cls , prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) / ( n + 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def streamAvg ( cls , arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print " Average ▁ of ▁ " + ( i + 1 ) + " ▁ numbers ▁ is ▁ " + String . format ( " % .1f " , avg ) NEW_LINE i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = arr . length NEW_LINE cls . streamAvg ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE prev = Node ( ) NEW_LINE next = Node ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def push ( cls , head_ref , new_data ) : NEW_LINE INDENT new_node = cls . Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . prev = None NEW_LINE new_node . next = ( head_ref ) NEW_LINE if ( head_ref ) != None : NEW_LINE INDENT ( head_ref ) . prev = new_node NEW_LINE DEDENT ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT @ classmethod NEW_LINE def makeOddNode ( cls , head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE next = cls . Node ( ) NEW_LINE i = 0 NEW_LINE while ptr != None : NEW_LINE INDENT next = ptr . next NEW_LINE if ptr . data % 2 == 0 : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT @ classmethod NEW_LINE def printList ( cls , head ) : NEW_LINE INDENT while head != None : NEW_LINE INDENT print head . data + " ▁ " , NEW_LINE head = head . next NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT head = None NEW_LINE Arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 6 ) NEW_LINE n = Arr . length NEW_LINE print " Original ▁ List : ▁ " , NEW_LINE cls . printList ( head ) NEW_LINE print NEW_LINE head = makeOddNode ( head , Arr , n ) NEW_LINE print " New ▁ odd ▁ List : ▁ " , NEW_LINE cls . printList ( head ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE primeUpto = [ None ] * MAX NEW_LINE @ classmethod NEW_LINE def SieveOfEratosthenes ( cls ) : NEW_LINE INDENT isPrime = [ None ] * MAX NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT i += 1 NEW_LINE DEDENT isPrime [ 0 ] = isPrime [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while i * i < MAX : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT while j < MAX : NEW_LINE INDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < MAX : NEW_LINE INDENT cls . primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT cls . primeUpto [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def countOfNumbers ( cls , N , K ) : NEW_LINE INDENT cls . SieveOfEratosthenes ( ) NEW_LINE low = 1 NEW_LINE high = N NEW_LINE ans = 0 NEW_LINE while low <= high : NEW_LINE INDENT if mid - cls . primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT ans = N - ans + 1 if ans != 0 else 0 NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print cls . countOfNumbers ( N , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countOperations ( cls , n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i ) < n and ( n % i ) > 0 : NEW_LINE if ( i * i ) > n : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) / 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE print cls . countOperations ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . PrintWriter NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def exec_ ( cls , in_ , out ) : NEW_LINE INDENT in_ . nextInt ( ) NEW_LINE Q = in_ . nextInt ( ) NEW_LINE S = in_ . next ( ) NEW_LINE t = len ( [ None ] * S ) NEW_LINE i = 0 NEW_LINE while i < t . length - 1 : NEW_LINE INDENT if S . charAt ( i ) == ' A ' and S . charAt ( i + 1 ) == ' C ' : NEW_LINE INDENT t [ i + 1 ] = t [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT t [ i + 1 ] = t [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < Q : NEW_LINE INDENT out . println ( t [ r - 1 ] - t [ l - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT w = PrintWriter ( System . out ) NEW_LINE cls . exec_ ( Scanner ( System . in_ ) , w ) NEW_LINE w . flush ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class A_FindDivisible ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE f = str ( ) NEW_LINE t = int ( ) NEW_LINE l = str ( ) NEW_LINE r = str ( ) NEW_LINE t = scanner . nextInt ( ) NEW_LINE while t > 0 : NEW_LINE INDENT try : NEW_LINE INDENT l = scanner . next ( ) NEW_LINE r = scanner . next ( ) NEW_LINE print l + " ▁ " + Integer . parseInt ( l ) * 2 NEW_LINE t -= 1 NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT System . exit ( 0 ) NEW_LINE DEDENT DEDENT System . exit ( 0 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A_FindDivisible . main ( sys . argv ) NEW_LINE DEDENT
class p249 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p249 ( ) . run ( ) NEW_LINE DEDENT LIMIT = 5000 NEW_LINE MODULUS = 10000000000000000 L NEW_LINE def run ( self ) : NEW_LINE INDENT isPrime = Library . listPrimality ( self . LIMIT * self . LIMIT / 2 ) NEW_LINE numSubsets = [ None ] * LIMIT * LIMIT / 2 NEW_LINE numSubsets [ 0 ] = 1 NEW_LINE maxSum = 0 NEW_LINE i = 0 NEW_LINE while i < LIMIT : NEW_LINE INDENT if not isPrime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxSum += i NEW_LINE while j >= i : NEW_LINE INDENT if temp < MODULUS : NEW_LINE INDENT numSubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numSubsets [ j ] = temp - MODULUS NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < numSubsets . length : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT sum = ( sum + numSubsets [ i ] ) % MODULUS NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Long . toString ( sum ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p249 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countOddNumber ( cls , row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while row_num > 0 : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT @ classmethod NEW_LINE def gouldSequence ( cls , n ) : NEW_LINE INDENT row_num = 0 NEW_LINE while row_num < n : NEW_LINE INDENT print cls . countOddNumber ( row_num , + " ▁ " ) NEW_LINE row_num += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 16 NEW_LINE cls . gouldSequence ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class p052 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p052 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT if i > Integer . MAX_VALUE / 6 : NEW_LINE INDENT raise ArithmeticException ( " Overflow " ) NEW_LINE DEDENT if multiplesHaveSameDigits ( i ) : NEW_LINE INDENT return Integer . toString ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def multiplesHaveSameDigits ( cls , x ) : NEW_LINE INDENT i = 2 NEW_LINE while i <= 6 : NEW_LINE INDENT if not Arrays == toSortedDigits ( x , toSortedDigits ( i * x ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def toSortedDigits ( cls , x ) : NEW_LINE INDENT result = Integer . toString ( x ) . toCharArray ( ) NEW_LINE Arrays . sort ( result ) NEW_LINE return result NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p052 . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findExtraCharcter ( cls , strA , strB ) : NEW_LINE INDENT m1 = [ None ] * 256 NEW_LINE i = 0 NEW_LINE while i < strB . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < strA . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < m1 . length : NEW_LINE INDENT if m1 [ i ] == 1 : NEW_LINE INDENT return ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Character . MIN_VALUE NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT strA = " abcd " NEW_LINE strB = " cbdad " NEW_LINE print cls . findExtraCharcter ( strA . toCharArray ( ) , strB . toCharArray ( ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . awt . geom . Line2D NEW_LINE import java . awt . geom . Point2D NEW_LINE import java . awt . geom . Point2D . Double NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE import java . util . PriorityQueue NEW_LINE import java . util . Scanner NEW_LINE import java . util . TreeSet NEW_LINE import java . lang . Object NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT aoj1216 ( ) . doIt ( ) NEW_LINE DEDENT class aoj1216 ( object ) : NEW_LINE INDENT a = [ None ] * 101 NEW_LINE b = [ None ] * 101 NEW_LINE def doIt ( self ) : NEW_LINE INDENT i = 0 NEW_LINE while i < 101 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < 101 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < 101 : NEW_LINE INDENT while j < 101 : NEW_LINE INDENT if self . a [ i ] + self . b [ j ] <= n : NEW_LINE INDENT num = Math . max ( num , a [ i ] + b [ j ] ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print num NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class AAB ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxSumPair ( cls , arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = Integer . MIN_VALUE NEW_LINE max2 = Integer . MIN_VALUE NEW_LINE i = 0 NEW_LINE while i < n1 : NEW_LINE INDENT if arr1 [ i ] > max1 : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n2 : NEW_LINE INDENT if arr2 [ i ] > max2 : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max1 + max2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = arr1 . length NEW_LINE n2 = arr2 . length NEW_LINE print cls . maxSumPair ( arr1 , n1 , arr2 , n2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE AAB . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def operations ( cls , op , n , k ) : NEW_LINE INDENT i = int ( ) NEW_LINE count = 0 NEW_LINE nVal = 0 NEW_LINE min = Integer . MAX_VALUE NEW_LINE while i < n : NEW_LINE INDENT nVal += op [ i ] NEW_LINE min = Math . min ( min , nVal ) NEW_LINE if ( k + nVal ) <= 0 : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if nVal >= 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - Math . abs ( min ) ) / Math . abs ( nVal ) NEW_LINE k = ( k - ( times * Math . abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while k > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if k <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT op = [ - 60 , 65 , - 1 , 14 , - 25 ] NEW_LINE n = op . length NEW_LINE k = 100000 NEW_LINE print cls . operations ( op , n , k , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




import java . lang . Math NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def nthTerm ( cls , N ) : NEW_LINE INDENT nth = 0 NEW_LINE i = int ( ) NEW_LINE while i > 0 : NEW_LINE INDENT nth += Math . pow ( i , i ) NEW_LINE i -= 1 NEW_LINE DEDENT return nth NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 3 NEW_LINE print cls . nthTerm ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print " True " if isPower ( 10 , 1 ) else " False " NEW_LINE print " True " if isPower ( 1 , 20 ) else " False " NEW_LINE print " True " if isPower ( 2 , 128 ) else " False " NEW_LINE print " True " if isPower ( 2 , 30 ) else " False " NEW_LINE DEDENT @ classmethod NEW_LINE def isPower ( cls , x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE return ( pow == y ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Test . main ( sys . argv ) NEW_LINE DEDENT
class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print 1 if isPower ( 10 , 1 ) else 0 NEW_LINE print 1 if isPower ( 1 , 20 ) else 0 NEW_LINE print 1 if isPower ( 2 , 128 ) else 0 NEW_LINE print 1 if isPower ( 2 , 30 ) else 0 NEW_LINE DEDENT @ classmethod NEW_LINE def isPower ( cls , x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE return ( pow == y ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Test . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countWays ( cls , N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if N == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( Math . pow ( 2 , E - 1 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 4 NEW_LINE print cls . countWays ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return cls . __gcd ( a - b , b ) NEW_LINE DEDENT return cls . __gcd ( a , b - a ) NEW_LINE DEDENT @ classmethod NEW_LINE def findLCM ( cls , arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / __gcd ( arr [ i ] , lcm ) NEW_LINE i += 1 NEW_LINE DEDENT return lcm NEW_LINE DEDENT @ classmethod NEW_LINE def countNumbers ( cls , arr , n , l , r ) : NEW_LINE INDENT lcm = cls . findLCM ( arr , n ) NEW_LINE count = ( r / lcm ) - ( ( l - 1 ) / lcm ) NEW_LINE return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] NEW_LINE n = arr . length NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print cls . countNumbers ( arr , n , l , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . IOException NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE import java . util . List NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE n = scanner . nextInt ( ) NEW_LINE a = Math . min ( n , 4 ) NEW_LINE num = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT Arrays . sort ( num ) NEW_LINE ans = ArrayList ( ) NEW_LINE i = 0 NEW_LINE while i < a : NEW_LINE INDENT i += 1 NEW_LINE DEDENT Collections . sort ( ans ) NEW_LINE print ans . get ( 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class DeleteN ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = 1234 NEW_LINE inp = Integer . toString ( in_ ) NEW_LINE del_ = 3 NEW_LINE print " num _ after _ deleting _ from _ starting ▁ " + fromStart ( inp , del_ ) NEW_LINE print " num _ after _ deleting _ from _ ending ▁ " + fromEnd ( inp , del_ ) NEW_LINE DEDENT @ classmethod NEW_LINE def fromStart ( cls , inp , del_ ) : NEW_LINE INDENT try : NEW_LINE INDENT return inp1 + inp2 NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT return " Check ▁ Input " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def fromEnd ( cls , inp , del_ ) : NEW_LINE INDENT try : NEW_LINE INDENT return inp1 + inp2 NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT return " Check ▁ Input " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE DeleteN . main ( sys . argv ) NEW_LINE DEDENT


import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . StringTokenizer NEW_LINE class BusGame ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def canTake ( cls , xNeeded , xAvailable , yNeeded , yAvailable ) : NEW_LINE INDENT if xNeeded > xAvailable : NEW_LINE INDENT return False NEW_LINE DEDENT if yNeeded > yAvailable : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE st = StringTokenizer ( br . readLine ( ) ) NEW_LINE x = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE y = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE turn = 0 NEW_LINE while True : NEW_LINE INDENT if turn % 2 == 0 : NEW_LINE INDENT if cls . canTake ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT elif cls . canTake ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif cls . canTake ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT else : NEW_LINE INDENT print " Hanako " NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if cls . canTake ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT elif cls . canTake ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif cls . canTake ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT print " Ciel " NEW_LINE return NEW_LINE DEDENT DEDENT turn += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE BusGame . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class FlippingGame ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE if scanner . hasNext ( ) : NEW_LINE __x_0 = x NEW_LINE x += 1 NEW_LINE INDENT while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT for k in arr : NEW_LINE INDENT brr [ __x_0 ] = k NEW_LINE DEDENT while k <= j : NEW_LINE INDENT if brr [ k ] == 0 : NEW_LINE INDENT brr [ k ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT brr [ k ] = 0 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT if count > max : NEW_LINE INDENT max = count NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT if arr [ 0 ] == 1 : NEW_LINE INDENT print 0 NEW_LINE DEDENT else : NEW_LINE INDENT print 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print max NEW_LINE DEDENT DEDENT DEDENT @ classmethod NEW_LINE def checKNo ( cls , brr ) : NEW_LINE INDENT val = 0 NEW_LINE for i in brr : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT val += 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE FlippingGame . main ( sys . argv ) NEW_LINE DEDENT
import java . util . HashMap NEW_LINE class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countDistictSubarray ( cls , arr , n ) : NEW_LINE INDENT vis = HashMap ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vis . clear ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE left = 0 NEW_LINE while left < n : NEW_LINE INDENT while right < n and window < k : NEW_LINE INDENT vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) NEW_LINE if vis . get ( arr [ right ] ) == 1 : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if window == k : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) NEW_LINE if vis . get ( arr [ left ] ) == 0 : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT left += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 1 , 3 , 2 , 3 ] NEW_LINE print cls . countDistictSubarray ( arr , arr . length ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Test . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import java . nio . charset . MalformedInputException NEW_LINE import java . util . StringTokenizer NEW_LINE import java . util . Arrays NEW_LINE import java . util . HashSet NEW_LINE class Cv ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = FastScanner ( ) NEW_LINE sc = Scanner ( System . in_ ) NEW_LINE o = PrintWriter ( System . out ) NEW_LINE n = sc . nextInt ( ) NEW_LINE s = sc . nextInt ( ) NEW_LINE max = 0 NEW_LINE __n_0 = n NEW_LINE n -= 1 NEW_LINE while __n_0 > 0 : NEW_LINE INDENT if max < f + t : NEW_LINE INDENT max = f + t NEW_LINE DEDENT DEDENT o . println ( Math . max ( max , s ) ) NEW_LINE o . close ( ) NEW_LINE DEDENT class FastScanner ( object ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE st = StringTokenizer ( " " ) NEW_LINE def next ( self ) : NEW_LINE INDENT while not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT str_ = " " NEW_LINE try : NEW_LINE INDENT str_ = br . readLine ( ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT return str_ NEW_LINE DEDENT def nextByte ( self ) : NEW_LINE INDENT return Byte . parseByte ( self . next ( ) ) NEW_LINE DEDENT def nextShort ( self ) : NEW_LINE INDENT return Short . parseShort ( self . next ( ) ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return java . lang . Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return Double . parseDouble ( self . next ( ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Cv . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countSetBits ( cls , n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def pairs ( cls , arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT if sum == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = arr . length NEW_LINE k = 4 NEW_LINE print cls . pairs ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . LinkedList NEW_LINE import java . util . Queue NEW_LINE import java . util . Stack NEW_LINE class Reverse_k_element_queue ( object ) : NEW_LINE INDENT queue = Queue ( ) NEW_LINE @ classmethod NEW_LINE def reverseQueueFirstKElements ( cls , k ) : NEW_LINE INDENT if cls . queue . isEmpty ( ) == True or k > len ( queue ) : NEW_LINE INDENT return NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return NEW_LINE DEDENT stack = Stack ( ) NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT stack . push ( cls . queue . peek ( ) ) NEW_LINE cls . queue . remove ( ) NEW_LINE i += 1 NEW_LINE DEDENT while not stack . empty ( ) : NEW_LINE INDENT cls . queue . add ( stack . peek ( ) ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( queue ) - k : NEW_LINE INDENT cls . queue . add ( cls . queue . peek ( ) ) NEW_LINE cls . queue . remove ( ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def Print ( cls ) : NEW_LINE INDENT while not cls . queue . isEmpty ( ) : NEW_LINE INDENT print cls . queue . peek ( , + " ▁ " ) NEW_LINE cls . queue . remove ( ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . queue = LinkedList ( ) NEW_LINE cls . queue . add ( 10 ) NEW_LINE cls . queue . add ( 20 ) NEW_LINE cls . queue . add ( 30 ) NEW_LINE cls . queue . add ( 40 ) NEW_LINE cls . queue . add ( 50 ) NEW_LINE cls . queue . add ( 60 ) NEW_LINE cls . queue . add ( 70 ) NEW_LINE cls . queue . add ( 80 ) NEW_LINE cls . queue . add ( 90 ) NEW_LINE cls . queue . add ( 100 ) NEW_LINE k = 5 NEW_LINE cls . reverseQueueFirstKElements ( k ) NEW_LINE cls . Print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Reverse_k_element_queue . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def xorCalc ( cls , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( k + 1 ) & k ) == 0 : NEW_LINE INDENT return k / 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT k = 31 NEW_LINE print cls . xorCalc ( k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while low <= high : NEW_LINE INDENT if mid * mid == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid * mid < num : NEW_LINE INDENT low = ( mid ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = ( mid ) - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 16 NEW_LINE out = sObj . isPerfectSquare ( n ) NEW_LINE print out NEW_LINE DEDENT DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE size = Integer . parseInt ( scanner . next ( ) ) NEW_LINE quantum = Integer . parseInt ( scanner . next ( ) ) NEW_LINE sum = 0 NEW_LINE queue = Queue ( ) NEW_LINE i = 0 NEW_LINE while i < size : NEW_LINE INDENT if time <= quantum : NEW_LINE INDENT sum += time NEW_LINE print name + " ▁ " + sum NEW_LINE DEDENT else : NEW_LINE INDENT sum += quantum NEW_LINE queue . enqueue ( Process ( name , time - quantum ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while not queue . isEmpty ( ) : NEW_LINE INDENT if process . quantum <= quantum : NEW_LINE INDENT sum += process . quantum NEW_LINE print process . name + " ▁ " + sum NEW_LINE DEDENT else : NEW_LINE INDENT sum += quantum NEW_LINE queue . enqueue ( Process ( process . name , process . quantum - quantum ) ) NEW_LINE DEDENT DEDENT DEDENT class Queue ( object ) : NEW_LINE INDENT SIZE = 100000 NEW_LINE array = [ None ] * SIZE NEW_LINE head = 0 NEW_LINE tail = 0 NEW_LINE def dequeue ( self ) : NEW_LINE INDENT if isEmpty ( ) : NEW_LINE INDENT raise IllegalStateException ( " You ▁ dequeued ▁ from ▁ empty ▁ " + " queue . " ) NEW_LINE DEDENT value = self . array [ self . tail ] NEW_LINE self . tail += 1 NEW_LINE if self . tail == SIZE : NEW_LINE INDENT self . tail -= SIZE NEW_LINE DEDENT return value NEW_LINE DEDENT def enqueue ( self , process ) : NEW_LINE INDENT if isFull ( ) : NEW_LINE INDENT raise IllegalStateException ( " You ▁ enqueued ▁ to ▁ full ▁ queue . " ) NEW_LINE DEDENT self . array [ self . head ] = process NEW_LINE self . head += 1 NEW_LINE if self . head == SIZE : NEW_LINE INDENT self . head -= SIZE NEW_LINE DEDENT DEDENT def isFull ( self ) : NEW_LINE INDENT return self . head + 1 == ( tail % SIZE ) NEW_LINE DEDENT def isEmpty ( self ) : NEW_LINE INDENT return self . head == tail NEW_LINE DEDENT DEDENT class Process ( object ) : NEW_LINE INDENT name = str ( ) NEW_LINE quantum = int ( ) NEW_LINE def __init__ ( self , name , quantum ) : NEW_LINE INDENT self . name = name NEW_LINE self . quantum = quantum NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT MAXN = 1000001 NEW_LINE spf = [ None ] * MAXN NEW_LINE hash1 = [ None ] * MAXN NEW_LINE @ classmethod NEW_LINE def sieve ( cls ) : NEW_LINE INDENT cls . spf [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while i < MAXN : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 4 NEW_LINE while i < MAXN : NEW_LINE INDENT i += 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAXN : NEW_LINE INDENT if cls . spf [ i ] == i : NEW_LINE INDENT while j < MAXN : NEW_LINE INDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def getFactorization ( cls , x ) : NEW_LINE INDENT temp = int ( ) NEW_LINE while x != 1 : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if x % temp == 0 : NEW_LINE INDENT cls . hash1 [ cls . spf [ x ] ] += 1 NEW_LINE x = x / spf [ x ] NEW_LINE DEDENT while x % temp == 0 : NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def check ( cls , x ) : NEW_LINE INDENT temp = int ( ) NEW_LINE while x != 1 : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if x % temp == 0 and cls . hash1 [ temp ] > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT while x % temp == 0 : NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def hasValidNum ( cls , arr , n ) : NEW_LINE INDENT cls . sieve ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = arr . length NEW_LINE if cls . hasValidNum ( arr , n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def areaOfKite ( cls , d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print " Area ▁ of ▁ Kite ▁ = ▁ " + cls . areaOfKite ( d1 , d2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Solution ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE a = [ None ] * 4 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if i == 2 and j != 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT a [ i ] [ j ] = True NEW_LINE i = ( i + 1 ) % 4 NEW_LINE DEDENT print " + - - - - - - - - - - - - - - - - - - - - - - - - + " NEW_LINE i = 0 NEW_LINE while i < 4 : NEW_LINE INDENT print " | " , NEW_LINE while j < 11 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT print " | D | ) " NEW_LINE DEDENT else : NEW_LINE INDENT print ( " . . | " if i == 2 else " | . | " ) + ( " ) " if i == 3 else " " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " + - - - - - - - - - - - - - - - - - - - - - - - - + " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Solution . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def productEqual ( cls , n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 NEW_LINE prodEven = 1 NEW_LINE while n > 0 : NEW_LINE INDENT prodOdd *= digit NEW_LINE n /= 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT digit = n % 10 NEW_LINE prodEven *= digit NEW_LINE n /= 10 NEW_LINE DEDENT if prodEven == prodOdd : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4324 NEW_LINE if cls . productEqual ( n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Collections NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < n : NEW_LINE INDENT key [ i ] = Integer . parseInt ( str_ [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while i < c . length : NEW_LINE INDENT while j < key [ keyCount ] : NEW_LINE INDENT if c [ i ] == 97 : NEW_LINE INDENT c [ i ] = 90 NEW_LINE DEDENT elif c [ i ] == 65 : NEW_LINE INDENT c [ i ] = 122 NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] -= 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if keyCount == key . length - 1 : NEW_LINE INDENT keyCount = 0 NEW_LINE DEDENT else : NEW_LINE INDENT keyCount += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < c . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print " \n " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPrime ( cls , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 2 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def findPrime ( cls , n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while num > 0 : NEW_LINE INDENT if cls . isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def minNumber ( cls , arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if cls . isPrime ( sum ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = cls . findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = arr . length NEW_LINE print cls . minNumber ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT intx = 0 NEW_LINE inty = 0 NEW_LINE intWork = 0 NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT if strLine != None : NEW_LINE INDENT intx = Integer . parseInt ( strNumList [ 0 ] ) NEW_LINE inty = Integer . parseInt ( strNumList [ 1 ] ) NEW_LINE if intx != 0 or inty != 0 : NEW_LINE INDENT if intx > inty : NEW_LINE INDENT intWork = intx NEW_LINE intx = inty NEW_LINE inty = intWork NEW_LINE DEDENT print intx + " ▁ " + inty NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT except IOException as e1 : NEW_LINE INDENT print e1 NEW_LINE DEDENT except NumberFormatException as e2 : NEW_LINE INDENT print e2 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT strarr = [ None ] * NEW_LINE s = Scanner ( System . in_ ) NEW_LINE t = s . nextInt ( ) NEW_LINE indexWord = 0 NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT if s1 . endsWith ( " po " ) : NEW_LINE INDENT indexWord = 0 NEW_LINE DEDENT elif s1 . endsWith ( " mnida " ) : NEW_LINE INDENT indexWord = 2 NEW_LINE DEDENT else : NEW_LINE INDENT indexWord = 1 NEW_LINE DEDENT print strarr [ indexWord ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findSum ( cls , arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ] NEW_LINE queries = 3 NEW_LINE q = [ ] NEW_LINE n = arr . length NEW_LINE i = 0 NEW_LINE while i < queries : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE size = sc . nextInt ( ) NEW_LINE arr = [ None ] * size + 1 NEW_LINE i = 1 NEW_LINE while i <= size : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print split ( arr , 1 , size ) NEW_LINE DEDENT @ classmethod NEW_LINE def split ( cls , arr , s , m ) : NEW_LINE INDENT if s == m : NEW_LINE INDENT return 1 NEW_LINE DEDENT half = ( m - s + 1 ) >> 1 NEW_LINE mid = half + s NEW_LINE ans1 = cls . split ( arr , s , mid - 1 ) NEW_LINE ans2 = cls . split ( arr , mid , m ) NEW_LINE if arr [ mid ] >= arr [ mid - 1 ] and ans1 == ans2 and ans1 == half : NEW_LINE INDENT return ans1 + ans2 NEW_LINE DEDENT elif ans1 > ans2 : NEW_LINE INDENT return ans1 NEW_LINE DEDENT else : NEW_LINE INDENT return ans2 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def nDigitPerfectSquares ( cls , n ) : NEW_LINE INDENT smallest = ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) ) NEW_LINE print smallest + " ▁ " , NEW_LINE largest = ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) NEW_LINE print largest , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE cls . nDigitPerfectSquares ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT discard_count = 0 NEW_LINE @ classmethod NEW_LINE def power ( cls , a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = cls . power ( a , n / 2 ) NEW_LINE p = p * p NEW_LINE if n % 2 == 1 : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls , i , n , sum , k , a , prefix ) : NEW_LINE INDENT if sum > k : NEW_LINE INDENT cls . discard_count += power ( 2 , n - i ) NEW_LINE return NEW_LINE DEDENT if i == n : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if sum + a [ i ] + rem > k : NEW_LINE INDENT cls . solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if sum + rem > k : NEW_LINE INDENT cls . solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def countSubsequences ( cls , arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = ( Math . log ( K ) ) NEW_LINE prefix = [ None ] * n NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = ( Math . log ( arr [ i ] ) ) NEW_LINE sum += a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT prefix [ 0 ] = a [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT total = cls . power ( 2 , n ) - 1 NEW_LINE if sum <= k : NEW_LINE INDENT return ( total ) NEW_LINE DEDENT cls . solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return ( ( total - cls . discard_count ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = arr . length NEW_LINE k = 50 NEW_LINE print cls . countSubsequences ( arr , n , k , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE left = Node ( ) NEW_LINE right = Node ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def newNode ( cls , data ) : NEW_LINE INDENT node = cls . Node ( ) NEW_LINE node . data = data NEW_LINE node . left = None NEW_LINE node . right = None NEW_LINE return node NEW_LINE DEDENT @ classmethod NEW_LINE def inorder ( cls , root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT cls . inorder ( root . left ) NEW_LINE print root . data + " ▁ " , NEW_LINE cls . inorder ( root . right ) NEW_LINE DEDENT @ classmethod NEW_LINE def isIdentical ( cls , root1 , root2 ) : NEW_LINE INDENT if root1 == None and root2 == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root1 != None and root2 == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root1 == None and root2 != None : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if root1 . data == root2 . data and cls . isIdentical ( root1 . left , root2 . left ) == 1 and cls . isIdentical ( root1 . right , root2 . right ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT root1 = cls . newNode ( 5 ) NEW_LINE root2 = cls . newNode ( 5 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 8 ) NEW_LINE root1 . left . left = newNode ( 2 ) NEW_LINE root1 . left . right = newNode ( 4 ) NEW_LINE root2 . left = newNode ( 3 ) NEW_LINE root2 . right = newNode ( 8 ) NEW_LINE root2 . left . left = newNode ( 2 ) NEW_LINE root2 . left . right = newNode ( 4 ) NEW_LINE if cls . isIdentical ( root1 , root2 ) == 1 : NEW_LINE INDENT print " Both ▁ BSTs ▁ are ▁ identical " , NEW_LINE DEDENT else : NEW_LINE INDENT print " BSTs ▁ are ▁ not ▁ identical " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE surface = br . readLine ( ) . split ( " ▁ " ) NEW_LINE order = br . readLine ( ) . split ( " " ) NEW_LINE dice1 = Dise ( ) NEW_LINE dice1 . setSurface ( surface ) NEW_LINE dice1 . SetDice ( 1 , 2 , 3 ) NEW_LINE dice1 . RollDice ( order ) NEW_LINE DEDENT DEDENT class Dise ( object ) : NEW_LINE INDENT surface = [ None ] * 6 NEW_LINE Top = int ( ) NEW_LINE Bottom = int ( ) NEW_LINE Right = int ( ) NEW_LINE Left = int ( ) NEW_LINE Front = int ( ) NEW_LINE Back = int ( ) NEW_LINE def setSurface ( self , SurfaceString ) : NEW_LINE INDENT i = 0 NEW_LINE while i < 6 : NEW_LINE INDENT self . surface [ i ] = Integer . parseInt ( SurfaceString [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def SetDice ( self , top , front , right ) : NEW_LINE INDENT self . Top = top - 1 NEW_LINE self . Front = front - 1 NEW_LINE self . Right = right - 1 NEW_LINE self . Bottom = 5 - ( top - 1 ) NEW_LINE self . Back = 5 - ( front - 1 ) NEW_LINE self . Left = 5 - ( right - 1 ) NEW_LINE DEDENT def RollDice ( self , RollString ) : NEW_LINE INDENT i = 0 NEW_LINE while i < RollString . length : NEW_LINE INDENT if RollString [ i ] == " W " : NEW_LINE INDENT self . Bottom = Left NEW_LINE self . Left = Top NEW_LINE self . Top = 5 - Bottom NEW_LINE self . Right = 5 - Left NEW_LINE DEDENT elif RollString [ i ] == " S " : NEW_LINE INDENT self . Bottom = Front NEW_LINE self . Front = Top NEW_LINE self . Top = 5 - Bottom NEW_LINE self . Back = 5 - Front NEW_LINE DEDENT elif RollString [ i ] == " E " : NEW_LINE INDENT self . Bottom = Right NEW_LINE self . Right = Top NEW_LINE self . Top = 5 - Bottom NEW_LINE self . Left = 5 - Right NEW_LINE DEDENT else : NEW_LINE INDENT self . Bottom = Back NEW_LINE self . Back = Top NEW_LINE self . Top = 5 - Bottom NEW_LINE self . Front = 5 - Back NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print self . surface [ self . Top ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT class node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE next = node ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def add ( cls , data ) : NEW_LINE INDENT newnode = cls . node ( ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT @ classmethod NEW_LINE def printArr ( cls , a , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def findlength ( cls , head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while curr != None : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT @ classmethod NEW_LINE def convertArr ( cls , head ) : NEW_LINE INDENT len = cls . findlength ( head ) NEW_LINE arr = [ None ] * len NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE __index_0 = index NEW_LINE index += 1 NEW_LINE while curr != None : NEW_LINE INDENT arr [ __index_0 ] = curr . data NEW_LINE curr = curr . next NEW_LINE DEDENT cls . printArr ( arr , len ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT head = cls . node ( ) NEW_LINE head = add ( 1 ) NEW_LINE head . next = add ( 2 ) NEW_LINE head . next . next = add ( 3 ) NEW_LINE head . next . next . next = add ( 4 ) NEW_LINE head . next . next . next . next = add ( 5 ) NEW_LINE cls . convertArr ( head ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if nums . length == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT Arrays . sort ( nums ) NEW_LINE min_num = nums [ 0 ] NEW_LINE ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT ans += num - min_num NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print out NEW_LINE DEDENT DEDENT

class geeks ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def firstSetBit ( cls , n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 12 NEW_LINE print cls . firstSetBit ( n ) NEW_LINE DEDENT DEDENT



class p205 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p205 ( ) . run ( ) NEW_LINE DEDENT PYRAMIDAL_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE def run ( self ) : NEW_LINE INDENT ninePyramidalPdf = [ 1 ] NEW_LINE i = 0 NEW_LINE while i < 9 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT sixCubicPdf = [ 1 ] NEW_LINE i = 0 NEW_LINE while i < 6 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT numer = 0 NEW_LINE i = 0 NEW_LINE while i < ninePyramidalPdf . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT denom = ( sum ( ninePyramidalPdf , 0 , ninePyramidalPdf . length ) ) * sum ( sixCubicPdf , 0 , sixCubicPdf . length ) NEW_LINE return String . format ( " % .7f " , ( numer ) / denom ) NEW_LINE DEDENT @ classmethod NEW_LINE def convolve ( cls , a , b ) : NEW_LINE INDENT c = [ None ] * a . length + b . length - 1 NEW_LINE i = 0 NEW_LINE while i < a . length : NEW_LINE INDENT while j < b . length : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT @ classmethod NEW_LINE def sum ( cls , array , start , end ) : NEW_LINE INDENT sum = 0 NEW_LINE i = start NEW_LINE while i < end : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p205 . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Scanner NEW_LINE class CF_1712_A ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT if a [ i ] <= k : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print counter NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE CF_1712_A . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class JavaApplication38 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE num1 = sc . nextInt ( ) NEW_LINE num2 = sc . nextInt ( ) NEW_LINE counter = 0 NEW_LINE while num1 != 0 and num2 != 0 : NEW_LINE INDENT if num1 == 1 and num2 == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if num1 <= num2 : NEW_LINE INDENT num1 += 1 NEW_LINE num2 -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT num1 -= 2 NEW_LINE num2 += 1 NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT print counter NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE JavaApplication38 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def encodedChar ( cls , str_ , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while i < len ( str_ ) and str_ . charAt ( i ) >= ' a ' and str_ . charAt ( i ) <= ' z ' : NEW_LINE INDENT temp += str_ . charAt ( i ) NEW_LINE i += 1 NEW_LINE DEDENT while i < len ( str_ ) and str_ . charAt ( i ) >= '1' and str_ . charAt ( i ) <= '9' : NEW_LINE INDENT freq = freq * 10 + str_ . charAt ( i ) - '0' NEW_LINE i += 1 NEW_LINE DEDENT while j <= freq : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT if freq == 0 : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand . charAt ( k - 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " ab4c12ed3" NEW_LINE k = 21 NEW_LINE print cls . encodedChar ( str_ , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def summation ( cls , n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) / 2 NEW_LINE sign = 1 if n + 1 % 2 == 0 else - 1 NEW_LINE result_sum = sign * abs_sum NEW_LINE return result_sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 2 NEW_LINE print cls . summation ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT








import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sn = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if slot . isEnd ( ) : NEW_LINE INDENT break NEW_LINE DEDENT print 100 + slot . getBenefit ( ) - slot . getLost ( ) NEW_LINE DEDENT DEDENT DEDENT class Slot ( object ) : NEW_LINE INDENT b = int ( ) NEW_LINE r = int ( ) NEW_LINE g = int ( ) NEW_LINE c = int ( ) NEW_LINE s = int ( ) NEW_LINE t = int ( ) NEW_LINE def __init__ ( self , b , r , g , c , s , t ) : NEW_LINE INDENT self . b = b NEW_LINE self . r = r NEW_LINE self . g = g NEW_LINE self . c = c NEW_LINE self . s = s NEW_LINE self . t = t NEW_LINE DEDENT def getLost ( self ) : NEW_LINE INDENT return ( self . t - 5 * self . b - 3 * self . r - self . s ) * 3 + ( 5 * self . b + 3 * self . r ) * 2 NEW_LINE DEDENT def getBenefit ( self ) : NEW_LINE INDENT return self . b * 15 + self . r * 15 + self . g * 7 + self . c * 2 + ( self . b * 5 + self . r * 3 ) * 15 NEW_LINE DEDENT def isEnd ( self ) : NEW_LINE INDENT return self . b + self . r + self . g + self . c + self . s + self . t == 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def reverseDigits ( cls , num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT @ classmethod NEW_LINE def isPalindrome ( cls , n ) : NEW_LINE INDENT rev_n = cls . reverseDigits ( n ) NEW_LINE if rev_n == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4562 NEW_LINE print " Is ▁ " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ " + ( " True " if cls . isPalindrome ( n ) == 1 else " False " ) NEW_LINE n = 2002 NEW_LINE print " Is ▁ " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ " + ( " True " if cls . isPalindrome ( n ) == 1 else " False " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT sb = StringBuilder ( ) NEW_LINE carry = 0 NEW_LINE i = len ( num1 ) - 1 NEW_LINE j = len ( num2 ) - 1 NEW_LINE while i >= 0 or j >= 0 or carry == 1 : NEW_LINE INDENT sb . append ( ( x + y + carry ) % 10 ) NEW_LINE carry = ( x + y + carry ) / 10 NEW_LINE j -= 1 NEW_LINE DEDENT return sb . reverse ( ) . __str__ ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num1 = "11" NEW_LINE num2 = "123" NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print out NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Solution . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPerfect ( cls , n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if sum == n and n != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" NEW_LINE n = 2 NEW_LINE while n < 10000 : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPower ( cls , n ) : NEW_LINE INDENT x = 2 NEW_LINE while x <= Math . sqrt ( n ) : NEW_LINE INDENT while p <= n : NEW_LINE INDENT p = p * x NEW_LINE if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT x += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT i = 2 NEW_LINE while i < 100 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPower ( cls , n ) : NEW_LINE INDENT x = 2 NEW_LINE while x <= Math . sqrt ( n ) : NEW_LINE INDENT while p <= n and p > 0 : NEW_LINE INDENT if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = Math . pow ( x , y ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT i = 2 NEW_LINE while i < 100 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . InputStreamReader NEW_LINE class RobotCleaner ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def time ( cls , m , n , rb , cb , rd , cd ) : NEW_LINE INDENT t = 0 NEW_LINE dr = 1 NEW_LINE dc = 1 NEW_LINE while True : NEW_LINE INDENT if rb == rd or cb == cd : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE if ( rb + dr ) <= 0 or ( rb + dr > m ) : NEW_LINE INDENT dr *= - 1 NEW_LINE DEDENT if ( cb + dc ) <= 0 or ( cb + dc > n ) : NEW_LINE INDENT dc *= - 1 NEW_LINE DEDENT rb += dr NEW_LINE cb += dc NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT streamReader = InputStreamReader ( System . in_ ) NEW_LINE reader = BufferedReader ( streamReader ) NEW_LINE testCases = Integer . parseInt ( reader . readLine ( ) ) NEW_LINE __testCases_0 = testCases NEW_LINE testCases -= 1 NEW_LINE while __testCases_0 > 0 : NEW_LINE INDENT print t NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE RobotCleaner . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = cls . sc . nextInt ( ) NEW_LINE a = cls . sc . nextInt ( ) NEW_LINE b = cls . sc . nextInt ( ) NEW_LINE c = cls . sc . nextInt ( ) NEW_LINE d = cls . sc . nextInt ( ) NEW_LINE ans1 = 100000 NEW_LINE ans2 = 1000000 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if a * i >= n : NEW_LINE INDENT ans1 = i * b NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if c * i >= n : NEW_LINE INDENT ans2 = i * d NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print Math . min ( ans2 , ans1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countNumbers ( cls , L , R , K ) : NEW_LINE INDENT if K == 9 : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers / 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE i = R NEW_LINE while i > R - rem : NEW_LINE INDENT if rem1 == K : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print cls . countNumbers ( L , R , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def multiplyWith3Point5 ( cls , x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 4 NEW_LINE print cls . multiplyWith3Point5 ( x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . lang . Math NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longestSubstring ( cls , s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s . charAt ( i ) != s . charAt ( i - 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = Math . max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT maxi = Math . max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " ccccdeededff " NEW_LINE print cls . longestSubstring ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE k = sc . nextLong ( ) NEW_LINE n = 50 NEW_LINE sum = k / n NEW_LINE amari = k % n NEW_LINE a = [ None ] * 50 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = i + sum NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < amari : NEW_LINE INDENT a [ n - 1 - i ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT print n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT print a [ i ] + ( " \n " if i == n - 1 else " ▁ " , ) NEW_LINE i += 1 NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def zeroUpto ( cls , digits ) : NEW_LINE INDENT first = ( ( ( Math . pow ( 10 , digits ) - 1 ) / 9 ) ) NEW_LINE second = ( ( ( Math . pow ( 9 , digits ) - 1 ) / 8 ) ) NEW_LINE return 9 * ( first - second ) NEW_LINE DEDENT @ classmethod NEW_LINE def toInt ( cls , c ) : NEW_LINE INDENT return ( c ( - 48 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def countZero ( cls , num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = cls . zeroUpto ( k - 1 ) NEW_LINE non_zero = 0 NEW_LINE i = 0 NEW_LINE while i < len ( num ) : NEW_LINE INDENT if num . charAt ( i ) == '0' : NEW_LINE INDENT non_zero -= 1 NEW_LINE break NEW_LINE DEDENT non_zero += ( toInt ( num . charAt ( i ) ) - 1 ) * ( Math . pow ( 9 , k - 1 - i ) ) NEW_LINE i += 1 NEW_LINE DEDENT no = 0 NEW_LINE remaining = 0 NEW_LINE calculatedUpto = 0 NEW_LINE i = 0 NEW_LINE while i < len ( num ) : NEW_LINE INDENT no = no * 10 + ( toInt ( num . charAt ( i ) ) ) NEW_LINE if i != 0 : NEW_LINE INDENT calculatedUpto = calculatedUpto * 10 + 9 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT remaining = no - calculatedUpto NEW_LINE ans = cls . zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = "107" NEW_LINE print " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + cls . countZero ( num ) NEW_LINE num = "1264" NEW_LINE print " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + cls . countZero ( num ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE a = sc . next ( ) . toCharArray ( ) [ 0 ] NEW_LINE b = sc . next ( ) . toCharArray ( ) [ 0 ] NEW_LINE if a > b : NEW_LINE INDENT print ' > ' NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ' = ' NEW_LINE DEDENT else : NEW_LINE INDENT print ' < ' NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class p045 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p045 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT if min == triangle and min == pentagon and min == hexagon : NEW_LINE INDENT return Long . toString ( min ) NEW_LINE DEDENT if min == triangle : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if min == pentagon : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if min == hexagon : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p045 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxPrimefactorNum ( cls , N ) : NEW_LINE INDENT if N < 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ None ] * N + 1 NEW_LINE prod = 1 NEW_LINE res = 0 NEW_LINE p = 2 NEW_LINE while p * p <= N : NEW_LINE INDENT if arr [ p ] == False : NEW_LINE INDENT while i <= N : NEW_LINE INDENT i += p NEW_LINE DEDENT prod *= p NEW_LINE if prod > N : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT p += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 500 NEW_LINE print cls . maxPrimefactorNum ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class Test ( object ) : NEW_LINE INDENT arr = [ None ] * NEW_LINE @ classmethod NEW_LINE def subArray ( cls , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT while k <= j : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print " All ▁ Non - empty ▁ Subarrays " NEW_LINE cls . subArray ( cls . arr . length ) NEW_LINE DEDENT DEDENT


import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxSum ( cls , a , n ) : NEW_LINE INDENT Arrays . sort ( a ) NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT sum += a [ i ] NEW_LINE i += 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = arr . length NEW_LINE print cls . maxSum ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findSum ( cls , arr , n ) : NEW_LINE INDENT Arrays . sort ( arr ) NEW_LINE sum = arr [ 0 ] NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = arr . length NEW_LINE print cls . findSum ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = Scanner ( System . in_ ) NEW_LINE n = s . nextInt ( ) NEW_LINE arr = [ None ] * n + 1 NEW_LINE arr [ 0 ] = 2 NEW_LINE arr [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while i < arr . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print arr [ n ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxsum_SIS ( cls , arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = Math . max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Math . max ( max_sum , current_sum ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = arr . length NEW_LINE print " Maximum ▁ sum ▁ : ▁ " + cls . maxsum_SIS ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT






class Squares ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def numberOfSquares ( cls , base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base / 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT base = 8 NEW_LINE print cls . numberOfSquares ( base ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def rmsValue ( cls , arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0 NEW_LINE root = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT square += Math . pow ( arr [ i ] , 2 ) NEW_LINE i += 1 NEW_LINE DEDENT mean = ( square / ( ( n ) ) ) NEW_LINE root = ( Math . sqrt ( mean ) ) NEW_LINE return root NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 10 , 4 , 6 , 8 ] NEW_LINE n = arr . length NEW_LINE print String . format ( " % .4f " , cls . rmsValue ( arr , n ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT M = cls . sc . nextInt ( ) NEW_LINE N = cls . sc . nextInt ( ) NEW_LINE P = [ None ] * M NEW_LINE i = 0 NEW_LINE while i < M : NEW_LINE INDENT P [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( P ) NEW_LINE dp = [ None ] * M + 10001 NEW_LINE Arrays . fill ( dp , Integer . MAX_VALUE ) NEW_LINE dp [ 0 ] = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT while j - C >= 0 : NEW_LINE INDENT if dp [ j - C ] == Integer . MAX_VALUE : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ j ] = Math . min ( dp [ j ] , dp [ j - C ] + E ) NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum = [ None ] * dp . length NEW_LINE i = 0 NEW_LINE while i < M : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + P [ M - 1 - i ] NEW_LINE i += 1 NEW_LINE DEDENT i = M + 1 NEW_LINE while i < sum . length : NEW_LINE INDENT sum [ i ] = sum [ M ] NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < sum . length : NEW_LINE INDENT if dp [ i ] == Integer . MAX_VALUE : NEW_LINE INDENT continue NEW_LINE DEDENT ans = Math . max ( ans , sum [ i ] - dp [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE n = scanner . nextInt ( ) NEW_LINE array = [ None ] * n + 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT array [ i ] = scanner . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT System . out . printf ( " node ▁ % d : ▁ key ▁ = ▁ % d , ▁ " , i , array [ i ] ) NEW_LINE if i / 2 > 0 : NEW_LINE INDENT System . out . printf ( " parent ▁ key ▁ = ▁ % d , ▁ " , array [ i / 2 ] ) NEW_LINE DEDENT if 2 * i <= n : NEW_LINE INDENT System . out . printf ( " left ▁ key ▁ = ▁ % d , ▁ " , array [ 2 * i ] ) NEW_LINE DEDENT if ( 2 * i + 1 ) <= n : NEW_LINE INDENT System . out . printf ( " right ▁ key ▁ = ▁ % d , ▁ " , array [ 2 * i + 1 ] ) NEW_LINE DEDENT print " \n " , NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def knapSack ( cls , W , wt , val , n ) : NEW_LINE INDENT maxratio = Integer . MIN_VALUE NEW_LINE maxindex = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( val [ i ] / wt [ i ] ) > maxratio : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( W * maxratio ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT val = [ 14 , 27 , 44 , 19 ] NEW_LINE wt = [ 6 , 7 , 9 , 8 ] NEW_LINE n = val . length NEW_LINE W = 50 NEW_LINE print cls . knapSack ( W , wt , val , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE A = scan . nextInt ( ) NEW_LINE B = scan . nextInt ( ) NEW_LINE C = scan . nextInt ( ) NEW_LINE if A <= C and B >= C : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def makearrayequal ( cls , arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE i += 1 NEW_LINE DEDENT print Math . min ( x , n - x ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = arr . length NEW_LINE cls . makearrayequal ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isDivisible ( cls , n ) : NEW_LINE INDENT temp = n NEW_LINE while n > 0 : NEW_LINE INDENT if temp % k == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 9876543 NEW_LINE print cls . isDivisible ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isDivisible ( cls , n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += k NEW_LINE n /= 10 NEW_LINE DEDENT if temp % sum == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 123 NEW_LINE print cls . isDivisible ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def calculateAreaSum ( cls , l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = Math . min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE i = 1 NEW_LINE while i <= maxSize : NEW_LINE INDENT totalArea += area NEW_LINE size += 1 NEW_LINE i += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT l = 4 NEW_LINE b = 3 NEW_LINE print cls . calculateAreaSum ( l , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def arrange ( cls , N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT print "1" NEW_LINE return NEW_LINE DEDENT if N == 2 or N == 3 : NEW_LINE INDENT print " - 1" NEW_LINE return NEW_LINE DEDENT even = - 1 NEW_LINE odd = - 1 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT even = N NEW_LINE odd = N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = N NEW_LINE even = N - 1 NEW_LINE DEDENT while odd >= 1 : NEW_LINE INDENT print odd , NEW_LINE print " ▁ " , NEW_LINE odd = odd - 2 NEW_LINE DEDENT while even >= 2 : NEW_LINE INDENT print even , NEW_LINE print " ▁ " , NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 5 NEW_LINE cls . arrange ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE t = scanner . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT if mod == 1 : NEW_LINE INDENT while j < n / 3 : NEW_LINE INDENT builder . append ( 12 ) NEW_LINE j += 1 NEW_LINE DEDENT builder . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT while j < n / 3 : NEW_LINE INDENT builder . append ( 21 ) NEW_LINE j += 1 NEW_LINE DEDENT if mod == 2 : NEW_LINE INDENT builder . append ( 2 ) NEW_LINE DEDENT DEDENT print builder NEW_LINE i += 1 NEW_LINE DEDENT scanner . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Arrays NEW_LINE import java . util . HashSet NEW_LINE import java . util . Scanner NEW_LINE class Practice ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if n > m : NEW_LINE INDENT print " NO " NEW_LINE continue NEW_LINE DEDENT Arrays . sort ( a ) NEW_LINE while i >= 0 : NEW_LINE INDENT ans += 1 NEW_LINE if i > 0 : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ans <= m : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Practice . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def getPairs ( cls , a ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < a . length : NEW_LINE INDENT while j < a . length : NEW_LINE INDENT if a [ i ] < a [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print cls . getPairs ( a ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class main1 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE arr = [ None ] * 4 NEW_LINE i = 0 NEW_LINE while i < 4 : NEW_LINE INDENT while j < 4 : NEW_LINE INDENT arr [ i ] [ j ] = sc . nextInt ( ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if arr [ 0 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 0 ] [ 1 ] == 1 or arr [ 0 ] [ 2 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 : NEW_LINE INDENT print " YES " NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 1 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 1 ] [ 1 ] == 1 or arr [ 1 ] [ 2 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 0 ] == 1 or arr [ 3 ] [ 1 ] == 1 or arr [ 0 ] [ 2 ] == 1 : NEW_LINE INDENT print " YES " NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 2 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 2 ] [ 1 ] == 1 or arr [ 2 ] [ 2 ] == 1 or arr [ 2 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 0 ] [ 1 ] == 1 or arr [ 1 ] [ 2 ] == 1 : NEW_LINE INDENT print " YES " NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 3 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 3 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 1 ] == 1 or arr [ 2 ] [ 2 ] == 1 : NEW_LINE INDENT print " YES " NEW_LINE return NEW_LINE DEDENT DEDENT print " NO " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE main1 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT N = 10000 NEW_LINE MOD = 1000000007 NEW_LINE F = [ None ] * N NEW_LINE @ classmethod NEW_LINE def precompute ( cls ) : NEW_LINE INDENT cls . F [ 1 ] = 2 NEW_LINE cls . F [ 2 ] = 3 NEW_LINE cls . F [ 3 ] = 4 NEW_LINE i = 4 NEW_LINE while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 8 NEW_LINE cls . precompute ( ) NEW_LINE print cls . F [ n ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def checkPowerof8 ( cls , n ) : NEW_LINE INDENT i = Math . log ( n ) / Math . log ( 8 ) NEW_LINE return ( i - Math . floor ( i ) < 0.000001 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 65 NEW_LINE if cls . checkPowerof8 ( n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . ArrayList NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT maxes = ArrayList ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT ( Main ( ) ) . go ( ) NEW_LINE DEDENT def go ( self ) : NEW_LINE INDENT self . maxes = ArrayList ( ) NEW_LINE sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < m : NEW_LINE INDENT while j < n : NEW_LINE INDENT points [ j ] += sc . nextInt ( ) NEW_LINE if i == m - 1 and max < points [ j ] : NEW_LINE INDENT max = points [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT self . maxes . add ( max ) NEW_LINE DEDENT for max in maxes : NEW_LINE INDENT print max NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT l [ i ] = in_ . nextInt ( ) NEW_LINE r [ i ] = in_ . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT if s < r [ i ] : NEW_LINE INDENT if l [ i ] > s : NEW_LINE INDENT s = l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT print s + " ▁ " , NEW_LINE DEDENT else : NEW_LINE INDENT print 0 + " ▁ " , NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def print_ ( cls , n ) : NEW_LINE INDENT print n + n / 2 NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT i += 2 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 2 NEW_LINE DEDENT i = 2 NEW_LINE while i <= n : NEW_LINE INDENT i += 2 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE cls . print_ ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT bfr = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE str_ = " " NEW_LINE try : NEW_LINE INDENT str_ = bfr . readLine ( ) NEW_LINE if str_ == " " : NEW_LINE INDENT System . exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = Long . parseLong ( str_ ) NEW_LINE while i < 1 : NEW_LINE INDENT han = ( res >> ruijyo ) % 2 NEW_LINE if han == 0 : NEW_LINE INDENT res = ( res % ni_beki ) + 1 NEW_LINE i = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT ni_beki = ni_beki * 2 NEW_LINE ruijyo += 1 NEW_LINE DEDENT DEDENT print res NEW_LINE DEDENT DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def equivalentBase4 ( cls , bin ) : NEW_LINE INDENT if bin . compareTo ( "00" ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if bin . compareTo ( "01" ) == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if bin . compareTo ( "10" ) == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT @ classmethod NEW_LINE def isDivisibleBy5 ( cls , bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if l % 2 != 0 : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE isOddDigit = 1 NEW_LINE i = 0 NEW_LINE while i < len ( bin ) : NEW_LINE INDENT if isOddDigit != 0 : NEW_LINE INDENT odd_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) NEW_LINE DEDENT isOddDigit ^= 1 NEW_LINE i += 2 NEW_LINE DEDENT if Math . abs ( odd_sum - even_sum ) % 5 == 0 : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT bin = "10000101001" NEW_LINE print cls . isDivisibleBy5 ( bin ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def fun ( cls , n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT n = 7 NEW_LINE print " The ▁ number ▁ after ▁ unsetting ▁ " + " the ▁ rightmost ▁ set ▁ bit ▁ " + cls . fun ( n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check ( cls , arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if Math . floor ( y ) == Math . ceil ( y ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if sum % x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = arr . length NEW_LINE x = 13 NEW_LINE if cls . check ( arr , x , n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def calculate_min_sum ( cls , a , n ) : NEW_LINE INDENT Arrays . sort ( a ) NEW_LINE min_sum = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT min_sum += Math . abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE i += 2 NEW_LINE DEDENT return min_sum NEW_LINE DEDENT @ classmethod NEW_LINE def calculate_max_sum ( cls , a , n ) : NEW_LINE INDENT Arrays . sort ( a ) NEW_LINE max_sum = 0 NEW_LINE i = 0 NEW_LINE while i < n / 2 : NEW_LINE INDENT max_sum += Math . abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = a . length NEW_LINE print " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + cls . calculate_min_sum ( a , n ) NEW_LINE print " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + cls . calculate_max_sum ( a , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . ArrayList NEW_LINE import java . util . Collections NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sum = int ( ) NEW_LINE sc = Scanner ( System . in_ ) NEW_LINE a = sc . nextInt ( ) NEW_LINE stateList = ArrayList ( ) NEW_LINE cnt4 = 0 NEW_LINE cnt2 = 0 NEW_LINE work = 0 NEW_LINE i = 0 NEW_LINE while i < a : NEW_LINE INDENT stateList . add ( sc . nextInt ( ) ) NEW_LINE work = stateList . get ( i ) % 4 NEW_LINE if work == 0 : NEW_LINE INDENT cnt4 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT work = stateList . get ( i ) % 2 NEW_LINE if work == 0 : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT work = a / 2 NEW_LINE if work <= cnt4 : NEW_LINE INDENT print " Yes " NEW_LINE return NEW_LINE DEDENT work = a - ( cnt4 * 2 ) NEW_LINE if ( work == 0 ) | ( cnt2 == 0 ) : NEW_LINE INDENT print " No " NEW_LINE return NEW_LINE DEDENT if work == cnt2 : NEW_LINE INDENT print " Yes " NEW_LINE return NEW_LINE DEDENT print " No " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPalindrome ( cls , s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s . charAt ( i ) != len ( s . charAt ( s ) - i - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def ans ( cls , s ) : NEW_LINE INDENT s2 = s NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT s2 = len ( s2 . charAt ( s2 ) - 1 ) + s2 NEW_LINE s2 = s2 . substring ( 0 , len ( s2 ) - 1 ) NEW_LINE if ( s2 != None if s == None else not s == s2 ) and cls . isPalindrome ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls , s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ None ] * 25 NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT cnt [ s . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT if Arrays . stream ( cnt ) . max ( ) . getAsInt ( ) >= len ( ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 if cls . ans ( s ) else 2 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " nolon " NEW_LINE print cls . solve ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GfG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minCost ( cls , n , arr , cost ) : NEW_LINE INDENT sum = 0 NEW_LINE totalCost = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT totalCost += cost * sum NEW_LINE arr [ n - 1 ] += sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = arr . length NEW_LINE cost = 1 NEW_LINE print cls . minCost ( n , arr , cost ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GfG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . LinkedList NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . teamFormationMake ( ) NEW_LINE return NEW_LINE DEDENT def teamFormationMake ( self ) : NEW_LINE INDENT bufferedReader = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE try : NEW_LINE INDENT while i < yearNum : NEW_LINE INDENT programmerList . add ( LinkedList ( ) ) NEW_LINE while j < teamStrs . length : NEW_LINE INDENT programmerList . get ( i ) . add ( Integer . parseInt ( teamStrs [ j ] ) ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < yearNum : NEW_LINE INDENT while True : NEW_LINE INDENT if c >= 1 and a >= 1 and n >= 1 : NEW_LINE INDENT teamNum += 1 NEW_LINE c -= 1 NEW_LINE a -= 1 NEW_LINE n -= 1 NEW_LINE DEDENT elif c >= 2 and a >= 1 : NEW_LINE INDENT teamNum += 1 NEW_LINE c = c - 2 NEW_LINE a -= 1 NEW_LINE DEDENT elif c >= 3 : NEW_LINE INDENT teamNum += 1 NEW_LINE c = c - 3 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print teamNum NEW_LINE teamNum = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE left = Node ( ) NEW_LINE right = Node ( ) NEW_LINE def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = right = None NEW_LINE DEDENT DEDENT class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def insert ( cls , root , data ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT if data > root . data : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT @ classmethod NEW_LINE def inOrder ( cls , root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT cls . inOrder ( root . left ) NEW_LINE print root . data + " ▁ " , NEW_LINE cls . inOrder ( root . right ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE n = arr . length NEW_LINE root = None NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT root = insert ( root , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT cls . inOrder ( root ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE @ classmethod NEW_LINE def removeChars ( cls , str_ , k ) : NEW_LINE INDENT hash = [ None ] * MAX_CHAR NEW_LINE n = len ( str_ ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT hash [ str_ . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT res = " " NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if hash [ str_ . charAt ( i ) - ' a ' ] >= k : NEW_LINE INDENT res += str_ . charAt ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print cls . removeChars ( str_ , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class LongestCommonSubSequence ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def LCSubStr ( cls , X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ None ] * m + 1 NEW_LINE result = 0 NEW_LINE i = 0 NEW_LINE while i <= m : NEW_LINE INDENT while j <= n : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = Integer . max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT X = " OldSite : GeeksforGeeks . org " NEW_LINE Y = " NewSite : GeeksQuiz . com " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ▁ " + cls . LCSubStr ( X . toCharArray ( ) , Y . toCharArray ( ) , m , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE LongestCommonSubSequence . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class A1452 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE t = scanner . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT a [ 0 ] = scanner . nextInt ( ) NEW_LINE a [ 1 ] = scanner . nextInt ( ) NEW_LINE Arrays . sort ( a ) NEW_LINE if a [ 0 ] == a [ 1 ] : NEW_LINE INDENT print 2 * a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT print 2 * a [ 1 ] - 1 NEW_LINE DEDENT DEDENT scanner . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A1452 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def reverse ( cls , str_ , x ) : NEW_LINE INDENT n = len ( ( str_ ) - x ) / 2 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = n + x - 1 NEW_LINE while i >= n : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT i = n + x NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE cls . reverse ( str_ , x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def lps ( cls , str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE L = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT cl = 2 NEW_LINE while cl <= n : NEW_LINE INDENT while i < n - cl + 1 : NEW_LINE INDENT if str_ . charAt ( i ) == str_ . charAt ( j ) and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str_ . charAt ( i ) == str_ . charAt ( j ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = Integer . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT cl += 1 NEW_LINE DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def minimumNumberOfDeletions ( cls , str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE len = cls . lps ( str_ ) NEW_LINE return ( n - len ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE print " Minimum ▁ number ▁ " + " of ▁ deletions ▁ = ▁ " + cls . minimumNumberOfDeletions ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def bit_check ( cls , n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 14 NEW_LINE if cls . bit_check ( n ) : NEW_LINE INDENT print '1' NEW_LINE DEDENT else : NEW_LINE INDENT print '0' NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class p187 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p187 ( ) . run ( ) NEW_LINE DEDENT LIMIT = Library . pow ( 10 , 8 ) - 1 NEW_LINE def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE primes = Library . listPrimes ( self . LIMIT / 2 ) NEW_LINE i = 0 NEW_LINE sqrt = Library . sqrt ( self . LIMIT ) NEW_LINE while i < primes . length and primes [ i ] <= sqrt : NEW_LINE INDENT if end >= 0 : NEW_LINE INDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = - end - 1 NEW_LINE DEDENT count += end - i NEW_LINE i += 1 NEW_LINE DEDENT return Integer . toString ( count ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p187 . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def index ( cls , i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT @ classmethod NEW_LINE def check ( cls , n ) : NEW_LINE INDENT s = [ " negative " , " zero " , " positive " ] NEW_LINE val = cls . index ( n ) NEW_LINE print n + " ▁ is ▁ " + s [ val ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . check ( 30 ) NEW_LINE cls . check ( - 20 ) NEW_LINE cls . check ( 0 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPrime ( cls , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def isThreeDisctFactors ( cls , n ) : NEW_LINE INDENT sq = ( Math . sqrt ( n ) ) NEW_LINE if 1 L * sq * sq != n : NEW_LINE INDENT return False NEW_LINE DEDENT return True if cls . isPrime ( sq ) else False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = 9 NEW_LINE if cls . isThreeDisctFactors ( num ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT num = 15 NEW_LINE if cls . isThreeDisctFactors ( num ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT num = 12397923568441 L NEW_LINE if cls . isThreeDisctFactors ( num ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigInteger NEW_LINE class p065 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p065 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT n = BigInteger . ONE NEW_LINE d = BigInteger . ZERO NEW_LINE i = 99 NEW_LINE while i >= 0 : NEW_LINE INDENT d = n NEW_LINE n = temp NEW_LINE i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE while not n == BigInteger . ZERO : NEW_LINE INDENT sum += divrem [ 1 ] . intValue ( ) NEW_LINE n = divrem [ 0 ] NEW_LINE DEDENT return Integer . toString ( sum ) NEW_LINE DEDENT @ classmethod NEW_LINE def continuedFractionTerm ( cls , i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif i % 3 == 2 : NEW_LINE INDENT return i / 3 * 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p065 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT MAXN = 100001 NEW_LINE prime = [ None ] * MAXN NEW_LINE @ classmethod NEW_LINE def SieveOfEratosthenes ( cls ) : NEW_LINE INDENT i = 0 NEW_LINE while i < prime . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT cls . prime [ 0 ] = False NEW_LINE cls . prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p < MAXN : NEW_LINE INDENT if cls . prime [ p ] == True : NEW_LINE INDENT while i < MAXN : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def common_prime ( cls , a , b ) : NEW_LINE INDENT gcd = ( __gcd ( a , b ) ) NEW_LINE i = 2 NEW_LINE while i <= ( gcd ) : NEW_LINE INDENT if cls . prime [ i ] and gcd % i == 0 : NEW_LINE INDENT print i + " ▁ " , NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return cls . __gcd ( b % a , a ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . SieveOfEratosthenes ( ) NEW_LINE a = 6 NEW_LINE b = 12 NEW_LINE cls . common_prime ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT N = 205 NEW_LINE M = 205 NEW_LINE grid = [ None ] * N NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT solve ( sc ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def solve ( cls , sc ) : NEW_LINE INDENT n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < m : NEW_LINE INDENT cls . grid [ i ] [ j ] = line . charAt ( j ) - '0' NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT while j < m - 1 : NEW_LINE INDENT if sum == 3 : NEW_LINE INDENT print " NO " NEW_LINE return NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " YES " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE tc = 1 NEW_LINE __tc_0 = tc NEW_LINE tc -= 1 NEW_LINE while __tc_0 > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT s = sc . next ( ) NEW_LINE len [ i ] = len ( s ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( len ) NEW_LINE while i < n : NEW_LINE INDENT if len [ i ] == plen : NEW_LINE INDENT min += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE min += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE min += 5 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT k = kk NEW_LINE while i < n - 1 : NEW_LINE INDENT if ( len [ i ] == plen and len [ i + 1 ] > plen ) : NEW_LINE INDENT max += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE max += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE max += 5 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if len [ n - 1 ] == plen : NEW_LINE INDENT max += 1 NEW_LINE DEDENT print min + " ▁ " + max NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . HashSet NEW_LINE import java . util . Scanner NEW_LINE import java . util . Set NEW_LINE class A ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE cases = sc . nextInt ( ) NEW_LINE caze = 1 NEW_LINE while caze <= cases : NEW_LINE INDENT while i < N : NEW_LINE INDENT while j < L : NEW_LINE INDENT j += 1 NEW_LINE DEDENT have . add ( tmp2 ) NEW_LINE i += 1 NEW_LINE DEDENT while i < N : NEW_LINE INDENT while j < L : NEW_LINE INDENT j += 1 NEW_LINE DEDENT need . add ( tmp2 ) NEW_LINE lastNeeded = tmp2 NEW_LINE i += 1 NEW_LINE DEDENT for elem in have : NEW_LINE INDENT for e in need : NEW_LINE INDENT got . add ( e ^ flip ) NEW_LINE DEDENT if got == have : NEW_LINE INDENT ans = Math . min ( ans , Long . bitCount ( flip ) ) NEW_LINE DEDENT DEDENT print " Case ▁ # " + caze + " : ▁ " + ( " NOT ▁ POSSIBLE " if ans > L else ans ) NEW_LINE caze += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Stack NEW_LINE class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT dr = [ None ] * NEW_LINE dc = [ None ] * NEW_LINE ans = 0 NEW_LINE r0 = 0 NEW_LINE while r0 < grid . length : NEW_LINE INDENT while c0 < grid [ 0 ] . length : NEW_LINE INDENT if grid [ r0 ] [ c0 ] == 1 : NEW_LINE INDENT stack . push ( [ None ] * ) NEW_LINE grid [ r0 ] [ c0 ] = 0 NEW_LINE while not stack . empty ( ) : NEW_LINE INDENT shape += 1 NEW_LINE while k < 4 : NEW_LINE INDENT if 0 <= nr and nr < grid . length and 0 <= nc and nc < grid [ 0 ] . length and grid [ nr ] [ nc ] == 1 : NEW_LINE INDENT stack . push ( [ None ] * ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT ans = Math . max ( ans , shape ) NEW_LINE DEDENT c0 += 1 NEW_LINE DEDENT r0 += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE grid = [ ] NEW_LINE out = sObj . maxAreaOfIsland ( grid ) NEW_LINE print out NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sum ( cls , x , y , n ) : NEW_LINE INDENT sum1 = ( ( ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ) ) NEW_LINE sum2 = ( ( ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 2 NEW_LINE y = 2 NEW_LINE n = 2 NEW_LINE print cls . sum ( x , y , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE next = Node ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def push ( cls , head_ref , new_data ) : NEW_LINE INDENT new_node = cls . Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT @ classmethod NEW_LINE def isPrime ( cls , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def deleteNonPrimeNodes ( cls , head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ptr != None and not cls . isPrime ( ptr . data ) : NEW_LINE INDENT ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if ptr == None : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while curr != None : NEW_LINE INDENT if not cls . isPrime ( curr . data ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT return head_ref NEW_LINE DEDENT @ classmethod NEW_LINE def printList ( cls , head ) : NEW_LINE INDENT while head != None : NEW_LINE INDENT print head . data + " ▁ " , NEW_LINE head = head . next NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE print " Original ▁ List : ▁ " , NEW_LINE cls . printList ( head ) NEW_LINE head = deleteNonPrimeNodes ( head ) NEW_LINE print " \n Modified ▁ List : ▁ " , NEW_LINE cls . printList ( head ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minReplacement ( cls , str_ ) : NEW_LINE INDENT if len ( str_ ) > 26 : NEW_LINE INDENT print " IMPOSSIBLE " NEW_LINE DEDENT else : NEW_LINE INDENT while i < len ( str_ ) : NEW_LINE INDENT hash [ str_ . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT while i < len ( str_ ) : NEW_LINE INDENT if hash [ str_ . charAt ( i ) - ' a ' ] > 1 : NEW_LINE INDENT while j < 26 : NEW_LINE INDENT if hash [ j ] == 0 : NEW_LINE INDENT hash [ str_ . charAt ( i ) - ' a ' ] -= 1 NEW_LINE str_ = str_ . substring ( 0 , i ) + ( ( j + ' a ' ) ) + str_ . substring ( i + 1 ) NEW_LINE hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print str_ NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " xxxxyyyy " NEW_LINE cls . minReplacement ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longestSubseq ( cls , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ None ] * n + 2 NEW_LINE pre_count_1 = [ None ] * n + 1 NEW_LINE post_count_0 = [ None ] * n + 2 NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE j = 1 NEW_LINE while j <= n : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if s . charAt ( j - 1 ) == '0' : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if s . charAt ( n - j ) == '0' : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = "000011100000" NEW_LINE print cls . longestSubseq ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sieveOfEratosthenes ( cls , N , s ) : NEW_LINE INDENT prime = [ None ] * N + 1 NEW_LINE i = 2 NEW_LINE while i <= N : NEW_LINE INDENT i += 2 NEW_LINE DEDENT i = 3 NEW_LINE while i <= N : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s [ i ] = i NEW_LINE while j * i <= N : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT j += 2 NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def generatePrimeFactors ( cls , N ) : NEW_LINE INDENT s = [ None ] * N + 1 NEW_LINE cls . sieveOfEratosthenes ( N , s ) NEW_LINE print " Factor ▁ Power " NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N /= s [ N ] NEW_LINE if curr == s [ N ] : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print curr + " \t " + cnt NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 360 NEW_LINE cls . generatePrimeFactors ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longestSubarray ( cls , a , n ) : NEW_LINE INDENT hash = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while num != 0 : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num /= 10 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT longest = Integer . MIN_VALUE NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT while j < 10 : NEW_LINE INDENT if hash [ i ] [ j ] == 1 & hash [ i + 1 ] [ j ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == 10 : NEW_LINE INDENT longest = Math . max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT longest = Math . max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = a . length NEW_LINE print cls . longestSubarray ( a , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Vector NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def Divisors ( cls , x ) : NEW_LINE INDENT c = 0 NEW_LINE v = Vector ( ) NEW_LINE while x % 2 == 0 : NEW_LINE INDENT c += 1 NEW_LINE x /= 2 NEW_LINE DEDENT v . add ( c ) NEW_LINE c = 0 NEW_LINE while x % 3 == 0 : NEW_LINE INDENT c += 1 NEW_LINE x /= 3 NEW_LINE DEDENT v . add ( c ) NEW_LINE c = 0 NEW_LINE while x % 7 == 0 : NEW_LINE INDENT c += 1 NEW_LINE x /= 7 NEW_LINE DEDENT v . add ( c ) NEW_LINE v . add ( x ) NEW_LINE return v NEW_LINE DEDENT @ classmethod NEW_LINE def MinOperations ( cls , a , b ) : NEW_LINE INDENT va = cls . Divisors ( a ) NEW_LINE vb = cls . Divisors ( b ) NEW_LINE if va . get ( 3 ) != vb . get ( 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = Math . abs ( va . get ( 0 ) - vb . get ( 0 ) ) + Math . abs ( va . get ( 1 ) - vb . get ( 1 ) ) + Math . abs ( va . get ( 2 ) - vb . get ( 2 ) ) NEW_LINE return minOperations NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 14 NEW_LINE b = 28 NEW_LINE print cls . MinOperations ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Scanner NEW_LINE import java . util . Arrays NEW_LINE class A ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def power ( cls , a ) : NEW_LINE INDENT res = 0 NEW_LINE while a > 0 : NEW_LINE INDENT res += 1 NEW_LINE a = a / 10 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def mult ( cls , a ) : NEW_LINE INDENT pow = cls . power ( a ) NEW_LINE max = 0 NEW_LINE j = 0 NEW_LINE while j < pow : NEW_LINE INDENT max = max * 10 + 9 NEW_LINE j += 1 NEW_LINE DEDENT return a * ( max - a ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE l = in_ . nextLong ( ) NEW_LINE r = in_ . nextLong ( ) NEW_LINE res = 0 NEW_LINE maxxes = [ None ] * 10 NEW_LINE temp = 0 NEW_LINE i = 0 NEW_LINE while i < 10 : NEW_LINE INDENT temp = temp * 10 + 9 NEW_LINE maxxes [ i ] = temp / 2 * ( temp - temp / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT res = Math . max ( mult ( l ) , res ) NEW_LINE res = Math . max ( mult ( r ) , res ) NEW_LINE temp = 0 NEW_LINE i = 0 NEW_LINE while i < 10 : NEW_LINE INDENT temp = temp * 10 + 9 NEW_LINE if l <= temp / 2 and temp / 2 <= r : NEW_LINE INDENT res = Math . max ( maxxes [ i ] , res ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , * args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT printArray ( a ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT while j >= 0 and a [ j ] > key : NEW_LINE INDENT a [ j + 1 ] = a [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT a [ j + 1 ] = key NEW_LINE printArray ( a ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def printArray ( cls , a ) : NEW_LINE INDENT i = 0 NEW_LINE while i < a . length - 1 : NEW_LINE INDENT print a [ i ] + " ▁ " , NEW_LINE i += 1 NEW_LINE DEDENT print a [ a . length - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = "111111101010101111100101001111111 ▁ 100000100000000001010110001000001 ▁ 101110100110110000011010001011101 ▁ 101110101011001001111101001011101 ▁ 101110101100011000111100101011101 ▁ 100000101010101011010000101000001 ▁ 111111101010101010101010101111111 ▁ 000000001111101111100111100000000 ▁ 100010111100100001011110111111001 ▁ 110111001111111100100001000101100 ▁ 011100111010000101000111010001010 ▁ 011110000110001111110101100000011 ▁ 111111111111111000111001001011000 ▁ 111000010111010011010011010100100 ▁ 101010100010110010110101010000010 ▁ 101100000101010001111101000000000 ▁ 000010100011001101000111101011010 ▁ 101001001111101111000101010001110 ▁ 101101111111000100100001110001000 ▁ 000010011000100110000011010000010 ▁ 001101101001101110010010011011000 ▁ 011101011010001000111101010100110 ▁ 111010100110011101001101000001110 ▁ 110001010010101111000101111111000 ▁ 001000111011100001010110111110000 ▁ 000000001110010110100010100010110 ▁ 111111101000101111000110101011010 ▁ 100000100111010101111100100011011 ▁ 101110101001010000101000111111000 ▁ 101110100011010010010111111011010 ▁ 101110100100011011110110101110000 ▁ 100000100110011001111100111100000 ▁ 111111101101000101001101110010001" NEW_LINE array = s . split ( " ▁ " ) NEW_LINE input = Scanner ( System . in_ ) NEW_LINE x = input . nextInt ( ) NEW_LINE y = input . nextInt ( ) NEW_LINE print array [ x ] . charAt ( y , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Test . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class NewClass37 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE p = 1 NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT print n NEW_LINE continue NEW_LINE DEDENT while x > 0 : NEW_LINE INDENT count += 1 NEW_LINE x /= 10 NEW_LINE DEDENT while count > 0 : NEW_LINE INDENT first = first * 10 + 1 NEW_LINE count -= 1 NEW_LINE DEDENT if first <= n : NEW_LINE INDENT sum += n / first NEW_LINE DEDENT first /= 10 NEW_LINE while first > 0 : NEW_LINE INDENT sum += 9 NEW_LINE first /= 10 NEW_LINE DEDENT print sum NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE NewClass37 . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE @ classmethod NEW_LINE def modFact ( cls , n , m ) : NEW_LINE INDENT result = 1 NEW_LINE i = 1 NEW_LINE while i <= m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE print cls . modFact ( n , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . IOException NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE w = scanner . nextInt ( ) NEW_LINE h = scanner . nextInt ( ) NEW_LINE map = [ None ] * h + 2 NEW_LINE v = [ None ] * h + 2 NEW_LINE i = 1 NEW_LINE while i <= h : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print slove ( 0 , 0 ) NEW_LINE DEDENT def slove ( self , y , x ) : NEW_LINE INDENT v [ y ] [ x ] = True NEW_LINE res = 0 NEW_LINE i = 0 NEW_LINE while i < 6 : NEW_LINE INDENT if not isOK ( ny , nx ) : NEW_LINE INDENT continue NEW_LINE DEDENT if map [ ny ] [ nx ] : NEW_LINE INDENT res += 1 NEW_LINE continue NEW_LINE DEDENT if v [ ny ] [ nx ] : NEW_LINE INDENT continue NEW_LINE DEDENT res += slove ( ny , nx ) NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def isOK ( self , ny , nx ) : NEW_LINE INDENT if 0 <= ny and ny <= h + 1 and 0 <= nx and nx <= w + 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT h = int ( ) NEW_LINE w = int ( ) NEW_LINE map = [ ] NEW_LINE v = [ ] NEW_LINE dy = [ - 1 , - 1 , 0 , 0 , 1 , 1 ] NEW_LINE dx1 = [ 0 , 1 , - 1 , 1 , 0 , 1 ] NEW_LINE dx2 = [ - 1 , 0 , - 1 , 1 , - 1 , 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . ArrayList NEW_LINE import java . util . StringTokenizer NEW_LINE class prepformerge ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE st = StringTokenizer ( br . readLine ( ) ) NEW_LINE n = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE lists = ArrayList ( ) NEW_LINE a = [ None ] * n + 1 NEW_LINE st = StringTokenizer ( br . readLine ( ) ) NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT a [ i ] = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT start . add ( a [ i ] ) NEW_LINE lists . add ( start ) NEW_LINE DEDENT else : NEW_LINE INDENT if lists . get ( hi ) . get ( lists . get ( hi ) . size ( ) - 1 ) > a [ i ] : NEW_LINE INDENT start . add ( a [ i ] ) NEW_LINE lists . add ( start ) NEW_LINE DEDENT else : NEW_LINE INDENT while lo != hi : NEW_LINE INDENT if lists . get ( mid ) . get ( lists . get ( mid ) . size ( ) - 1 ) < a [ i ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT lists . get ( lo ) . add ( a [ i ] ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for lis in lists : NEW_LINE INDENT while i < len ( lis ) : NEW_LINE INDENT print lis . get ( i , + " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE prepformerge . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def circlearea ( cls , a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ) NEW_LINE return A NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 8 NEW_LINE b = 10 NEW_LINE print cls . circlearea ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find ( cls , arr , length , s ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= ( Math . pow ( 2 , length ) ) : NEW_LINE INDENT while j < length : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if sum == s : NEW_LINE INDENT print " YES " NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " NO " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sum = 5 NEW_LINE array = [ - 1 , 2 , 4 , 121 ] NEW_LINE length = array . length NEW_LINE cls . find ( array , length , sum ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def K_String ( cls , s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT str_ = " " NEW_LINE i = 0 NEW_LINE while i < 26 : NEW_LINE INDENT if fre [ i ] % k == 0 : NEW_LINE INDENT while x != 0 : NEW_LINE INDENT str_ += ( ( i + ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return str_ NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print cls . K_String ( s , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigInteger NEW_LINE import java . util . ArrayDeque NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Collections NEW_LINE import java . util . HashMap NEW_LINE import java . util . PriorityQueue NEW_LINE import java . util . Scanner NEW_LINE import javax . xml . crypto . Data NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1.0 NEW_LINE while i < n : NEW_LINE INDENT while j < 24 : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] += dp [ i ] [ j ] * 1.0 / pp NEW_LINE dp [ i + 1 ] [ 0 ] += dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) NEW_LINE sum += j * dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while j < 25 : NEW_LINE INDENT sum += j * dp [ n ] [ j ] NEW_LINE j += 1 NEW_LINE DEDENT System . out . printf ( " % .20f \n " , sum ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . io . BufferedReader NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT br = None NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT line = br . readLine ( ) NEW_LINE lines = line . split ( " ▁ " ) NEW_LINE if N == 0 and K == 0 : NEW_LINE INDENT return NEW_LINE DEDENT line = br . readLine ( ) NEW_LINE lines = line . split ( " ▁ " ) NEW_LINE while i < K : NEW_LINE INDENT bloodAmt [ i ] = Integer . parseInt ( lines [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while i < N : NEW_LINE INDENT line = br . readLine ( ) NEW_LINE lines = line . split ( " ▁ " ) NEW_LINE while j < K : NEW_LINE INDENT bloodAmt [ j ] -= Integer . parseInt ( lines [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < K : NEW_LINE INDENT if bloodAmt [ i ] < 0 : NEW_LINE INDENT print " No " NEW_LINE break NEW_LINE DEDENT if i == K - 1 : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT except Exception as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxZeros ( cls , n ) : NEW_LINE INDENT if n == 0 or ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE setBit = 1 NEW_LINE prev = 0 NEW_LINE i = int ( ) NEW_LINE while i <= b * 8 : NEW_LINE INDENT prev += 1 NEW_LINE if ( n & setBit ) == setBit : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE i += 1 NEW_LINE DEDENT max0 = Integer . MIN_VALUE NEW_LINE cur = prev NEW_LINE j = i + 1 NEW_LINE while j <= b * 8 : NEW_LINE INDENT cur += 1 NEW_LINE if ( n & setBit ) == setBit : NEW_LINE INDENT if max0 < ( cur - prev - 1 ) : NEW_LINE INDENT max0 = cur - prev - 1 NEW_LINE DEDENT prev = cur NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE j += 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 549 NEW_LINE print cls . maxZeros ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT MAX = 1000 NEW_LINE @ classmethod NEW_LINE def replaceSpaces ( cls , str_ ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE while i < str_ . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while str_ [ i - 1 ] == ' ▁ ' : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return str_ NEW_LINE DEDENT index = new_length - 1 NEW_LINE new_str = str_ NEW_LINE str_ = [ None ] * new_length NEW_LINE j = i - 1 NEW_LINE while j >= 0 : NEW_LINE INDENT if new_str [ j ] == ' ▁ ' : NEW_LINE INDENT str_ [ index ] = '0' NEW_LINE str_ [ index - 1 ] = '2' NEW_LINE str_ [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT str_ [ index ] = new_str [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return str_ NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " Mr ▁ John ▁ Smith ▁ " . toCharArray ( ) NEW_LINE str_ = replaceSpaces ( str_ ) NEW_LINE i = 0 NEW_LINE while i < str_ . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class MainClass ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , agrs ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE a = sc . nextInt ( ) NEW_LINE b = sc . nextInt ( ) NEW_LINE if a == b : NEW_LINE INDENT print a * 10 + 1 + " ▁ " + ( a * 10 + 2 ) NEW_LINE DEDENT elif a + 1 == b : NEW_LINE INDENT print a + " ▁ " + b NEW_LINE DEDENT elif a + 1 == b * 10 : NEW_LINE INDENT print a + " ▁ " + b * 10 NEW_LINE DEDENT else : NEW_LINE INDENT print - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE MainClass . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class B940 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE N = in_ . nextInt ( ) NEW_LINE K = in_ . nextInt ( ) NEW_LINE A = in_ . nextInt ( ) NEW_LINE B = in_ . nextInt ( ) NEW_LINE cost = 0 NEW_LINE while N != 1 : NEW_LINE INDENT if N < K : NEW_LINE INDENT cost += ( N - 1 ) * A NEW_LINE break NEW_LINE DEDENT cost += r * A NEW_LINE N -= r NEW_LINE if B >= ( N - N / K ) * A : NEW_LINE INDENT cost += ( N - 1 ) * A NEW_LINE break NEW_LINE DEDENT cost += B NEW_LINE N /= K NEW_LINE DEDENT print cost NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE B940 . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def smallestPermute ( cls , n ) : NEW_LINE INDENT res = [ None ] * n + 1 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res [ i ] = ( ( 48 + i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = ( ( 48 + i ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while i < n - 2 : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res [ i ] = ( ( 48 + i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = ( ( 48 + i ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT res [ n - 1 ] = ( ( 48 + n - 2 ) ) NEW_LINE res [ n - 2 ] = ( ( 48 + n ) ) NEW_LINE res [ n - 3 ] = ( ( 48 + n - 1 ) ) NEW_LINE DEDENT res [ n ] = ' \0' NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT print res [ i ] , NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 7 NEW_LINE cls . smallestPermute ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE k = in_ . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT if B == 1 : NEW_LINE INDENT print " NO " NEW_LINE DEDENT else : NEW_LINE INDENT print " YES " NEW_LINE print A + " ▁ " + A * B + " ▁ " + ( B + 1 ) * A NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findMaxValue ( cls , arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print " The ▁ array ▁ should ▁ have " + " ▁ atleast ▁ 4 ▁ elements " NEW_LINE DEDENT table1 = [ None ] * n + 1 NEW_LINE table2 = [ None ] * n NEW_LINE table3 = [ None ] * n - 1 NEW_LINE table4 = [ None ] * n - 2 NEW_LINE Arrays . fill ( table1 , Integer . MIN_VALUE ) NEW_LINE Arrays . fill ( table2 , Integer . MIN_VALUE ) NEW_LINE Arrays . fill ( table3 , Integer . MIN_VALUE ) NEW_LINE Arrays . fill ( table4 , Integer . MIN_VALUE ) NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT i = n - 3 NEW_LINE while i >= 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT i = n - 4 NEW_LINE while i >= 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = arr . length NEW_LINE print cls . findMaxValue ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def diagonalsMinMax ( cls , mat ) : NEW_LINE INDENT n = mat . length NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT if i == j : NEW_LINE INDENT if mat [ i ] [ j ] < principalMin : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if mat [ i ] [ j ] > principalMax : NEW_LINE INDENT principalMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i + j ) == ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] < secondaryMin : NEW_LINE INDENT secondaryMin = mat [ i ] [ j ] NEW_LINE DEDENT if mat [ i ] [ j ] > secondaryMax : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin NEW_LINE print " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax NEW_LINE print " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin NEW_LINE print " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT matrix = [ ] NEW_LINE cls . diagonalsMinMax ( matrix ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def diagonalsMinMax ( cls , mat ) : NEW_LINE INDENT n = mat . length NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if mat [ i ] [ i ] < principalMin : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if mat [ i ] [ i ] > principalMax : NEW_LINE INDENT principalMax = mat [ i ] [ i ] NEW_LINE DEDENT if mat [ n - 1 - i ] [ i ] < secondaryMin : NEW_LINE INDENT secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT if mat [ n - 1 - i ] [ i ] > secondaryMax : NEW_LINE INDENT secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin NEW_LINE print " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax NEW_LINE print " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin NEW_LINE print " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT matrix = [ ] NEW_LINE cls . diagonalsMinMax ( matrix ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def Vertices ( cls , x , y ) : NEW_LINE INDENT val = Math . abs ( x ) + Math . abs ( y ) NEW_LINE print val * ( - 1 if x < 0 else 1 , + " ▁ 0 ▁ " ) NEW_LINE print "0 ▁ " + val * ( - 1 if y < 0 else 1 , ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 3 NEW_LINE y = 3 NEW_LINE cls . Vertices ( x , y ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Vector NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def originalArray ( cls , greater , n ) : NEW_LINE INDENT temp = Vector ( ) NEW_LINE i = 0 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT arr = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT arr [ i ] = temp . get ( k ) NEW_LINE temp . remove ( k ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = Arr . length NEW_LINE cls . originalArray ( Arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT Arrays . sort ( heaters ) NEW_LINE result = Integer . MIN_VALUE NEW_LINE for house in houses : NEW_LINE INDENT if index < 0 : NEW_LINE INDENT index = - ( index + 1 ) NEW_LINE DEDENT result = Math . max ( result , Math . min ( dist1 , dist2 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE houses = [ 1 , 2 , 3 ] NEW_LINE heaters = [ 2 ] NEW_LINE out = sObj . findRadius ( houses , heaters ) NEW_LINE print out NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Solution . main ( sys . argv ) NEW_LINE DEDENT
class p130 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p130 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE found = 0 NEW_LINE i = 7 NEW_LINE while found < 25 : NEW_LINE INDENT if i % 5 != 0 and not Library . isPrime ( i ) and ( i - 1 ) % findLeastDivisibleRepunit ( i ) == 0 : NEW_LINE INDENT sum += i NEW_LINE found += 1 NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return Integer . toString ( sum ) NEW_LINE DEDENT @ classmethod NEW_LINE def findLeastDivisibleRepunit ( cls , n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > Integer . MAX_VALUE / 10 : NEW_LINE INDENT raise IllegalArgumentException ( " Arithmetic ▁ overflow " ) NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p130 . main ( sys . argv ) NEW_LINE DEDENT







class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countCubes ( cls , a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = a NEW_LINE while i <= b : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 7 NEW_LINE b = 30 NEW_LINE print " Count ▁ of ▁ Cubes ▁ is ▁ " + cls . countCubes ( a , b , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE oddList = [ None ] * 100001 NEW_LINE evenList = [ None ] * 100001 NEW_LINE i = 1 NEW_LINE while i < n + 1 : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT oddList [ v ] += 1 NEW_LINE DEDENT if i % 2 == 0 : NEW_LINE INDENT evenList [ v ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT maxOdd = 0 NEW_LINE maxEven = 0 NEW_LINE secondmaxOdd = 0 NEW_LINE secondmaxEven = 0 NEW_LINE countOdd = 0 NEW_LINE countEven = 0 NEW_LINE i = 1 NEW_LINE while i < 100001 : NEW_LINE INDENT maxOdd = Math . max ( oddList [ i ] , maxOdd ) NEW_LINE maxEven = Math . max ( evenList [ i ] , maxEven ) NEW_LINE i += 1 NEW_LINE DEDENT oddnum = 0 NEW_LINE evennum = 0 NEW_LINE i = 1 NEW_LINE while i < 100001 : NEW_LINE INDENT if oddList [ i ] == maxOdd : NEW_LINE INDENT oddnum = i NEW_LINE countOdd += 1 NEW_LINE DEDENT if evenList [ i ] == maxEven : NEW_LINE INDENT evennum = i NEW_LINE countEven += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < 100001 : NEW_LINE INDENT if oddList [ i ] != maxOdd : NEW_LINE INDENT secondmaxOdd = Math . max ( oddList [ i ] , secondmaxOdd ) NEW_LINE DEDENT if evenList [ i ] != maxEven : NEW_LINE INDENT secondmaxEven = Math . max ( evenList [ i ] , secondmaxEven ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if countOdd >= 2 : NEW_LINE INDENT secondmaxOdd = maxOdd NEW_LINE DEDENT if countEven >= 2 : NEW_LINE INDENT secondmaxEven = maxEven NEW_LINE DEDENT i = 1 NEW_LINE while i < 100001 : NEW_LINE INDENT if oddList [ i ] == maxOdd : NEW_LINE INDENT oddnum = i NEW_LINE DEDENT if evenList [ i ] == maxEven : NEW_LINE INDENT evennum = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if oddnum == evennum : NEW_LINE INDENT if maxOdd > maxEven : NEW_LINE INDENT maxEven = secondmaxEven NEW_LINE DEDENT elif maxOdd < maxEven : NEW_LINE INDENT maxOdd = secondmaxOdd NEW_LINE DEDENT else : NEW_LINE INDENT maxEven = Math . max ( secondmaxOdd , secondmaxEven ) NEW_LINE DEDENT DEDENT ans = n - maxOdd - maxEven NEW_LINE print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def SubString ( cls , str_ , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " abcd " NEW_LINE cls . SubString ( str_ , len ( str_ ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPrime ( cls , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 2 NEW_LINE while i < n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def countPrimePosition ( cls , arr ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE n = arr . length NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 0 and cls . isPrime ( i ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if arr [ i ] == 1 and cls . isPrime ( i ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " Number ▁ of ▁ 0s ▁ = ▁ " + c0 NEW_LINE print " Number ▁ of ▁ 1s ▁ = ▁ " + c1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE cls . countPrimePosition ( arr ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printMinIndexChar ( cls , str_ , patt ) : NEW_LINE INDENT minIndex = Integer . MAX_VALUE NEW_LINE m = len ( str_ ) NEW_LINE n = len ( patt ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < m : NEW_LINE INDENT if patt . charAt ( i ) == str_ . charAt ( j ) and j < minIndex : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if minIndex != Integer . MAX_VALUE : NEW_LINE INDENT print " Minimum ▁ Index ▁ Character ▁ = ▁ " + str_ . charAt ( minIndex ) NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ character ▁ present " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE patt = " set " NEW_LINE cls . printMinIndexChar ( str_ , patt ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE n = scanner . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if b < a : NEW_LINE INDENT print " Happy ▁ Alex " NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " Poor ▁ Alex " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT io = Scanner ( System . in_ ) NEW_LINE n = io . nextInt ( ) NEW_LINE a = [ None ] * n + 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT a [ i ] = io . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = 1 NEW_LINE end = 0 NEW_LINE ans_p = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_p += Math . abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_p += Math . abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE i += 1 NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = - 1 NEW_LINE end = 0 NEW_LINE ans_m = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_m += Math . abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_m += Math . abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE i += 1 NEW_LINE DEDENT print Math . min ( ans_p , ans_m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class AAA ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def get_last_two_digit ( cls , N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT while i <= N : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE i += 1 NEW_LINE DEDENT return ( ans ) % 100 NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 1 NEW_LINE while N <= 10 : NEW_LINE INDENT N += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE AAA . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT binaryNumber = "1001" NEW_LINE print Integer . parseInt ( binaryNumber , 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT







class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check ( cls , s , k ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s . charAt ( i ) != s . charAt ( i % k ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def countCommonDivisors ( cls , a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE i = 1 NEW_LINE while i <= Math . min ( n , m ) : NEW_LINE INDENT if n % i == 0 and m % i == 0 : NEW_LINE INDENT if a . substring ( 0 , i ) == b . substring ( 0 , i ) : NEW_LINE INDENT if cls . check ( a , i ) and cls . check ( b , i ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT return ct NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = " xaxa " NEW_LINE b = " xaxaxaxa " NEW_LINE print cls . countCommonDivisors ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def max ( cls , a , b ) : NEW_LINE INDENT return a if ( a > b ) else b NEW_LINE DEDENT @ classmethod NEW_LINE def printknapSack ( cls , W , wt , val , n ) : NEW_LINE INDENT i = int ( ) NEW_LINE w = int ( ) NEW_LINE K = [ None ] * n + 1 NEW_LINE while i <= n : NEW_LINE INDENT while w <= W : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT w += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT res = K [ n ] [ W ] NEW_LINE print res NEW_LINE w = W NEW_LINE while i > 0 and res > 0 : NEW_LINE INDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print wt [ i - 1 ] + " ▁ " , NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = val . length NEW_LINE cls . printknapSack ( W , wt , val , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def larrgestPalindrome ( cls , n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT upper_limit *= 10 NEW_LINE upper_limit += 9 NEW_LINE i += 1 NEW_LINE DEDENT lower_limit = 1 + upper_limit / 10 NEW_LINE max_product = 0 NEW_LINE i = upper_limit NEW_LINE while i >= lower_limit : NEW_LINE INDENT while j >= lower_limit : NEW_LINE INDENT if product < max_product : NEW_LINE INDENT break NEW_LINE DEDENT while number != 0 : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number /= 10 NEW_LINE DEDENT if product == reverse and product > max_product : NEW_LINE INDENT max_product = product NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return max_product NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 2 NEW_LINE print cls . larrgestPalindrome ( n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check ( cls , dp , a ) : NEW_LINE INDENT start = 0 NEW_LINE end = dp . length - 1 NEW_LINE while True : NEW_LINE INDENT if dp [ start ] >= a : NEW_LINE INDENT return start NEW_LINE DEDENT elif dp [ end ] <= a : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT if start + 1 == end : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT if dp [ mid ] == a : NEW_LINE INDENT return mid NEW_LINE DEDENT elif dp [ mid ] > a : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT dp = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT dp [ i ] = 1000000001 NEW_LINE i += 1 NEW_LINE DEDENT dp [ 0 ] = a [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if dp [ i ] > 1000000000 : NEW_LINE INDENT print i NEW_LINE break NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print n NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class FastFoodRestaurant ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE test = sc . nextInt ( ) NEW_LINE __test_0 = test NEW_LINE test -= 1 NEW_LINE while __test_0 > 0 : NEW_LINE INDENT if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print 0 NEW_LINE DEDENT else : NEW_LINE INDENT if b > c and b > a : NEW_LINE INDENT a = b NEW_LINE b = k NEW_LINE DEDENT if c > b and c > a : NEW_LINE INDENT a = c NEW_LINE c = k NEW_LINE DEDENT if a >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if b >= 1 : NEW_LINE INDENT b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and c >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 and b >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 and c >= 1 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT print res NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE FastFoodRestaurant . main ( sys . argv ) NEW_LINE DEDENT



import java . util . HashMap NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT n = int ( ) NEW_LINE map = HashMap ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE m = Main ( sc ) NEW_LINE m . solve ( ) NEW_LINE sc . close ( ) NEW_LINE DEDENT def __init__ ( self , sc ) : NEW_LINE INDENT self . n = sc . nextInt ( ) NEW_LINE self . map = HashMap ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT self . map . replace ( a , self . map . get ( a ) + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def solve ( self ) : NEW_LINE INDENT max = Integer . MIN_VALUE NEW_LINE x = 0 NEW_LINE while x <= 1.0e+5 + 1 : NEW_LINE INDENT max = Math . max ( max , map . get ( x - 1 ) + map . get ( x ) + map . get ( x + 1 ) ) NEW_LINE x += 1 NEW_LINE DEDENT print max NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT m = Main ( ) NEW_LINE m . run ( ) NEW_LINE DEDENT sc = Scanner ( System . in_ ) NEW_LINE def run ( self ) : NEW_LINE INDENT n = self . sc . nextInt ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print " Hello ▁ World " NEW_LINE DEDENT else : NEW_LINE INDENT print a + b NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def extractMaximum ( cls , str_ ) : NEW_LINE INDENT num = 0 NEW_LINE res = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT if Character . isDigit ( str_ . charAt ( i ) ) : NEW_LINE INDENT num = num * 10 + ( str_ . charAt ( i ) - '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT res = Math . max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Math . max ( res , num ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = "100klh564abc365bg " NEW_LINE print cls . extractMaximum ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT max = 50009 NEW_LINE @ classmethod NEW_LINE def find_Indices ( cls , arr , n ) : NEW_LINE INDENT sum = [ None ] * max NEW_LINE index_1 = int ( ) NEW_LINE index_2 = int ( ) NEW_LINE index_3 = int ( ) NEW_LINE index = int ( ) NEW_LINE k = int ( ) NEW_LINE i = int ( ) NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT ans = - ( 1e15 ) NEW_LINE index_1 = index_2 = index_3 = - 1 NEW_LINE l = 0 NEW_LINE while l <= n : NEW_LINE INDENT index = 0 NEW_LINE while r <= n : NEW_LINE INDENT if sum [ r ] < vmin : NEW_LINE INDENT vmin = sum [ r ] NEW_LINE index = r NEW_LINE DEDENT if sum [ l ] + sum [ r ] - vmin > ans : NEW_LINE INDENT ans = sum [ l ] + sum [ r ] - vmin NEW_LINE index_1 = l NEW_LINE index_2 = index NEW_LINE index_3 = r NEW_LINE DEDENT r += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT print index_1 + " ▁ " + index_2 + " ▁ " + index_3 , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ - 1 , 2 , 3 ] NEW_LINE n = arr . length NEW_LINE cls . find_Indices ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printElements ( cls , arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE while i < n - 1 : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT print arr [ i ] + " ▁ " , NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEW_LINE n = arr . length NEW_LINE cls . printElements ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def valueofX ( cls , ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + ar [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT return sum / n NEW_LINE DEDENT else : NEW_LINE INDENT while i < n : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE i += 1 NEW_LINE DEDENT if ValueA < ValueB : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 1 , 3 , 7 ] NEW_LINE print cls . valueofX ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countNumber ( cls , N , S ) : NEW_LINE INDENT countElements = 0 NEW_LINE currSum = 0 NEW_LINE while currSum <= S : NEW_LINE INDENT currSum += N NEW_LINE N -= 1 NEW_LINE countElements += 1 NEW_LINE DEDENT return countElements NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = int ( ) NEW_LINE S = int ( ) NEW_LINE N = 5 NEW_LINE S = 11 NEW_LINE count = cls . countNumber ( N , S ) NEW_LINE print count NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def strmatch ( cls , str_ , pattern , n , m ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ None ] * n + 1 NEW_LINE i = 0 NEW_LINE while i < n + 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT lookup [ 0 ] [ 0 ] = True NEW_LINE j = 1 NEW_LINE while j <= m : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j <= m : NEW_LINE INDENT if pattern . charAt ( j - 1 ) == ' * ' : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE DEDENT elif pattern . charAt ( j - 1 ) == ' ? ' or str_ . charAt ( i - 1 ) == pattern . charAt ( j - 1 ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " baaabab " NEW_LINE pattern = " * * * * * ba * * * * * ab " NEW_LINE if cls . strmatch ( str_ , pattern , len ( str_ ) , len ( pattern ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE import java . util . SortedSet NEW_LINE import java . util . TreeSet NEW_LINE class Main ( object ) : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE N = 1000001 NEW_LINE p = [ None ] * N NEW_LINE Arrays . fill ( p , True ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i < N : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT while j < N : NEW_LINE INDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT while True : NEW_LINE INDENT if ( a | b ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT if p [ k ] and a % k == 0 : NEW_LINE INDENT a /= k NEW_LINE sa . add ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT k = 2 NEW_LINE while b > 1 : NEW_LINE INDENT if p [ k ] and b % k == 0 : NEW_LINE INDENT b /= k NEW_LINE sb . add ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT sa . remove ( pa ) NEW_LINE sb . remove ( pb ) NEW_LINE for x in sa : NEW_LINE INDENT pa -= x NEW_LINE DEDENT for x in sb : NEW_LINE INDENT pb -= x NEW_LINE DEDENT print " a " if pa > pb else " b " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( a ) NEW_LINE min = Integer . MAX_VALUE NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if sa < min : NEW_LINE INDENT min = sa NEW_LINE ans = a [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print a [ n - 1 ] + " ▁ " , NEW_LINE print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . io . IOException NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT n = int ( ) NEW_LINE A = int ( ) NEW_LINE B = int ( ) NEW_LINE C = [ None ] * 10000 NEW_LINE sb = StringBuilder ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE cls . n = scan . nextInt ( ) NEW_LINE cls . A = [ None ] * n NEW_LINE cls . B = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT cls . A [ i ] = scan . nextInt ( ) NEW_LINE cls . C [ cls . A [ i ] ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < 10000 : NEW_LINE INDENT cls . C [ i ] = C [ i - 1 ] + C [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i = cls . n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT cls . B [ cls . C [ cls . A [ i ] ] - 1 ] = A [ i ] NEW_LINE cls . C [ cls . A [ i ] ] -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT cls . sb . append ( cls . B [ i ] ) NEW_LINE cls . sb . append ( " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print cls . sb . __str__ ( ) + cls . B [ cls . n - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sumOfDigit ( cls , n , b ) : NEW_LINE INDENT unitDigit = int ( ) NEW_LINE sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n / b NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 50 NEW_LINE b = 2 NEW_LINE print cls . sumOfDigit ( n , b , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class codechef_submission ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE k = sc . nextInt ( ) NEW_LINE b = [ None ] * n NEW_LINE if n < k : NEW_LINE INDENT print n NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT b [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT d = [ None ] * n - 1 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT d [ i ] = b [ i + 1 ] - b [ i ] - 1 NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( d ) NEW_LINE sum = b [ b . length - 1 ] - b [ 0 ] + 1 NEW_LINE i = d . length - 1 NEW_LINE while i > d . length - 1 - ( k - 1 ) : NEW_LINE INDENT sum -= d [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE codechef_submission . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def onesComplement ( cls , n ) : NEW_LINE INDENT number_of_bits = ( ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ) + 1 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 22 NEW_LINE print cls . onesComplement ( n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class NewClass27 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while w % 2 == 0 : NEW_LINE INDENT w /= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT while h % 2 == 0 : NEW_LINE INDENT h /= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT if sheet >= n : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE NewClass27 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findPoint ( cls , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print " ( " + ( ( 2 * x2 - x1 ) ) + " , " + ( ( 2 * y2 - y1 ) ) + " ▁ ) " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 1 NEW_LINE y2 = 1 NEW_LINE cls . findPoint ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class A1569 ( object ) : NEW_LINE INDENT flag = bool ( ) NEW_LINE finals = int ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE cases = sc . nextInt ( ) NEW_LINE __cases_0 = cases NEW_LINE cases -= 1 NEW_LINE while __cases_0 > 0 : NEW_LINE INDENT cls . flag = False NEW_LINE while i < letters : NEW_LINE INDENT if ab . charAt ( i - 1 ) != ab . charAt ( i ) : NEW_LINE INDENT cls . flag = True NEW_LINE print i ( + " ▁ " ) + ( i + 1 ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if cls . flag == False : NEW_LINE INDENT print " - 1 ▁ " + " - 1" NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A1569 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def unsort ( cls , l , r , a , k ) : NEW_LINE INDENT if k < 1 or l + 1 == r : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) / 2 NEW_LINE temp = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE cls . unsort ( l , mid , a , k ) NEW_LINE cls . unsort ( mid , r , a , k ) NEW_LINE DEDENT @ classmethod NEW_LINE def arrayWithKCalls ( cls , n , k ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print " NO ▁ SOLUTION " , NEW_LINE return NEW_LINE DEDENT a = [ None ] * n + 1 NEW_LINE a [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT k -= 1 NEW_LINE cls . unsort ( 0 , n , a , k ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 10 NEW_LINE k = 17 NEW_LINE cls . arrayWithKCalls ( n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . io . IOException NEW_LINE import java . io . InputStream NEW_LINE import java . io . PrintWriter NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Collection NEW_LINE import java . util . Collections NEW_LINE import java . util . Comparator NEW_LINE import java . util . HashMap NEW_LINE import java . util . HashSet NEW_LINE import java . util . InputMismatchException NEW_LINE import java . util . PriorityQueue NEW_LINE import java . util . Random NEW_LINE import java . util . Scanner NEW_LINE import java . util . Stack NEW_LINE import java . util . TreeMap NEW_LINE import java . util . TreeSet NEW_LINE class CF427_1 ( object ) : NEW_LINE INDENT N = int ( ) NEW_LINE MOD = ( ( 1e9 + 7 ) ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE out = PrintWriter ( System . out ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT if n < a : NEW_LINE INDENT out . println ( " No " ) NEW_LINE continue NEW_LINE DEDENT if a == b : NEW_LINE INDENT if n % a == 0 : NEW_LINE INDENT out . println ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT out . println ( " No " ) NEW_LINE DEDENT continue NEW_LINE DEDENT if n > x * a : NEW_LINE INDENT out . println ( " Yes " ) NEW_LINE continue NEW_LINE DEDENT while low <= high : NEW_LINE INDENT if mid * a < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT if n > ( ans - 1 ) * b and n < ans * a : NEW_LINE INDENT out . println ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT out . println ( " Yes " ) NEW_LINE DEDENT DEDENT out . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE CF427_1 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def getsum ( cls , x ) : NEW_LINE INDENT return ( x * ( x + 1 ) ) / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def countJumps ( cls , n ) : NEW_LINE INDENT n = Math . abs ( n ) NEW_LINE ans = 0 NEW_LINE while cls . getsum ( ans ) < n or ( ( cls . getsum ( ans ) - n ) & 1 ) > 0 : NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 9 NEW_LINE print cls . countJumps ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 10 NEW_LINE @ classmethod NEW_LINE def lcs ( cls , dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if arr1 [ n - 1 ] == arr2 [ m - 1 ] : NEW_LINE INDENT ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 2 ] NEW_LINE n = arr1 . length NEW_LINE m = arr2 . length NEW_LINE dp = [ None ] * MAX NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print cls . lcs ( dp , arr1 , n , arr2 , m , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigDecimal NEW_LINE import java . text . DecimalFormat NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE N = scan . nextDouble ( ) NEW_LINE d = scan . nextDouble ( ) NEW_LINE x = scan . nextDouble ( ) NEW_LINE ans = BigDecimal ( "0.0" ) NEW_LINE while N > 0.5 : NEW_LINE INDENT ans = ans . add ( adnum ) NEW_LINE d = ( N + 1.0 ) * d / N + ( 5.0 * x ) / ( 2.0 * N ) NEW_LINE x = ( 1.0 + ( 2.0 / N ) ) * x NEW_LINE N -= 1 NEW_LINE DEDENT format = DecimalFormat ( " # . # " ) NEW_LINE format . setMinimumFractionDigits ( 20 ) NEW_LINE print format . format ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT





import java . lang . Math NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def fib ( cls , n ) : NEW_LINE INDENT phi = ( 1 + Math . sqrt ( 5 ) ) / 2 NEW_LINE return ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def calculateSum ( cls , l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE i = l NEW_LINE while i <= r : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT l = 4 NEW_LINE r = 8 NEW_LINE print cls . calculateSum ( l , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def fib ( cls , n ) : NEW_LINE INDENT phi = ( 1 + Math . sqrt ( 5 ) ) / 2 NEW_LINE return ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def calculateSum ( cls , l , r ) : NEW_LINE INDENT sum = cls . fib ( r + 2 ) - cls . fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT l = 4 NEW_LINE r = 8 NEW_LINE print cls . calculateSum ( l , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE a = scan . nextInt ( ) NEW_LINE b = scan . nextInt ( ) NEW_LINE ans = getNum ( a , b ) NEW_LINE print ans NEW_LINE DEDENT @ classmethod NEW_LINE def getNum ( cls , a , b ) : NEW_LINE INDENT reverseB = 0 NEW_LINE while b > 0 : NEW_LINE INDENT reverseB = reverseB * 10 + b % 10 NEW_LINE b /= 10 NEW_LINE DEDENT return a + reverseB NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . io . PrintWriter NEW_LINE import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE pw = PrintWriter ( System . out ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT Arrays . fill ( freq , 0 ) NEW_LINE while i < n : NEW_LINE INDENT freq [ s . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT while i < 26 : NEW_LINE INDENT while j < freq [ i ] : NEW_LINE INDENT tmp . append ( ( ( ' a ' + i ) ) + " " ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT if s . charAt ( i ) != tmp . charAt ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT pw . println ( count ) NEW_LINE DEDENT sc . close ( ) NEW_LINE pw . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sumAP ( cls , n , d ) : NEW_LINE INDENT n /= d NEW_LINE return ( n ) * ( 1 + n ) * d / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def sumMultiples ( cls , n ) : NEW_LINE INDENT n -= 1 NEW_LINE return cls . sumAP ( n , 2 ) + cls . sumAP ( n , 5 ) - cls . sumAP ( n , 10 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 20 NEW_LINE print cls . sumMultiples ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE t = scan . nextInt ( ) NEW_LINE while t > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT s = scan . nextInt ( ) NEW_LINE f = scan . nextInt ( ) NEW_LINE sum += f - s NEW_LINE i += 1 NEW_LINE DEDENT if t <= sum : NEW_LINE INDENT print " OK " NEW_LINE DEDENT else : NEW_LINE INDENT print t - sum NEW_LINE DEDENT t = scan . nextInt ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def fact ( cls , num ) : NEW_LINE INDENT fact = 1 NEW_LINE while num > 1 : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT @ classmethod NEW_LINE def catalan ( cls , n ) : NEW_LINE INDENT return cls . fact ( 2 * n ) / ( cls . fact ( n ) * cls . fact ( n + 1 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE i = int ( ) NEW_LINE k = int ( ) NEW_LINE while k < n : NEW_LINE INDENT while i < n : NEW_LINE INDENT if arr [ i ] < arr [ k ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print totalBST + " ▁ " , NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countWays ( cls , n , arr , len ) : NEW_LINE INDENT count = [ None ] * n + 1 NEW_LINE count [ 0 ] = 1 NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j < len : NEW_LINE INDENT if i - arr [ j ] >= 0 : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count [ n ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 3 , 5 ] NEW_LINE len = arr . length NEW_LINE n = 5 NEW_LINE print cls . countWays ( n , arr , len , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class CF709A ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE b = sc . nextInt ( ) NEW_LINE d = sc . nextInt ( ) NEW_LINE a = int ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE __n_0 = n NEW_LINE n -= 1 NEW_LINE while __n_0 > 0 : NEW_LINE INDENT a = sc . nextInt ( ) NEW_LINE if a <= b : NEW_LINE INDENT sum += a NEW_LINE DEDENT if sum > d : NEW_LINE INDENT sum = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print count NEW_LINE sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE CF709A . main ( sys . argv ) NEW_LINE DEDENT
class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def binarySearch ( cls , arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return cls . binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return cls . binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = int ( ) NEW_LINE key = int ( ) NEW_LINE n = arr . length NEW_LINE key = 10 NEW_LINE print " Index : ▁ " + cls . binarySearch ( arr , 0 , n , key ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def equal_xor_sum ( cls , arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if Sum == Xor : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = arr . length NEW_LINE cls . equal_xor_sum ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findPairs ( cls , arr , n ) : NEW_LINE INDENT cntEven = 0 NEW_LINE cntOdd = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT evenPairs = 0 NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) NEW_LINE oddPairs = 0 NEW_LINE oddPairs += ( cntEven * cntOdd ) NEW_LINE print " Odd ▁ pairs ▁ = ▁ " + oddPairs NEW_LINE print " Even ▁ pairs ▁ = ▁ " + evenPairs NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = arr . length NEW_LINE cls . findPairs ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT AOJ0181 ( ) . doIt ( ) NEW_LINE DEDENT class AOJ0181 ( object ) : NEW_LINE INDENT m = int ( ) NEW_LINE n = int ( ) NEW_LINE books = [ ] NEW_LINE def isPossible ( self , width ) : NEW_LINE INDENT w = 0 NEW_LINE cnt = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT w += books [ i ] NEW_LINE if self . books [ i ] > width : NEW_LINE INDENT return False NEW_LINE DEDENT if w > width : NEW_LINE INDENT cnt += 1 NEW_LINE w = books [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False if cnt > m else True NEW_LINE DEDENT def doIt ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT self . m = in_ . nextInt ( ) NEW_LINE self . n = in_ . nextInt ( ) NEW_LINE if self . n + self . m == 0 : NEW_LINE INDENT return NEW_LINE DEDENT self . books = [ None ] * n NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while right - left != 1 : NEW_LINE INDENT if self . isPossible ( next ) : NEW_LINE INDENT right = next NEW_LINE DEDENT else : NEW_LINE INDENT left = next NEW_LINE DEDENT DEDENT print right NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def getSingle ( cls , arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE common_bit_mask = int ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE i += 1 NEW_LINE DEDENT return ones NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = arr . length NEW_LINE print " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + cls . getSingle ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class CF_1447B_NumbersBox ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE count = scanner . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < count : NEW_LINE INDENT while j < arr . length : NEW_LINE INDENT arr [ j ] = scanner . nextInt ( ) NEW_LINE if arr [ j ] < 0 : NEW_LINE INDENT arr [ j ] = 0 - arr [ j ] NEW_LINE nagiviteTimes += 1 NEW_LINE sumNum += arr [ j ] NEW_LINE if minNum > arr [ j ] : NEW_LINE INDENT minNum = arr [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT sumNum += arr [ j ] NEW_LINE if minNum > arr [ j ] : NEW_LINE INDENT minNum = arr [ j ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT if nagiviteTimes % 2 == 0 : NEW_LINE INDENT print sumNum NEW_LINE DEDENT else : NEW_LINE INDENT print sumNum - minNum * 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE CF_1447B_NumbersBox . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class AP ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def makeAP ( cls , arr , n ) : NEW_LINE INDENT initial_term = int ( ) NEW_LINE common_difference = int ( ) NEW_LINE if n == 3 : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = arr . length NEW_LINE cls . makeAP ( arr , n ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countPairs ( cls , n ) : NEW_LINE INDENT count = 0 NEW_LINE x = 1 NEW_LINE while x < n : NEW_LINE INDENT while y <= n : NEW_LINE INDENT if ( y + x ) % ( y ^ x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 6 NEW_LINE print cls . countPairs ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class Solution ( object ) : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT count = [ None ] * 128 NEW_LINE for c in s . toCharArray ( ) : NEW_LINE INDENT count [ c ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v / 2 * 2 NEW_LINE if ans % 2 == 0 and v % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " abccccdd " NEW_LINE out = sObj . longestPalindrome ( s ) NEW_LINE print out NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def binomialCoeff ( cls , n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT i = 0 NEW_LINE while i < k : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def catalan ( cls , n ) : NEW_LINE INDENT c = cls . binomialCoeff ( 2 * n , n ) NEW_LINE return c / ( n + 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def findWays ( cls , n ) : NEW_LINE INDENT if ( n & 1 ) != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return cls . catalan ( n / 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 6 NEW_LINE print " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ " + n + " ▁ is ▁ " + cls . findWays ( 6 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . OutputStream NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStream NEW_LINE import java . io . PrintWriter NEW_LINE import java . util . StringTokenizer NEW_LINE import java . io . IOException NEW_LINE import java . io . BufferedReader NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . InputStream NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT inputStream = System . in_ NEW_LINE outputStream = System . out NEW_LINE in_ = InputReader ( inputStream ) NEW_LINE out = PrintWriter ( outputStream ) NEW_LINE solver = ATwoProblems ( ) NEW_LINE solver . solve ( 1 , in_ , out ) NEW_LINE out . close ( ) NEW_LINE DEDENT class ATwoProblems ( object ) : NEW_LINE INDENT def solve ( self , testNumber , in_ , out ) : NEW_LINE INDENT points = in_ . nextInt ( ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE a = in_ . nextInt ( ) NEW_LINE b = in_ . nextInt ( ) NEW_LINE ta = in_ . nextInt ( ) NEW_LINE tb = in_ . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT while j < t : NEW_LINE INDENT if points == a - i * ta + b - j * tb or ( points == 0 ) or points == a - ta * i or points == b - tb * j : NEW_LINE INDENT out . println ( " YES " ) NEW_LINE return NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT out . println ( " NO " ) NEW_LINE DEDENT DEDENT class InputReader ( object ) : NEW_LINE INDENT reader = BufferedReader ( ) NEW_LINE tokenizer = StringTokenizer ( ) NEW_LINE def __init__ ( self , stream ) : NEW_LINE INDENT self . reader = BufferedReader ( InputStreamReader ( stream ) , 32768 ) NEW_LINE self . tokenizer = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . tokenizer == None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . tokenizer = StringTokenizer ( reader . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT raise RuntimeException ( e ) NEW_LINE DEDENT DEDENT return self . tokenizer . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isSumOfPowersOfTwo ( cls , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 10 NEW_LINE if cls . isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT print " Yes " , NEW_LINE DEDENT else : NEW_LINE INDENT print " No " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxAverageOfPath ( cls , cost , N ) : NEW_LINE INDENT dp = [ None ] * N + 1 NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE i = 1 NEW_LINE while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j = 1 NEW_LINE while j < N : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ( dp [ N - 1 ] [ N - 1 ] ) / ( 2 * N - 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cost = [ ] NEW_LINE print cls . maxAverageOfPath ( cost , 3 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def waysToSplit ( cls , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ None ] * n NEW_LINE suffix = [ None ] * n NEW_LINE seen = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if seen [ s . charAt ( i ) - ' a ' ] == 0 : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ s . charAt ( i ) - ' a ' ] = 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < 26 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE i = n - 1 NEW_LINE while i >= 1 : NEW_LINE INDENT if seen [ s . charAt ( i ) - ' a ' ] == 0 : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ s . charAt ( i ) - ' a ' ] = 1 NEW_LINE i -= 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if prefix [ i ] == suffix [ i ] : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " ababa " NEW_LINE print cls . waysToSplit ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigInteger NEW_LINE class p121 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p121 ( ) . run ( ) NEW_LINE DEDENT TURNS = 15 NEW_LINE def run ( self ) : NEW_LINE INDENT ways = [ None ] * TURNS + 1 NEW_LINE ways [ 0 ] = [ None ] * NEW_LINE i = 1 NEW_LINE while i <= TURNS : NEW_LINE INDENT ways [ i ] = [ None ] * i + 1 NEW_LINE while j <= i : NEW_LINE INDENT if j < i : NEW_LINE INDENT temp = ways [ i - 1 ] [ j ] . multiply ( BigInteger . valueOf ( i ) ) NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT temp = temp . add ( ways [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT ways [ i ] [ j ] = temp NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT numer = BigInteger . ZERO NEW_LINE i = self . TURNS / 2 + 1 NEW_LINE while i <= TURNS : NEW_LINE INDENT i += 1 NEW_LINE DEDENT denom = Library . factorial ( self . TURNS + 1 ) NEW_LINE return denom . divide ( numer ) . __str__ ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p121 . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class Test ( object ) : NEW_LINE INDENT arr1 = [ None ] * NEW_LINE arr2 = [ None ] * NEW_LINE @ classmethod NEW_LINE def merge ( cls , m , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT while j >= 0 and cls . arr1 [ j ] > arr2 [ i ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j != m - 2 or last > arr2 [ i ] : NEW_LINE INDENT cls . arr1 [ j + 1 ] = arr2 [ i ] NEW_LINE cls . arr2 [ i ] = last NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . merge ( cls . arr1 . length , cls . arr2 . length ) NEW_LINE print " After ▁ Merging ▁ \n First ▁ Array : ▁ " , NEW_LINE print Arrays . toString ( cls . arr1 ) NEW_LINE print " Second ▁ Array : ▁ " , NEW_LINE print Arrays . toString ( cls . arr2 ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def gcd ( cls , a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return cls . gcd ( b % a , a ) NEW_LINE DEDENT @ classmethod NEW_LINE def sameRemainder ( cls , a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return cls . gcd ( a1 , cls . gcd ( b1 , c1 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 237 NEW_LINE print cls . sameRemainder ( a , b , c ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT dp = [ None ] * 5001 NEW_LINE @ classmethod NEW_LINE def countWaysUtil ( cls , n , parts , nextPart ) : NEW_LINE INDENT if parts == 0 and n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n <= 0 or parts <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if cls . dp [ n ] [ nextPart ] [ parts ] != - 1 : NEW_LINE INDENT return cls . dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE i = nextPart NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ( cls . dp [ n ] [ nextPart ] [ parts ] = ans ) NEW_LINE DEDENT @ classmethod NEW_LINE def countWays ( cls , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < 5001 : NEW_LINE INDENT while j < 5001 : NEW_LINE INDENT while l < 5 : NEW_LINE INDENT l += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cls . countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 8 NEW_LINE print cls . countWays ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find_k ( cls , a , b ) : NEW_LINE INDENT if ( a + b ) % 2 == 0 : NEW_LINE INDENT return ( ( a + b ) / 2 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 16 NEW_LINE print cls . find_k ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT N = 101 NEW_LINE mod = ( 1e9 ) + 7 NEW_LINE exactsum = [ None ] * N NEW_LINE exactnum = [ None ] * N NEW_LINE @ classmethod NEW_LINE def getSum ( cls , x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE cls . exactnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE i = 0 NEW_LINE while i <= x : NEW_LINE INDENT while j <= y : NEW_LINE INDENT while k <= z : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT cls . exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod NEW_LINE cls . exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT cls . exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod NEW_LINE cls . exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT cls . exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod NEW_LINE cls . exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod NEW_LINE ans %= mod NEW_LINE k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 1 NEW_LINE y = 1 NEW_LINE z = 1 NEW_LINE print cls . getSum ( x , y , z ) % mod NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT CHARS = 26 NEW_LINE @ classmethod NEW_LINE def isValidString ( cls , str_ ) : NEW_LINE INDENT freq = [ None ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT freq [ str_ . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = int ( ) NEW_LINE freq1 = 0 NEW_LINE count_freq1 = 0 NEW_LINE while i < CHARS : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j = int ( ) NEW_LINE freq2 = 0 NEW_LINE count_freq2 = 0 NEW_LINE while j < CHARS : NEW_LINE INDENT if freq [ j ] != 0 : NEW_LINE INDENT if freq [ j ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT k = j + 1 NEW_LINE while k < CHARS : NEW_LINE INDENT if freq [ k ] != 0 : NEW_LINE INDENT if freq [ k ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if freq [ k ] == freq2 : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if count_freq1 > 1 and count_freq2 > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " abcbc " NEW_LINE if cls . isValidString ( str_ ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findMinimumSubsequences ( cls , A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < 26 : NEW_LINE INDENT while j < sizeOfB : NEW_LINE INDENT next [ i ] [ j ] = inf NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < sizeOfB : NEW_LINE INDENT next [ B . charAt ( i ) - ' a ' ] [ i ] = i NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < 26 : NEW_LINE INDENT while j >= 0 : NEW_LINE INDENT if next [ i ] [ j ] == inf : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while i < sizeOfA : NEW_LINE INDENT if pos == 0 and next [ A . charAt ( i ) - ' a ' ] [ pos ] == inf : NEW_LINE INDENT numberOfSubsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif pos < sizeOfB and next [ A . charAt ( i ) - ' a ' ] [ pos ] < inf : NEW_LINE INDENT pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT A = " aacbe " NEW_LINE B = " aceab " NEW_LINE print cls . findMinimumSubsequences ( A , B , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . FileReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE import java . util . Comparator NEW_LINE import java . util . HashMap NEW_LINE import java . util . HashSet NEW_LINE import java . util . Iterator NEW_LINE import java . util . List NEW_LINE class Algorithm ( object ) : NEW_LINE INDENT ans = 0 NEW_LINE @ classmethod NEW_LINE def main ( cls , rgs ) : NEW_LINE INDENT bufferedReader = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE stringBuilder = StringBuilder ( ) NEW_LINE t = Integer . parseInt ( bufferedReader . readLine ( ) ) NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE __p_0 = p NEW_LINE p += 1 NEW_LINE INDENT while j < row : NEW_LINE INDENT while k < col : NEW_LINE INDENT while l < 4 : NEW_LINE INDENT dis = Math . max ( dis , Math . abs ( rowarray [ l ] - j ) + Math . abs ( colarray [ l ] - k ) ) NEW_LINE l += 1 NEW_LINE DEDENT ansarray [ __p_0 ] = dis NEW_LINE k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT Arrays . sort ( ansarray ) NEW_LINE while j < ansarray . length : NEW_LINE INDENT cls . ans . append ( ansarray [ j ] ) . append ( " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT stringBuilder . append ( cls . ans ) . append ( " \n " ) NEW_LINE i += 1 NEW_LINE DEDENT print stringBuilder NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Algorithm . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Comparator NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE h = sc . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE b = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE b [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( a ) NEW_LINE Arrays . sort ( b ) NEW_LINE Arrays . sort ( b , Comparator . reverseOrder ( ) ) NEW_LINE ans = Integer . MAX_VALUE NEW_LINE i = 0 NEW_LINE while i <= n : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT h -= b [ i - 1 ] NEW_LINE DEDENT if h > 0 : NEW_LINE INDENT cnt = ( h + a [ n - 1 ] - 1 ) / a [ n - 1 ] NEW_LINE DEDENT ans = Math . min ( ans , cnt + i ) NEW_LINE i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class Digits ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def firstkdigits ( cls , n , k ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( ( product / Math . pow ( 10 , k ) ) ) != 0 : NEW_LINE return product NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 15 NEW_LINE k = 4 NEW_LINE print cls . firstkdigits ( n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Digits . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE s = sc . next ( ) NEW_LINE a = [ None ] * 26 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT a [ s . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < 26 : NEW_LINE INDENT sum += a [ i ] % 2 NEW_LINE i += 1 NEW_LINE DEDENT print sum / 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countUnsetBits ( cls , n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return Integer . bitCount ( x ^ n ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 17 NEW_LINE print cls . countUnsetBits ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minOperations ( cls , arr , n ) : NEW_LINE INDENT maxi = int ( ) NEW_LINE result = 0 NEW_LINE freq = [ None ] * 1000001 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT freq [ x ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) NEW_LINE i = 1 NEW_LINE while i <= maxi : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT while j <= maxi : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE j = j + i NEW_LINE DEDENT result += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = arr . length NEW_LINE print cls . minOperations ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE s = sc . next ( ) . toCharArray ( ) NEW_LINE x = 0 NEW_LINE max = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT max = Math . max ( max , x ) NEW_LINE i += 1 NEW_LINE DEDENT print max NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT arr = [ 1 , 5 , 6 ] NEW_LINE @ classmethod NEW_LINE def countWays ( cls , N ) : NEW_LINE INDENT count = [ None ] * N + 1 NEW_LINE count [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i <= N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return count [ N ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 7 NEW_LINE print " Total ▁ number ▁ of ▁ ways ▁ = ▁ " + cls . countWays ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countFreq ( cls , a , n ) : NEW_LINE INDENT hm = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if hm [ a [ i ] ] != 0 : NEW_LINE INDENT print a [ i ] + " - > " + cumul NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = a . length NEW_LINE cls . countFreq ( a , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT alphabets = " abcdefghijklmnopqrstuvwxyz " . toCharArray ( ) NEW_LINE @ classmethod NEW_LINE def conversion ( cls , charSet , str1 ) : NEW_LINE INDENT s2 = " " NEW_LINE for i in str1 : NEW_LINE INDENT s2 += alphabets [ charSet . indexOf ( i ) ] NEW_LINE DEDENT return s2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT charSet = " qwertyuiopasdfghjklzxcvbnm " NEW_LINE str1 = " egrt " NEW_LINE print cls . conversion ( charSet , str1 . toCharArray ( , ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def product ( cls , x ) : NEW_LINE INDENT prod = 1 NEW_LINE while x > 0 : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x /= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT @ classmethod NEW_LINE def findNumber ( cls , l , r ) : NEW_LINE INDENT b = Integer . toString ( r ) NEW_LINE ans = r NEW_LINE i = 0 NEW_LINE while i < len ( b ) : NEW_LINE INDENT if b . charAt ( i ) == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT curr [ i ] = ( ( ( ( ( curr [ i ] - ( '0' ) ) ) - 1 ) + ( ( '0' ) ) ) ) NEW_LINE while j < curr . length : NEW_LINE INDENT j += 1 NEW_LINE DEDENT while j < curr . length : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if num >= l and cls . product ( ans ) < product ( num ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE print cls . findNumber ( l , r ) NEW_LINE l = 51 NEW_LINE r = 62 NEW_LINE print cls . findNumber ( l , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 100005 NEW_LINE isPrime = [ None ] * MAX NEW_LINE @ classmethod NEW_LINE def sieveOfEratostheneses ( cls ) : NEW_LINE INDENT cls . isPrime [ 1 ] = True NEW_LINE i = 2 NEW_LINE while i * i < MAX : NEW_LINE INDENT if not cls . isPrime [ i ] : NEW_LINE INDENT while j < MAX : NEW_LINE INDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def findPrime ( cls , n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while num > 0 : NEW_LINE INDENT if not cls . isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def minNumber ( cls , arr , n ) : NEW_LINE INDENT cls . sieveOfEratostheneses ( ) NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if not cls . isPrime [ sum ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = cls . findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = arr . length NEW_LINE print cls . minNumber ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 25 NEW_LINE @ classmethod NEW_LINE def getMinSum ( cls , arr , n ) : NEW_LINE INDENT bits_count = [ None ] * MAX NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE d = 0 NEW_LINE while d < n : NEW_LINE INDENT while e > 0 : NEW_LINE INDENT e = e / 2 NEW_LINE if rem == 1 : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = Math . max ( max_bit , f ) NEW_LINE d += 1 NEW_LINE DEDENT d = 0 NEW_LINE while d < max_bit : NEW_LINE INDENT if bits_count [ d ] > n / 2 : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT d += 1 NEW_LINE DEDENT d = 0 NEW_LINE while d < n : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE d += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = arr . length NEW_LINE print cls . getMinSum ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE sb = StringBuilder ( br . readLine ( ) ) NEW_LINE n = Integer . parseInt ( br . readLine ( ) ) NEW_LINE temp = StringBuilder ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if splitCommand [ 0 ] . startsWith ( " p " ) : NEW_LINE INDENT print sb . substring ( a , b + 1 ) NEW_LINE DEDENT elif splitCommand [ 0 ] . startsWith ( " rev " ) : NEW_LINE INDENT temp = StringBuilder ( sb . substring ( a , b + 1 ) ) NEW_LINE temp . reverse ( ) NEW_LINE sb . replace ( a , b + 1 , str ( temp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sb . replace ( a , b + 1 , p ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def solve ( cls , A , n ) : NEW_LINE INDENT dp = [ None ] * 2000 NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = - sum NEW_LINE while i <= sum : NEW_LINE INDENT try : NEW_LINE INDENT dp [ 0 ] [ i ] = Integer . MAX_VALUE NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT i += 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j <= sum : NEW_LINE INDENT try : NEW_LINE INDENT dp [ flag ] [ j ] = Integer . MAX_VALUE NEW_LINE if j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= - sum : NEW_LINE INDENT dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] NEW_LINE DEDENT if j + A [ i - 1 ] <= sum and j + A [ i - 1 ] >= - sum and dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != Integer . MAX_VALUE : NEW_LINE INDENT dp [ flag ] [ j ] = Math . min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT j += 1 NEW_LINE DEDENT flag = flag ^ 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i <= sum : NEW_LINE INDENT if dp [ flag ^ 1 ] [ i ] != Integer . MAX_VALUE : NEW_LINE INDENT return dp [ flag ^ 1 ] [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = arr . length NEW_LINE print cls . solve ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT AOJ0221 ( ) . doIt ( ) NEW_LINE DEDENT class AOJ0221 ( object ) : NEW_LINE INDENT person = [ ] NEW_LINE m = int ( ) NEW_LINE n = int ( ) NEW_LINE def doIt ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT self . m = in_ . nextInt ( ) NEW_LINE self . n = in_ . nextInt ( ) NEW_LINE if self . m + self . n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT self . person = [ None ] * m NEW_LINE while i <= n : NEW_LINE INDENT if input == talk == False and self . m - cnt > 1 : NEW_LINE INDENT self . person [ user ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT user = getUser ( user ) NEW_LINE i += 1 NEW_LINE DEDENT while i < m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT def getTalk ( self , num ) : NEW_LINE INDENT return " FizzBuzz " if num % 15 == 0 else " Fizz " if num % 3 == 0 else " Buzz " if num % 5 == 0 else Integer . toString ( num ) NEW_LINE DEDENT def getUser ( self , currentUser ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT l = [ None ] * 1001 NEW_LINE @ classmethod NEW_LINE def initialize ( cls ) : NEW_LINE INDENT cls . l [ 0 ] [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i < 1001 : NEW_LINE INDENT cls . l [ i ] [ 0 ] = 1 NEW_LINE while j < i + 1 : NEW_LINE INDENT cls . l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def nCr ( cls , n , r ) : NEW_LINE INDENT return cls . l [ n ] [ r ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print cls . nCr ( n , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class problemB ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def quickSort ( cls , a , d , c ) : NEW_LINE INDENT i = d NEW_LINE j = c NEW_LINE mid = a [ ( d + c ) / 2 ] NEW_LINE while i <= j : NEW_LINE INDENT while a [ i ] < mid : NEW_LINE while a [ j ] > mid : NEW_LINE if i <= j : NEW_LINE INDENT a [ i ] = a [ j ] NEW_LINE a [ j ] = tg NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if d < j : NEW_LINE INDENT cls . quickSort ( a , d , j ) NEW_LINE DEDENT if i < c : NEW_LINE INDENT cls . quickSort ( a , i , c ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE a = [ None ] * n + 5 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT b = [ None ] * n + 5 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT c = [ None ] * n + 5 NEW_LINE i = 1 NEW_LINE while i <= n - 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT cls . quickSort ( a , 1 , n ) NEW_LINE cls . quickSort ( b , 1 , n - 1 ) NEW_LINE cls . quickSort ( c , 1 , n - 2 ) NEW_LINE resA = a [ n ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT resA = a [ i ] NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print resA NEW_LINE resB = b [ n - 1 ] NEW_LINE i = 1 NEW_LINE while i <= n - 2 : NEW_LINE INDENT if b [ i ] != c [ i ] : NEW_LINE INDENT resB = b [ i ] NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print resB NEW_LINE sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE problemB . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class B148 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE VP = in_ . nextInt ( ) NEW_LINE VD = in_ . nextInt ( ) NEW_LINE T = in_ . nextInt ( ) NEW_LINE F = in_ . nextInt ( ) NEW_LINE C = in_ . nextInt ( ) NEW_LINE if VD <= VP : NEW_LINE INDENT print "0" NEW_LINE return NEW_LINE DEDENT answer = 0 NEW_LINE start = T NEW_LINE while True : NEW_LINE INDENT if ( start + x ) * VP >= C : NEW_LINE INDENT break NEW_LINE DEDENT start += 2 * x + F NEW_LINE answer += 1 NEW_LINE DEDENT print answer NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE B148 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def longestAlternatingSubarray ( cls , a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] < 0 : NEW_LINE INDENT cnt += 1 NEW_LINE longest = Math . max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return longest NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] NEW_LINE n = a . length NEW_LINE print cls . longestAlternatingSubarray ( a , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT max = 100 NEW_LINE @ classmethod NEW_LINE def countSubsequence ( cls , s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s . charAt ( i ) == ' G ' : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE DEDENT elif s . charAt ( i ) == ' F ' : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " GFGFG " NEW_LINE n = len ( s ) NEW_LINE cls . countSubsequence ( s , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countSteps ( cls , n ) : NEW_LINE INDENT steps = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 150 NEW_LINE print cls . countSteps ( n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT class AOJ_0138 ( Comparable , AOJ_0138 ) : NEW_LINE INDENT num = int ( ) NEW_LINE time = Double ( ) NEW_LINE def compareTo ( self , o ) : NEW_LINE INDENT return self . time . compareTo ( o . time ) NEW_LINE DEDENT DEDENT def doIt ( self ) : NEW_LINE INDENT m = 0 NEW_LINE sc = Scanner ( System . in_ ) NEW_LINE data = [ None ] * 8 NEW_LINE sub = [ None ] * 18 NEW_LINE i = 0 NEW_LINE while i < 3 : NEW_LINE INDENT while k < 8 : NEW_LINE INDENT data [ k ] = AOJ_0138 ( ) NEW_LINE data [ k ] . num = sc . nextInt ( ) NEW_LINE data [ k ] . time = sc . nextDouble ( ) NEW_LINE k += 1 NEW_LINE DEDENT Arrays . sort ( data ) NEW_LINE System . out . printf ( " % d ▁ % .2f \n " , data [ 0 ] . num , data [ 0 ] . time ) NEW_LINE System . out . printf ( " % d ▁ % .2f \n " , data [ 1 ] . num , data [ 1 ] . time ) NEW_LINE while k < 8 : NEW_LINE INDENT sub [ m ] = data [ k ] NEW_LINE m += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT Arrays . sort ( sub ) NEW_LINE System . out . printf ( " % d ▁ % .2f \n " , sub [ 0 ] . num , sub [ 0 ] . time ) NEW_LINE System . out . printf ( " % d ▁ % .2f \n " , sub [ 1 ] . num , sub [ 1 ] . time ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . doIt ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find_count ( cls , arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT if i % x == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print cls . find_count ( arr , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE sugoroku = " " NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT inputSugoroku ( ) NEW_LINE solveSugoroku ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def solveSugoroku ( cls ) : NEW_LINE INDENT dice = 0 NEW_LINE safes = cls . sugoroku . split ( "0" ) NEW_LINE i = 0 NEW_LINE while i < safes . length : NEW_LINE INDENT dice = Math . max ( dice , len ( safes [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT print dice + 1 NEW_LINE DEDENT @ classmethod NEW_LINE def inputSugoroku ( cls ) : NEW_LINE INDENT sb = StringBuilder ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sb . append ( cls . sc . nextInt ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT cls . sugoroku = sb . __str__ ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . lang . reflect . Array NEW_LINE import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class practice2 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE __t2_1 = t2 NEW_LINE t2 += 1 NEW_LINE __t1_2 = t1 NEW_LINE t1 += 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < 2 * n : NEW_LINE INDENT if x1 == 0 : NEW_LINE INDENT y [ __t2_1 ] = y1 * y1 NEW_LINE DEDENT else : NEW_LINE INDENT x [ __t1_2 ] = x1 * x1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT Arrays . sort ( x ) NEW_LINE Arrays . sort ( y ) NEW_LINE while i > - 1 : NEW_LINE INDENT sum += Math . sqrt ( x [ i ] + y [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT print sum NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE practice2 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countNonDecreasing ( cls , n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count /= i NEW_LINE i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE print cls . countNonDecreasing ( n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT mod = 1000000007 L NEW_LINE @ classmethod NEW_LINE def mult ( cls , a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT @ classmethod NEW_LINE def calculate_factors ( cls , n ) : NEW_LINE INDENT ans = long ( ) NEW_LINE cnt = long ( ) NEW_LINE cnt = 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n / 2 NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT i = 3 NEW_LINE while i <= Math . sqrt ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n / i NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT ans = mult ( ans , ( 2 ) ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 193748576239475639 L NEW_LINE cls . mod = 17 NEW_LINE print cls . calculate_factors ( n , + " \n " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class cf32A ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE s = input . next ( ) NEW_LINE str_ = " " NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s . charAt ( i ) == ' . ' : NEW_LINE INDENT str_ += 0 NEW_LINE DEDENT else : NEW_LINE INDENT if s . charAt ( i ) == ' - ' and s . charAt ( i + 1 ) == ' . ' : NEW_LINE INDENT str_ += 1 NEW_LINE DEDENT else : NEW_LINE INDENT str_ += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print str_ NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE cf32A . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxAbsDiff ( cls , arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT minEle = Math . min ( minEle , arr [ i ] ) NEW_LINE maxEle = Math . max ( maxEle , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = arr . length NEW_LINE print cls . maxAbsDiff ( arr , n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class JavaApplication125 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE num = sc . nextInt ( ) NEW_LINE old = - 1 NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < num : NEW_LINE INDENT if s == 1 : NEW_LINE INDENT if old >= 0 : NEW_LINE INDENT ans *= ( i - old ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT old = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE JavaApplication125 . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def checkUtil ( cls , num , dig , base ) : NEW_LINE INDENT if dig == 1 and num < base : NEW_LINE INDENT return True NEW_LINE DEDENT if dig > 1 and num >= base : NEW_LINE dig -= 1 NEW_LINE dig -= 1 NEW_LINE INDENT return cls . checkUtil ( num / base , dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def check ( cls , num , dig ) : NEW_LINE INDENT base = 2 NEW_LINE while base <= 32 : NEW_LINE INDENT base += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = 8 NEW_LINE dig = 3 NEW_LINE if cls . check ( num , dig ) : NEW_LINE INDENT print " Yes " , NEW_LINE DEDENT else : NEW_LINE INDENT print " No " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printArray ( cls , arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print arr [ i ] + " ▁ " , NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def getMin ( cls , arr , i , j ) : NEW_LINE INDENT __i_0 = i NEW_LINE i += 1 NEW_LINE minVal = arr [ __i_0 ] NEW_LINE while i <= j : NEW_LINE INDENT minVal = Math . min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT @ classmethod NEW_LINE def getMax ( cls , arr , i , j ) : NEW_LINE INDENT __i_1 = i NEW_LINE i += 1 NEW_LINE maxVal = arr [ __i_1 ] NEW_LINE while i <= j : NEW_LINE INDENT maxVal = Math . max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT @ classmethod NEW_LINE def generateArr ( cls , arr , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print arr [ 0 ] NEW_LINE return NEW_LINE DEDENT tmpArr = [ None ] * n NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE i = 1 NEW_LINE while i < n - 1 : NEW_LINE INDENT tmpArr [ i ] = Math . abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE i += 1 NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE cls . printArray ( tmpArr , n ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = arr . length NEW_LINE cls . generateArr ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE __n_0 = n NEW_LINE n -= 1 NEW_LINE while __n_0 > 0 : NEW_LINE INDENT if katamukiab == katamukicd : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def nthXorFib ( cls , n , a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return ( a ^ b ) NEW_LINE DEDENT return cls . nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE n = 10 NEW_LINE print cls . nthXorFib ( n , a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class p073 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p073 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT return Integer . toString ( sternBrocotCount ( 1 , 3 , 1 , 2 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def sternBrocotCount ( cls , leftN , leftD , rightN , rightD ) : NEW_LINE INDENT n = leftN + rightN NEW_LINE d = leftD + rightD NEW_LINE if d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + cls . sternBrocotCount ( leftN , leftD , n , d ) + cls . sternBrocotCount ( n , d , rightN , rightD ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p073 . main ( sys . argv ) NEW_LINE DEDENT
import java . io . PrintWriter NEW_LINE import java . util . Scanner NEW_LINE class Filling_Shapes ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE pw = PrintWriter ( System . out ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = cls . sc . nextInt ( ) NEW_LINE cls . pw . println ( 0 if ( n % 2 ) == 1 else ( Math . pow ( 2 , n / 2 ) ) ) NEW_LINE cls . pw . close ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def find ( cls , n ) : NEW_LINE INDENT arr = [ None ] * 60 + 1 NEW_LINE arr [ 1 ] = 0 NEW_LINE arr [ 2 ] = 2 NEW_LINE i = 3 NEW_LINE while i <= n : NEW_LINE INDENT arr [ i ] = arr [ i - 2 ] * 2 NEW_LINE i += 1 NEW_LINE DEDENT return arr [ n ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Filling_Shapes . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sieve ( cls , prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT while i <= n : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def sumPrime ( cls , d ) : NEW_LINE INDENT i = int ( ) NEW_LINE maxVal = ( Math . pow ( 10 , d ) ) - 1 NEW_LINE prime = [ None ] * maxVal + 1 NEW_LINE while i < maxVal + 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT cls . sieve ( prime , maxVal ) NEW_LINE sum = 0 NEW_LINE while i <= maxVal : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT sum += i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT d = 3 NEW_LINE print cls . sumPrime ( d ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . time . LocalDate NEW_LINE import java . time . Period NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT age_difference ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def age_difference ( cls ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE d = [ None ] * 6 NEW_LINE i = 0 NEW_LINE while i < 6 : NEW_LINE INDENT d [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT d1 = LocalDate . of ( d [ 0 ] , d [ 1 ] , d [ 2 ] ) NEW_LINE d2 = LocalDate . of ( d [ 3 ] , d [ 4 ] , d [ 5 ] ) NEW_LINE age_diff = Math . abs ( Period . between ( d1 , d2 ) . getYears ( ) ) NEW_LINE if d [ 1 ] == d [ 4 ] and d [ 2 ] == d [ 5 ] : NEW_LINE INDENT print age_diff NEW_LINE DEDENT else : NEW_LINE INDENT print age_diff + 1 NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT





class Geeks ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check_digits ( cls , n ) : NEW_LINE INDENT while n > 0 : NEW_LINE INDENT if ( n % 10 ) % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT @ classmethod NEW_LINE def smallest_number ( cls , n ) : NEW_LINE INDENT i = n NEW_LINE while True : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 2397 NEW_LINE print cls . smallest_number ( N ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check_digits ( cls , n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT if ( n % 10 ) % 2 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT @ classmethod NEW_LINE def smallest_number ( cls , n ) : NEW_LINE INDENT i = n NEW_LINE while True : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 2397 NEW_LINE print cls . smallest_number ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class TheBestGift ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE str_ = br . readLine ( ) . split ( " ▁ " ) NEW_LINE n = Integer . parseInt ( str_ [ 0 ] ) NEW_LINE m = Integer . parseInt ( str_ [ 1 ] ) NEW_LINE arr = [ None ] * m NEW_LINE str_ = br . readLine ( ) . split ( " ▁ " ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT arr [ Integer . parseInt ( str_ [ i ] ) - 1 ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT print getNumberOfWays2 ( arr , n ) NEW_LINE DEDENT @ classmethod NEW_LINE def getNumberOfWays1 ( cls , arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < arr . length : NEW_LINE INDENT count = count + ( arr [ i ] * ( n - arr [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT return count / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def sumNatual ( cls , n ) : NEW_LINE INDENT return ( ( n ) * ( n + 1 l ) ) / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def getNumberOfWays2 ( cls , arr , n ) : NEW_LINE INDENT t = cls . sumNatual ( n ) NEW_LINE for x in arr : NEW_LINE INDENT t -= sumNatual ( x ) NEW_LINE DEDENT return t NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE TheBestGift . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findPosition ( cls , k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = long ( ) NEW_LINE i = 2 NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE k = 4 NEW_LINE print " Position ▁ of ▁ n ' th ▁ multiple " + " ▁ of ▁ k ▁ in ▁ Fibonacci ▁ Series ▁ is ▁ " , NEW_LINE print cls . findPosition ( k , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE s = sc . next ( ) NEW_LINE len = len ( s ) NEW_LINE n = 0 NEW_LINE c = int ( ) NEW_LINE ans = str ( ) NEW_LINE e = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < len : NEW_LINE INDENT if e [ ( ( s . charAt ( i ) ) ) - 97 ] == False : NEW_LINE INDENT n += 1 NEW_LINE DEDENT e [ ( ( s . charAt ( i ) ) ) - 97 ] = True NEW_LINE i += 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c = len - 2 NEW_LINE if s . charAt ( 0 ) == s . charAt ( len - 1 ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT if c % 2 == 0 : NEW_LINE INDENT ans = " Second " NEW_LINE DEDENT else : NEW_LINE INDENT ans = " First " NEW_LINE DEDENT print ans NEW_LINE sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT










import java . io . BufferedInputStream NEW_LINE import java . util . Arrays NEW_LINE import java . util . HashMap NEW_LINE import java . util . Scanner NEW_LINE import java . util . TreeMap NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( BufferedInputStream ( System . in_ ) ) NEW_LINE N = scan . nextInt ( ) NEW_LINE arr = [ None ] * N NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT tsk = Task ( ) NEW_LINE print tsk . solve ( arr ) NEW_LINE DEDENT class Task ( object ) : NEW_LINE INDENT def solve ( self , arr ) : NEW_LINE INDENT n = arr . length NEW_LINE sorted = Arrays . copyOf ( arr , n ) NEW_LINE Arrays . sort ( sorted ) NEW_LINE total = ( n ) * ( n + 1 ) / 2 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while l < r : NEW_LINE INDENT while x < bit . length : NEW_LINE INDENT x += x & - x NEW_LINE DEDENT while i < n : NEW_LINE INDENT cur += 1 if arr [ i ] <= target else - 1 NEW_LINE while x < bit . length : NEW_LINE INDENT x += x & - x NEW_LINE DEDENT while x > 0 : NEW_LINE INDENT x -= x & - x NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if cnt >= total / 2 + 1 : NEW_LINE INDENT r = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return sorted [ l ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT stdIn = Scanner ( System . in_ ) NEW_LINE ca = [ None ] * NEW_LINE cb = [ None ] * NEW_LINE c = [ None ] * NEW_LINE while stdIn . hasNext ( ) : NEW_LINE INDENT while i < ca . length : NEW_LINE INDENT if ca [ i ] > a : NEW_LINE INDENT ar = i NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < cb . length : NEW_LINE INDENT if cb [ i ] > b : NEW_LINE INDENT br = i NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ans == 100 : NEW_LINE INDENT ans = c . length - 1 NEW_LINE DEDENT print c [ ans ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class q1 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT a = sc . nextLong ( ) NEW_LINE b = sc . nextLong ( ) NEW_LINE c = sc . nextLong ( ) NEW_LINE d = sc . nextLong ( ) NEW_LINE print res NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE q1 . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class A_Remove_Smallest ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sn = Scanner ( System . in_ ) NEW_LINE t = sn . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT Arrays . sort ( arr ) NEW_LINE while i < n - 1 : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] ) <= 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A_Remove_Smallest . main ( sys . argv ) NEW_LINE DEDENT
import NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def cal_sin ( cls , n ) : NEW_LINE INDENT accuracy = ( 0.0001 ) NEW_LINE denominator = float ( ) NEW_LINE sinx = float ( ) NEW_LINE sinval = float ( ) NEW_LINE n = n * ( ( 3.142 / 180.0 ) ) NEW_LINE x1 = n NEW_LINE sinx = n NEW_LINE sinval = ( sin ( n ) ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT denominator = 2 * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE if not ( ( accuracy <= sinval - sinx ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print sinx NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 90 NEW_LINE cls . cal_sin ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE @ classmethod NEW_LINE def multiply ( cls ) : NEW_LINE INDENT pro = 1 NEW_LINE i = 0 NEW_LINE while i < arr . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return pro NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print cls . multiply ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findMinIndex ( cls , arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return cls . findMinIndex ( arr , low , mid - 1 ) NEW_LINE DEDENT return cls . findMinIndex ( arr , mid + 1 , high ) NEW_LINE DEDENT @ classmethod NEW_LINE def binary_search ( cls , arr , l , h , x ) : NEW_LINE INDENT while l <= h : NEW_LINE INDENT if arr [ mid ] <= x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT @ classmethod NEW_LINE def countEleLessThanOrEqual ( cls , arr , n , x ) : NEW_LINE INDENT min_index = cls . findMinIndex ( arr , 0 , n - 1 ) NEW_LINE if x <= arr [ n - 1 ] : NEW_LINE INDENT return ( cls . binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ) NEW_LINE DEDENT if ( min_index - 1 ) >= 0 and x <= arr [ min_index - 1 ] : NEW_LINE INDENT return ( n - min_index + cls . binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 6 , 10 , 12 , 15 , 2 , 4 , 5 ] NEW_LINE n = arr . length NEW_LINE x = 14 NEW_LINE print " Count ▁ = ▁ " + cls . countEleLessThanOrEqual ( arr , n , x , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def kthString ( cls , n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while total < k : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE j = 1 NEW_LINE while j < first_y_position : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print " y " , NEW_LINE j = first_y_position + 1 NEW_LINE while second_y_position > 1 : NEW_LINE INDENT print " x " , NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print " y " , NEW_LINE while j < n : NEW_LINE INDENT print " x " , NEW_LINE j += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE k = 7 NEW_LINE cls . kthString ( n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def binomialCoeff ( cls , n , k ) : NEW_LINE INDENT C = [ None ] * k + 1 NEW_LINE C [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j > 0 : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return C [ k ] NEW_LINE DEDENT @ classmethod NEW_LINE def count_of_subarrays ( cls , N ) : NEW_LINE INDENT count = cls . binomialCoeff ( 2 * N - 1 , N ) NEW_LINE return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 3 NEW_LINE print cls . count_of_subarrays ( N , + " \n " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def getSmallestAndLargest ( cls , s , k ) : NEW_LINE INDENT currStr = s . substring ( 0 , k ) NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE i = k NEW_LINE while i < len ( s ) : NEW_LINE INDENT currStr = currStr . substring ( 1 , k ) + s . charAt ( i ) NEW_LINE if lexMax . compareTo ( currStr ) < 0 : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if lexMin . compareTo ( currStr ) > 0 : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print lexMin NEW_LINE print lexMax NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE cls . getSmallestAndLargest ( str_ , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE number = sc . nextInt ( ) NEW_LINE wooden = [ None ] * number NEW_LINE i = 0 NEW_LINE while i < wooden . length : NEW_LINE INDENT wooden [ i ] = each NEW_LINE i += 1 NEW_LINE DEDENT height = [ None ] * wooden . length NEW_LINE count = int ( ) NEW_LINE i = 0 NEW_LINE while i < wooden . length : NEW_LINE INDENT if wooden [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE while j < wooden . length : NEW_LINE INDENT if wooden [ i ] == wooden [ j ] : NEW_LINE INDENT wooden [ j ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT height [ i ] = count NEW_LINE DEDENT i += 1 NEW_LINE DEDENT index = 0 NEW_LINE max = height [ 0 ] NEW_LINE i = 0 NEW_LINE while i < height . length : NEW_LINE INDENT if height [ i ] != 0 : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if max < height [ i ] : NEW_LINE INDENT max = height [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print max + " ▁ " + index NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT freq = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " leetcode " NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print out NEW_LINE DEDENT DEDENT






import java . util . Scanner NEW_LINE import java . util . Arrays NEW_LINE class Ishu ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def gcd ( cls , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return cls . gcd ( b , a % b ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE t = long ( ) NEW_LINE n = long ( ) NEW_LINE ans = 1 NEW_LINE t = scan . nextLong ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT n = scan . nextLong ( ) NEW_LINE ans = 1 + ( ( 4 * n ) / gcd ( 4 * n , n + 1 ) ) NEW_LINE print ans NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Ishu . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT PI = 3.14 NEW_LINE @ classmethod NEW_LINE def find_area ( cls , r , d ) : NEW_LINE INDENT R = d / cls . PI NEW_LINE R += Math . pow ( r , 2 ) NEW_LINE R = Math . sqrt ( R ) NEW_LINE area = cls . PI * Math . pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT r = 4 NEW_LINE d = 5 NEW_LINE print cls . find_area ( r , d ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isVowel ( cls , ch ) : NEW_LINE INDENT if ch == ' a ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' e ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' i ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' o ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' u ' : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def isSatisfied ( cls , str_ , n ) : NEW_LINE INDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT if not cls . isVowel ( str_ [ i ] ) and not cls . isVowel ( str_ [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n - 1 : NEW_LINE INDENT if cls . isVowel ( str_ [ i ] ) and not cls . isVowel ( str_ [ i - 1 ] ) and not cls . isVowel ( str_ [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " acaba " NEW_LINE n = len ( str_ ) NEW_LINE if cls . isSatisfied ( str_ . toCharArray ( ) , n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countWays ( cls , n ) : NEW_LINE INDENT dp = [ None ] * n + 1 NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE i = 3 NEW_LINE while i <= n : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE i += 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 6 NEW_LINE print cls . countWays ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def expect ( cls , m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE i = float ( ) NEW_LINE while i > 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT m = 6 NEW_LINE n = 3 NEW_LINE print String . format ( " % .5f " , cls . expect ( m , n ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def ProdOfPrimes ( cls , n ) : NEW_LINE INDENT prime = [ None ] * n + 1 NEW_LINE Arrays . fill ( prime , True ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT while i <= n : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT prod = 1 NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 10 NEW_LINE print cls . ProdOfPrimes ( n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class p019 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p019 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE y = 1901 NEW_LINE while y <= 2000 : NEW_LINE INDENT while m <= 12 : NEW_LINE INDENT if dayOfWeek ( y , m , 1 ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT m += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT return Integer . toString ( count ) NEW_LINE DEDENT @ classmethod NEW_LINE def dayOfWeek ( cls , year , month , day ) : NEW_LINE INDENT if year < 0 or year > 10000 or month < 1 or month > 12 or day < 1 or day > 31 : NEW_LINE INDENT raise IllegalArgumentException ( ) NEW_LINE DEDENT m = ( month - 3 + 4800 ) % 4800 NEW_LINE y = ( year + m / 12 ) % 400 NEW_LINE m %= 12 NEW_LINE return ( y + y / 4 - y / 100 + ( 13 * m + 2 ) / 5 + day + 2 ) % 7 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p019 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT class Date ( object ) : NEW_LINE INDENT d = int ( ) NEW_LINE m = int ( ) NEW_LINE y = int ( ) NEW_LINE def __init__ ( self , d , m , y ) : NEW_LINE INDENT self . d = d NEW_LINE self . m = m NEW_LINE self . y = y NEW_LINE DEDENT DEDENT monthDays = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE @ classmethod NEW_LINE def countLeapYears ( cls , d ) : NEW_LINE INDENT years = d . y NEW_LINE if d . m <= 2 : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT return years / 4 - years / 100 + years / 400 NEW_LINE DEDENT @ classmethod NEW_LINE def getDifference ( cls , dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 365 + dt1 . d NEW_LINE i = 0 NEW_LINE while i < dt1 . m - 1 : NEW_LINE INDENT n1 += monthDays [ i ] NEW_LINE i += 1 NEW_LINE DEDENT n1 += countLeapYears ( dt1 ) NEW_LINE n2 = dt2 . y * 365 + dt2 . d NEW_LINE i = 0 NEW_LINE while i < dt2 . m - 1 : NEW_LINE INDENT n2 += monthDays [ i ] NEW_LINE i += 1 NEW_LINE DEDENT n2 += countLeapYears ( dt2 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT dt1 = cls . Date ( 1 , 2 , 2000 ) NEW_LINE dt2 = cls . Date ( 1 , 2 , 2004 ) NEW_LINE print " Difference ▁ between ▁ two ▁ dates ▁ is ▁ " + cls . getDifference ( dt1 , dt2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class ProgressBar ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE n = scan . nextInt ( ) NEW_LINE k = scan . nextInt ( ) NEW_LINE t = scan . nextInt ( ) NEW_LINE temp = ( t * k * n ) / 100.0 NEW_LINE x = 0 NEW_LINE while temp - k >= 0 : NEW_LINE INDENT temp -= k NEW_LINE x += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < x : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if temp != 0 : NEW_LINE INDENT print ( temp , + " ▁ " ) NEW_LINE x += 1 NEW_LINE DEDENT i = x NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE ProgressBar . main ( sys . argv ) NEW_LINE DEDENT
import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . HashMap NEW_LINE import java . util . Map NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( ) NEW_LINE def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT if ( N | Q ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < 100 : NEW_LINE INDENT map . put ( i , 0 ) NEW_LINE i += 1 NEW_LINE DEDENT while i < N : NEW_LINE INDENT list_ [ i ] = [ None ] * M NEW_LINE while j < M : NEW_LINE INDENT list_ [ i ] [ j ] = d NEW_LINE map . put ( d , map . get ( d ) + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for key in map . keySet ( ) : NEW_LINE INDENT if n >= Q : NEW_LINE INDENT if max < n : NEW_LINE INDENT idx = key NEW_LINE max = n NEW_LINE DEDENT DEDENT DEDENT print idx NEW_LINE DEDENT DEDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = Scanner ( System . in_ ) NEW_LINE DEDENT def ni ( self ) : NEW_LINE INDENT return self . sc . nextInt ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def debug ( self , * os ) : NEW_LINE INDENT System . err . println ( Arrays . deepToString ( os ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class OddOccurance ( object ) : NEW_LINE INDENT def getOddOccurrence ( self , ar , ar_size ) : NEW_LINE INDENT i = int ( ) NEW_LINE res = 0 NEW_LINE while i < ar_size : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT occur = OddOccurance ( ) NEW_LINE ar = [ None ] * NEW_LINE n = ar . length NEW_LINE print occur . getOddOccurrence ( ar , n ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isKthBitSet ( cls , x , k ) : NEW_LINE INDENT rslt = 1 if ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) else 0 NEW_LINE return rslt NEW_LINE DEDENT @ classmethod NEW_LINE def isPalindrome ( cls , x ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( Integer . SIZE / 8 ) * 8 NEW_LINE while l < r : NEW_LINE INDENT if cls . isKthBitSet ( x , l ) != isKthBitSet ( x , r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 1 << 15 + 1 << 16 NEW_LINE print cls . isPalindrome ( x ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print cls . isPalindrome ( x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def SieveOfEratosthenes ( cls , n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT while i <= n : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def findPrimePair ( cls , n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ None ] * n + 1 NEW_LINE cls . SieveOfEratosthenes ( n , isPrime ) NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT if isPrime [ i ] and isPrime [ x ] and x != i and x * i == n : NEW_LINE INDENT print i + " ▁ " + x NEW_LINE flag = 1 NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag == 0 : NEW_LINE INDENT print " No ▁ such ▁ pair ▁ found " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 39 NEW_LINE cls . findPrimePair ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class p174 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p174 ( ) . run ( ) NEW_LINE DEDENT SIZE_LIMIT = 1000000 NEW_LINE TYPE_LIMIT = 10 NEW_LINE def run ( self ) : NEW_LINE INDENT type_ = [ None ] * SIZE_LIMIT + 1 NEW_LINE n = 3 NEW_LINE while ( n - 1 ) * 4 <= SIZE_LIMIT : NEW_LINE INDENT while m >= 1 : NEW_LINE INDENT if tiles > SIZE_LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT type_ [ tiles ] += 1 NEW_LINE m -= 2 NEW_LINE DEDENT n += 1 NEW_LINE DEDENT count = 0 NEW_LINE for t in type_ : NEW_LINE INDENT if 1 <= t and t <= TYPE_LIMIT : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return Integer . toString ( count ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p174 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxZeros ( cls , N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while N != 0 : NEW_LINE INDENT if ( N & 1 ) == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = Math . max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = Math . max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 14 NEW_LINE print cls . maxZeros ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class Linked_list_2D_Matrix ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE right = Node ( ) NEW_LINE down = Node ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def construct ( cls , arr , i , j , m , n ) : NEW_LINE INDENT if i > n - 1 or j > m - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT temp = cls . Node ( ) NEW_LINE temp . data = arr [ i ] [ j ] NEW_LINE temp . right = construct ( arr , i , j + 1 , m , n ) NEW_LINE temp . down = construct ( arr , i + 1 , j , m , n ) NEW_LINE return temp NEW_LINE DEDENT @ classmethod NEW_LINE def display ( cls , head ) : NEW_LINE INDENT Rp = cls . Node ( ) NEW_LINE Dp = head NEW_LINE while Dp != None : NEW_LINE INDENT Rp = Dp NEW_LINE while Rp != None : NEW_LINE INDENT print Rp . data + " ▁ " , NEW_LINE Rp = Rp . right NEW_LINE DEDENT print NEW_LINE Dp = Dp . down NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ ] NEW_LINE m = 3 NEW_LINE n = 3 NEW_LINE head = cls . construct ( arr , 0 , 0 , m , n ) NEW_LINE cls . display ( head ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Linked_list_2D_Matrix . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE n = Integer . parseInt ( br . readLine ( ) ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if isPrime ( Integer . parseInt ( br . readLine ( ) ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT @ classmethod NEW_LINE def isPrime ( cls , x ) : NEW_LINE INDENT if x < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if x <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if x % 2 == 0 or x % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= x : NEW_LINE INDENT if x % i == 0 or x % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findNthTerm ( cls , N ) : NEW_LINE INDENT ans = int ( ) NEW_LINE if N % 2 == 0 : NEW_LINE INDENT ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 NEW_LINE DEDENT print ans + " \n " , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 3 NEW_LINE cls . findNthTerm ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isRectangle ( cls , a , b , c , d ) : NEW_LINE INDENT if a == b and a == c and a == d and c == d and b == c and b == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE if cls . isRectangle ( a , b , c , d ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def discreteLogarithm ( cls , a , b , m ) : NEW_LINE INDENT n = ( ( Math . sqrt ( m ) + 1 ) ) NEW_LINE an = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT value = [ None ] * m NEW_LINE i = 1 NEW_LINE cur = an NEW_LINE while i <= n : NEW_LINE INDENT if value [ cur ] == 0 : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE cur = b NEW_LINE while i <= n : NEW_LINE INDENT if value [ cur ] > 0 : NEW_LINE INDENT if ans < m : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE m = 5 NEW_LINE print cls . discreteLogarithm ( a , b , m ) NEW_LINE a = 3 NEW_LINE b = 7 NEW_LINE m = 11 NEW_LINE print cls . discreteLogarithm ( a , b , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT mod = 998244353 NEW_LINE nchoosek = [ ] NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . nchoosek = [ None ] * 4001 NEW_LINE i = 0 NEW_LINE while i < nchoosek . length : NEW_LINE INDENT cls . nchoosek [ i ] [ 0 ] = nchoosek [ i ] [ i ] = 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 2 NEW_LINE while i < nchoosek . length : NEW_LINE INDENT while j < i : NEW_LINE INDENT cls . nchoosek [ i ] [ j ] = ( nchoosek [ i - 1 ] [ j ] + nchoosek [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sc = Scanner ( System . in_ ) NEW_LINE k = sc . nextInt ( ) NEW_LINE n = sc . nextInt ( ) NEW_LINE i = 2 NEW_LINE while i <= 2 * k : NEW_LINE INDENT if i > k : NEW_LINE INDENT pairs = k - i / 2 NEW_LINE DEDENT else : NEW_LINE INDENT pairs = ( i - 1 ) / 2 NEW_LINE DEDENT if i % 2 == 0 : NEW_LINE INDENT active -= 1 NEW_LINE DEDENT while j <= pairs : NEW_LINE INDENT times2 = times2 * 2 % mod NEW_LINE if active + j - 1 < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT total += choice * nchoosek [ n + active - 1 ] [ active + j - 1 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT total += choice * nchoosek [ n + active - 2 ] [ active + j - 1 ] NEW_LINE DEDENT total %= mod NEW_LINE j += 1 NEW_LINE DEDENT print total NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def gcd ( cls , a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return cls . gcd ( b % a , a ) NEW_LINE DEDENT @ classmethod NEW_LINE def largestGCD1Subset ( cls , A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if currentGCD == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = A . length NEW_LINE print cls . largestGCD1Subset ( A , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class p179 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p179 ( ) . run ( ) NEW_LINE DEDENT LIMIT = Library . pow ( 10 , 7 ) NEW_LINE def run ( self ) : NEW_LINE INDENT numDivisors = [ None ] * LIMIT + 1 NEW_LINE Arrays . fill ( numDivisors , 2 ) NEW_LINE i = 2 NEW_LINE while i < numDivisors . length : NEW_LINE INDENT while j < numDivisors . length : NEW_LINE INDENT j += i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT count = 0 NEW_LINE i = 2 NEW_LINE while i < numDivisors . length - 1 : NEW_LINE INDENT if numDivisors [ i ] == numDivisors [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Integer . toString ( count ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p179 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def updateArray ( cls , arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while i > 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = arr . length NEW_LINE cls . updateArray ( arr , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findEncryptedArray ( cls , arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = arr . length NEW_LINE cls . findEncryptedArray ( arr , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def updateArray ( cls , arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = arr . length NEW_LINE cls . updateArray ( arr , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class Factorial ( object ) : NEW_LINE INDENT def factorial ( self , n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * self . factorial ( n - 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT obj = Factorial ( ) NEW_LINE num = 5 NEW_LINE print " Factorial ▁ of ▁ " + num + " ▁ is ▁ " + obj . factorial ( num ) NEW_LINE DEDENT DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . StringTokenizer NEW_LINE import NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE line = str ( ) NEW_LINE words = [ ] NEW_LINE st = StringTokenizer ( ) NEW_LINE st = StringTokenizer ( br . readLine ( ) ) NEW_LINE n = int ( ) NEW_LINE d = int ( ) NEW_LINE x = int ( ) NEW_LINE n = parseInt ( st . nextToken ( ) ) NEW_LINE d = parseInt ( st . nextToken ( ) ) NEW_LINE x = parseInt ( st . nextToken ( ) ) NEW_LINE price = [ None ] * d NEW_LINE i = 0 NEW_LINE while i < d : NEW_LINE INDENT st = StringTokenizer ( br . readLine ( ) ) NEW_LINE while j < n : NEW_LINE INDENT price [ i ] [ j ] = parseInt ( st . nextToken ( ) ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < d - 1 : NEW_LINE INDENT while j <= x : NEW_LINE INDENT dp [ j ] = j NEW_LINE j += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT while k <= x : NEW_LINE INDENT if k >= price [ i ] [ j ] : NEW_LINE INDENT dp [ k ] = Math . max ( dp [ k ] , dp [ k - price [ i ] [ j ] ] + price [ i + 1 ] [ j ] ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT x = dp [ x ] NEW_LINE i += 1 NEW_LINE DEDENT print x NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def LiesInsieRectangle ( cls , a , b , x , y ) : NEW_LINE INDENT if x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 7 NEW_LINE b = 2 NEW_LINE x = 4 NEW_LINE y = 5 NEW_LINE if cls . LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print " Given ▁ point ▁ lies ▁ " + " inside ▁ the ▁ rectangle " NEW_LINE DEDENT else : NEW_LINE INDENT print " Given ▁ point ▁ does ▁ not ▁ " + " lie ▁ on ▁ the ▁ rectangle " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT N = 1000 NEW_LINE @ classmethod NEW_LINE def countPairs ( cls , arr , n ) : NEW_LINE INDENT size = ( 2 * cls . N ) + 1 NEW_LINE freq = [ None ] * size NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT freq [ x + cls . N ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < size : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 NEW_LINE while j < 2001 : NEW_LINE INDENT if freq [ j ] > 0 and ( freq [ ( i + j ) / 2 ] > 0 ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT j += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = arr . length NEW_LINE print cls . countPairs ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT sum = int ( ) NEW_LINE n = int ( ) NEW_LINE @ classmethod NEW_LINE def getAvg ( cls , x ) : NEW_LINE INDENT cls . sum += x NEW_LINE n += 1 NEW_LINE n += 1 NEW_LINE return ( ( ( cls . sum ) ) / n ) NEW_LINE DEDENT @ classmethod NEW_LINE def streamAvg ( cls , arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT avg = getAvg ( ( arr [ i ] ) ) NEW_LINE print " Average ▁ of ▁ " + ( i + 1 ) + " ▁ numbers ▁ is ▁ " + avg NEW_LINE i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ None ] * NEW_LINE n = arr . length NEW_LINE cls . streamAvg ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def kthSmallest ( cls , arr , k ) : NEW_LINE INDENT Arrays . sort ( arr ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ None ] * NEW_LINE k = 2 NEW_LINE print " K ' th ▁ smallest ▁ element ▁ is ▁ " + cls . kthSmallest ( arr , k , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





class Solution ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def max_element ( cls , A ) : NEW_LINE INDENT max = Integer . MIN_VALUE NEW_LINE i = 0 NEW_LINE while i < A . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return max NEW_LINE DEDENT @ classmethod NEW_LINE def SumDivPrime ( cls , A , n ) : NEW_LINE INDENT max_val = ( cls . max_element ( A ) ) + 1 NEW_LINE prime = [ None ] * max_val + 1 NEW_LINE i = 0 NEW_LINE while i <= max_val : NEW_LINE INDENT i += 1 NEW_LINE DEDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT while i <= max_val : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if prime [ A [ i ] ] : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if prime [ A [ i ] ] and sum % A [ i ] == 0 : NEW_LINE INDENT print " YES " NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " NO " NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = A . length NEW_LINE cls . SumDivPrime ( A , n ) NEW_LINE DEDENT DEDENT



import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT dp = [ None ] * 901 NEW_LINE @ classmethod NEW_LINE def minimumNumberOfDigits ( cls , a , b ) : NEW_LINE INDENT if a > b or a < 0 or b < 0 or a > 900 or b > 8100 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 0 and b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if cls . dp [ a ] [ b ] != - 1 : NEW_LINE INDENT return cls . dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE i = 9 NEW_LINE while i >= 1 : NEW_LINE INDENT if k != - 1 : NEW_LINE INDENT ans = Math . min ( ans , k + 1 ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return cls . dp [ a ] [ b ] = ans NEW_LINE DEDENT @ classmethod NEW_LINE def printSmallestNumber ( cls , a , b ) : NEW_LINE INDENT for row in dp : NEW_LINE INDENT Arrays . fill ( row , - 1 ) NEW_LINE DEDENT cls . dp [ 0 ] [ 0 ] = 0 NEW_LINE k = cls . minimumNumberOfDigits ( a , b ) NEW_LINE if k == - 1 or k > 100 : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT else : NEW_LINE INDENT while a > 0 and b > 0 : NEW_LINE INDENT while i <= 9 : NEW_LINE INDENT if a >= i and b >= i * i and 1 + cls . dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] : NEW_LINE INDENT print i , NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 18 NEW_LINE b = 162 NEW_LINE cls . printSmallestNumber ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . HashSet NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE t = input . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT while j < n : NEW_LINE INDENT set . add ( input . nextInt ( ) ) NEW_LINE j += 1 NEW_LINE DEDENT while j < m : NEW_LINE INDENT if set . add ( input . nextInt ( ) ) == False : NEW_LINE INDENT count += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print count NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GCD ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def totalPrimeFactors ( cls , n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE i = i + 2 NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def countPairs ( cls , G , L ) : NEW_LINE INDENT if L % G != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L / G NEW_LINE return ( 1 << totalPrimeFactors ( div ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + G , NEW_LINE print " ▁ & ▁ LCM ▁ " + L , NEW_LINE print " ▁ = ▁ " + cls . countPairs ( G , L , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GCD . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def calculate_sum ( cls , a , N ) : NEW_LINE INDENT m = N / a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 7 NEW_LINE N = 49 NEW_LINE print " Sum ▁ of ▁ multiples ▁ of ▁ " + a + " ▁ up ▁ to ▁ " + N + " ▁ = ▁ " + cls . calculate_sum ( a , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def next ( cls , arr , target ) : NEW_LINE INDENT start = 0 NEW_LINE end = arr . length - 1 NEW_LINE ans = - 1 NEW_LINE while start <= end : NEW_LINE INDENT if arr [ mid ] <= target : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] NEW_LINE print cls . next ( arr , 8 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT word = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " ] NEW_LINE @ classmethod NEW_LINE def printWordsWithoutIfSwitch ( cls , n ) : NEW_LINE INDENT digits = [ None ] * 10 NEW_LINE dc = 0 NEW_LINE while True : NEW_LINE INDENT digits [ dc ] = n % 10 NEW_LINE n = n / 10 NEW_LINE dc += 1 NEW_LINE if not ( ( n != 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = dc - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 350 NEW_LINE cls . printWordsWithoutIfSwitch ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def solve ( cls , a , b ) : NEW_LINE INDENT l = a . length NEW_LINE min = 0 NEW_LINE max = 0 NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT if a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] : NEW_LINE INDENT min += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print min + max + " \n " , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s1 = " a + c " NEW_LINE s2 = " + + b " NEW_LINE cls . solve ( s1 . toCharArray ( ) , s2 . toCharArray ( ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def TotalWays ( cls , n , s , k ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE i = s NEW_LINE while i < n : NEW_LINE INDENT while j < i : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return dp [ n - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE s = 2 NEW_LINE print " Total ▁ Ways ▁ = ▁ " + cls . TotalWays ( n , s , k , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . IOException NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE import java . util . List NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE n = scanner . nextInt ( ) NEW_LINE k = scanner . nextInt ( ) NEW_LINE lists = [ None ] * 10 NEW_LINE i = 0 NEW_LINE while i < 10 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT lists [ g ] . add ( c ) NEW_LINE i += 1 NEW_LINE DEDENT dp = [ None ] * k + 1 NEW_LINE Arrays . fill ( dp , - 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE i = 0 NEW_LINE while i < 10 : NEW_LINE INDENT Collections . sort ( lists [ i ] , Collections . reverseOrder ( ) ) NEW_LINE while j >= 0 : NEW_LINE INDENT if dp [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT while l < lists [ i ] . size ( ) and j + l < k : NEW_LINE INDENT sum += lists [ i ] . get ( l ) NEW_LINE dp [ j + l + 1 ] = Math . max ( dp [ j + l + 1 ] , dp [ j ] + sum + ( l + 1 ) * l ) NEW_LINE l += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print dp [ k ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE k = sc . nextInt ( ) NEW_LINE mask = [ None ] * k NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT mask [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < Math . pow ( 2 , k ) : NEW_LINE INDENT while temp > 0 : NEW_LINE INDENT if temp % 2 == 1 : NEW_LINE INDENT bitArray [ mask [ j ] ] = 1 NEW_LINE index += Math . pow ( 2 , mask [ j ] ) NEW_LINE DEDENT temp /= 2 NEW_LINE j += 1 NEW_LINE DEDENT print index + " : " , NEW_LINE while j < k : NEW_LINE INDENT if bitArray [ mask [ j ] ] == 1 : NEW_LINE INDENT print " ▁ " + mask [ j ] , NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def largestPalinSub ( cls , s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s . charAt ( 0 ) NEW_LINE i = 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print cls . largestPalinSub ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def initializeDiffArray ( cls , A , D ) : NEW_LINE INDENT n = A . length NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def update ( cls , D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT @ classmethod NEW_LINE def printArray ( cls , A , D ) : NEW_LINE INDENT i = 0 NEW_LINE while i < A . length : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print A [ i ] + " ▁ " , NEW_LINE i += 1 NEW_LINE DEDENT print NEW_LINE return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE n = A . length NEW_LINE D = [ None ] * n + 1 NEW_LINE cls . initializeDiffArray ( A , D ) NEW_LINE cls . update ( D , 0 , 1 , 10 ) NEW_LINE cls . printArray ( A , D ) NEW_LINE cls . update ( D , 1 , 3 , 20 ) NEW_LINE cls . update ( D , 2 , 2 , 30 ) NEW_LINE cls . printArray ( A , D ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT if in_ == " # END " : NEW_LINE INDENT return NEW_LINE DEDENT while i < len ( in_ ) : NEW_LINE INDENT if len ( lcs ) > len ( ans ) : NEW_LINE INDENT ans = lcs NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT def lcs ( self , s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE m = len ( t ) NEW_LINE dp = [ None ] * n + 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < m : NEW_LINE INDENT if s . charAt ( i ) == t . charAt ( j ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT res = [ None ] * dp [ n ] [ m ] NEW_LINE while n > 0 and m > 0 : NEW_LINE INDENT if dp [ n ] [ m ] == dp [ n - 1 ] [ m ] : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT elif dp [ n ] [ m ] == dp [ n ] [ m - 1 ] : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ dp [ n - 1 ] [ m - 1 ] ] = s . charAt ( n - 1 ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT return String . valueOf ( res ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def calcFunction ( cls , n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = Math . max ( r , n - r ) NEW_LINE i = mx + 1 NEW_LINE while i <= n : NEW_LINE INDENT finalDenominator = ( finalDenominator * denominator ) / numerator NEW_LINE i += 1 NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print "1 / " + cls . calcFunction ( n , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . util . ArrayList NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check ( cls , b ) : NEW_LINE INDENT if b . get ( 0 ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 1 NEW_LINE while i < len ( b ) : NEW_LINE INDENT if b . get ( i - 1 ) != b . get ( i ) - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def gap ( cls , b ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( b ) : NEW_LINE INDENT if b . get ( i ) <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def removeGap ( cls , b ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( b ) : NEW_LINE INDENT if b . get ( i ) <= 0 : NEW_LINE INDENT b . remove ( i ) NEW_LINE i -= 1 NEW_LINE continue NEW_LINE DEDENT i += 1 NEW_LINE DEDENT b . trimToSize ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT stdIn = Scanner ( System . in_ ) NEW_LINE list_ = ArrayList ( ) NEW_LINE while True : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < N : NEW_LINE INDENT list_ . add ( stdIn . nextInt ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT while not cls . check ( list_ ) and c < 10000 : NEW_LINE INDENT c += 1 NEW_LINE if cls . gap ( list_ ) : NEW_LINE INDENT while i < len ( list_ ) : NEW_LINE INDENT list_ . set ( i , list_ . get ( i ) - 1 ) NEW_LINE i += 1 NEW_LINE DEDENT list_ . add ( size ) NEW_LINE DEDENT cls . removeGap ( list_ ) NEW_LINE DEDENT print c if ( cls . check ( list_ ) ) else - 1 NEW_LINE list_ . clear ( ) NEW_LINE list_ . trimToSize ( ) NEW_LINE System . gc ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class p142 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p142 ( ) . run ( ) NEW_LINE DEDENT isSquare = [ ] NEW_LINE def run ( self ) : NEW_LINE INDENT sumLimit = 10 NEW_LINE while True : NEW_LINE INDENT self . isSquare = [ None ] * sumLimit NEW_LINE while i * i < sumLimit : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if sum != - 1 : NEW_LINE INDENT sum = sumLimit NEW_LINE break NEW_LINE DEDENT sumLimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT if sum == - 1 : NEW_LINE INDENT return Integer . toString ( sumLimit ) NEW_LINE DEDENT sumLimit = sum NEW_LINE DEDENT DEDENT def findSum ( self , limit ) : NEW_LINE INDENT a = 1 NEW_LINE while a * a < limit : NEW_LINE INDENT while b > 0 : NEW_LINE INDENT if ( a + b ) % 2 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT while c * c - y < zlimit : NEW_LINE INDENT if self . isSquare [ x + z ] and self . isSquare [ x - z ] and self . isSquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT c += 1 NEW_LINE DEDENT b -= 1 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p142 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isVowel ( cls , c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT @ classmethod NEW_LINE def encryptString ( cls , s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = " " NEW_LINE l = 0 NEW_LINE while l <= n - k : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE while r <= l + k - 1 : NEW_LINE INDENT if cls . isVowel ( s . charAt ( r ) ) == True : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT ans += String . valueOf ( countVowels * countConsonants ) NEW_LINE l += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print cls . encryptString ( s , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT dx = [ 1 , 1 , 0 , - 1 ] NEW_LINE dy = [ 0 , 1 , 1 , 1 ] NEW_LINE in_ = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE INF = 1 << 58 NEW_LINE while True : NEW_LINE INDENT if ( n | k ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < n : NEW_LINE INDENT Arrays . fill ( fare [ i ] , INF ) NEW_LINE fare [ i ] [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT while i < k : NEW_LINE INDENT if init == 1 : NEW_LINE INDENT if e < fare [ c ] [ d ] : NEW_LINE INDENT fare [ c ] [ d ] = fare [ d ] [ c ] = e NEW_LINE while p < n : NEW_LINE INDENT while q < n : NEW_LINE INDENT fare [ p ] [ q ] = Math . min ( fare [ p ] [ q ] , fare [ p ] [ c ] + fare [ c ] [ d ] + fare [ d ] [ q ] ) NEW_LINE fare [ p ] [ q ] = Math . min ( fare [ p ] [ q ] , fare [ p ] [ d ] + fare [ c ] [ d ] + fare [ c ] [ q ] ) NEW_LINE q += 1 NEW_LINE DEDENT p += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print fare [ a ] [ b ] if fare [ a ] [ b ] != INF else - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def increaseInVol ( cls , l , b , h ) : NEW_LINE INDENT percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT l = 50 NEW_LINE b = 20 NEW_LINE h = 10 NEW_LINE print cls . increaseInVol ( l , b , h ) + " % " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE next = Node ( ) NEW_LINE prev = Node ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def getNode ( cls , data ) : NEW_LINE INDENT newNode = cls . Node ( ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT @ classmethod NEW_LINE def insertEnd ( cls , head , new_node ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT new_node . next = new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = ( head ) . prev NEW_LINE new_node . next = head NEW_LINE ( head ) . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT @ classmethod NEW_LINE def reverse ( cls , head ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last NEW_LINE prev = cls . Node ( ) NEW_LINE while curr . prev != last : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT @ classmethod NEW_LINE def display ( cls , head ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print " Forward ▁ direction : ▁ " , NEW_LINE while temp . next != head : NEW_LINE INDENT print temp . data + " ▁ " , NEW_LINE temp = temp . next NEW_LINE DEDENT print temp . data + " ▁ " , NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print " \n Backward ▁ direction : ▁ " , NEW_LINE while temp . prev != last : NEW_LINE INDENT print temp . data + " ▁ " , NEW_LINE temp = temp . prev NEW_LINE DEDENT print temp . data + " ▁ " , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print " Current ▁ list : \n " , NEW_LINE cls . display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print " \n \n Reversed ▁ list : \n " , NEW_LINE cls . display ( head ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def lastFiveDigits ( cls , n ) : NEW_LINE INDENT n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 NEW_LINE ans = 1 NEW_LINE i = 0 NEW_LINE while i < 5 : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 12345 NEW_LINE cls . lastFiveDigits ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigInteger NEW_LINE class p080 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p080 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while i <= 100 : NEW_LINE INDENT x = x . multiply ( BigInteger . TEN . pow ( 100 * 2 ) ) NEW_LINE if not y . multiply ( y ) == x : NEW_LINE INDENT while j < len ( s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return Integer . toString ( sum ) NEW_LINE DEDENT @ classmethod NEW_LINE def sqrt ( cls , x ) : NEW_LINE INDENT i = 0 NEW_LINE while BigInteger . TEN . pow ( i * 2 ) . compareTo ( x ) <= 0 : NEW_LINE y = BigInteger . ZERO NEW_LINE while i >= 0 : NEW_LINE INDENT while j >= 0 : NEW_LINE INDENT delta = y . shiftLeft ( 1 ) . add ( temp ) . multiply ( temp ) NEW_LINE if delta . compareTo ( x ) <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT x = x . subtract ( delta ) NEW_LINE y = y . add ( BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ) NEW_LINE i -= 1 NEW_LINE DEDENT return y NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p080 . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countKdivPairs ( cls , A , n , K ) : NEW_LINE INDENT freq = [ None ] * K NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if rem != 0 : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = A . length NEW_LINE K = 4 NEW_LINE print cls . countKdivPairs ( A , n , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE scanner . useDelimiter ( " , " ) NEW_LINE a = scanner . next ( ) NEW_LINE b = scanner . next ( ) NEW_LINE c = scanner . next ( ) NEW_LINE print a + " ▁ " + b + " ▁ " + c NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE nums = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT nums [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT l = 0 NEW_LINE r = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if l == 0 and nums [ n - i - 1 ] != nums [ 0 ] : NEW_LINE INDENT l = n - i - 1 NEW_LINE DEDENT if r == 0 and nums [ i ] != nums [ n - 1 ] : NEW_LINE INDENT r = n - i - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print Math . max ( l , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countSubarrays ( cls , arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ None ] * n + 1 NEW_LINE hash_negative = [ None ] * n + 1 NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( arr [ i ] & 1 ) == 1 : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if difference < 0 : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ None ] * NEW_LINE n = arr . length NEW_LINE print " Total ▁ Number ▁ of ▁ Even - Odd " + " ▁ subarrays ▁ are ▁ " + cls . countSubarrays ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printChar ( cls , str_ , n ) : NEW_LINE INDENT freq = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if freq [ str_ . charAt ( i ) - ' a ' ] % 2 == 1 : NEW_LINE INDENT print str_ . charAt ( i , ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE n = len ( str_ ) NEW_LINE cls . printChar ( str_ , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countGreater ( cls , arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while l <= r : NEW_LINE INDENT if arr [ m ] > k : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = arr . length NEW_LINE k = 7 NEW_LINE print cls . countGreater ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findAandB ( cls , N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if val < 0 : NEW_LINE INDENT print " NO " NEW_LINE return NEW_LINE DEDENT a = ( N + Math . sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - Math . sqrt ( val ) ) / 2.0 NEW_LINE print " a ▁ = ▁ " + a NEW_LINE print " b ▁ = ▁ " + b NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 69.0 NEW_LINE cls . findAandB ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if aa [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j < 2 : NEW_LINE INDENT while carry < 2 : NEW_LINE INDENT while a < 10 : NEW_LINE INDENT if da != - 1 and da != a : NEW_LINE INDENT continue NEW_LINE DEDENT while b < 10 : NEW_LINE INDENT if db != - 1 and db != b : NEW_LINE INDENT continue NEW_LINE DEDENT if ( j == 0 and c >= 10 ) or ( j == 1 and c < 10 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if i == n : NEW_LINE INDENT if a * b * c == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if dc == - 1 or dc == c % 10 : NEW_LINE INDENT patterns += 1 NEW_LINE DEDENT b += 1 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT dp [ i ] [ j ] += dp [ i - 1 ] [ carry ] * patterns % MOD NEW_LINE dp [ i ] [ j ] %= MOD NEW_LINE carry += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print dp [ n ] [ 0 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Multiply ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while a % 2 == 0 : NEW_LINE INDENT a = a / 2 NEW_LINE two += 1 NEW_LINE DEDENT while a % 3 == 0 : NEW_LINE INDENT a = a / 3 NEW_LINE three += 1 NEW_LINE DEDENT if a == 1 : NEW_LINE INDENT if three >= two : NEW_LINE INDENT three -= two NEW_LINE temp += three * 2 NEW_LINE print temp NEW_LINE DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Multiply . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT MOD = ( ( 1e9 + 7 ) ) NEW_LINE @ classmethod NEW_LINE def modulo_13 ( cls , s , n ) : NEW_LINE INDENT dp = [ None ] * n + 1 NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < 10 : NEW_LINE INDENT if s . charAt ( i ) == ' ? ' : NEW_LINE INDENT nxt = j NEW_LINE DEDENT while k < 13 : NEW_LINE INDENT dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE k += 1 NEW_LINE DEDENT if s . charAt ( i ) != ' ? ' : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dp [ n ] [ 5 ] ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " ? 44" NEW_LINE n = len ( s ) NEW_LINE print cls . modulo_13 ( s , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countNums ( cls , a , b , c , d ) : NEW_LINE INDENT x = b / c - ( a - 1 ) / c NEW_LINE y = b / d - ( a - 1 ) / d NEW_LINE k = ( c * d ) / __gcd ( c , d ) NEW_LINE z = b / k - ( a - 1 ) / k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return cls . __gcd ( b , a % b ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 10 NEW_LINE b = 50 NEW_LINE c = 4 NEW_LINE d = 6 NEW_LINE print cls . countNums ( a , b , c , d ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def NthCharacter ( cls , n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if c < 10 : NEW_LINE INDENT s += Integer . toString ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT while dup > 0 : NEW_LINE INDENT s1 += Integer . toString ( dup % 10 ) NEW_LINE dup /= 10 NEW_LINE DEDENT temp . append ( s1 ) NEW_LINE temp = temp . reverse ( ) NEW_LINE s += temp NEW_LINE DEDENT c += 1 NEW_LINE if len ( s ) >= n : NEW_LINE INDENT return s . charAt ( n - 1 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 11 NEW_LINE print cls . NthCharacter ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE tosi = [ None ] * n NEW_LINE M = [ None ] * n NEW_LINE D = [ None ] * n NEW_LINE i = int ( ) NEW_LINE k = int ( ) NEW_LINE c = 0 NEW_LINE while k < n : NEW_LINE INDENT tosi [ k ] = sc . nextInt ( ) NEW_LINE M [ k ] = sc . nextInt ( ) NEW_LINE D [ k ] = sc . nextInt ( ) NEW_LINE while i <= 1000 : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT total += 200 NEW_LINE DEDENT else : NEW_LINE INDENT total += 195 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if tosi [ k ] % 3 == 0 : NEW_LINE INDENT day = tuki + D [ k ] - 6 NEW_LINE DEDENT else : NEW_LINE INDENT if ( M [ k ] - 1 ) % 2 == 0 : NEW_LINE INDENT day = ( ( M [ k ] - 1 ) / 2 ) * 20 + ( ( M [ k ] - 1 ) / 2 ) * 19 + D [ k ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT day = ( ( M [ k ] ) / 2 ) * 20 + ( ( M [ k ] - 1 ) / 2 ) * 19 + D [ k ] - 1 NEW_LINE DEDENT DEDENT total = total - day NEW_LINE print total NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . ArrayList NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE n = input . nextInt ( ) NEW_LINE m = input . nextInt ( ) NEW_LINE req = ArrayList ( ) NEW_LINE pre = ArrayList ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT req . add ( input . nextInt ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < m : NEW_LINE INDENT pre . add ( input . nextInt ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT i = n - 1 NEW_LINE j = m - 1 NEW_LINE ans = 0 NEW_LINE while i >= 0 and j >= 0 : NEW_LINE INDENT if req . get ( i ) > pre . get ( j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ans + i + 1 , NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def catalanDP ( cls , n ) : NEW_LINE INDENT catalan = [ None ] * n + 2 NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE while j < i : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return catalan [ n ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT i = 0 NEW_LINE while i < 10 : NEW_LINE INDENT print cls . catalanDP ( i , + " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigInteger NEW_LINE class p243 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p243 ( ) . run ( ) NEW_LINE DEDENT TARGET = Fraction ( BigInteger . valueOf ( 15499 ) , BigInteger . valueOf ( 94744 ) ) NEW_LINE def run ( self ) : NEW_LINE INDENT totient = BigInteger . ONE NEW_LINE denominator = BigInteger . ONE NEW_LINE p = 2 NEW_LINE while True : NEW_LINE INDENT totient = totient . multiply ( BigInteger . valueOf ( p - 1 ) ) NEW_LINE denominator = denominator . multiply ( BigInteger . valueOf ( p ) ) NEW_LINE while True : NEW_LINE INDENT if not ( ( not Library . isPrime ( p ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if Fraction ( totient , denominator ) . compareTo ( self . TARGET ) < 0 : NEW_LINE INDENT while i < p : NEW_LINE INDENT if Fraction ( numer , denom . subtract ( BigInteger . ONE ) ) . compareTo ( self . TARGET ) < 0 : NEW_LINE INDENT return denom . __str__ ( ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p243 . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Ishu ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE i = int ( ) NEW_LINE j = int ( ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE k = 0 NEW_LINE dx = int ( ) NEW_LINE dy = int ( ) NEW_LINE flag = True NEW_LINE s = str ( ) NEW_LINE ch = [ None ] * 100 NEW_LINE co = [ None ] * 2 NEW_LINE s = scan . next ( ) NEW_LINE ch = s . toCharArray ( ) NEW_LINE co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE k += 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ch [ i ] == ' L ' : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT elif ch [ i ] == ' R ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif ch [ i ] == ' U ' : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif ch [ i ] == ' D ' : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while i < k - 3 : NEW_LINE INDENT while j < k : NEW_LINE INDENT dx = co [ 0 ] [ i ] - co [ 0 ] [ j ] NEW_LINE dy = co [ 1 ] [ i ] - co [ 1 ] [ j ] NEW_LINE if dx < 0 : NEW_LINE INDENT dx *= ( - 1 ) NEW_LINE DEDENT if dy < 0 : NEW_LINE INDENT dy *= ( - 1 ) NEW_LINE DEDENT if ( dx <= 1 and dy == 0 ) or ( dy <= 1 and dx == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT print " OK " NEW_LINE DEDENT else : NEW_LINE INDENT print " BUG " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Ishu . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPrime ( cls , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 2 NEW_LINE while i <= Math . sqrt ( n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def isPossible ( cls , N ) : NEW_LINE INDENT if cls . isPrime ( N ) and cls . isPrime ( N - 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 13 NEW_LINE if cls . isPossible ( n ) == True : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countDyckPaths ( cls , n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE print " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " + cls . countDyckPaths ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE tc = 0 NEW_LINE while tc < t : NEW_LINE INDENT print solve ( n ) NEW_LINE tc += 1 NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls , n ) : NEW_LINE INDENT if n <= 30 : NEW_LINE INDENT return " NO " NEW_LINE DEDENT elif n == 36 or n == 40 or n == 44 : NEW_LINE INDENT return String . format ( " YES \n 6 ▁ 10 ▁ 15 ▁ % d " , n - 31 ) NEW_LINE DEDENT else : NEW_LINE INDENT return String . format ( " YES \n 6 ▁ 10 ▁ 14 ▁ % d " , n - 30 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def pentdiagonal ( cls , a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 6 NEW_LINE print cls . pentdiagonal ( a ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def hexDiagonal ( cls , a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = ( 1.73 ) * a NEW_LINE return d NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 9 NEW_LINE print cls . hexDiagonal ( a ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class p128 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p128 ( ) . run ( ) NEW_LINE DEDENT TARGET = 2000 NEW_LINE def run ( self ) : NEW_LINE INDENT count = 2 NEW_LINE ring = 2 NEW_LINE while True : NEW_LINE INDENT if ( ring ) * 12 + 5 > Integer . MAX_VALUE : NEW_LINE INDENT raise ArithmeticException ( ) NEW_LINE DEDENT if Library . isPrime ( ring * 6 - 1 ) and Library . isPrime ( ring * 6 + 1 ) and Library . isPrime ( ring * 12 + 5 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return Long . toString ( ( ring ) * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if Library . isPrime ( ring * 6 - 1 ) and Library . isPrime ( ring * 6 + 5 ) and Library . isPrime ( ring * 12 - 7 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return Long . toString ( ( ring ) * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT ring += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p128 . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE import NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE c = 0 NEW_LINE i = 0 NEW_LINE while i <= max ( n , m ) : NEW_LINE INDENT while j <= max ( n , m ) : NEW_LINE INDENT if ( i * i ) + j == n and i + ( j * j ) == m : NEW_LINE INDENT c += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print c NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE e = [ None ] * 13 NEW_LINE i = int ( ) NEW_LINE p = 0 NEW_LINE k = int ( ) NEW_LINE while i < 12 : NEW_LINE INDENT e [ i ] = scan . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT while i < 12 : NEW_LINE INDENT while j < 12 - i : NEW_LINE INDENT if e [ j ] < e [ j + 1 ] : NEW_LINE INDENT e [ j ] = e [ j + 1 ] NEW_LINE e [ j + 1 ] = y NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT u = 0 NEW_LINE while u < 3 : NEW_LINE INDENT while k < 4 : NEW_LINE INDENT i = u * 4 NEW_LINE if e [ i ] == e [ i + 1 ] and e [ i + 2 ] == e [ i + 3 ] and e [ i ] == e [ i + 2 ] and e [ i + 1 ] == e [ i + 3 ] and e [ i ] == e [ i + 3 ] and e [ i + 1 ] == e [ i + 2 ] : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 0 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT u += 1 NEW_LINE DEDENT if p == 12 : NEW_LINE INDENT print " yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " no " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Iterator NEW_LINE import java . util . LinkedList NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < 9 : NEW_LINE INDENT pos [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT pos [ start ] = 1 NEW_LINE while i < n : NEW_LINE INDENT while j < 9 : NEW_LINE INDENT next [ j ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT while j < 9 : NEW_LINE INDENT if j % 3 != 0 and not_ != j - 1 : NEW_LINE INDENT next [ j - 1 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ j ] += pos [ j ] / 4 NEW_LINE DEDENT if j % 3 != 2 and not_ != j + 1 : NEW_LINE INDENT next [ j + 1 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ j ] += pos [ j ] / 4 NEW_LINE DEDENT if j / 3 != 0 and not_ != j - 3 : NEW_LINE INDENT next [ j - 3 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ j ] += pos [ j ] / 4 NEW_LINE DEDENT if j / 3 != 2 and not_ != j + 3 : NEW_LINE INDENT next [ j + 3 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ j ] += pos [ j ] / 4 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT next = pos NEW_LINE pos = tmp NEW_LINE i += 1 NEW_LINE DEDENT System . out . printf ( " % .8f \n " , pos [ end ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE N = sc . nextInt ( ) NEW_LINE K = sc . nextInt ( ) NEW_LINE sc . close ( ) NEW_LINE t = 1 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT t = Math . min ( 2 * t , t + K ) NEW_LINE i += 1 NEW_LINE DEDENT print t NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE @ classmethod NEW_LINE def findAndPrintUncommonChars ( cls , str1 , str2 ) : NEW_LINE INDENT present = [ None ] * MAX_CHAR NEW_LINE i = 0 NEW_LINE while i < MAX_CHAR : NEW_LINE INDENT present [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE while i < l1 : NEW_LINE INDENT present [ str1 . charAt ( i ) - ' a ' ] = 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < l2 : NEW_LINE INDENT if present [ str2 . charAt ( i ) - ' a ' ] == 1 or present [ str2 . charAt ( i ) - ' a ' ] == - 1 : NEW_LINE INDENT present [ str2 . charAt ( i ) - ' a ' ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ str2 . charAt ( i ) - ' a ' ] = 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < MAX_CHAR : NEW_LINE INDENT if present [ i ] == 1 or present [ i ] == 2 : NEW_LINE INDENT print ( ( i + ' a ' , ) + " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str1 = " characters " NEW_LINE str2 = " alphabets " NEW_LINE cls . findAndPrintUncommonChars ( str1 , str2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isInside ( cls , circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT x = 1 NEW_LINE y = 1 NEW_LINE circle_x = 0 NEW_LINE circle_y = 1 NEW_LINE rad = 2 NEW_LINE if cls . isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT print " Inside " , NEW_LINE DEDENT else : NEW_LINE INDENT print " Outside " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minSum ( cls , arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible = - 1 NEW_LINE minimum = arr [ 0 ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if arr [ i ] % x == 0 and largestDivisible < arr [ i ] : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) NEW_LINE return Math . min ( sum , sumAfterOperation ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = arr . length NEW_LINE x = 3 NEW_LINE print cls . minSum ( arr , n , x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def nthTerm ( cls , n ) : NEW_LINE INDENT nth = long ( ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = long ( ) NEW_LINE n = 5 NEW_LINE print cls . nthTerm ( n ) NEW_LINE n = 25 NEW_LINE print cls . nthTerm ( n ) NEW_LINE n = 25000000 NEW_LINE print cls . nthTerm ( n ) NEW_LINE n = 250000007 NEW_LINE print cls . nthTerm ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class c1029A ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE n = scan . nextInt ( ) NEW_LINE k = scan . nextInt ( ) NEW_LINE s = scan . next ( ) NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s . substring ( 0 , i ) == s . substring ( s . length ( - i ) ) : NEW_LINE INDENT ans = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sb = StringBuilder ( ) NEW_LINE len ( sb . append ( s . substring ( s ) - ans ) ) NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT sb . append ( s . substring ( ans ) ) NEW_LINE i += 1 NEW_LINE DEDENT print sb NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE c1029A . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE left = Node ( ) NEW_LINE right = Node ( ) NEW_LINE DEDENT class INT ( object ) : NEW_LINE INDENT a = int ( ) NEW_LINE def __init__ ( self , a ) : NEW_LINE INDENT self . a = a NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def newNode ( cls , data ) : NEW_LINE INDENT temp = cls . Node ( ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT @ classmethod NEW_LINE def printInorder ( cls , node ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return NEW_LINE DEDENT cls . printInorder ( node . left ) NEW_LINE System . out . printf ( " % d ▁ " , node . data ) NEW_LINE cls . printInorder ( node . right ) NEW_LINE DEDENT @ classmethod NEW_LINE def conBinaryTreeUtil ( cls , pre , preM , preIndex , l , h , size ) : NEW_LINE INDENT if preIndex . a >= size or l > h : NEW_LINE INDENT return None NEW_LINE DEDENT root = cls . newNode ( pre [ preIndex . a ] ) NEW_LINE ( preIndex . a ) += 1 NEW_LINE if l == h : NEW_LINE INDENT return root NEW_LINE DEDENT i = int ( ) NEW_LINE while i <= h : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i <= h : NEW_LINE INDENT root . left = conBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) NEW_LINE root . right = conBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) NEW_LINE DEDENT return root NEW_LINE DEDENT @ classmethod NEW_LINE def conBinaryTree ( cls , root , pre , preMirror , size ) : NEW_LINE INDENT preIndex = cls . INT ( 0 ) NEW_LINE preMIndex = 0 NEW_LINE root = conBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) NEW_LINE cls . printInorder ( root ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT preOrder = [ 1 , 2 , 4 , 5 , 3 , 6 , 7 ] NEW_LINE preOrderMirror = [ 1 , 3 , 7 , 6 , 2 , 5 , 4 ] NEW_LINE size = preOrder . length NEW_LINE root = cls . Node ( ) NEW_LINE cls . conBinaryTree ( root , preOrder , preOrderMirror , size ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT no_of_chars = 256 NEW_LINE @ classmethod NEW_LINE def findSubString ( cls , str_ , pat ) : NEW_LINE INDENT len1 = len ( str_ ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print " No ▁ such ▁ window ▁ exists " NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ None ] * no_of_chars NEW_LINE hash_str = [ None ] * no_of_chars NEW_LINE i = 0 NEW_LINE while i < len2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = Integer . MAX_VALUE NEW_LINE count = 0 NEW_LINE j = 0 NEW_LINE while j < len1 : NEW_LINE INDENT hash_str [ str_ . charAt ( j ) ] += 1 NEW_LINE if hash_pat [ str_ . charAt ( j ) ] != 0 and hash_str [ str_ . charAt ( j ) ] <= hash_pat [ str_ . charAt ( j ) ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while hash_str [ str_ . charAt ( start ) ] > hash_pat [ str_ . charAt ( start ) ] or hash_pat [ str_ . charAt ( start ) ] == 0 : NEW_LINE INDENT if hash_str [ str_ . charAt ( start ) ] > hash_pat [ str_ . charAt ( start ) ] : NEW_LINE INDENT hash_str [ str_ . charAt ( start ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT if start_index == - 1 : NEW_LINE INDENT print " No ▁ such ▁ window ▁ exists " NEW_LINE return " " NEW_LINE DEDENT return str_ . substring ( start_index , start_index + min_len ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " this ▁ is ▁ a ▁ test ▁ string " NEW_LINE pat = " tist " NEW_LINE print " Smallest ▁ window ▁ is ▁ : \n ▁ " + cls . findSubString ( str_ , pat , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Comparator NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE while in_ . hasNext ( ) : NEW_LINE INDENT while i < 4 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) > 0 and ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) > 0 and ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) > 0 ) or ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) < 0 and ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) < 0 and ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) < 0 ) : NEW_LINE INDENT judge = True NEW_LINE DEDENT print " YES " if judge else " NO " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def ccw ( cls , p1 , p2 , p3 ) : NEW_LINE INDENT return ( p2 . y - p1 . y ) * ( p3 . x - p1 . x ) - ( p3 . y - p1 . y ) * ( p2 . x - p1 . x ) NEW_LINE DEDENT DEDENT class Point2 ( object ) : NEW_LINE INDENT x = float ( ) NEW_LINE y = float ( ) NEW_LINE def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . HashMap NEW_LINE import java . util . Map NEW_LINE import java . util . Scanner NEW_LINE class PolandBoardAndGame ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = cls . sc . nextInt ( ) NEW_LINE m = cls . sc . nextInt ( ) NEW_LINE if n > m : NEW_LINE INDENT print " YES " NEW_LINE DEDENT elif m > n : NEW_LINE INDENT print " NO " NEW_LINE DEDENT else : NEW_LINE INDENT while i < n : NEW_LINE INDENT map . put ( cls . sc . next ( ) , 1 ) NEW_LINE i += 1 NEW_LINE DEDENT while i < m : NEW_LINE INDENT if map . containsKey ( cls . sc . next ( ) ) : NEW_LINE INDENT dem += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if dem % 2 == 0 : NEW_LINE INDENT print " NO " NEW_LINE DEDENT else : NEW_LINE INDENT print " YES " NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE PolandBoardAndGame . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE science = [ None ] * 4 NEW_LINE minsc = 100 NEW_LINE sumsc = 0 NEW_LINE i = 0 NEW_LINE while i < 4 : NEW_LINE INDENT science [ i ] = sc . nextInt ( ) NEW_LINE minsc = Math . min ( minsc , science [ i ] ) NEW_LINE sumsc += science [ i ] NEW_LINE i += 1 NEW_LINE DEDENT sumsc -= minsc NEW_LINE sumso = sc . nextInt ( ) NEW_LINE x = sc . nextInt ( ) NEW_LINE if sumso < x : NEW_LINE INDENT sumso = x NEW_LINE DEDENT print sumsc + sumso NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE sb = StringBuilder ( ) NEW_LINE c = [ None ] * 3 NEW_LINE b = True NEW_LINE i = 0 NEW_LINE while i < 3 : NEW_LINE INDENT while j < 3 : NEW_LINE INDENT c [ i ] [ j ] = sc . nextInt ( ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < 2 : NEW_LINE INDENT while j < 3 : NEW_LINE INDENT if c [ i ] [ 0 ] - c [ j ] [ 0 ] == c [ i ] [ 1 ] - c [ j ] [ 1 ] and c [ i ] [ 1 ] - c [ j ] [ 1 ] == c [ i ] [ 2 ] - c [ j ] [ 2 ] : NEW_LINE else : NEW_LINE INDENT b = False NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < 2 : NEW_LINE INDENT while j < 3 : NEW_LINE INDENT if c [ 0 ] [ i ] - c [ 0 ] [ j ] == c [ 1 ] [ i ] - c [ 1 ] [ j ] and c [ 1 ] [ i ] - c [ 1 ] [ j ] == c [ 2 ] [ i ] - c [ 2 ] [ j ] : NEW_LINE else : NEW_LINE INDENT b = False NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if b : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class p218 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p218 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p218 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def search ( cls , arr , x ) : NEW_LINE INDENT n = arr . length NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = cls . search ( arr , x ) NEW_LINE if result == - 1 : NEW_LINE INDENT print " Element ▁ is ▁ not ▁ present ▁ in ▁ array " , NEW_LINE DEDENT else : NEW_LINE INDENT print " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . IOException NEW_LINE import java . io . BufferedReader NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE input = br . readLine ( ) . split ( " ▁ " ) NEW_LINE n = Integer . parseInt ( input [ 0 ] ) NEW_LINE c = Long . parseLong ( input [ 1 ] ) NEW_LINE forwardMax = [ None ] * n + 1 NEW_LINE backwardMax = [ None ] * n + 1 NEW_LINE positions = [ None ] * n + 1 NEW_LINE values = [ None ] * n + 1 NEW_LINE positions [ 0 ] = 0 NEW_LINE values [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT input = br . readLine ( ) . split ( " ▁ " ) NEW_LINE positions [ i ] = Long . parseLong ( input [ 0 ] ) NEW_LINE values [ i ] = Long . parseLong ( input [ 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT max = 0 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i <= n : NEW_LINE INDENT sum += values [ i ] NEW_LINE max = Math . max ( max , sum - positions [ i ] ) NEW_LINE forwardMax [ i ] = max NEW_LINE i += 1 NEW_LINE DEDENT max = 0 NEW_LINE sum = 0 NEW_LINE i = n NEW_LINE while i >= 0 : NEW_LINE INDENT sum += values [ i ] NEW_LINE max = Math . max ( max , sum - ( c - positions [ i ] ) ) NEW_LINE backwardMax [ i ] = max NEW_LINE i -= 1 NEW_LINE DEDENT res = 0 NEW_LINE i = 0 NEW_LINE while i <= n : NEW_LINE INDENT res = Math . max ( res , forwardMax [ i ] ) NEW_LINE if i != n : NEW_LINE INDENT res = Math . max ( res , forwardMax [ i ] - ( positions [ i ] ) + backwardMax [ i + 1 ] ) NEW_LINE DEDENT res = Math . max ( res , backwardMax [ i ] ) NEW_LINE if i != 0 : NEW_LINE INDENT res = Math . max ( res , backwardMax [ i ] - ( c - positions [ i ] ) + forwardMax [ i - 1 ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def MinStep ( cls , a , n ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE zero = 0 NEW_LINE step = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif a [ i ] < 0 : NEW_LINE INDENT negative += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step = step + ( a [ i ] - 1 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if negative % 2 == 0 : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if zero > 0 : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 0 , - 2 , - 1 , - 3 , 4 ] NEW_LINE n = a . length NEW_LINE print cls . MinStep ( a , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE number = sc . nextInt ( ) NEW_LINE start = sc . nextInt ( ) NEW_LINE end = sc . nextInt ( ) NEW_LINE arr = [ None ] * number + 1 NEW_LINE str_ = sc . next ( ) NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT arr [ i + 1 ] = str_ . charAt ( i ) - '0' NEW_LINE i += 1 NEW_LINE DEDENT if arr [ start ] == arr [ end ] : NEW_LINE INDENT print 0 NEW_LINE DEDENT else : NEW_LINE INDENT print Math . abs ( arr [ start ] - arr [ end ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return cls . __gcd ( b , a % b ) NEW_LINE DEDENT @ classmethod NEW_LINE def noOfSquares ( cls , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = Math . abs ( x2 - x1 ) NEW_LINE dy = Math . abs ( y2 - y1 ) NEW_LINE ans = dx + dy - cls . __gcd ( dx , dy ) NEW_LINE print ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x1 = 1 NEW_LINE y1 = 1 NEW_LINE x2 = 4 NEW_LINE y2 = 3 NEW_LINE cls . noOfSquares ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def get_maximum ( cls , s , a ) : NEW_LINE INDENT n = s . length NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] - '0' < a [ s [ i ] - '0' ] : NEW_LINE INDENT while j < n and ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) : NEW_LINE INDENT s [ j ] = ( ( '0' + a [ s [ j ] - '0' ] ) ) NEW_LINE j += 1 NEW_LINE DEDENT return String . valueOf ( s ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return String . valueOf ( s ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = "1337" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print cls . get_maximum ( s . toCharArray ( ) , a ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def binarySearch ( cls , arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE midValue = arr [ mid ] NEW_LINE if mid == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = Math . min ( mid - 1 , midValue ) NEW_LINE left = cls . binarySearch ( arr , low , leftindex ) NEW_LINE if left >= 0 : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = Math . max ( mid + 1 , midValue ) NEW_LINE right = cls . binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ] NEW_LINE print " Fixed ▁ Point ▁ is ▁ " + cls . binarySearch ( arr , 0 , arr . length - 1 ) NEW_LINE arr1 = [ - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 ] NEW_LINE print " Fixed ▁ Point ▁ is ▁ " + cls . binarySearch ( arr1 , 0 , arr1 . length - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . ArrayDeque NEW_LINE import java . util . ArrayList NEW_LINE import java . util . List NEW_LINE import java . util . Queue NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE str_ = br . readLine ( ) . split ( " ▁ " ) NEW_LINE n = Integer . parseInt ( str_ [ 0 ] ) NEW_LINE k = Integer . parseInt ( str_ [ 1 ] ) NEW_LINE x = [ None ] * n NEW_LINE str_ = br . readLine ( ) . split ( " ▁ " ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT x [ i ] = Integer . parseInt ( str_ [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT ans = Integer . MAX_VALUE NEW_LINE i = 0 NEW_LINE while i + k - 1 < n : NEW_LINE INDENT ans = Math . min ( ans , Math . min ( Math . abs ( left ) , Math . abs ( right ) ) + right - left ) NEW_LINE i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE import java . util . Arrays NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE a = [ None ] * 105 NEW_LINE max = 0 NEW_LINE i = 0 NEW_LINE while i <= n - 1 : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE if i > 0 and a [ i ] > a [ max ] : NEW_LINE INDENT max = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ansmax = a [ max ] + m NEW_LINE i = 0 NEW_LINE while i <= m - 1 : NEW_LINE INDENT while j <= n - 1 : NEW_LINE INDENT if j > 0 and a [ j ] < a [ min ] : NEW_LINE INDENT min = j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT a [ min ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT max = 0 NEW_LINE i = 1 NEW_LINE while i <= n - 1 : NEW_LINE INDENT if a [ i ] > a [ max ] : NEW_LINE INDENT max = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ansmin = a [ max ] NEW_LINE print ansmin + " ▁ " + ansmax , NEW_LINE sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT









class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findSum ( cls , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE print cls . findSum ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT N = 10000 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE p = ArrayList ( ) NEW_LINE i = 2 NEW_LINE while len ( p ) <= N : NEW_LINE INDENT while j < len ( p ) : NEW_LINE INDENT f &= i % p . get ( j ) != 0 NEW_LINE if not f : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if f : NEW_LINE INDENT p . add ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < n : NEW_LINE INDENT sum += p . get ( i ) NEW_LINE i += 1 NEW_LINE DEDENT print sum NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT def debug ( self , * os ) : NEW_LINE INDENT System . err . println ( Arrays . deepToString ( os ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class Optimal_BST2 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def optimalSearchTree ( cls , keys , freq , n ) : NEW_LINE INDENT cost = [ None ] * n + 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT L = 2 NEW_LINE while L <= n : NEW_LINE INDENT while i <= n - L + 1 : NEW_LINE INDENT cost [ i ] [ j ] = Integer . MAX_VALUE NEW_LINE while r <= j : NEW_LINE INDENT if c < cost [ i ] [ j ] : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT r += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def sum ( cls , freq , i , j ) : NEW_LINE INDENT s = 0 NEW_LINE k = i NEW_LINE while k <= j : NEW_LINE INDENT if k >= freq . length : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ k ] NEW_LINE k += 1 NEW_LINE DEDENT return s NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT keys = [ 10 , 12 , 20 ] NEW_LINE freq = [ 34 , 8 , 50 ] NEW_LINE n = keys . length NEW_LINE print " Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ " + cls . optimalSearchTree ( keys , freq , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Optimal_BST2 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def get ( cls , x , y , z ) : NEW_LINE INDENT if x > z : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) / y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 1 NEW_LINE y = 5 NEW_LINE z = 8 NEW_LINE print cls . get ( x , y , z , + " \n " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isVowel ( cls , ch ) : NEW_LINE INDENT if ch == ' a ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' e ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' i ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' o ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif ch == ' u ' : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def vowelPairs ( cls , s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if cls . isVowel ( s . charAt ( i ) ) and cls . isVowel ( s . charAt ( i + 1 ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " abaebio " NEW_LINE n = len ( s ) NEW_LINE print cls . vowelPairs ( s , n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . PrintWriter NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls ) : NEW_LINE INDENT scn = Scanner ( System . in_ ) NEW_LINE pr = PrintWriter ( System . out ) NEW_LINE __N_0 = N NEW_LINE N -= 1 NEW_LINE while True : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while __N_0 > 0 : NEW_LINE INDENT map [ scn . nextInt ( ) ] [ scn . nextInt ( ) ] += 1 NEW_LINE DEDENT while s <= W - S + 1 : NEW_LINE INDENT while t <= H - T + 1 : NEW_LINE INDENT while a < s + S : NEW_LINE INDENT while b < t + T : NEW_LINE INDENT count += map [ a ] [ b ] NEW_LINE b += 1 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT if max < count : NEW_LINE INDENT max = count NEW_LINE DEDENT t += 1 NEW_LINE DEDENT s += 1 NEW_LINE DEDENT pr . println ( max ) NEW_LINE DEDENT pr . flush ( ) NEW_LINE scn . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isSubstring ( cls , s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT while j < M : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s1 = " for " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = cls . isSubstring ( s1 , s2 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print " Not ▁ present " NEW_LINE DEDENT else : NEW_LINE INDENT print " Present ▁ at ▁ index ▁ " + res NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def angleOncirCumference ( cls , z ) : NEW_LINE INDENT return ( z / 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT angle = 65 NEW_LINE z = cls . angleOncirCumference ( angle ) NEW_LINE print " The ▁ angle ▁ is ▁ " + z + " ▁ degrees " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printNumbers ( cls , N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if N > 0 : NEW_LINE INDENT while x > 0 and flag == 1 : NEW_LINE INDENT if digit != 1 and digit != 3 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x / 10 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print N + " ▁ " , NEW_LINE DEDENT cls . printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 20 NEW_LINE cls . printNumbers ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class TheRank ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE ans = 0 NEW_LINE rank = 1 NEW_LINE arr = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT arr [ i ] = sum NEW_LINE i += 1 NEW_LINE DEDENT for j in arr : NEW_LINE INDENT if arr [ 0 ] < j : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print rank NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE TheRank . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isHeap ( cls , arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= ( n - 2 ) / 2 : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = arr . length NEW_LINE if cls . isHeap ( arr , n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isHeap ( cls , arr , i , n ) : NEW_LINE INDENT if i > ( n - 2 ) / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and cls . isHeap ( arr , 2 * i + 1 , n ) and cls . isHeap ( arr , 2 * i + 2 , n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = arr . length - 1 NEW_LINE if cls . isHeap ( arr , 0 , n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findMinDel ( cls , arr , n ) : NEW_LINE INDENT min_num = Integer . MAX_VALUE NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return n - cnt NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] NEW_LINE n = arr . length NEW_LINE print cls . findMinDel ( arr , n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class Test ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printCubes ( cls , a , b ) : NEW_LINE INDENT i = a NEW_LINE while i <= b : NEW_LINE INDENT while j * j * j <= i : NEW_LINE INDENT if j * j * j == i : NEW_LINE INDENT print j * j * j + " ▁ ▁ " , NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 1 NEW_LINE b = 100 NEW_LINE print " Perfect ▁ cubes ▁ in ▁ given ▁ range : " NEW_LINE cls . printCubes ( a , b ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def getModulo ( cls , n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 6 NEW_LINE d = 4 NEW_LINE print n + " ▁ moduo ▁ " + d + " ▁ is ▁ " + cls . getModulo ( n , d ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . Arrays NEW_LINE import java . util . StringTokenizer NEW_LINE class pre598 ( object ) : NEW_LINE INDENT class FastReader ( object ) : NEW_LINE INDENT br = BufferedReader ( ) NEW_LINE st = StringTokenizer ( ) NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st == None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return Double . parseDouble ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT str_ = " " NEW_LINE try : NEW_LINE INDENT str_ = br . readLine ( ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT return str_ NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT obj = cls . FastReader ( ) NEW_LINE n = obj . nextInt ( ) NEW_LINE d = obj . nextInt ( ) NEW_LINE arr = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT Arrays . sort ( arr ) NEW_LINE max = Integer . MIN_VALUE NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT if l < arr [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT max = Math . max ( max , count ) NEW_LINE i += 1 NEW_LINE DEDENT print n - max NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE pre598 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPerfectCube ( cls , x ) : NEW_LINE INDENT cr = ( Math . cbrt ( x ) ) NEW_LINE return ( cr * cr * cr == x ) NEW_LINE DEDENT @ classmethod NEW_LINE def canBePerfectCube ( cls , N , K ) : NEW_LINE INDENT if cls . isPerfectCube ( N + K ) or cls . isPerfectCube ( N - K ) == True : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 7 NEW_LINE K = 1 NEW_LINE cls . canBePerfectCube ( N , K ) NEW_LINE N = 5 NEW_LINE K = 4 NEW_LINE cls . canBePerfectCube ( N , K ) NEW_LINE N = 7 NEW_LINE K = 2 NEW_LINE cls . canBePerfectCube ( N , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE t = scan . nextInt ( ) NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT print maxLeft ( n ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def maxLeft ( cls , n ) : NEW_LINE INDENT return n - 2 if n > 2 else 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class CandyAndFriend ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE while t > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE sum += a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT if a [ i ] > div : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print count NEW_LINE DEDENT else : NEW_LINE INDENT print - 1 NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE CandyAndFriend . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . solveD ( ) NEW_LINE DEDENT def solveD ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE N = sc . nextInt ( ) NEW_LINE t = [ None ] * N NEW_LINE sum_t = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT t [ i ] = sc . nextInt ( ) * 2 NEW_LINE sum_t += t [ i ] NEW_LINE i += 1 NEW_LINE DEDENT v = [ None ] * N NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT v [ i ] = sc . nextInt ( ) * 2 NEW_LINE i += 1 NEW_LINE DEDENT tmp_v = 0 NEW_LINE tmp_t = 0 NEW_LINE max_v = [ None ] * sum_t + 1 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE tmp_t += 1 NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] if v [ i ] < tmp_v else tmp_v NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE while t_ind < t [ i ] : NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] if v [ i ] < tmp_v + 1 else tmp_v + 1 NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE t_ind += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT tmp_v = 0 NEW_LINE i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] if v [ i ] < tmp_v else tmp_v NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE while t_ind < t [ i ] : NEW_LINE INDENT tmp_t -= 1 NEW_LINE max_v [ tmp_t ] = max_v [ tmp_t ] if max_v [ tmp_t ] < back_v else back_v NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE t_ind += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT answer = 0 NEW_LINE i = 0 NEW_LINE while i < sum_t : NEW_LINE INDENT answer += ( max_v [ i ] + max_v [ i + 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT print answer * 0.125 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT













class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findNumber ( cls , N , S ) : NEW_LINE INDENT i = ( ( ( ( N ) ) * ( ( N + 1 ) ) ) / 4 ) - ( ( ( S + 1 ) ) / 2 ) NEW_LINE return i NEW_LINE DEDENT @ classmethod NEW_LINE def check ( cls , N , S ) : NEW_LINE INDENT i = cls . findNumber ( N , S ) NEW_LINE integerI = ( i ) NEW_LINE if i - integerI == 0 : NEW_LINE INDENT print " Yes : ▁ " + integerI + " , ▁ " + ( integerI + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 4 NEW_LINE S = 3 NEW_LINE cls . check ( N , S ) NEW_LINE N = 5 NEW_LINE S = 3 NEW_LINE cls . check ( N , S ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countOcc ( cls , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 0 NEW_LINE while i < len ( s ) - 3 : NEW_LINE INDENT while j < i + 4 : NEW_LINE INDENT if s . charAt ( j ) == ' c ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif s . charAt ( j ) == ' l ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif s . charAt ( j ) == ' a ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif s . charAt ( j ) == ' p ' : NEW_LINE INDENT p += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if c == 1 and l == 1 and a == 1 and p == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " clapc " NEW_LINE print cls . countOcc ( s . toLowerCase ( , ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPerfectSquare ( cls , x ) : NEW_LINE INDENT sr = Math . sqrt ( x ) NEW_LINE return ( ( sr - Math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT @ classmethod NEW_LINE def isSunnyNum ( cls , n ) : NEW_LINE INDENT if cls . isPerfectSquare ( n + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE if cls . isSunnyNum ( n ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < N : NEW_LINE INDENT replaces [ sc . next ( ) . toCharArray ( ) [ 0 ] ] = sc . next ( ) . toCharArray ( ) [ 0 ] NEW_LINE i += 1 NEW_LINE DEDENT while i < M : NEW_LINE INDENT print replaces [ c ] if replaces [ c ] != 0 else c , NEW_LINE i += 1 NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def trailing_zeros ( cls , N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE i = 1 NEW_LINE while i <= N : NEW_LINE INDENT while val % 2 == 0 and val > 0 : NEW_LINE INDENT val /= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while val % 5 == 0 and val > 0 : NEW_LINE INDENT val /= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = Math . min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 12 NEW_LINE print cls . trailing_zeros ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GfG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def removeZero ( cls , n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 10 != 0 : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def isEqual ( cls , a , b ) : NEW_LINE INDENT if cls . removeZero ( a ) + cls . removeZero ( b ) == removeZero ( a + b ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 105 NEW_LINE b = 106 NEW_LINE if cls . isEqual ( a , b ) == True : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GfG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE import java . util . Locale NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scn = Scanner ( System . in_ ) NEW_LINE size = scn . nextInt ( ) NEW_LINE arr = [ None ] * size NEW_LINE i = 0 NEW_LINE while i < size : NEW_LINE INDENT arr [ i ] = scn . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT print asd ( arr ) NEW_LINE DEDENT @ classmethod NEW_LINE def asd ( cls , arr ) : NEW_LINE INDENT Arrays . sort ( arr ) NEW_LINE return arr [ arr . length / 2 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def totalPairs ( cls , s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ None ] * 7 NEW_LINE arr2 = [ None ] * 7 NEW_LINE i = 0 NEW_LINE while i < len ( s1 ) : NEW_LINE INDENT arr1 [ set_bits ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( s2 ) : NEW_LINE INDENT arr2 [ set_bits ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= 6 : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s1 = " geeks " NEW_LINE s2 = " forgeeks " NEW_LINE print cls . totalPairs ( s1 , s2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countSubSeq ( cls , i , sum , cnt , a , n ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if sum == 0 and cnt > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , sum , cnt , a , n ) NEW_LINE ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ - 1 , 2 , - 2 , 1 ] NEW_LINE n = a . length NEW_LINE print cls . countSubSeq ( 0 , 0 , 0 , a , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Decoding ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT reader = Scanner ( System . in_ ) NEW_LINE n = reader . nextInt ( ) NEW_LINE s = [ None ] * n NEW_LINE newS = [ None ] * n NEW_LINE input = reader . next ( ) NEW_LINE s = input . toCharArray ( ) NEW_LINE mid = ( n - 1 ) / 2 NEW_LINE counter = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT newS [ mid - counter ] = s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT newS [ mid + counter ] = s [ i ] NEW_LINE DEDENT if counter >= 0 : NEW_LINE INDENT counter = counter - temp NEW_LINE DEDENT else : NEW_LINE INDENT counter = counter + temp NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print str ( newS ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Decoding . main ( sys . argv ) NEW_LINE DEDENT

class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def pivotedBinarySearch ( cls , arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT @ classmethod NEW_LINE def findPivot ( cls , arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return cls . findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return cls . findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT @ classmethod NEW_LINE def binarySearch ( cls , arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return cls . binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return cls . binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = arr1 . length NEW_LINE key = 3 NEW_LINE print " Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ " + cls . pivotedBinarySearch ( arr1 , n , key ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class HocJava ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = int ( ) NEW_LINE mod = 1000000007 NEW_LINE n = sc . nextInt ( ) NEW_LINE res = 0 NEW_LINE c = [ None ] * 4050 NEW_LINE dp = [ None ] * 4050 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT c [ i ] [ 0 ] = 1 NEW_LINE while j < i : NEW_LINE INDENT c [ i ] [ j ] = ( c [ i - 1 ] [ j - 1 ] + c [ i - 1 ] [ j ] ) % mod NEW_LINE j += 1 NEW_LINE DEDENT c [ i ] [ i ] = 1 NEW_LINE i += 1 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT while j < i : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT res = ( res + g ) % mod NEW_LINE i += 1 NEW_LINE DEDENT print res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE HocJava . main ( sys . argv ) NEW_LINE DEDENT
import java . awt . Point NEW_LINE import java . util . Arrays NEW_LINE import java . util . Comparator NEW_LINE import java . util . Scanner NEW_LINE class A843 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE N = in_ . nextInt ( ) NEW_LINE P = [ None ] * N NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT P [ n ] = Point ( n , in_ . nextInt ( ) ) NEW_LINE n += 1 NEW_LINE DEDENT Arrays . sort ( P , Comparator ( ) ) NEW_LINE output = StringBuilder ( ) NEW_LINE lineCount = 0 NEW_LINE used = [ None ] * N NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT if not used [ n ] : NEW_LINE INDENT lineCount += 1 NEW_LINE while not used [ pos ] : NEW_LINE INDENT count += 1 NEW_LINE used [ pos ] = True NEW_LINE line . append ( ' ▁ ' ) . append ( pos + 1 ) NEW_LINE pos = P [ pos ] . x NEW_LINE DEDENT output . append ( count ) . append ( line ) . append ( ' \n ' ) NEW_LINE DEDENT n += 1 NEW_LINE DEDENT print lineCount NEW_LINE print output , NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A843 . main ( sys . argv ) NEW_LINE DEDENT


import java . util . LinkedList NEW_LINE import java . util . Scanner NEW_LINE import java . util . Iterator NEW_LINE class Graph ( object ) : NEW_LINE INDENT totalVertex = int ( ) NEW_LINE adjList = LinkedList ( ) NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . totalVertex = 0 NEW_LINE DEDENT def loadAdjList ( self ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE self . totalVertex = in_ . nextInt ( ) NEW_LINE self . adjList = LinkedList ( ) NEW_LINE i = 0 NEW_LINE while i < totalVertex : NEW_LINE INDENT while j < degree : NEW_LINE INDENT tmp . add ( idx2 ) NEW_LINE j += 1 NEW_LINE DEDENT self . adjList . add ( tmp ) NEW_LINE i += 1 NEW_LINE DEDENT in_ . close ( ) NEW_LINE DEDENT def printAdjMatrix ( self ) : NEW_LINE INDENT adjMatrix = [ None ] * totalVertex NEW_LINE i = 0 NEW_LINE while i < totalVertex : NEW_LINE INDENT while j < totalVertex : NEW_LINE INDENT if vertexes . contains ( j ) : NEW_LINE INDENT adjMatrix [ i ] [ j ] = 1 NEW_LINE print "1" , NEW_LINE DEDENT else : NEW_LINE INDENT adjMatrix [ i ] [ j ] = 0 NEW_LINE print "0" , NEW_LINE DEDENT if j != totalVertex - 1 : NEW_LINE INDENT print " ▁ " , NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , argv ) : NEW_LINE INDENT g = Graph ( ) NEW_LINE g . loadAdjList ( ) NEW_LINE g . printAdjMatrix ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT N = 100005 NEW_LINE d = [ None ] * N NEW_LINE pre = [ None ] * N NEW_LINE @ classmethod NEW_LINE def Positive_Divisors ( cls ) : NEW_LINE INDENT i = 1 NEW_LINE while i < N : NEW_LINE INDENT while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT cls . d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cls . d [ i ] += 2 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 2 NEW_LINE while i < N : NEW_LINE INDENT if cls . d [ i ] == d [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT cls . pre [ i ] = ans NEW_LINE i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print cls . pre [ n ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT MAX = 256 NEW_LINE @ classmethod NEW_LINE def lastNonRepeating ( cls , str_ , n ) : NEW_LINE INDENT freq = [ None ] * MAX NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if freq [ ch ] == 1 : NEW_LINE INDENT return ( " " + ch ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return " - 1" NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " GeeksForGeeks " NEW_LINE n = len ( str_ ) NEW_LINE print cls . lastNonRepeating ( str_ , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def y ( cls , x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def BooleRule ( cls , a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = int ( ) NEW_LINE h = ( ( ( b - a ) / n ) ) NEW_LINE sum = 0 NEW_LINE bl = ( 7 * cls . y ( a ) + 32 * cls . y ( a + h ) + 12 * cls . y ( a + 2 * h ) + 32 * cls . y ( a + 3 * h ) + 7 * cls . y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT System . out . printf ( ( " f ( x ) ▁ = ▁ % .4f " ) , cls . BooleRule ( 0 , 4 ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = [ None ] * maxN NEW_LINE v = [ None ] * maxN NEW_LINE @ classmethod NEW_LINE def findLen ( cls , arr , i , curr , n , m ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if cls . v [ i ] [ curr ] : NEW_LINE INDENT return cls . dp [ i ] [ curr ] NEW_LINE DEDENT cls . v [ i ] [ curr ] = True NEW_LINE l = cls . findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = cls . findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) NEW_LINE cls . dp [ i ] [ curr ] = l NEW_LINE if r != - 1 : NEW_LINE INDENT cls . dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return cls . dp [ i ] [ curr ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = arr . length NEW_LINE m = 3 NEW_LINE ans = cls . findLen ( arr , 0 , 0 , n , m ) NEW_LINE if ans == - 1 : NEW_LINE INDENT print 0 NEW_LINE DEDENT else : NEW_LINE INDENT print ans NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT cost = int ( ) NEW_LINE n = int ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT cls . n = in_ . nextInt ( ) NEW_LINE if cls . n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT cls . cost = [ None ] * n + 1 NEW_LINE while i < n - 1 : NEW_LINE INDENT cls . cost [ a ] [ b ] = cost [ b ] [ a ] = c NEW_LINE ans += cost [ a ] [ b ] * 2 NEW_LINE i += 1 NEW_LINE DEDENT while i <= n : NEW_LINE INDENT while j <= n : NEW_LINE INDENT if cls . cost [ i ] [ j ] > 0 or cls . cost [ i ] [ j ] == - 1 : NEW_LINE INDENT reaf += 1 NEW_LINE ii = i NEW_LINE jj = j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if i != 1 and reaf == 1 : NEW_LINE INDENT ans -= cost [ ii ] [ jj ] * 2 NEW_LINE cls . cost [ ii ] [ jj ] = cost [ jj ] [ ii ] = - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ans - max ( 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def max ( cls , m ) : NEW_LINE INDENT cut = 0 NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT if cls . cost [ m ] [ i ] > 0 : NEW_LINE INDENT cls . cost [ i ] [ m ] = 0 NEW_LINE cut = Math . max ( cut , cost [ m ] [ i ] + max ( i ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cut NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT





class p204 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p204 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT return Integer . toString ( count ( 0 , 1 ) ) NEW_LINE DEDENT LIMIT = Library . pow ( 10 , 9 ) NEW_LINE primes = Library . listPrimes ( 100 ) NEW_LINE def count ( self , primeIndex , product ) : NEW_LINE INDENT if primeIndex == primes . length : NEW_LINE INDENT return 1 if product <= LIMIT else 0 NEW_LINE DEDENT else : NEW_LINE INDENT while product <= LIMIT : NEW_LINE INDENT self . count += count ( primeIndex + 1 , product ) NEW_LINE product *= primes [ primeIndex ] NEW_LINE DEDENT return self . count NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p204 . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Shopping ( object ) : NEW_LINE INDENT def input ( self , numberOne , numberTwo , numberThree ) : NEW_LINE INDENT one = numberOne + numberTwo + numberThree NEW_LINE two = 2 * ( numberOne + numberTwo ) NEW_LINE three = 2 * ( numberOne + numberThree ) NEW_LINE four = 2 * ( numberTwo + numberThree ) NEW_LINE print java . lang . Math . min ( java . lang . Math . min ( one , two ) , java . lang . Math . min ( three , four ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , a ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE instance_ = Shopping ( ) NEW_LINE numOne = input . nextInt ( ) NEW_LINE numTwo = input . nextInt ( ) NEW_LINE numThree = input . nextInt ( ) NEW_LINE instance_ . input ( numOne , numTwo , numThree ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Shopping . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def makeEven ( cls , string ) : NEW_LINE INDENT str_ = string . toCharArray ( ) NEW_LINE n = str_ . length NEW_LINE even = Integer . MAX_VALUE NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if ( str_ [ i ] - '0' ) % 2 == 0 : NEW_LINE INDENT even = ( str_ [ i ] - '0' ) NEW_LINE index = i NEW_LINE DEDENT if even <= ( str_ [ n - 1 ] - '0' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if even == Integer . MAX_VALUE : NEW_LINE INDENT return str_ NEW_LINE DEDENT swap ( str_ , index , n - 1 ) NEW_LINE return str_ NEW_LINE DEDENT @ classmethod NEW_LINE def swap ( cls , str_ , index1 , index2 ) : NEW_LINE INDENT temp = str_ [ index1 ] NEW_LINE str_ [ index1 ] = str_ [ index2 ] NEW_LINE str_ [ index2 ] = temp NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = "1356425" NEW_LINE print cls . makeEven ( str_ , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findDivisors ( cls , n ) : NEW_LINE INDENT div = [ None ] * n + 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j * i <= n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 10 NEW_LINE cls . findDivisors ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX_CHAR = 256 NEW_LINE @ classmethod NEW_LINE def printDistinct ( cls , str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE count = [ None ] * MAX_CHAR NEW_LINE index = [ None ] * MAX_CHAR NEW_LINE i = 0 NEW_LINE while i < MAX_CHAR : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT count [ x ] += 1 NEW_LINE if count [ x ] == 1 and x != ' ▁ ' : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if count [ x ] == 2 : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT i += 1 NEW_LINE DEDENT Arrays . sort ( index ) NEW_LINE i = 0 NEW_LINE while i < MAX_CHAR and index [ i ] != n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " GeeksforGeeks " NEW_LINE cls . printDistinct ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def calculate ( cls , x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE __k_0 = k NEW_LINE k -= 1 NEW_LINE while __k_0 > 0 : NEW_LINE INDENT result = ( Math . pow ( result , x ) ) NEW_LINE if result > m : NEW_LINE INDENT result %= m NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 5 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print cls . calculate ( x , k , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT







class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def power ( cls , x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y % 2 == 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def findModuloByM ( cls , X , N , M ) : NEW_LINE INDENT if N < 6 : NEW_LINE INDENT while i < N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if N % 2 == 0 : NEW_LINE INDENT return res NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print cls . findModuloByM ( X , N , M ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def numberOfPaths ( cls , m , n ) : NEW_LINE INDENT count = [ None ] * m NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < m : NEW_LINE INDENT while j < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print cls . numberOfPaths ( 3 , 3 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isKthBitSet ( cls , n , k ) : NEW_LINE INDENT if ( n >> ( k - 1 ) ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def setKthBit ( cls , n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) | n ) NEW_LINE DEDENT @ classmethod NEW_LINE def allBitsAreSet ( cls , n ) : NEW_LINE INDENT if ( ( n + 1 ) & n ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def bitsAreInAltOrder ( cls , n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return cls . allBitsAreSet ( num ) NEW_LINE DEDENT @ classmethod NEW_LINE def bitsAreInAltPatrnInGivenRange ( cls , n , l , r ) : NEW_LINE INDENT num = int ( ) NEW_LINE left_shift = int ( ) NEW_LINE if cls . isKthBitSet ( n , r ) : NEW_LINE INDENT num = n NEW_LINE left_shift = r NEW_LINE DEDENT else : NEW_LINE INDENT num = setKthBit ( n , ( r + 1 ) ) NEW_LINE left_shift = r + 1 NEW_LINE DEDENT num = num & ( ( 1 << left_shift ) - 1 ) NEW_LINE num = num >> ( l - 1 ) NEW_LINE return cls . bitsAreInAltOrder ( num ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if cls . bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def commonPrefixUtil ( cls , str1 , str2 ) : NEW_LINE INDENT result = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if str1 . charAt ( i ) != str2 . charAt ( j ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 . charAt ( i ) NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT @ classmethod NEW_LINE def commonPrefix ( cls , arr , n ) : NEW_LINE INDENT Arrays . sort ( arr ) NEW_LINE print cls . commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geek " , " geezer " ] NEW_LINE n = arr . length NEW_LINE cls . commonPrefix ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE N = sc . nextInt ( ) NEW_LINE a = [ None ] * N * 3 NEW_LINE i = 0 NEW_LINE while i < N * 3 : NEW_LINE INDENT a [ i ] = sc . nextLong ( ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . sort ( a ) NEW_LINE sum = 0 NEW_LINE i = N NEW_LINE while i < 3 * N : NEW_LINE INDENT sum += a [ i ] NEW_LINE i += 2 NEW_LINE DEDENT print sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class p301 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p301 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE i = 0 NEW_LINE while i < 32 : NEW_LINE INDENT a = b NEW_LINE b = c NEW_LINE i += 1 NEW_LINE DEDENT return Integer . toString ( a ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p301 . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Arrays NEW_LINE class p070 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p070 ( ) . run ( ) NEW_LINE DEDENT LIMIT = Library . pow ( 10 , 7 ) NEW_LINE def run ( self ) : NEW_LINE INDENT minNumer = 1 NEW_LINE minDenom = 0 NEW_LINE totients = Library . listTotients ( self . LIMIT - 1 ) NEW_LINE n = 2 NEW_LINE while n < totients . length : NEW_LINE INDENT if ( n ) * minDenom < ( minNumer ) * tot and hasSameDigits ( n , tot ) : NEW_LINE INDENT minNumer = n NEW_LINE minDenom = tot NEW_LINE DEDENT n += 1 NEW_LINE DEDENT if minDenom == 0 : NEW_LINE INDENT raise RuntimeException ( " Not ▁ found " ) NEW_LINE DEDENT return Integer . toString ( minNumer ) NEW_LINE DEDENT @ classmethod NEW_LINE def hasSameDigits ( cls , x , y ) : NEW_LINE INDENT xdigits = Integer . toString ( x ) . toCharArray ( ) NEW_LINE ydigits = Integer . toString ( y ) . toCharArray ( ) NEW_LINE Arrays . sort ( xdigits ) NEW_LINE Arrays . sort ( ydigits ) NEW_LINE return Arrays == xdigits , ydigits NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p070 . main ( sys . argv ) NEW_LINE DEDENT



class cfg ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def subarrayCount ( cls , arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE fast = 0 NEW_LINE slow = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] - arr [ i - 1 ] == 1 : NEW_LINE INDENT fast += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += len * ( len - 1 ) / 2 NEW_LINE fast = i NEW_LINE slow = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if fast != slow : NEW_LINE INDENT result += len * ( len - 1 ) / 2 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 6 , 7 ] NEW_LINE n = arr . length NEW_LINE print cls . subarrayCount ( arr , n ) NEW_LINE DEDENT DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = java . util . Scanner ( System . in_ ) NEW_LINE n = scan . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = scan . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT sum = long ( ) NEW_LINE min = long ( ) NEW_LINE max = long ( ) NEW_LINE sum = 0 NEW_LINE max = - 1000000 NEW_LINE min = 1000000 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum += a [ i ] NEW_LINE if max <= a [ i ] : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT if min >= a [ i ] : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print min + " ▁ " + max + " ▁ " + sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX_CHARS = 256 NEW_LINE @ classmethod NEW_LINE def findSubString ( cls , str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE dist_count = 0 NEW_LINE visited = [ None ] * MAX_CHARS NEW_LINE Arrays . fill ( visited , False ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if visited [ str_ . charAt ( i ) ] == False : NEW_LINE INDENT visited [ str_ . charAt ( i ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = Integer . MAX_VALUE NEW_LINE count = 0 NEW_LINE curr_count = [ None ] * MAX_CHARS NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT curr_count [ str_ . charAt ( j ) ] += 1 NEW_LINE if curr_count [ str_ . charAt ( j ) ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist_count : NEW_LINE INDENT while curr_count [ str_ . charAt ( start ) ] > 1 : NEW_LINE INDENT if curr_count [ str_ . charAt ( start ) ] > 1 : NEW_LINE INDENT curr_count [ str_ . charAt ( start ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT return str_ . substring ( start_index , start_index + min_len ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " aabcbcdbca " NEW_LINE print " Smallest ▁ window ▁ containing ▁ all ▁ distinct " + " ▁ characters ▁ is : ▁ " + cls . findSubString ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE A = sc . nextInt ( ) NEW_LINE B = sc . nextInt ( ) NEW_LINE C = sc . nextInt ( ) NEW_LINE D = sc . nextInt ( ) NEW_LINE E = sc . nextInt ( ) NEW_LINE F = sc . nextInt ( ) NEW_LINE water = 0 NEW_LINE suger = 0 NEW_LINE watmax = 0 NEW_LINE sugmax = 0 NEW_LINE maxnodo = 100 * E / ( 100 + E ) NEW_LINE nodo = 0 NEW_LINE nodomax = 0 NEW_LINE a = 0 NEW_LINE while a <= F / 100 : NEW_LINE INDENT while b <= F / 100 : NEW_LINE INDENT while c <= F : NEW_LINE INDENT while d <= F : NEW_LINE INDENT water = 100 * a + 100 * b NEW_LINE suger = c + d NEW_LINE if water == 0 or water + suger > F : NEW_LINE INDENT break NEW_LINE DEDENT nodo = 100 * suger / ( water + suger ) NEW_LINE if nodo >= nodomax and nodo <= maxnodo : NEW_LINE INDENT watmax = water NEW_LINE sugmax = suger NEW_LINE nodomax = nodo NEW_LINE DEDENT d += D NEW_LINE DEDENT c += C NEW_LINE DEDENT b += B NEW_LINE DEDENT a += A NEW_LINE DEDENT print ( watmax ) + ( sugmax ) + " ▁ " + ( sugmax ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE before = None NEW_LINE while True : NEW_LINE INDENT if not sc . hasNext ( ) : NEW_LINE INDENT break NEW_LINE DEDENT while i < str_ . length : NEW_LINE INDENT inner [ i ] = Integer . parseInt ( str_ [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT if before == None : NEW_LINE INDENT before = inner NEW_LINE DEDENT else : NEW_LINE INDENT while i < before . length : NEW_LINE INDENT if i < tmp . length : NEW_LINE INDENT if tmp [ i ] < before [ i ] + inner [ i ] : NEW_LINE INDENT tmp [ i ] = before [ i ] + inner [ i ] NEW_LINE DEDENT DEDENT if before . length > tmp . length : NEW_LINE INDENT if ( i - 1 ) < tmp . length and ( i - 1 ) >= 0 : NEW_LINE INDENT if tmp [ i - 1 ] < before [ i ] + inner [ i - 1 ] : NEW_LINE INDENT tmp [ i - 1 ] = before [ i ] + inner [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( i + 1 ) < tmp . length : NEW_LINE INDENT if tmp [ i + 1 ] < before [ i ] + inner [ i + 1 ] : NEW_LINE INDENT tmp [ i + 1 ] = before [ i ] + inner [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT before = tmp NEW_LINE DEDENT DEDENT print before [ 0 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countPairs ( cls , arr , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( even ) * ( n - 1 ) NEW_LINE print ( odd ) * ( n - 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = arr . length NEW_LINE cls . countPairs ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . HashMap NEW_LINE import java . util . HashSet NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE m = sc . nextInt ( ) NEW_LINE arrs = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT arrs [ i ] = sc . next ( ) NEW_LINE i += 1 NEW_LINE DEDENT length = [ None ] * n NEW_LINE index = 0 NEW_LINE returnDex = 0 NEW_LINE for tmp in arrs : NEW_LINE __index_0 = index NEW_LINE index += 1 NEW_LINE INDENT if dexG > dexS : NEW_LINE INDENT returnDex = - 1 NEW_LINE DEDENT length [ __index_0 ] = dexS - dexG NEW_LINE DEDENT set = HashSet ( ) NEW_LINE for len in length : NEW_LINE INDENT set . add ( len ) NEW_LINE DEDENT if returnDex == - 1 : NEW_LINE INDENT print returnDex NEW_LINE DEDENT else : NEW_LINE INDENT print len ( set ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def search ( cls , arr , n , x ) : NEW_LINE INDENT front = 0 NEW_LINE back = n - 1 NEW_LINE while front <= back : NEW_LINE INDENT if arr [ front ] == x or arr [ back ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = arr . length NEW_LINE if cls . search ( arr , n , x ) : NEW_LINE INDENT print " Yes " , NEW_LINE DEDENT else : NEW_LINE INDENT print " No " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findEquation ( cls , a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print " x ^ 2 ▁ - ▁ ( " + sum + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE cls . findEquation ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . regex . Pattern NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT reader = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE builder = StringBuilder ( ) NEW_LINE n = Integer . parseInt ( reader . readLine ( ) ) NEW_LINE pattern = Pattern . compile ( " that | this " ) NEW_LINE __n_0 = n NEW_LINE n -= 1 NEW_LINE while __n_0 > 0 : NEW_LINE INDENT while i < 26 : NEW_LINE INDENT while j < 26 : NEW_LINE INDENT a = rep ( result , i , j ) NEW_LINE if pattern . matcher ( a ) . find ( ) : NEW_LINE INDENT builder . append ( a ) . append ( ' \n ' ) NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT DEDENT print builder , NEW_LINE DEDENT @ classmethod NEW_LINE def rep ( cls , a , i , j ) : NEW_LINE INDENT chs = len ( [ None ] * a ) NEW_LINE k = 0 NEW_LINE while k < len ( a ) : NEW_LINE INDENT if ' a ' <= a . charAt ( k ) and a . charAt ( k ) <= ' z ' : NEW_LINE INDENT chs [ k ] = ( ( ( b * i + j ) % 26 + 97 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT chs [ k ] = a . charAt ( k ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return String . valueOf ( chs ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findNature ( cls , a , b , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return True if ( a & 1 ) == 1 else False NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return True if ( b & 1 ) == 1 else False NEW_LINE DEDENT if ( a & 1 ) == 0 : NEW_LINE INDENT if ( b & 1 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 3 != 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) == 0 : NEW_LINE INDENT return ( ( n - 1 ) % 3 != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) % 3 != 0 ) NEW_LINE DEDENT DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE n = 3 NEW_LINE if cls . findNature ( a , b , n ) : NEW_LINE INDENT print " Odd " NEW_LINE DEDENT else : NEW_LINE INDENT print " Even " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT







import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE n = scanner . nextLong ( ) NEW_LINE s = scanner . nextLong ( ) NEW_LINE if n < s : NEW_LINE INDENT print - 1 NEW_LINE return NEW_LINE DEDENT d = 39 NEW_LINE while d > 1 : NEW_LINE INDENT while d * Math . log ( b ) <= Math . log ( n ) : NEW_LINE INDENT if test ( b , n , s ) : NEW_LINE INDENT print b NEW_LINE return NEW_LINE DEDENT b += 1 NEW_LINE DEDENT d -= 1 NEW_LINE DEDENT a1 = ( Math . sqrt ( n - s ) ) NEW_LINE while a1 >= 1 : NEW_LINE INDENT if ( n - s ) % a1 == 0 : NEW_LINE INDENT if a0 >= 0 and a0 < b and a0 + a1 == s : NEW_LINE INDENT print b NEW_LINE return NEW_LINE DEDENT DEDENT a1 -= 1 NEW_LINE DEDENT if n == s : NEW_LINE INDENT print n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print - 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def test ( cls , b , n , s ) : NEW_LINE INDENT if b < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % b NEW_LINE n /= b NEW_LINE DEDENT return sum == s NEW_LINE DEDENT @ classmethod NEW_LINE def lowerBound ( cls , d , n ) : NEW_LINE INDENT left = 1 NEW_LINE right = n NEW_LINE logn = Math . log ( n ) NEW_LINE while right - left > 1 : NEW_LINE INDENT if logm > logn : NEW_LINE INDENT right = mid NEW_LINE DEDENT else : NEW_LINE INDENT left = mid NEW_LINE DEDENT DEDENT return right NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check ( cls , n , m ) : NEW_LINE INDENT if m % n == 0 : NEW_LINE INDENT print " YES " , NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " , NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE m = 10 NEW_LINE cls . check ( n , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE a = sc . nextInt ( ) NEW_LINE b = sc . nextInt ( ) NEW_LINE if a <= b : NEW_LINE INDENT print b - a NEW_LINE DEDENT else : NEW_LINE INDENT print a - b NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE a = sc . nextInt ( ) NEW_LINE b = sc . nextInt ( ) NEW_LINE c = [ None ] * a NEW_LINE s = sc . next ( ) NEW_LINE c = s . toCharArray ( ) NEW_LINE ch = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < 26 : NEW_LINE INDENT ch [ i ] = ( ( ' a ' + i ) ) NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < b : NEW_LINE INDENT while j < 26 : NEW_LINE INDENT if ch [ j ] == mm and flag == 1 : NEW_LINE INDENT ch [ j ] = nn NEW_LINE flag = 0 NEW_LINE DEDENT if ch [ j ] == nn and flag == 1 : NEW_LINE INDENT ch [ j ] = mm NEW_LINE flag = 0 NEW_LINE DEDENT flag = 1 NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < a : NEW_LINE INDENT c [ i ] = ch [ c [ i ] - 97 ] NEW_LINE i += 1 NEW_LINE DEDENT print c NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class MUHandSticks ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = Scanner ( System . in_ ) NEW_LINE sticks = [ None ] * 9 NEW_LINE i = 0 NEW_LINE while i < 6 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT legs = False NEW_LINE headbody = False NEW_LINE i = 0 NEW_LINE while i < 9 : NEW_LINE INDENT if sticks [ i ] >= 4 : NEW_LINE INDENT legs = True NEW_LINE DEDENT if sticks [ i ] >= 6 : NEW_LINE INDENT headbody = True NEW_LINE DEDENT if sticks [ i ] == 2 : NEW_LINE INDENT headbody = True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if legs and headbody : NEW_LINE INDENT print " Elephant " NEW_LINE DEDENT elif legs : NEW_LINE INDENT print " Bear " NEW_LINE DEDENT else : NEW_LINE INDENT print " Alien " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE MUHandSticks . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigInteger NEW_LINE class p401 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p401 ( ) . run ( ) NEW_LINE DEDENT LIMIT = 1000000000000000 L NEW_LINE MODULUS = Library . pow ( 10 , 9 ) NEW_LINE def run ( self ) : NEW_LINE INDENT splitCount = ( Library . sqrt ( self . LIMIT ) ) NEW_LINE splitCount = Math . max ( splitCount / 3 , 1 ) NEW_LINE splitAt = ( ( self . LIMIT / ( splitCount + 1 ) ) ) NEW_LINE sum = 0 NEW_LINE i = 1 NEW_LINE while i <= splitAt : NEW_LINE INDENT term = term * count % MODULUS NEW_LINE sum = ( sum + term ) % MODULUS NEW_LINE i += 1 NEW_LINE DEDENT i = splitCount NEW_LINE while i >= 1 : NEW_LINE INDENT sumSquares = ( sumSquares + MODULUS ) % MODULUS NEW_LINE sum = ( sum + i * sumSquares % MODULUS ) % MODULUS NEW_LINE i -= 1 NEW_LINE DEDENT return Long . toString ( sum ) NEW_LINE DEDENT MODULUS_BI = BigInteger . valueOf ( MODULUS ) NEW_LINE SIX_BI = BigInteger . valueOf ( 6 ) NEW_LINE @ classmethod NEW_LINE def sumSquaresMod ( cls , n ) : NEW_LINE INDENT x = BigInteger . valueOf ( n ) NEW_LINE y = x . multiply ( x . add ( BigInteger . ONE ) ) NEW_LINE y = y . multiply ( x . shiftLeft ( 1 ) . add ( BigInteger . ONE ) ) NEW_LINE y = y . divide ( SIX_BI ) NEW_LINE y = y . mod ( MODULUS_BI ) NEW_LINE return y . longValue ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p401 . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE b = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import java . util . StringTokenizer NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = MyScanner ( ) NEW_LINE n = sc . nextInt ( ) NEW_LINE q = sc . nextInt ( ) NEW_LINE a = [ None ] * n NEW_LINE a [ 0 ] = sc . nextInt ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT pw = PrintWriter ( System . out ) NEW_LINE i = 0 NEW_LINE while i < q : NEW_LINE INDENT while left < n : NEW_LINE INDENT while right < n and sum + a [ right ] <= x : NEW_LINE cnt += right - left NEW_LINE if right == left : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= a [ left ] NEW_LINE DEDENT left += 1 NEW_LINE DEDENT pw . println ( cnt ) NEW_LINE i += 1 NEW_LINE DEDENT pw . flush ( ) NEW_LINE DEDENT class MyScanner ( object ) : NEW_LINE INDENT reader = BufferedReader ( InputStreamReader ( System . in_ ) , 1 << 15 ) NEW_LINE tokenizer = StringTokenizer ( ) NEW_LINE def next ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while self . tokenizer == None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT self . tokenizer = StringTokenizer ( reader . readLine ( ) ) NEW_LINE DEDENT DEDENT except IOException as ignored : NEW_LINE INDENT pass NEW_LINE DEDENT return self . tokenizer . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class A1642 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE T = in_ . nextInt ( ) NEW_LINE t = 0 NEW_LINE while t < T : NEW_LINE INDENT while i < 3 : NEW_LINE INDENT X [ i ] = in_ . nextInt ( ) NEW_LINE Y [ i ] = in_ . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT while i < 3 : NEW_LINE INDENT if Y [ i ] == Y [ ( i + 1 ) % 3 ] and Y [ i ] > Y [ ( i + 2 ) % 3 ] : NEW_LINE INDENT answer += Math . abs ( X [ ( i + 1 ) % 3 ] - X [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print answer NEW_LINE t += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A1642 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPalindrome ( cls , str_ ) : NEW_LINE INDENT len = len ( str_ ) NEW_LINE i = 0 NEW_LINE while i < len / 2 : NEW_LINE INDENT if str_ . charAt ( i ) != str_ . charAt ( len - 1 - i ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def createStringAndCheckPalindrome ( cls , N ) : NEW_LINE INDENT sub = " " + N NEW_LINE res_str = " " NEW_LINE sum = 0 NEW_LINE while N > 0 : NEW_LINE INDENT sum += digit NEW_LINE N = N / 10 NEW_LINE DEDENT while len ( res_str ) < sum : NEW_LINE if len ( res_str ) > sum : NEW_LINE INDENT res_str = res_str . substring ( 0 , sum ) NEW_LINE DEDENT if cls . isPalindrome ( res_str ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 10101 NEW_LINE if cls . createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Scanner NEW_LINE class CF1293B ( object ) : NEW_LINE INDENT scanner = Scanner ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . scanner = Scanner ( System . in_ ) NEW_LINE n = cls . scanner . nextInt ( ) NEW_LINE res = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE CF1293B . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sum ( cls , n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) / 3 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 2 NEW_LINE print cls . sum ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxHandshake ( cls , n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 10 NEW_LINE print cls . maxHandshake ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def grayCode ( cls , n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 10 NEW_LINE print cls . grayCode ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def Max_Sum ( cls , n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 8 NEW_LINE print cls . Max_Sum ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def possibleways ( cls , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT return n / 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n / 4 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 20 NEW_LINE print cls . possibleways ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def CountSetBits ( cls , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) == 1 : NEW_LINE INDENT return 1 + cls . CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return cls . CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 21 NEW_LINE print cls . CountSetBits ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sum ( cls , m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT m = 3 NEW_LINE n = 2 NEW_LINE print cls . sum ( m , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def SUM ( cls , n , m ) : NEW_LINE INDENT if m == 1 : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT sum = cls . SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) / 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE print " SUM ( " + n + " , ▁ " + m + " ) : ▁ " + cls . SUM ( n , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxLCM ( cls , n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE print cls . maxLCM ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findSum ( cls , n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE print cls . findSum ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def cntWays ( cls , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) / 4 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 18 NEW_LINE print cls . cntWays ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def find_composite_nos ( cls , n ) : NEW_LINE INDENT print 9 * n + " ▁ " + 8 * n NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE cls . find_composite_nos ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findThirdDigit ( cls , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if ( n & 1 ) > 0 else 6 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 7 NEW_LINE print cls . findThirdDigit ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countMaxIntersect ( cls , n ) : NEW_LINE INDENT return ( n ) * ( n - 1 ) / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 8 NEW_LINE print cls . countMaxIntersect ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sum ( cls , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + cls . sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 2 NEW_LINE print cls . sum ( n ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def highestPowerOf2 ( cls , n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 48 NEW_LINE print cls . highestPowerOf2 ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countIntersections ( cls , n ) : NEW_LINE INDENT return n * ( n - 1 ) / 2 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE print cls . countIntersections ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE s = sc . next ( ) NEW_LINE sc . close ( ) NEW_LINE c = " None " NEW_LINE i = ' a ' NEW_LINE while i <= ' z ' : NEW_LINE INDENT if not s . contains ( " " + ( i ) ) : NEW_LINE INDENT c = " " + ( i ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print c NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print " ABC " if 1200 > sc . nextInt ( ) else " ARC " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def smallest ( cls , x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while x != 0 and y != 0 and z != 0 : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE System . out . printf ( " Minimum ▁ of ▁ 3" + " ▁ numbers ▁ is ▁ % d " , cls . smallest ( x , y , z ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE c1 = scan . nextInt ( ) NEW_LINE c5 = scan . nextInt ( ) NEW_LINE c10 = scan . nextInt ( ) NEW_LINE c50 = scan . nextInt ( ) NEW_LINE c100 = scan . nextInt ( ) NEW_LINE c500 = scan . nextInt ( ) NEW_LINE if c1 + c5 * 5 + c10 * 10 + c50 * 50 + c100 * 100 + c500 * 500 < 1000 : NEW_LINE INDENT print "0" NEW_LINE DEDENT else : NEW_LINE INDENT print "1" NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import java . util . StringTokenizer NEW_LINE class Another ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = FastReader ( ) NEW_LINE pw = PrintWriter ( System . out ) NEW_LINE m = in_ . nextLong ( ) NEW_LINE R = in_ . nextLong ( ) NEW_LINE pw . printf ( " % .12f \n " , ( 2 + 2. * ( m - 1 ) * m * ( m + 1 ) / 3 / m / m - 2 * ( 2 - Math . sqrt ( 2 ) ) + ( 2 - Math . sqrt ( 2 ) ) * ( 2 * m + 2 * ( m - 1 ) ) / m / m ) * R ) NEW_LINE pw . flush ( ) NEW_LINE pw . close ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT st = StringTokenizer ( ) NEW_LINE br = BufferedReader ( ) NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT if self . st == None or not self . st . hasMoreTokens ( ) : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def hasNext ( self ) : NEW_LINE INDENT if self . st != None and self . st . hasMoreTokens ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT s = self . br . readLine ( ) NEW_LINE if s == None or s . isEmpty ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT self . st = StringTokenizer ( s ) NEW_LINE return True NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return Double . parseDouble ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . br . readLine ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Another . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countCubes ( cls , a , b ) : NEW_LINE INDENT return ( ( Math . floor ( Math . cbrt ( b ) ) - Math . ceil ( Math . cbrt ( a ) ) + 1 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE print " Count ▁ of ▁ cubes ▁ is ▁ " + cls . countCubes ( a , b , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . io . IOException NEW_LINE import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if ( D | N ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < N : NEW_LINE INDENT a [ i ] = aa NEW_LINE e [ i ] = ee NEW_LINE r [ i ] = rr NEW_LINE i += 1 NEW_LINE DEDENT for d in dp : NEW_LINE INDENT Arrays . fill ( d , INF ) NEW_LINE DEDENT dp [ D ] [ 0 ] = 0 NEW_LINE while i > 0 : NEW_LINE INDENT while j <= 100 : NEW_LINE INDENT if dp [ i ] [ j ] == INF : NEW_LINE INDENT continue NEW_LINE DEDENT while k < N : NEW_LINE INDENT if j < r [ k ] : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ Math . max ( 0 , i - a [ k ] ) ] [ Math . min ( 100 , j + e [ k ] ) ] = Math . min ( dp [ Math . max ( 0 , i - a [ k ] ) ] [ Math . min ( 100 , j + e [ k ] ) ] , dp [ i ] [ j ] + 1 ) NEW_LINE k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT while i < 101 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print " NA " if ret == INF else ret NEW_LINE DEDENT DEDENT INF = 1 << 30 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class p012 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p012 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT triangle = 0 NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if Integer . MAX_VALUE - triangle < i : NEW_LINE INDENT raise ArithmeticException ( " Overflow " ) NEW_LINE DEDENT triangle += i NEW_LINE if countDivisors ( triangle ) > 500 : NEW_LINE INDENT return Integer . toString ( triangle ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def countDivisors ( cls , n ) : NEW_LINE INDENT count = 0 NEW_LINE end = Library . sqrt ( n ) NEW_LINE i = 1 NEW_LINE while i < end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if end * end == n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p012 . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def SieveOfEratosthenes ( cls , n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT while i <= n : NEW_LINE INDENT i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def findPrimePair ( cls , n ) : NEW_LINE INDENT isPrime = [ None ] * n + 1 NEW_LINE cls . SieveOfEratosthenes ( n , isPrime ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if isPrime [ i ] and isPrime [ n - i ] : NEW_LINE INDENT print i + " ▁ " + ( n - i , ) NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 74 NEW_LINE cls . findPrimePair ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def replaceDigit ( cls , x , d1 , d2 ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while x % 10 > 0 : NEW_LINE INDENT if remainder == d1 : NEW_LINE INDENT result = result + d2 * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = x / 10 NEW_LINE DEDENT return result NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 645 NEW_LINE d1 = 6 NEW_LINE d2 = 5 NEW_LINE print cls . replaceDigit ( x , d1 , d2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def printPattern ( cls , i , j , n ) : NEW_LINE INDENT if j >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if j == i or j == n - 1 - i : NEW_LINE INDENT if i == n - 1 - j : NEW_LINE INDENT print " / " , NEW_LINE DEDENT else : NEW_LINE INDENT print " \\ " , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " * " , NEW_LINE DEDENT if cls . printPattern ( i , j + 1 , n ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT print NEW_LINE return cls . printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 9 NEW_LINE cls . printPattern ( 0 , 0 , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT







import java . util . Scanner NEW_LINE class Beat ( object ) : NEW_LINE INDENT number = int ( ) NEW_LINE def __init__ ( self , number ) : NEW_LINE INDENT self . number = number NEW_LINE DEDENT def getNumber ( self ) : NEW_LINE INDENT return self . number NEW_LINE DEDENT numberEven = 0 NEW_LINE numberOdd = 0 NEW_LINE def input ( self , number ) : NEW_LINE INDENT if number % 2 == 0 : NEW_LINE INDENT self . numberEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . numberOdd += 1 NEW_LINE DEDENT DEDENT def printResult ( self ) : NEW_LINE INDENT print java . lang . Math . min ( self . numberEven , self . numberOdd ) NEW_LINE self . numberEven = 0 NEW_LINE self . numberOdd = 0 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , a ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE number = input . nextInt ( ) NEW_LINE instance_ = Beat ( number ) NEW_LINE i = 0 NEW_LINE while i < instance_ . getNumber ( ) : NEW_LINE INDENT while k < num : NEW_LINE INDENT instance_ . input ( n ) NEW_LINE k += 1 NEW_LINE DEDENT instance_ . printResult ( ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Beat . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE s1 = sc . next ( ) . toCharArray ( ) NEW_LINE ans = 0 NEW_LINE c1 = 0 NEW_LINE c0 = 0 NEW_LINE i = 0 NEW_LINE while i < s1 . length : NEW_LINE INDENT if s1 [ i ] == '1' : NEW_LINE INDENT if c0 > 0 : NEW_LINE INDENT c0 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c1 > 0 : NEW_LINE INDENT c1 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ans * 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def pythagoreanTriplet ( cls , n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n / 3 : NEW_LINE INDENT while j <= n / 2 : NEW_LINE INDENT if i * i + j * j == k * k : NEW_LINE INDENT print i + " , ▁ " + j + " , ▁ " + k , NEW_LINE return NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print " No ▁ Triplet " , NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT n = 12 NEW_LINE cls . pythagoreanTriplet ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countDigits ( cls , a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) ) + 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 33 NEW_LINE b = - 24 NEW_LINE print cls . countDigits ( a , b , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . StringTokenizer NEW_LINE class main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT fr = FastReader ( ) NEW_LINE n = fr . nextInt ( ) NEW_LINE sum = 0 NEW_LINE total = 0 NEW_LINE i = 1 NEW_LINE if n == 2 : NEW_LINE INDENT print 1 NEW_LINE return NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT n -= 1 NEW_LINE if n > 0 : NEW_LINE INDENT if n >= 2 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT n -= 2 NEW_LINE DEDENT total += 1 NEW_LINE DEDENT print total NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE st = StringTokenizer ( " " ) NEW_LINE def next ( self ) : NEW_LINE INDENT while not self . st . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = StringTokenizer ( br . readLine ( ) ) NEW_LINE DEDENT except IOException as e : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def readArray ( self , n ) : NEW_LINE INDENT a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return a NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return Integer . parseInt ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return Long . parseLong ( self . next ( ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE main . main ( sys . argv ) NEW_LINE DEDENT
import java . math . BigDecimal NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT num = float ( ) NEW_LINE sc = Scanner ( System . in_ ) NEW_LINE d = Doctor ( ) NEW_LINE while True : NEW_LINE INDENT num = sc . nextDouble ( ) NEW_LINE if num < 0 : NEW_LINE INDENT break NEW_LINE DEDENT d = Doctor ( num ) NEW_LINE if d . judge ( ) : NEW_LINE INDENT print d . getBD ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print " NA " NEW_LINE DEDENT DEDENT DEDENT DEDENT class Doctor ( object ) : NEW_LINE INDENT num = float ( ) NEW_LINE bd = str ( ) NEW_LINE integers = int ( ) NEW_LINE decimals = float ( ) NEW_LINE def __init__ ( self , num ) : NEW_LINE INDENT self . num = num NEW_LINE self . bd = " " NEW_LINE self . integers = ( num ) NEW_LINE self . decimals = BigDecimal ( num - integers ) . setScale ( 4 , BigDecimal . ROUND_UP ) . doubleValue ( ) NEW_LINE DEDENT def judge ( self ) : NEW_LINE INDENT if self . integers > 255 or self . decimals > 0.9375 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def toBinaryDigits ( self ) : NEW_LINE INDENT tmp = " " NEW_LINE count = 1 NEW_LINE i = self . integers NEW_LINE while i > 0 : NEW_LINE INDENT tmp += i % 2 NEW_LINE i /= 2 NEW_LINE DEDENT sb = StringBuffer ( tmp ) NEW_LINE i = 0 NEW_LINE while i < 8 - len ( tmp ) : NEW_LINE INDENT self . bd += "0" NEW_LINE i += 1 NEW_LINE DEDENT self . bd += sb . reverse ( ) . __str__ ( ) + " . " NEW_LINE while True : NEW_LINE INDENT if self . decimals == 0 : NEW_LINE INDENT self . bd += "0000" NEW_LINE break NEW_LINE DEDENT if count > 4 : NEW_LINE INDENT return False NEW_LINE DEDENT self . decimals *= 2 NEW_LINE if self . decimals >= 1 : NEW_LINE INDENT self . decimals -= 1 NEW_LINE self . bd += "1" NEW_LINE if self . decimals == 0 : NEW_LINE INDENT while i < 4 - count : NEW_LINE INDENT self . bd += "0" NEW_LINE i += 1 NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . bd += "0" NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getBD ( self ) : NEW_LINE INDENT if self . toBinaryDigits ( ) : NEW_LINE INDENT return self . bd NEW_LINE DEDENT return " NA " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def digSum ( cls , n ) : NEW_LINE INDENT sum = 0 NEW_LINE rem = 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE sum += rem NEW_LINE n /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def findX ( cls , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 43 NEW_LINE print " x ▁ = ▁ " + cls . findX ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




import java . util . Locale NEW_LINE import java . util . Scanner NEW_LINE class B215 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Locale . setDefault ( Locale . US ) NEW_LINE in_ = Scanner ( System . in_ ) NEW_LINE N = in_ . nextInt ( ) NEW_LINE R1 = [ None ] * N NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT R1 [ n ] = in_ . nextInt ( ) NEW_LINE n += 1 NEW_LINE DEDENT M = in_ . nextInt ( ) NEW_LINE P1 = [ None ] * M NEW_LINE m = 0 NEW_LINE while m < M : NEW_LINE INDENT P1 [ m ] = in_ . nextInt ( ) NEW_LINE m += 1 NEW_LINE DEDENT K = in_ . nextInt ( ) NEW_LINE P2 = [ None ] * K NEW_LINE k = 0 NEW_LINE while k < K : NEW_LINE INDENT P2 [ k ] = in_ . nextInt ( ) NEW_LINE k += 1 NEW_LINE DEDENT A = in_ . nextInt ( ) NEW_LINE B = in_ . nextInt ( ) NEW_LINE maxR1 = 0 NEW_LINE for r1 in R1 : NEW_LINE INDENT maxR1 = Math . max ( maxR1 , r1 ) NEW_LINE DEDENT maxP1 = 0 NEW_LINE for p1 in P1 : NEW_LINE INDENT maxP1 = Math . max ( maxP1 , p1 ) NEW_LINE DEDENT minP2 = Integer . MAX_VALUE NEW_LINE for p2 in P2 : NEW_LINE INDENT minP2 = Math . min ( minP2 , p2 ) NEW_LINE DEDENT r2 = Math . sqrt ( maxR1 * maxR1 * ( B ) * maxP1 / ( A * minP2 + B * maxP1 ) ) NEW_LINE print r2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE B215 . main ( sys . argv ) NEW_LINE DEDENT
class HelloWorld ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def trapeziumPattern ( cls , num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfSpaces = 0 NEW_LINE numOfLines = num NEW_LINE while numOfLines >= 1 : NEW_LINE __firsthalf_0 = firsthalf NEW_LINE firsthalf += 1 NEW_LINE __firsthalf_1 = firsthalf NEW_LINE firsthalf += 1 NEW_LINE __secondhalf_2 = secondhalf NEW_LINE secondhalf += 1 NEW_LINE INDENT while numOfSpacesCounter >= 1 : NEW_LINE INDENT print " ▁ " , NEW_LINE numOfSpacesCounter -= 1 NEW_LINE DEDENT while firstHalfCounter <= numOfLines : NEW_LINE INDENT if firstHalfCounter == numOfLines : NEW_LINE INDENT print ( __firsthalf_0 , ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( __firsthalf_1 , + " * " ) NEW_LINE DEDENT firstHalfCounter += 1 NEW_LINE DEDENT while secondHalfCounter <= numOfLines : NEW_LINE INDENT print " * " + ( __secondhalf_2 , ) NEW_LINE secondHalfCounter += 1 NEW_LINE DEDENT print NEW_LINE numOfSpaces += 2 NEW_LINE secondhalf = ( secondhalf - 1 ) - ( ( numOfLines - 1 ) * 2 ) NEW_LINE numOfLines -= 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . trapeziumPattern ( 3 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE HelloWorld . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def solve ( cls , N , K ) : NEW_LINE INDENT combo = [ ] NEW_LINE combo = [ None ] * 50 NEW_LINE combo [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i <= K : NEW_LINE INDENT while j <= N : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return combo [ N ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 29 NEW_LINE K = 5 NEW_LINE print cls . solve ( N , K ) NEW_LINE cls . solve ( N , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = Math . abs ( x ) NEW_LINE while x > 0 : NEW_LINE INDENT if not sign and t != 0 : NEW_LINE INDENT t = 10 - t NEW_LINE x += 10 NEW_LINE DEDENT builder . insert ( 0 , t ) NEW_LINE sign = not sign NEW_LINE x /= 10 NEW_LINE DEDENT print builder NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def normal ( cls , m , n ) : NEW_LINE INDENT N = ( ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ) NEW_LINE return N NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT m = - 5 NEW_LINE n = 3 NEW_LINE print cls . normal ( m , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countBits ( cls , n ) : NEW_LINE INDENT count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT i = 65 NEW_LINE print cls . countBits ( i , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isHeterogram ( cls , s , n ) : NEW_LINE INDENT hash = [ None ] * 26 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s . charAt ( i ) != ' ▁ ' : NEW_LINE INDENT if hash [ s . charAt ( i ) - ' a ' ] == 0 : NEW_LINE INDENT hash [ s . charAt ( i ) - ' a ' ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " NEW_LINE n = len ( s ) NEW_LINE if cls . isHeterogram ( s , n ) : NEW_LINE INDENT print " YES " , NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class p024 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p024 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT array = [ None ] * 10 NEW_LINE i = 0 NEW_LINE while i < array . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < 999999 : NEW_LINE INDENT if not Library . nextPermutation ( array ) : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = " " NEW_LINE i = 0 NEW_LINE while i < array . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p024 . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def FindPoint ( cls , x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if x > x1 and x < x2 and y > y1 and y < y2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE x = 1 NEW_LINE y = 5 NEW_LINE if cls . FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . InputStreamReader NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT scan = Scanner ( BufferedReader ( InputStreamReader ( System . in_ ) ) ) NEW_LINE X = scan . nextLong ( ) NEW_LINE Y = scan . nextLong ( ) NEW_LINE Z = Y / X NEW_LINE answer = f ( Z ) + 1 NEW_LINE print answer NEW_LINE DEDENT def f ( self , Z ) : NEW_LINE INDENT t = 1 NEW_LINE result = 0 NEW_LINE while t < Z : NEW_LINE INDENT t *= 2 NEW_LINE result += 1 NEW_LINE DEDENT if t == Z : NEW_LINE INDENT return result NEW_LINE DEDENT return result - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import java . util . StringTokenizer NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE out = PrintWriter ( System . out ) NEW_LINE t = Integer . parseInt ( in_ . readLine ( ) ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT a [ i ] = Integer . parseInt ( st . nextToken ( ) ) NEW_LINE i += 1 NEW_LINE DEDENT while i < n - 1 : NEW_LINE INDENT if replaceNext : NEW_LINE INDENT a [ i ] = Math . max ( a [ i - 1 ] , a [ i + 1 ] ) NEW_LINE ans += 1 NEW_LINE replaceNext = False NEW_LINE DEDENT if a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] : NEW_LINE INDENT replaceNext = True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if replaceNext : NEW_LINE INDENT a [ n - 1 ] = a [ n - 2 ] NEW_LINE ans += 1 NEW_LINE replaceNext = False NEW_LINE DEDENT out . println ( ans ) NEW_LINE while i < n : NEW_LINE INDENT out . print_ ( a [ i ] + " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT out . println ( ) NEW_LINE DEDENT in_ . close ( ) NEW_LINE out . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def command ( cls , arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= True NEW_LINE arr [ b + 1 ] ^= True NEW_LINE DEDENT @ classmethod NEW_LINE def process ( cls , arr , n ) : NEW_LINE INDENT k = 1 NEW_LINE while k <= n : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def result ( cls , arr , n ) : NEW_LINE INDENT k = 1 NEW_LINE while k <= n : NEW_LINE INDENT if arr [ k ] == True : NEW_LINE INDENT print "1" + " ▁ " , NEW_LINE DEDENT else : NEW_LINE INDENT print "0" + " ▁ " , NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ None ] * n + 2 NEW_LINE cls . command ( arr , 1 , 5 ) NEW_LINE cls . command ( arr , 2 , 5 ) NEW_LINE cls . command ( arr , 3 , 5 ) NEW_LINE cls . process ( arr , n ) NEW_LINE cls . result ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT MAX = 26 NEW_LINE @ classmethod NEW_LINE def maxLength ( cls , str_ , len ) : NEW_LINE INDENT res = 0 NEW_LINE lastPos = [ None ] * MAX NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT lastPos [ i ] = - 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len : NEW_LINE INDENT if lastPos [ C ] != - 1 : NEW_LINE INDENT res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) NEW_LINE DEDENT lastPos [ C ] = i NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE len = len ( str_ ) NEW_LINE print cls . maxLength ( str_ , len ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE @ classmethod NEW_LINE def ksmallest ( cls , arr , n , k ) : NEW_LINE INDENT b = [ None ] * MAX NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE i += 1 NEW_LINE DEDENT j = 1 NEW_LINE while j < MAX : NEW_LINE INDENT if b [ j ] != 1 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if k != 1 : NEW_LINE INDENT return j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return Integer . MAX_VALUE NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT k = 1 NEW_LINE arr = [ 1 ] NEW_LINE n = arr . length NEW_LINE print cls . ksmallest ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isDivisible ( cls , n ) : NEW_LINE INDENT d = int ( ) NEW_LINE while ( n / 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n /= 10 NEW_LINE n = Math . abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 2795 NEW_LINE if cls . isDivisible ( N ) : NEW_LINE INDENT print " Yes " , NEW_LINE DEDENT else : NEW_LINE INDENT print " No " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def isPowerOfTwo ( cls , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) == ( ( Math . floor ( ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT if cls . isPowerOfTwo ( 31 ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT if cls . isPowerOfTwo ( 64 ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Problem1 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT s = Scanner ( System . in_ ) NEW_LINE t = s . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT print a + b NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Problem1 . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxDiff ( cls , arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE i = 1 NEW_LINE while i < n - 1 : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if curr_sum > 0 : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = arr . length NEW_LINE print " Maximum ▁ difference ▁ is ▁ " + cls . maxDiff ( arr , n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE line = str ( ) NEW_LINE MOD = 100000007 NEW_LINE @ classmethod NEW_LINE @ overloaded NEW_LINE def solve ( cls , len , loop ) : NEW_LINE INDENT ret = 0 NEW_LINE dp = [ None ] * len + 1 NEW_LINE dp [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i <= len : NEW_LINE INDENT while j <= Math . min ( loop , i ) : NEW_LINE INDENT dp [ i ] += dp [ i - j ] NEW_LINE j += 1 NEW_LINE DEDENT dp [ i ] %= MOD NEW_LINE if ( len - i ) % loop == 0 : NEW_LINE INDENT ret += dp [ i ] NEW_LINE ret %= MOD NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT @ classmethod NEW_LINE @ solve . register ( object ) NEW_LINE def solve_0 ( cls ) : NEW_LINE INDENT ans = 1 NEW_LINE prev = 0 NEW_LINE i = 1 NEW_LINE while i < len ( line ) : NEW_LINE INDENT if cls . line . charAt ( i ) != line . charAt ( i - 1 ) : NEW_LINE INDENT ans *= solve ( i - prev , loop ( line . charAt ( prev ) ) ) NEW_LINE ans %= MOD NEW_LINE prev = i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans *= len ( solve ( line ) - prev , loop ( line . charAt ( prev ) ) ) NEW_LINE ans %= MOD NEW_LINE return ( ans ) NEW_LINE DEDENT @ classmethod NEW_LINE def loop ( cls , c ) : NEW_LINE INDENT return 3 if c == '8' or c == '0' else 5 NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT while True : NEW_LINE INDENT cls . line = sc . next ( ) NEW_LINE if cls . line == " # " : NEW_LINE INDENT break NEW_LINE DEDENT print cls . solve ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countPairs ( cls , n ) : NEW_LINE INDENT num = ( ( n / 2 ) + 1 ) NEW_LINE max = n % num NEW_LINE count = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j <= n : NEW_LINE INDENT if val == max : NEW_LINE INDENT count += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE print cls . countPairs ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . io . IOException NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT scanner = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if ( n | m ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT pow3 [ 0 ] = 1 NEW_LINE while i <= n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < 3 : NEW_LINE INDENT while j > 0 : NEW_LINE INDENT c [ n - k ] = i NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT x += pow3 [ i ] * d NEW_LINE if d == 1 : NEW_LINE INDENT p = 2 - p NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if x > y : NEW_LINE INDENT x = y NEW_LINE DEDENT print - 1 if x > m else x NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT





import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE x1 = scan . nextInt ( ) NEW_LINE y1 = scan . nextInt ( ) NEW_LINE x2 = scan . nextInt ( ) NEW_LINE y2 = scan . nextInt ( ) NEW_LINE x3 = x2 + ( y1 - y2 ) NEW_LINE y3 = y2 - ( x1 - x2 ) NEW_LINE x4 = x1 - ( y2 - y1 ) NEW_LINE y4 = y1 + ( x2 - x1 ) NEW_LINE print x3 + " ▁ " + y3 + " ▁ " + x4 + " ▁ " + y4 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def max ( cls , x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT @ classmethod NEW_LINE def lps ( cls , seq , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 1 NEW_LINE DEDENT if seq [ i ] == seq [ j ] and i + 1 == j : NEW_LINE INDENT return 2 NEW_LINE DEDENT if seq [ i ] == seq [ j ] : NEW_LINE INDENT return cls . lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return cls . max ( cls . lps ( seq , i , j - 1 ) , cls . lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE System . out . printf ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , cls . lps ( seq . toCharArray ( ) , 0 , n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findLength ( cls , str_ , n ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i <= n - 2 : NEW_LINE INDENT while r < n and l >= 0 : NEW_LINE INDENT lsum += str_ . charAt ( l ) - '0' NEW_LINE rsum += str_ . charAt ( r ) - '0' NEW_LINE if lsum == rsum : NEW_LINE INDENT ans = Math . max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = "123123" NEW_LINE print " Length ▁ of ▁ the ▁ substring ▁ is ▁ " + cls . findLength ( str_ , len ( str_ ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class ER42B ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE a = in_ . nextInt ( ) NEW_LINE b = in_ . nextInt ( ) NEW_LINE s = in_ . next ( ) NEW_LINE ans = a + b NEW_LINE flip = 1 if a > b else - 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if s . charAt ( i ) == ' * ' : NEW_LINE INDENT flip = 1 if a > b else - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if flip == 1 : NEW_LINE INDENT a = ( 0 if a == 0 else a - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( 0 if b == 0 else b - 1 ) NEW_LINE DEDENT flip *= - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ans - a - b NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE ER42B . main ( sys . argv ) NEW_LINE DEDENT
import java . util . ArrayList NEW_LINE import java . util . List NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE id = sc . nextInt ( ) NEW_LINE id += 1 NEW_LINE root = Node ( id , 0 , sc . next ( ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE id += 1 NEW_LINE INDENT parent . children . add ( Node ( id , parent . depth + 1 , sc . next ( ) ) ) NEW_LINE i += 1 NEW_LINE DEDENT root . printContents ( ) NEW_LINE sc . close ( ) NEW_LINE DEDENT DEDENT class Node ( object ) : NEW_LINE INDENT id = int ( ) NEW_LINE depth = int ( ) NEW_LINE contents = str ( ) NEW_LINE children = List ( ) NEW_LINE def __init__ ( self , i , d , c ) : NEW_LINE INDENT self . id = i NEW_LINE self . depth = d NEW_LINE self . contents = c NEW_LINE self . children = ArrayList ( ) NEW_LINE DEDENT def findNode ( self , id ) : NEW_LINE INDENT if id == self . id : NEW_LINE INDENT return self NEW_LINE DEDENT for child in children : NEW_LINE INDENT if target != None : NEW_LINE INDENT return target NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def printContents ( self ) : NEW_LINE INDENT i = 0 NEW_LINE while i < depth : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print self . contents NEW_LINE for child in children : NEW_LINE INDENT child . printContents ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE T = sc . nextInt ( ) NEW_LINE __T_0 = T NEW_LINE T -= 1 NEW_LINE while __T_0 > 0 : NEW_LINE INDENT while i <= n : NEW_LINE INDENT while j <= i : NEW_LINE INDENT if j == 1 or i == j : NEW_LINE INDENT print 1 + " ▁ " , NEW_LINE DEDENT else : NEW_LINE INDENT print 0 + " ▁ " , NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def bin ( cls , n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT cls . bin ( n >> 1 ) NEW_LINE DEDENT System . out . printf ( " % d " , n & 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . bin ( 131 ) NEW_LINE System . out . printf ( " \n " ) NEW_LINE cls . bin ( 3 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class p001 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p001 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < 1000 : NEW_LINE INDENT if i % 3 == 0 or i % 5 == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Integer . toString ( sum ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p001 . main ( sys . argv ) NEW_LINE DEDENT











class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countPairs ( cls , arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while right < n : NEW_LINE INDENT while right < n and not visited [ arr [ right ] ] : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while left < right and ( right != n and visited [ arr [ right ] ] ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = arr . length NEW_LINE print cls . countPairs ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT M = 1001 NEW_LINE MOD = 998244353 NEW_LINE dp = [ None ] * M NEW_LINE @ classmethod NEW_LINE def solve ( cls , idx , diff , N , M , K ) : NEW_LINE INDENT if idx > N : NEW_LINE INDENT if diff == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if cls . dp [ idx ] [ diff ] != - 1 : NEW_LINE INDENT return cls . dp [ idx ] [ diff ] NEW_LINE DEDENT ans = cls . solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE return cls . dp [ idx ] [ diff ] = ans % MOD NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 0 NEW_LINE i = 0 NEW_LINE while i <= M : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( M * cls . solve ( 2 , 0 , N , M , K ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class p222 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p222 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sphereRadii = [ None ] * 21 NEW_LINE i = 0 NEW_LINE while i < sphereRadii . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT minLength = [ None ] * sphereRadii . length NEW_LINE min = Double . POSITIVE_INFINITY NEW_LINE i = 0 NEW_LINE while i < sphereRadii . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return Long . toString ( Math . round ( min ) ) NEW_LINE DEDENT sphereRadii = [ ] NEW_LINE minLength = [ ] NEW_LINE def findMinimumLength ( self , currentSphereIndex , setOfSpheres ) : NEW_LINE INDENT if ( setOfSpheres & ( 1 << currentSphereIndex ) ) == 0 : NEW_LINE INDENT raise IllegalArgumentException ( ) NEW_LINE DEDENT if self . minLength [ currentSphereIndex ] [ setOfSpheres ] == 0 : NEW_LINE INDENT if Integer . bitCount ( setOfSpheres ) == 1 : NEW_LINE INDENT result = sphereRadii [ currentSphereIndex ] NEW_LINE DEDENT else : NEW_LINE INDENT result = Double . POSITIVE_INFINITY NEW_LINE while i < sphereRadii . length : NEW_LINE INDENT if ( newSetOfSpheres & ( 1 << i ) ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT temp += findMinimumLength ( i , newSetOfSpheres ) NEW_LINE result = Math . min ( temp , result ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT self . minLength [ currentSphereIndex ] [ setOfSpheres ] = result NEW_LINE DEDENT return self . minLength [ currentSphereIndex ] [ setOfSpheres ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p222 . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT input = Scanner ( System . in_ ) NEW_LINE l = float ( ) NEW_LINE p = float ( ) NEW_LINE q = float ( ) NEW_LINE l = input . nextDouble ( ) NEW_LINE p = input . nextDouble ( ) NEW_LINE q = input . nextDouble ( ) NEW_LINE print ( p * l ) / ( p + q ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE a = sc . nextInt ( ) NEW_LINE c = sc . next ( ) . toCharArray ( ) NEW_LINE w = [ None ] * a + 1 NEW_LINE e = [ None ] * a + 1 NEW_LINE min = a NEW_LINE i = 1 NEW_LINE while i <= a : NEW_LINE INDENT if c [ i - 1 ] == ' W ' : NEW_LINE INDENT w [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT e [ i ] += 1 NEW_LINE DEDENT w [ i ] += w [ i - 1 ] NEW_LINE e [ i ] += e [ i - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= a : NEW_LINE INDENT min = Math . min ( min , w [ i - 1 ] + e [ a ] - e [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT print min NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class CF1213A ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE n = scan . nextInt ( ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if num1 % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if even > odd : NEW_LINE INDENT print odd NEW_LINE DEDENT else : NEW_LINE INDENT print even NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE CF1213A . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minimumCostOfBreaking ( cls , X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE Arrays . sort ( X , Collections . reverseOrder ( ) ) NEW_LINE Arrays . sort ( Y , Collections . reverseOrder ( ) ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if X [ i ] > Y [ j ] : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while i < m : NEW_LINE res += total * vert NEW_LINE total = 0 NEW_LINE while j < n : NEW_LINE res += total * hzntl NEW_LINE return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT m = 6 NEW_LINE n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print cls . minimumCostOfBreaking ( X , Y , m - 1 , n - 1 , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GCD ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def gcd ( cls , a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return cls . gcd ( b % a , a ) NEW_LINE DEDENT @ classmethod NEW_LINE def countPairs ( cls , G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE a = 1 NEW_LINE while a <= L : NEW_LINE INDENT a += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + G , NEW_LINE print " ▁ & ▁ LCM ▁ " + L , NEW_LINE print " ▁ = ▁ " + cls . countPairs ( G , L , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GCD . main ( sys . argv ) NEW_LINE DEDENT


class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT brokenPoint = 0 NEW_LINE i = 0 NEW_LINE while i < nums . length - 1 : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT brokenPoint += 1 NEW_LINE if brokenPoint >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossibility ( nums ) NEW_LINE print out NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def check ( cls , mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if array [ i ] > mid : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if sum > mid : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT count += 1 NEW_LINE if count <= K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls , array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT end += array [ i ] NEW_LINE i += 1 NEW_LINE DEDENT answer = 0 NEW_LINE while start <= end : NEW_LINE INDENT if cls . check ( mid , array , n , K ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = array . length NEW_LINE K = 3 NEW_LINE print cls . solve ( array , n , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE M = int ( ) NEW_LINE memo = [ None ] * 1 << 22 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT while True : NEW_LINE INDENT cls . M = sc . nextInt ( ) NEW_LINE if cls . M == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while i < N : NEW_LINE INDENT list_ . add ( Integer . parseInt ( cls . sc . next ( ) , 2 ) ) NEW_LINE i += 1 NEW_LINE DEDENT Arrays . fill ( cls . memo , - 1 ) NEW_LINE print rec ( 0 , list_ ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def rec ( cls , used , list_ ) : NEW_LINE INDENT if len ( list_ ) <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if cls . memo [ used ] >= 0 : NEW_LINE INDENT return cls . memo [ used ] NEW_LINE DEDENT ret = 99 NEW_LINE i = 0 NEW_LINE while i < M : NEW_LINE INDENT if ( used & ( 3 << ( 2 * i ) ) ) != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for v in list_ : NEW_LINE INDENT if ( v & ( 1 << i ) ) != 0 : NEW_LINE INDENT on . add ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT off . add ( v ) NEW_LINE DEDENT DEDENT if on . isEmpty ( ) or off . isEmpty ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT ret = Math . min ( ret , Math . max ( rec ( used | ( 1 << ( 2 * i ) ) , on ) , rec ( used | ( 2 << ( 2 * i ) ) , off ) ) ) NEW_LINE i += 1 NEW_LINE DEDENT cls . memo [ used ] = ret + 1 NEW_LINE return ret + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE tc = 0 NEW_LINE while tc < t : NEW_LINE INDENT print solve ( a , b ) NEW_LINE tc += 1 NEW_LINE DEDENT sc . close ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def solve ( cls , a , b ) : NEW_LINE INDENT return Math . min ( Math . min ( computeSquareArea ( a + a , b ) , computeSquareArea ( a + b , Math . max ( a , b ) ) ) , computeSquareArea ( a , b + b ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def computeSquareArea ( cls , side1 , side2 ) : NEW_LINE INDENT size = Math . max ( side1 , side2 ) NEW_LINE return size * size NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def even_or_odd ( cls , N ) : NEW_LINE INDENT len = len ( N ) NEW_LINE if N . charAt ( len - 1 ) == '0' or N . charAt ( len - 1 ) == '2' or N . charAt ( len - 1 ) == '4' or N . charAt ( len - 1 ) == '6' : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = "735" NEW_LINE print cls . even_or_odd ( N , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Vector ( object ) : NEW_LINE INDENT A = [ ] NEW_LINE length = 0 NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . A = [ None ] * 20 NEW_LINE DEDENT def add ( self , x ) : NEW_LINE INDENT if self . length == A . length : NEW_LINE INDENT self . A = Arrays . copyOf ( A , length * 2 ) NEW_LINE DEDENT self . A [ self . length ] = x NEW_LINE self . length += 1 NEW_LINE DEDENT def deleteBack ( self ) : NEW_LINE INDENT self . length -= 1 NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT sb = StringBuilder ( ) NEW_LINE if self . length > 0 : NEW_LINE INDENT sb . append ( self . A [ 0 ] ) NEW_LINE DEDENT i = 1 NEW_LINE while i < length : NEW_LINE INDENT sb . append ( " ▁ " ) NEW_LINE sb . append ( self . A [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return sb . __str__ ( ) NEW_LINE DEDENT DEDENT class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE q = sc . nextInt ( ) NEW_LINE v = [ None ] * n NEW_LINE active = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < q : NEW_LINE INDENT if req == 0 : NEW_LINE INDENT if not active [ t ] : NEW_LINE INDENT v [ t ] = Vector ( ) NEW_LINE active [ t ] = True NEW_LINE DEDENT v [ t ] . add ( sc . nextInt ( ) ) NEW_LINE DEDENT elif req == 1 : NEW_LINE INDENT if active [ t ] : NEW_LINE INDENT print v [ t ] NEW_LINE DEDENT else : NEW_LINE INDENT print NEW_LINE DEDENT DEDENT elif req == 2 : NEW_LINE INDENT active [ t ] = False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def solve ( cls , X , Y , N , K ) : NEW_LINE INDENT count = [ None ] * N + 1 NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i <= N : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + Math . abs ( X . charAt ( i - 1 ) - Y . charAt ( i - 1 ) ) NEW_LINE i += 1 NEW_LINE DEDENT j = 0 NEW_LINE i = 1 NEW_LINE while i <= N : NEW_LINE INDENT while ( count [ i ] - count [ j ] ) > K : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = Math . max ( sol , i - j ) NEW_LINE i += 1 NEW_LINE DEDENT return sol NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT N = 4 NEW_LINE X = " abcd " NEW_LINE Y = " bcde " NEW_LINE K = 3 NEW_LINE print cls . solve ( X , Y , N , K , + " \n " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def snoob ( cls , x ) : NEW_LINE INDENT rightOne = int ( ) NEW_LINE nextHigherOneBit = int ( ) NEW_LINE rightOnesPattern = int ( ) NEW_LINE next = 0 NEW_LINE if x > 0 : NEW_LINE INDENT rightOne = x & - x NEW_LINE nextHigherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE rightOnesPattern = ( rightOnesPattern ) / rightOne NEW_LINE rightOnesPattern >>= 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT x = 156 NEW_LINE print " Next ▁ higher ▁ number ▁ with ▁ same " + " number ▁ of ▁ set ▁ bits ▁ is ▁ " + cls . snoob ( x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def properDivisorSum ( cls , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT sum = sum - i NEW_LINE i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE print cls . properDivisorSum ( n ) NEW_LINE n = 5 NEW_LINE print cls . properDivisorSum ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . io . BufferedReader NEW_LINE import java . io . InputStreamReader NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT br = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE n = Integer . parseInt ( br . readLine ( ) ) NEW_LINE sa = br . readLine ( ) . split ( " ▁ " ) NEW_LINE a = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT a [ i ] = Integer . parseInt ( sa [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT br . close ( ) NEW_LINE mod = 1000000007 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT p = p * i % mod NEW_LINE i += 1 NEW_LINE DEDENT q = [ None ] * n NEW_LINE q [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT q [ i ] = ( q [ i - 1 ] + modinv ( i + 1 , mod ) ) % mod NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT val *= a [ i ] NEW_LINE val %= mod NEW_LINE val *= p NEW_LINE val %= mod NEW_LINE ans += val NEW_LINE ans %= mod NEW_LINE i += 1 NEW_LINE DEDENT print ans NEW_LINE DEDENT @ classmethod NEW_LINE def modinv ( cls , a , m ) : NEW_LINE INDENT b = m NEW_LINE u = 1 NEW_LINE v = 0 NEW_LINE tmp = 0 NEW_LINE while b > 0 : NEW_LINE INDENT a -= t * b NEW_LINE tmp = a NEW_LINE a = b NEW_LINE b = tmp NEW_LINE u -= t * v NEW_LINE tmp = u NEW_LINE u = v NEW_LINE v = tmp NEW_LINE DEDENT u %= m NEW_LINE if u < 0 : NEW_LINE INDENT u += m NEW_LINE DEDENT return u NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
import java . util . LinkedList NEW_LINE import java . util . Queue NEW_LINE import java . util . Stack NEW_LINE class Queue_reverse ( object ) : NEW_LINE INDENT queue = Queue ( ) NEW_LINE @ classmethod NEW_LINE def Print ( cls ) : NEW_LINE INDENT while not cls . queue . isEmpty ( ) : NEW_LINE INDENT print cls . queue . peek ( , + " ▁ " ) NEW_LINE cls . queue . remove ( ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def reverseQueue ( cls , q ) : NEW_LINE INDENT if q . isEmpty ( ) : NEW_LINE INDENT return q NEW_LINE DEDENT data = q . peek ( ) NEW_LINE q . remove ( ) NEW_LINE q = reverseQueue ( q ) NEW_LINE q . add ( data ) NEW_LINE return q NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT cls . queue = LinkedList ( ) NEW_LINE cls . queue . add ( 56 ) NEW_LINE cls . queue . add ( 27 ) NEW_LINE cls . queue . add ( 30 ) NEW_LINE cls . queue . add ( 45 ) NEW_LINE cls . queue . add ( 85 ) NEW_LINE cls . queue . add ( 92 ) NEW_LINE cls . queue . add ( 58 ) NEW_LINE cls . queue . add ( 80 ) NEW_LINE cls . queue . add ( 90 ) NEW_LINE cls . queue . add ( 100 ) NEW_LINE cls . queue = reverseQueue ( queue ) NEW_LINE cls . Print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Queue_reverse . main ( sys . argv ) NEW_LINE DEDENT


import java . io . BufferedReader NEW_LINE import java . io . IOException NEW_LINE import java . io . InputStreamReader NEW_LINE import java . io . PrintWriter NEW_LINE import NEW_LINE class A_Summer_Camp ( object ) : NEW_LINE INDENT in_ = BufferedReader ( InputStreamReader ( System . in_ ) ) NEW_LINE out = PrintWriter ( System . out ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = Integer . parseInt ( cls . in_ . readLine ( ) ) NEW_LINE s = " " NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT s += i NEW_LINE i += 1 NEW_LINE DEDENT cls . out . print_ ( s . charAt ( n - 1 ) ) NEW_LINE cls . out . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE A_Summer_Camp . main ( sys . argv ) NEW_LINE DEDENT







class Solution ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minimumX ( cls , n , k ) : NEW_LINE INDENT ans = Integer . MAX_VALUE NEW_LINE rem = k - 1 NEW_LINE while rem > 0 : NEW_LINE INDENT if n % rem == 0 : NEW_LINE INDENT ans = Math . min ( ans , rem + ( n / rem ) * k ) NEW_LINE DEDENT rem -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE k = 6 NEW_LINE print cls . minimumX ( n , k ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print cls . minimumX ( n , k ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def moduloMultiplication ( cls , a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b > 0 : NEW_LINE INDENT if ( b & 1 ) > 0 : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = 10123465234878998 L NEW_LINE b = 65746311545646431 L NEW_LINE m = 10005412336548794 L NEW_LINE print cls . moduloMultiplication ( a , b , m , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT MAX = ' Z ' - ' A ' + 1 NEW_LINE n = int ( ) NEW_LINE inDeg = [ ] NEW_LINE outDeg = [ ] NEW_LINE vis = [ ] NEW_LINE nei = [ ] NEW_LINE def check ( self ) : NEW_LINE INDENT i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT if self . vis [ i ] != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT if self . inDeg [ i ] != outDeg [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def dfs ( self , k ) : NEW_LINE INDENT if self . vis [ k ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT self . vis [ k ] = 1 NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT if 0 < nei [ k ] [ i ] : NEW_LINE INDENT self . dfs ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def run ( self ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT self . n = sc . nextInt ( ) NEW_LINE if self . n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT self . inDeg = [ None ] * MAX NEW_LINE self . outDeg = [ None ] * MAX NEW_LINE self . vis = [ None ] * MAX NEW_LINE self . nei = [ None ] * MAX NEW_LINE Arrays . fill ( self . vis , 1 ) NEW_LINE while i < n : NEW_LINE INDENT self . outDeg [ u ] += 1 NEW_LINE self . inDeg [ v ] += 1 NEW_LINE self . nei [ u ] [ v ] = 1 NEW_LINE self . vis [ u ] = vis [ v ] = - 1 NEW_LINE s = u NEW_LINE i += 1 NEW_LINE DEDENT self . dfs ( s ) NEW_LINE if self . check ( ) : NEW_LINE INDENT print " OK " NEW_LINE DEDENT else : NEW_LINE INDENT print " NG " NEW_LINE DEDENT DEDENT DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT





class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def count_pairs ( cls , a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < m : NEW_LINE INDENT if b [ i ] % 2 == 1 : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = a . length NEW_LINE m = b . length NEW_LINE print cls . count_pairs ( a , b , n , m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class MaximumDiffrence ( object ) : NEW_LINE INDENT def maxDiff ( self , arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE i = int ( ) NEW_LINE while i < arr_size : NEW_LINE INDENT if arr [ i ] - min_element > max_diff : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if arr [ i ] < min_element : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max_diff NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT maxdif = MaximumDiffrence ( ) NEW_LINE arr = [ 1 , 2 , 6 , 80 , 100 ] NEW_LINE size = arr . length NEW_LINE print " Maximum ▁ difference ▁ is ▁ " + maxdif . maxDiff ( arr , size ) NEW_LINE DEDENT DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def binomialCoeff ( cls , n , k ) : NEW_LINE INDENT C = [ None ] * n + 1 NEW_LINE i = int ( ) NEW_LINE j = int ( ) NEW_LINE while i <= n : NEW_LINE INDENT while j <= Math . min ( i , k ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return C [ n ] [ k ] NEW_LINE DEDENT @ classmethod NEW_LINE def findMax ( cls , n ) : NEW_LINE INDENT return cls . binomialCoeff ( n , n / 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 5 NEW_LINE print cls . findMax ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT MAX = 26 NEW_LINE @ classmethod NEW_LINE def max_element ( cls , freq ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT if max_ele < freq [ i ] : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max_ele NEW_LINE DEDENT @ classmethod NEW_LINE def minimumAddition ( cls , str_ , len ) : NEW_LINE INDENT freq = [ None ] * MAX NEW_LINE i = 0 NEW_LINE while i < len : NEW_LINE INDENT freq [ str_ . charAt ( i ) - ' a ' ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT maxFreq = cls . max_element ( freq ) NEW_LINE minAddition = 0 NEW_LINE i = 0 NEW_LINE while i < MAX : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT minAddition += Math . abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return minAddition NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " geeksforgeeks " NEW_LINE len = len ( str_ ) NEW_LINE print cls . minimumAddition ( str_ , len ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class test195 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE a = in_ . next ( ) . toCharArray ( ) NEW_LINE b = in_ . next ( ) . toCharArray ( ) NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if Math . abs ( a [ i ] - b [ i ] ) > 5 : NEW_LINE INDENT sum += 10 - Math . abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += Math . abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print sum NEW_LINE in_ . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE test195 . main ( sys . argv ) NEW_LINE DEDENT

class p027 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p027 ( ) . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT bestNum = 0 NEW_LINE bestA = 0 NEW_LINE bestB = 0 NEW_LINE a = - 1000 NEW_LINE while a <= 1000 : NEW_LINE INDENT while b <= 1000 : NEW_LINE INDENT if num > bestNum : NEW_LINE INDENT bestNum = num NEW_LINE bestA = a NEW_LINE bestB = b NEW_LINE DEDENT b += 1 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT return Integer . toString ( bestA * bestB ) NEW_LINE DEDENT @ classmethod NEW_LINE def numberOfConsecutivePrimesGenerated ( cls , a , b ) : NEW_LINE INDENT i = 0 NEW_LINE while True : NEW_LINE INDENT if n < 0 or not Library . isPrime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p027 . main ( sys . argv ) NEW_LINE DEDENT


import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT scan = Scanner ( System . in_ ) NEW_LINE n = int ( ) NEW_LINE r = int ( ) NEW_LINE t = int ( ) NEW_LINE sum = int ( ) NEW_LINE pos = int ( ) NEW_LINE n = scan . nextInt ( ) NEW_LINE r = scan . nextInt ( ) NEW_LINE t = scan . nextInt ( ) NEW_LINE sum = 0 NEW_LINE p = [ None ] * n NEW_LINE water = [ None ] * r NEW_LINE empty = [ None ] * r NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT p [ i ] = scan . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i <= t : NEW_LINE INDENT while j < n : NEW_LINE INDENT pos = ( p [ j ] * i % r ) NEW_LINE if i > 1 : NEW_LINE INDENT empty [ pos ] += 1 NEW_LINE DEDENT if water [ pos ] > 0 : NEW_LINE INDENT water [ pos ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT while j < r : NEW_LINE INDENT if empty [ j ] > 0 : NEW_LINE INDENT water [ j ] += empty [ j ] NEW_LINE empty [ j ] = 0 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print sum NEW_LINE scan . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT



import java . util . Arrays NEW_LINE class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def modularSum ( cls , arr , n , m ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ None ] * m NEW_LINE Arrays . fill ( DP , False ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if DP [ 0 ] : NEW_LINE INDENT return True NEW_LINE DEDENT Arrays . fill ( temp , False ) NEW_LINE while j < m : NEW_LINE INDENT if DP [ j ] == True : NEW_LINE INDENT if DP [ ( j + arr [ i ] ) % m ] == False : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT while j < m : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DP [ arr [ i ] % m ] = True NEW_LINE i += 1 NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , arg ) : NEW_LINE INDENT arr = [ 1 , 7 ] NEW_LINE n = arr . length NEW_LINE m = 5 NEW_LINE if cls . modularSum ( arr , n , m ) : NEW_LINE INDENT print " YES \n " , NEW_LINE DEDENT else : NEW_LINE INDENT print " NO \n " , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sum ( cls , k , n ) : NEW_LINE INDENT sum = ( ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ) NEW_LINE return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print cls . sum ( K , n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT dp = [ None ] * 18 NEW_LINE @ classmethod NEW_LINE def solve ( cls , i , tight , sum_so_far , Sum , number , len ) : NEW_LINE INDENT if i == len : NEW_LINE INDENT if sum_so_far == Sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = cls . dp [ i ] [ 1 ] [ sum_so_far ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE ntight = bool ( ) NEW_LINE nsum_so_far = int ( ) NEW_LINE currdigit = '0' NEW_LINE while currdigit <= '9' : NEW_LINE INDENT if not tight and currdigit > number . charAt ( i ) : NEW_LINE INDENT break NEW_LINE DEDENT ntight = tight or currdigit < number . charAt ( i ) NEW_LINE nsum_so_far = sum_so_far + ( currdigit - '0' ) NEW_LINE ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , len ) NEW_LINE currdigit += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 4 NEW_LINE number = "100" NEW_LINE i = 0 NEW_LINE while i < 18 : NEW_LINE INDENT while j < 2 : NEW_LINE INDENT while k < 162 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print cls . solve ( 0 , False , 0 , sum , number , len ( number ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class FriendsDecision ( object ) : NEW_LINE INDENT count = 0 NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE n = sc . nextInt ( ) NEW_LINE sc . nextLine ( ) NEW_LINE arr = [ None ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT arr [ i ] = sc . nextLine ( ) NEW_LINE decision ( arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT print cls . count NEW_LINE DEDENT @ classmethod NEW_LINE def decision ( cls , entery ) : NEW_LINE INDENT localct = 0 NEW_LINE inputs = entery . split ( " ▁ " ) NEW_LINE i = 0 NEW_LINE while i < inputs . length : NEW_LINE INDENT if inputs [ i ] == "1" : NEW_LINE INDENT localct += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if localct > 1 : NEW_LINE INDENT cls . count += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE FriendsDecision . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minCost ( cls , arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return Math . min ( count_even , count_odd ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = arr . length NEW_LINE print cls . minCost ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT while i < n : NEW_LINE INDENT k [ i ] = sc . nextInt ( ) NEW_LINE if k [ i ] > 0 : NEW_LINE INDENT up1 += 1 NEW_LINE if k [ i ] >= 2 : NEW_LINE INDENT up2 += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if up2 == 0 : NEW_LINE INDENT print " NA " NEW_LINE DEDENT else : NEW_LINE INDENT print up1 + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def sumOfAP ( cls , a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print cls . sumOfAP ( a , d , n , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT



import java . math . BigInteger NEW_LINE class p164 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p164 ( ) . run ( ) NEW_LINE DEDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE def run ( self ) : NEW_LINE INDENT ways = [ None ] * DIGITS + CONSECUTIVE + 1 NEW_LINE ways [ 0 ] [ 0 ] = BigInteger . ONE NEW_LINE prefix = 1 NEW_LINE while prefix < ways [ 0 ] . length : NEW_LINE INDENT prefix += 1 NEW_LINE DEDENT digits = 1 NEW_LINE while digits < ways . length : NEW_LINE INDENT while prefix < ways [ digits ] . length : NEW_LINE INDENT if digitSum ( prefix ) <= MAX_SUM : NEW_LINE INDENT while nextDigit < BASE : NEW_LINE INDENT nextDigit += 1 NEW_LINE DEDENT DEDENT ways [ digits ] [ prefix ] = sum NEW_LINE prefix += 1 NEW_LINE DEDENT digits += 1 NEW_LINE DEDENT return ways [ self . DIGITS + self . CONSECUTIVE ] [ 0 ] . subtract ( ways [ self . DIGITS + self . CONSECUTIVE - 1 ] [ 0 ] ) . __str__ ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def digitSum ( cls , n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT n /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p164 . main ( sys . argv ) NEW_LINE DEDENT
import java . lang . reflect . Array NEW_LINE import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . IllegalFormatCodePointException NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT md = ArrayList ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE l = [ None ] * 4 NEW_LINE l [ 0 ] = in_ . next ( ) NEW_LINE l [ 1 ] = in_ . next ( ) NEW_LINE l [ 2 ] = in_ . next ( ) NEW_LINE l [ 3 ] = in_ . next ( ) NEW_LINE a = char ( ) NEW_LINE f = False NEW_LINE i = 0 NEW_LINE while i < 3 : NEW_LINE INDENT while j < 3 : NEW_LINE INDENT a = l [ i ] . charAt ( j ) NEW_LINE if l [ i ] . charAt ( j + 1 ) == a : NEW_LINE INDENT if l [ i + 1 ] . charAt ( j ) == a or l [ i + 1 ] . charAt ( j + 1 ) == a : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT elif i > 0 and ( l [ i - 1 ] . charAt ( j ) == a or l [ i - 1 ] . charAt ( j + 1 ) == a ) : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT f = False NEW_LINE DEDENT DEDENT if l [ 3 ] . charAt ( j ) == l [ 3 ] . charAt ( j + 1 ) and ( l [ 2 ] . charAt ( j ) == l [ 3 ] . charAt ( j ) or l [ 2 ] . charAt ( j + 1 ) == l [ 3 ] . charAt ( j + 1 ) ) : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if f == True : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if f == True : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT r = 1 NEW_LINE while r < matrix . length : NEW_LINE INDENT r += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ ] NEW_LINE out = sObj . isToeplitzMatrix ( matrix ) NEW_LINE print out NEW_LINE DEDENT DEDENT
class p094 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print p094 ( ) . run ( ) NEW_LINE DEDENT LIMIT = Library . pow ( 10 , 9 ) NEW_LINE def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE s = 1 NEW_LINE while s * s <= ( LIMIT + 1 ) / 3 : NEW_LINE INDENT while t > 0 : NEW_LINE INDENT if Library . gcd ( s , t ) == 1 : NEW_LINE INDENT if a * 2 == c - 1 : NEW_LINE INDENT if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if b * 2 == c - 1 : NEW_LINE INDENT if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if b * 2 == c + 1 : NEW_LINE INDENT if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT DEDENT t -= 2 NEW_LINE DEDENT s += 2 NEW_LINE DEDENT return Long . toString ( sum ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE p094 . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class oddsum ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE __t_0 = t NEW_LINE t -= 1 NEW_LINE while __t_0 > 0 : NEW_LINE INDENT while i < a : NEW_LINE INDENT x = in_ . nextInt ( ) NEW_LINE s += x NEW_LINE if x % 2 != 0 : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT e += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if s % 2 != 0 : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT if o >= 1 and e >= 1 : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE oddsum . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minInsertions ( cls , H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if diff <= K : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += Math . ceil ( diff / K ) - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return inser NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT H = [ None ] * NEW_LINE K = 3 NEW_LINE n = H . length NEW_LINE print cls . minInsertions ( H , n , K ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def countWords ( cls , str_ , len ) : NEW_LINE INDENT count = 1 NEW_LINE if len == 1 : NEW_LINE INDENT return count NEW_LINE DEDENT if str_ . charAt ( 0 ) == str_ . charAt ( 1 ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT j = 1 NEW_LINE while j < len - 1 : NEW_LINE INDENT if str_ . charAt ( j ) == str_ . charAt ( j - 1 ) and str_ . charAt ( j ) == str_ . charAt ( j + 1 ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif str_ . charAt ( j ) == str_ . charAt ( j - 1 ) or str_ . charAt ( j ) == str_ . charAt ( j + 1 ) or str_ . charAt ( j - 1 ) == str_ . charAt ( j + 1 ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if str_ . charAt ( len - 1 ) == str_ . charAt ( len - 2 ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = " abc " NEW_LINE len = len ( str_ ) NEW_LINE print cls . countWords ( str_ , len ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findHypotenuse ( cls , side1 , side2 ) : NEW_LINE INDENT h = Math . sqrt ( ( side1 * side1 ) + ( side2 * side2 ) ) NEW_LINE return h NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , s ) : NEW_LINE INDENT side1 = 3 NEW_LINE side2 = 4 NEW_LINE System . out . printf ( " % .2f " , cls . findHypotenuse ( side1 , side2 ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class StroneGame ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE t = sc . nextInt ( ) NEW_LINE while t > 0 : NEW_LINE INDENT while i < n : NEW_LINE INDENT ar [ i ] = sc . nextInt ( ) NEW_LINE if ar [ i ] < min : NEW_LINE INDENT min = ar [ i ] NEW_LINE x = i + 1 NEW_LINE DEDENT if ar [ i ] > max : NEW_LINE INDENT max = ar [ i ] NEW_LINE y = i + 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT pos1 = x NEW_LINE pos2 += n - x NEW_LINE if pos1 < pos2 : NEW_LINE INDENT a = pos1 NEW_LINE DEDENT else : NEW_LINE INDENT a = pos2 NEW_LINE DEDENT pos3 = y NEW_LINE pos4 += n - y NEW_LINE if pos3 < pos4 : NEW_LINE INDENT b = pos3 NEW_LINE DEDENT else : NEW_LINE INDENT b = pos4 NEW_LINE DEDENT if div < a or div < b : NEW_LINE INDENT mm = Math . min ( a , b ) NEW_LINE total += mm + div NEW_LINE DEDENT else : NEW_LINE INDENT total += a + b NEW_LINE DEDENT print total NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE StroneGame . main ( sys . argv ) NEW_LINE DEDENT


class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = int ( ) NEW_LINE next = Node ( ) NEW_LINE def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def printList ( cls , head ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE while True : NEW_LINE INDENT print temp . data + " - > " , NEW_LINE temp = temp . next NEW_LINE if not ( ( temp != head ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print head . data NEW_LINE DEDENT @ classmethod NEW_LINE def deleteK ( cls , head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if head == None : NEW_LINE INDENT return None NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while True : NEW_LINE INDENT if curr . next == head and curr == head : NEW_LINE INDENT break NEW_LINE DEDENT cls . printList ( head ) NEW_LINE while i < k : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE i += 1 NEW_LINE DEDENT if curr == head : NEW_LINE INDENT prev = head NEW_LINE while prev . next != head : NEW_LINE head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif curr . next == head : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT @ classmethod NEW_LINE def insertNode ( cls , head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = cls . Node ( x ) NEW_LINE if head == None : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT while temp1 . next != head : NEW_LINE temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT head = None NEW_LINE head = insertNode ( head , 1 ) NEW_LINE head = insertNode ( head , 2 ) NEW_LINE head = insertNode ( head , 3 ) NEW_LINE head = insertNode ( head , 4 ) NEW_LINE head = insertNode ( head , 5 ) NEW_LINE head = insertNode ( head , 6 ) NEW_LINE head = insertNode ( head , 7 ) NEW_LINE head = insertNode ( head , 8 ) NEW_LINE head = insertNode ( head , 9 ) NEW_LINE k = 4 NEW_LINE head = deleteK ( head , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def steps ( cls , cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return Integer . MAX_VALUE NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT return Math . abs ( ( n - cur ) / x ) NEW_LINE DEDENT else : NEW_LINE INDENT return Math . abs ( ( cur - 1 ) / x ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def countSteps ( cls , curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = moves . length NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE moves = [ ] NEW_LINE print cls . countSteps ( x , y , n , m , moves , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . ArrayList NEW_LINE import java . util . Arrays NEW_LINE import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT md = ArrayList ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE x1 = in_ . nextInt ( ) NEW_LINE x2 = in_ . nextInt ( ) NEW_LINE x3 = in_ . nextInt ( ) NEW_LINE point = Math . min ( x1 , Math . min ( x2 , x3 ) ) NEW_LINE if ( x1 > x2 and x1 < x3 ) or ( x1 > x3 and x1 < x2 ) : NEW_LINE INDENT point = x1 NEW_LINE DEDENT elif ( x1 > x2 and x2 > x3 ) or ( x2 < x3 and x2 > x1 ) : NEW_LINE INDENT point = x2 NEW_LINE DEDENT else : NEW_LINE INDENT point = x3 NEW_LINE DEDENT d = 0 NEW_LINE d = ( Math . abs ( x1 - point ) + Math . abs ( x2 - point ) + Math . abs ( x3 - point ) ) NEW_LINE print d NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def cntSubArr ( cls , arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT curr_gcd = __gcd ( curr_gcd , arr [ j ] ) NEW_LINE ans += 1 if ( curr_gcd == 1 ) else 0 NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT @ classmethod NEW_LINE def __gcd ( cls , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return cls . __gcd ( b , a % b ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = arr . length NEW_LINE print cls . cntSubArr ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def minStepToDeleteString ( cls , str_ ) : NEW_LINE INDENT N = len ( str_ ) NEW_LINE dp = [ None ] * N + 1 NEW_LINE i = 0 NEW_LINE while i <= N : NEW_LINE INDENT i += 1 NEW_LINE DEDENT len = 1 NEW_LINE while len <= N : NEW_LINE INDENT while j < N : NEW_LINE INDENT if len == 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if str_ . charAt ( i ) == str_ . charAt ( i + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT while K <= j : NEW_LINE INDENT K += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT len += 1 NEW_LINE DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT str_ = "2553432" NEW_LINE print cls . minStepToDeleteString ( str_ ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT

class GFG ( object ) : NEW_LINE INDENT DP_s = 9 NEW_LINE @ classmethod NEW_LINE def getNumMonotone ( cls , len ) : NEW_LINE INDENT DP = [ None ] * len NEW_LINE i = 0 NEW_LINE while i < DP_s : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < len : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return DP [ len - 1 ] [ cls . DP_s - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print cls . getNumMonotone ( 10 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT DP_s = 9 NEW_LINE @ classmethod NEW_LINE def getNumMonotone ( cls , len ) : NEW_LINE INDENT DP = [ None ] * len NEW_LINE i = 0 NEW_LINE while i < DP_s : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < len : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return DP [ len - 1 ] [ cls . DP_s - 1 ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print cls . getNumMonotone ( 10 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def maxCost ( cls , a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE k = int ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count = [ None ] * mx + 1 NEW_LINE i = 0 NEW_LINE while i < count . length : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT res = [ None ] * mx + 1 NEW_LINE res [ 0 ] = 0 NEW_LINE l = Math . min ( l , r ) NEW_LINE num = 1 NEW_LINE while num <= mx : NEW_LINE INDENT k = Math . max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE num += 1 NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = a . length NEW_LINE print cls . maxCost ( a , n , l , r ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class B1680 ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE T = in_ . nextInt ( ) NEW_LINE t = 0 NEW_LINE while t < T : NEW_LINE INDENT while r < R : NEW_LINE INDENT A [ r ] = in_ . next ( ) . toCharArray ( ) NEW_LINE r += 1 NEW_LINE DEDENT while rr < R : NEW_LINE INDENT while cc < C : NEW_LINE INDENT if A [ rr ] [ cc ] == ' R ' : NEW_LINE INDENT r = rr NEW_LINE c = cc NEW_LINE break NEW_LINE DEDENT cc += 1 NEW_LINE DEDENT rr += 1 NEW_LINE DEDENT while rr < R : NEW_LINE INDENT while cc < c : NEW_LINE INDENT if A [ rr ] [ cc ] == ' R ' : NEW_LINE INDENT ok = False NEW_LINE DEDENT cc += 1 NEW_LINE DEDENT rr += 1 NEW_LINE DEDENT print " YES " if ok else " NO " NEW_LINE t += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE B1680 . main ( sys . argv ) NEW_LINE DEDENT
class Test ( object ) : NEW_LINE INDENT PI = Math . PI NEW_LINE @ classmethod NEW_LINE def findArea ( cls , r ) : NEW_LINE INDENT return cls . PI * Math . pow ( r , 2 ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print " Area ▁ is ▁ " + cls . findArea ( 5 ) NEW_LINE DEDENT DEDENT




class GFG ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def findDigits ( cls , n , b ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) NEW_LINE return ( ( Math . floor ( x ) + 1 ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT print cls . findDigits ( 4 , 16 , + " \n " ) NEW_LINE print cls . findDigits ( 5 , 8 , + " \n " ) NEW_LINE print cls . findDigits ( 12 , 16 , + " \n " ) NEW_LINE print cls . findDigits ( 19 , 13 , + " \n " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE GFG . main ( sys . argv ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT in_ = Scanner ( System . in_ ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE q = in_ . nextInt ( ) NEW_LINE init ( n ) NEW_LINE i = 0 NEW_LINE while i < q : NEW_LINE INDENT if in_ . nextInt ( ) == 0 : NEW_LINE INDENT add ( in_ . nextInt ( ) , in_ . nextInt ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print sum ( in_ . nextInt ( ) , in_ . nextInt ( ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT nodes = [ ] NEW_LINE size = int ( ) NEW_LINE @ classmethod NEW_LINE def init ( cls , n ) : NEW_LINE INDENT cls . size = 1 NEW_LINE while cls . size < n : NEW_LINE cls . nodes = [ None ] * size + 1 NEW_LINE DEDENT @ classmethod NEW_LINE def add ( cls , target , value ) : NEW_LINE INDENT while target < nodes . length : NEW_LINE INDENT cls . nodes [ target ] += value NEW_LINE target += target & ( - target ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE @ overloaded NEW_LINE def sum ( cls , s , t ) : NEW_LINE INDENT return cls . sum ( t ) - cls . sum ( s - 1 ) NEW_LINE DEDENT @ classmethod NEW_LINE @ sum . register ( object , int ) NEW_LINE def sum_0 ( cls , t ) : NEW_LINE INDENT res = 0 NEW_LINE while t > 0 : NEW_LINE INDENT res += nodes [ t ] NEW_LINE t -= t & ( - t ) NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT

import java . util . Scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT numerator = int ( ) NEW_LINE denominator = int ( ) NEW_LINE maxproduct = int ( ) NEW_LINE parts = int ( ) NEW_LINE @ classmethod NEW_LINE def main ( cls , args ) : NEW_LINE INDENT sc = Scanner ( System . in_ ) NEW_LINE while True : NEW_LINE INDENT cls . numerator = sc . nextInt ( ) NEW_LINE cls . denominator = sc . nextInt ( ) NEW_LINE cls . maxproduct = sc . nextInt ( ) NEW_LINE cls . parts = sc . nextInt ( ) NEW_LINE if cls . parts == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count += Judge ( numerator , denominator , parts , 1 , 0 ) NEW_LINE print count NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def Judge ( cls , p , q , separate , now_pro , prev_deno ) : NEW_LINE INDENT count = 0 NEW_LINE if p == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if separate <= 0 : NEW_LINE INDENT return count NEW_LINE DEDENT deno = cls . maxproduct / now_pro + 1 NEW_LINE while separate * q < p * deno : NEW_LINE while p * deno >= q and prev_deno <= deno : NEW_LINE INDENT if now_pro * deno <= maxproduct : NEW_LINE INDENT count += Judge ( subtraction_nume , subtraction_deno , separate - 1 , now_pro * deno , deno ) NEW_LINE DEDENT deno -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE Main . main ( sys . argv ) NEW_LINE DEDENT






