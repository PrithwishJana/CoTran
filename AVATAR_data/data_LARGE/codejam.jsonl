{"id": "codejam_11_03", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class CandySplit { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new FileReader ( \" C - large \u2581 ( 1 ) . in \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output \" ) ) ; for ( int I = 1 ; I <= T ; I ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; int small = Integer . MAX_VALUE , tot = 0 , xor = 0 ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \" , false ) ; for ( int i = 0 ; i < N ; i ++ ) { int k = Integer . parseInt ( st . nextToken ( ) ) ; if ( k < small ) small = k ; tot += k ; xor = xor ^ k ; } if ( xor != 0 ) pw . println ( \" Case \u2581 # \" + I + \" : \u2581 NO \" ) ; else pw . println ( \" Case \u2581 # \" + I + \" : \u2581 \" + ( tot - small ) ) ; } br . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } catch ( IOException ie ) { ie . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new FileReader ( \" C - large \u2581 ( 1 ) . in \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output \" ) ) ; for ( int I = 1 ; I <= T ; I ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; int small = Integer . MAX_VALUE , tot = 0 , xor = 0 ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \" , false ) ; for ( int i = 0 ; i < N ; i ++ ) { int k = Integer . parseInt ( st . nextToken ( ) ) ; if ( k < small ) small = k ; tot += k ; xor = xor ^ k ; } if ( xor != 0 ) pw . println ( \" Case \u2581 # \" + I + \" : \u2581 NO \" ) ; else pw . println ( \" Case \u2581 # \" + I + \" : \u2581 \" + ( tot - small ) ) ; } br . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } catch ( IOException ie ) { ie . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "13", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Arrays ; public class C { public String solve ( int [ ] a ) { Arrays . sort ( a ) ; int n = a . length ; int total = 0 ; int xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor ^= a [ i ] ; total += a [ i ] ; } if ( xor != 0 ) { return \" NO \\n \" ; } total -= a [ 0 ] ; return total + \" \\n \" ; } public String runInput ( BufferedReader br ) throws IOException { int n = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; String [ ] items = br . readLine ( ) . trim ( ) . split ( \" \\\\ s + \" ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( items [ i ] ) ; } return solve ( a ) ; } public static void main ( String [ ] args ) { C c = new C ( ) ; try { c . parseFile ( \" C - sample \" ) ; c . parseFile ( \" C - small - attempt0\" ) ; c . parseFile ( \" C - large \" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public void parseFile ( String filePrefix ) throws IOException { String fileIn = filePrefix + \" . in \" ; String fileOut = filePrefix + \" . out \" ; BufferedReader br = new BufferedReader ( new FileReader ( fileIn ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( fileOut ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { String ret = \" Case \u2581 # \" + i + \" : \u2581 \" ; ret += runInput ( br ) ; System . out . print ( ret ) ; bw . write ( ret ) ; } br . close ( ) ; bw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { C c = new C ( ) ; try { c . parseFile ( \" C - sample \" ) ; c . parseFile ( \" C - small - attempt0\" ) ; c . parseFile ( \" C - large \" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": [["solve", "public String solve ( int [ ] a ) { Arrays . sort ( a ) ; int n = a . length ; int total = 0 ; int xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor ^= a [ i ] ; total += a [ i ] ; } if ( xor != 0 ) { return \" NO \\n \" ; } total -= a [ 0 ] ; return total + \" \\n \" ; }"], ["runInput", "public String runInput ( BufferedReader br ) throws IOException { int n = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; String [ ] items = br . readLine ( ) . trim ( ) . split ( \" \\\\ s + \" ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( items [ i ] ) ; } return solve ( a ) ; }"], ["parseFile", "public void parseFile ( String filePrefix ) throws IOException { String fileIn = filePrefix + \" . in \" ; String fileOut = filePrefix + \" . out \" ; BufferedReader br = new BufferedReader ( new FileReader ( fileIn ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( fileOut ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { String ret = \" Case \u2581 # \" + i + \" : \u2581 \" ; ret += runInput ( br ) ; System . out . print ( ret ) ; bw . write ( ret ) ; } br . close ( ) ; bw . close ( ) ; }"]]}, {"id": "18", "code": "import java . util . Scanner ; public class C { private static Scanner sc ; public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , exec ( ) ) ; } private static String exec ( ) { int n = sc . nextInt ( ) ; int [ ] candy = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) candy [ i ] = sc . nextInt ( ) ; return calc ( candy ) ; } private static String calc ( int [ ] candy ) { int xor = 0 ; int smallest = Integer . MAX_VALUE ; int sum = 0 ; for ( int c : candy ) { if ( smallest > c ) smallest = c ; xor ^= c ; sum += c ; } if ( xor != 0 ) return \" NO \" ; return \" \" + ( sum - smallest ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , exec ( ) ) ; }"], ["exec", "private static String exec ( ) { int n = sc . nextInt ( ) ; int [ ] candy = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) candy [ i ] = sc . nextInt ( ) ; return calc ( candy ) ; }"], ["calc", "private static String calc ( int [ ] candy ) { int xor = 0 ; int smallest = Integer . MAX_VALUE ; int sum = 0 ; for ( int c : candy ) { if ( smallest > c ) smallest = c ; xor ^= c ; sum += c ; } if ( xor != 0 ) return \" NO \" ; return \" \" + ( sum - smallest ) ; }"]], "functions_class": []}, {"id": "17", "code": "import java . awt . geom . * ; import java . io . * ; import java . math . * ; import java . util . * ; import java . util . regex . * ; import static java . lang . Math . * ; public class C_small { public static void main ( String [ ] args ) throws Exception { new C_small ( ) ; } public C_small ( ) throws Exception { line = br . readLine ( ) ; st = new StringTokenizer ( line ) ; int caseCount = Integer . parseInt ( st . nextToken ( ) ) ; for ( int caseNum = 1 ; caseNum <= caseCount ; caseNum ++ ) { String ans = null ; int N = Integer . parseInt ( br . readLine ( ) ) ; int total = 0 ; int xor = 0 ; int min = 1 << 30 ; line = br . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < N ; i ++ ) { int v = Integer . parseInt ( st . nextToken ( ) ) ; xor ^= v ; total += v ; min = min ( min , v ) ; } if ( xor != 0 ) ans = \" NO \" ; else { ans = total - min + \" \" ; } buf . append ( String . format ( \" Case \u2581 # % d : \u2581 % s \\n \" , caseNum , ans ) ) ; } System . out . print ( buf ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; StringTokenizer st ; StringBuilder buf = new StringBuilder ( ) ; public static void debug ( Object ... arr ) { System . err . println ( Arrays . deepToString ( arr ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new C_small ( ) ; }"], ["debug", "public static void debug ( Object ... arr ) { System . err . println ( Arrays . deepToString ( arr ) ) ; }"]], "functions_class": [["C_small", "public C_small ( ) throws Exception { line = br . readLine ( ) ; st = new StringTokenizer ( line ) ; int caseCount = Integer . parseInt ( st . nextToken ( ) ) ; for ( int caseNum = 1 ; caseNum <= caseCount ; caseNum ++ ) { String ans = null ; int N = Integer . parseInt ( br . readLine ( ) ) ; int total = 0 ; int xor = 0 ; int min = 1 << 30 ; line = br . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < N ; i ++ ) { int v = Integer . parseInt ( st . nextToken ( ) ) ; xor ^= v ; total += v ; min = min ( min , v ) ; } if ( xor != 0 ) ans = \" NO \" ; else { ans = total - min + \" \" ; } buf . append ( String . format ( \" Case \u2581 # % d : \u2581 % s \\n \" , caseNum , ans ) ) ; } System . out . print ( buf ) ; }"]]}, {"id": "3", "code": "import java . io . * ; import java . util . * ; public class C { private BufferedReader in ; private PrintWriter out ; private StringTokenizer st ; C ( ) throws IOException { in = new BufferedReader ( new FileReader ( \" C . large . in \" ) ) ; out = new PrintWriter ( \" C . large . out \" ) ; eat ( \" \" ) ; int T = nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int N = nextInt ( ) , xor = 0 , sum = 0 , m = 1000001 , c ; for ( int i = 0 ; i < N ; i ++ ) { c = nextInt ( ) ; xor ^= c ; sum += c ; m = Math . min ( m , c ) ; } out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; if ( xor != 0 ) { out . println ( \" NO \" ) ; } else { out . println ( sum - m ) ; } } in . close ( ) ; out . close ( ) ; } private void eat ( String str ) { st = new StringTokenizer ( str ) ; } String next ( ) throws IOException { while ( ! st . hasMoreTokens ( ) ) { String line = in . readLine ( ) ; if ( line == null ) { return null ; } eat ( line ) ; } return st . nextToken ( ) ; } int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public static void main ( String [ ] args ) throws IOException { new C ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new C ( ) ; }"]], "functions_class": [["C", "C ( ) throws IOException { in = new BufferedReader ( new FileReader ( \" C . large . in \" ) ) ; out = new PrintWriter ( \" C . large . out \" ) ; eat ( \" \" ) ; int T = nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int N = nextInt ( ) , xor = 0 , sum = 0 , m = 1000001 , c ; for ( int i = 0 ; i < N ; i ++ ) { c = nextInt ( ) ; xor ^= c ; sum += c ; m = Math . min ( m , c ) ; } out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; if ( xor != 0 ) { out . println ( \" NO \" ) ; } else { out . println ( sum - m ) ; } } in . close ( ) ; out . close ( ) ; }"], ["eat", "private void eat ( String str ) { st = new StringTokenizer ( str ) ; }"], ["next", "String next ( ) throws IOException { while ( ! st . hasMoreTokens ( ) ) { String line = in . readLine ( ) ; if ( line == null ) { return null ; } eat ( line ) ; } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; }"]]}], "python": [{"id": "11", "code": "import sys , re NEW_LINE from pprint import pprint NEW_LINE fi = open ( ' C - large . in ' , ' r ' ) NEW_LINE fo = open ( ' C - large . out ' , ' w ' ) NEW_LINE t = int ( fi . readline ( ) ) NEW_LINE for _ in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( fi . readline ( ) ) NEW_LINE v = map ( int , fi . readline ( ) . split ( ) ) NEW_LINE s = 0 NEW_LINE ss = 0 NEW_LINE for x in v : NEW_LINE INDENT s ^= x NEW_LINE ss += x NEW_LINE DEDENT if s > 0 : NEW_LINE INDENT fo . write ( ' Case \u2581 # % d : \u2581 NO \\n ' % _ ) NEW_LINE DEDENT else : NEW_LINE INDENT fo . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( _ , ss - min ( v ) ) ) NEW_LINE DEDENT DEDENT fi . close ( ) NEW_LINE fo . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "data = [ l . strip ( ) for l in open ( \" infile \" , \" r \" ) . readlines ( ) ] NEW_LINE out = open ( \" outfile \" , \" w \" ) NEW_LINE ncases = int ( data . pop ( 0 ) ) NEW_LINE for case in range ( ncases ) : NEW_LINE INDENT numcandies = int ( data . pop ( 0 ) ) NEW_LINE candies = [ int ( c ) for c in data . pop ( 0 ) . split ( ' \u2581 ' ) ] NEW_LINE truesum = 0 NEW_LINE xorsum = 0 NEW_LINE minimum = candies [ 0 ] NEW_LINE for i in candies : NEW_LINE INDENT truesum += i NEW_LINE xorsum ^= i NEW_LINE if i < minimum : NEW_LINE INDENT minimum = i NEW_LINE DEDENT DEDENT ans = ' NO ' NEW_LINE if xorsum == 0 : NEW_LINE INDENT ans = str ( truesum - minimum ) NEW_LINE DEDENT out . write ( \" Case \u2581 # \" + str ( case + 1 ) + \" : \u2581 \" + ans + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_11_04", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class Goro { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new FileReader ( \" D - large . in \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output \" ) ) ; for ( int I = 1 ; I <= T ; I ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \" , false ) ; int ret = N ; for ( int i = 0 ; i < N ; i ++ ) { int k = Integer . parseInt ( st . nextToken ( ) ) ; if ( k == i + 1 ) ret -- ; } pw . println ( \" Case \u2581 # \" + I + \" : \u2581 \" + ret + \" . 000000\" ) ; } br . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } catch ( IOException ie ) { ie . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new FileReader ( \" D - large . in \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output \" ) ) ; for ( int I = 1 ; I <= T ; I ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \" , false ) ; int ret = N ; for ( int i = 0 ; i < N ; i ++ ) { int k = Integer . parseInt ( st . nextToken ( ) ) ; if ( k == i + 1 ) ret -- ; } pw . println ( \" Case \u2581 # \" + I + \" : \u2581 \" + ret + \" . 000000\" ) ; } br . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } catch ( IOException ie ) { ie . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "1", "code": "import java . util . * ; import java . io . * ; public class Solution { public void doIt ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; final int MAX = 1000 ; double [ ] invFact = new double [ MAX + 1 ] ; invFact [ 0 ] = 1.0 ; for ( int i = 1 ; i <= MAX ; i ++ ) invFact [ i ] = invFact [ i - 1 ] / ( double ) i ; double [ ] derang = new double [ MAX + 1 ] ; derang [ 0 ] = invFact [ 0 ] ; for ( int i = 1 ; i <= MAX ; i ++ ) derang [ i ] = derang [ i - 1 ] + ( i % 2 == 1 ? - 1 : 1 ) * invFact [ i ] ; double [ ] avgTime = new double [ MAX + 1 ] ; avgTime [ 0 ] = 0.0 ; for ( int i = 1 ; i <= MAX ; i ++ ) { double sum = 1.0 ; for ( int j = 1 ; j <= i ; j ++ ) sum += avgTime [ i - j ] * invFact [ j ] * derang [ i - j ] ; avgTime [ i ] = sum / ( 1 - invFact [ 0 ] * derang [ i ] ) ; } int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { int N = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int x = sc . nextInt ( ) ; if ( x != i ) ans ++ ; } pw . println ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" + ans ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } public static void main ( String [ ] args ) throws Exception { new Solution ( ) . doIt ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new Solution ( ) . doIt ( ) ; }"]], "functions_class": [["doIt", "public void doIt ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; final int MAX = 1000 ; double [ ] invFact = new double [ MAX + 1 ] ; invFact [ 0 ] = 1.0 ; for ( int i = 1 ; i <= MAX ; i ++ ) invFact [ i ] = invFact [ i - 1 ] / ( double ) i ; double [ ] derang = new double [ MAX + 1 ] ; derang [ 0 ] = invFact [ 0 ] ; for ( int i = 1 ; i <= MAX ; i ++ ) derang [ i ] = derang [ i - 1 ] + ( i % 2 == 1 ? - 1 : 1 ) * invFact [ i ] ; double [ ] avgTime = new double [ MAX + 1 ] ; avgTime [ 0 ] = 0.0 ; for ( int i = 1 ; i <= MAX ; i ++ ) { double sum = 1.0 ; for ( int j = 1 ; j <= i ; j ++ ) sum += avgTime [ i - j ] * invFact [ j ] * derang [ i - j ] ; avgTime [ i ] = sum / ( 1 - invFact [ 0 ] * derang [ i ] ) ; } int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { int N = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int x = sc . nextInt ( ) ; if ( x != i ) ans ++ ; } pw . println ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" + ans ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]]}, {"id": "20", "code": "import java . util . * ; public class d { static double [ ] memo = new double [ 1010 ] ; static double [ ] [ ] memoo = new double [ 1010 ] [ 1010 ] ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = in . nextInt ( ) ; int k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( i != in . nextInt ( ) ) k ++ ; System . out . printf ( \" Case \u2581 # % d : \u2581 % f % n \" , t , ( double ) k ) ; } } public static double f ( int k , int j ) { if ( j < 0 || j > k ) return 0 ; if ( k == 0 && j == 0 ) return 1 ; if ( memoo [ k ] [ j ] != 0 ) return memoo [ k ] [ j ] ; double ans = f ( k - 1 , j - 1 ) + f ( k - 1 , j ) * ( k - 1 - j ) + f ( k - 1 , j + 1 ) * ( j + 1 ) ; ans /= k ; return memoo [ k ] [ j ] = ans ; } public static double go ( int k ) { if ( k == 0 ) return 0 ; if ( memo [ k ] != 0 ) return memo [ k ] ; double total = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { total += f ( k , i ) * go ( k - i ) ; } total /= ( 1 - f ( k , 0 ) ) ; return memo [ k ] = total ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = in . nextInt ( ) ; int k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( i != in . nextInt ( ) ) k ++ ; System . out . printf ( \" Case \u2581 # % d : \u2581 % f % n \" , t , ( double ) k ) ; } }"], ["f", "public static double f ( int k , int j ) { if ( j < 0 || j > k ) return 0 ; if ( k == 0 && j == 0 ) return 1 ; if ( memoo [ k ] [ j ] != 0 ) return memoo [ k ] [ j ] ; double ans = f ( k - 1 , j - 1 ) + f ( k - 1 , j ) * ( k - 1 - j ) + f ( k - 1 , j + 1 ) * ( j + 1 ) ; ans /= k ; return memoo [ k ] [ j ] = ans ; }"], ["go", "public static double go ( int k ) { if ( k == 0 ) return 0 ; if ( memo [ k ] != 0 ) return memo [ k ] ; double total = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { total += f ( k , i ) * go ( k - i ) ; } total /= ( 1 - f ( k , 0 ) ) ; return memo [ k ] = total ; }"]], "functions_class": []}, {"id": "7", "code": "import java . io . * ; import java . util . * ; import java . math . * ; public class Main implements Runnable { String file = \" D - large \" ; private void solve ( ) throws IOException { int tn = nextInt ( ) ; for ( int testN = 1 ; testN <= tn ; ++ testN ) { int n = nextInt ( ) ; int ans = n ; for ( int i = 0 ; i < n ; ++ i ) { if ( nextInt ( ) == i + 1 ) { -- ans ; } } out . printf ( \" Case \u2581 # % d : \u2581 % d . 000000 \\n \" , testN , ans ) ; } } public static void main ( String [ ] args ) { new Thread ( new Main ( ) ) . start ( ) ; } StringTokenizer tok ; PrintWriter out ; BufferedReader br ; @ Override public void run ( ) { try { Locale . setDefault ( Locale . US ) ; out = new PrintWriter ( new FileWriter ( file + \" . out \" ) ) ; br = new BufferedReader ( new FileReader ( file + \" . in \" ) ) ; tok = new StringTokenizer ( \" \" ) ; while ( hasNext ( ) ) { solve ( ) ; } out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } boolean hasNext ( ) throws IOException { while ( ! tok . hasMoreElements ( ) ) { String line = br . readLine ( ) ; if ( line == null ) { return false ; } tok = new StringTokenizer ( line ) ; } return true ; } String next ( ) throws IOException { if ( hasNext ( ) ) { return tok . nextToken ( ) ; } throw new IOException ( \" No \u2581 more \u2581 tokens \" ) ; } int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) throws IOException { if ( hasNext ( ) ) { return tok . nextToken ( \" \\n \" ) ; } throw new IOException ( \" No \u2581 more \u2581 tokens \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Thread ( new Main ( ) ) . start ( ) ; }"]], "functions_class": [["solve", "private void solve ( ) throws IOException { int tn = nextInt ( ) ; for ( int testN = 1 ; testN <= tn ; ++ testN ) { int n = nextInt ( ) ; int ans = n ; for ( int i = 0 ; i < n ; ++ i ) { if ( nextInt ( ) == i + 1 ) { -- ans ; } } out . printf ( \" Case \u2581 # % d : \u2581 % d . 000000 \\n \" , testN , ans ) ; } }"], ["run", "public void run ( ) { try { Locale . setDefault ( Locale . US ) ; out = new PrintWriter ( new FileWriter ( file + \" . out \" ) ) ; br = new BufferedReader ( new FileReader ( file + \" . in \" ) ) ; tok = new StringTokenizer ( \" \" ) ; while ( hasNext ( ) ) { solve ( ) ; } out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }"], ["hasNext", "boolean hasNext ( ) throws IOException { while ( ! tok . hasMoreElements ( ) ) { String line = br . readLine ( ) ; if ( line == null ) { return false ; } tok = new StringTokenizer ( line ) ; } return true ; }"], ["next", "String next ( ) throws IOException { if ( hasNext ( ) ) { return tok . nextToken ( ) ; } throw new IOException ( \" No \u2581 more \u2581 tokens \" ) ; }"], ["nextInt", "int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; }"], ["nextLine", "String nextLine ( ) throws IOException { if ( hasNext ( ) ) { return tok . nextToken ( \" \\n \" ) ; } throw new IOException ( \" No \u2581 more \u2581 tokens \" ) ; }"]]}, {"id": "12", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class D { static double [ ] dpc = new double [ 1024 ] ; static double [ ] dpa = new double [ 1024 ] ; public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( new File ( \" D . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" D . out \" ) ) ; dpc [ 1 ] = 0 ; dpc [ 2 ] = 2 ; dpa [ 1 ] = 0 ; dpa [ 2 ] = 1 ; for ( int i = 3 ; i <= 1000 ; i ++ ) { dpc [ i ] = 1 ; for ( int j = 1 ; j < i ; j ++ ) { dpc [ i ] += ( dpc [ j ] + dpa [ i - j ] ) / i ; } dpc [ i ] *= ( ( double ) i ) / ( i - 1 ) ; dpa [ i ] = dpc [ i ] - 1 ; } int T = s . nextInt ( ) ; int [ ] arr = new int [ 1024 ] ; boolean [ ] mark = new boolean [ 1024 ] ; for ( int tc = 1 ; tc <= T ; tc ++ ) { out . print ( \" Case \u2581 # \" + tc + \" : \u2581 \" ) ; int N = s . nextInt ( ) ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i ] = s . nextInt ( ) ; double answer = 0 ; Arrays . fill ( mark , false ) ; for ( int i = 1 ; i <= N ; i ++ ) { int cycleLength = 0 ; int cur = i ; while ( ! mark [ cur ] ) { mark [ cur ] = true ; cur = arr [ cur ] ; cycleLength ++ ; } answer += dpc [ cycleLength ] ; } out . println ( answer ) ; } out . close ( ) ; System . out . println ( dpc [ 1000 ] ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( new File ( \" D . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" D . out \" ) ) ; dpc [ 1 ] = 0 ; dpc [ 2 ] = 2 ; dpa [ 1 ] = 0 ; dpa [ 2 ] = 1 ; for ( int i = 3 ; i <= 1000 ; i ++ ) { dpc [ i ] = 1 ; for ( int j = 1 ; j < i ; j ++ ) { dpc [ i ] += ( dpc [ j ] + dpa [ i - j ] ) / i ; } dpc [ i ] *= ( ( double ) i ) / ( i - 1 ) ; dpa [ i ] = dpc [ i ] - 1 ; } int T = s . nextInt ( ) ; int [ ] arr = new int [ 1024 ] ; boolean [ ] mark = new boolean [ 1024 ] ; for ( int tc = 1 ; tc <= T ; tc ++ ) { out . print ( \" Case \u2581 # \" + tc + \" : \u2581 \" ) ; int N = s . nextInt ( ) ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i ] = s . nextInt ( ) ; double answer = 0 ; Arrays . fill ( mark , false ) ; for ( int i = 1 ; i <= N ; i ++ ) { int cycleLength = 0 ; int cur = i ; while ( ! mark [ cur ] ) { mark [ cur ] = true ; cur = arr [ cur ] ; cycleLength ++ ; } answer += dpc [ cycleLength ] ; } out . println ( answer ) ; } out . close ( ) ; System . out . println ( dpc [ 1000 ] ) ; }"]], "functions_class": []}], "python": [{"id": "19", "code": "data = [ l . strip ( ) for l in open ( \" infile \" , \" r \" ) . readlines ( ) ] NEW_LINE out = open ( \" outfile \" , \" w \" ) NEW_LINE ncases = int ( data . pop ( 0 ) ) NEW_LINE for case in range ( ncases ) : NEW_LINE INDENT numelements = int ( data . pop ( 0 ) ) NEW_LINE elements = [ int ( s ) for s in data . pop ( 0 ) . split ( ' \u2581 ' ) ] NEW_LINE inwrongplace = 0 NEW_LINE for i in range ( len ( elements ) ) : NEW_LINE INDENT if elements [ i ] != i + 1 : NEW_LINE INDENT inwrongplace += 1 NEW_LINE DEDENT DEDENT out . write ( \" Case \u2581 # \" + str ( case + 1 ) + \" : \u2581 \" + str ( \" % .6f \" % inwrongplace ) + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_11_32", "java": [{"id": "19", "code": "import java . util . Arrays ; import java . util . Scanner ; public class Space { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int L = sc . nextInt ( ) ; long t = sc . nextLong ( ) ; int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; long time = t ; int [ ] a = new int [ 1000001 ] ; for ( int j = 0 ; j < C ; j ++ ) { a [ j ] = sc . nextInt ( ) ; } for ( int j = C ; j < N ; j ++ ) { a [ j ] = a [ j - C ] ; } int index = 0 ; while ( t > 0 && index < N ) { if ( a [ index ] > ( t / 2 ) ) { a [ index ] -= t / 2 ; t = - 1 ; } else { t -= a [ index ] * 2 ; index ++ ; } } if ( t > 0 ) { time -= t ; } if ( index < N ) { Arrays . sort ( a , index , ( int ) N ) ; for ( int j = ( int ) ( N - 1 ) ; j >= index ; j -- ) { if ( L > 0 ) { time += a [ j ] ; L -- ; } else { time += a [ j ] * 2 ; } } } System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + time ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int L = sc . nextInt ( ) ; long t = sc . nextLong ( ) ; int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; long time = t ; int [ ] a = new int [ 1000001 ] ; for ( int j = 0 ; j < C ; j ++ ) { a [ j ] = sc . nextInt ( ) ; } for ( int j = C ; j < N ; j ++ ) { a [ j ] = a [ j - C ] ; } int index = 0 ; while ( t > 0 && index < N ) { if ( a [ index ] > ( t / 2 ) ) { a [ index ] -= t / 2 ; t = - 1 ; } else { t -= a [ index ] * 2 ; index ++ ; } } if ( t > 0 ) { time -= t ; } if ( index < N ) { Arrays . sort ( a , index , ( int ) N ) ; for ( int j = ( int ) ( N - 1 ) ; j >= index ; j -- ) { if ( L > 0 ) { time += a [ j ] ; L -- ; } else { time += a [ j ] * 2 ; } } } System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + time ) ; } }"]], "functions_class": []}, {"id": "6", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . * ; public class SquareTiles { public static void main ( String args [ ] ) throws FileNotFoundException { new SquareTiles ( ) ; } public SquareTiles ( ) throws FileNotFoundException { Scanner scanner = new Scanner ( System . in ) ; PrintWriter writer = new PrintWriter ( new File ( \" C : / res . txt \" ) ) ; int COUNT = scanner . nextInt ( ) ; for ( int y = 1 ; y <= COUNT ; y ++ ) { int N = scanner . nextInt ( ) , M = scanner . nextInt ( ) ; char matrix [ ] [ ] = new char [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { String t = scanner . next ( ) ; for ( int j = 0 ; j < M ; j ++ ) matrix [ i ] [ j ] = t . charAt ( j ) ; } boolean impossible = false ; loop : for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( matrix [ i ] [ j ] == ' # ' ) { if ( i < N - 1 && j < M - 1 && matrix [ i ] [ j ] == ' # ' && matrix [ i ] [ j + 1 ] == ' # ' && matrix [ i + 1 ] [ j ] == ' # ' && matrix [ i + 1 ] [ j + 1 ] == ' # ' ) { matrix [ i ] [ j ] = ' / ' ; matrix [ i ] [ j + 1 ] = ' \\ \\' ; matrix [ i + 1 ] [ j ] = ' \\ \\' ; matrix [ i + 1 ] [ j + 1 ] = ' / ' ; } else { impossible = true ; break loop ; } } } } writer . write ( String . format ( \" Case \u2581 # % d : \\n \" , y ) ) ; if ( impossible ) writer . write ( \" Impossible \\n \" ) ; else { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) writer . write ( matrix [ i ] [ j ] ) ; writer . write ( \" \\n \" ) ; } } } writer . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws FileNotFoundException { new SquareTiles ( ) ; }"]], "functions_class": [["SquareTiles", "public SquareTiles ( ) throws FileNotFoundException { Scanner scanner = new Scanner ( System . in ) ; PrintWriter writer = new PrintWriter ( new File ( \" C : / res . txt \" ) ) ; int COUNT = scanner . nextInt ( ) ; for ( int y = 1 ; y <= COUNT ; y ++ ) { int N = scanner . nextInt ( ) , M = scanner . nextInt ( ) ; char matrix [ ] [ ] = new char [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { String t = scanner . next ( ) ; for ( int j = 0 ; j < M ; j ++ ) matrix [ i ] [ j ] = t . charAt ( j ) ; } boolean impossible = false ; loop : for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( matrix [ i ] [ j ] == ' # ' ) { if ( i < N - 1 && j < M - 1 && matrix [ i ] [ j ] == ' # ' && matrix [ i ] [ j + 1 ] == ' # ' && matrix [ i + 1 ] [ j ] == ' # ' && matrix [ i + 1 ] [ j + 1 ] == ' # ' ) { matrix [ i ] [ j ] = ' / ' ; matrix [ i ] [ j + 1 ] = ' \\ \\' ; matrix [ i + 1 ] [ j ] = ' \\ \\' ; matrix [ i + 1 ] [ j + 1 ] = ' / ' ; } else { impossible = true ; break loop ; } } } } writer . write ( String . format ( \" Case \u2581 # % d : \\n \" , y ) ) ; if ( impossible ) writer . write ( \" Impossible \\n \" ) ; else { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) writer . write ( matrix [ i ] [ j ] ) ; writer . write ( \" \\n \" ) ; } } } writer . close ( ) ; }"]]}, {"id": "12", "code": "import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; public class BL { private static final String FILE_NAME = \" B - large \" ; public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( FILE_NAME + \" . in \" ) ) ; Scanner scanner = new Scanner ( in ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( FILE_NAME + \" L . out \" ) ) ; int t = scanner . nextInt ( ) ; for ( int c = 1 ; c <= t ; ++ c ) { int speedN = scanner . nextInt ( ) ; long speedT = scanner . nextLong ( ) ; int n = scanner . nextInt ( ) ; int cc = scanner . nextInt ( ) ; long totalTime = 0 ; List < Long > savedTimes = new ArrayList < Long > ( ) ; int [ ] d = new int [ cc ] ; for ( int i = 0 ; i < n ; ++ i ) { int time ; if ( i < cc ) { d [ i ] = 2 * scanner . nextInt ( ) ; time = d [ i ] ; } else { time = d [ i % cc ] ; } if ( totalTime >= speedT ) { savedTimes . add ( ( long ) time / 2 ) ; } else if ( totalTime + time > speedT ) { savedTimes . add ( ( ( totalTime + time ) - speedT ) / 2 ) ; } totalTime += time ; } Collections . sort ( savedTimes ) ; int len = savedTimes . size ( ) ; for ( int i = 0 ; i < speedN && i < len ; ++ i ) { totalTime -= savedTimes . get ( len - i - 1 ) ; } StringBuilder ans = new StringBuilder ( ) ; ans . append ( \" Case \u2581 # \" ) ; ans . append ( c ) ; ans . append ( \" : \u2581 \" ) ; ans . append ( totalTime ) ; out . write ( ans . toString ( ) + \" \\n \" ) ; System . out . println ( ans . toString ( ) ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( FILE_NAME + \" . in \" ) ) ; Scanner scanner = new Scanner ( in ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( FILE_NAME + \" L . out \" ) ) ; int t = scanner . nextInt ( ) ; for ( int c = 1 ; c <= t ; ++ c ) { int speedN = scanner . nextInt ( ) ; long speedT = scanner . nextLong ( ) ; int n = scanner . nextInt ( ) ; int cc = scanner . nextInt ( ) ; long totalTime = 0 ; List < Long > savedTimes = new ArrayList < Long > ( ) ; int [ ] d = new int [ cc ] ; for ( int i = 0 ; i < n ; ++ i ) { int time ; if ( i < cc ) { d [ i ] = 2 * scanner . nextInt ( ) ; time = d [ i ] ; } else { time = d [ i % cc ] ; } if ( totalTime >= speedT ) { savedTimes . add ( ( long ) time / 2 ) ; } else if ( totalTime + time > speedT ) { savedTimes . add ( ( ( totalTime + time ) - speedT ) / 2 ) ; } totalTime += time ; } Collections . sort ( savedTimes ) ; int len = savedTimes . size ( ) ; for ( int i = 0 ; i < speedN && i < len ; ++ i ) { totalTime -= savedTimes . get ( len - i - 1 ) ; } StringBuilder ans = new StringBuilder ( ) ; ans . append ( \" Case \u2581 # \" ) ; ans . append ( c ) ; ans . append ( \" : \u2581 \" ) ; ans . append ( totalTime ) ; out . write ( ans . toString ( ) + \" \\n \" ) ; System . out . println ( ans . toString ( ) ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "0", "code": "import java . util . * ; import java . io . * ; public class Solution { public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int T = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { System . out . println ( \" case \u2581 \" + caseNum ) ; int L = sc . nextInt ( ) ; long t = sc . nextLong ( ) ; int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; long [ ] a = new long [ N ] ; for ( int i = 0 ; i < C ; i ++ ) a [ i ] = sc . nextLong ( ) ; for ( int i = C ; i < N ; i ++ ) a [ i ] = a [ i - C ] ; long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) res += 4 * a [ i ] ; int pos = 0 ; while ( pos < N && 2 * a [ pos ] <= t ) { t -= 2 * a [ pos ] ; pos ++ ; } if ( pos < N ) { List < Long > ll = new ArrayList < Long > ( ) ; ll . add ( 2 * a [ pos ] - t ) ; for ( int i = pos + 1 ; i < N ; i ++ ) ll . add ( 2 * a [ i ] ) ; Collections . sort ( ll ) ; for ( int i = ll . size ( ) - 1 ; i >= 0 && i >= ll . size ( ) - L ; i -- ) { res -= ll . get ( i ) ; } } if ( res % 2 == 1 ) { System . out . println ( \" failure \" ) ; System . exit ( 0 ) ; } else pw . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + res / 2 ) ; } sc . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; }"]], "functions_class": [["doMain", "public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int T = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { System . out . println ( \" case \u2581 \" + caseNum ) ; int L = sc . nextInt ( ) ; long t = sc . nextLong ( ) ; int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; long [ ] a = new long [ N ] ; for ( int i = 0 ; i < C ; i ++ ) a [ i ] = sc . nextLong ( ) ; for ( int i = C ; i < N ; i ++ ) a [ i ] = a [ i - C ] ; long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) res += 4 * a [ i ] ; int pos = 0 ; while ( pos < N && 2 * a [ pos ] <= t ) { t -= 2 * a [ pos ] ; pos ++ ; } if ( pos < N ) { List < Long > ll = new ArrayList < Long > ( ) ; ll . add ( 2 * a [ pos ] - t ) ; for ( int i = pos + 1 ; i < N ; i ++ ) ll . add ( 2 * a [ i ] ) ; Collections . sort ( ll ) ; for ( int i = ll . size ( ) - 1 ; i >= 0 && i >= ll . size ( ) - L ; i -- ) { res -= ll . get ( i ) ; } } if ( res % 2 == 1 ) { System . out . println ( \" failure \" ) ; System . exit ( 0 ) ; } else pw . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + res / 2 ) ; } sc . close ( ) ; pw . flush ( ) ; pw . close ( ) ; }"]]}, {"id": "18", "code": "package CodeJam ; import java . util . * ; import java . io . * ; public class B { private static String inFilename = \" B - large . in \" ; public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" src / CodeJam / \" + inFilename ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" src / CodeJam / output . txt \" ) ) ; int T = in . nextInt ( ) ; for ( int tt = 0 ; tt < T ; tt ++ ) { long result = 0 ; int L = in . nextInt ( ) ; long t = in . nextLong ( ) ; int N = in . nextInt ( ) ; int C = in . nextInt ( ) ; int [ ] a = new int [ C ] ; for ( int i = 0 ; i < C ; i ++ ) { a [ i ] = in . nextInt ( ) ; } int [ ] d = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { d [ i ] = a [ i % C ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( result + d [ i ] * 2 <= t ) { result += d [ i ] * 2 ; } else { int left0 = ( int ) ( d [ i ] - ( t - result ) / 2 ) ; result = t ; int [ ] left = new int [ N - i ] ; left [ 0 ] = left0 ; for ( int j = 1 ; j < N - i ; j ++ ) { left [ j ] = d [ i + j ] ; } Arrays . sort ( left ) ; int j = left . length - 1 ; for ( int l = 0 ; l < L && j >= 0 ; l ++ ) { result += left [ j -- ] ; } for ( int k = j ; k >= 0 ; k -- ) { result += left [ k ] * 2 ; } break ; } } out . print ( \" Case \u2581 # \" + ( tt + 1 ) + \" : \u2581 \" + result + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" src / CodeJam / \" + inFilename ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" src / CodeJam / output . txt \" ) ) ; int T = in . nextInt ( ) ; for ( int tt = 0 ; tt < T ; tt ++ ) { long result = 0 ; int L = in . nextInt ( ) ; long t = in . nextLong ( ) ; int N = in . nextInt ( ) ; int C = in . nextInt ( ) ; int [ ] a = new int [ C ] ; for ( int i = 0 ; i < C ; i ++ ) { a [ i ] = in . nextInt ( ) ; } int [ ] d = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { d [ i ] = a [ i % C ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( result + d [ i ] * 2 <= t ) { result += d [ i ] * 2 ; } else { int left0 = ( int ) ( d [ i ] - ( t - result ) / 2 ) ; result = t ; int [ ] left = new int [ N - i ] ; left [ 0 ] = left0 ; for ( int j = 1 ; j < N - i ; j ++ ) { left [ j ] = d [ i + j ] ; } Arrays . sort ( left ) ; int j = left . length - 1 ; for ( int l = 0 ; l < L && j >= 0 ; l ++ ) { result += left [ j -- ] ; } for ( int k = j ; k >= 0 ; k -- ) { result += left [ k ] * 2 ; } break ; } } out . print ( \" Case \u2581 # \" + ( tt + 1 ) + \" : \u2581 \" + result + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "14", "code": "import math NEW_LINE import sys NEW_LINE def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE sys . stderr . write ( \" , \" . join ( [ str ( x ) for x in st ] ) + \" \\n \" ) NEW_LINE DEDENT def generator ( N , l ) : NEW_LINE INDENT a = 0 NEW_LINE i = 0 NEW_LINE while a < N : NEW_LINE INDENT yield l [ i ] NEW_LINE i += 1 NEW_LINE if i == len ( l ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT DEDENT def simulate ( ) : NEW_LINE INDENT l = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE L = l . pop ( 0 ) NEW_LINE t = l . pop ( 0 ) NEW_LINE N = l . pop ( 0 ) NEW_LINE C = l . pop ( 0 ) NEW_LINE printe ( l ) NEW_LINE sum = 0 NEW_LINE pfactory = [ ] NEW_LINE firstBuilt = False NEW_LINE for star in generator ( N , l ) : NEW_LINE INDENT if sum > t : NEW_LINE INDENT pfactory . append ( star ) NEW_LINE if not firstBuilt : NEW_LINE INDENT firstBuilt = True NEW_LINE pfactory . append ( ( sum - t ) / 2 ) NEW_LINE DEDENT DEDENT sum += star * 2 NEW_LINE printe ( star ) NEW_LINE DEDENT if sum > t : NEW_LINE INDENT if not firstBuilt : NEW_LINE INDENT pfactory . append ( ( sum - t ) / 2 ) NEW_LINE DEDENT DEDENT pfactory . sort ( reverse = True ) NEW_LINE printe ( \" pf \" , pfactory ) NEW_LINE for i in range ( L ) : NEW_LINE INDENT if i >= len ( pfactory ) : NEW_LINE INDENT break NEW_LINE DEDENT sum -= pfactory [ i ] NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i + 1 , simulate ( ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["printe", "def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE sys . stderr . write ( \" , \" . join ( [ str ( x ) for x in st ] ) + \" \\n \" ) NEW_LINE DEDENT"], ["generator", "def generator ( N , l ) : NEW_LINE INDENT a = 0 NEW_LINE i = 0 NEW_LINE while a < N : NEW_LINE INDENT yield l [ i ] NEW_LINE i += 1 NEW_LINE if i == len ( l ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT DEDENT"], ["simulate", "def simulate ( ) : NEW_LINE INDENT l = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE L = l . pop ( 0 ) NEW_LINE t = l . pop ( 0 ) NEW_LINE N = l . pop ( 0 ) NEW_LINE C = l . pop ( 0 ) NEW_LINE printe ( l ) NEW_LINE sum = 0 NEW_LINE pfactory = [ ] NEW_LINE firstBuilt = False NEW_LINE for star in generator ( N , l ) : NEW_LINE INDENT if sum > t : NEW_LINE INDENT pfactory . append ( star ) NEW_LINE if not firstBuilt : NEW_LINE INDENT firstBuilt = True NEW_LINE pfactory . append ( ( sum - t ) / 2 ) NEW_LINE DEDENT DEDENT sum += star * 2 NEW_LINE printe ( star ) NEW_LINE DEDENT if sum > t : NEW_LINE INDENT if not firstBuilt : NEW_LINE INDENT pfactory . append ( ( sum - t ) / 2 ) NEW_LINE DEDENT DEDENT pfactory . sort ( reverse = True ) NEW_LINE printe ( \" pf \" , pfactory ) NEW_LINE for i in range ( L ) : NEW_LINE INDENT if i >= len ( pfactory ) : NEW_LINE INDENT break NEW_LINE DEDENT sum -= pfactory [ i ] NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "4", "code": "from __future__ import division NEW_LINE import sys NEW_LINE import math NEW_LINE def calc ( line ) : NEW_LINE INDENT boosters = int ( line [ 0 ] ) NEW_LINE ready = int ( line [ 1 ] ) NEW_LINE stars = int ( line [ 2 ] ) NEW_LINE dist = [ int ( x ) for x in line [ 4 : ] ] NEW_LINE dist = dist * int ( math . ceil ( stars / len ( dist ) ) ) NEW_LINE dist = dist [ : stars ] NEW_LINE timer = 0 NEW_LINE i = 0 NEW_LINE while timer < ready : NEW_LINE INDENT if ready - timer < dist [ i ] * 2 : NEW_LINE INDENT dist [ i ] -= ( ready - timer ) / 2 NEW_LINE timer = ready NEW_LINE DEDENT else : NEW_LINE INDENT timer += dist [ i ] * 2 NEW_LINE i += 1 NEW_LINE if i == stars : return timer NEW_LINE DEDENT DEDENT dist = list ( reversed ( sorted ( dist [ i : ] ) ) ) NEW_LINE for i in range ( boosters , len ( dist ) ) : NEW_LINE INDENT dist [ i ] *= 2 NEW_LINE DEDENT timer += sum ( dist ) NEW_LINE return timer NEW_LINE DEDENT def getints ( ) : NEW_LINE INDENT return [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" \u2581 \" ) ] NEW_LINE DEDENT numTestCases = getints ( ) [ 0 ] NEW_LINE for i in range ( numTestCases ) : NEW_LINE INDENT result = calc ( getints ( ) ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \" % ( i + 1 , result ) ) NEW_LINE DEDENT", "functions_standalone": [["calc", "def calc ( line ) : NEW_LINE INDENT boosters = int ( line [ 0 ] ) NEW_LINE ready = int ( line [ 1 ] ) NEW_LINE stars = int ( line [ 2 ] ) NEW_LINE dist = [ int ( x ) for x in line [ 4 : ] ] NEW_LINE dist = dist * int ( math . ceil ( stars / len ( dist ) ) ) NEW_LINE dist = dist [ : stars ] NEW_LINE timer = 0 NEW_LINE i = 0 NEW_LINE while timer < ready : NEW_LINE INDENT if ready - timer < dist [ i ] * 2 : NEW_LINE INDENT dist [ i ] -= ( ready - timer ) / 2 NEW_LINE timer = ready NEW_LINE DEDENT else : NEW_LINE INDENT timer += dist [ i ] * 2 NEW_LINE i += 1 NEW_LINE if i == stars : return timer NEW_LINE DEDENT DEDENT dist = list ( reversed ( sorted ( dist [ i : ] ) ) ) NEW_LINE for i in range ( boosters , len ( dist ) ) : NEW_LINE INDENT dist [ i ] *= 2 NEW_LINE DEDENT timer += sum ( dist ) NEW_LINE return timer NEW_LINE DEDENT"], ["getints", "def getints ( ) : NEW_LINE INDENT return [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" \u2581 \" ) ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_11_33", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; import java . math . * ; public class C { private BufferedReader in ; private PrintWriter out ; private StringTokenizer st ; private void solve ( ) throws IOException { int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int N = nextInt ( ) ; long L = nextLong ( ) ; long H = nextLong ( ) ; long [ ] A = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = nextLong ( ) ; } long result = - 1 ; for ( long C = L ; C <= H ; C ++ ) { boolean ok = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( C % A [ i ] != 0 && A [ i ] % C != 0 ) { ok = false ; break ; } } if ( ok ) { result = C ; break ; } } if ( result == - 1 ) { out . println ( \" NO \" ) ; } else { out . println ( result ) ; } } } public static void main ( String [ ] args ) { new C ( ) . run ( ) ; } public void run ( ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( System . out ) ; st = null ; solve ( ) ; in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private String nextToken ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( in . readLine ( ) ) ; } return st . nextToken ( ) ; } private int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } private long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } private double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new C ( ) . run ( ) ; }"]], "functions_class": [["solve", "private void solve ( ) throws IOException { int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int N = nextInt ( ) ; long L = nextLong ( ) ; long H = nextLong ( ) ; long [ ] A = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = nextLong ( ) ; } long result = - 1 ; for ( long C = L ; C <= H ; C ++ ) { boolean ok = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( C % A [ i ] != 0 && A [ i ] % C != 0 ) { ok = false ; break ; } } if ( ok ) { result = C ; break ; } } if ( result == - 1 ) { out . println ( \" NO \" ) ; } else { out . println ( result ) ; } } }"], ["run", "public void run ( ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( System . out ) ; st = null ; solve ( ) ; in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"], ["nextToken", "private String nextToken ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( in . readLine ( ) ) ; } return st . nextToken ( ) ; }"], ["nextInt", "private int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "private long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "private double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; }"]]}, {"id": "20", "code": "package CodeJam ; import java . util . * ; import java . io . * ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . ArrayUtils ; import java . lang . Math . * ; import java . math . BigInteger ; import static helper . Print . * ; public class B { private static String inFilename = \" C - small - attempt0 . in \" ; public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" src / CodeJam / \" + inFilename ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" src / CodeJam / output . txt \" ) ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { String result = \" NO \" ; int N = in . nextInt ( ) ; int L = in . nextInt ( ) ; int H = in . nextInt ( ) ; int [ ] f = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { f [ i ] = in . nextInt ( ) ; } loop : for ( int i = L ; i <= H ; i ++ ) { int j = 0 ; for ( ; j < N ; j ++ ) { if ( ! ( f [ j ] % i == 0 || i % f [ j ] == 0 ) ) { continue loop ; } } if ( j == N ) { result = String . valueOf ( i ) ; break ; } } out . print ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + result + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" src / CodeJam / \" + inFilename ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" src / CodeJam / output . txt \" ) ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { String result = \" NO \" ; int N = in . nextInt ( ) ; int L = in . nextInt ( ) ; int H = in . nextInt ( ) ; int [ ] f = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { f [ i ] = in . nextInt ( ) ; } loop : for ( int i = L ; i <= H ; i ++ ) { int j = 0 ; for ( ; j < N ; j ++ ) { if ( ! ( f [ j ] % i == 0 || i % f [ j ] == 0 ) ) { continue loop ; } } if ( j == N ) { result = String . valueOf ( i ) ; break ; } } out . print ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + result + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": []}, {"id": "8", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class PerfectHarmony { public static void main ( String args [ ] ) throws FileNotFoundException { new PerfectHarmony ( ) ; } public PerfectHarmony ( ) throws FileNotFoundException { Scanner scanner = new Scanner ( System . in ) ; PrintWriter writer = new PrintWriter ( new File ( \" C : / res . txt \" ) ) ; int COUNT = scanner . nextInt ( ) ; for ( int y = 1 ; y <= COUNT ; y ++ ) { int N = scanner . nextInt ( ) , L = scanner . nextInt ( ) , H = scanner . nextInt ( ) ; int nums [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) nums [ i ] = scanner . nextInt ( ) ; boolean result = false ; loop : for ( int i = L ; i <= H ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) if ( i % nums [ j ] != 0 && nums [ j ] % i != 0 ) continue loop ; writer . write ( String . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , y , i ) ) ; result = true ; break loop ; } if ( ! result ) { writer . write ( String . format ( \" Case \u2581 # % d : \u2581 NO \\n \" , y ) ) ; } } writer . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws FileNotFoundException { new PerfectHarmony ( ) ; }"]], "functions_class": [["PerfectHarmony", "public PerfectHarmony ( ) throws FileNotFoundException { Scanner scanner = new Scanner ( System . in ) ; PrintWriter writer = new PrintWriter ( new File ( \" C : / res . txt \" ) ) ; int COUNT = scanner . nextInt ( ) ; for ( int y = 1 ; y <= COUNT ; y ++ ) { int N = scanner . nextInt ( ) , L = scanner . nextInt ( ) , H = scanner . nextInt ( ) ; int nums [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) nums [ i ] = scanner . nextInt ( ) ; boolean result = false ; loop : for ( int i = L ; i <= H ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) if ( i % nums [ j ] != 0 && nums [ j ] % i != 0 ) continue loop ; writer . write ( String . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , y , i ) ) ; result = true ; break loop ; } if ( ! result ) { writer . write ( String . format ( \" Case \u2581 # % d : \u2581 NO \\n \" , y ) ) ; } } writer . close ( ) ; }"]]}, {"id": "13", "code": "import java . io . * ; import java . util . * ; public class Main { Scanner in ; PrintWriter out ; static final String problem = \" C - small \" ; static void asserT ( boolean e ) { if ( ! e ) { throw new Error ( ) ; } } void solveOne ( ) { int nPlayers = in . nextInt ( ) ; int low = in . nextInt ( ) ; int high = in . nextInt ( ) ; int freq [ ] = new int [ nPlayers ] ; for ( int i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = in . nextInt ( ) ; } for ( int f = low ; f <= high ; f ++ ) { boolean fail = false ; for ( int other : freq ) { if ( other % f != 0 && f % other != 0 ) { fail = true ; break ; } } if ( ! fail ) { out . println ( f ) ; return ; } } out . println ( \" NO \" ) ; } void solve ( ) { int nTests = in . nextInt ( ) ; for ( int i = 0 ; i < nTests ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solveOne ( ) ; } } void run ( ) { try { in = new Scanner ( new FileReader ( \" C : \\ \\r oundC \\ \\\" + problem + \" . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" C : \\ \\r oundC \\ \\\" + problem + \" . out \" ) ) ; } catch ( IOException e ) { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; } try { solve ( ) ; } finally { out . close ( ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }", "functions_standalone": [["asserT", "static void asserT ( boolean e ) { if ( ! e ) { throw new Error ( ) ; } }"], ["main", "public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; }"]], "functions_class": [["solveOne", "void solveOne ( ) { int nPlayers = in . nextInt ( ) ; int low = in . nextInt ( ) ; int high = in . nextInt ( ) ; int freq [ ] = new int [ nPlayers ] ; for ( int i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = in . nextInt ( ) ; } for ( int f = low ; f <= high ; f ++ ) { boolean fail = false ; for ( int other : freq ) { if ( other % f != 0 && f % other != 0 ) { fail = true ; break ; } } if ( ! fail ) { out . println ( f ) ; return ; } } out . println ( \" NO \" ) ; }"], ["solve", "void solve ( ) { int nTests = in . nextInt ( ) ; for ( int i = 0 ; i < nTests ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solveOne ( ) ; } }"], ["run", "void run ( ) { try { in = new Scanner ( new FileReader ( \" C : \\ \\r oundC \\ \\\" + problem + \" . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" C : \\ \\r oundC \\ \\\" + problem + \" . out \" ) ) ; } catch ( IOException e ) { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; } try { solve ( ) ; } finally { out . close ( ) ; } }"]]}, {"id": "7", "code": "import java . io . * ; import java . math . * ; import java . util . * ; import java . text . * ; import java . util . regex . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Integer . * ; import static java . lang . Double . * ; import static java . lang . Character . * ; public class C { Object solve ( ) { int N = sc . nextInt ( ) ; long L = sc . nextLong ( ) ; long H = sc . nextLong ( ) ; long [ ] a = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) a [ i ] = sc . nextLong ( ) ; loop : for ( long m = L ; m <= H ; m ++ ) { for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] % m != 0 && m % a [ i ] != 0 ) continue loop ; } return m ; } return \" NO \" ; } private static Scanner sc ; private static PrintWriter fw ; public static void main ( String [ ] args ) throws Exception { String inFile ; inFile = \" C - small - attempt0 . in \" ; sc = new Scanner ( new FileInputStream ( inFile ) ) ; fw = new PrintWriter ( new FileWriter ( \" output . txt \" , false ) ) ; int N = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int cas = 1 ; cas <= N ; cas ++ ) { fw . print ( \" Case \u2581 # \" + cas + \" : \u2581 \" ) ; Object res = new C ( ) . solve ( ) ; if ( res instanceof Double ) fw . printf ( \" % .10f \\n \" , res ) ; else fw . printf ( \" % s \\n \" , res ) ; fw . flush ( ) ; } fw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String inFile ; inFile = \" C - small - attempt0 . in \" ; sc = new Scanner ( new FileInputStream ( inFile ) ) ; fw = new PrintWriter ( new FileWriter ( \" output . txt \" , false ) ) ; int N = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int cas = 1 ; cas <= N ; cas ++ ) { fw . print ( \" Case \u2581 # \" + cas + \" : \u2581 \" ) ; Object res = new C ( ) . solve ( ) ; if ( res instanceof Double ) fw . printf ( \" % .10f \\n \" , res ) ; else fw . printf ( \" % s \\n \" , res ) ; fw . flush ( ) ; } fw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["solve", "Object solve ( ) { int N = sc . nextInt ( ) ; long L = sc . nextLong ( ) ; long H = sc . nextLong ( ) ; long [ ] a = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) a [ i ] = sc . nextLong ( ) ; loop : for ( long m = L ; m <= H ; m ++ ) { for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] % m != 0 && m % a [ i ] != 0 ) continue loop ; } return m ; } return \" NO \" ; }"]]}], "python": [{"id": "6", "code": "T = int ( input ( ) ) NEW_LINE for num in range ( 1 , T + 1 ) : NEW_LINE INDENT n , l , h = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE l = int ( l ) NEW_LINE h = int ( h ) NEW_LINE F = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( \" Case \u2581 # \" , num , \" : \" , sep = ' ' , end = ' \u2581 ' ) NEW_LINE for ans in range ( l , h + 1 ) : NEW_LINE INDENT good = True NEW_LINE for elem in F : NEW_LINE INDENT if elem % ans != 0 and ans % elem != 0 : NEW_LINE INDENT good = False NEW_LINE DEDENT DEDENT if good : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "7", "code": "from __future__ import division NEW_LINE import sys NEW_LINE def calc ( a , b ) : NEW_LINE INDENT n , l , h = a NEW_LINE freq = b NEW_LINE for i in range ( l , h + 1 ) : NEW_LINE INDENT harmony = True NEW_LINE for f in freq : NEW_LINE INDENT if not ( f % i == 0 or i % f == 0 ) : NEW_LINE INDENT harmony = False NEW_LINE break NEW_LINE DEDENT DEDENT if harmony : NEW_LINE INDENT return \" % d \" % i NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT def getints ( ) : NEW_LINE INDENT return [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" \u2581 \" ) ] NEW_LINE DEDENT numTestCases = getints ( ) [ 0 ] NEW_LINE for i in range ( numTestCases ) : NEW_LINE INDENT result = calc ( getints ( ) , getints ( ) ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , result ) ) NEW_LINE DEDENT", "functions_standalone": [["calc", "def calc ( a , b ) : NEW_LINE INDENT n , l , h = a NEW_LINE freq = b NEW_LINE for i in range ( l , h + 1 ) : NEW_LINE INDENT harmony = True NEW_LINE for f in freq : NEW_LINE INDENT if not ( f % i == 0 or i % f == 0 ) : NEW_LINE INDENT harmony = False NEW_LINE break NEW_LINE DEDENT DEDENT if harmony : NEW_LINE INDENT return \" % d \" % i NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT"], ["getints", "def getints ( ) : NEW_LINE INDENT return [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" \u2581 \" ) ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import math NEW_LINE inf = open ( \" in . txt \" , \" r \" ) NEW_LINE ouf = open ( ' out . txt ' , ' w ' ) NEW_LINE def close_files ( ) : NEW_LINE INDENT inf . close NEW_LINE ouf . close NEW_LINE DEDENT def precount ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT printcounter = 0 NEW_LINE def printstr ( a ) : NEW_LINE INDENT global printcounter NEW_LINE printcounter += 1 NEW_LINE print >> ouf , ' Case \u2581 # % d : \u2581 % s ' % ( printcounter , a ) NEW_LINE DEDENT def solvetest ( ) : NEW_LINE INDENT inp = inf . readline ( ) . split ( ) NEW_LINE [ n , l , h ] = map ( int , inp ) NEW_LINE inp = inf . readline ( ) . split ( ) NEW_LINE a = map ( int , inp ) NEW_LINE f = 0 NEW_LINE for i in xrange ( l , h + 1 ) : NEW_LINE INDENT bad = 0 NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT if ( i % a [ j ] == 0 ) or ( a [ j ] % i == 0 ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT bad = 1 NEW_LINE DEDENT DEDENT if not bad : NEW_LINE INDENT f = i NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT printstr ( str ( f ) ) NEW_LINE DEDENT else : NEW_LINE INDENT printstr ( ' NO ' ) NEW_LINE DEDENT DEDENT precount ( ) NEW_LINE testnum = int ( inf . readline ( ) ) NEW_LINE for test in xrange ( testnum ) : NEW_LINE INDENT solvetest ( ) NEW_LINE DEDENT close_files ( ) NEW_LINE", "functions_standalone": [["close_files", "def close_files ( ) : NEW_LINE INDENT inf . close NEW_LINE ouf . close NEW_LINE DEDENT"], ["precount", "def precount ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "import math NEW_LINE import sys NEW_LINE def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE sys . stderr . write ( \" , \" . join ( [ str ( x ) for x in st ] ) + \" \\n \" ) NEW_LINE DEDENT def generator ( N , l ) : NEW_LINE INDENT a = 0 NEW_LINE i = 0 NEW_LINE while a < N : NEW_LINE INDENT yield l [ i ] NEW_LINE i += 1 NEW_LINE if i == len ( l ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT DEDENT def simulate ( ) : NEW_LINE INDENT [ n , l , h ] = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE orchestra = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE notes = [ ] NEW_LINE for i in range ( l , h + 1 ) : NEW_LINE INDENT notes . append ( i ) NEW_LINE DEDENT for l in orchestra : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( notes ) : NEW_LINE INDENT if notes [ i ] % l == 0 or l % notes [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT notes . pop ( i ) NEW_LINE DEDENT DEDENT printe ( notes ) NEW_LINE DEDENT if len ( notes ) == 0 : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT else : NEW_LINE INDENT return notes [ 0 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i + 1 , simulate ( ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["printe", "def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE sys . stderr . write ( \" , \" . join ( [ str ( x ) for x in st ] ) + \" \\n \" ) NEW_LINE DEDENT"], ["generator", "def generator ( N , l ) : NEW_LINE INDENT a = 0 NEW_LINE i = 0 NEW_LINE while a < N : NEW_LINE INDENT yield l [ i ] NEW_LINE i += 1 NEW_LINE if i == len ( l ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT DEDENT"], ["simulate", "def simulate ( ) : NEW_LINE INDENT [ n , l , h ] = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE orchestra = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE notes = [ ] NEW_LINE for i in range ( l , h + 1 ) : NEW_LINE INDENT notes . append ( i ) NEW_LINE DEDENT for l in orchestra : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( notes ) : NEW_LINE INDENT if notes [ i ] % l == 0 or l % notes [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT notes . pop ( i ) NEW_LINE DEDENT DEDENT printe ( notes ) NEW_LINE DEDENT if len ( notes ) == 0 : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT else : NEW_LINE INDENT return notes [ 0 ] NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_11_11", "java": [{"id": "9", "code": "import java . util . Scanner ; import java . io . * ; import java . math . BigInteger ; public class A { public static void main ( String [ ] args ) throws Throwable { Scanner in = new Scanner ( new File ( \" in . txt \" ) ) ; PrintStream out = new PrintStream ( new File ( \" out . txt \" ) ) ; int t = in . nextInt ( ) ; in . nextLine ( ) ; for ( int c = 1 ; c <= t ; c ++ ) { out . print ( \" Case \u2581 # \" ) ; out . print ( c ) ; out . print ( \" : \u2581 \" ) ; out . println ( getSolution ( in ) ) ; } } private static String getSolution ( Scanner in ) { long n ; int pd , pg ; n = in . nextLong ( ) ; pd = in . nextInt ( ) ; pg = in . nextInt ( ) ; int factor = gcf ( 100 , pd ) ; if ( 100 / factor > n ) return \" Broken \" ; if ( ( pg == 100 && pd != 100 ) || ( pg == 0 && pd != 0 ) ) return \" Broken \" ; return \" Possible \" ; } public static int gcf ( int a , int b ) { int s ; if ( a > b ) s = b ; else s = a ; for ( int i = s ; i > 0 ; i -- ) { if ( ( a % i == 0 ) && ( b % i == 0 ) ) return i ; } return - 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { Scanner in = new Scanner ( new File ( \" in . txt \" ) ) ; PrintStream out = new PrintStream ( new File ( \" out . txt \" ) ) ; int t = in . nextInt ( ) ; in . nextLine ( ) ; for ( int c = 1 ; c <= t ; c ++ ) { out . print ( \" Case \u2581 # \" ) ; out . print ( c ) ; out . print ( \" : \u2581 \" ) ; out . println ( getSolution ( in ) ) ; } }"], ["getSolution", "private static String getSolution ( Scanner in ) { long n ; int pd , pg ; n = in . nextLong ( ) ; pd = in . nextInt ( ) ; pg = in . nextInt ( ) ; int factor = gcf ( 100 , pd ) ; if ( 100 / factor > n ) return \" Broken \" ; if ( ( pg == 100 && pd != 100 ) || ( pg == 0 && pd != 0 ) ) return \" Broken \" ; return \" Possible \" ; }"], ["gcf", "public static int gcf ( int a , int b ) { int s ; if ( a > b ) s = b ; else s = a ; for ( int i = s ; i > 0 ; i -- ) { if ( ( a % i == 0 ) && ( b % i == 0 ) ) return i ; } return - 1 ; }"]], "functions_class": []}, {"id": "20", "code": "package round1a ; import java . io . File ; import java . util . ArrayList ; import java . util . Scanner ; public class A { int caseNo ; double epsilon = 0.00000001 ; boolean equals ( double a , double b ) { return ( Math . abs ( a - b ) < epsilon ) ; } public void test ( Scanner in ) { long maxGamesToday = in . nextLong ( ) ; int rateToday = in . nextInt ( ) ; int rateTotal = in . nextInt ( ) ; boolean possible = true ; if ( maxGamesToday < 100 ) { boolean found = false ; if ( maxGamesToday >= 1 ) { found |= ( rateToday % 100 == 0 ) ; } if ( maxGamesToday >= 2 ) { found |= ( rateToday % 50 == 0 ) ; } if ( maxGamesToday >= 4 ) { found |= ( rateToday % 25 == 0 ) ; } if ( maxGamesToday >= 5 ) { found |= ( rateToday % 20 == 0 ) ; } if ( maxGamesToday >= 10 ) { found |= ( rateToday % 10 == 0 ) ; } if ( maxGamesToday >= 20 ) { found |= ( rateToday % 5 == 0 ) ; } if ( maxGamesToday >= 25 ) { found |= ( rateToday % 4 == 0 ) ; } if ( maxGamesToday >= 50 ) { found |= ( rateToday % 2 == 0 ) ; } possible = found ; } if ( possible ) { if ( rateTotal == 0 && rateToday != 0 ) possible = false ; if ( rateTotal == 100 && rateToday != 100 ) possible = false ; } if ( possible ) System . out . println ( \" Case \u2581 # \" + caseNo + \" : \u2581 Possible \" ) ; else System . out . println ( \" Case \u2581 # \" + caseNo + \" : \u2581 Broken \" ) ; } public static void main ( String [ ] args ) throws Exception { ( new A ( ) ) . test ( ) ; } public void test ( ) throws Exception { Scanner s = new Scanner ( new File ( \" A - large . in \" ) ) ; int numTests = s . nextInt ( ) ; for ( caseNo = 1 ; caseNo <= numTests ; caseNo ++ ) { test ( s ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new A ( ) ) . test ( ) ; }"]], "functions_class": [["equals", "boolean equals ( double a , double b ) { return ( Math . abs ( a - b ) < epsilon ) ; }"], ["test", "public void test ( Scanner in ) { long maxGamesToday = in . nextLong ( ) ; int rateToday = in . nextInt ( ) ; int rateTotal = in . nextInt ( ) ; boolean possible = true ; if ( maxGamesToday < 100 ) { boolean found = false ; if ( maxGamesToday >= 1 ) { found |= ( rateToday % 100 == 0 ) ; } if ( maxGamesToday >= 2 ) { found |= ( rateToday % 50 == 0 ) ; } if ( maxGamesToday >= 4 ) { found |= ( rateToday % 25 == 0 ) ; } if ( maxGamesToday >= 5 ) { found |= ( rateToday % 20 == 0 ) ; } if ( maxGamesToday >= 10 ) { found |= ( rateToday % 10 == 0 ) ; } if ( maxGamesToday >= 20 ) { found |= ( rateToday % 5 == 0 ) ; } if ( maxGamesToday >= 25 ) { found |= ( rateToday % 4 == 0 ) ; } if ( maxGamesToday >= 50 ) { found |= ( rateToday % 2 == 0 ) ; } possible = found ; } if ( possible ) { if ( rateTotal == 0 && rateToday != 0 ) possible = false ; if ( rateTotal == 100 && rateToday != 100 ) possible = false ; } if ( possible ) System . out . println ( \" Case \u2581 # \" + caseNo + \" : \u2581 Possible \" ) ; else System . out . println ( \" Case \u2581 # \" + caseNo + \" : \u2581 Broken \" ) ; }"], ["test", "public void test ( ) throws Exception { Scanner s = new Scanner ( new File ( \" A - large . in \" ) ) ; int numTests = s . nextInt ( ) ; for ( caseNo = 1 ; caseNo <= numTests ; caseNo ++ ) { test ( s ) ; } }"]]}, {"id": "17", "code": "package jam2011 ; import java . io . * ; import java . util . * ; public class AA { public static void main ( String [ ] args ) throws Exception { BufferedReader inputFile = new BufferedReader ( new InputStreamReader ( new FileInputStream ( args [ 0 ] ) ) ) ; int cases = Integer . parseInt ( inputFile . readLine ( ) ) ; PrintStream outFile = new PrintStream ( new FileOutputStream ( args [ 1 ] ) ) ; for ( int i = 1 ; i <= cases ; i ++ ) { String lineT [ ] = tokenize ( inputFile . readLine ( ) ) ; long n = Long . parseLong ( lineT [ 0 ] ) ; long pd = Long . parseLong ( lineT [ 1 ] ) ; long pg = Long . parseLong ( lineT [ 2 ] ) ; String out = null ; if ( pg == 0 ) out = pd == 0 ? \" Possible \" : \" Broken \" ; else if ( pg == 100 ) out = pd == 100 ? \" Possible \" : \" Broken \" ; else { if ( n >= 100 ) out = \" Possible \" ; else { int nnn = 100 ; while ( pd % 2 == 0 && nnn % 2 == 0 || pd % 5 == 0 && nnn % 5 == 0 ) { if ( pd % 2 == 0 && nnn % 2 == 0 ) { nnn /= 2 ; pd /= 2 ; } if ( pd % 5 == 0 && nnn % 5 == 0 ) { nnn /= 5 ; pd /= 5 ; } } out = nnn <= n ? \" Possible \" : \" Broken \" ; } } outFile . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + out ) ; } outFile . close ( ) ; inputFile . close ( ) ; } public static String [ ] tokenize ( String input ) { StringTokenizer st = new StringTokenizer ( input ) ; String [ ] k = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i < k . length ; i ++ ) k [ i ] = st . nextToken ( ) ; return k ; } public static String [ ] tokenize ( String input , String sep ) { StringTokenizer st = new StringTokenizer ( input , sep ) ; String [ ] k = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i < k . length ; i ++ ) k [ i ] = st . nextToken ( ) ; return k ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader inputFile = new BufferedReader ( new InputStreamReader ( new FileInputStream ( args [ 0 ] ) ) ) ; int cases = Integer . parseInt ( inputFile . readLine ( ) ) ; PrintStream outFile = new PrintStream ( new FileOutputStream ( args [ 1 ] ) ) ; for ( int i = 1 ; i <= cases ; i ++ ) { String lineT [ ] = tokenize ( inputFile . readLine ( ) ) ; long n = Long . parseLong ( lineT [ 0 ] ) ; long pd = Long . parseLong ( lineT [ 1 ] ) ; long pg = Long . parseLong ( lineT [ 2 ] ) ; String out = null ; if ( pg == 0 ) out = pd == 0 ? \" Possible \" : \" Broken \" ; else if ( pg == 100 ) out = pd == 100 ? \" Possible \" : \" Broken \" ; else { if ( n >= 100 ) out = \" Possible \" ; else { int nnn = 100 ; while ( pd % 2 == 0 && nnn % 2 == 0 || pd % 5 == 0 && nnn % 5 == 0 ) { if ( pd % 2 == 0 && nnn % 2 == 0 ) { nnn /= 2 ; pd /= 2 ; } if ( pd % 5 == 0 && nnn % 5 == 0 ) { nnn /= 5 ; pd /= 5 ; } } out = nnn <= n ? \" Possible \" : \" Broken \" ; } } outFile . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + out ) ; } outFile . close ( ) ; inputFile . close ( ) ; }"], ["tokenize", "public static String [ ] tokenize ( String input ) { StringTokenizer st = new StringTokenizer ( input ) ; String [ ] k = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i < k . length ; i ++ ) k [ i ] = st . nextToken ( ) ; return k ; }"], ["tokenize", "public static String [ ] tokenize ( String input , String sep ) { StringTokenizer st = new StringTokenizer ( input , sep ) ; String [ ] k = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i < k . length ; i ++ ) k [ i ] = st . nextToken ( ) ; return k ; }"]], "functions_class": []}, {"id": "3", "code": "import java . io . * ; import java . util . * ; import java . text . * ; public class A { public PrintStream out = System . out ; public PrintStream err = System . err ; public Scanner in = new Scanner ( System . in ) ; public DecimalFormat fmt = new DecimalFormat ( \"0.000000000\" ) ; public int p , q , n ; public void main ( ) { try { int TCase = in . nextInt ( ) ; for ( int cc = 1 ; cc <= TCase ; ++ cc ) { n = in . nextInt ( ) ; p = in . nextInt ( ) ; q = in . nextInt ( ) ; out . println ( \" Case \u2581 # \" + cc + \" : \u2581 \" + ( poss ( ) ? \" Possible \" : \" Broken \" ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } public boolean poss ( ) { for ( int D = 1 ; D <= n ; ++ D ) { if ( ( p * D ) % 100 != 0 ) continue ; int W = p * D / 100 ; int c = 100 * W - q * D ; for ( int DD = 0 ; DD <= 1000000 ; ++ DD ) { if ( ( q * DD - c ) % 100 != 0 ) continue ; int WW = ( q * DD - c ) / 100 ; if ( 0 <= WW && WW <= DD ) return true ; } } return false ; } public static void main ( String [ ] args ) { long startTime = System . currentTimeMillis ( ) ; ( new A ( ) ) . main ( ) ; long endTime = System . currentTimeMillis ( ) ; long ms = endTime - startTime ; long sec = ms / 1000 ; ms = ms % 1000 ; long min = sec / 60 ; sec = sec % 60 ; System . err . println ( \" Time \u2581 Spent : \u2581 \" + min + \" \u2581 minute ( s ) \u2581 \" + sec + \" \u2581 second ( s ) \u2581 \" + ms + \" \u2581 ( ms ) \" ) ; } public int iInt ( ) { return in . nextInt ( ) ; } public long iLong ( ) { return in . nextLong ( ) ; } public String iToken ( ) { return in . next ( ) ; } public String iLine ( ) { return in . nextLine ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { long startTime = System . currentTimeMillis ( ) ; ( new A ( ) ) . main ( ) ; long endTime = System . currentTimeMillis ( ) ; long ms = endTime - startTime ; long sec = ms / 1000 ; ms = ms % 1000 ; long min = sec / 60 ; sec = sec % 60 ; System . err . println ( \" Time \u2581 Spent : \u2581 \" + min + \" \u2581 minute ( s ) \u2581 \" + sec + \" \u2581 second ( s ) \u2581 \" + ms + \" \u2581 ( ms ) \" ) ; }"]], "functions_class": [["main", "public void main ( ) { try { int TCase = in . nextInt ( ) ; for ( int cc = 1 ; cc <= TCase ; ++ cc ) { n = in . nextInt ( ) ; p = in . nextInt ( ) ; q = in . nextInt ( ) ; out . println ( \" Case \u2581 # \" + cc + \" : \u2581 \" + ( poss ( ) ? \" Possible \" : \" Broken \" ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }"], ["poss", "public boolean poss ( ) { for ( int D = 1 ; D <= n ; ++ D ) { if ( ( p * D ) % 100 != 0 ) continue ; int W = p * D / 100 ; int c = 100 * W - q * D ; for ( int DD = 0 ; DD <= 1000000 ; ++ DD ) { if ( ( q * DD - c ) % 100 != 0 ) continue ; int WW = ( q * DD - c ) / 100 ; if ( 0 <= WW && WW <= DD ) return true ; } } return false ; }"], ["iInt", "public int iInt ( ) { return in . nextInt ( ) ; }"], ["iLong", "public long iLong ( ) { return in . nextLong ( ) ; }"], ["iToken", "public String iToken ( ) { return in . next ( ) ; }"], ["iLine", "public String iLine ( ) { return in . nextLine ( ) ; }"]]}, {"id": "16", "code": "package r1a ; import java . util . Scanner ; public class A { static long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static boolean solve ( long N , long PD , long PG ) { long dcoeff = 100 / gcd ( 100 , PD ) ; long gcoeff = 100 / gcd ( 100 , PG ) ; long dw = dcoeff * PD / 100 ; long gw = gcoeff * PG / 100 ; long dl = dcoeff - dw ; long gl = gcoeff - gw ; if ( gw == 0 && dw != 0 ) return false ; if ( gl == 0 && dl != 0 ) return false ; if ( dcoeff > N ) return false ; return true ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cn = 1 ; cn <= T ; ++ cn ) { long N = sc . nextLong ( ) ; int PD = sc . nextInt ( ) ; int PG = sc . nextInt ( ) ; if ( solve ( N , PD , PG ) ) { System . out . printf ( \" Case \u2581 # % d : \u2581 Possible \\n \" , cn ) ; } else { System . out . printf ( \" Case \u2581 # % d : \u2581 Broken \\n \" , cn ) ; } } } }", "functions_standalone": [["gcd", "static long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"], ["solve", "static boolean solve ( long N , long PD , long PG ) { long dcoeff = 100 / gcd ( 100 , PD ) ; long gcoeff = 100 / gcd ( 100 , PG ) ; long dw = dcoeff * PD / 100 ; long gw = gcoeff * PG / 100 ; long dl = dcoeff - dw ; long gl = gcoeff - gw ; if ( gw == 0 && dw != 0 ) return false ; if ( gl == 0 && dl != 0 ) return false ; if ( dcoeff > N ) return false ; return true ; }"], ["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cn = 1 ; cn <= T ; ++ cn ) { long N = sc . nextLong ( ) ; int PD = sc . nextInt ( ) ; int PG = sc . nextInt ( ) ; if ( solve ( N , PD , PG ) ) { System . out . printf ( \" Case \u2581 # % d : \u2581 Possible \\n \" , cn ) ; } else { System . out . printf ( \" Case \u2581 # % d : \u2581 Broken \\n \" , cn ) ; } } }"]], "functions_class": []}], "python": [{"id": "15", "code": "import sys , time NEW_LINE start_time = time . time ( ) NEW_LINE try : NEW_LINE INDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT inname = sys . argv [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT inname = input ( \" Enter \u2581 input \u2581 filename : \u2581 \" ) NEW_LINE DEDENT assert inname . endswith ( ' . in ' ) NEW_LINE outname = inname . replace ( ' . in ' , ' . out ' ) NEW_LINE with open ( inname ) as fin : NEW_LINE INDENT with open ( outname , ' w ' ) as fout : NEW_LINE INDENT num_cases = int ( fin . readline ( ) ) NEW_LINE for case_idx in range ( 1 , 1 + num_cases ) : NEW_LINE INDENT if time . time ( ) >= start_time + 5 : NEW_LINE INDENT print ( \" [ = = \u2581 Case \u2581 % d \u2581 of \u2581 % d \u2581 = = ] \" % ( case_idx , num_cases ) ) NEW_LINE DEDENT N , pD , pG = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE answer = True NEW_LINE N = min ( N , 100 ) NEW_LINE if pG == 100 and pD != 100 : answer = False NEW_LINE if pG == 0 and pD != 0 : answer = False NEW_LINE if all ( ( pD * D ) % 100 for D in range ( 1 , 1 + N ) ) : answer = False NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case_idx , ' Possible ' if answer else ' Broken ' ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT DEDENT except : NEW_LINE INDENT import traceback NEW_LINE print ( \" Exception \u2581 caught : \" , file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE traceback . print_exc ( file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE input ( \" Press \u2581 Enter \u2581 to \u2581 close \" ) NEW_LINE DEDENT else : NEW_LINE INDENT total_time = time . time ( ) - start_time NEW_LINE print ( \" Completed \u2581 in \u2581 % .1f \u2581 seconds \" % total_time , file = sys . stderr ) NEW_LINE time . sleep ( 3 ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "19", "code": "def simp ( n ) : NEW_LINE INDENT j = 100 NEW_LINE k = n NEW_LINE if n % 4 == 0 : NEW_LINE INDENT j = j / 4 NEW_LINE k = k / 4 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT j = j / 2 NEW_LINE k = k / 2 NEW_LINE DEDENT if n % 25 == 0 : NEW_LINE INDENT j = j / 25 NEW_LINE k = k / 25 NEW_LINE DEDENT elif n % 5 == 0 : NEW_LINE INDENT j = j / 5 NEW_LINE k = k / 5 NEW_LINE DEDENT return ( k , j ) NEW_LINE DEDENT def works ( maxD , pd , pg ) : NEW_LINE INDENT ( numd , dend ) = simp ( pd ) NEW_LINE ( numg , deng ) = simp ( pg ) NEW_LINE if dend > maxD : NEW_LINE INDENT return False NEW_LINE DEDENT if ( pg == 0 ) and ( pd != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( pg == 100 ) and ( pd != 100 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def run ( ) : NEW_LINE INDENT f = open ( \" input . in \" ) NEW_LINE g = open ( \" out . txt \" , ' w ' ) NEW_LINE num = int ( f . readline ( ) ) NEW_LINE for i in range ( num ) : NEW_LINE INDENT g . write ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) ) NEW_LINE [ maxD , pd , pg ] = map ( int , f . readline ( ) . split ( ) ) NEW_LINE if works ( maxD , pd , pg ) : NEW_LINE INDENT g . write ( \" Possible \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT g . write ( \" Broken \\n \" ) NEW_LINE DEDENT DEDENT f . close ( ) NEW_LINE g . close ( ) NEW_LINE DEDENT", "functions_standalone": [["simp", "def simp ( n ) : NEW_LINE INDENT j = 100 NEW_LINE k = n NEW_LINE if n % 4 == 0 : NEW_LINE INDENT j = j / 4 NEW_LINE k = k / 4 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT j = j / 2 NEW_LINE k = k / 2 NEW_LINE DEDENT if n % 25 == 0 : NEW_LINE INDENT j = j / 25 NEW_LINE k = k / 25 NEW_LINE DEDENT elif n % 5 == 0 : NEW_LINE INDENT j = j / 5 NEW_LINE k = k / 5 NEW_LINE DEDENT return ( k , j ) NEW_LINE DEDENT"], ["works", "def works ( maxD , pd , pg ) : NEW_LINE INDENT ( numd , dend ) = simp ( pd ) NEW_LINE ( numg , deng ) = simp ( pg ) NEW_LINE if dend > maxD : NEW_LINE INDENT return False NEW_LINE DEDENT if ( pg == 0 ) and ( pd != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( pg == 100 ) and ( pd != 100 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT"], ["run", "def run ( ) : NEW_LINE INDENT f = open ( \" input . in \" ) NEW_LINE g = open ( \" out . txt \" , ' w ' ) NEW_LINE num = int ( f . readline ( ) ) NEW_LINE for i in range ( num ) : NEW_LINE INDENT g . write ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) ) NEW_LINE [ maxD , pd , pg ] = map ( int , f . readline ( ) . split ( ) ) NEW_LINE if works ( maxD , pd , pg ) : NEW_LINE INDENT g . write ( \" Possible \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT g . write ( \" Broken \\n \" ) NEW_LINE DEDENT DEDENT f . close ( ) NEW_LINE g . close ( ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "inFile = open ( \" intpu1 . txt \" , \" r \" ) NEW_LINE outFile = open ( \" output1 . txt \" , \" w \" ) NEW_LINE def solve1 ( NN , Pd , Pg ) : NEW_LINE INDENT if Pd == 100 and Pg == 100 : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT if Pd == 0 and Pg == 0 : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT d = 1 NEW_LINE while d <= NN : NEW_LINE INDENT if ( d * Pd ) % 100 == 0 : NEW_LINE INDENT if Pg < 100 and Pg > 0 : NEW_LINE INDENT print ( NN , Pd , Pg ) NEW_LINE return \" Possible \" NEW_LINE break ; NEW_LINE DEDENT DEDENT d += 1 NEW_LINE DEDENT return \" Broken \" ; NEW_LINE DEDENT N = int ( inFile . readline ( ) ) NEW_LINE cnt = 0 NEW_LINE for line in inFile : NEW_LINE INDENT cnt += 1 NEW_LINE llLine = line . split ( ) NEW_LINE NN = int ( llLine [ 0 ] ) NEW_LINE Pd = int ( llLine [ 1 ] ) NEW_LINE Pg = int ( llLine [ 2 ] ) NEW_LINE result = solve1 ( NN , Pd , Pg ) NEW_LINE resStr = \" Case \u2581 # \" + str ( cnt ) + \" : \u2581 \" NEW_LINE resStr = resStr + result + \" \\n \" NEW_LINE print ( resStr ) NEW_LINE outFile . write ( resStr ) NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT while a : NEW_LINE INDENT a , b = b % a , a NEW_LINE DEDENT return b NEW_LINE DEDENT", "functions_standalone": [["solve1", "def solve1 ( NN , Pd , Pg ) : NEW_LINE INDENT if Pd == 100 and Pg == 100 : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT if Pd == 0 and Pg == 0 : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT d = 1 NEW_LINE while d <= NN : NEW_LINE INDENT if ( d * Pd ) % 100 == 0 : NEW_LINE INDENT if Pg < 100 and Pg > 0 : NEW_LINE INDENT print ( NN , Pd , Pg ) NEW_LINE return \" Possible \" NEW_LINE break ; NEW_LINE DEDENT DEDENT d += 1 NEW_LINE DEDENT return \" Broken \" ; NEW_LINE DEDENT"], ["gcd", "def gcd ( a , b ) : NEW_LINE INDENT while a : NEW_LINE INDENT a , b = b % a , a NEW_LINE DEDENT return b NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "from fractions import gcd NEW_LINE name = \" A - large \" NEW_LINE f_in = open ( name + ' . in ' , \" r \" ) NEW_LINE f_out = open ( name + ' . out ' , ' w ' ) NEW_LINE T = int ( f_in . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( i ) NEW_LINE N , Pd , Pg = [ int ( x ) for x in ( f_in . readline ( ) . split ( ) ) ] NEW_LINE if ( Pg == 100 and Pd != 100 ) : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Broken \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pg == 100 ) : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pg == 0 and Pd != 0 ) : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Broken \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pg == 0 ) : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pd == 0 ) : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pd == 100 ) : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = False NEW_LINE g1 = max ( 100 // gcd ( Pd , 100 ) , 100 // gcd ( 100 - Pd , 100 ) ) NEW_LINE print ( g1 , N ) NEW_LINE if ( g1 <= N ) : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT f_out . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( \" Broken \" ) + \" \\n \" ) NEW_LINE DEDENT DEDENT DEDENT f_in . close ( ) NEW_LINE f_out . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "from fractions import * NEW_LINE def yf ( x , y ) : NEW_LINE INDENT t = gcd ( x , y ) NEW_LINE return x / t , y / t NEW_LINE DEDENT def ok ( n , pd , pg ) : NEW_LINE INDENT w1 , d = yf ( pd , 100 ) NEW_LINE if d > n : NEW_LINE INDENT return False NEW_LINE DEDENT if pg == 100 : NEW_LINE INDENT return pd == 100 NEW_LINE DEDENT if pg == 0 : NEW_LINE INDENT return pd == 0 NEW_LINE DEDENT return True NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for tt in range ( 1 , T + 1 ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE n = int ( line [ 0 ] ) NEW_LINE pd = int ( line [ 1 ] ) NEW_LINE pg = int ( line [ 2 ] ) NEW_LINE if ok ( n , pd , pg ) : NEW_LINE INDENT res = \" Possible \" NEW_LINE DEDENT else : NEW_LINE INDENT res = \" Broken \" NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( tt , res ) ) NEW_LINE DEDENT", "functions_standalone": [["yf", "def yf ( x , y ) : NEW_LINE INDENT t = gcd ( x , y ) NEW_LINE return x / t , y / t NEW_LINE DEDENT"], ["ok", "def ok ( n , pd , pg ) : NEW_LINE INDENT w1 , d = yf ( pd , 100 ) NEW_LINE if d > n : NEW_LINE INDENT return False NEW_LINE DEDENT if pg == 100 : NEW_LINE INDENT return pd == 100 NEW_LINE DEDENT if pg == 0 : NEW_LINE INDENT return pd == 0 NEW_LINE DEDENT return True NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_11_43", "java": [{"id": "9", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class C { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new C ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; } private String solve ( Scanner in ) { long N = in . nextLong ( ) ; int m = 0 ; while ( 1l * m * m <= N ) m ++ ; boolean [ ] p = new boolean [ m ] ; Arrays . fill ( p , true ) ; int res = 0 ; for ( int x = 2 ; x < m ; x ++ ) { if ( p [ x ] ) { for ( int y = x + x ; y < m ; y += x ) { p [ y ] = false ; } int t = 0 ; long n = N ; while ( n >= x ) { n /= x ; t ++ ; } res += t - 1 ; } } if ( N > 1 ) res ++ ; return \" \" + res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new C ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private String solve ( Scanner in ) { long N = in . nextLong ( ) ; int m = 0 ; while ( 1l * m * m <= N ) m ++ ; boolean [ ] p = new boolean [ m ] ; Arrays . fill ( p , true ) ; int res = 0 ; for ( int x = 2 ; x < m ; x ++ ) { if ( p [ x ] ) { for ( int y = x + x ; y < m ; y += x ) { p [ y ] = false ; } int t = 0 ; long n = N ; while ( n >= x ) { n /= x ; t ++ ; } res += t - 1 ; } } if ( N > 1 ) res ++ ; return \" \" + res ; }"]]}, {"id": "18", "code": "import java . io . * ; import java . util . * ; public class SolC implements Runnable { public static void main ( String [ ] args ) { new Thread ( new SolC ( ) ) . start ( ) ; } BufferedReader br ; StringTokenizer st ; PrintWriter out ; boolean eof ; @ Override public void run ( ) { try { br = new BufferedReader ( new FileReader ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( FNAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } String FNAME = \" C - large \" ; void solve ( ) { int tests = nextInt ( ) ; int max = 1000001 ; boolean [ ] np = new boolean [ max ] ; np [ 0 ] = np [ 1 ] = true ; for ( int i = 2 ; i < max ; i ++ ) { if ( ! np [ i ] ) { int j = 2 * i ; while ( j < max ) { np [ j ] = true ; j += i ; } } } for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; long n = nextLong ( ) ; long ans = 0 ; if ( n > 1 ) { ans ++ ; } for ( long i = 2 ; i * i <= n ; i ++ ) { if ( np [ ( int ) i ] ) continue ; long j = i * i ; while ( j <= n ) { ans ++ ; j *= i ; } } out . println ( ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Thread ( new SolC ( ) ) . start ( ) ; }"]], "functions_class": [["run", "public void run ( ) { try { br = new BufferedReader ( new FileReader ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( FNAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"], ["nextToken", "String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["solve", "void solve ( ) { int tests = nextInt ( ) ; int max = 1000001 ; boolean [ ] np = new boolean [ max ] ; np [ 0 ] = np [ 1 ] = true ; for ( int i = 2 ; i < max ; i ++ ) { if ( ! np [ i ] ) { int j = 2 * i ; while ( j < max ) { np [ j ] = true ; j += i ; } } } for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; long n = nextLong ( ) ; long ans = 0 ; if ( n > 1 ) { ans ++ ; } for ( long i = 2 ; i * i <= n ; i ++ ) { if ( np [ ( int ) i ] ) continue ; long j = i * i ; while ( j <= n ) { ans ++ ; j *= i ; } } out . println ( ans ) ; } }"]]}, {"id": "1", "code": "import static java . lang . Math . * ; import static java . math . BigInteger . * ; import static java . util . Arrays . * ; import java . io . * ; import java . math . * ; import java . util . * ; public class C { Scanner sc = new Scanner ( System . in ) ; int M = 1000010 ; void solve ( ) { long N = sc . nextLong ( ) ; if ( N == 1 ) { System . out . println ( 0 ) ; return ; } boolean [ ] isPrime = new boolean [ M ] ; for ( int i = 3 ; i < M ; i += 2 ) isPrime [ i ] = true ; isPrime [ 2 ] = true ; for ( int i = 3 ; i * i < M ; i += 2 ) if ( isPrime [ i ] ) { for ( int j = i * i , k = i * 2 ; j < M ; j += k ) { isPrime [ j ] = false ; } } long res = 1 ; for ( long i = 2 ; i * i <= N ; i ++ ) if ( isPrime [ ( int ) i ] ) { int num = 2 ; long j = i * i ; while ( j * i <= N ) { j *= i ; num ++ ; } res += num - 1 ; } System . out . println ( res ) ; } void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( C . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new C ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( C . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new C ( ) . run ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { long N = sc . nextLong ( ) ; if ( N == 1 ) { System . out . println ( 0 ) ; return ; } boolean [ ] isPrime = new boolean [ M ] ; for ( int i = 3 ; i < M ; i += 2 ) isPrime [ i ] = true ; isPrime [ 2 ] = true ; for ( int i = 3 ; i * i < M ; i += 2 ) if ( isPrime [ i ] ) { for ( int j = i * i , k = i * 2 ; j < M ; j += k ) { isPrime [ j ] = false ; } } long res = 1 ; for ( long i = 2 ; i * i <= N ; i ++ ) if ( isPrime [ ( int ) i ] ) { int num = 2 ; long j = i * i ; while ( j * i <= N ) { j *= i ; num ++ ; } res += num - 1 ; } System . out . println ( res ) ; }"], ["run", "void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "16", "code": "import java . io . * ; import java . util . * ; public class ExpensiveDinner { void solve ( ) throws Exception { long n = nextLong ( ) ; if ( n == 1 ) { out . println ( 0 ) ; return ; } ArrayList < Long > primes = new ArrayList < Long > ( ) ; int sqrt = ( int ) Math . sqrt ( n ) + 10 ; boolean [ ] a = new boolean [ sqrt + 1 ] ; for ( int i = 2 ; i <= sqrt ; i ++ ) { if ( ! a [ i ] ) { primes . add ( ( long ) i ) ; for ( int j = 2 * i ; j <= sqrt ; j += i ) a [ j ] = true ; } } long ans1 = 0 ; long ans2 = 1 ; for ( long i : primes ) { if ( i > n ) break ; ans1 ++ ; long j = i ; while ( j <= n ) { ans2 ++ ; j *= i ; } } out . println ( ans2 - ans1 ) ; } void run ( ) { try { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int tests = nextInt ( ) ; for ( int i = 0 ; i < tests ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solve ( ) ; } out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } BufferedReader in ; StringTokenizer st ; PrintWriter out ; final String filename = new String ( \" ExpensiveDinner \" ) . toLowerCase ( ) ; String nextToken ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( in . readLine ( ) ) ; return st . nextToken ( ) ; } int nextInt ( ) throws Exception { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) throws Exception { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) throws Exception { return Double . parseDouble ( nextToken ( ) ) ; } public static void main ( String [ ] args ) { new ExpensiveDinner ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new ExpensiveDinner ( ) . run ( ) ; }"]], "functions_class": [["solve", "void solve ( ) throws Exception { long n = nextLong ( ) ; if ( n == 1 ) { out . println ( 0 ) ; return ; } ArrayList < Long > primes = new ArrayList < Long > ( ) ; int sqrt = ( int ) Math . sqrt ( n ) + 10 ; boolean [ ] a = new boolean [ sqrt + 1 ] ; for ( int i = 2 ; i <= sqrt ; i ++ ) { if ( ! a [ i ] ) { primes . add ( ( long ) i ) ; for ( int j = 2 * i ; j <= sqrt ; j += i ) a [ j ] = true ; } } long ans1 = 0 ; long ans2 = 1 ; for ( long i : primes ) { if ( i > n ) break ; ans1 ++ ; long j = i ; while ( j <= n ) { ans2 ++ ; j *= i ; } } out . println ( ans2 - ans1 ) ; }"], ["run", "void run ( ) { try { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int tests = nextInt ( ) ; for ( int i = 0 ; i < tests ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solve ( ) ; } out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }"], ["nextToken", "String nextToken ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( in . readLine ( ) ) ; return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws Exception { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws Exception { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws Exception { return Double . parseDouble ( nextToken ( ) ) ; }"]]}, {"id": "11", "code": "import java . io . * ; import java . util . * ; public class Bai3 { static int gcd ( int a , int b ) { while ( a != 0 && b != 0 ) if ( a > b ) a %= b ; else b %= a ; return a + b ; } public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" Clarge . out \" ) ) ; boolean [ ] isprime = new boolean [ 1000010 ] ; Arrays . fill ( isprime , true ) ; isprime [ 0 ] = isprime [ 1 ] = false ; int nprime = 0 ; for ( int i = 2 ; i < isprime . length ; ++ i ) if ( isprime [ i ] ) { ++ nprime ; for ( int j = i + i ; j < isprime . length ; j += i ) isprime [ j ] = false ; } int [ ] primelist = new int [ nprime ] ; nprime = 0 ; for ( int i = 2 ; i < isprime . length ; ++ i ) if ( isprime [ i ] ) primelist [ nprime ++ ] = i ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; ++ test ) { long n = sc . nextLong ( ) ; long res = 0 ; if ( n > 1 ) { res = 1 ; for ( int i = 0 ; i < nprime ; ++ i ) { long p = primelist [ i ] ; if ( p * p > n ) break ; long t = p ; while ( t * p <= n ) { t *= p ; ++ res ; } } } pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; pw . print ( res ) ; pw . println ( ) ; } pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["gcd", "static int gcd ( int a , int b ) { while ( a != 0 && b != 0 ) if ( a > b ) a %= b ; else b %= a ; return a + b ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" Clarge . out \" ) ) ; boolean [ ] isprime = new boolean [ 1000010 ] ; Arrays . fill ( isprime , true ) ; isprime [ 0 ] = isprime [ 1 ] = false ; int nprime = 0 ; for ( int i = 2 ; i < isprime . length ; ++ i ) if ( isprime [ i ] ) { ++ nprime ; for ( int j = i + i ; j < isprime . length ; j += i ) isprime [ j ] = false ; } int [ ] primelist = new int [ nprime ] ; nprime = 0 ; for ( int i = 2 ; i < isprime . length ; ++ i ) if ( isprime [ i ] ) primelist [ nprime ++ ] = i ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; ++ test ) { long n = sc . nextLong ( ) ; long res = 0 ; if ( n > 1 ) { res = 1 ; for ( int i = 0 ; i < nprime ; ++ i ) { long p = primelist [ i ] ; if ( p * p > n ) break ; long t = p ; while ( t * p <= n ) { t *= p ; ++ res ; } } } pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; pw . print ( res ) ; pw . println ( ) ; } pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "import sys NEW_LINE import fractions NEW_LINE infile = sys . stdin NEW_LINE def genprimes ( ) : NEW_LINE INDENT composites = { } NEW_LINE candidate = 2 NEW_LINE while True : NEW_LINE INDENT if candidate not in composites : NEW_LINE INDENT yield candidate NEW_LINE composites [ candidate * candidate ] = [ candidate ] NEW_LINE DEDENT else : NEW_LINE INDENT for p in composites [ candidate ] : NEW_LINE INDENT composites . setdefault ( p + candidate , [ ] ) . append ( p ) NEW_LINE DEDENT del composites [ candidate ] NEW_LINE DEDENT candidate += 1 NEW_LINE DEDENT DEDENT powers = set ( ) NEW_LINE pmax = 1e12 NEW_LINE for p in genprimes ( ) : NEW_LINE INDENT power = p * p NEW_LINE if power > pmax : break NEW_LINE while power < pmax : NEW_LINE INDENT powers . add ( power ) NEW_LINE power *= p NEW_LINE DEDENT DEDENT def get_spread ( N ) : NEW_LINE INDENT if N == 1 : return 0 NEW_LINE return 1 + sum ( 1 for p in powers if N >= p ) NEW_LINE DEDENT T = int ( infile . readline ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT N = int ( infile . readline ( ) ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \" % ( i + 1 , get_spread ( N ) ) ) NEW_LINE DEDENT", "functions_standalone": [["genprimes", "def genprimes ( ) : NEW_LINE INDENT composites = { } NEW_LINE candidate = 2 NEW_LINE while True : NEW_LINE INDENT if candidate not in composites : NEW_LINE INDENT yield candidate NEW_LINE composites [ candidate * candidate ] = [ candidate ] NEW_LINE DEDENT else : NEW_LINE INDENT for p in composites [ candidate ] : NEW_LINE INDENT composites . setdefault ( p + candidate , [ ] ) . append ( p ) NEW_LINE DEDENT del composites [ candidate ] NEW_LINE DEDENT candidate += 1 NEW_LINE DEDENT DEDENT"], ["get_spread", "def get_spread ( N ) : NEW_LINE INDENT if N == 1 : return 0 NEW_LINE return 1 + sum ( 1 for p in powers if N >= p ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT TASK = \" C \" NEW_LINE print ( \" Precalculation . . . \" ) NEW_LINE import math NEW_LINE def isprime ( num , primes ) : NEW_LINE INDENT s = math . sqrt ( num ) NEW_LINE for p in primes : NEW_LINE INDENT if p > s : NEW_LINE INDENT return True NEW_LINE DEDENT if num % p == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT primes = [ ] NEW_LINE for i in xrange ( 2 , 10 ** 6 + 1 ) : NEW_LINE INDENT if isprime ( i , primes ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT print ( \" Precalculation \u2581 done . \" ) NEW_LINE print ( \" Calculation . . . \" ) NEW_LINE with open ( TASK + \" . in \" ) as infile : NEW_LINE INDENT with open ( TASK + \" . out \" , mode = \" wt \" ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for ncase in range ( cases ) : NEW_LINE INDENT N = int ( infile . readline ( ) ) NEW_LINE s = math . sqrt ( N ) NEW_LINE ans = 0 NEW_LINE for p in primes : NEW_LINE INDENT if p > s : break NEW_LINE ans += int ( math . log ( N , p ) ) - 1 NEW_LINE DEDENT if N > 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT outfile . write ( \" Case \u2581 # { nc } : \u2581 { data } \\n \" . format ( nc = ncase + 1 , data = ans ) ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Calculation \u2581 done . \" ) NEW_LINE", "functions_standalone": [["memoized", "def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT"], ["isprime", "def isprime ( num , primes ) : NEW_LINE INDENT s = math . sqrt ( num ) NEW_LINE for p in primes : NEW_LINE INDENT if p > s : NEW_LINE INDENT return True NEW_LINE DEDENT if num % p == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "import sys NEW_LINE cache = { } NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n in cache : NEW_LINE INDENT return cache [ n ] NEW_LINE DEDENT cache [ n ] = kk ( n ) NEW_LINE return cache [ n ] NEW_LINE DEDENT def kk ( n ) : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT x = 3 NEW_LINE while x * x <= n : NEW_LINE INDENT if n % x == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT x += 2 NEW_LINE DEDENT return True NEW_LINE DEDENT def primes ( n ) : NEW_LINE INDENT res = [ 2 ] NEW_LINE i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT if is_prime ( i ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return res NEW_LINE DEDENT def foo ( ifile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for x in primes : NEW_LINE INDENT if x * x > n : NEW_LINE INDENT break NEW_LINE DEDENT t = x * x NEW_LINE while t <= n : NEW_LINE INDENT res += 1 NEW_LINE t *= x NEW_LINE DEDENT DEDENT return res + 1 NEW_LINE DEDENT primes = [ 2 ] NEW_LINE def create_primes ( ) : NEW_LINE INDENT x = 3 NEW_LINE while x * x <= 10 ** 12 : NEW_LINE INDENT if is_prime ( x ) : NEW_LINE INDENT primes . append ( x ) NEW_LINE DEDENT x += 2 NEW_LINE DEDENT DEDENT def main ( ifile , ofile ) : NEW_LINE INDENT create_primes ( ) NEW_LINE n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE DEDENT DEDENT main ( sys . stdin , sys . stdout ) NEW_LINE", "functions_standalone": [["is_prime", "def is_prime ( n ) : NEW_LINE INDENT if n in cache : NEW_LINE INDENT return cache [ n ] NEW_LINE DEDENT cache [ n ] = kk ( n ) NEW_LINE return cache [ n ] NEW_LINE DEDENT"], ["kk", "def kk ( n ) : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT x = 3 NEW_LINE while x * x <= n : NEW_LINE INDENT if n % x == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT x += 2 NEW_LINE DEDENT return True NEW_LINE DEDENT"], ["primes", "def primes ( n ) : NEW_LINE INDENT res = [ 2 ] NEW_LINE i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT if is_prime ( i ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return res NEW_LINE DEDENT"], ["foo", "def foo ( ifile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for x in primes : NEW_LINE INDENT if x * x > n : NEW_LINE INDENT break NEW_LINE DEDENT t = x * x NEW_LINE while t <= n : NEW_LINE INDENT res += 1 NEW_LINE t *= x NEW_LINE DEDENT DEDENT return res + 1 NEW_LINE DEDENT"], ["create_primes", "def create_primes ( ) : NEW_LINE INDENT x = 3 NEW_LINE while x * x <= 10 ** 12 : NEW_LINE INDENT if is_prime ( x ) : NEW_LINE INDENT primes . append ( x ) NEW_LINE DEDENT x += 2 NEW_LINE DEDENT DEDENT"], ["main", "def main ( ifile , ofile ) : NEW_LINE INDENT create_primes ( ) NEW_LINE n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "9", "code": "from math import * NEW_LINE def sieve ( n ) : NEW_LINE INDENT s = [ True ] * n NEW_LINE for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : NEW_LINE INDENT if s [ i ] : NEW_LINE INDENT s [ i * i : : 2 * i ] = [ False ] * ( ( n - i * i - 1 ) // ( 2 * i ) + 1 ) NEW_LINE DEDENT DEDENT return [ 2 ] + [ i for i in range ( 3 , n , 2 ) if s [ i ] ] NEW_LINE DEDENT with open ( ' input . in ' , ' r ' ) as fin : NEW_LINE INDENT with open ( ' output . txt ' , ' w ' ) as fout : NEW_LINE INDENT numcases = int ( fin . readline ( ) ) NEW_LINE primes = sieve ( 1000000 ) NEW_LINE for casenum in range ( 1 , numcases + 1 ) : NEW_LINE INDENT print ( casenum ) NEW_LINE numpeople = int ( fin . readline ( ) ) NEW_LINE spread = 0 NEW_LINE if numpeople > 1 : NEW_LINE INDENT spread = 1 NEW_LINE DEDENT for i in range ( len ( primes ) ) : NEW_LINE INDENT if ( primes [ i ] * primes [ i ] > numpeople ) : NEW_LINE INDENT break NEW_LINE DEDENT mult = primes [ i ] * primes [ i ] NEW_LINE while ( mult <= numpeople ) : NEW_LINE INDENT spread += 1 NEW_LINE mult *= primes [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT solnstr = str ( spread ) NEW_LINE fout . write ( \" Case \u2581 # \" + str ( casenum ) + \" : \u2581 \" + solnstr + ' \\n ' ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["sieve", "def sieve ( n ) : NEW_LINE INDENT s = [ True ] * n NEW_LINE for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : NEW_LINE INDENT if s [ i ] : NEW_LINE INDENT s [ i * i : : 2 * i ] = [ False ] * ( ( n - i * i - 1 ) // ( 2 * i ) + 1 ) NEW_LINE DEDENT DEDENT return [ 2 ] + [ i for i in range ( 3 , n , 2 ) if s [ i ] ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "14", "code": "def gcd ( a , b ) : NEW_LINE INDENT while b > 0 : NEW_LINE INDENT ( a , b ) = ( b , a % b ) NEW_LINE DEDENT return a NEW_LINE DEDENT def isprime ( n ) : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT i = 2 NEW_LINE while n % i != 0 and i ** 2 < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return n % i != 0 NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE for num in range ( 1 , N + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE P = 1 NEW_LINE Max = 1 NEW_LINE for a in range ( 2 , n + 1 ) : NEW_LINE INDENT if P % a != 0 : NEW_LINE INDENT nod = gcd ( a , P ) NEW_LINE nok = a * P // nod NEW_LINE Max += 1 NEW_LINE P = nok NEW_LINE DEDENT DEDENT Min = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if isprime ( i ) : NEW_LINE INDENT Min += 1 NEW_LINE DEDENT DEDENT if n == 1 : NEW_LINE INDENT Min = 1 NEW_LINE DEDENT print ( \" Case \u2581 # \" , num , \" : \u2581 \" , Max - Min , sep = ' ' ) NEW_LINE DEDENT", "functions_standalone": [["gcd", "def gcd ( a , b ) : NEW_LINE INDENT while b > 0 : NEW_LINE INDENT ( a , b ) = ( b , a % b ) NEW_LINE DEDENT return a NEW_LINE DEDENT"], ["isprime", "def isprime ( n ) : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT i = 2 NEW_LINE while n % i != 0 and i ** 2 < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return n % i != 0 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_11_31", "java": [{"id": "9", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . StringTokenizer ; public class SquareTiles { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int test = Integer . parseInt ( in . nextLine ( ) ) ; for ( int t = 1 ; t <= test ; t ++ ) { String nums = in . nextLine ( ) ; StringTokenizer st = new StringTokenizer ( nums ) ; int r = Integer . parseInt ( st . nextToken ( ) ) ; int c = Integer . parseInt ( st . nextToken ( ) ) ; char [ ] [ ] map = new char [ r ] [ c ] ; for ( int i = 0 ; i < r ; i ++ ) { String row = in . nextLine ( ) ; map [ i ] = row . toCharArray ( ) ; } for ( int i = 0 ; i < r - 1 ; i ++ ) { for ( int j = 0 ; j < c - 1 ; j ++ ) { if ( map [ i ] [ j ] == ' # ' && map [ i ] [ j + 1 ] == ' # ' && map [ i + 1 ] [ j ] == ' # ' && map [ i + 1 ] [ j + 1 ] == ' # ' ) { map [ i ] [ j ] = ' / ' ; map [ i + 1 ] [ j + 1 ] = ' / ' ; map [ i ] [ j + 1 ] = ' \\ \\' ; map [ i + 1 ] [ j ] = ' \\ \\' ; } } } boolean ok = true ; for ( int i = 0 ; i < r ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( map [ i ] [ j ] == ' # ' ) ok = false ; out . println ( \" Case \u2581 # \" + t + \" : \" ) ; if ( ! ok ) out . println ( \" Impossible \" ) ; else { for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) out . print ( map [ i ] [ j ] ) ; out . println ( ) ; } } } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int test = Integer . parseInt ( in . nextLine ( ) ) ; for ( int t = 1 ; t <= test ; t ++ ) { String nums = in . nextLine ( ) ; StringTokenizer st = new StringTokenizer ( nums ) ; int r = Integer . parseInt ( st . nextToken ( ) ) ; int c = Integer . parseInt ( st . nextToken ( ) ) ; char [ ] [ ] map = new char [ r ] [ c ] ; for ( int i = 0 ; i < r ; i ++ ) { String row = in . nextLine ( ) ; map [ i ] = row . toCharArray ( ) ; } for ( int i = 0 ; i < r - 1 ; i ++ ) { for ( int j = 0 ; j < c - 1 ; j ++ ) { if ( map [ i ] [ j ] == ' # ' && map [ i ] [ j + 1 ] == ' # ' && map [ i + 1 ] [ j ] == ' # ' && map [ i + 1 ] [ j + 1 ] == ' # ' ) { map [ i ] [ j ] = ' / ' ; map [ i + 1 ] [ j + 1 ] = ' / ' ; map [ i ] [ j + 1 ] = ' \\ \\' ; map [ i + 1 ] [ j ] = ' \\ \\' ; } } } boolean ok = true ; for ( int i = 0 ; i < r ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( map [ i ] [ j ] == ' # ' ) ok = false ; out . println ( \" Case \u2581 # \" + t + \" : \" ) ; if ( ! ok ) out . println ( \" Impossible \" ) ; else { for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) out . print ( map [ i ] [ j ] ) ; out . println ( ) ; } } } out . close ( ) ; }"]], "functions_class": []}, {"id": "6", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . * ; public class SquareTiles { public static void main ( String args [ ] ) throws FileNotFoundException { new SquareTiles ( ) ; } public SquareTiles ( ) throws FileNotFoundException { Scanner scanner = new Scanner ( System . in ) ; PrintWriter writer = new PrintWriter ( new File ( \" C : / res . txt \" ) ) ; int COUNT = scanner . nextInt ( ) ; for ( int y = 1 ; y <= COUNT ; y ++ ) { int N = scanner . nextInt ( ) , M = scanner . nextInt ( ) ; char matrix [ ] [ ] = new char [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { String t = scanner . next ( ) ; for ( int j = 0 ; j < M ; j ++ ) matrix [ i ] [ j ] = t . charAt ( j ) ; } boolean impossible = false ; loop : for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( matrix [ i ] [ j ] == ' # ' ) { if ( i < N - 1 && j < M - 1 && matrix [ i ] [ j ] == ' # ' && matrix [ i ] [ j + 1 ] == ' # ' && matrix [ i + 1 ] [ j ] == ' # ' && matrix [ i + 1 ] [ j + 1 ] == ' # ' ) { matrix [ i ] [ j ] = ' / ' ; matrix [ i ] [ j + 1 ] = ' \\ \\' ; matrix [ i + 1 ] [ j ] = ' \\ \\' ; matrix [ i + 1 ] [ j + 1 ] = ' / ' ; } else { impossible = true ; break loop ; } } } } writer . write ( String . format ( \" Case \u2581 # % d : \\n \" , y ) ) ; if ( impossible ) writer . write ( \" Impossible \\n \" ) ; else { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) writer . write ( matrix [ i ] [ j ] ) ; writer . write ( \" \\n \" ) ; } } } writer . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws FileNotFoundException { new SquareTiles ( ) ; }"]], "functions_class": [["SquareTiles", "public SquareTiles ( ) throws FileNotFoundException { Scanner scanner = new Scanner ( System . in ) ; PrintWriter writer = new PrintWriter ( new File ( \" C : / res . txt \" ) ) ; int COUNT = scanner . nextInt ( ) ; for ( int y = 1 ; y <= COUNT ; y ++ ) { int N = scanner . nextInt ( ) , M = scanner . nextInt ( ) ; char matrix [ ] [ ] = new char [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { String t = scanner . next ( ) ; for ( int j = 0 ; j < M ; j ++ ) matrix [ i ] [ j ] = t . charAt ( j ) ; } boolean impossible = false ; loop : for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( matrix [ i ] [ j ] == ' # ' ) { if ( i < N - 1 && j < M - 1 && matrix [ i ] [ j ] == ' # ' && matrix [ i ] [ j + 1 ] == ' # ' && matrix [ i + 1 ] [ j ] == ' # ' && matrix [ i + 1 ] [ j + 1 ] == ' # ' ) { matrix [ i ] [ j ] = ' / ' ; matrix [ i ] [ j + 1 ] = ' \\ \\' ; matrix [ i + 1 ] [ j ] = ' \\ \\' ; matrix [ i + 1 ] [ j + 1 ] = ' / ' ; } else { impossible = true ; break loop ; } } } } writer . write ( String . format ( \" Case \u2581 # % d : \\n \" , y ) ) ; if ( impossible ) writer . write ( \" Impossible \\n \" ) ; else { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) writer . write ( matrix [ i ] [ j ] ) ; writer . write ( \" \\n \" ) ; } } } writer . close ( ) ; }"]]}, {"id": "19", "code": "import java . util . Scanner ; public class Problem { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { char [ ] [ ] map = new char [ 55 ] [ 55 ] ; int R = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; for ( int j = 1 ; j <= R ; j ++ ) { String line = sc . next ( ) ; for ( int k = 1 ; k <= C ; k ++ ) { map [ j ] [ k ] = line . charAt ( k - 1 ) ; } } boolean possible = true ; for ( int j = 1 ; j <= R ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( map [ j ] [ k ] == ' # ' ) { map [ j ] [ k ] = ' / ' ; if ( map [ j ] [ k + 1 ] == ' # ' && map [ j + 1 ] [ k + 1 ] == ' # ' && map [ j + 1 ] [ k + 1 ] == ' # ' ) { map [ j ] [ k + 1 ] = ' \\ \\' ; map [ j + 1 ] [ k ] = ' \\ \\' ; map [ j + 1 ] [ k + 1 ] = ' / ' ; } else { possible = false ; } } } } if ( ! possible ) { System . out . format ( \" Case \u2581 # % d : \\n \" , i ) ; System . out . println ( \" Impossible \" ) ; } else { System . out . format ( \" Case \u2581 # % d : \\n \" , i ) ; for ( int j = 1 ; j <= R ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { System . out . print ( map [ j ] [ k ] ) ; } System . out . println ( ) ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { char [ ] [ ] map = new char [ 55 ] [ 55 ] ; int R = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; for ( int j = 1 ; j <= R ; j ++ ) { String line = sc . next ( ) ; for ( int k = 1 ; k <= C ; k ++ ) { map [ j ] [ k ] = line . charAt ( k - 1 ) ; } } boolean possible = true ; for ( int j = 1 ; j <= R ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( map [ j ] [ k ] == ' # ' ) { map [ j ] [ k ] = ' / ' ; if ( map [ j ] [ k + 1 ] == ' # ' && map [ j + 1 ] [ k + 1 ] == ' # ' && map [ j + 1 ] [ k + 1 ] == ' # ' ) { map [ j ] [ k + 1 ] = ' \\ \\' ; map [ j + 1 ] [ k ] = ' \\ \\' ; map [ j + 1 ] [ k + 1 ] = ' / ' ; } else { possible = false ; } } } } if ( ! possible ) { System . out . format ( \" Case \u2581 # % d : \\n \" , i ) ; System . out . println ( \" Impossible \" ) ; } else { System . out . format ( \" Case \u2581 # % d : \\n \" , i ) ; for ( int j = 1 ; j <= R ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { System . out . print ( map [ j ] [ k ] ) ; } System . out . println ( ) ; } } } }"]], "functions_class": []}, {"id": "0", "code": "import java . util . * ; import java . io . * ; public class Solution { public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int T = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { int R = sc . nextInt ( ) , C = sc . nextInt ( ) ; char [ ] [ ] data = new char [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) { data [ i ] = sc . next ( ) . toCharArray ( ) ; } boolean ok = true ; for ( int i = 0 ; i < R && ok ; i ++ ) for ( int j = 0 ; j < C && ok ; j ++ ) if ( data [ i ] [ j ] == ' # ' ) { if ( i + 1 < R && j + 1 < C && data [ i + 1 ] [ j ] == ' # ' && data [ i ] [ j + 1 ] == ' # ' && data [ i + 1 ] [ j + 1 ] == ' # ' ) { data [ i ] [ j ] = data [ i + 1 ] [ j + 1 ] = ' / ' ; data [ i + 1 ] [ j ] = data [ i ] [ j + 1 ] = ' \\ \\' ; } else ok = false ; } pw . println ( \" Case \u2581 # \" + caseNum + \" : \" ) ; if ( ok ) { for ( int i = 0 ; i < R ; i ++ ) pw . println ( new String ( data [ i ] ) ) ; } else pw . println ( \" Impossible \" ) ; } sc . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; }"]], "functions_class": [["doMain", "public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int T = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { int R = sc . nextInt ( ) , C = sc . nextInt ( ) ; char [ ] [ ] data = new char [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) { data [ i ] = sc . next ( ) . toCharArray ( ) ; } boolean ok = true ; for ( int i = 0 ; i < R && ok ; i ++ ) for ( int j = 0 ; j < C && ok ; j ++ ) if ( data [ i ] [ j ] == ' # ' ) { if ( i + 1 < R && j + 1 < C && data [ i + 1 ] [ j ] == ' # ' && data [ i ] [ j + 1 ] == ' # ' && data [ i + 1 ] [ j + 1 ] == ' # ' ) { data [ i ] [ j ] = data [ i + 1 ] [ j + 1 ] = ' / ' ; data [ i + 1 ] [ j ] = data [ i ] [ j + 1 ] = ' \\ \\' ; } else ok = false ; } pw . println ( \" Case \u2581 # \" + caseNum + \" : \" ) ; if ( ok ) { for ( int i = 0 ; i < R ; i ++ ) pw . println ( new String ( data [ i ] ) ) ; } else pw . println ( \" Impossible \" ) ; } sc . close ( ) ; pw . flush ( ) ; pw . close ( ) ; }"]]}, {"id": "14", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class R1CA { public static void main ( String [ ] args ) { try { new R1CA ( ) . solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new IllegalStateException ( ) ; } } private void solve ( ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" A - large . out \" ) ; int testCount = in . nextInt ( ) ; for ( int test = 1 ; test <= testCount ; ++ test ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; char [ ] [ ] a = new char [ n ] [ ] ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = in . next ( ) . toCharArray ( ) ; } for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = 0 ; j < m - 1 ; ++ j ) { if ( a [ i ] [ j ] == ' # ' && a [ i + 1 ] [ j ] == ' # ' && a [ i ] [ j + 1 ] == ' # ' && a [ i + 1 ] [ j + 1 ] == ' # ' ) { for ( int di = 0 ; di < 2 ; ++ di ) { for ( int dj = 0 ; dj < 2 ; ++ dj ) { a [ i + di ] [ j + dj ] = ( ( di + dj ) % 2 == 0 ) ? ' / ' : ' \\ \\' ; } } } } } boolean bad = false ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( a [ i ] [ j ] == ' # ' ) { bad = true ; } } } out . printf ( \" Case \u2581 # % d : \\n \" , test ) ; if ( bad ) { out . printf ( \" Impossible \\n \" ) ; } else { for ( int i = 0 ; i < n ; ++ i ) { out . println ( a [ i ] ) ; } } } out . flush ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { new R1CA ( ) . solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new IllegalStateException ( ) ; } }"]], "functions_class": [["solve", "private void solve ( ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" A - large . out \" ) ; int testCount = in . nextInt ( ) ; for ( int test = 1 ; test <= testCount ; ++ test ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; char [ ] [ ] a = new char [ n ] [ ] ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = in . next ( ) . toCharArray ( ) ; } for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = 0 ; j < m - 1 ; ++ j ) { if ( a [ i ] [ j ] == ' # ' && a [ i + 1 ] [ j ] == ' # ' && a [ i ] [ j + 1 ] == ' # ' && a [ i + 1 ] [ j + 1 ] == ' # ' ) { for ( int di = 0 ; di < 2 ; ++ di ) { for ( int dj = 0 ; dj < 2 ; ++ dj ) { a [ i + di ] [ j + dj ] = ( ( di + dj ) % 2 == 0 ) ? ' / ' : ' \\ \\' ; } } } } } boolean bad = false ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( a [ i ] [ j ] == ' # ' ) { bad = true ; } } } out . printf ( \" Case \u2581 # % d : \\n \" , test ) ; if ( bad ) { out . printf ( \" Impossible \\n \" ) ; } else { for ( int i = 0 ; i < n ; ++ i ) { out . println ( a [ i ] ) ; } } } out . flush ( ) ; }"]]}], "python": [{"id": "15", "code": "import math NEW_LINE import sys NEW_LINE def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE DEDENT def replace ( st , pos , char ) : NEW_LINE INDENT return st [ 0 : pos ] + char + st [ pos + 1 : ] NEW_LINE DEDENT def simulate ( ) : NEW_LINE INDENT [ r , c ] = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE t = [ ] NEW_LINE for b in range ( r ) : NEW_LINE INDENT t . append ( input ( ) ) NEW_LINE DEDENT printe ( t ) NEW_LINE for y in range ( r - 1 ) : NEW_LINE INDENT x = 0 NEW_LINE while ( x < c - 1 ) : NEW_LINE INDENT if t [ y ] [ x ] == ' # ' : NEW_LINE INDENT if t [ y ] [ x + 1 ] == ' # ' and t [ y + 1 ] [ x ] == ' # ' and t [ y + 1 ] [ x + 1 ] == ' # ' : NEW_LINE INDENT t [ y ] = replace ( t [ y ] , x , ' / ' ) NEW_LINE t [ y ] = replace ( t [ y ] , x + 1 , \" X \" ) NEW_LINE t [ y + 1 ] = replace ( t [ y + 1 ] , x , ' X ' ) NEW_LINE t [ y + 1 ] = replace ( t [ y + 1 ] , x + 1 , ' / ' ) NEW_LINE x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return \" Impossible \" NEW_LINE DEDENT DEDENT x += 1 NEW_LINE DEDENT DEDENT for y in range ( r ) : NEW_LINE INDENT if t [ y ] [ c - 1 ] == ' # ' : NEW_LINE INDENT return \" Impossible \" NEW_LINE DEDENT DEDENT for x in range ( c ) : NEW_LINE INDENT if t [ r - 1 ] [ x ] == ' # ' : NEW_LINE INDENT return \" Impossible \" NEW_LINE DEDENT DEDENT for y in range ( r ) : NEW_LINE INDENT t [ y ] = t [ y ] . replace ( \" X \" , \" \\ \\ \" ) NEW_LINE DEDENT return \" \\n \" . join ( t ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \\n { } \" . format ( i + 1 , simulate ( ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["printe", "def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE DEDENT"], ["replace", "def replace ( st , pos , char ) : NEW_LINE INDENT return st [ 0 : pos ] + char + st [ pos + 1 : ] NEW_LINE DEDENT"], ["simulate", "def simulate ( ) : NEW_LINE INDENT [ r , c ] = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE t = [ ] NEW_LINE for b in range ( r ) : NEW_LINE INDENT t . append ( input ( ) ) NEW_LINE DEDENT printe ( t ) NEW_LINE for y in range ( r - 1 ) : NEW_LINE INDENT x = 0 NEW_LINE while ( x < c - 1 ) : NEW_LINE INDENT if t [ y ] [ x ] == ' # ' : NEW_LINE INDENT if t [ y ] [ x + 1 ] == ' # ' and t [ y + 1 ] [ x ] == ' # ' and t [ y + 1 ] [ x + 1 ] == ' # ' : NEW_LINE INDENT t [ y ] = replace ( t [ y ] , x , ' / ' ) NEW_LINE t [ y ] = replace ( t [ y ] , x + 1 , \" X \" ) NEW_LINE t [ y + 1 ] = replace ( t [ y + 1 ] , x , ' X ' ) NEW_LINE t [ y + 1 ] = replace ( t [ y + 1 ] , x + 1 , ' / ' ) NEW_LINE x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return \" Impossible \" NEW_LINE DEDENT DEDENT x += 1 NEW_LINE DEDENT DEDENT for y in range ( r ) : NEW_LINE INDENT if t [ y ] [ c - 1 ] == ' # ' : NEW_LINE INDENT return \" Impossible \" NEW_LINE DEDENT DEDENT for x in range ( c ) : NEW_LINE INDENT if t [ r - 1 ] [ x ] == ' # ' : NEW_LINE INDENT return \" Impossible \" NEW_LINE DEDENT DEDENT for y in range ( r ) : NEW_LINE INDENT t [ y ] = t [ y ] . replace ( \" X \" , \" \\ \\ \" ) NEW_LINE DEDENT return \" \\n \" . join ( t ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "0", "code": "infile = open ( ' square _ tiles . in ' ) NEW_LINE outfile = open ( ' square _ tiles . out ' , ' w ' ) NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE def fill_spot ( i , j ) : NEW_LINE INDENT if i >= R - 1 or j >= C - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i2 in xrange ( i , i + 2 ) : NEW_LINE INDENT for j2 in xrange ( j , j + 2 ) : NEW_LINE INDENT if grid [ i2 ] [ j2 ] != ' # ' : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT grid [ i ] [ j ] = ' / ' NEW_LINE grid [ i ] [ j + 1 ] = ' \\ \\ ' NEW_LINE grid [ i + 1 ] [ j ] = ' \\ \\ ' NEW_LINE grid [ i + 1 ] [ j + 1 ] = ' / ' NEW_LINE return True NEW_LINE DEDENT def convert_to_red ( ) : NEW_LINE INDENT for i in xrange ( R ) : NEW_LINE INDENT for j in xrange ( C ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' # ' : NEW_LINE INDENT if not fill_spot ( i , j ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT for t in xrange ( T ) : NEW_LINE INDENT R , C = [ int ( s ) for s in infile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE grid = [ list ( infile . readline ( ) . strip ( ) ) for i in xrange ( R ) ] NEW_LINE outfile . write ( ' Case \u2581 # % d : \\n ' % ( t + 1 ) ) NEW_LINE if not convert_to_red ( ) : NEW_LINE INDENT outfile . write ( ' Impossible \\n ' ) NEW_LINE continue NEW_LINE DEDENT for i in xrange ( R ) : NEW_LINE INDENT outfile . write ( ' ' . join ( grid [ i ] ) + ' \\n ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "N = int ( input ( ) ) NEW_LINE for num in range ( 1 , N + 1 ) : NEW_LINE INDENT r , c = input ( ) . split ( ) NEW_LINE r = int ( r ) NEW_LINE c = int ( c ) NEW_LINE M = [ 0 ] * r NEW_LINE for i in range ( r ) : NEW_LINE INDENT M [ i ] = list ( input ( ) ) NEW_LINE DEDENT ans = True NEW_LINE for i in range ( r - 1 ) : NEW_LINE INDENT for j in range ( c - 1 ) : NEW_LINE INDENT if M [ i ] [ j ] == ' # ' : NEW_LINE INDENT if M [ i + 1 ] [ j ] == ' # ' and M [ i ] [ j + 1 ] == ' # ' and M [ i + 1 ] [ j + 1 ] == ' # ' : NEW_LINE INDENT M [ i ] [ j ] = ' / ' NEW_LINE M [ i ] [ j + 1 ] = ' \\ \\ ' NEW_LINE M [ i + 1 ] [ j ] = ' \\ \\ ' NEW_LINE M [ i + 1 ] [ j + 1 ] = ' / ' NEW_LINE DEDENT else : NEW_LINE INDENT ans = False NEW_LINE DEDENT DEDENT DEDENT if ' # ' in M [ i ] : NEW_LINE INDENT ans = False NEW_LINE DEDENT DEDENT if ' # ' in M [ - 1 ] : NEW_LINE INDENT ans = False NEW_LINE DEDENT print ( \" Case \u2581 # \" , num , \" : \" , sep = ' ' ) NEW_LINE if ans : NEW_LINE INDENT for i in range ( r ) : NEW_LINE INDENT print ( ' ' . join ( M [ i ] ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "import os NEW_LINE def process ( data , rf ) : NEW_LINE INDENT data = data . split ( \" \u2581 \" ) NEW_LINE rows = int ( data [ 0 ] ) NEW_LINE cols = int ( data [ 1 ] ) NEW_LINE picture = [ ] NEW_LINE for r in range ( rows ) : NEW_LINE INDENT data = rf . readline ( ) NEW_LINE data = data . replace ( ' # ' , '0' ) NEW_LINE data = data . strip ( ) NEW_LINE picture . append ( list ( data ) ) NEW_LINE DEDENT outstr = \" \" NEW_LINE for r in range ( rows ) : NEW_LINE INDENT outrow = \" \" NEW_LINE for c in range ( cols ) : NEW_LINE INDENT if ( picture [ r ] [ c ] == '0' ) : NEW_LINE INDENT try : NEW_LINE INDENT if ( ( picture [ r ] [ c + 1 ] == '0' ) and ( picture [ r + 1 ] [ c ] == '0' ) and ( picture [ r + 1 ] [ c + 1 ] == '0' ) ) : NEW_LINE INDENT picture [ r ] [ c ] = \" / \" NEW_LINE picture [ r ] [ c + 1 ] = \" \\ \\ \" NEW_LINE picture [ r + 1 ] [ c ] = \" \\ \\ \" NEW_LINE picture [ r + 1 ] [ c + 1 ] = \" / \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Impossible \\n \" NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT return \" Impossible \\n \" NEW_LINE DEDENT DEDENT outrow += picture [ r ] [ c ] NEW_LINE DEDENT outstr += outrow + \" \\n \" NEW_LINE DEDENT return outstr NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT rf = open ( os . path . join ( os . getcwd ( ) , \" A - large . in \" ) , \" r \" ) NEW_LINE wf = open ( os . path . join ( os . getcwd ( ) , \" output . txt \" ) , \" w \" ) NEW_LINE heading = True NEW_LINE test_num = 1 NEW_LINE while True : NEW_LINE INDENT line = rf . readline ( ) NEW_LINE line = line . strip ( ) NEW_LINE if not line : NEW_LINE INDENT rf . close ( ) NEW_LINE wf . close ( ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if ( heading ) : NEW_LINE INDENT heading = False NEW_LINE NUM_TEST_CASES = int ( line ) NEW_LINE DEDENT else : NEW_LINE INDENT wf . write ( \" Case \u2581 # \" + str ( test_num ) + \" : \\n \" + process ( line , rf ) ) NEW_LINE test_num += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT main ( ) NEW_LINE", "functions_standalone": [["process", "def process ( data , rf ) : NEW_LINE INDENT data = data . split ( \" \u2581 \" ) NEW_LINE rows = int ( data [ 0 ] ) NEW_LINE cols = int ( data [ 1 ] ) NEW_LINE picture = [ ] NEW_LINE for r in range ( rows ) : NEW_LINE INDENT data = rf . readline ( ) NEW_LINE data = data . replace ( ' # ' , '0' ) NEW_LINE data = data . strip ( ) NEW_LINE picture . append ( list ( data ) ) NEW_LINE DEDENT outstr = \" \" NEW_LINE for r in range ( rows ) : NEW_LINE INDENT outrow = \" \" NEW_LINE for c in range ( cols ) : NEW_LINE INDENT if ( picture [ r ] [ c ] == '0' ) : NEW_LINE INDENT try : NEW_LINE INDENT if ( ( picture [ r ] [ c + 1 ] == '0' ) and ( picture [ r + 1 ] [ c ] == '0' ) and ( picture [ r + 1 ] [ c + 1 ] == '0' ) ) : NEW_LINE INDENT picture [ r ] [ c ] = \" / \" NEW_LINE picture [ r ] [ c + 1 ] = \" \\ \\ \" NEW_LINE picture [ r + 1 ] [ c ] = \" \\ \\ \" NEW_LINE picture [ r + 1 ] [ c + 1 ] = \" / \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Impossible \\n \" NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT return \" Impossible \\n \" NEW_LINE DEDENT DEDENT outrow += picture [ r ] [ c ] NEW_LINE DEDENT outstr += outrow + \" \\n \" NEW_LINE DEDENT return outstr NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT rf = open ( os . path . join ( os . getcwd ( ) , \" A - large . in \" ) , \" r \" ) NEW_LINE wf = open ( os . path . join ( os . getcwd ( ) , \" output . txt \" ) , \" w \" ) NEW_LINE heading = True NEW_LINE test_num = 1 NEW_LINE while True : NEW_LINE INDENT line = rf . readline ( ) NEW_LINE line = line . strip ( ) NEW_LINE if not line : NEW_LINE INDENT rf . close ( ) NEW_LINE wf . close ( ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if ( heading ) : NEW_LINE INDENT heading = False NEW_LINE NUM_TEST_CASES = int ( line ) NEW_LINE DEDENT else : NEW_LINE INDENT wf . write ( \" Case \u2581 # \" + str ( test_num ) + \" : \\n \" + process ( line , rf ) ) NEW_LINE test_num += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "16", "code": "import math NEW_LINE inf = open ( \" in . txt \" , \" r \" ) NEW_LINE ouf = open ( ' out . txt ' , ' w ' ) NEW_LINE def close_files ( ) : NEW_LINE INDENT inf . close NEW_LINE ouf . close NEW_LINE DEDENT def precount ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT printcounter = 0 NEW_LINE def printstr ( a ) : NEW_LINE INDENT global printcounter NEW_LINE printcounter += 1 NEW_LINE print >> ouf , ' Case \u2581 # % d : \u2581 % s ' % ( printcounter , a ) NEW_LINE DEDENT def solvetest ( ) : NEW_LINE INDENT global printcounter NEW_LINE [ r , c ] = inf . readline ( ) . split ( ) NEW_LINE r , c = int ( r ) , int ( c ) NEW_LINE a = [ ] NEW_LINE for i in xrange ( r ) : NEW_LINE INDENT a . append ( list ( inf . readline ( ) . strip ( ) ) ) NEW_LINE DEDENT bad = 0 NEW_LINE for i in xrange ( r ) : NEW_LINE INDENT for j in xrange ( c ) : NEW_LINE INDENT if a [ i ] [ j ] == ' # ' : NEW_LINE INDENT if i == r - 1 or j == c - 1 : NEW_LINE INDENT bad = 1 NEW_LINE break NEW_LINE DEDENT if a [ i + 1 ] [ j ] != ' # ' or a [ i ] [ j + 1 ] != ' # ' or a [ i + 1 ] [ j + 1 ] != ' # ' : NEW_LINE INDENT bad = 1 NEW_LINE break NEW_LINE DEDENT a [ i ] [ j ] = ' / ' NEW_LINE a [ i + 1 ] [ j ] = ' \\ \\ ' NEW_LINE a [ i ] [ j + 1 ] = ' \\ \\ ' NEW_LINE a [ i + 1 ] [ j + 1 ] = ' / ' NEW_LINE DEDENT DEDENT if bad : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT printcounter += 1 NEW_LINE print >> ouf , ' Case \u2581 # % d : ' % ( printcounter ) NEW_LINE if bad : NEW_LINE INDENT print >> ouf , ' Impossible ' NEW_LINE DEDENT else : NEW_LINE INDENT for i in xrange ( r ) : NEW_LINE INDENT s = ' ' NEW_LINE for j in xrange ( c ) : NEW_LINE INDENT s = s + a [ i ] [ j ] NEW_LINE DEDENT print >> ouf , s NEW_LINE DEDENT DEDENT DEDENT precount ( ) NEW_LINE testnum = int ( inf . readline ( ) ) NEW_LINE for test in xrange ( testnum ) : NEW_LINE INDENT solvetest ( ) NEW_LINE DEDENT close_files ( ) NEW_LINE", "functions_standalone": [["close_files", "def close_files ( ) : NEW_LINE INDENT inf . close NEW_LINE ouf . close NEW_LINE DEDENT"], ["precount", "def precount ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_11_54", "java": [{"id": "15", "code": "import java . util . * ; import static java . lang . Math . * ; public class D { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { String S = in . next ( ) ; long v = 0 ; long nv = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { int at = S . length ( ) - i - 1 ; if ( S . charAt ( i ) == ' ? ' ) { nv |= 1L << at ; } else if ( S . charAt ( i ) == '1' ) { v |= 1L << at ; } } long ans = 0 ; for ( long c = nv ; ; c = ( c - 1 ) & nv ) { long test = v + c ; if ( issquare ( test ) ) { ans = test ; break ; } if ( c == 0 ) break ; } System . out . format ( \" Case \u2581 # % d : \u2581 % s \\n \" , zz , Long . toBinaryString ( ans ) ) ; } } private static boolean issquare ( long t ) { long low = 1 ; long high = Integer . MAX_VALUE ; while ( low <= high ) { long mid = ( low + high ) / 2 ; long v = mid * mid ; if ( v == t ) { return true ; } if ( v < t ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { String S = in . next ( ) ; long v = 0 ; long nv = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { int at = S . length ( ) - i - 1 ; if ( S . charAt ( i ) == ' ? ' ) { nv |= 1L << at ; } else if ( S . charAt ( i ) == '1' ) { v |= 1L << at ; } } long ans = 0 ; for ( long c = nv ; ; c = ( c - 1 ) & nv ) { long test = v + c ; if ( issquare ( test ) ) { ans = test ; break ; } if ( c == 0 ) break ; } System . out . format ( \" Case \u2581 # % d : \u2581 % s \\n \" , zz , Long . toBinaryString ( ans ) ) ; } }"], ["issquare", "private static boolean issquare ( long t ) { long low = 1 ; long high = Integer . MAX_VALUE ; while ( low <= high ) { long mid = ( low + high ) / 2 ; long v = mid * mid ; if ( v == t ) { return true ; } if ( v < t ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; }"]], "functions_class": []}, {"id": "3", "code": "import java . io . * ; import java . util . * ; public class D { private static String fileName = D . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) . toLowerCase ( ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; private static Scanner in ; private static PrintWriter out ; private void solve ( ) { String s = in . next ( ) ; int n = s . length ( ) ; int [ ] a = new int [ n ] ; int q = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case '0' : a [ i ] = 0 ; break ; case '1' : a [ i ] = 1 ; break ; case ' ? ' : a [ i ] = 2 ; q ++ ; break ; } } for ( int mask = 0 ; mask < ( 1 << q ) ; mask ++ ) { long v = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { int c = a [ i ] ; if ( c == 2 ) { c = ( mask >> j ) & 1 ; j ++ ; } v = 2 * v + c ; } long u = Math . round ( Math . sqrt ( v ) ) ; if ( u * u == v ) { out . println ( Long . toBinaryString ( v ) ) ; return ; } } throw new RuntimeException ( ) ; } public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new D ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new D ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( ) { String s = in . next ( ) ; int n = s . length ( ) ; int [ ] a = new int [ n ] ; int q = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case '0' : a [ i ] = 0 ; break ; case '1' : a [ i ] = 1 ; break ; case ' ? ' : a [ i ] = 2 ; q ++ ; break ; } } for ( int mask = 0 ; mask < ( 1 << q ) ; mask ++ ) { long v = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { int c = a [ i ] ; if ( c == 2 ) { c = ( mask >> j ) & 1 ; j ++ ; } v = 2 * v + c ; } long u = Math . round ( Math . sqrt ( v ) ) ; if ( u * u == v ) { out . println ( Long . toBinaryString ( v ) ) ; return ; } } throw new RuntimeException ( ) ; }"]]}, {"id": "16", "code": "import static java . lang . Math . * ; import static java . util . Arrays . * ; import java . io . * ; import java . util . * ; public class D { Scanner sc = new Scanner ( System . in ) ; void solve ( ) { char [ ] cs = sc . next ( ) . toCharArray ( ) ; int m = 0 ; for ( char c : cs ) if ( c == ' ? ' ) m ++ ; for ( int i = 0 ; i < 1 << m ; i ++ ) { char [ ] ds = cs . clone ( ) ; int p = 0 ; for ( int j = 0 ; j < cs . length ; j ++ ) if ( cs [ j ] == ' ? ' ) { ds [ j ] = ( char ) ( '0' + ( i >> p & 1 ) ) ; p ++ ; } long v = 0 ; for ( char c : ds ) v = v * 2 + c - '0' ; long a = ( long ) sqrt ( v ) ; while ( a * a < v ) a ++ ; while ( a * a > v ) a -- ; if ( a * a == v ) { System . out . println ( Long . toBinaryString ( v ) ) ; return ; } } } void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( D . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new D ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( D . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new D ( ) . run ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { char [ ] cs = sc . next ( ) . toCharArray ( ) ; int m = 0 ; for ( char c : cs ) if ( c == ' ? ' ) m ++ ; for ( int i = 0 ; i < 1 << m ; i ++ ) { char [ ] ds = cs . clone ( ) ; int p = 0 ; for ( int j = 0 ; j < cs . length ; j ++ ) if ( cs [ j ] == ' ? ' ) { ds [ j ] = ( char ) ( '0' + ( i >> p & 1 ) ) ; p ++ ; } long v = 0 ; for ( char c : ds ) v = v * 2 + c - '0' ; long a = ( long ) sqrt ( v ) ; while ( a * a < v ) a ++ ; while ( a * a > v ) a -- ; if ( a * a == v ) { System . out . println ( Long . toBinaryString ( v ) ) ; return ; } } }"], ["run", "void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "8", "code": "package round3 ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class D { static long [ ] stepeni = new long [ 62 ] ; static { stepeni [ 0 ] = 1 ; for ( int i = 1 ; i < stepeni . length ; i ++ ) stepeni [ i ] = 2 * stepeni [ i - 1 ] ; } static boolean jePotpunKvadrat ( long a ) { long koren = Math . round ( Math . sqrt ( a ) ) ; return koren * koren == a ; } static long resi ( String s , long value , int position ) { if ( jePotpunKvadrat ( value ) ) return value ; if ( position == s . length ( ) ) return - 1 ; if ( s . charAt ( position ) == ' ? ' ) { long res = resi ( s , value , position + 1 ) ; if ( res != - 1 ) return res ; return resi ( s , value + stepeni [ s . length ( ) - position - 1 ] , position + 1 ) ; } else return resi ( s , value , position + 1 ) ; } public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" D . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" D . out \" ) ) ; int tt = in . nextInt ( ) ; for ( int ttt = 1 ; ttt <= tt ; ttt ++ ) { String s = in . next ( ) ; long min = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( s . length ( ) - i - 1 ) == '1' ) min += stepeni [ i ] ; long res = resi ( s , min , 0 ) ; out . printf ( \" Case \u2581 # % d : \u2581 % s \" , ttt , Long . toBinaryString ( res ) ) ; out . println ( ) ; } out . flush ( ) ; out . close ( ) ; in . close ( ) ; } }", "functions_standalone": [["jePotpunKvadrat", "static boolean jePotpunKvadrat ( long a ) { long koren = Math . round ( Math . sqrt ( a ) ) ; return koren * koren == a ; }"], ["resi", "static long resi ( String s , long value , int position ) { if ( jePotpunKvadrat ( value ) ) return value ; if ( position == s . length ( ) ) return - 1 ; if ( s . charAt ( position ) == ' ? ' ) { long res = resi ( s , value , position + 1 ) ; if ( res != - 1 ) return res ; return resi ( s , value + stepeni [ s . length ( ) - position - 1 ] , position + 1 ) ; } else return resi ( s , value , position + 1 ) ; }"], ["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" D . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" D . out \" ) ) ; int tt = in . nextInt ( ) ; for ( int ttt = 1 ; ttt <= tt ; ttt ++ ) { String s = in . next ( ) ; long min = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( s . length ( ) - i - 1 ) == '1' ) min += stepeni [ i ] ; long res = resi ( s , min , 0 ) ; out . printf ( \" Case \u2581 # % d : \u2581 % s \" , ttt , Long . toBinaryString ( res ) ) ; out . println ( ) ; } out . flush ( ) ; out . close ( ) ; in . close ( ) ; }"]], "functions_class": []}, {"id": "20", "code": "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class Main { public StringBuffer s ; public boolean ok ; public String ans ; public void rec ( ) { if ( ok ) return ; int pos = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == ' ? ' ) { pos = i ; break ; } if ( pos == - 1 ) { BigInteger b = BigInteger . ZERO ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == '1' ) b = b . add ( BigInteger . ONE . shiftLeft ( s . length ( ) - 1 - i ) ) ; BigInteger l = BigInteger . ONE , r = BigInteger . TEN . pow ( 25 ) ; while ( l . compareTo ( r ) != 0 ) { BigInteger x = l . add ( r ) . shiftRight ( 1 ) ; BigInteger xx = x . multiply ( x ) ; if ( xx . compareTo ( b ) >= 0 ) r = x ; else l = x . add ( BigInteger . ONE ) ; } BigInteger test = l . multiply ( l ) ; if ( test . compareTo ( b ) == 0 ) { ok = true ; ans = test . toString ( 2 ) ; } } else { s . setCharAt ( pos , '0' ) ; rec ( ) ; s . setCharAt ( pos , '1' ) ; rec ( ) ; s . setCharAt ( pos , ' ? ' ) ; } } public void run ( ) throws IOException { Scanner in = new Scanner ( new File ( \" D . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" D . out \" ) ) ; int T = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; String ss = in . nextLine ( ) ; s = new StringBuffer ( ss ) ; ok = false ; rec ( ) ; out . println ( ans ) ; out . flush ( ) ; } } public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; }"]], "functions_class": [["rec", "public void rec ( ) { if ( ok ) return ; int pos = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == ' ? ' ) { pos = i ; break ; } if ( pos == - 1 ) { BigInteger b = BigInteger . ZERO ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == '1' ) b = b . add ( BigInteger . ONE . shiftLeft ( s . length ( ) - 1 - i ) ) ; BigInteger l = BigInteger . ONE , r = BigInteger . TEN . pow ( 25 ) ; while ( l . compareTo ( r ) != 0 ) { BigInteger x = l . add ( r ) . shiftRight ( 1 ) ; BigInteger xx = x . multiply ( x ) ; if ( xx . compareTo ( b ) >= 0 ) r = x ; else l = x . add ( BigInteger . ONE ) ; } BigInteger test = l . multiply ( l ) ; if ( test . compareTo ( b ) == 0 ) { ok = true ; ans = test . toString ( 2 ) ; } } else { s . setCharAt ( pos , '0' ) ; rec ( ) ; s . setCharAt ( pos , '1' ) ; rec ( ) ; s . setCharAt ( pos , ' ? ' ) ; } }"], ["run", "public void run ( ) throws IOException { Scanner in = new Scanner ( new File ( \" D . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" D . out \" ) ) ; int T = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; String ss = in . nextLine ( ) ; s = new StringBuffer ( ss ) ; ok = false ; rec ( ) ; out . println ( ans ) ; out . flush ( ) ; } }"]]}], "python": [{"id": "5", "code": "import sys , collections NEW_LINE infile = sys . stdin NEW_LINE def find_square ( S ) : NEW_LINE INDENT qpos = [ i for i , ch in enumerate ( S ) if ch == ' ? ' ] NEW_LINE ns = len ( S ) NEW_LINE nq = len ( qpos ) NEW_LINE baseval = int ( S . replace ( ' ? ' , '0' ) , 2 ) NEW_LINE for i in xrange ( 1 << len ( qpos ) ) : NEW_LINE INDENT val = baseval NEW_LINE for j in xrange ( nq ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT p = 1 << ( ns - qpos [ j ] - 1 ) NEW_LINE val += p NEW_LINE DEDENT DEDENT r = int ( val ** 0.5 ) NEW_LINE if ( r * r == val ) : NEW_LINE INDENT return bin ( val ) [ 2 : ] NEW_LINE DEDENT DEDENT DEDENT T = int ( infile . readline ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT S = infile . readline ( ) . strip ( ) NEW_LINE result = find_square ( S ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , result ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE def foo2 ( word , idx , n ) : NEW_LINE INDENT word = word [ : ] NEW_LINE for i in range ( len ( idx ) ) : NEW_LINE INDENT word [ idx [ i ] ] = n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT res = 0 NEW_LINE for x in word : NEW_LINE INDENT res = res * 2 + x NEW_LINE DEDENT t = int ( res ** 0.5 ) NEW_LINE if t * t == res : NEW_LINE INDENT return ' ' . join ( str ( x ) for x in word ) NEW_LINE DEDENT DEDENT def foo ( ifile ) : NEW_LINE INDENT word = list ( ifile . readline ( ) . strip ( ) ) NEW_LINE idx = [ ] NEW_LINE n = 0 NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT if word [ i ] == ' ? ' : NEW_LINE INDENT idx . append ( i ) NEW_LINE word [ i ] = None NEW_LINE DEDENT else : NEW_LINE INDENT word [ i ] = int ( word [ i ] ) NEW_LINE DEDENT DEDENT n = len ( idx ) NEW_LINE if n == 0 : NEW_LINE INDENT return ' ' . join ( str ( x ) for x in word ) NEW_LINE DEDENT for i in range ( 2 ** n ) : NEW_LINE INDENT t = foo2 ( word , idx , i ) NEW_LINE if t is not None : NEW_LINE INDENT return t NEW_LINE DEDENT DEDENT DEDENT def main ( ifile , ofile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE ofile . flush ( ) NEW_LINE DEDENT DEDENT main ( sys . stdin , sys . stdout ) NEW_LINE", "functions_standalone": [["foo2", "def foo2 ( word , idx , n ) : NEW_LINE INDENT word = word [ : ] NEW_LINE for i in range ( len ( idx ) ) : NEW_LINE INDENT word [ idx [ i ] ] = n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT res = 0 NEW_LINE for x in word : NEW_LINE INDENT res = res * 2 + x NEW_LINE DEDENT t = int ( res ** 0.5 ) NEW_LINE if t * t == res : NEW_LINE INDENT return ' ' . join ( str ( x ) for x in word ) NEW_LINE DEDENT DEDENT"], ["foo", "def foo ( ifile ) : NEW_LINE INDENT word = list ( ifile . readline ( ) . strip ( ) ) NEW_LINE idx = [ ] NEW_LINE n = 0 NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT if word [ i ] == ' ? ' : NEW_LINE INDENT idx . append ( i ) NEW_LINE word [ i ] = None NEW_LINE DEDENT else : NEW_LINE INDENT word [ i ] = int ( word [ i ] ) NEW_LINE DEDENT DEDENT n = len ( idx ) NEW_LINE if n == 0 : NEW_LINE INDENT return ' ' . join ( str ( x ) for x in word ) NEW_LINE DEDENT for i in range ( 2 ** n ) : NEW_LINE INDENT t = foo2 ( word , idx , i ) NEW_LINE if t is not None : NEW_LINE INDENT return t NEW_LINE DEDENT DEDENT DEDENT"], ["main", "def main ( ifile , ofile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE ofile . flush ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_11_01", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class BotTrust { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output \" ) ) ; for ( int I = 1 ; I <= T ; I ++ ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \\n \\ t \" , false ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int Opos = 1 , Bpos = 1 ; int Oextra = 0 , Bextra = 0 ; int ret = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int nextBot = ( st . nextToken ( ) . equals ( \" O \" ) ? 0 : 1 ) ; int button = Integer . parseInt ( st . nextToken ( ) ) ; if ( nextBot == 0 ) { int dist = Math . abs ( Opos - button ) ; if ( Oextra >= dist ) dist = 0 ; else dist -= Oextra ; ret += dist + 1 ; Bextra += dist + 1 ; Oextra = 0 ; Opos = button ; } else { int dist = Math . abs ( Bpos - button ) ; if ( Bextra >= dist ) dist = 0 ; else dist -= Bextra ; ret += dist + 1 ; Oextra += dist + 1 ; Bextra = 0 ; Bpos = button ; } } pw . println ( \" Case \u2581 # \" + I + \" : \u2581 \" + ret ) ; } br . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } catch ( IOException ie ) { ie . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output \" ) ) ; for ( int I = 1 ; I <= T ; I ++ ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \\n \\ t \" , false ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int Opos = 1 , Bpos = 1 ; int Oextra = 0 , Bextra = 0 ; int ret = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int nextBot = ( st . nextToken ( ) . equals ( \" O \" ) ? 0 : 1 ) ; int button = Integer . parseInt ( st . nextToken ( ) ) ; if ( nextBot == 0 ) { int dist = Math . abs ( Opos - button ) ; if ( Oextra >= dist ) dist = 0 ; else dist -= Oextra ; ret += dist + 1 ; Bextra += dist + 1 ; Oextra = 0 ; Opos = button ; } else { int dist = Math . abs ( Bpos - button ) ; if ( Bextra >= dist ) dist = 0 ; else dist -= Bextra ; ret += dist + 1 ; Oextra += dist + 1 ; Bextra = 0 ; Bpos = button ; } } pw . println ( \" Case \u2581 # \" + I + \" : \u2581 \" + ret ) ; } br . close ( ) ; pw . flush ( ) ; pw . close ( ) ; } catch ( IOException ie ) { ie . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "19", "code": "import java . util . Scanner ; public class bottrust { public static void main ( String [ ] args ) { Scanner ins = new Scanner ( System . in ) ; int cc ; int ntc = ins . nextInt ( ) ; for ( cc = 1 ; cc <= ntc ; cc ++ ) { int pos [ ] = { 1 , 1 } , time [ ] = { 0 , 0 } ; int cnt = ins . nextInt ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { String s = ins . next ( ) ; int r = 0 ; if ( s . equals ( \" B \" ) ) r = 1 ; int p = ins . nextInt ( ) ; int mtime = p - pos [ r ] ; if ( mtime < 0 ) mtime = - mtime ; mtime += time [ r ] + 1 ; if ( mtime <= time [ 1 - r ] ) mtime = time [ 1 - r ] + 1 ; time [ r ] = mtime ; pos [ r ] = p ; } int maxtime = time [ 0 ] ; if ( time [ 1 ] > maxtime ) maxtime = time [ 1 ] ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , cc , maxtime ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner ins = new Scanner ( System . in ) ; int cc ; int ntc = ins . nextInt ( ) ; for ( cc = 1 ; cc <= ntc ; cc ++ ) { int pos [ ] = { 1 , 1 } , time [ ] = { 0 , 0 } ; int cnt = ins . nextInt ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { String s = ins . next ( ) ; int r = 0 ; if ( s . equals ( \" B \" ) ) r = 1 ; int p = ins . nextInt ( ) ; int mtime = p - pos [ r ] ; if ( mtime < 0 ) mtime = - mtime ; mtime += time [ r ] + 1 ; if ( mtime <= time [ 1 - r ] ) mtime = time [ 1 - r ] + 1 ; time [ r ] = mtime ; pos [ r ] = p ; } int maxtime = time [ 0 ] ; if ( time [ 1 ] > maxtime ) maxtime = time [ 1 ] ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , cc , maxtime ) ; } }"]], "functions_class": []}, {"id": "14", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . Iterator ; public class InputFileParser implements Iterable < String [ ] > { private final int linesPerCase ; private final int totalCases ; private BufferedReader reader ; private int casesExtracted = 0 ; public InputFileParser ( int linesPerCase , String fileName ) { this . linesPerCase = linesPerCase ; try { FileReader fileReader = new FileReader ( fileName ) ; this . reader = new BufferedReader ( fileReader ) ; String line = this . reader . readLine ( ) ; this . totalCases = Integer . parseInt ( line ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } private String readLine ( ) { try { return this . reader . readLine ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } @ Override public Iterator < String [ ] > iterator ( ) { return new Iterator < String [ ] > ( ) { @ Override public boolean hasNext ( ) { return casesExtracted < totalCases ; } @ Override public String [ ] next ( ) { String [ ] caseLines = new String [ linesPerCase ] ; for ( int i = 0 ; i < linesPerCase ; i ++ ) { caseLines [ i ] = readLine ( ) ; } casesExtracted ++ ; return caseLines ; } @ Override public void remove ( ) { } } ; } }", "functions_standalone": [], "functions_class": [["InputFileParser", "public InputFileParser ( int linesPerCase , String fileName ) { this . linesPerCase = linesPerCase ; try { FileReader fileReader = new FileReader ( fileName ) ; this . reader = new BufferedReader ( fileReader ) ; String line = this . reader . readLine ( ) ; this . totalCases = Integer . parseInt ( line ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }"], ["readLine", "private String readLine ( ) { try { return this . reader . readLine ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }"], ["iterator", "public Iterator < String [ ] > iterator ( ) { return new Iterator < String [ ] > ( ) { @ Override public boolean hasNext ( ) { return casesExtracted < totalCases ; } @ Override public String [ ] next ( ) { String [ ] caseLines = new String [ linesPerCase ] ; for ( int i = 0 ; i < linesPerCase ; i ++ ) { caseLines [ i ] = readLine ( ) ; } casesExtracted ++ ; return caseLines ; } @ Override public void remove ( ) { } } ; }"]]}, {"id": "2", "code": "import java . io . * ; import java . util . * ; import java . util . regex . Pattern ; public class GCJ2011QualA { void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= T ; testCase ++ ) { int N = sc . nextInt ( ) ; int oT = 0 , bT = 0 ; int oP = 1 , bP = 1 ; for ( int i = 0 ; i < N ; i ++ ) { char [ ] c = sc . next ( ) . toCharArray ( ) ; int pos = sc . nextInt ( ) ; if ( c [ 0 ] == ' O ' ) { oT = Math . max ( oT + Math . abs ( pos - oP ) , bT ) + 1 ; oP = pos ; } else { bT = Math . max ( bT + Math . abs ( pos - bP ) , oT ) + 1 ; bP = pos ; } } System . out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + Math . max ( bT , oT ) ) ; } } public static void main ( String args [ ] ) { new GCJ2011QualA ( ) . solve ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { new GCJ2011QualA ( ) . solve ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= T ; testCase ++ ) { int N = sc . nextInt ( ) ; int oT = 0 , bT = 0 ; int oP = 1 , bP = 1 ; for ( int i = 0 ; i < N ; i ++ ) { char [ ] c = sc . next ( ) . toCharArray ( ) ; int pos = sc . nextInt ( ) ; if ( c [ 0 ] == ' O ' ) { oT = Math . max ( oT + Math . abs ( pos - oP ) , bT ) + 1 ; oP = pos ; } else { bT = Math . max ( bT + Math . abs ( pos - bP ) , oT ) + 1 ; bP = pos ; } } System . out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + Math . max ( bT , oT ) ) ; } }"]]}, {"id": "1", "code": "import java . util . * ; import java . io . * ; public class Solution { public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; int curO = 1 , spareStepsO = 0 , curB = 1 , spareStepsB = 0 ; int N = sc . nextInt ( ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String who = sc . next ( ) ; if ( who . equals ( \" O \" ) ) { int pos = sc . nextInt ( ) ; int dist = Math . abs ( curO - pos ) + 1 ; dist -= Math . min ( spareStepsO , dist - 1 ) ; res += dist ; spareStepsB += dist ; spareStepsO = 0 ; curO = pos ; } else { int pos = sc . nextInt ( ) ; int dist = Math . abs ( curB - pos ) + 1 ; dist -= Math . min ( spareStepsB , dist - 1 ) ; res += dist ; spareStepsO += dist ; spareStepsB = 0 ; curB = pos ; } } pw . println ( res ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } public static void main ( String [ ] args ) throws Exception { new Solution ( ) . doMain ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new Solution ( ) . doMain ( ) ; }"]], "functions_class": [["doMain", "public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; int curO = 1 , spareStepsO = 0 , curB = 1 , spareStepsB = 0 ; int N = sc . nextInt ( ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String who = sc . next ( ) ; if ( who . equals ( \" O \" ) ) { int pos = sc . nextInt ( ) ; int dist = Math . abs ( curO - pos ) + 1 ; dist -= Math . min ( spareStepsO , dist - 1 ) ; res += dist ; spareStepsB += dist ; spareStepsO = 0 ; curO = pos ; } else { int pos = sc . nextInt ( ) ; int dist = Math . abs ( curB - pos ) + 1 ; dist -= Math . min ( spareStepsB , dist - 1 ) ; res += dist ; spareStepsO += dist ; spareStepsB = 0 ; curB = pos ; } } pw . println ( res ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]]}], "python": [{"id": "11", "code": "import sys , re NEW_LINE from pprint import pprint NEW_LINE fi = open ( ' A - large . in ' , ' r ' ) NEW_LINE fo = open ( ' A - large . out ' , ' w ' ) NEW_LINE t = int ( fi . readline ( ) ) NEW_LINE for _ in range ( 1 , t + 1 ) : NEW_LINE INDENT inp = fi . readline ( ) . split ( ) NEW_LINE n = int ( inp [ 0 ] ) NEW_LINE btn = zip ( inp [ 1 : : 2 ] , map ( int , inp [ 2 : : 2 ] ) ) NEW_LINE o = b = 1 NEW_LINE to = tb = 0 NEW_LINE for c , x in btn : NEW_LINE INDENT if c == ' O ' : NEW_LINE INDENT to , o = to + abs ( x - o ) + 1 , x NEW_LINE to = max ( to , tb + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tb , b = tb + abs ( x - b ) + 1 , x NEW_LINE tb = max ( tb , to + 1 ) NEW_LINE DEDENT DEDENT fo . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( _ , max ( to , tb ) ) ) NEW_LINE DEDENT fi . close ( ) NEW_LINE fo . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "20", "code": "with open ( ' input1 . txt ' , ' r ' ) as fin : NEW_LINE INDENT with open ( ' output1 . txt ' , ' w ' ) as fout : NEW_LINE INDENT numcases = int ( fin . readline ( ) ) NEW_LINE for i in range ( 1 , numcases + 1 ) : NEW_LINE INDENT orange = [ 1 , 0 ] NEW_LINE blue = [ 1 , 0 ] NEW_LINE robotmap = { ' O ' : orange , ' B ' : blue } NEW_LINE notrobotmap = { ' O ' : blue , ' B ' : orange } NEW_LINE line = fin . readline ( ) . split ( ) NEW_LINE for j in range ( 1 , len ( line ) , 2 ) : NEW_LINE INDENT r = robotmap [ line [ j ] ] NEW_LINE notr = notrobotmap [ line [ j ] ] NEW_LINE target = int ( line [ j + 1 ] ) NEW_LINE r [ 1 ] += abs ( target - r [ 0 ] ) + 1 NEW_LINE if ( r [ 1 ] <= notr [ 1 ] ) : NEW_LINE INDENT r [ 1 ] = notr [ 1 ] + 1 NEW_LINE DEDENT r [ 0 ] = target NEW_LINE DEDENT fout . write ( \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + str ( max ( ( orange [ 1 ] , blue [ 1 ] ) ) ) + ' \\n ' ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "import sys NEW_LINE data = [ l . strip ( ) for l in open ( \" infile \" , \" r \" ) . readlines ( ) ] NEW_LINE out = open ( \" outfile \" , \" w \" ) NEW_LINE class robot : NEW_LINE INDENT def __init__ ( self , col , casedata ) : NEW_LINE INDENT self . color = col NEW_LINE self . pos = 1 NEW_LINE self . cindex = - 2 NEW_LINE self . nextgoal = ' START ' NEW_LINE self . findnextgoal ( casedata ) NEW_LINE DEDENT def movetowardgoal ( self ) : NEW_LINE INDENT if self . nextgoal == ' DONE ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif self . pos < self . nextgoal : NEW_LINE INDENT self . pos += 1 NEW_LINE DEDENT elif self . pos > self . nextgoal : NEW_LINE INDENT self . pos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def findnextgoal ( self , casedata ) : NEW_LINE INDENT self . cindex += 2 NEW_LINE while self . cindex < len ( casedata ) and casedata [ self . cindex ] != self . color : NEW_LINE INDENT self . cindex += 2 NEW_LINE DEDENT try : NEW_LINE INDENT self . nextgoal = int ( casedata [ 1 + self . cindex ] ) NEW_LINE DEDENT except : NEW_LINE INDENT self . nextgoal = ' DONE ' NEW_LINE DEDENT DEDENT DEDENT ncases = int ( data . pop ( 0 ) ) NEW_LINE for case in range ( ncases ) : NEW_LINE INDENT casedata = data . pop ( 0 ) . split ( ' \u2581 ' ) NEW_LINE numreqs = casedata . pop ( 0 ) NEW_LINE timetaken = 0 NEW_LINE orange = robot ( ' O ' , casedata ) NEW_LINE blue = robot ( ' B ' , casedata ) NEW_LINE while ( orange . nextgoal != ' DONE ' or blue . nextgoal != ' DONE ' ) : NEW_LINE INDENT timetaken += 1 NEW_LINE if orange . cindex < blue . cindex : NEW_LINE INDENT if orange . nextgoal == orange . pos : NEW_LINE INDENT orange . findnextgoal ( casedata ) NEW_LINE DEDENT else : NEW_LINE INDENT orange . movetowardgoal ( ) NEW_LINE DEDENT blue . movetowardgoal ( ) NEW_LINE DEDENT elif blue . cindex < orange . cindex : NEW_LINE INDENT if blue . nextgoal == blue . pos : NEW_LINE INDENT blue . findnextgoal ( casedata ) NEW_LINE DEDENT else : NEW_LINE INDENT blue . movetowardgoal ( ) NEW_LINE DEDENT orange . movetowardgoal ( ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . exit ( ) NEW_LINE DEDENT DEDENT out . write ( \" Case \u2581 # \" + str ( case + 1 ) + \" : \u2581 \" + str ( timetaken ) + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": [["__init__", "def __init__ ( self , col , casedata ) : NEW_LINE INDENT self . color = col NEW_LINE self . pos = 1 NEW_LINE self . cindex = - 2 NEW_LINE self . nextgoal = ' START ' NEW_LINE self . findnextgoal ( casedata ) NEW_LINE DEDENT"], ["movetowardgoal", "def movetowardgoal ( self ) : NEW_LINE INDENT if self . nextgoal == ' DONE ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif self . pos < self . nextgoal : NEW_LINE INDENT self . pos += 1 NEW_LINE DEDENT elif self . pos > self . nextgoal : NEW_LINE INDENT self . pos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT"], ["findnextgoal", "def findnextgoal ( self , casedata ) : NEW_LINE INDENT self . cindex += 2 NEW_LINE while self . cindex < len ( casedata ) and casedata [ self . cindex ] != self . color : NEW_LINE INDENT self . cindex += 2 NEW_LINE DEDENT try : NEW_LINE INDENT self . nextgoal = int ( casedata [ 1 + self . cindex ] ) NEW_LINE DEDENT except : NEW_LINE INDENT self . nextgoal = ' DONE ' NEW_LINE DEDENT DEDENT"]]}]}
{"id": "codejam_11_52", "java": [{"id": "15", "code": "import java . util . * ; import static java . lang . Math . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; int [ ] MC = new int [ 10000 ] ; for ( int i = 0 ; i < N ; i ++ ) { MC [ in . nextInt ( ) - 1 ] ++ ; } int ans = 0 ; int [ ] C = new int [ 10000 ] ; int [ ] E = new int [ 10000 ] ; for ( int i = 1 ; i <= N ; i ++ ) { boolean good = true ; for ( int j = 0 ; j < 10000 ; j ++ ) C [ j ] = MC [ j ] ; Arrays . fill ( E , 0 ) ; for ( int j = 0 ; j < 10000 ; j ++ ) { while ( C [ j ] > 0 ) { boolean legal = true ; if ( j + i > 10000 ) { legal = false ; } else { for ( int k = 0 ; k < i ; k ++ ) if ( C [ j + k ] == 0 ) legal = false ; } if ( legal ) { for ( int k = 0 ; k < i ; k ++ ) C [ j + k ] -- ; if ( j + i < 10000 ) E [ j + i ] ++ ; } else { if ( E [ j ] > 0 ) { E [ j ] -- ; C [ j ] -- ; if ( j + 1 < 10000 ) E [ j + 1 ] ++ ; } else { good = false ; break ; } } } } if ( good ) { ans = i ; } } System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; int [ ] MC = new int [ 10000 ] ; for ( int i = 0 ; i < N ; i ++ ) { MC [ in . nextInt ( ) - 1 ] ++ ; } int ans = 0 ; int [ ] C = new int [ 10000 ] ; int [ ] E = new int [ 10000 ] ; for ( int i = 1 ; i <= N ; i ++ ) { boolean good = true ; for ( int j = 0 ; j < 10000 ; j ++ ) C [ j ] = MC [ j ] ; Arrays . fill ( E , 0 ) ; for ( int j = 0 ; j < 10000 ; j ++ ) { while ( C [ j ] > 0 ) { boolean legal = true ; if ( j + i > 10000 ) { legal = false ; } else { for ( int k = 0 ; k < i ; k ++ ) if ( C [ j + k ] == 0 ) legal = false ; } if ( legal ) { for ( int k = 0 ; k < i ; k ++ ) C [ j + k ] -- ; if ( j + i < 10000 ) E [ j + i ] ++ ; } else { if ( E [ j ] > 0 ) { E [ j ] -- ; C [ j ] -- ; if ( j + 1 < 10000 ) E [ j + 1 ] ++ ; } else { good = false ; break ; } } } } if ( good ) { ans = i ; } } System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans ) ; } }"]], "functions_class": []}, {"id": "1", "code": "import java . util . * ; import java . io . * ; class B_as { Scanner in ; PrintWriter out ; public void solve ( ) throws IOException { int testNo = in . nextInt ( ) ; for ( int test = 1 ; test <= testNo ; test ++ ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; int m = 0 ; int [ ] last = new int [ n ] ; int [ ] len = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int blen = Integer . MAX_VALUE ; int best = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( last [ j ] == a [ i ] - 1 && len [ j ] < blen ) { best = j ; blen = len [ j ] ; } } if ( best == - 1 ) { last [ m ] = a [ i ] ; len [ m ] = 1 ; m ++ ; } else { last [ best ] = a [ i ] ; len [ best ] = len [ best ] + 1 ; } } int blen = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( len [ i ] < blen ) { blen = len [ i ] ; } } if ( blen == Integer . MAX_VALUE ) { blen = 0 ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + blen ) ; } } public void run ( ) { try { in = new Scanner ( new File ( \" B - large . in \" ) ) ; out = new PrintWriter ( new File ( \" B - large . out \" ) ) ; solve ( ) ; in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] arg ) { Locale . setDefault ( Locale . US ) ; new B_as ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] arg ) { Locale . setDefault ( Locale . US ) ; new B_as ( ) . run ( ) ; }"]], "functions_class": [["solve", "public void solve ( ) throws IOException { int testNo = in . nextInt ( ) ; for ( int test = 1 ; test <= testNo ; test ++ ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; int m = 0 ; int [ ] last = new int [ n ] ; int [ ] len = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int blen = Integer . MAX_VALUE ; int best = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( last [ j ] == a [ i ] - 1 && len [ j ] < blen ) { best = j ; blen = len [ j ] ; } } if ( best == - 1 ) { last [ m ] = a [ i ] ; len [ m ] = 1 ; m ++ ; } else { last [ best ] = a [ i ] ; len [ best ] = len [ best ] + 1 ; } } int blen = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( len [ i ] < blen ) { blen = len [ i ] ; } } if ( blen == Integer . MAX_VALUE ) { blen = 0 ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + blen ) ; } }"], ["run", "public void run ( ) { try { in = new Scanner ( new File ( \" B - large . in \" ) ) ; out = new PrintWriter ( new File ( \" B - large . out \" ) ) ; solve ( ) ; in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]]}, {"id": "8", "code": "package round3 ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class B { static class Niz { int zadnji , duzina ; Niz ( int element ) { duzina = 1 ; zadnji = element ; } } public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" B . out \" ) ) ; int tt = in . nextInt ( ) ; for ( int ttt = 1 ; ttt <= tt ; ttt ++ ) { int n = in . nextInt ( ) ; int [ ] t = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) t [ i ] = in . nextInt ( ) ; int res = 0 ; if ( n > 0 ) { Arrays . sort ( t ) ; ArrayList < Niz > nizovi = new ArrayList < B . Niz > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Niz a = null ; for ( Niz niz : nizovi ) if ( niz . zadnji == t [ i ] - 1 && ( a == null || a . duzina > niz . duzina ) ) a = niz ; if ( a == null ) nizovi . add ( new Niz ( t [ i ] ) ) ; else { a . duzina ++ ; a . zadnji = t [ i ] ; } } res = n ; for ( Niz niz : nizovi ) if ( niz . duzina < res ) res = niz . duzina ; } out . printf ( \" Case \u2581 # % d : \u2581 % d \" , ttt , res ) ; out . println ( ) ; } out . flush ( ) ; out . close ( ) ; in . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" B . out \" ) ) ; int tt = in . nextInt ( ) ; for ( int ttt = 1 ; ttt <= tt ; ttt ++ ) { int n = in . nextInt ( ) ; int [ ] t = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) t [ i ] = in . nextInt ( ) ; int res = 0 ; if ( n > 0 ) { Arrays . sort ( t ) ; ArrayList < Niz > nizovi = new ArrayList < B . Niz > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Niz a = null ; for ( Niz niz : nizovi ) if ( niz . zadnji == t [ i ] - 1 && ( a == null || a . duzina > niz . duzina ) ) a = niz ; if ( a == null ) nizovi . add ( new Niz ( t [ i ] ) ) ; else { a . duzina ++ ; a . zadnji = t [ i ] ; } } res = n ; for ( Niz niz : nizovi ) if ( niz . duzina < res ) res = niz . duzina ; } out . printf ( \" Case \u2581 # % d : \u2581 % d \" , ttt , res ) ; out . println ( ) ; } out . flush ( ) ; out . close ( ) ; in . close ( ) ; }"]], "functions_class": [["Niz", "Niz ( int element ) { duzina = 1 ; zadnji = element ; }"]]}, {"id": "20", "code": "import java . io . * ; import java . util . * ; import java . math . * ; public class Main { static StreamTokenizer in ; static int next ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; } ; static PrintWriter out ; static String NAME = \" b \" ; public static void main ( String [ ] args ) throws Exception { in = new StreamTokenizer ( new BufferedReader ( new FileReader ( new File ( NAME + \" . in \" ) ) ) ) ; out = new PrintWriter ( new File ( NAME + \" . out \" ) ) ; int tests = next ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int n = next ( ) ; if ( n == 0 ) { out . println ( \" Case \u2581 # \" + test + \" : \u2581 0\" ) ; continue ; } int m = 10005 ; int [ ] k = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) k [ next ( ) ] ++ ; int answ = 100000 ; int start = 0 ; int end = 0 ; while ( true ) { while ( start < m && k [ start ] == 0 ) start ++ ; if ( start == m ) break ; end = start ; while ( k [ end ] != 0 ) end ++ ; ArrayList < Integer > s = new ArrayList < Integer > ( ) ; ArrayList < Integer > e = new ArrayList < Integer > ( ) ; for ( int i = start ; i <= end ; i ++ ) { if ( k [ i ] > k [ i - 1 ] ) for ( int j = 0 ; j < k [ i ] - k [ i - 1 ] ; j ++ ) s . add ( i ) ; if ( k [ i ] < k [ i - 1 ] ) for ( int j = 0 ; j < k [ i - 1 ] - k [ i ] ; j ++ ) e . add ( i ) ; } for ( int i = 0 ; i < s . size ( ) ; i ++ ) answ = Math . min ( answ , e . get ( i ) - s . get ( i ) ) ; start = end ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + answ ) ; } out . close ( ) ; } }", "functions_standalone": [["next", "static int next ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { in = new StreamTokenizer ( new BufferedReader ( new FileReader ( new File ( NAME + \" . in \" ) ) ) ) ; out = new PrintWriter ( new File ( NAME + \" . out \" ) ) ; int tests = next ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int n = next ( ) ; if ( n == 0 ) { out . println ( \" Case \u2581 # \" + test + \" : \u2581 0\" ) ; continue ; } int m = 10005 ; int [ ] k = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) k [ next ( ) ] ++ ; int answ = 100000 ; int start = 0 ; int end = 0 ; while ( true ) { while ( start < m && k [ start ] == 0 ) start ++ ; if ( start == m ) break ; end = start ; while ( k [ end ] != 0 ) end ++ ; ArrayList < Integer > s = new ArrayList < Integer > ( ) ; ArrayList < Integer > e = new ArrayList < Integer > ( ) ; for ( int i = start ; i <= end ; i ++ ) { if ( k [ i ] > k [ i - 1 ] ) for ( int j = 0 ; j < k [ i ] - k [ i - 1 ] ; j ++ ) s . add ( i ) ; if ( k [ i ] < k [ i - 1 ] ) for ( int j = 0 ; j < k [ i - 1 ] - k [ i ] ; j ++ ) e . add ( i ) ; } for ( int i = 0 ; i < s . size ( ) ; i ++ ) answ = Math . min ( answ , e . get ( i ) - s . get ( i ) ) ; start = end ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + answ ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "6", "code": "import sun . java2d . pipe . OutlineTextRenderer ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class B { private static final int MAX = 20000 ; private String solve ( Scanner in ) { int n = in . nextInt ( ) ; if ( n == 0 ) { return \"0\" ; } int [ ] a = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ in . nextInt ( ) - 1 ] ++ ; } int l = 1 ; int r = n + 1 ; main : while ( r > l + 1 ) { int m = ( l + r ) / 2 ; int [ ] aa = a . clone ( ) ; int [ ] b = new int [ MAX + 1 ] ; for ( int i = 0 ; i < MAX ; i ++ ) { while ( aa [ i ] > 0 ) { if ( i > 0 && b [ i - 1 ] > 0 ) { b [ i - 1 ] -- ; b [ i ] ++ ; aa [ i ] -- ; } else { boolean ok = true ; for ( int j = i ; j < i + m ; j ++ ) { if ( aa [ j ] == 0 ) ok = false ; aa [ j ] -- ; } if ( ! ok ) { r = m ; continue main ; } b [ i + m - 1 ] ++ ; } } } l = m ; } return \" \" + l ; } public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private String solve ( Scanner in ) { int n = in . nextInt ( ) ; if ( n == 0 ) { return \"0\" ; } int [ ] a = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ in . nextInt ( ) - 1 ] ++ ; } int l = 1 ; int r = n + 1 ; main : while ( r > l + 1 ) { int m = ( l + r ) / 2 ; int [ ] aa = a . clone ( ) ; int [ ] b = new int [ MAX + 1 ] ; for ( int i = 0 ; i < MAX ; i ++ ) { while ( aa [ i ] > 0 ) { if ( i > 0 && b [ i - 1 ] > 0 ) { b [ i - 1 ] -- ; b [ i ] ++ ; aa [ i ] -- ; } else { boolean ok = true ; for ( int j = i ; j < i + m ; j ++ ) { if ( aa [ j ] == 0 ) ok = false ; aa [ j ] -- ; } if ( ! ok ) { r = m ; continue main ; } b [ i + m - 1 ] ++ ; } } } l = m ; } return \" \" + l ; }"]]}], "python": [{"id": "2", "code": "import sys NEW_LINE def foo ( ifile ) : NEW_LINE INDENT a = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] [ 1 : ] NEW_LINE a . sort ( ) NEW_LINE if len ( a ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT bb = { } NEW_LINE for item in a : NEW_LINE INDENT t = 0 NEW_LINE if item - 1 in bb : NEW_LINE INDENT t = bb [ item - 1 ] [ 0 ] NEW_LINE bb [ item - 1 ] = bb [ item - 1 ] [ 1 : ] NEW_LINE if len ( bb [ item - 1 ] ) == 0 : NEW_LINE INDENT del bb [ item - 1 ] NEW_LINE DEDENT DEDENT if item not in bb : NEW_LINE INDENT bb [ item ] = [ ] NEW_LINE DEDENT bb [ item ] . append ( t + 1 ) NEW_LINE bb [ item ] . sort ( ) NEW_LINE DEDENT res = len ( a ) NEW_LINE for k , v in bb . items ( ) : NEW_LINE INDENT res = min ( res , min ( v ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( ifile , ofile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE DEDENT DEDENT main ( sys . stdin , sys . stdout ) NEW_LINE", "functions_standalone": [["foo", "def foo ( ifile ) : NEW_LINE INDENT a = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] [ 1 : ] NEW_LINE a . sort ( ) NEW_LINE if len ( a ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT bb = { } NEW_LINE for item in a : NEW_LINE INDENT t = 0 NEW_LINE if item - 1 in bb : NEW_LINE INDENT t = bb [ item - 1 ] [ 0 ] NEW_LINE bb [ item - 1 ] = bb [ item - 1 ] [ 1 : ] NEW_LINE if len ( bb [ item - 1 ] ) == 0 : NEW_LINE INDENT del bb [ item - 1 ] NEW_LINE DEDENT DEDENT if item not in bb : NEW_LINE INDENT bb [ item ] = [ ] NEW_LINE DEDENT bb [ item ] . append ( t + 1 ) NEW_LINE bb [ item ] . sort ( ) NEW_LINE DEDENT res = len ( a ) NEW_LINE for k , v in bb . items ( ) : NEW_LINE INDENT res = min ( res , min ( v ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT"], ["main", "def main ( ifile , ofile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "5", "code": "from __future__ import division NEW_LINE from __future__ import with_statement NEW_LINE from __future__ import print_function NEW_LINE def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT TASK = \" B \" NEW_LINE from collections import Counter NEW_LINE from bisect import insort NEW_LINE print ( \" Calculation . . . \" ) NEW_LINE with open ( TASK + \" . in \" ) as infile : NEW_LINE INDENT with open ( TASK + \" . out \" , mode = \" wt \" ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for ncase in range ( cases ) : NEW_LINE INDENT print ( \" Case \u2581 # { nc } \" . format ( nc = ncase + 1 ) ) NEW_LINE cards = [ int ( s ) for s in infile . readline ( ) . split ( ) ] [ 1 : ] NEW_LINE values = Counter ( cards ) NEW_LINE nums = [ values [ i ] for i in xrange ( 0 , 10002 ) ] NEW_LINE starts = [ ] NEW_LINE shortest = 100000 NEW_LINE c = 0 NEW_LINE for i , n in enumerate ( nums ) : NEW_LINE INDENT if n > c : NEW_LINE INDENT starts += [ i ] * ( n - c ) NEW_LINE DEDENT if c > n : NEW_LINE INDENT shortest = min ( shortest , i - starts [ c - n - 1 ] ) NEW_LINE starts = starts [ c - n : ] NEW_LINE DEDENT c = n NEW_LINE DEDENT if len ( cards ) == 0 : NEW_LINE INDENT shortest = 0 NEW_LINE DEDENT outfile . write ( \" Case \u2581 # { nc } : \u2581 { data } \\n \" . format ( nc = ncase + 1 , data = shortest ) ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Calculation \u2581 done . \" ) NEW_LINE", "functions_standalone": [["memoized", "def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_11_41", "java": [{"id": "19", "code": "import java . io . * ; import java . util . * ; public class Main { static StreamTokenizer in ; static int next ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; } static PrintWriter out ; static String NAME = \" a \" ; public static void main ( String [ ] args ) throws Exception { out = new PrintWriter ( new File ( NAME + \" . out \" ) ) ; in = new StreamTokenizer ( new BufferedReader ( new FileReader ( new File ( NAME + \" . in \" ) ) ) ) ; int tests = next ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int x = next ( ) ; int s = next ( ) ; int r = next ( ) ; double t = next ( ) ; int n = next ( ) ; int m = 101 ; int [ ] l = new int [ m ] ; l [ 0 ] = x ; for ( int i = 0 ; i < n ; i ++ ) { int b = next ( ) ; int e = next ( ) ; l [ next ( ) ] += e - b ; l [ 0 ] -= e - b ; } double answ = 0 ; for ( int i = 0 ; i < m ; i ++ ) { double tt = Math . min ( t , ( double ) l [ i ] / ( i + r ) ) ; t -= tt ; answ -= tt * ( r - s ) / ( i + s ) ; } for ( int i = 0 ; i < m ; i ++ ) answ += ( double ) l [ i ] / ( i + s ) ; out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + answ ) ; } out . close ( ) ; } }", "functions_standalone": [["next", "static int next ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { out = new PrintWriter ( new File ( NAME + \" . out \" ) ) ; in = new StreamTokenizer ( new BufferedReader ( new FileReader ( new File ( NAME + \" . in \" ) ) ) ) ; int tests = next ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int x = next ( ) ; int s = next ( ) ; int r = next ( ) ; double t = next ( ) ; int n = next ( ) ; int m = 101 ; int [ ] l = new int [ m ] ; l [ 0 ] = x ; for ( int i = 0 ; i < n ; i ++ ) { int b = next ( ) ; int e = next ( ) ; l [ next ( ) ] += e - b ; l [ 0 ] -= e - b ; } double answ = 0 ; for ( int i = 0 ; i < m ; i ++ ) { double tt = Math . min ( t , ( double ) l [ i ] / ( i + r ) ) ; t -= tt ; answ -= tt * ( r - s ) / ( i + s ) ; } for ( int i = 0 ; i < m ; i ++ ) answ += ( double ) l [ i ] / ( i + s ) ; out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + answ ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "8", "code": "import java . util . * ; import static java . lang . Math . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int X = in . nextInt ( ) ; int S = in . nextInt ( ) ; int R = in . nextInt ( ) ; int t = in . nextInt ( ) ; int N = in . nextInt ( ) ; int [ ] length = new int [ 1000 ] ; int total = X ; for ( int i = 0 ; i < N ; i ++ ) { int begin = in . nextInt ( ) ; int end = in . nextInt ( ) ; int speed = in . nextInt ( ) ; length [ speed + S ] += end - begin ; total -= end - begin ; } length [ S ] += total ; double left = t ; double ans = 0 ; for ( int i = 0 ; i < length . length ; i ++ ) { double v = i ; double nv = v + ( R - S ) ; double len = length [ i ] ; if ( len / nv <= left ) { left -= len / nv ; ans += len / nv ; } else { ans += ( len - ( R - S ) * left ) / v ; left = 0 ; } } System . out . format ( \" Case \u2581 # % d : \u2581 % .09f \\n \" , zz , ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int X = in . nextInt ( ) ; int S = in . nextInt ( ) ; int R = in . nextInt ( ) ; int t = in . nextInt ( ) ; int N = in . nextInt ( ) ; int [ ] length = new int [ 1000 ] ; int total = X ; for ( int i = 0 ; i < N ; i ++ ) { int begin = in . nextInt ( ) ; int end = in . nextInt ( ) ; int speed = in . nextInt ( ) ; length [ speed + S ] += end - begin ; total -= end - begin ; } length [ S ] += total ; double left = t ; double ans = 0 ; for ( int i = 0 ; i < length . length ; i ++ ) { double v = i ; double nv = v + ( R - S ) ; double len = length [ i ] ; if ( len / nv <= left ) { left -= len / nv ; ans += len / nv ; } else { ans += ( len - ( R - S ) * left ) / v ; left = 0 ; } } System . out . format ( \" Case \u2581 # % d : \u2581 % .09f \\n \" , zz , ans ) ; } }"]], "functions_class": []}, {"id": "0", "code": "import java . util . * ; import java . io . * ; public class Solution { class Road implements Comparable < Road > { int add ; int len ; public Road ( int len , int add ) { this . len = len ; this . add = add ; } public int compareTo ( Road other ) { return this . add - other . add ; } } public void go ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= caseCnt ; caseNum ++ ) { int X = sc . nextInt ( ) ; int S = sc . nextInt ( ) ; int R = sc . nextInt ( ) ; double t = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; Road [ ] r = new Road [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { int B = sc . nextInt ( ) ; int E = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; r [ i ] = new Road ( E - B , w ) ; X -= r [ i ] . len ; } r [ N ] = new Road ( X , 0 ) ; Arrays . sort ( r ) ; double res = 0.0 ; for ( int i = 0 ; i < r . length ; i ++ ) { double need = r [ i ] . len / ( double ) ( R + r [ i ] . add ) ; if ( need < t ) { t -= need ; res += need ; } else { double dist = r [ i ] . len - ( R + r [ i ] . add ) * t ; res += t ; t = 0 ; res += dist / ( double ) ( S + r [ i ] . add ) ; } } pw . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + res ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . go ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . go ( ) ; }"]], "functions_class": [["Road", "public Road ( int len , int add ) { this . len = len ; this . add = add ; }"], ["compareTo", "public int compareTo ( Road other ) { return this . add - other . add ; }"], ["go", "public void go ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= caseCnt ; caseNum ++ ) { int X = sc . nextInt ( ) ; int S = sc . nextInt ( ) ; int R = sc . nextInt ( ) ; double t = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; Road [ ] r = new Road [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { int B = sc . nextInt ( ) ; int E = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; r [ i ] = new Road ( E - B , w ) ; X -= r [ i ] . len ; } r [ N ] = new Road ( X , 0 ) ; Arrays . sort ( r ) ; double res = 0.0 ; for ( int i = 0 ; i < r . length ; i ++ ) { double need = r [ i ] . len / ( double ) ( R + r [ i ] . add ) ; if ( need < t ) { t -= need ; res += need ; } else { double dist = r [ i ] . len - ( R + r [ i ] . add ) * t ; res += t ; t = 0 ; res += dist / ( double ) ( S + r [ i ] . add ) ; } } pw . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + res ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]]}, {"id": "10", "code": "import java . io . * ; import java . util . * ; import java . math . * ; import java . text . * ; public class a { private static class W implements Comparable < W > { public int l ; public int w ; public W ( int l , int w ) { this . l = l ; this . w = w ; } public int compareTo ( W o ) { return w - o . w ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( new BufferedInputStream ( System . in ) ) ; int T = sc . nextInt ( ) ; for ( int c = 1 ; c <= T ; ++ c ) { int x = sc . nextInt ( ) ; double s = sc . nextInt ( ) ; double r = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; W [ ] ws = new W [ n + 1 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int b = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; ws [ i ] = new W ( e - b , w ) ; sum += e - b ; } ws [ n ] = new W ( x - sum , 0 ) ; Arrays . sort ( ws ) ; double time = 0 ; double remaining_running = t ; for ( int i = 0 ; i <= n ; ++ i ) { W w = ws [ i ] ; if ( remaining_running > 0 ) { double tt = w . l / ( w . w + r ) ; if ( tt < remaining_running ) { remaining_running -= tt ; time += tt ; } else { time += remaining_running ; time += ( w . l - ( w . w + r ) * remaining_running ) / ( w . w + s ) ; remaining_running = 0 ; } } else { time += w . l / ( w . w + s ) ; } } System . out . format ( \" Case \u2581 # % d : \u2581 % .6f % n \" , c , time ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( new BufferedInputStream ( System . in ) ) ; int T = sc . nextInt ( ) ; for ( int c = 1 ; c <= T ; ++ c ) { int x = sc . nextInt ( ) ; double s = sc . nextInt ( ) ; double r = sc . nextInt ( ) ; int t = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; W [ ] ws = new W [ n + 1 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int b = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; ws [ i ] = new W ( e - b , w ) ; sum += e - b ; } ws [ n ] = new W ( x - sum , 0 ) ; Arrays . sort ( ws ) ; double time = 0 ; double remaining_running = t ; for ( int i = 0 ; i <= n ; ++ i ) { W w = ws [ i ] ; if ( remaining_running > 0 ) { double tt = w . l / ( w . w + r ) ; if ( tt < remaining_running ) { remaining_running -= tt ; time += tt ; } else { time += remaining_running ; time += ( w . l - ( w . w + r ) * remaining_running ) / ( w . w + s ) ; remaining_running = 0 ; } } else { time += w . l / ( w . w + s ) ; } } System . out . format ( \" Case \u2581 # % d : \u2581 % .6f % n \" , c , time ) ; } }"]], "functions_class": [["W", "public W ( int l , int w ) { this . l = l ; this . w = w ; }"], ["compareTo", "public int compareTo ( W o ) { return w - o . w ; }"]]}], "python": [{"id": "15", "code": "infile = open ( ' airport _ walk . in ' ) NEW_LINE outfile = open ( ' airport _ walk . out ' , ' w ' ) NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for t in xrange ( T ) : NEW_LINE INDENT X , S , R , runtime , N = [ int ( s ) for s in infile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE run_bonus = R - S NEW_LINE speeds , lengths = [ ] , [ ] NEW_LINE walkways = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT B , E , w = [ int ( s ) for s in infile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE walkways . append ( ( w + S , E - B ) ) NEW_LINE DEDENT sum_lens = sum ( w [ 1 ] for w in walkways ) NEW_LINE walkways . append ( ( S , X - sum_lens ) ) NEW_LINE walkways = sorted ( walkways , key = lambda w : w [ 0 ] ) NEW_LINE answer = 0.0 NEW_LINE for speed , distance in walkways : NEW_LINE INDENT cur_runtime = min ( distance / float ( speed + run_bonus ) , float ( runtime ) ) NEW_LINE runtime -= cur_runtime NEW_LINE answer += cur_runtime + ( ( distance - ( speed + run_bonus ) * cur_runtime ) / float ( speed ) ) NEW_LINE DEDENT outfile . write ( ' Case \u2581 # % d : \u2581 % .9f \\n ' % ( t + 1 , answer ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "9", "code": "with open ( ' input . in ' , ' r ' ) as fin : NEW_LINE INDENT with open ( ' output . txt ' , ' w ' ) as fout : NEW_LINE INDENT numcases = int ( fin . readline ( ) ) NEW_LINE for casenum in range ( 1 , numcases + 1 ) : NEW_LINE INDENT info = [ int ( i ) for i in fin . readline ( ) . split ( ) ] NEW_LINE length = info [ 0 ] NEW_LINE walksp = float ( info [ 1 ] ) NEW_LINE runsp = float ( info [ 2 ] ) NEW_LINE runt = float ( info [ 3 ] ) NEW_LINE walkways = [ ] NEW_LINE for walkway in range ( info [ 4 ] ) : NEW_LINE INDENT w = [ int ( i ) for i in fin . readline ( ) . split ( ) ] NEW_LINE walkways . append ( ( w [ 2 ] , ( w [ 1 ] - w [ 0 ] ) ) ) NEW_LINE DEDENT walkways . sort ( ) NEW_LINE lengths = sum ( [ x [ 1 ] for x in walkways ] ) NEW_LINE time = 0.0 NEW_LINE nowalklen = length - lengths NEW_LINE print ( nowalklen ) NEW_LINE if ( runt < nowalklen / runsp ) : NEW_LINE INDENT time = runt + ( nowalklen - ( runsp * runt ) ) / walksp NEW_LINE runt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT runt -= nowalklen / runsp NEW_LINE time += nowalklen / runsp NEW_LINE DEDENT print ( time ) NEW_LINE for i in walkways : NEW_LINE INDENT if ( runt < i [ 1 ] / ( i [ 0 ] + runsp ) ) : NEW_LINE INDENT time += runt + ( i [ 1 ] - ( ( i [ 0 ] + runsp ) * runt ) ) / ( i [ 0 ] + walksp ) NEW_LINE runt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT time += i [ 1 ] / ( i [ 0 ] + runsp ) NEW_LINE runt -= i [ 1 ] / ( i [ 0 ] + runsp ) NEW_LINE DEDENT DEDENT fout . write ( \" Case \u2581 # \" + str ( casenum ) + \" : \u2581 \" + str ( time ) + ' \\n ' ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "10", "code": "from __future__ import division NEW_LINE def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT TASK = \" A \" NEW_LINE print ( \" Calculation . . . \" ) NEW_LINE with open ( TASK + \" . in \" ) as infile : NEW_LINE INDENT with open ( TASK + \" . out \" , mode = \" wt \" ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for ncase in range ( cases ) : NEW_LINE INDENT X , W , R , t , N = ( int ( s ) for s in infile . readline ( ) . split ( ) ) NEW_LINE parts = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT B , E , s = ( int ( s ) for s in infile . readline ( ) . split ( ) ) NEW_LINE X -= E - B NEW_LINE parts . append ( ( s , E - B ) ) NEW_LINE DEDENT parts . append ( ( 0 , X ) ) NEW_LINE parts . sort ( ) NEW_LINE T = 0 NEW_LINE for s , L in parts : NEW_LINE INDENT if t > 0 : NEW_LINE INDENT Tr = min ( L / ( s + R ) , t ) NEW_LINE T += Tr NEW_LINE t -= Tr NEW_LINE L -= ( s + R ) * Tr NEW_LINE DEDENT if t == 0 : NEW_LINE INDENT T += L / ( s + W ) NEW_LINE DEDENT DEDENT outfile . write ( \" Case \u2581 # { nc } : \u2581 { data } \\n \" . format ( nc = ncase + 1 , data = T ) ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Calculation \u2581 done . \" ) NEW_LINE", "functions_standalone": [["memoized", "def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT"]], "functions_class": []}, {"id": "8", "code": "import sys , collections NEW_LINE infile = sys . stdin NEW_LINE def get_time ( segments , S , R , running_time ) : NEW_LINE INDENT segments = collections . deque ( sorted ( segments , key = lambda s : s [ 1 ] ) ) NEW_LINE t = 0 NEW_LINE while segments : NEW_LINE INDENT sdist , sspeed = segments . popleft ( ) NEW_LINE if running_time > 0 : NEW_LINE INDENT rt = sdist / ( sspeed + R ) NEW_LINE if rt <= running_time : NEW_LINE INDENT running_time -= rt NEW_LINE t += rt NEW_LINE DEDENT else : NEW_LINE INDENT remaining = sdist - ( running_time * ( R + sspeed ) ) NEW_LINE t += running_time + ( remaining / ( S + sspeed ) ) NEW_LINE running_time = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT t += ( sdist / ( S + sspeed ) ) NEW_LINE DEDENT DEDENT return t NEW_LINE DEDENT T = int ( infile . readline ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT X , S , R , t , N = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE segments = [ ] NEW_LINE wdist = 0 NEW_LINE for j in xrange ( N ) : NEW_LINE INDENT B , E , w = map ( float , infile . readline ( ) . split ( ) ) NEW_LINE segments . append ( ( E - B , w ) ) NEW_LINE wdist += E - B NEW_LINE DEDENT segments . append ( ( X - wdist , 0 ) ) NEW_LINE result = get_time ( segments , float ( S ) , float ( R ) , float ( t ) ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % f \" % ( i + 1 , result ) ) NEW_LINE DEDENT", "functions_standalone": [["get_time", "def get_time ( segments , S , R , running_time ) : NEW_LINE INDENT segments = collections . deque ( sorted ( segments , key = lambda s : s [ 1 ] ) ) NEW_LINE t = 0 NEW_LINE while segments : NEW_LINE INDENT sdist , sspeed = segments . popleft ( ) NEW_LINE if running_time > 0 : NEW_LINE INDENT rt = sdist / ( sspeed + R ) NEW_LINE if rt <= running_time : NEW_LINE INDENT running_time -= rt NEW_LINE t += rt NEW_LINE DEDENT else : NEW_LINE INDENT remaining = sdist - ( running_time * ( R + sspeed ) ) NEW_LINE t += running_time + ( remaining / ( S + sspeed ) ) NEW_LINE running_time = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT t += ( sdist / ( S + sspeed ) ) NEW_LINE DEDENT DEDENT return t NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "N = int ( input ( ) ) NEW_LINE for num in range ( 1 , N + 1 ) : NEW_LINE INDENT X , S , R , T , n = map ( int , input ( ) . split ( ) ) NEW_LINE L = { } NEW_LINE W = { } NEW_LINE L [ 0 ] = X NEW_LINE W [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b , e , w = map ( int , input ( ) . split ( ) ) NEW_LINE L [ i ] = ( e - b ) NEW_LINE W [ i ] = w NEW_LINE L [ 0 ] -= ( e - b ) NEW_LINE DEDENT Idx = list ( range ( n + 1 ) ) NEW_LINE Idx = sorted ( Idx , key = W . get ) NEW_LINE Answer = 0 NEW_LINE for i in Idx : NEW_LINE INDENT if T == 0 : NEW_LINE INDENT Answer += L [ i ] / ( W [ i ] + S ) NEW_LINE DEDENT elif ( W [ i ] + R ) * T >= L [ i ] : NEW_LINE INDENT Answer += L [ i ] / ( W [ i ] + R ) NEW_LINE T -= L [ i ] / ( W [ i ] + R ) NEW_LINE DEDENT else : NEW_LINE INDENT Answer += T + ( L [ i ] - T * ( W [ i ] + R ) ) / ( W [ i ] + S ) NEW_LINE T = 0 NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # \" , num , \" : \u2581 \" , Answer , sep = ' ' ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_11_22", "java": [{"id": "19", "code": "import java . io . * ; import java . util . * ; public class B { private static String fileName = B . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; private static Scanner in ; private static PrintWriter out ; private void solve ( ) { int points = in . nextInt ( ) ; int d = in . nextInt ( ) ; List < Integer > xs = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < points ; i ++ ) { int x = in . nextInt ( ) ; int amount = in . nextInt ( ) ; for ( int j = 0 ; j < amount ; j ++ ) { xs . add ( x ) ; } } Collections . sort ( xs ) ; double left = 0 ; double right = 1e12 ; binsearch : while ( left + 0.5e-6 < right ) { System . out . println ( right - left ) ; double time = ( left + right ) / 2 ; double p = - 1e15 ; for ( int x : xs ) { double pp = Math . max ( x - time , p + d ) ; if ( pp > x + time ) { if ( left == time ) { break ; } left = time ; continue binsearch ; } p = pp ; } if ( right == time ) { break ; } right = time ; } out . println ( right ) ; } public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new B ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new B ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( ) { int points = in . nextInt ( ) ; int d = in . nextInt ( ) ; List < Integer > xs = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < points ; i ++ ) { int x = in . nextInt ( ) ; int amount = in . nextInt ( ) ; for ( int j = 0 ; j < amount ; j ++ ) { xs . add ( x ) ; } } Collections . sort ( xs ) ; double left = 0 ; double right = 1e12 ; binsearch : while ( left + 0.5e-6 < right ) { System . out . println ( right - left ) ; double time = ( left + right ) / 2 ; double p = - 1e15 ; for ( int x : xs ) { double pp = Math . max ( x - time , p + d ) ; if ( pp > x + time ) { if ( left == time ) { break ; } left = time ; continue binsearch ; } p = pp ; } if ( right == time ) { break ; } right = time ; } out . println ( right ) ; }"]]}, {"id": "4", "code": "package round1 ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class HotDogs { static class Point { int position , total ; public Point ( int position , int total ) { this . position = position ; this . total = total ; } } static final double eps = 0.0000000001 ; public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" hotDog . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" hotDog . out \" ) ) ; int tt = in . nextInt ( ) ; for ( int t = 1 ; t <= tt ; t ++ ) { System . out . println ( t ) ; int c = in . nextInt ( ) ; double d = in . nextInt ( ) ; Point [ ] p = new Point [ c ] ; for ( int i = 0 ; i < c ; i ++ ) { int position = in . nextInt ( ) ; int total = in . nextInt ( ) ; p [ i ] = new Point ( position , total ) ; } double lg = 0 , dg = 1000000000 ; dg *= dg ; int count = 0 ; while ( dg - lg > eps && count < 100000 ) { count ++ ; double s = ( dg + lg ) / 2 ; boolean moze = true ; double tmin = - 1000000000000000000.0 ; for ( int i = 0 ; moze && i < c ; i ++ ) { double t1 = Math . max ( tmin , p [ i ] . position - s ) ; double tlast = t1 + ( double ) ( p [ i ] . total - 1 ) * ( double ) d ; if ( tlast - p [ i ] . position > s + eps ) moze = false ; else tmin = tlast + ( double ) d ; } if ( moze ) dg = s ; else lg = s ; } System . out . println ( dg + \" \u2581 \" + lg ) ; out . printf ( \" Case \u2581 # % d : \u2581 % .10f \" , t , ( lg + dg ) / 2 ) ; out . println ( ) ; } out . flush ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" hotDog . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" hotDog . out \" ) ) ; int tt = in . nextInt ( ) ; for ( int t = 1 ; t <= tt ; t ++ ) { System . out . println ( t ) ; int c = in . nextInt ( ) ; double d = in . nextInt ( ) ; Point [ ] p = new Point [ c ] ; for ( int i = 0 ; i < c ; i ++ ) { int position = in . nextInt ( ) ; int total = in . nextInt ( ) ; p [ i ] = new Point ( position , total ) ; } double lg = 0 , dg = 1000000000 ; dg *= dg ; int count = 0 ; while ( dg - lg > eps && count < 100000 ) { count ++ ; double s = ( dg + lg ) / 2 ; boolean moze = true ; double tmin = - 1000000000000000000.0 ; for ( int i = 0 ; moze && i < c ; i ++ ) { double t1 = Math . max ( tmin , p [ i ] . position - s ) ; double tlast = t1 + ( double ) ( p [ i ] . total - 1 ) * ( double ) d ; if ( tlast - p [ i ] . position > s + eps ) moze = false ; else tmin = tlast + ( double ) d ; } if ( moze ) dg = s ; else lg = s ; } System . out . println ( dg + \" \u2581 \" + lg ) ; out . printf ( \" Case \u2581 # % d : \u2581 % .10f \" , t , ( lg + dg ) / 2 ) ; out . println ( ) ; } out . flush ( ) ; out . close ( ) ; }"]], "functions_class": [["Point", "public Point ( int position , int total ) { this . position = position ; this . total = total ; }"]]}, {"id": "8", "code": "package round1b ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . util . ArrayList ; import java . util . Collections ; import qual2011 . Kattio ; public class B { public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" src / round1b / B - large - 0 . in \" ) , new FileOutputStream ( \" src / round1b / B - large - 0 . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; new B ( ) . solve ( io ) ; } io . close ( ) ; } private void solve ( Kattio io ) { int C = io . getInt ( ) , D = io . getInt ( ) ; ArrayList < Long > vendor = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < C ; i ++ ) { int P = io . getInt ( ) , V = io . getInt ( ) ; for ( int j = 0 ; j < V ; j ++ ) { vendor . add ( ( long ) P * 2 ) ; } } D *= 2 ; Collections . sort ( vendor ) ; long lo = 0 , hi = 2000000000000L ; int iter = 0 ; long best = hi ; while ( hi > lo ) { long x = ( hi + lo ) / 2 ; long allowed = vendor . get ( 0 ) - x ; boolean ok = true ; for ( Long v : vendor ) { long t = Math . max ( allowed , v - x ) ; if ( Math . abs ( t - v ) > x ) { ok = false ; break ; } allowed = t + D ; } if ( ok ) { hi = x ; best = x ; } else { lo = x + 1 ; } iter ++ ; } io . println ( best / 2.0 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" src / round1b / B - large - 0 . in \" ) , new FileOutputStream ( \" src / round1b / B - large - 0 . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; new B ( ) . solve ( io ) ; } io . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( Kattio io ) { int C = io . getInt ( ) , D = io . getInt ( ) ; ArrayList < Long > vendor = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < C ; i ++ ) { int P = io . getInt ( ) , V = io . getInt ( ) ; for ( int j = 0 ; j < V ; j ++ ) { vendor . add ( ( long ) P * 2 ) ; } } D *= 2 ; Collections . sort ( vendor ) ; long lo = 0 , hi = 2000000000000L ; int iter = 0 ; long best = hi ; while ( hi > lo ) { long x = ( hi + lo ) / 2 ; long allowed = vendor . get ( 0 ) - x ; boolean ok = true ; for ( Long v : vendor ) { long t = Math . max ( allowed , v - x ) ; if ( Math . abs ( t - v ) > x ) { ok = false ; break ; } allowed = t + D ; } if ( ok ) { hi = x ; best = x ; } else { lo = x + 1 ; } iter ++ ; } io . println ( best / 2.0 ) ; }"]]}, {"id": "11", "code": "import java . util . * ; import java . io . * ; import static java . lang . Math . * ; public class B { public static void main ( String [ ] args ) throws Exception { new B ( ) . run ( ) ; } final double EPS = 1e-9 ; void run ( ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int o = 1 ; o <= T ; o ++ ) { int C = sc . nextInt ( ) ; int D = sc . nextInt ( ) ; ArrayList < Integer > ps = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < C ; i ++ ) { int P = sc . nextInt ( ) ; int V = sc . nextInt ( ) ; for ( int j = 0 ; j < V ; j ++ ) ps . add ( P ) ; } Collections . sort ( ps ) ; double left = 0 , right = 1e13 ; double ans = right * 2 ; for ( int e = 0 ; e < 200 ; e ++ ) { double m = ( left + right ) / 2 ; if ( ok ( ps , D , m ) ) { right = m ; ans = min ( m , ans ) ; } else { left = m ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % f \\n \" , o , ans ) ; } } boolean ok ( ArrayList < Integer > ps , int D , double len ) { double last = ps . get ( 0 ) - len ; for ( int i = 1 ; i < ps . size ( ) ; i ++ ) { double p = ps . get ( i ) ; if ( p - last + len < D + EPS ) return false ; if ( p - last - len > D - EPS ) { last = p - len ; } else { last += D ; } } return true ; } } class CL implements Comparable < CL > { int pos ; int num ; CL ( int p , int v ) { pos = p ; num = v ; } public int compareTo ( CL cl ) { return this . pos - cl . pos ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new B ( ) . run ( ) ; }"]], "functions_class": [["run", "void run ( ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int o = 1 ; o <= T ; o ++ ) { int C = sc . nextInt ( ) ; int D = sc . nextInt ( ) ; ArrayList < Integer > ps = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < C ; i ++ ) { int P = sc . nextInt ( ) ; int V = sc . nextInt ( ) ; for ( int j = 0 ; j < V ; j ++ ) ps . add ( P ) ; } Collections . sort ( ps ) ; double left = 0 , right = 1e13 ; double ans = right * 2 ; for ( int e = 0 ; e < 200 ; e ++ ) { double m = ( left + right ) / 2 ; if ( ok ( ps , D , m ) ) { right = m ; ans = min ( m , ans ) ; } else { left = m ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % f \\n \" , o , ans ) ; } }"], ["ok", "boolean ok ( ArrayList < Integer > ps , int D , double len ) { double last = ps . get ( 0 ) - len ; for ( int i = 1 ; i < ps . size ( ) ; i ++ ) { double p = ps . get ( i ) ; if ( p - last + len < D + EPS ) return false ; if ( p - last - len > D - EPS ) { last = p - len ; } else { last += D ; } } return true ; }"], ["CL", "CL ( int p , int v ) { pos = p ; num = v ; }"], ["compareTo", "public int compareTo ( CL cl ) { return this . pos - cl . pos ; }"]]}, {"id": "6", "code": "import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class B implements Runnable { public void solve ( ) throws IOException { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int n = in . nextInt ( ) ; int d = in . nextInt ( ) ; int [ ] v = new int [ n ] ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextInt ( ) ; v [ i ] = in . nextInt ( ) ; } double l = 0.0 ; double r = 1E14 ; while ( r - l > 0.1 ) { double t = 0.5 * ( l + r ) ; double X = Double . NEGATIVE_INFINITY ; boolean ok = true ; for ( int i = 0 ; i < n ; i ++ ) { X = Math . max ( X + d , x [ i ] - t ) + ( v [ i ] - 1 ) * 1.0 * d ; if ( Math . abs ( X - x [ i ] ) > t ) { ok = false ; break ; } } if ( ok ) { r = t ; } else { l = t ; } } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + Math . round ( l + r ) * 0.5 ) ; } } public Scanner in ; public PrintWriter out ; B ( ) throws IOException { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; } void close ( ) throws IOException { out . close ( ) ; } void check ( boolean f , String msg ) { if ( ! f ) { out . close ( ) ; throw new RuntimeException ( msg ) ; } } public void run ( ) { try { solve ( ) ; close ( ) ; } catch ( Exception e ) { e . printStackTrace ( out ) ; out . flush ( ) ; throw new RuntimeException ( e ) ; } } public static void main ( String [ ] args ) throws IOException { new Thread ( new B ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Thread ( new B ( ) ) . start ( ) ; }"]], "functions_class": [["solve", "public void solve ( ) throws IOException { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int n = in . nextInt ( ) ; int d = in . nextInt ( ) ; int [ ] v = new int [ n ] ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextInt ( ) ; v [ i ] = in . nextInt ( ) ; } double l = 0.0 ; double r = 1E14 ; while ( r - l > 0.1 ) { double t = 0.5 * ( l + r ) ; double X = Double . NEGATIVE_INFINITY ; boolean ok = true ; for ( int i = 0 ; i < n ; i ++ ) { X = Math . max ( X + d , x [ i ] - t ) + ( v [ i ] - 1 ) * 1.0 * d ; if ( Math . abs ( X - x [ i ] ) > t ) { ok = false ; break ; } } if ( ok ) { r = t ; } else { l = t ; } } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + Math . round ( l + r ) * 0.5 ) ; } }"], ["B", "B ( ) throws IOException { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; }"], ["close", "void close ( ) throws IOException { out . close ( ) ; }"], ["check", "void check ( boolean f , String msg ) { if ( ! f ) { out . close ( ) ; throw new RuntimeException ( msg ) ; } }"], ["run", "public void run ( ) { try { solve ( ) ; close ( ) ; } catch ( Exception e ) { e . printStackTrace ( out ) ; out . flush ( ) ; throw new RuntimeException ( e ) ; } }"]]}], "python": [{"id": "6", "code": "inFile = open ( \" B - large . in . in \" , ' r ' ) NEW_LINE outFile = open ( \" B . out \" , ' w ' ) NEW_LINE N = int ( inFile . readline ( ) ) NEW_LINE for I in range ( 1 , N + 1 ) : NEW_LINE INDENT numPoints , minDist = tuple ( [ int ( x ) for x in inFile . readline ( ) . split ( ) ] ) NEW_LINE vendors = [ ] NEW_LINE for i in range ( numPoints ) : NEW_LINE INDENT point , numVendors = tuple ( [ int ( x ) for x in inFile . readline ( ) . split ( ) ] ) NEW_LINE for j in range ( numVendors ) : NEW_LINE INDENT vendors . append ( point ) NEW_LINE DEDENT DEDENT maxMove = 0 NEW_LINE for i in range ( 1 , len ( vendors ) ) : NEW_LINE INDENT if vendors [ i ] - vendors [ i - 1 ] < minDist : NEW_LINE INDENT maxMove = max ( maxMove , vendors [ i - 1 ] - vendors [ i ] + minDist ) NEW_LINE vendors [ i ] = vendors [ i - 1 ] + minDist NEW_LINE DEDENT DEDENT outFile . write ( \" Case \u2581 # \" + str ( I ) + \" : \u2581 \" + str ( maxMove / 2 ) + \" \\n \" ) NEW_LINE print ( \" Case \u2581 # \" + str ( I ) + \" : \u2581 \" + str ( maxMove / 2 ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "3", "code": "import sys NEW_LINE NAME = None NEW_LINE def ok ( points , time , D ) : NEW_LINE INDENT prev = None NEW_LINE for p in points : NEW_LINE INDENT x , cnt = p [ 0 ] , p [ 1 ] NEW_LINE minX = x - time NEW_LINE if prev is not None : NEW_LINE INDENT minX = max ( minX , prev + D ) NEW_LINE DEDENT next = minX + D * ( cnt - 1 ) NEW_LINE if abs ( x - next ) > time : NEW_LINE INDENT return False NEW_LINE DEDENT prev = next NEW_LINE DEDENT return True NEW_LINE DEDENT def getMagicWord ( ) : NEW_LINE INDENT numPoints = nextToken ( int ) NEW_LINE D = nextToken ( int ) * 2 NEW_LINE p = [ ] NEW_LINE pMin = 1000000 NEW_LINE pMax = - pMin NEW_LINE n = 0 NEW_LINE for i in range ( numPoints ) : NEW_LINE INDENT x = nextToken ( int ) * 2 NEW_LINE cnt = nextToken ( int ) NEW_LINE p . append ( ( x , cnt ) ) NEW_LINE DEDENT p . sort ( key = lambda x : x [ 0 ] ) NEW_LINE L , R = - 1 , 10 ** 14 NEW_LINE while R - L > 1 : NEW_LINE INDENT K = ( L + R ) // 2 NEW_LINE if ok ( p , K , D ) : NEW_LINE INDENT R = K NEW_LINE DEDENT else : NEW_LINE INDENT L = K NEW_LINE DEDENT DEDENT return \" % .1f \" % ( R / 2 ) NEW_LINE DEDENT def nextToken ( func = None ) : NEW_LINE INDENT res = \" \" NEW_LINE while fin : NEW_LINE INDENT c = fin . read ( 1 ) NEW_LINE if c . isspace ( ) : NEW_LINE INDENT break NEW_LINE DEDENT res += c NEW_LINE DEDENT if func : NEW_LINE INDENT return func ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT def nextLine ( ) : NEW_LINE INDENT if fin : NEW_LINE INDENT return fin . readline ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return \" \" NEW_LINE DEDENT DEDENT if NAME : NEW_LINE INDENT fin , fout = open ( NAME + \" . in \" , \" r \" ) , open ( NAME + \" . out \" , \" w \" ) NEW_LINE DEDENT else : NEW_LINE INDENT fin , fout = sys . stdin , sys . stdout NEW_LINE DEDENT for testNum in range ( nextToken ( int ) ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( testNum + 1 , getMagicWord ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["ok", "def ok ( points , time , D ) : NEW_LINE INDENT prev = None NEW_LINE for p in points : NEW_LINE INDENT x , cnt = p [ 0 ] , p [ 1 ] NEW_LINE minX = x - time NEW_LINE if prev is not None : NEW_LINE INDENT minX = max ( minX , prev + D ) NEW_LINE DEDENT next = minX + D * ( cnt - 1 ) NEW_LINE if abs ( x - next ) > time : NEW_LINE INDENT return False NEW_LINE DEDENT prev = next NEW_LINE DEDENT return True NEW_LINE DEDENT"], ["getMagicWord", "def getMagicWord ( ) : NEW_LINE INDENT numPoints = nextToken ( int ) NEW_LINE D = nextToken ( int ) * 2 NEW_LINE p = [ ] NEW_LINE pMin = 1000000 NEW_LINE pMax = - pMin NEW_LINE n = 0 NEW_LINE for i in range ( numPoints ) : NEW_LINE INDENT x = nextToken ( int ) * 2 NEW_LINE cnt = nextToken ( int ) NEW_LINE p . append ( ( x , cnt ) ) NEW_LINE DEDENT p . sort ( key = lambda x : x [ 0 ] ) NEW_LINE L , R = - 1 , 10 ** 14 NEW_LINE while R - L > 1 : NEW_LINE INDENT K = ( L + R ) // 2 NEW_LINE if ok ( p , K , D ) : NEW_LINE INDENT R = K NEW_LINE DEDENT else : NEW_LINE INDENT L = K NEW_LINE DEDENT DEDENT return \" % .1f \" % ( R / 2 ) NEW_LINE DEDENT"], ["nextToken", "def nextToken ( func = None ) : NEW_LINE INDENT res = \" \" NEW_LINE while fin : NEW_LINE INDENT c = fin . read ( 1 ) NEW_LINE if c . isspace ( ) : NEW_LINE INDENT break NEW_LINE DEDENT res += c NEW_LINE DEDENT if func : NEW_LINE INDENT return func ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT"], ["nextLine", "def nextLine ( ) : NEW_LINE INDENT if fin : NEW_LINE INDENT return fin . readline ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return \" \" NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE def foo ( ifile ) : NEW_LINE INDENT C , D = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT P , V = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE a += [ [ P , V ] ] NEW_LINE DEDENT n = len ( a ) NEW_LINE b = [ [ a [ i ] [ 0 ] , a [ i ] [ 0 ] ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i ) [ : : - 1 ] : NEW_LINE INDENT count += a [ j ] [ 1 ] NEW_LINE b [ i ] [ 1 ] = max ( b [ i ] [ 1 ] , a [ j ] [ 0 ] + count * D ) NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT count += a [ j ] [ 1 ] NEW_LINE b [ i ] [ 0 ] = min ( b [ i ] [ 0 ] , a [ j ] [ 0 ] + count * D ) NEW_LINE DEDENT DEDENT return \" % .1f \" % ( max ( [ b [ i ] [ 1 ] - b [ i ] [ 0 ] + D * a [ i ] [ 1 ] - D for i in range ( n ) ] ) / 2.0 ) NEW_LINE DEDENT def main ( ifile , ofile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE DEDENT DEDENT main ( sys . stdin , sys . stdout ) NEW_LINE", "functions_standalone": [["foo", "def foo ( ifile ) : NEW_LINE INDENT C , D = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT P , V = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE a += [ [ P , V ] ] NEW_LINE DEDENT n = len ( a ) NEW_LINE b = [ [ a [ i ] [ 0 ] , a [ i ] [ 0 ] ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i ) [ : : - 1 ] : NEW_LINE INDENT count += a [ j ] [ 1 ] NEW_LINE b [ i ] [ 1 ] = max ( b [ i ] [ 1 ] , a [ j ] [ 0 ] + count * D ) NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT count += a [ j ] [ 1 ] NEW_LINE b [ i ] [ 0 ] = min ( b [ i ] [ 0 ] , a [ j ] [ 0 ] + count * D ) NEW_LINE DEDENT DEDENT return \" % .1f \" % ( max ( [ b [ i ] [ 1 ] - b [ i ] [ 0 ] + D * a [ i ] [ 1 ] - D for i in range ( n ) ] ) / 2.0 ) NEW_LINE DEDENT"], ["main", "def main ( ifile , ofile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ofile . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , foo ( ifile ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_03", "java": [{"id": "5", "code": "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class C { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" src / C - large . in \" ) ) ) ) ; String output = \" \" ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int n = sc . nextInt ( ) ; int j = sc . nextInt ( ) ; long num = ( 1l << ( n - 1 ) ) + 1 ; int count = 0 ; output += \" Case \u2581 # \" + i + \" : \\n \" ; while ( count < j ) { String s = Long . toBinaryString ( num ) ; boolean found = true ; ArrayList < Integer > factors = new ArrayList < Integer > ( ) ; for ( int k = 2 ; k <= 10 ; k ++ ) { BigInteger big = new BigInteger ( s , k ) ; if ( big . isProbablePrime ( 10 ) ) { found = false ; break ; } int factor = - 1 ; for ( int m = 3 ; m < 1000 ; m += 2 ) { if ( big . mod ( new BigInteger ( \" \" + m ) ) . equals ( BigInteger . ZERO ) ) { factor = m ; break ; } } if ( factor == - 1 ) { found = false ; break ; } factors . add ( factor ) ; } if ( found ) { count ++ ; output += s ; for ( int k : factors ) { output += \" \u2581 \" + k ; } output += \" \\n \" ; } num += 2 ; } } BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( \" src / C - large . out \" ) , \" utf - 8\" ) ) ; bw . write ( output ) ; bw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" src / C - large . in \" ) ) ) ) ; String output = \" \" ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int n = sc . nextInt ( ) ; int j = sc . nextInt ( ) ; long num = ( 1l << ( n - 1 ) ) + 1 ; int count = 0 ; output += \" Case \u2581 # \" + i + \" : \\n \" ; while ( count < j ) { String s = Long . toBinaryString ( num ) ; boolean found = true ; ArrayList < Integer > factors = new ArrayList < Integer > ( ) ; for ( int k = 2 ; k <= 10 ; k ++ ) { BigInteger big = new BigInteger ( s , k ) ; if ( big . isProbablePrime ( 10 ) ) { found = false ; break ; } int factor = - 1 ; for ( int m = 3 ; m < 1000 ; m += 2 ) { if ( big . mod ( new BigInteger ( \" \" + m ) ) . equals ( BigInteger . ZERO ) ) { factor = m ; break ; } } if ( factor == - 1 ) { found = false ; break ; } factors . add ( factor ) ; } if ( found ) { count ++ ; output += s ; for ( int k : factors ) { output += \" \u2581 \" + k ; } output += \" \\n \" ; } num += 2 ; } } BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( \" src / C - large . out \" ) , \" utf - 8\" ) ) ; bw . write ( output ) ; bw . close ( ) ; }"]], "functions_class": []}, {"id": "20", "code": "package lab6zp ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Lab6ZP { public static String makeit ( int i ) { String s = \"11\" ; int k = 14 ; while ( k > 0 ) { k -- ; if ( i % 2 == 0 ) { s += \"11\" ; } else { s += \"00\" ; } i /= 2 ; } s += \"11\" ; return s ; } public static void main ( String [ ] args ) { System . out . println ( \" Case \u2581 # 1 : \" ) ; for ( int i = 0 ; i < 500 ; i ++ ) { String s = makeit ( i ) ; System . out . println ( s + \" \u2581 3 \u2581 4 \u2581 5 \u2581 6 \u2581 7 \u2581 8 \u2581 9 \u2581 10 \u2581 11\" ) ; } } }", "functions_standalone": [["makeit", "public static String makeit ( int i ) { String s = \"11\" ; int k = 14 ; while ( k > 0 ) { k -- ; if ( i % 2 == 0 ) { s += \"11\" ; } else { s += \"00\" ; } i /= 2 ; } s += \"11\" ; return s ; }"], ["main", "public static void main ( String [ ] args ) { System . out . println ( \" Case \u2581 # 1 : \" ) ; for ( int i = 0 ; i < 500 ; i ++ ) { String s = makeit ( i ) ; System . out . println ( s + \" \u2581 3 \u2581 4 \u2581 5 \u2581 6 \u2581 7 \u2581 8 \u2581 9 \u2581 10 \u2581 11\" ) ; } }"]], "functions_class": []}, {"id": "8", "code": "import java . math . BigInteger ; public class C { public static void main ( String [ ] args ) { int N = 32 ; int J = 500 ; System . out . println ( \" Case \u2581 # 1 : \" ) ; for ( int i = 0 ; i < J ; i ++ ) { String bitmask = Integer . toBinaryString ( i ) ; while ( bitmask . length ( ) + 2 < N / 2 ) { bitmask = '0' + bitmask ; } String divisor = String . format ( \"1 % s1\" , bitmask ) ; String jamcoin = divisor + divisor ; System . out . print ( jamcoin ) ; for ( int base = 2 ; base <= 10 ; base ++ ) { System . out . print ( \" \u2581 \" + new BigInteger ( divisor , base ) ) ; } System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int N = 32 ; int J = 500 ; System . out . println ( \" Case \u2581 # 1 : \" ) ; for ( int i = 0 ; i < J ; i ++ ) { String bitmask = Integer . toBinaryString ( i ) ; while ( bitmask . length ( ) + 2 < N / 2 ) { bitmask = '0' + bitmask ; } String divisor = String . format ( \"1 % s1\" , bitmask ) ; String jamcoin = divisor + divisor ; System . out . print ( jamcoin ) ; for ( int base = 2 ; base <= 10 ; base ++ ) { System . out . print ( \" \u2581 \" + new BigInteger ( divisor , base ) ) ; } System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "16", "code": "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class CoinJam { public static final PrintStream out = System . out ; public static final BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; public int numCases ; public void doCase ( int caseNumber ) throws Exception { String line = in . readLine ( ) ; Scanner scan = new Scanner ( line ) ; int N = scan . nextInt ( ) ; int J = scan . nextInt ( ) ; String divisor = \"1\" ; for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { divisor += \"0\" ; } divisor += \"1\" ; for ( int i = 0 ; i < J ; i ++ ) { String coin = \"1\" ; coin += pad ( Integer . toString ( i , 2 ) , N / 2 - 2 ) ; coin += \"11\" ; coin += pad ( Integer . toString ( i , 2 ) , N / 2 - 2 ) ; coin += \"1\" ; System . out . print ( coin ) ; for ( int base = 2 ; base <= 10 ; base ++ ) { System . out . print ( \" \u2581 \" ) ; System . out . print ( new BigInteger ( divisor , base ) ) ; } System . out . println ( ) ; } } String pad ( String s , int len ) { String res = \" \" ; for ( int i = s . length ( ) ; i < len ; i ++ ) { res += \"0\" ; } res += s ; return res ; } public void run ( ) throws Exception { numCases = Integer . parseInt ( in . readLine ( ) . trim ( ) ) ; for ( int i = 1 ; i <= numCases ; i ++ ) { out . print ( \" Case \u2581 # \" + i + \" : \\n \" ) ; doCase ( i ) ; } } public static void main ( String [ ] args ) throws Exception { new CoinJam ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new CoinJam ( ) . run ( ) ; }"]], "functions_class": [["doCase", "public void doCase ( int caseNumber ) throws Exception { String line = in . readLine ( ) ; Scanner scan = new Scanner ( line ) ; int N = scan . nextInt ( ) ; int J = scan . nextInt ( ) ; String divisor = \"1\" ; for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { divisor += \"0\" ; } divisor += \"1\" ; for ( int i = 0 ; i < J ; i ++ ) { String coin = \"1\" ; coin += pad ( Integer . toString ( i , 2 ) , N / 2 - 2 ) ; coin += \"11\" ; coin += pad ( Integer . toString ( i , 2 ) , N / 2 - 2 ) ; coin += \"1\" ; System . out . print ( coin ) ; for ( int base = 2 ; base <= 10 ; base ++ ) { System . out . print ( \" \u2581 \" ) ; System . out . print ( new BigInteger ( divisor , base ) ) ; } System . out . println ( ) ; } }"], ["pad", "String pad ( String s , int len ) { String res = \" \" ; for ( int i = s . length ( ) ; i < len ; i ++ ) { res += \"0\" ; } res += s ; return res ; }"], ["run", "public void run ( ) throws Exception { numCases = Integer . parseInt ( in . readLine ( ) . trim ( ) ) ; for ( int i = 1 ; i <= numCases ; i ++ ) { out . print ( \" Case \u2581 # \" + i + \" : \\n \" ) ; doCase ( i ) ; } }"]]}, {"id": "14", "code": "import java . io . * ; import java . util . * ; public class C { static long value ( int i , int m , int b ) { long n = 1 ; for ( int k = 0 ; k < m ; k ++ ) { n = n * b + i % 2 ; i /= 2 ; } return n * b + 1 ; } public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int t = 1 ; t <= T ; t ++ ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int j = Integer . parseInt ( st . nextToken ( ) ) ; pw . println ( \" Case \u2581 # \" + t + \" : \" ) ; int m = n / 2 - 2 ; for ( int i = 0 ; i < j ; i ++ ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"1\" ) ; for ( int k = 0 ; k < m ; k ++ ) sb . append ( ( i & 1 << k ) == 0 ? \"0\" : \"1\" ) ; sb . append ( \"11\" ) ; for ( int k = 0 ; k < m ; k ++ ) sb . append ( ( i & 1 << k ) == 0 ? \"0\" : \"1\" ) ; sb . append ( \"1\" ) ; for ( int b = 2 ; b <= 10 ; b ++ ) sb . append ( \" \u2581 \" + value ( i , m , b ) ) ; pw . println ( sb ) ; } } pw . close ( ) ; } }", "functions_standalone": [["value", "static long value ( int i , int m , int b ) { long n = 1 ; for ( int k = 0 ; k < m ; k ++ ) { n = n * b + i % 2 ; i /= 2 ; } return n * b + 1 ; }"], ["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int t = 1 ; t <= T ; t ++ ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int j = Integer . parseInt ( st . nextToken ( ) ) ; pw . println ( \" Case \u2581 # \" + t + \" : \" ) ; int m = n / 2 - 2 ; for ( int i = 0 ; i < j ; i ++ ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"1\" ) ; for ( int k = 0 ; k < m ; k ++ ) sb . append ( ( i & 1 << k ) == 0 ? \"0\" : \"1\" ) ; sb . append ( \"11\" ) ; for ( int k = 0 ; k < m ; k ++ ) sb . append ( ( i & 1 << k ) == 0 ? \"0\" : \"1\" ) ; sb . append ( \"1\" ) ; for ( int b = 2 ; b <= 10 ; b ++ ) sb . append ( \" \u2581 \" + value ( i , m , b ) ) ; pw . println ( sb ) ; } } pw . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "from sympy import * NEW_LINE import random NEW_LINE n = 32 NEW_LINE j = 500 NEW_LINE arr = [ ] NEW_LINE f = open ( \" out . txt \" , \" w \" ) NEW_LINE def findDivisor ( x ) : NEW_LINE INDENT res = 2 NEW_LINE while x % res != 0 and res < 100 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT for i in xrange ( 2 ** ( n - 2 ) ) : NEW_LINE INDENT t = bin ( i ) [ 2 : ] NEW_LINE t = \"0\" * ( n - 2 - len ( t ) ) + t NEW_LINE t = \"1\" + t + \"1\" NEW_LINE ok = True NEW_LINE for base in xrange ( 2 , 11 ) : NEW_LINE INDENT if isprime ( int ( t , base ) ) or findDivisor ( int ( t , base ) ) == 100 : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT if ok : NEW_LINE INDENT data = [ ] NEW_LINE data . append ( t ) NEW_LINE for base in xrange ( 2 , 11 ) : NEW_LINE INDENT num = int ( t , base ) NEW_LINE data . append ( str ( findDivisor ( num ) ) ) NEW_LINE DEDENT arr . append ( data ) NEW_LINE if len ( arr ) == j : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print >> f , \" Case \u2581 # 1 : \" NEW_LINE for l in arr : NEW_LINE INDENT print >> f , ' \u2581 ' . join ( l ) NEW_LINE DEDENT", "functions_standalone": [["findDivisor", "def findDivisor ( x ) : NEW_LINE INDENT res = 2 NEW_LINE while x % res != 0 and res < 100 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import os , sys , ljqpy , time , random NEW_LINE time . clock ( ) NEW_LINE def CheckNotPrime ( x ) : NEW_LINE INDENT if x % 2 == 0 : return 2 NEW_LINE for i in range ( 3 , 101 , 2 ) : NEW_LINE INDENT if i >= x : break NEW_LINE if x % i == 0 : return i NEW_LINE DEDENT return 0 NEW_LINE DEDENT def Run ( n , j , fout ) : NEW_LINE INDENT random . seed ( 1333 ) NEW_LINE st = set ( ) NEW_LINE while j > 0 : NEW_LINE INDENT v = [ 1 ] + [ random . randint ( 0 , 1 ) for x in range ( n - 2 ) ] + [ 1 ] NEW_LINE zz = ' ' . join ( str ( x ) for x in v ) NEW_LINE if zz in st : continue NEW_LINE st . add ( zz ) NEW_LINE rt = [ ] NEW_LINE for b in range ( 2 , 11 ) : NEW_LINE INDENT z = 0 NEW_LINE for c in v : z = z * b + c NEW_LINE rt . append ( CheckNotPrime ( z ) ) NEW_LINE if rt [ - 1 ] == 0 : break NEW_LINE DEDENT if rt [ - 1 ] != 0 : NEW_LINE INDENT print ( zz , rt ) NEW_LINE fout . write ( zz + ' \u2581 ' ) NEW_LINE fout . write ( ' \u2581 ' . join ( str ( x ) for x in rt ) ) NEW_LINE fout . write ( ' \\n ' ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT lst = ljqpy . LoadList ( ' input . txt ' ) NEW_LINE outf = ' C - large . out ' NEW_LINE with open ( outf , ' w ' ) as fout : NEW_LINE INDENT fout . write ( ' Case \u2581 # 1 : \\n ' ) NEW_LINE Run ( 32 , 500 , fout ) NEW_LINE DEDENT os . system ( outf ) NEW_LINE print ( ' completed ' ) NEW_LINE", "functions_standalone": [["CheckNotPrime", "def CheckNotPrime ( x ) : NEW_LINE INDENT if x % 2 == 0 : return 2 NEW_LINE for i in range ( 3 , 101 , 2 ) : NEW_LINE INDENT if i >= x : break NEW_LINE if x % i == 0 : return i NEW_LINE DEDENT return 0 NEW_LINE DEDENT"], ["Run", "def Run ( n , j , fout ) : NEW_LINE INDENT random . seed ( 1333 ) NEW_LINE st = set ( ) NEW_LINE while j > 0 : NEW_LINE INDENT v = [ 1 ] + [ random . randint ( 0 , 1 ) for x in range ( n - 2 ) ] + [ 1 ] NEW_LINE zz = ' ' . join ( str ( x ) for x in v ) NEW_LINE if zz in st : continue NEW_LINE st . add ( zz ) NEW_LINE rt = [ ] NEW_LINE for b in range ( 2 , 11 ) : NEW_LINE INDENT z = 0 NEW_LINE for c in v : z = z * b + c NEW_LINE rt . append ( CheckNotPrime ( z ) ) NEW_LINE if rt [ - 1 ] == 0 : break NEW_LINE DEDENT if rt [ - 1 ] != 0 : NEW_LINE INDENT print ( zz , rt ) NEW_LINE fout . write ( zz + ' \u2581 ' ) NEW_LINE fout . write ( ' \u2581 ' . join ( str ( x ) for x in rt ) ) NEW_LINE fout . write ( ' \\n ' ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "7", "code": "TEST = ' large ' NEW_LINE IN = ' C - { } . in ' . format ( TEST ) NEW_LINE OUT = ' C - { } . out ' . format ( TEST ) NEW_LINE MAX_PRIME = 10000 NEW_LINE def sieve ( lim ) : NEW_LINE INDENT p = [ True ] * lim NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( lim ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT for j in range ( i * 2 , lim , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return [ i for i , v in enumerate ( p ) if v ] NEW_LINE DEDENT primes = sieve ( MAX_PRIME ) NEW_LINE def check ( s ) : NEW_LINE INDENT r = [ ] NEW_LINE for b in range ( 2 , 11 ) : NEW_LINE INDENT x = int ( s , b ) NEW_LINE for p in primes : NEW_LINE INDENT if x % p == 0 : NEW_LINE INDENT r . append ( p ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def run ( n , j ) : NEW_LINE INDENT maxm = 2 ** ( n - 2 ) NEW_LINE fmt = '1 { { :0 { } b } }1' . format ( n - 2 ) NEW_LINE coins = [ ] NEW_LINE for m in range ( maxm ) : NEW_LINE INDENT s = fmt . format ( m ) NEW_LINE r = check ( s ) NEW_LINE if r is not None : NEW_LINE INDENT coins . append ( ( s , r ) ) NEW_LINE if len ( coins ) == j : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT assert len ( coins ) == j NEW_LINE return [ ' { } \u2581 { } ' . format ( s , ' \u2581 ' . join ( map ( str , r ) ) ) for s , r in coins ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( IN ) as fin , open ( OUT , ' w ' ) as fout : NEW_LINE INDENT t = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , j = map ( int , fin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE res = run ( n , j ) NEW_LINE print ( ' Case \u2581 # { } : ' . format ( i + 1 ) , file = fout ) NEW_LINE for line in res : NEW_LINE INDENT print ( line , file = fout ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["sieve", "def sieve ( lim ) : NEW_LINE INDENT p = [ True ] * lim NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( lim ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT for j in range ( i * 2 , lim , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return [ i for i , v in enumerate ( p ) if v ] NEW_LINE DEDENT"], ["check", "def check ( s ) : NEW_LINE INDENT r = [ ] NEW_LINE for b in range ( 2 , 11 ) : NEW_LINE INDENT x = int ( s , b ) NEW_LINE for p in primes : NEW_LINE INDENT if x % p == 0 : NEW_LINE INDENT r . append ( p ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT"], ["run", "def run ( n , j ) : NEW_LINE INDENT maxm = 2 ** ( n - 2 ) NEW_LINE fmt = '1 { { :0 { } b } }1' . format ( n - 2 ) NEW_LINE coins = [ ] NEW_LINE for m in range ( maxm ) : NEW_LINE INDENT s = fmt . format ( m ) NEW_LINE r = check ( s ) NEW_LINE if r is not None : NEW_LINE INDENT coins . append ( ( s , r ) ) NEW_LINE if len ( coins ) == j : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT assert len ( coins ) == j NEW_LINE return [ ' { } \u2581 { } ' . format ( s , ' \u2581 ' . join ( map ( str , r ) ) ) for s , r in coins ] NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT with open ( IN ) as fin , open ( OUT , ' w ' ) as fout : NEW_LINE INDENT t = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , j = map ( int , fin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE res = run ( n , j ) NEW_LINE print ( ' Case \u2581 # { } : ' . format ( i + 1 ) , file = fout ) NEW_LINE for line in res : NEW_LINE INDENT print ( line , file = fout ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "18", "code": "import sys NEW_LINE fin = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fout = open ( \" p3 . out \" , \" w \" ) NEW_LINE fin . readline ( ) NEW_LINE N , J = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE fout . write ( \" Case \u2581 # 1 : \\n \" ) NEW_LINE def conv_base ( l , base ) : NEW_LINE INDENT ret = 1 + base ** ( N - 1 ) NEW_LINE ret += sum ( map ( lambda x : base ** x , l ) ) NEW_LINE return ret NEW_LINE DEDENT def lcp ( n ) : NEW_LINE INDENT for m in xrange ( 2 , min ( n , 1000 ) ) : NEW_LINE INDENT if n % m == 0 : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT ans = { 3 : 2 , 4 : 3 , 5 : 2 , 7 : 2 , 9 : 2 , 10 : 3 } NEW_LINE cur = [ 1 , 2 , 3 , 4 ] NEW_LINE while J > 0 : NEW_LINE INDENT j = 3 NEW_LINE for i in xrange ( len ( cur ) - 1 ) : NEW_LINE INDENT if cur [ i ] + 1 == cur [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT j = i NEW_LINE break NEW_LINE DEDENT DEDENT cur [ j ] += 1 NEW_LINE for i in xrange ( j ) : NEW_LINE INDENT cur [ i ] = i + 1 NEW_LINE DEDENT ans [ 2 ] = lcp ( conv_base ( cur , 2 ) ) NEW_LINE ans [ 6 ] = lcp ( conv_base ( cur , 6 ) ) NEW_LINE ans [ 8 ] = lcp ( conv_base ( cur , 8 ) ) NEW_LINE if ans [ 2 ] < 0 or ans [ 6 ] < 0 or ans [ 8 ] < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT J -= 1 NEW_LINE fout . write ( str ( conv_base ( cur , 10 ) ) + ' \u2581 ' ) NEW_LINE for i in xrange ( 2 , 10 ) : NEW_LINE INDENT fout . write ( str ( ans [ i ] ) + ' \u2581 ' ) NEW_LINE DEDENT fout . write ( str ( ans [ 10 ] ) + ' \\n ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["conv_base", "def conv_base ( l , base ) : NEW_LINE INDENT ret = 1 + base ** ( N - 1 ) NEW_LINE ret += sum ( map ( lambda x : base ** x , l ) ) NEW_LINE return ret NEW_LINE DEDENT"]], "functions_class": []}, {"id": "13", "code": "import itertools NEW_LINE N = 32 NEW_LINE J = 500 NEW_LINE print ( \" Case \u2581 # 1 : \" ) NEW_LINE for _ , tup in zip ( range ( J ) , itertools . product ( [ '00' , '11' ] , repeat = N // 2 - 1 ) ) : NEW_LINE INDENT coin = '1 % s1 \u2581 3 \u2581 4 \u2581 5 \u2581 6 \u2581 7 \u2581 8 \u2581 9 \u2581 10 \u2581 11' % ( ' ' . join ( tup ) , ) NEW_LINE print ( coin ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_16_04", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class Round0D { int cases ; void process ( Scanner scanner , PrintStream out ) throws IOException { cases = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int curCase = 0 ; curCase < cases ; curCase ++ ) { long K = scanner . nextLong ( ) ; long C = scanner . nextLong ( ) ; long S = scanner . nextLong ( ) ; if ( C * S < K ) { out . println ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \u2581 IMPOSSIBLE \" ) ; } else { out . print ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \" ) ; long k = 0 ; for ( long s = 0 ; s < S && k < K ; s ++ ) { long num = 0 ; for ( int i = 0 ; i < C ; i ++ ) { num = num * K + ( k % K ) ; k ++ ; } out . print ( ' \u2581 ' ) ; out . print ( num + 1 ) ; } out . println ( ) ; } } } Round0D ( ) throws IOException { Scanner in = new Scanner ( new File ( \" C : \\\\ Users \\\\ Olaf \\\\ Downloads \\\\ D - large . in \" ) ) ; PrintStream out = new PrintStream ( \" out - D - large . txt \" ) ; process ( in , out ) ; in . close ( ) ; out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new Round0D ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Round0D ( ) ; }"]], "functions_class": [["process", "void process ( Scanner scanner , PrintStream out ) throws IOException { cases = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int curCase = 0 ; curCase < cases ; curCase ++ ) { long K = scanner . nextLong ( ) ; long C = scanner . nextLong ( ) ; long S = scanner . nextLong ( ) ; if ( C * S < K ) { out . println ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \u2581 IMPOSSIBLE \" ) ; } else { out . print ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \" ) ; long k = 0 ; for ( long s = 0 ; s < S && k < K ; s ++ ) { long num = 0 ; for ( int i = 0 ; i < C ; i ++ ) { num = num * K + ( k % K ) ; k ++ ; } out . print ( ' \u2581 ' ) ; out . print ( num + 1 ) ; } out . println ( ) ; } } }"], ["Round0D", "Round0D ( ) throws IOException { Scanner in = new Scanner ( new File ( \" C : \\\\ Users \\\\ Olaf \\\\ Downloads \\\\ D - large . in \" ) ) ; PrintStream out = new PrintStream ( \" out - D - large . txt \" ) ; process ( in , out ) ; in . close ( ) ; out . close ( ) ; }"]]}, {"id": "13", "code": "package qualification ; import java . io . * ; import java . math . * ; import java . util . * ; public class D_Fractiles { private static final String FILENAME = \" data / qualification / D - large \" ; private static final boolean STANDARD_OUTPUT = false ; private static BufferedReader in = null ; private static PrintStream out = null ; public static void main ( String [ ] args ) throws Throwable { try ( BufferedReader reader = in = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ) { try ( PrintStream writer = out = ! STANDARD_OUTPUT ? new PrintStream ( FILENAME + \" . out \" ) : System . out ) { process ( ) ; } } } private static void process ( ) throws Throwable { for ( int caseNumber = 1 , T = Integer . parseInt ( in . readLine ( ) ) ; caseNumber <= T ; caseNumber ++ ) { StringTokenizer tokenizer = new StringTokenizer ( in . readLine ( ) ) ; K = Integer . parseInt ( tokenizer . nextToken ( ) ) ; C = Integer . parseInt ( tokenizer . nextToken ( ) ) ; S = Integer . parseInt ( tokenizer . nextToken ( ) ) ; positions = new ArrayList < > ( ) ; visited = new HashSet < > ( ) ; f ( BigInteger . ZERO , 0 ) ; out . print ( \" Case \u2581 # \" + caseNumber + \" : \" ) ; if ( positions . size ( ) <= S ) { for ( BigInteger position : positions ) { out . print ( \" \u2581 \" + position . add ( BigInteger . ONE ) ) ; } out . println ( ) ; } else { out . println ( \" \u2581 IMPOSSIBLE \" ) ; } } } static int K , C , S ; static List < BigInteger > positions ; static Set < Integer > visited ; static void f ( BigInteger start , int c ) { if ( c == C || visited . size ( ) == K ) { positions . add ( start ) ; } else { BigInteger childSize = BigInteger . valueOf ( K ) . pow ( C - c - 1 ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( ! visited . contains ( i ) ) { visited . add ( i ) ; f ( start . add ( childSize . multiply ( BigInteger . valueOf ( i ) ) ) , c + 1 ) ; if ( c > 0 ) break ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { try ( BufferedReader reader = in = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ) { try ( PrintStream writer = out = ! STANDARD_OUTPUT ? new PrintStream ( FILENAME + \" . out \" ) : System . out ) { process ( ) ; } } }"], ["process", "private static void process ( ) throws Throwable { for ( int caseNumber = 1 , T = Integer . parseInt ( in . readLine ( ) ) ; caseNumber <= T ; caseNumber ++ ) { StringTokenizer tokenizer = new StringTokenizer ( in . readLine ( ) ) ; K = Integer . parseInt ( tokenizer . nextToken ( ) ) ; C = Integer . parseInt ( tokenizer . nextToken ( ) ) ; S = Integer . parseInt ( tokenizer . nextToken ( ) ) ; positions = new ArrayList < > ( ) ; visited = new HashSet < > ( ) ; f ( BigInteger . ZERO , 0 ) ; out . print ( \" Case \u2581 # \" + caseNumber + \" : \" ) ; if ( positions . size ( ) <= S ) { for ( BigInteger position : positions ) { out . print ( \" \u2581 \" + position . add ( BigInteger . ONE ) ) ; } out . println ( ) ; } else { out . println ( \" \u2581 IMPOSSIBLE \" ) ; } } }"], ["f", "static void f ( BigInteger start , int c ) { if ( c == C || visited . size ( ) == K ) { positions . add ( start ) ; } else { BigInteger childSize = BigInteger . valueOf ( K ) . pow ( C - c - 1 ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( ! visited . contains ( i ) ) { visited . add ( i ) ; f ( start . add ( childSize . multiply ( BigInteger . valueOf ( i ) ) ) , c + 1 ) ; if ( c > 0 ) break ; } } } }"]], "functions_class": []}, {"id": "17", "code": "package lab6zp ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Lab6ZP { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { long k = in . nextInt ( ) ; long c = in . nextInt ( ) ; int s = in . nextInt ( ) ; System . out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; if ( c * s < k ) { System . out . println ( \" IMPOSSIBLE \" ) ; } else { long val = 0 ; while ( s > 0 ) { long exp = 1 ; long total = 0 ; while ( exp < Math . pow ( k , c ) ) { total += val * exp ; exp *= k ; if ( val < k - 1 ) { val ++ ; } } s -- ; System . out . print ( total + 1 ) ; if ( total + 1 == Math . pow ( k , c ) ) { s = 0 ; } if ( s != 0 ) { System . out . print ( \" \u2581 \" ) ; } else { System . out . println ( ) ; } } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { long k = in . nextInt ( ) ; long c = in . nextInt ( ) ; int s = in . nextInt ( ) ; System . out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; if ( c * s < k ) { System . out . println ( \" IMPOSSIBLE \" ) ; } else { long val = 0 ; while ( s > 0 ) { long exp = 1 ; long total = 0 ; while ( exp < Math . pow ( k , c ) ) { total += val * exp ; exp *= k ; if ( val < k - 1 ) { val ++ ; } } s -- ; System . out . print ( total + 1 ) ; if ( total + 1 == Math . pow ( k , c ) ) { s = 0 ; } if ( s != 0 ) { System . out . print ( \" \u2581 \" ) ; } else { System . out . println ( ) ; } } } } }"]], "functions_class": []}, {"id": "16", "code": "package cj2016 . qr ; import java . io . * ; import java . util . * ; public class D { Scanner sc ; PrintWriter pw ; int K , C , S ; public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" D - large \" ; try { new D ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } } public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; } void read ( Scanner sc ) { K = sc . nextInt ( ) ; C = sc . nextInt ( ) ; S = sc . nextInt ( ) ; } void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; } void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; } public void solve ( ) { if ( C * S < K ) { println ( \" IMPOSSIBLE \" ) ; return ; } int M = ( K + C - 1 ) / C ; long [ ] pos = new long [ M ] ; for ( int i = 0 ; i < K ; i ++ ) { pos [ i / C ] += pow ( K , i % C ) * i ; } for ( int i = 0 ; i < M ; i ++ ) print ( ( pos [ i ] + 1 ) + ( i == M - 1 ? \" \\n \" : \" \u2581 \" ) ) ; } long pow ( long a , int b ) { long ans = 1 ; for ( int i = 0 ; i < b ; i ++ ) ans *= a ; return ans ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" D - large \" ; try { new D ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } }"]], "functions_class": [["run", "public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; }"], ["read", "void read ( Scanner sc ) { K = sc . nextInt ( ) ; C = sc . nextInt ( ) ; S = sc . nextInt ( ) ; }"], ["print", "void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; }"], ["println", "void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; }"], ["solve", "public void solve ( ) { if ( C * S < K ) { println ( \" IMPOSSIBLE \" ) ; return ; } int M = ( K + C - 1 ) / C ; long [ ] pos = new long [ M ] ; for ( int i = 0 ; i < K ; i ++ ) { pos [ i / C ] += pow ( K , i % C ) * i ; } for ( int i = 0 ; i < M ; i ++ ) print ( ( pos [ i ] + 1 ) + ( i == M - 1 ? \" \\n \" : \" \u2581 \" ) ) ; }"], ["pow", "long pow ( long a , int b ) { long ans = 1 ; for ( int i = 0 ; i < b ; i ++ ) ans *= a ; return ans ; }"]]}, {"id": "4", "code": "import java . io . * ; import java . util . * ; public class D { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" src / D - large . in \" ) ) ) ) ; String output = \" \" ; int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int k = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; if ( s * c < k ) { output += \" Case \u2581 # \" + i + \" : \u2581 IMPOSSIBLE \\n \" ; continue ; } ArrayList < Long > nums = new ArrayList < Long > ( ) ; for ( int j = 0 ; j < s ; j ++ ) { if ( j * c >= k ) break ; long next = 0 ; long mult = 1 ; for ( int m = 0 ; m < c ; m ++ ) { if ( j * c + m >= k ) break ; next += ( j * c + m ) * mult ; mult *= k ; } next ++ ; nums . add ( next ) ; } String toAdd = \" \" ; for ( int j = 0 ; j < nums . size ( ) ; j ++ ) { toAdd += \" \u2581 \" + nums . get ( j ) ; } output += \" Case \u2581 # \" + i + \" : \" + toAdd + \" \\n \" ; } BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( \" src / D - large . out \" ) , \" utf - 8\" ) ) ; bw . write ( output ) ; bw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" src / D - large . in \" ) ) ) ) ; String output = \" \" ; int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int k = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; if ( s * c < k ) { output += \" Case \u2581 # \" + i + \" : \u2581 IMPOSSIBLE \\n \" ; continue ; } ArrayList < Long > nums = new ArrayList < Long > ( ) ; for ( int j = 0 ; j < s ; j ++ ) { if ( j * c >= k ) break ; long next = 0 ; long mult = 1 ; for ( int m = 0 ; m < c ; m ++ ) { if ( j * c + m >= k ) break ; next += ( j * c + m ) * mult ; mult *= k ; } next ++ ; nums . add ( next ) ; } String toAdd = \" \" ; for ( int j = 0 ; j < nums . size ( ) ; j ++ ) { toAdd += \" \u2581 \" + nums . get ( j ) ; } output += \" Case \u2581 # \" + i + \" : \" + toAdd + \" \\n \" ; } BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( \" src / D - large . out \" ) , \" utf - 8\" ) ) ; bw . write ( output ) ; bw . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "import sys NEW_LINE sys . stdin = open ( \" data . txt \" ) NEW_LINE sys . stdout = open ( \" out . txt \" , \" w \" ) NEW_LINE input = sys . stdin . readline NEW_LINE for case in range ( int ( input ( ) ) ) : NEW_LINE INDENT k , c , s = map ( int , input ( ) . split ( ) ) NEW_LINE if c * s < k : print ( \" Case \u2581 # % s : \u2581 IMPOSSIBLE \" % ( case + 1 ) ) NEW_LINE else : NEW_LINE INDENT check = [ ] NEW_LINE num = 0 NEW_LINE carry = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT num *= k NEW_LINE num += i NEW_LINE carry += 1 NEW_LINE if carry == c : NEW_LINE INDENT check . append ( num + 1 ) NEW_LINE carry = 0 NEW_LINE num = 0 NEW_LINE DEDENT DEDENT if carry : check . append ( num + 1 ) NEW_LINE print ( \" Case \u2581 # % s : \u2581 % s \" % ( case + 1 , \" \u2581 \" . join ( map ( str , check ) ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "9", "code": "filename = \" D - large \" NEW_LINE fin = open ( filename + \" . in \" , \" r \" ) NEW_LINE fout = open ( filename + \" . out \" , \" w \" ) NEW_LINE casenum = int ( fin . readline ( ) ) NEW_LINE for ite in range ( casenum ) : NEW_LINE INDENT in_list = fin . readline ( ) . split ( ) NEW_LINE K = int ( in_list [ 0 ] ) NEW_LINE C = int ( in_list [ 1 ] ) NEW_LINE S = int ( in_list [ 2 ] ) NEW_LINE Smin = ( K - 1 ) // C + 1 NEW_LINE if S < ( K - 1 ) // C + 1 : NEW_LINE INDENT return_str = \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT return_str = ' ' NEW_LINE for jte in range ( Smin - 1 ) : NEW_LINE INDENT next_num = 0 NEW_LINE for kte in range ( C ) : NEW_LINE INDENT next_num *= K NEW_LINE next_num += kte + C * jte NEW_LINE DEDENT return_str += str ( next_num + 1 ) + ' \u2581 ' NEW_LINE DEDENT next_num = 0 NEW_LINE for kte in range ( K - C , K ) : NEW_LINE INDENT next_num *= K NEW_LINE if kte >= 0 : NEW_LINE INDENT next_num += kte NEW_LINE DEDENT DEDENT return_str += str ( next_num + 1 ) NEW_LINE DEDENT fout . write ( \" Case \u2581 # { 0 } : \u2581 { 1 } \\n \" . format ( ite + 1 , return_str ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "7", "code": "import os , inspect NEW_LINE problemName = ' fractiles ' NEW_LINE runOnRealData = True NEW_LINE def solution ( K , C , S ) : NEW_LINE INDENT necessaryTiles = ( K + C - 1 ) / C NEW_LINE if S < necessaryTiles : NEW_LINE INDENT return [ ' IMPOSSIBLE ' ] NEW_LINE DEDENT result = [ ] NEW_LINE k = 0 NEW_LINE level = 0 NEW_LINE tile = 0 NEW_LINE while len ( result ) < necessaryTiles : NEW_LINE INDENT tile = ( tile * K ) + min ( k , K - 1 ) NEW_LINE level += 1 NEW_LINE k += 1 NEW_LINE if level == C : NEW_LINE INDENT result . append ( tile + 1 ) NEW_LINE level = 0 NEW_LINE tile = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT currentDir = os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) NEW_LINE inputString = ' D - large . in ' NEW_LINE outputString = problemName + ( ' _ example _ output ' if not runOnRealData else ' _ output ' ) NEW_LINE inFile = os . path . join ( currentDir , ' inputfiles ' , inputString ) NEW_LINE outFile = os . path . join ( currentDir , ' outputfiles ' , ' % s . txt ' % outputString ) NEW_LINE if os . path . exists ( outFile ) : NEW_LINE INDENT os . remove ( outFile ) NEW_LINE DEDENT with open ( inFile , ' r ' ) as inputfile : NEW_LINE INDENT numberOfCases = int ( inputfile . readline ( ) ) NEW_LINE for case in xrange ( 1 , numberOfCases + 1 ) : NEW_LINE INDENT [ K , C , S ] = map ( int , inputfile . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE result = solution ( K , C , S ) NEW_LINE with open ( outFile , ' a ' ) as f : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( case , ' \u2581 ' . join ( map ( str , result ) ) ) ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["solution", "def solution ( K , C , S ) : NEW_LINE INDENT necessaryTiles = ( K + C - 1 ) / C NEW_LINE if S < necessaryTiles : NEW_LINE INDENT return [ ' IMPOSSIBLE ' ] NEW_LINE DEDENT result = [ ] NEW_LINE k = 0 NEW_LINE level = 0 NEW_LINE tile = 0 NEW_LINE while len ( result ) < necessaryTiles : NEW_LINE INDENT tile = ( tile * K ) + min ( k , K - 1 ) NEW_LINE level += 1 NEW_LINE k += 1 NEW_LINE if level == C : NEW_LINE INDENT result . append ( tile + 1 ) NEW_LINE level = 0 NEW_LINE tile = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "import math NEW_LINE import sys NEW_LINE def findsol ( K , C , S ) : NEW_LINE INDENT if C * S < K : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT a = [ ] NEW_LINE flag = 0 NEW_LINE for ii in range ( S ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for jj in range ( C ) : NEW_LINE INDENT x = ii * C + jj NEW_LINE if ( x >= K ) : NEW_LINE INDENT x = K - 1 NEW_LINE flag = 1 NEW_LINE DEDENT tmp . append ( x ) NEW_LINE DEDENT tmp2 = 0 NEW_LINE for jj in tmp : NEW_LINE INDENT tmp2 = K * tmp2 + jj NEW_LINE DEDENT a . append ( tmp2 + 1 ) NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( float ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( float ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT fidi = open ( ' D - large . in ' , ' r ' ) NEW_LINE fido = open ( ' a . out ' , ' w ' ) NEW_LINE T = fidi . readline ( ) NEW_LINE T = int ( T ) NEW_LINE for ii in range ( 1 , T + 1 ) : NEW_LINE INDENT tmp = fidi . readline ( ) NEW_LINE tmp = convertnums ( tmp ) NEW_LINE K = int ( tmp [ 0 ] ) NEW_LINE C = int ( tmp [ 1 ] ) NEW_LINE S = int ( tmp [ 2 ] ) NEW_LINE a = findsol ( K , C , S ) NEW_LINE if ( a [ 0 ] == ' I ' ) : NEW_LINE INDENT fido . write ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' + a + ' \\n ' ) NEW_LINE print ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' + a ) NEW_LINE DEDENT else : NEW_LINE INDENT fido . write ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' ) NEW_LINE for jj in a : NEW_LINE INDENT fido . write ( str ( jj ) + ' \u2581 ' ) NEW_LINE DEDENT fido . write ( ' \\n ' ) NEW_LINE print ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' , str ( a ) ) NEW_LINE DEDENT DEDENT fidi . close ( ) NEW_LINE fido . close ( ) NEW_LINE", "functions_standalone": [["findsol", "def findsol ( K , C , S ) : NEW_LINE INDENT if C * S < K : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT a = [ ] NEW_LINE flag = 0 NEW_LINE for ii in range ( S ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for jj in range ( C ) : NEW_LINE INDENT x = ii * C + jj NEW_LINE if ( x >= K ) : NEW_LINE INDENT x = K - 1 NEW_LINE flag = 1 NEW_LINE DEDENT tmp . append ( x ) NEW_LINE DEDENT tmp2 = 0 NEW_LINE for jj in tmp : NEW_LINE INDENT tmp2 = K * tmp2 + jj NEW_LINE DEDENT a . append ( tmp2 + 1 ) NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT"], ["convertnums", "def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( float ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( float ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT"]], "functions_class": []}, {"id": "12", "code": "import sys NEW_LINE import math NEW_LINE def prework ( argv ) : NEW_LINE INDENT return \" nothing \" NEW_LINE DEDENT def base_conv ( i_list , from_base ) : NEW_LINE INDENT s = 0 NEW_LINE for i in reversed ( i_list ) : NEW_LINE INDENT s *= from_base NEW_LINE s += i NEW_LINE DEDENT return s NEW_LINE DEDENT def once ( ) : NEW_LINE INDENT [ k , c , s ] = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if s < math . ceil ( k / c ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT ans_list = list ( ) NEW_LINE for ic in range ( 0 , k , c ) : NEW_LINE INDENT l = list ( ) NEW_LINE for j in range ( c ) : NEW_LINE INDENT if ic + j >= k : NEW_LINE INDENT break NEW_LINE DEDENT l . append ( ic + j ) NEW_LINE DEDENT printerr ( l ) NEW_LINE ans_list . append ( base_conv ( l , k ) ) NEW_LINE DEDENT return \" \u2581 \" . join ( str ( x + 1 ) for x in ans_list ) NEW_LINE DEDENT def printerr ( * v ) : NEW_LINE INDENT print ( * v , file = sys . stderr ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT TT = int ( input ( ) ) NEW_LINE for tt in range ( 1 , TT + 1 ) : NEW_LINE INDENT printerr ( \" coping \u2581 Case \u2581 % d . . \" % ( tt ) ) NEW_LINE ans = once ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( tt , ( ans ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT msg = prework ( sys . argv ) NEW_LINE print ( \" prework \u2581 down \u2581 with \" , msg , file = sys . stderr ) NEW_LINE main ( ) NEW_LINE DEDENT", "functions_standalone": [["prework", "def prework ( argv ) : NEW_LINE INDENT return \" nothing \" NEW_LINE DEDENT"], ["base_conv", "def base_conv ( i_list , from_base ) : NEW_LINE INDENT s = 0 NEW_LINE for i in reversed ( i_list ) : NEW_LINE INDENT s *= from_base NEW_LINE s += i NEW_LINE DEDENT return s NEW_LINE DEDENT"], ["once", "def once ( ) : NEW_LINE INDENT [ k , c , s ] = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if s < math . ceil ( k / c ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT ans_list = list ( ) NEW_LINE for ic in range ( 0 , k , c ) : NEW_LINE INDENT l = list ( ) NEW_LINE for j in range ( c ) : NEW_LINE INDENT if ic + j >= k : NEW_LINE INDENT break NEW_LINE DEDENT l . append ( ic + j ) NEW_LINE DEDENT printerr ( l ) NEW_LINE ans_list . append ( base_conv ( l , k ) ) NEW_LINE DEDENT return \" \u2581 \" . join ( str ( x + 1 ) for x in ans_list ) NEW_LINE DEDENT"], ["printerr", "def printerr ( * v ) : NEW_LINE INDENT print ( * v , file = sys . stderr ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT TT = int ( input ( ) ) NEW_LINE for tt in range ( 1 , TT + 1 ) : NEW_LINE INDENT printerr ( \" coping \u2581 Case \u2581 % d . . \" % ( tt ) ) NEW_LINE ans = once ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( tt , ( ans ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_32", "java": [{"id": "4", "code": "import java . util . * ; public class B { static Scanner in ; public static void main ( String [ ] args ) { in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( ) ) ; } } public static String solve ( ) { String out = \" \" ; int B = in . nextInt ( ) ; long M = in . nextLong ( ) - 1 ; String binary = \" \" ; while ( M > 0 ) { binary += M % 2 ; M = M / 2 ; } System . err . println ( binary ) ; if ( binary . length ( ) > B - 2 ) { out = \" IMPOSSIBLE \" ; } else { out = \" POSSIBLE \" ; for ( int i = 0 ; i < B ; i ++ ) { String line = \" \" ; for ( int j = 0 ; j <= i ; j ++ ) { line += \"0\" ; } for ( int j = 0 ; j < B - 2 - i ; j ++ ) { line += \"1\" ; } if ( i < B - 1 ) { if ( i == 0 ) { line += \"1\" ; } else if ( i - 1 < binary . length ( ) ) { line += binary . charAt ( i - 1 ) ; } else { line += \"0\" ; } } out += \" \\n \" + line ; } } return out ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( ) ) ; } }"], ["solve", "public static String solve ( ) { String out = \" \" ; int B = in . nextInt ( ) ; long M = in . nextLong ( ) - 1 ; String binary = \" \" ; while ( M > 0 ) { binary += M % 2 ; M = M / 2 ; } System . err . println ( binary ) ; if ( binary . length ( ) > B - 2 ) { out = \" IMPOSSIBLE \" ; } else { out = \" POSSIBLE \" ; for ( int i = 0 ; i < B ; i ++ ) { String line = \" \" ; for ( int j = 0 ; j <= i ; j ++ ) { line += \"0\" ; } for ( int j = 0 ; j < B - 2 - i ; j ++ ) { line += \"1\" ; } if ( i < B - 1 ) { if ( i == 0 ) { line += \"1\" ; } else if ( i - 1 < binary . length ( ) ) { line += binary . charAt ( i - 1 ) ; } else { line += \"0\" ; } } out += \" \\n \" + line ; } } return out ; }"]], "functions_class": []}, {"id": "11", "code": "import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int x = 1 ; x <= t ; ++ x ) { int b = scanner . nextInt ( ) ; long m = scanner . nextLong ( ) ; System . out . print ( \" Case \u2581 # \" + x + \" : \u2581 \" ) ; if ( m > Math . pow ( 2 , b - 2 ) ) { System . out . print ( \" IMPOSSIBLE \\n \" ) ; continue ; } else System . out . print ( \" POSSIBLE \\n \" ) ; int [ ] [ ] slides = new int [ b ] [ b ] ; for ( int i = 0 ; i < b ; ++ i ) { for ( int j = i + 1 ; j < b ; ++ j ) { slides [ i ] [ j ] = 1 ; } } String str = Long . toBinaryString ( m - 1 ) + \" \" ; if ( str . equals ( \"0\" ) ) str = \" \" ; while ( str . length ( ) < b - 1 ) { str = \"0\" + str ; } str += \"1\" ; System . out . println ( str ) ; for ( int i = 1 ; i < b ; ++ i ) { for ( int j = 0 ; j < b ; ++ j ) { System . out . print ( slides [ i ] [ j ] ) ; } System . out . print ( \" \\n \" ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int x = 1 ; x <= t ; ++ x ) { int b = scanner . nextInt ( ) ; long m = scanner . nextLong ( ) ; System . out . print ( \" Case \u2581 # \" + x + \" : \u2581 \" ) ; if ( m > Math . pow ( 2 , b - 2 ) ) { System . out . print ( \" IMPOSSIBLE \\n \" ) ; continue ; } else System . out . print ( \" POSSIBLE \\n \" ) ; int [ ] [ ] slides = new int [ b ] [ b ] ; for ( int i = 0 ; i < b ; ++ i ) { for ( int j = i + 1 ; j < b ; ++ j ) { slides [ i ] [ j ] = 1 ; } } String str = Long . toBinaryString ( m - 1 ) + \" \" ; if ( str . equals ( \"0\" ) ) str = \" \" ; while ( str . length ( ) < b - 1 ) { str = \"0\" + str ; } str += \"1\" ; System . out . println ( str ) ; for ( int i = 1 ; i < b ; ++ i ) { for ( int j = 0 ; j < b ; ++ j ) { System . out . print ( slides [ i ] [ j ] ) ; } System . out . print ( \" \\n \" ) ; } } }"]], "functions_class": []}, {"id": "1", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class B { public static void main ( String [ ] args ) { new B ( ) . run ( ) ; } BufferedReader br ; StringTokenizer in ; PrintWriter out ; public String nextToken ( ) throws IOException { while ( in == null || ! in . hasMoreTokens ( ) ) { in = new StringTokenizer ( br . readLine ( ) ) ; } return in . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } public void solve ( ) throws IOException { int n = nextInt ( ) ; long b = nextLong ( ) ; if ( b > 1L << ( n - 2 ) ) { out . println ( \" IMPOSSIBLE \" ) ; return ; } int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { a [ i ] [ j ] = 1 ; } } b -- ; a [ 0 ] [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( b % 2 == 1 ) { a [ 0 ] [ i ] = 1 ; } b /= 2 ; } out . println ( \" POSSIBLE \" ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { out . print ( a [ i ] [ j ] ) ; } out . println ( ) ; } } public void run ( ) { try { br = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int t = nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { out . print ( String . format ( \" Case \u2581 # % d : \u2581 \" , i + 1 ) ) ; solve ( ) ; } out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new B ( ) . run ( ) ; }"]], "functions_class": [["nextToken", "public String nextToken ( ) throws IOException { while ( in == null || ! in . hasMoreTokens ( ) ) { in = new StringTokenizer ( br . readLine ( ) ) ; } return in . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "public long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; }"], ["solve", "public void solve ( ) throws IOException { int n = nextInt ( ) ; long b = nextLong ( ) ; if ( b > 1L << ( n - 2 ) ) { out . println ( \" IMPOSSIBLE \" ) ; return ; } int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { a [ i ] [ j ] = 1 ; } } b -- ; a [ 0 ] [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( b % 2 == 1 ) { a [ 0 ] [ i ] = 1 ; } b /= 2 ; } out . println ( \" POSSIBLE \" ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { out . print ( a [ i ] [ j ] ) ; } out . println ( ) ; } }"], ["run", "public void run ( ) { try { br = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int t = nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { out . print ( String . format ( \" Case \u2581 # % d : \u2581 \" , i + 1 ) ) ; solve ( ) ; } out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]]}, {"id": "0", "code": "import java . util . * ; import java . io . * ; public class B { static int N ; static int ans ; public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int B = input . nextInt ( ) ; long M = input . nextLong ( ) ; if ( M > ( 1L << ( B - 2 ) ) ) { System . out . printf ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE \\n \" , n + 1 ) ; continue ; } boolean [ ] [ ] slides = new boolean [ B ] [ B ] ; if ( M == ( 1L << ( B - 2 ) ) ) { for ( int i = 0 ; i < B ; i ++ ) for ( int j = i + 1 ; j < B ; j ++ ) slides [ i ] [ j ] = true ; } for ( int i = 0 ; i + 1 < B ; i ++ ) for ( int j = i + 1 ; j + 1 < B ; j ++ ) slides [ i ] [ j ] = true ; for ( int i = 0 ; i + 2 < B ; i ++ ) if ( ( M & ( 1L << i ) ) > 0 ) slides [ i + 1 ] [ B - 1 ] = true ; System . out . printf ( \" Case \u2581 # % d : \u2581 POSSIBLE \\n \" , n + 1 ) ; for ( int i = 0 ; i < B ; i ++ ) { for ( int j = 0 ; j < B ; j ++ ) System . out . print ( slides [ i ] [ j ] ? '1' : '0' ) ; System . out . println ( ) ; } } } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int B = input . nextInt ( ) ; long M = input . nextLong ( ) ; if ( M > ( 1L << ( B - 2 ) ) ) { System . out . printf ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE \\n \" , n + 1 ) ; continue ; } boolean [ ] [ ] slides = new boolean [ B ] [ B ] ; if ( M == ( 1L << ( B - 2 ) ) ) { for ( int i = 0 ; i < B ; i ++ ) for ( int j = i + 1 ; j < B ; j ++ ) slides [ i ] [ j ] = true ; } for ( int i = 0 ; i + 1 < B ; i ++ ) for ( int j = i + 1 ; j + 1 < B ; j ++ ) slides [ i ] [ j ] = true ; for ( int i = 0 ; i + 2 < B ; i ++ ) if ( ( M & ( 1L << i ) ) > 0 ) slides [ i + 1 ] [ B - 1 ] = true ; System . out . printf ( \" Case \u2581 # % d : \u2581 POSSIBLE \\n \" , n + 1 ) ; for ( int i = 0 ; i < B ; i ++ ) { for ( int j = 0 ; j < B ; j ++ ) System . out . print ( slides [ i ] [ j ] ? '1' : '0' ) ; System . out . println ( ) ; } } }"]], "functions_class": []}, {"id": "7", "code": "package Round1 ; import java . io . * ; public class B { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" / Users / chao / Downloads / B - large . in \" ) ) ; FileWriter out = new FileWriter ( \" / Users / chao / Desktop / B - large . txt \" ) ; String s = in . readLine ( ) ; int m = Integer . parseInt ( s ) ; for ( int cases = 1 ; cases <= m ; cases ++ ) { String [ ] ss = in . readLine ( ) . split ( \" \u2581 \" ) ; int B = Integer . parseInt ( ss [ 0 ] ) ; long M = Long . parseLong ( ss [ 1 ] ) ; out . write ( \" Case \u2581 # \" + cases + \" : \u2581 \" ) ; int n = B ; long max = pow ( B - 2 ) ; if ( max >= M ) { out . write ( \" POSSIBLE \\n \" ) ; int [ ] [ ] map = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map [ i ] [ j ] = 1 ; } } for ( int k = 1 ; k < n ; k ++ ) { if ( k != n - 1 ) max = max / 2 ; if ( max <= M ) { M -= max ; map [ 0 ] [ k ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { out . write ( \" \" + map [ i ] [ j ] ) ; } out . write ( \" \\n \" ) ; } } else { out . write ( \" IMPOSSIBLE \\n \" ) ; } } in . close ( ) ; out . flush ( ) ; out . close ( ) ; } private static long pow ( int n ) { long x = 1 ; for ( int i = 0 ; i < n ; i ++ ) { x *= 2 ; } return x ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" / Users / chao / Downloads / B - large . in \" ) ) ; FileWriter out = new FileWriter ( \" / Users / chao / Desktop / B - large . txt \" ) ; String s = in . readLine ( ) ; int m = Integer . parseInt ( s ) ; for ( int cases = 1 ; cases <= m ; cases ++ ) { String [ ] ss = in . readLine ( ) . split ( \" \u2581 \" ) ; int B = Integer . parseInt ( ss [ 0 ] ) ; long M = Long . parseLong ( ss [ 1 ] ) ; out . write ( \" Case \u2581 # \" + cases + \" : \u2581 \" ) ; int n = B ; long max = pow ( B - 2 ) ; if ( max >= M ) { out . write ( \" POSSIBLE \\n \" ) ; int [ ] [ ] map = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map [ i ] [ j ] = 1 ; } } for ( int k = 1 ; k < n ; k ++ ) { if ( k != n - 1 ) max = max / 2 ; if ( max <= M ) { M -= max ; map [ 0 ] [ k ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { out . write ( \" \" + map [ i ] [ j ] ) ; } out . write ( \" \\n \" ) ; } } else { out . write ( \" IMPOSSIBLE \\n \" ) ; } } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }"], ["pow", "private static long pow ( int n ) { long x = 1 ; for ( int i = 0 ; i < n ; i ++ ) { x *= 2 ; } return x ; }"]], "functions_class": []}], "python": [{"id": "3", "code": "def solve ( b , m ) : NEW_LINE INDENT if m > 2 ** ( b - 2 ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE return NEW_LINE DEDENT print ( \" POSSIBLE \" ) NEW_LINE if m == 2 ** ( b - 2 ) : NEW_LINE INDENT print ( \"0\" + \"1\" * ( b - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT l = [ ( m >> i ) & 1 for i in range ( b - 2 ) ] NEW_LINE print ( \"0\" + \" \" . join ( map ( str , reversed ( l ) ) ) + \"0\" ) NEW_LINE DEDENT for i in range ( 1 , b ) : NEW_LINE INDENT print ( \"0\" * ( i + 1 ) + \"1\" * ( b - i - 1 ) ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \" , end = \" \u2581 \" ) NEW_LINE b , m = map ( int , input ( ) . split ( ) ) NEW_LINE solve ( b , m ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( b , m ) : NEW_LINE INDENT if m > 2 ** ( b - 2 ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE return NEW_LINE DEDENT print ( \" POSSIBLE \" ) NEW_LINE if m == 2 ** ( b - 2 ) : NEW_LINE INDENT print ( \"0\" + \"1\" * ( b - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT l = [ ( m >> i ) & 1 for i in range ( b - 2 ) ] NEW_LINE print ( \"0\" + \" \" . join ( map ( str , reversed ( l ) ) ) + \"0\" ) NEW_LINE DEDENT for i in range ( 1 , b ) : NEW_LINE INDENT print ( \"0\" * ( i + 1 ) + \"1\" * ( b - i - 1 ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "7", "code": "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE B = int ( t [ 0 ] ) NEW_LINE M = int ( t [ 1 ] ) NEW_LINE if M > 2 ** ( B - 2 ) : NEW_LINE INDENT print ( ' Case \u2581 # { 0 } : \u2581 IMPOSSIBLE ' . format ( case ) ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Case \u2581 # { 0 } : \u2581 POSSIBLE ' . format ( case ) ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( B ) : NEW_LINE INDENT ans . append ( [ ] ) NEW_LINE for j in range ( B ) : NEW_LINE INDENT ans [ i ] . append ( '0' ) NEW_LINE DEDENT for j in range ( i + 1 , B - 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = '1' NEW_LINE DEDENT DEDENT for i in range ( B - 2 , 0 , - 1 ) : NEW_LINE INDENT now = 2 ** ( i - 1 ) NEW_LINE if M >= now : NEW_LINE INDENT M -= now NEW_LINE ans [ i ] [ B - 1 ] = '1' NEW_LINE DEDENT DEDENT assert ( M <= 1 ) NEW_LINE if M >= 1 : NEW_LINE INDENT ans [ 0 ] [ B - 1 ] = '1' NEW_LINE DEDENT for line in ans : NEW_LINE INDENT print ( ' ' . join ( line ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "T = int ( input ( ) ) NEW_LINE for test in range ( 1 , T + 1 ) : NEW_LINE INDENT B , M = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % test , end = \" \" ) NEW_LINE if M > ( 2 ** ( B - 2 ) ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE continue NEW_LINE DEDENT A = [ [ 0 ] * B for _ in range ( B ) ] NEW_LINE for i in range ( 0 , B ) : NEW_LINE INDENT for j in range ( i + 1 , B ) : NEW_LINE INDENT A [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT if M < 2 ** ( B - 2 ) : NEW_LINE INDENT A [ 0 ] [ B - 1 ] = 0 NEW_LINE for i in range ( B - 2 ) : NEW_LINE INDENT if ( 1 << i ) & M : NEW_LINE INDENT A [ 0 ] [ B - i - 2 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT A [ 0 ] [ B - i - 2 ] = 0 NEW_LINE DEDENT DEDENT DEDENT print ( \" POSSIBLE \" ) NEW_LINE for i in range ( B ) : NEW_LINE INDENT print ( \" \" . join ( [ str ( x ) for x in A [ i ] ] ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "import sys NEW_LINE def solve_test ( inp ) : NEW_LINE INDENT B , M = map ( int , inp . readline ( ) . split ( ) ) NEW_LINE if M > 2 ** ( B - 2 ) : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT if M == 2 ** ( B - 2 ) : NEW_LINE INDENT first = '0' + '1' * ( B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT first = '0' + bin ( M ) [ 2 : ] . zfill ( B - 2 ) + '0' NEW_LINE DEDENT print ( bin ( M ) , bin ( M ) [ 2 : ] . zfill ( B - 2 ) ) NEW_LINE lines = [ '0' * i + '1' * ( B - i ) for i in range ( 2 , B + 1 ) ] NEW_LINE return ' POSSIBLE \\n ' + ' \\n ' . join ( [ first ] + lines ) NEW_LINE DEDENT def solve_dumb ( inp ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT inp = open ( sys . argv [ 1 ] ) NEW_LINE inp_dumb = open ( sys . argv [ 1 ] ) NEW_LINE out = open ( sys . argv [ 1 ] . rsplit ( ' . ' , 1 ) [ 0 ] + ' . out ' , ' w ' ) NEW_LINE out_dumb = open ( sys . argv [ 1 ] . rsplit ( ' . ' , 1 ) [ 0 ] + ' . dumb . out ' , ' w ' ) NEW_LINE n_tests = int ( inp . readline ( ) ) NEW_LINE for i in range ( n_tests ) : NEW_LINE INDENT ans = solve_test ( inp ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) + ans , file = out ) NEW_LINE ans_dumb = solve_dumb ( inp_dumb ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) + ans_dumb , file = out_dumb ) NEW_LINE if ans != ans_dumb : NEW_LINE INDENT print ( ' Wrong ' , i + 1 , file = sys . stderr ) NEW_LINE DEDENT DEDENT out . close ( ) NEW_LINE", "functions_standalone": [["solve_test", "def solve_test ( inp ) : NEW_LINE INDENT B , M = map ( int , inp . readline ( ) . split ( ) ) NEW_LINE if M > 2 ** ( B - 2 ) : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT if M == 2 ** ( B - 2 ) : NEW_LINE INDENT first = '0' + '1' * ( B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT first = '0' + bin ( M ) [ 2 : ] . zfill ( B - 2 ) + '0' NEW_LINE DEDENT print ( bin ( M ) , bin ( M ) [ 2 : ] . zfill ( B - 2 ) ) NEW_LINE lines = [ '0' * i + '1' * ( B - i ) for i in range ( 2 , B + 1 ) ] NEW_LINE return ' POSSIBLE \\n ' + ' \\n ' . join ( [ first ] + lines ) NEW_LINE DEDENT"], ["solve_dumb", "def solve_dumb ( inp ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_51", "java": [{"id": "5", "code": "import java . io . * ; import java . util . * ; public class teachingassistant { private static InputReader in ; private static PrintWriter out ; public static boolean SUBMIT = true ; public static final String NAME = \" A - large \" ; private static void main2 ( ) throws IOException { char [ ] c = in . next ( ) . toCharArray ( ) ; int n = c . length ; char [ ] stack = new char [ n ] ; int idx = 0 ; int need = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( idx > 0 && stack [ idx - 1 ] == c [ i ] ) { idx -- ; continue ; } if ( i + idx >= n ) { need ++ ; idx -- ; } else { stack [ idx ++ ] = c [ i ] ; } } out . println ( ( n - need ) * 5 ) ; } public static void main ( String [ ] args ) throws IOException { if ( SUBMIT ) { in = new InputReader ( new FileInputStream ( new File ( NAME + \" . in \" ) ) ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ) ; } else { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out , true ) ; } int numCases = in . nextInt ( ) ; for ( int test = 1 ; test <= numCases ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; main2 ( ) ; } out . close ( ) ; System . exit ( 0 ) ; } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "functions_standalone": [["main2", "private static void main2 ( ) throws IOException { char [ ] c = in . next ( ) . toCharArray ( ) ; int n = c . length ; char [ ] stack = new char [ n ] ; int idx = 0 ; int need = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( idx > 0 && stack [ idx - 1 ] == c [ i ] ) { idx -- ; continue ; } if ( i + idx >= n ) { need ++ ; idx -- ; } else { stack [ idx ++ ] = c [ i ] ; } } out . println ( ( n - need ) * 5 ) ; }"], ["main", "public static void main ( String [ ] args ) throws IOException { if ( SUBMIT ) { in = new InputReader ( new FileInputStream ( new File ( NAME + \" . in \" ) ) ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ) ; } else { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out , true ) ; } int numCases = in . nextInt ( ) ; for ( int test = 1 ; test <= numCases ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; main2 ( ) ; } out . close ( ) ; System . exit ( 0 ) ; }"]], "functions_class": [["InputReader", "public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; }"], ["next", "public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }"]]}, {"id": "17", "code": "package cj2016 . r3 ; import java . io . * ; import java . util . * ; public class A { Scanner sc ; PrintWriter pw ; char [ ] c ; public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" A - large \" ; try { new A ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } } public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; } void read ( Scanner sc ) { c = sc . next ( ) . toCharArray ( ) ; } void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; } void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; } void solve ( ) { int N = c . length ; int score = 0 ; LinkedList < Character > stack = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! stack . isEmpty ( ) && stack . peek ( ) == c [ i ] ) { stack . pop ( ) ; score += 10 ; } else { stack . push ( c [ i ] ) ; } } println ( score + stack . size ( ) / 2 * 5 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" A - large \" ; try { new A ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } }"]], "functions_class": [["run", "public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; }"], ["read", "void read ( Scanner sc ) { c = sc . next ( ) . toCharArray ( ) ; }"], ["print", "void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; }"], ["println", "void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; }"], ["solve", "void solve ( ) { int N = c . length ; int score = 0 ; LinkedList < Character > stack = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! stack . isEmpty ( ) && stack . peek ( ) == c [ i ] ) { stack . pop ( ) ; score += 10 ; } else { stack . push ( c [ i ] ) ; } } println ( score + stack . size ( ) / 2 * 5 ) ; }"]]}, {"id": "15", "code": "import java . io . OutputStream ; import java . io . FilenameFilter ; import java . util . Locale ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . FileInputStream ; import java . io . File ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . LinkedList ; public class Main { public static void main ( String [ ] args ) { Locale . setDefault ( Locale . US ) ; InputStream inputStream ; try { final String regex = \" A - ( small | large ) . * [ . ] in \" ; File directory = new File ( \" . \" ) ; File [ ] candidates = directory . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . matches ( regex ) ; } } ) ; File toRun = null ; for ( File candidate : candidates ) { if ( toRun == null || candidate . lastModified ( ) > toRun . lastModified ( ) ) toRun = candidate ; } inputStream = new FileInputStream ( toRun ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } OutputStream outputStream ; try { outputStream = new FileOutputStream ( \" a . out \" ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; int testCount = Integer . parseInt ( in . next ( ) ) ; for ( int i = 1 ; i <= testCount ; i ++ ) solver . solve ( i , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , Scanner in , PrintWriter out ) { String s = in . next ( ) ; int pairs = 0 ; LinkedList < Character > list = new LinkedList < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char next = s . charAt ( i ) ; char last = list . size ( ) > 0 ? list . peekLast ( ) : ' x ' ; if ( last == next ) { pairs ++ ; list . pollLast ( ) ; } else { list . add ( next ) ; } } out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , testNumber , pairs * 10 + 5 * list . size ( ) / 2 ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Locale . setDefault ( Locale . US ) ; InputStream inputStream ; try { final String regex = \" A - ( small | large ) . * [ . ] in \" ; File directory = new File ( \" . \" ) ; File [ ] candidates = directory . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . matches ( regex ) ; } } ) ; File toRun = null ; for ( File candidate : candidates ) { if ( toRun == null || candidate . lastModified ( ) > toRun . lastModified ( ) ) toRun = candidate ; } inputStream = new FileInputStream ( toRun ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } OutputStream outputStream ; try { outputStream = new FileOutputStream ( \" a . out \" ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; int testCount = Integer . parseInt ( in . next ( ) ) ; for ( int i = 1 ; i <= testCount ; i ++ ) solver . solve ( i , in , out ) ; out . close ( ) ; }"]], "functions_class": [["solve", "public void solve ( int testNumber , Scanner in , PrintWriter out ) { String s = in . next ( ) ; int pairs = 0 ; LinkedList < Character > list = new LinkedList < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char next = s . charAt ( i ) ; char last = list . size ( ) > 0 ? list . peekLast ( ) : ' x ' ; if ( last == next ) { pairs ++ ; list . pollLast ( ) ; } else { list . add ( next ) ; } } out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , testNumber , pairs * 10 + 5 * list . size ( ) / 2 ) ; }"]]}, {"id": "8", "code": "import java . io . * ; import java . util . * ; public class Assistant { public void solve ( ) { String s = in . nextToken ( ) ; char [ ] stack = new char [ s . length ( ) ] ; int size = 0 ; for ( char c : s . toCharArray ( ) ) { if ( size > 0 && c == stack [ size - 1 ] ) { size -- ; } else { stack [ size ++ ] = c ; } } out . println ( 5 * ( size / 2 ) + 10 * ( s . length ( ) - size ) / 2 ) ; } public void run ( ) { try { in = new FastScanner ( \" input . txt \" ) ; out = new PrintWriter ( \" output . txt \" ) ; int tests = in . nextInt ( ) ; for ( int i = 1 ; i <= tests ; i ++ ) { long time = System . currentTimeMillis ( ) ; out . printf ( \" Case \u2581 # % d : \u2581 \" , i ) ; solve ( ) ; System . err . printf ( \" Solved \u2581 case \u2581 # % d \u2581 in \u2581 % d \u2581 ms \\n \" , i , System . currentTimeMillis ( ) - time ) ; } out . close ( ) ; } catch ( FileNotFoundException e ) { } } FastScanner in ; PrintWriter out ; class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( String fileName ) { try { br = new BufferedReader ( new FileReader ( fileName ) ) ; } catch ( FileNotFoundException e ) { } } String nextToken ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } } public static void main ( String [ ] args ) { new Assistant ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Assistant ( ) . run ( ) ; }"]], "functions_class": [["solve", "public void solve ( ) { String s = in . nextToken ( ) ; char [ ] stack = new char [ s . length ( ) ] ; int size = 0 ; for ( char c : s . toCharArray ( ) ) { if ( size > 0 && c == stack [ size - 1 ] ) { size -- ; } else { stack [ size ++ ] = c ; } } out . println ( 5 * ( size / 2 ) + 10 * ( s . length ( ) - size ) / 2 ) ; }"], ["run", "public void run ( ) { try { in = new FastScanner ( \" input . txt \" ) ; out = new PrintWriter ( \" output . txt \" ) ; int tests = in . nextInt ( ) ; for ( int i = 1 ; i <= tests ; i ++ ) { long time = System . currentTimeMillis ( ) ; out . printf ( \" Case \u2581 # % d : \u2581 \" , i ) ; solve ( ) ; System . err . printf ( \" Solved \u2581 case \u2581 # % d \u2581 in \u2581 % d \u2581 ms \\n \" , i , System . currentTimeMillis ( ) - time ) ; } out . close ( ) ; } catch ( FileNotFoundException e ) { } }"], ["FastScanner", "public FastScanner ( String fileName ) { try { br = new BufferedReader ( new FileReader ( fileName ) ) ; } catch ( FileNotFoundException e ) { } }"], ["nextToken", "String nextToken ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { } } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; }"]]}, {"id": "14", "code": "package gcj . gcj2016 . round3 ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . Stack ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int t = in . nextInt ( ) ; for ( int cs = 1 ; cs <= t ; cs ++ ) { char [ ] c = in . next ( ) . toCharArray ( ) ; out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , cs , solve ( c ) ) ) ; } out . flush ( ) ; } private static int solve ( char [ ] mood ) { int n = mood . length ; int score = 0 ; int code = 0 ; int jam = 0 ; Stack < Character > stk = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( stk . size ( ) == 0 ) { stk . push ( mood [ i ] ) ; } else { if ( stk . peek ( ) == mood [ i ] ) { stk . pop ( ) ; score += 10 ; } else { int pool = stk . size ( ) ; int left = n - i ; if ( pool + 1 <= left - 1 ) { stk . push ( mood [ i ] ) ; } else { stk . pop ( ) ; score += 5 ; } } } } return score ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int t = in . nextInt ( ) ; for ( int cs = 1 ; cs <= t ; cs ++ ) { char [ ] c = in . next ( ) . toCharArray ( ) ; out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , cs , solve ( c ) ) ) ; } out . flush ( ) ; }"], ["solve", "private static int solve ( char [ ] mood ) { int n = mood . length ; int score = 0 ; int code = 0 ; int jam = 0 ; Stack < Character > stk = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( stk . size ( ) == 0 ) { stk . push ( mood [ i ] ) ; } else { if ( stk . peek ( ) == mood [ i ] ) { stk . pop ( ) ; score += 10 ; } else { int pool = stk . size ( ) ; int left = n - i ; if ( pool + 1 <= left - 1 ) { stk . push ( mood [ i ] ) ; } else { stk . pop ( ) ; score += 5 ; } } } } return score ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "def run ( ) : NEW_LINE INDENT s = input ( ) . strip ( ) NEW_LINE stack = [ ] NEW_LINE res = 0 NEW_LINE for c in s : NEW_LINE INDENT if len ( stack ) > 0 and stack [ - 1 ] == c : NEW_LINE INDENT stack . pop ( ) NEW_LINE res += 10 NEW_LINE DEDENT else : NEW_LINE INDENT stack . append ( c ) NEW_LINE DEDENT DEDENT res += len ( stack ) // 2 * 5 NEW_LINE return res NEW_LINE DEDENT tc = int ( input ( ) ) NEW_LINE for i in range ( tc ) : NEW_LINE INDENT res = run ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , res ) ) NEW_LINE DEDENT", "functions_standalone": [["run", "def run ( ) : NEW_LINE INDENT s = input ( ) . strip ( ) NEW_LINE stack = [ ] NEW_LINE res = 0 NEW_LINE for c in s : NEW_LINE INDENT if len ( stack ) > 0 and stack [ - 1 ] == c : NEW_LINE INDENT stack . pop ( ) NEW_LINE res += 10 NEW_LINE DEDENT else : NEW_LINE INDENT stack . append ( c ) NEW_LINE DEDENT DEDENT res += len ( stack ) // 2 * 5 NEW_LINE return res NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "__author__ = ' Tianren \u2581 Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE mat = np . zeros ( [ n + 1 , n + 1 ] , int ) NEW_LINE for l in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT for s in range ( n + 1 - l ) : NEW_LINE INDENT t = s + l NEW_LINE mat [ s , t ] = max ( [ mat [ s + 1 , j ] + mat [ j + 1 , t ] + ( 10 if S [ s ] == S [ j ] else 5 ) for j in range ( s + 1 , t + 1 , 2 ) ] ) NEW_LINE DEDENT DEDENT return mat [ 0 , n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT S = sys . stdin . readline ( ) NEW_LINE S = [ s for s in S if s in { ' J ' , ' C ' } ] NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( t + 1 , solve ( S ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solve", "def solve ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE mat = np . zeros ( [ n + 1 , n + 1 ] , int ) NEW_LINE for l in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT for s in range ( n + 1 - l ) : NEW_LINE INDENT t = s + l NEW_LINE mat [ s , t ] = max ( [ mat [ s + 1 , j ] + mat [ j + 1 , t ] + ( 10 if S [ s ] == S [ j ] else 5 ) for j in range ( s + 1 , t + 1 , 2 ) ] ) NEW_LINE DEDENT DEDENT return mat [ 0 , n ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "4", "code": "def initialize_solver ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT def solve_testcase ( ) : NEW_LINE INDENT s = read ( False , str ) NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE j1 = 0 NEW_LINE j2 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if s [ i ] == \" C \" : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j1 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] == \" C \" : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j2 += 1 NEW_LINE DEDENT DEDENT DEDENT return 10 * ( min ( [ c1 , c2 ] ) + min ( [ j1 , j2 ] ) ) + 5 * abs ( c1 - c2 ) NEW_LINE DEDENT output_format = \" Case \u2581 # % d : \u2581 \" NEW_LINE filename = input ( ) . strip ( ) NEW_LINE sfile = None NEW_LINE tfile = None NEW_LINE if filename != \" \" : NEW_LINE INDENT sfile = open ( filename + \" . in \" , \" r \" ) NEW_LINE sfile . seek ( 0 ) NEW_LINE tfile = open ( filename + \" . out \" , \" w \" ) NEW_LINE DEDENT def read ( split = True , rettype = int ) : NEW_LINE INDENT if sfile : NEW_LINE INDENT input_line = sfile . readline ( ) . strip ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input_line = input ( ) . strip ( ) NEW_LINE DEDENT if split : NEW_LINE INDENT return list ( map ( rettype , input_line . split ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return rettype ( input_line ) NEW_LINE DEDENT DEDENT def write ( s = \" \\n \" ) : NEW_LINE INDENT if s is None : s = \" \" NEW_LINE if isinstance ( s , list ) : s = \" \u2581 \" . join ( map ( str , s ) ) NEW_LINE s = str ( s ) NEW_LINE if tfile : NEW_LINE INDENT tfile . write ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s , end = \" \" ) NEW_LINE DEDENT DEDENT if output_format == 0 : NEW_LINE INDENT solve_testcase ( ) NEW_LINE DEDENT else : NEW_LINE INDENT initialize_solver ( ) NEW_LINE total_cases = read ( split = False ) NEW_LINE for case_number in range ( 1 , total_cases + 1 ) : NEW_LINE INDENT write ( output_format . replace ( \" % d \" , str ( case_number ) ) ) NEW_LINE write ( solve_testcase ( ) ) NEW_LINE write ( \" \\n \" ) NEW_LINE DEDENT DEDENT if tfile is not None : tfile . close ( ) NEW_LINE", "functions_standalone": [["initialize_solver", "def initialize_solver ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT"], ["solve_testcase", "def solve_testcase ( ) : NEW_LINE INDENT s = read ( False , str ) NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE j1 = 0 NEW_LINE j2 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if s [ i ] == \" C \" : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j1 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] == \" C \" : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j2 += 1 NEW_LINE DEDENT DEDENT DEDENT return 10 * ( min ( [ c1 , c2 ] ) + min ( [ j1 , j2 ] ) ) + 5 * abs ( c1 - c2 ) NEW_LINE DEDENT"], ["read", "def read ( split = True , rettype = int ) : NEW_LINE INDENT if sfile : NEW_LINE INDENT input_line = sfile . readline ( ) . strip ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input_line = input ( ) . strip ( ) NEW_LINE DEDENT if split : NEW_LINE INDENT return list ( map ( rettype , input_line . split ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return rettype ( input_line ) NEW_LINE DEDENT DEDENT"], ["write", "def write ( s = \" \\n \" ) : NEW_LINE INDENT if s is None : s = \" \" NEW_LINE if isinstance ( s , list ) : s = \" \u2581 \" . join ( map ( str , s ) ) NEW_LINE s = str ( s ) NEW_LINE if tfile : NEW_LINE INDENT tfile . write ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s , end = \" \" ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "13", "code": "import os , inspect NEW_LINE problemName = ' A ' NEW_LINE testCase = ' large ' NEW_LINE attempt = 0 NEW_LINE def solution ( preferences ) : NEW_LINE INDENT totalTaken = 0 NEW_LINE holding = [ ] NEW_LINE points = 0 NEW_LINE for c in preferences : NEW_LINE INDENT if len ( holding ) == 0 or holding [ - 1 ] != c : NEW_LINE INDENT if totalTaken == len ( preferences ) / 2 : NEW_LINE INDENT holding . pop ( ) NEW_LINE points += 5 NEW_LINE DEDENT else : NEW_LINE INDENT holding . append ( c ) NEW_LINE totalTaken += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT holding . pop ( ) NEW_LINE points += 10 NEW_LINE DEDENT DEDENT return points NEW_LINE DEDENT currentDir = os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) NEW_LINE if testCase in [ ' large ' , ' example ' ] : NEW_LINE INDENT inputString = problemName + ( ' - % s ' % testCase ) NEW_LINE outputString = problemName + ( ' - % s ' % testCase ) NEW_LINE DEDENT else : NEW_LINE INDENT inputString = problemName + ( ' - % s - attempt % d ' % ( testCase , attempt ) ) NEW_LINE outputString = problemName + ( ' - % s ' % testCase ) NEW_LINE DEDENT inFile = os . path . join ( currentDir , ' inputfiles ' , ' % s . in ' % inputString ) NEW_LINE outFile = os . path . join ( currentDir , ' outputfiles ' , ' % s . out ' % outputString ) NEW_LINE if os . path . exists ( outFile ) : NEW_LINE INDENT os . remove ( outFile ) NEW_LINE DEDENT with open ( inFile , ' r ' ) as inputfile : NEW_LINE INDENT numberOfCases = int ( inputfile . readline ( ) ) NEW_LINE for case in xrange ( 1 , numberOfCases + 1 ) : NEW_LINE INDENT result = solution ( inputfile . readline ( ) . strip ( ) ) NEW_LINE with open ( outFile , ' a ' ) as f : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( case , result ) ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["solution", "def solution ( preferences ) : NEW_LINE INDENT totalTaken = 0 NEW_LINE holding = [ ] NEW_LINE points = 0 NEW_LINE for c in preferences : NEW_LINE INDENT if len ( holding ) == 0 or holding [ - 1 ] != c : NEW_LINE INDENT if totalTaken == len ( preferences ) / 2 : NEW_LINE INDENT holding . pop ( ) NEW_LINE points += 5 NEW_LINE DEDENT else : NEW_LINE INDENT holding . append ( c ) NEW_LINE totalTaken += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT holding . pop ( ) NEW_LINE points += 10 NEW_LINE DEDENT DEDENT return points NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "t = int ( input ( ) ) NEW_LINE def solve ( s ) : NEW_LINE INDENT assert ( len ( s ) % 2 == 0 ) NEW_LINE k = len ( s ) // 2 NEW_LINE stack = [ ] NEW_LINE score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( stack == [ ] or s [ i ] != stack [ - 1 ] ) and k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE stack . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT e = stack . pop ( ) NEW_LINE if e == s [ i ] : NEW_LINE INDENT score += 10 NEW_LINE DEDENT else : NEW_LINE INDENT score += 5 NEW_LINE DEDENT DEDENT DEDENT return score NEW_LINE DEDENT for i in range ( t ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \" % ( i + 1 ) , end = \" \u2581 \" ) NEW_LINE s = input ( ) . strip ( ) NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( s ) : NEW_LINE INDENT assert ( len ( s ) % 2 == 0 ) NEW_LINE k = len ( s ) // 2 NEW_LINE stack = [ ] NEW_LINE score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( stack == [ ] or s [ i ] != stack [ - 1 ] ) and k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE stack . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT e = stack . pop ( ) NEW_LINE if e == s [ i ] : NEW_LINE INDENT score += 10 NEW_LINE DEDENT else : NEW_LINE INDENT score += 5 NEW_LINE DEDENT DEDENT DEDENT return score NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_33", "java": [{"id": "4", "code": "import java . util . * ; public class C { static Scanner in ; public static void main ( String [ ] args ) { in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( ) ) ; } } public static String solve ( ) { String out = \" \" ; int a = in . nextInt ( ) , b = in . nextInt ( ) , c = in . nextInt ( ) , limit = in . nextInt ( ) ; int [ ] abT = new int [ 201 ] ; int [ ] bcT = new int [ 201 ] ; int [ ] acT = new int [ 201 ] ; int count = 0 ; for ( int i = a ; i >= 1 ; i -- ) { for ( int j = b ; j >= 1 ; j -- ) { for ( int kk = c ; kk >= 1 ; kk -- ) { int k = ( kk + ( i ) + ( j ) ) % c ; k ++ ; int ab = i * 15 + j ; int ac = i * 15 + k ; int bc = j * 15 + k ; if ( abT [ ab ] < limit && bcT [ bc ] < limit && acT [ ac ] < limit ) { out += \" \\n \" + i + \" \u2581 \" + j + \" \u2581 \" + k ; count ++ ; abT [ ab ] ++ ; bcT [ bc ] ++ ; acT [ ac ] ++ ; } else { } } } } System . err . println ( count ) ; return count + \" \" + out ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( ) ) ; } }"], ["solve", "public static String solve ( ) { String out = \" \" ; int a = in . nextInt ( ) , b = in . nextInt ( ) , c = in . nextInt ( ) , limit = in . nextInt ( ) ; int [ ] abT = new int [ 201 ] ; int [ ] bcT = new int [ 201 ] ; int [ ] acT = new int [ 201 ] ; int count = 0 ; for ( int i = a ; i >= 1 ; i -- ) { for ( int j = b ; j >= 1 ; j -- ) { for ( int kk = c ; kk >= 1 ; kk -- ) { int k = ( kk + ( i ) + ( j ) ) % c ; k ++ ; int ab = i * 15 + j ; int ac = i * 15 + k ; int bc = j * 15 + k ; if ( abT [ ab ] < limit && bcT [ bc ] < limit && acT [ ac ] < limit ) { out += \" \\n \" + i + \" \u2581 \" + j + \" \u2581 \" + k ; count ++ ; abT [ ab ] ++ ; bcT [ bc ] ++ ; acT [ ac ] ++ ; } else { } } } } System . err . println ( count ) ; return count + \" \" + out ; }"]], "functions_class": []}, {"id": "3", "code": "package gcj2016r1c ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . ArrayList ; import java . util . StringTokenizer ; public class ProblemC { public static void main ( String [ ] args ) throws Exception { String fileName = args [ 0 ] ; ProblemC obj = new ProblemC ( ) ; obj . solve ( fileName ) ; } public void solve ( String fileName ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( fileName ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( fileName + \" . out \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { String str = br . readLine ( ) ; StringTokenizer token = new StringTokenizer ( str , \" \u2581 \" ) ; int J = Integer . parseInt ( token . nextToken ( ) ) ; int P = Integer . parseInt ( token . nextToken ( ) ) ; int S = Integer . parseInt ( token . nextToken ( ) ) ; int K = Integer . parseInt ( token . nextToken ( ) ) ; ArrayList < int [ ] > list = new ArrayList < > ( ) ; int [ ] chk = new int [ P ] ; int s = 0 ; for ( int j = 0 ; j < J ; j ++ ) { for ( int p = 0 ; p < P ; p ++ ) { if ( j != 0 ) { s = chk [ p ] ; } for ( int k = 0 ; k < Math . min ( K , S ) ; k ++ ) { list . add ( new int [ ] { j + 1 , p + 1 , s + 1 } ) ; s = ( s + 1 ) % S ; chk [ p ] = s ; } } } bw . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + list . size ( ) ) ; bw . write ( \" \\r \\n \" ) ; for ( int [ ] e : list ) { bw . write ( e [ 0 ] + \" \u2581 \" + e [ 1 ] + \" \u2581 \" + e [ 2 ] ) ; bw . write ( \" \\r \\n \" ) ; } } bw . close ( ) ; br . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String fileName = args [ 0 ] ; ProblemC obj = new ProblemC ( ) ; obj . solve ( fileName ) ; }"]], "functions_class": [["solve", "public void solve ( String fileName ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( fileName ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( fileName + \" . out \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { String str = br . readLine ( ) ; StringTokenizer token = new StringTokenizer ( str , \" \u2581 \" ) ; int J = Integer . parseInt ( token . nextToken ( ) ) ; int P = Integer . parseInt ( token . nextToken ( ) ) ; int S = Integer . parseInt ( token . nextToken ( ) ) ; int K = Integer . parseInt ( token . nextToken ( ) ) ; ArrayList < int [ ] > list = new ArrayList < > ( ) ; int [ ] chk = new int [ P ] ; int s = 0 ; for ( int j = 0 ; j < J ; j ++ ) { for ( int p = 0 ; p < P ; p ++ ) { if ( j != 0 ) { s = chk [ p ] ; } for ( int k = 0 ; k < Math . min ( K , S ) ; k ++ ) { list . add ( new int [ ] { j + 1 , p + 1 , s + 1 } ) ; s = ( s + 1 ) % S ; chk [ p ] = s ; } } } bw . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + list . size ( ) ) ; bw . write ( \" \\r \\n \" ) ; for ( int [ ] e : list ) { bw . write ( e [ 0 ] + \" \u2581 \" + e [ 1 ] + \" \u2581 \" + e [ 2 ] ) ; bw . write ( \" \\r \\n \" ) ; } } bw . close ( ) ; br . close ( ) ; }"]]}, {"id": "13", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Scanner ; public class R1CQ3 { public static void main ( String [ ] args ) { try { String fileName = \" C - large \" ; Scanner in = new Scanner ( new File ( fileName + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( fileName + \" . out \" ) ; int numberOfTestCases = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numberOfTestCases ; caseNum ++ ) { int J = in . nextInt ( ) ; int P = in . nextInt ( ) ; int S = in . nextInt ( ) ; int k = in . nextInt ( ) ; int dayCount = 0 ; String result = \" \" ; for ( int j = 1 ; j <= J ; j ++ ) { for ( int p = 1 ; p <= P ; p ++ ) { for ( int i = 0 ; i < S && i < k ; i ++ ) { dayCount ++ ; int a = ( ( ( i + p + j ) % S ) + 1 ) ; result += j + \" \u2581 \" + p + \" \u2581 \" + a + \" \\n \" ; } } } out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + dayCount + \" \\n \" + result . substring ( 0 , result . length ( ) - 1 ) ) ; } in . close ( ) ; out . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { String fileName = \" C - large \" ; Scanner in = new Scanner ( new File ( fileName + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( fileName + \" . out \" ) ; int numberOfTestCases = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numberOfTestCases ; caseNum ++ ) { int J = in . nextInt ( ) ; int P = in . nextInt ( ) ; int S = in . nextInt ( ) ; int k = in . nextInt ( ) ; int dayCount = 0 ; String result = \" \" ; for ( int j = 1 ; j <= J ; j ++ ) { for ( int p = 1 ; p <= P ; p ++ ) { for ( int i = 0 ; i < S && i < k ; i ++ ) { dayCount ++ ; int a = ( ( ( i + p + j ) % S ) + 1 ) ; result += j + \" \u2581 \" + p + \" \u2581 \" + a + \" \\n \" ; } } } out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + dayCount + \" \\n \" + result . substring ( 0 , result . length ( ) - 1 ) ) ; } in . close ( ) ; out . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "17", "code": "package codejamquestion ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class CodeJamQuestion { public static void main ( String [ ] args ) { try { Scanner in = new Scanner ( new File ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" C - large . out \" ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { String answer = \" Case \u2581 # \" + test + \" : \u2581 \" ; String outfits = \" \" ; int days = 0 ; int J = in . nextInt ( ) ; int P = in . nextInt ( ) ; int S = in . nextInt ( ) ; int k = in . nextInt ( ) ; for ( int j = 1 ; j <= J ; j ++ ) { for ( int p = 1 ; p <= P ; p ++ ) { for ( int i = 0 ; i < S && i < k ; i ++ ) { outfits += j + \" \u2581 \" + p + \" \u2581 \" + ( ( ( i + p + j ) % S ) + 1 ) + \" \\n \" ; days ++ ; } } } answer += days + \" \\n \" + outfits ; out . println ( answer ) ; } in . close ( ) ; out . close ( ) ; } catch ( FileNotFoundException ex ) { System . out . println ( \" ERROR \" ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { Scanner in = new Scanner ( new File ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" C - large . out \" ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { String answer = \" Case \u2581 # \" + test + \" : \u2581 \" ; String outfits = \" \" ; int days = 0 ; int J = in . nextInt ( ) ; int P = in . nextInt ( ) ; int S = in . nextInt ( ) ; int k = in . nextInt ( ) ; for ( int j = 1 ; j <= J ; j ++ ) { for ( int p = 1 ; p <= P ; p ++ ) { for ( int i = 0 ; i < S && i < k ; i ++ ) { outfits += j + \" \u2581 \" + p + \" \u2581 \" + ( ( ( i + p + j ) % S ) + 1 ) + \" \\n \" ; days ++ ; } } } answer += days + \" \\n \" + outfits ; out . println ( answer ) ; } in . close ( ) ; out . close ( ) ; } catch ( FileNotFoundException ex ) { System . out . println ( \" ERROR \" ) ; } }"]], "functions_class": []}, {"id": "7", "code": "package Round1 ; import java . io . * ; public class C { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" / Users / chao / Downloads / C - large . in \" ) ) ; FileWriter out = new FileWriter ( \" / Users / chao / Desktop / C - large . txt \" ) ; String s = in . readLine ( ) ; int m = Integer . parseInt ( s ) ; int [ ] a = new int [ 3 ] ; for ( int cases = 1 ; cases <= m ; cases ++ ) { String [ ] ss = in . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < 3 ; i ++ ) { a [ i ] = Integer . parseInt ( ss [ i ] ) ; } int k = Integer . parseInt ( ss [ 3 ] ) ; k = Math . min ( k , a [ 2 ] ) ; int ans = a [ 0 ] * a [ 1 ] * k ; out . write ( \" Case \u2581 # \" + cases + \" : \u2581 \" + ans + \" \\n \" ) ; for ( int i = 1 ; i <= a [ 0 ] ; i ++ ) { for ( int j = 1 ; j <= a [ 1 ] ; j ++ ) { for ( int x = 0 ; x < k ; x ++ ) { int val = ( i + j + x - 2 ) % a [ 2 ] + 1 ; out . write ( i + \" \u2581 \" + j + \" \u2581 \" + val + \" \\n \" ) ; } } } } in . close ( ) ; out . flush ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" / Users / chao / Downloads / C - large . in \" ) ) ; FileWriter out = new FileWriter ( \" / Users / chao / Desktop / C - large . txt \" ) ; String s = in . readLine ( ) ; int m = Integer . parseInt ( s ) ; int [ ] a = new int [ 3 ] ; for ( int cases = 1 ; cases <= m ; cases ++ ) { String [ ] ss = in . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < 3 ; i ++ ) { a [ i ] = Integer . parseInt ( ss [ i ] ) ; } int k = Integer . parseInt ( ss [ 3 ] ) ; k = Math . min ( k , a [ 2 ] ) ; int ans = a [ 0 ] * a [ 1 ] * k ; out . write ( \" Case \u2581 # \" + cases + \" : \u2581 \" + ans + \" \\n \" ) ; for ( int i = 1 ; i <= a [ 0 ] ; i ++ ) { for ( int j = 1 ; j <= a [ 1 ] ; j ++ ) { for ( int x = 0 ; x < k ; x ++ ) { int val = ( i + j + x - 2 ) % a [ 2 ] + 1 ; out . write ( i + \" \u2581 \" + j + \" \u2581 \" + val + \" \\n \" ) ; } } } } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "def executer_calcul ( entrees ) : NEW_LINE INDENT J = entrees [ 0 ] NEW_LINE P = entrees [ 1 ] NEW_LINE S = entrees [ 2 ] NEW_LINE K = entrees [ 3 ] NEW_LINE Case = entrees [ 4 ] NEW_LINE if ( K > S ) : K = S NEW_LINE if ( P >= K ) : S = P NEW_LINE result = str ( J * P * K ) NEW_LINE for j in range ( J ) : NEW_LINE INDENT for p in range ( P ) : NEW_LINE INDENT for k in range ( K ) : NEW_LINE INDENT result = result + ' \\n ' + str ( j + 1 ) + ' \u2581 ' + str ( p + 1 ) + ' \u2581 ' + str ( ( p + j + k ) % S + 1 ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT multiprocessed = False NEW_LINE if ( multiprocessed ) : from multiprocessing import Pool NEW_LINE else : output = open ( ' Output . txt ' , ' w ' ) NEW_LINE if ( ( not multiprocessed ) or __name__ == ' _ _ main _ _ ' ) : NEW_LINE INDENT with open ( \" Input . txt \" , \" r \" ) as input : NEW_LINE INDENT lines = input . readlines ( ) NEW_LINE DEDENT T = int ( lines [ 0 ] ) NEW_LINE line = 1 NEW_LINE Case = 1 NEW_LINE calculs = [ ] NEW_LINE while ( line < len ( lines ) ) : NEW_LINE INDENT J , P , S , K = map ( int , lines [ line ] . split ( ' \u2581 ' ) ) NEW_LINE line = line + 1 NEW_LINE entrees = [ J , P , S , K , Case ] NEW_LINE if ( not multiprocessed ) : output . write ( ' Case \u2581 # ' + str ( Case ) + ' : \u2581 ' + executer_calcul ( entrees ) + ' \\n ' ) NEW_LINE else : calculs . append ( entrees ) NEW_LINE Case = Case + 1 NEW_LINE DEDENT if ( multiprocessed ) : NEW_LINE INDENT pool = Pool ( 3 ) NEW_LINE results = pool . map ( executer_calcul , calculs ) NEW_LINE output = open ( ' Output . txt ' , ' w ' ) NEW_LINE for case in range ( len ( results ) ) : NEW_LINE INDENT output . write ( ' Case \u2581 # ' + str ( case + 1 ) + ' : \u2581 ' + results [ case ] + ' \\n ' ) NEW_LINE DEDENT DEDENT output . close ( ) NEW_LINE DEDENT", "functions_standalone": [["executer_calcul", "def executer_calcul ( entrees ) : NEW_LINE INDENT J = entrees [ 0 ] NEW_LINE P = entrees [ 1 ] NEW_LINE S = entrees [ 2 ] NEW_LINE K = entrees [ 3 ] NEW_LINE Case = entrees [ 4 ] NEW_LINE if ( K > S ) : K = S NEW_LINE if ( P >= K ) : S = P NEW_LINE result = str ( J * P * K ) NEW_LINE for j in range ( J ) : NEW_LINE INDENT for p in range ( P ) : NEW_LINE INDENT for k in range ( K ) : NEW_LINE INDENT result = result + ' \\n ' + str ( j + 1 ) + ' \u2581 ' + str ( p + 1 ) + ' \u2581 ' + str ( ( p + j + k ) % S + 1 ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "T = int ( input ( ) ) NEW_LINE for TT in range ( 1 , T + 1 ) : NEW_LINE INDENT J , P , S , K = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE m = min ( S , K ) NEW_LINE ans = J * P * m NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( TT , ans ) ) NEW_LINE for j in range ( J ) : NEW_LINE INDENT for p in range ( P ) : NEW_LINE INDENT for s in range ( m ) : NEW_LINE INDENT t = ( j + p + s ) % S NEW_LINE print ( j + 1 , p + 1 , t + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \" , end = \" \u2581 \" ) NEW_LINE j , p , s , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( j * p * min ( s , k ) ) NEW_LINE u = min ( s , k ) NEW_LINE for a in range ( j ) : NEW_LINE INDENT for b in range ( p ) : NEW_LINE INDENT for r in range ( u ) : NEW_LINE INDENT c = ( a + b + r ) % s NEW_LINE print ( a + 1 , b + 1 , c + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "3", "code": "from collections import * NEW_LINE def solve ( J , P , S , K ) : NEW_LINE INDENT Q = set ( ) NEW_LINE A = defaultdict ( int ) NEW_LINE B = defaultdict ( int ) NEW_LINE C = defaultdict ( int ) NEW_LINE for j in range ( J ) : NEW_LINE INDENT for p in range ( P ) : NEW_LINE INDENT for s in range ( min ( S , K ) ) : NEW_LINE INDENT d = ( j + p + s ) % S NEW_LINE Q . add ( ( j , p , d ) ) NEW_LINE A [ ( j , p ) ] += 1 NEW_LINE B [ ( p , d ) ] += 1 NEW_LINE C [ ( d , j ) ] += 1 NEW_LINE DEDENT DEDENT DEDENT assert ( max ( A . values ( ) ) <= K ) NEW_LINE assert ( max ( B . values ( ) ) <= K ) NEW_LINE assert ( max ( C . values ( ) ) <= K ) NEW_LINE assert ( len ( Q ) == J * P * min ( S , K ) ) NEW_LINE return Q NEW_LINE DEDENT def test ( ) : NEW_LINE INDENT for k in range ( 1 , 11 ) : NEW_LINE INDENT for s in range ( 1 , 11 ) : NEW_LINE INDENT for p in range ( 1 , s + 1 ) : NEW_LINE INDENT for j in range ( 1 , p + 1 ) : NEW_LINE INDENT solve ( j , p , s , k ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT J , P , S , K = map ( int , input ( ) . split ( ) ) NEW_LINE Q = solve ( J , P , S , K ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \" % ( t + 1 , len ( Q ) ) ) NEW_LINE for q in Q : NEW_LINE INDENT print ( q [ 0 ] + 1 , q [ 1 ] + 1 , q [ 2 ] + 1 ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solve", "def solve ( J , P , S , K ) : NEW_LINE INDENT Q = set ( ) NEW_LINE A = defaultdict ( int ) NEW_LINE B = defaultdict ( int ) NEW_LINE C = defaultdict ( int ) NEW_LINE for j in range ( J ) : NEW_LINE INDENT for p in range ( P ) : NEW_LINE INDENT for s in range ( min ( S , K ) ) : NEW_LINE INDENT d = ( j + p + s ) % S NEW_LINE Q . add ( ( j , p , d ) ) NEW_LINE A [ ( j , p ) ] += 1 NEW_LINE B [ ( p , d ) ] += 1 NEW_LINE C [ ( d , j ) ] += 1 NEW_LINE DEDENT DEDENT DEDENT assert ( max ( A . values ( ) ) <= K ) NEW_LINE assert ( max ( B . values ( ) ) <= K ) NEW_LINE assert ( max ( C . values ( ) ) <= K ) NEW_LINE assert ( len ( Q ) == J * P * min ( S , K ) ) NEW_LINE return Q NEW_LINE DEDENT"], ["test", "def test ( ) : NEW_LINE INDENT for k in range ( 1 , 11 ) : NEW_LINE INDENT for s in range ( 1 , 11 ) : NEW_LINE INDENT for p in range ( 1 , s + 1 ) : NEW_LINE INDENT for j in range ( 1 , p + 1 ) : NEW_LINE INDENT solve ( j , p , s , k ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "7", "code": "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE J = int ( t [ 0 ] ) NEW_LINE P = int ( t [ 1 ] ) NEW_LINE S = int ( t [ 2 ] ) NEW_LINE K = int ( t [ 3 ] ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , J * P * min ( S , K ) ) ) NEW_LINE offset = 0 NEW_LINE for i in range ( 1 , J + 1 ) : NEW_LINE INDENT offset += 1 NEW_LINE now = offset NEW_LINE for j in range ( 1 , P + 1 ) : NEW_LINE INDENT for k in range ( min ( S , K ) ) : NEW_LINE INDENT now = now % S + 1 NEW_LINE print ( ' \u2581 ' . join ( [ str ( i ) , str ( j ) , str ( now ) ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_16_02", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class Round0B { int cases ; int count ( String stack ) { int flips = 0 ; for ( int n = 1 ; n < stack . length ( ) ; n ++ ) { if ( stack . charAt ( n - 1 ) != stack . charAt ( n ) ) flips ++ ; } return flips ; } void process ( Scanner scanner , PrintStream out ) throws IOException { cases = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int curCase = 0 ; curCase < cases ; curCase ++ ) { String stack = scanner . nextLine ( ) . trim ( ) ; out . println ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \u2581 \" + count ( stack + \" + \" ) ) ; } } Round0B ( ) throws IOException { Scanner in = new Scanner ( new File ( \" C : \\\\ Users \\\\ Olaf \\\\ Downloads \\\\ B - large . in \" ) ) ; PrintStream out = new PrintStream ( \" out - B - large . txt \" ) ; process ( in , out ) ; in . close ( ) ; out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new Round0B ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Round0B ( ) ; }"]], "functions_class": [["count", "int count ( String stack ) { int flips = 0 ; for ( int n = 1 ; n < stack . length ( ) ; n ++ ) { if ( stack . charAt ( n - 1 ) != stack . charAt ( n ) ) flips ++ ; } return flips ; }"], ["process", "void process ( Scanner scanner , PrintStream out ) throws IOException { cases = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int curCase = 0 ; curCase < cases ; curCase ++ ) { String stack = scanner . nextLine ( ) . trim ( ) ; out . println ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \u2581 \" + count ( stack + \" + \" ) ) ; } }"], ["Round0B", "Round0B ( ) throws IOException { Scanner in = new Scanner ( new File ( \" C : \\\\ Users \\\\ Olaf \\\\ Downloads \\\\ B - large . in \" ) ) ; PrintStream out = new PrintStream ( \" out - B - large . txt \" ) ; process ( in , out ) ; in . close ( ) ; out . close ( ) ; }"]]}, {"id": "17", "code": "package lab6zp ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Lab6ZP { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; Scanner sin = new Scanner ( System . in ) ; int n = Integer . parseInt ( sin . next ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = sin . next ( ) ; s += ' + ' ; int counter = 0 ; for ( int j = 0 ; j < s . length ( ) - 1 ; j ++ ) { if ( s . charAt ( j ) != s . charAt ( j + 1 ) ) { counter ++ ; } } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + counter ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; Scanner sin = new Scanner ( System . in ) ; int n = Integer . parseInt ( sin . next ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = sin . next ( ) ; s += ' + ' ; int counter = 0 ; for ( int j = 0 ; j < s . length ( ) - 1 ; j ++ ) { if ( s . charAt ( j ) != s . charAt ( j + 1 ) ) { counter ++ ; } } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + counter ) ; } }"]], "functions_class": []}, {"id": "8", "code": "package gcj2016 . qualif ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ExoB { public static void main ( final String [ ] args ) { final String base = \" / home / jfortin / workspace - gcj / Codejam2016 / q / ExoB / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } private static void test ( final Scanner sc , final PrintWriter pw ) { String in = sc . next ( ) ; System . out . println ( in ) ; int i = count ( in , in . length ( ) , ' + ' ) ; pw . print ( i ) ; } private static int count ( final String in , final int length , final char c ) { if ( length == 0 ) { return 0 ; } if ( in . charAt ( length - 1 ) == c ) { return count ( in , length - 1 , c ) ; } else { return 1 + count ( in , length - 1 , c == ' + ' ? ' - ' : ' + ' ) ; } } }", "functions_standalone": [["main", "public static void main ( final String [ ] args ) { final String base = \" / home / jfortin / workspace - gcj / Codejam2016 / q / ExoB / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"], ["test", "private static void test ( final Scanner sc , final PrintWriter pw ) { String in = sc . next ( ) ; System . out . println ( in ) ; int i = count ( in , in . length ( ) , ' + ' ) ; pw . print ( i ) ; }"], ["count", "private static int count ( final String in , final int length , final char c ) { if ( length == 0 ) { return 0 ; } if ( in . charAt ( length - 1 ) == c ) { return count ( in , length - 1 , c ) ; } else { return 1 + count ( in , length - 1 , c == ' + ' ? ' - ' : ' + ' ) ; } }"]], "functions_class": []}, {"id": "1", "code": "import java . awt . * ; import java . awt . event . * ; import java . awt . geom . * ; import java . io . * ; import java . math . * ; import java . text . * ; import java . util . * ; import java . util . concurrent . * ; public class B { static BufferedReader br ; static StringTokenizer st ; static PrintWriter pw ; public static void main ( String [ ] args ) throws Exception { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" b . out \" ) ) ) ; final int MAX_CASES = readInt ( ) ; for ( int casenum = 1 ; casenum <= MAX_CASES ; casenum ++ ) { pw . printf ( \" Case \u2581 # % d : \u2581 \" , casenum ) ; String s = nextToken ( ) ; boolean [ ] good = new boolean [ s . length ( ) ] ; int ret = 0 ; boolean last = true ; for ( int i = 0 ; i < good . length ; i ++ ) { good [ i ] = s . charAt ( i ) == ' + ' ; if ( i > 0 && last != good [ i ] ) { ret ++ ; } last = good [ i ] ; } if ( ! last ) ret ++ ; pw . println ( ret ) ; } pw . close ( ) ; } public static int readInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } public static long readLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } public static double readDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } public static String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { if ( ! br . ready ( ) ) { pw . close ( ) ; System . exit ( 0 ) ; } st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { System . err . println ( e ) ; System . exit ( 1 ) ; } } return st . nextToken ( ) ; } public static String readLine ( ) { st = null ; try { return br . readLine ( ) ; } catch ( IOException e ) { System . err . println ( e ) ; System . exit ( 1 ) ; return null ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" b . out \" ) ) ) ; final int MAX_CASES = readInt ( ) ; for ( int casenum = 1 ; casenum <= MAX_CASES ; casenum ++ ) { pw . printf ( \" Case \u2581 # % d : \u2581 \" , casenum ) ; String s = nextToken ( ) ; boolean [ ] good = new boolean [ s . length ( ) ] ; int ret = 0 ; boolean last = true ; for ( int i = 0 ; i < good . length ; i ++ ) { good [ i ] = s . charAt ( i ) == ' + ' ; if ( i > 0 && last != good [ i ] ) { ret ++ ; } last = good [ i ] ; } if ( ! last ) ret ++ ; pw . println ( ret ) ; } pw . close ( ) ; }"], ["readInt", "public static int readInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["readLong", "public static long readLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["readDouble", "public static double readDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; }"], ["nextToken", "public static String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { if ( ! br . ready ( ) ) { pw . close ( ) ; System . exit ( 0 ) ; } st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { System . err . println ( e ) ; System . exit ( 1 ) ; } } return st . nextToken ( ) ; }"], ["readLine", "public static String readLine ( ) { st = null ; try { return br . readLine ( ) ; } catch ( IOException e ) { System . err . println ( e ) ; System . exit ( 1 ) ; return null ; } }"]], "functions_class": []}, {"id": "0", "code": "import java . io . * ; import java . util . * ; public class revengepancake { private static InputReader in ; private static PrintWriter out ; public static boolean SUBMIT = true ; public static final String NAME = \" B - large \" ; private static void main2 ( ) throws IOException { char [ ] s = in . next ( ) . toCharArray ( ) ; int n = s . length ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) count ++ ; } if ( s [ n - 1 ] == ' - ' ) count ++ ; out . println ( count ) ; } public static void main ( String [ ] args ) throws IOException { if ( SUBMIT ) { in = new InputReader ( new FileInputStream ( new File ( NAME + \" . in \" ) ) ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ) ; } else { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out , true ) ; } int numCases = in . nextInt ( ) ; for ( int test = 1 ; test <= numCases ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; main2 ( ) ; } out . close ( ) ; System . exit ( 0 ) ; } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "functions_standalone": [["main2", "private static void main2 ( ) throws IOException { char [ ] s = in . next ( ) . toCharArray ( ) ; int n = s . length ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) count ++ ; } if ( s [ n - 1 ] == ' - ' ) count ++ ; out . println ( count ) ; }"], ["main", "public static void main ( String [ ] args ) throws IOException { if ( SUBMIT ) { in = new InputReader ( new FileInputStream ( new File ( NAME + \" . in \" ) ) ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ) ; } else { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out , true ) ; } int numCases = in . nextInt ( ) ; for ( int test = 1 ; test <= numCases ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; main2 ( ) ; } out . close ( ) ; System . exit ( 0 ) ; }"]], "functions_class": [["InputReader", "public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; }"], ["next", "public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }"]]}], "python": [{"id": "15", "code": "import sys NEW_LINE with open ( sys . argv [ 1 ] ) as f : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE DEDENT T = int ( lines [ 0 ] , 10 ) NEW_LINE for tt , l in enumerate ( lines [ 1 : ] ) : NEW_LINE INDENT pancakes = l . strip ( ) NEW_LINE done = False NEW_LINE flips = 0 NEW_LINE while 1 : NEW_LINE INDENT index = pancakes . rfind ( \" - \" ) NEW_LINE if index == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT flips += 1 NEW_LINE new_cakes = \" \" NEW_LINE for i in xrange ( index + 1 ) : NEW_LINE INDENT if pancakes [ i ] == \" + \" : NEW_LINE INDENT new_cakes += \" - \" NEW_LINE DEDENT elif pancakes [ i ] == \" - \" : NEW_LINE INDENT new_cakes += \" + \" NEW_LINE DEDENT else : NEW_LINE INDENT raise Exception ( \" wtf \" ) NEW_LINE DEDENT DEDENT pancakes = new_cakes + pancakes [ index + 1 : ] NEW_LINE DEDENT print ( \" Case \u2581 # % d : \" % ( tt + 1 ) ) , flips NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "f = open ( ' C : \\ \\ Users \\ \\ djspence \\ \\ Downloads \\ \\ B - large . in ' , ' r ' ) NEW_LINE tries = int ( f . readline ( ) ) NEW_LINE for i in range ( 0 , tries ) : NEW_LINE INDENT pans = f . readline ( ) . strip ( ) NEW_LINE flips = 0 NEW_LINE for j in range ( 1 , len ( pans ) ) : NEW_LINE INDENT if pans [ j ] != pans [ j - 1 ] : NEW_LINE INDENT flips += 1 NEW_LINE DEDENT DEDENT if pans [ len ( pans ) - 1 ] == \" - \" : NEW_LINE INDENT flips += 1 NEW_LINE DEDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( flips ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "6", "code": "import os , inspect NEW_LINE problemName = ' pancakes ' NEW_LINE runOnRealData = True NEW_LINE def solution ( string ) : NEW_LINE INDENT current = ' + ' NEW_LINE flips = 0 NEW_LINE for c in string [ : : - 1 ] : NEW_LINE INDENT if c != current : NEW_LINE INDENT flips += 1 NEW_LINE current = c NEW_LINE DEDENT DEDENT return flips NEW_LINE DEDENT currentDir = os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) NEW_LINE inputString = ' B - large . in ' NEW_LINE outputString = problemName + ( ' _ example _ output ' if not runOnRealData else ' _ output ' ) NEW_LINE inFile = os . path . join ( currentDir , ' inputfiles ' , inputString ) NEW_LINE outFile = os . path . join ( currentDir , ' outputfiles ' , ' % s . txt ' % outputString ) NEW_LINE if os . path . exists ( outFile ) : NEW_LINE INDENT os . remove ( outFile ) NEW_LINE DEDENT with open ( inFile , ' r ' ) as inputfile : NEW_LINE INDENT numberOfCases = int ( inputfile . readline ( ) ) NEW_LINE for case in xrange ( 1 , numberOfCases + 1 ) : NEW_LINE INDENT string = inputfile . readline ( ) . strip ( ) NEW_LINE result = solution ( string ) NEW_LINE with open ( outFile , ' a ' ) as f : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( case , result ) ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["solution", "def solution ( string ) : NEW_LINE INDENT current = ' + ' NEW_LINE flips = 0 NEW_LINE for c in string [ : : - 1 ] : NEW_LINE INDENT if c != current : NEW_LINE INDENT flips += 1 NEW_LINE current = c NEW_LINE DEDENT DEDENT return flips NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "import math NEW_LINE import itertools NEW_LINE import numpy as np NEW_LINE import devtools NEW_LINE def read_case ( f ) : NEW_LINE INDENT return read_letters ( f ) NEW_LINE DEDENT def solve_small ( case ) : NEW_LINE INDENT S = case NEW_LINE S . append ( ' + ' ) NEW_LINE return sum ( S [ i ] != S [ i + 1 ] for i in range ( len ( S ) - 1 ) ) NEW_LINE DEDENT def solve_large ( case ) : NEW_LINE INDENT return solve_small ( case ) NEW_LINE DEDENT def write_case ( f , i , res ) : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 ' % i ) NEW_LINE f . write ( ' % s ' % res ) NEW_LINE f . write ( ' \\n ' ) NEW_LINE DEDENT def read_word ( f ) : NEW_LINE INDENT return next ( f ) . strip ( ) NEW_LINE DEDENT def read_int ( f , b = 10 ) : NEW_LINE INDENT return int ( read_word ( f ) , b ) NEW_LINE DEDENT def read_letters ( f ) : NEW_LINE INDENT return list ( read_word ( f ) ) NEW_LINE DEDENT def read_digits ( f , b = 10 ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_letters ( f ) ] NEW_LINE DEDENT def read_words ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return read_word ( f ) . split ( d ) NEW_LINE DEDENT def read_ints ( f , b = 10 , d = ' \u2581 ' ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_words ( f , d ) ] NEW_LINE DEDENT def read_floats ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return [ float ( x ) for x in read_words ( f , d ) ] NEW_LINE DEDENT def read_arr ( f , R , reader = read_ints , * args , ** kwargs ) : NEW_LINE INDENT return [ reader ( f , * args , ** kwargs ) for i in range ( R ) ] NEW_LINE DEDENT def solve ( solver , fn , out_fn = None ) : NEW_LINE INDENT in_fn = fn + ' . in ' NEW_LINE if out_fn is None : NEW_LINE INDENT out_fn = fn + ' . out ' NEW_LINE DEDENT with open ( in_fn , ' r ' ) as fi : NEW_LINE INDENT with open ( out_fn , ' w ' ) as fo : NEW_LINE INDENT T = read_int ( fi ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT case = read_case ( fi ) NEW_LINE res = solver ( case ) NEW_LINE write_case ( fo , i , res ) NEW_LINE DEDENT DEDENT DEDENT DEDENT from run import * NEW_LINE", "functions_standalone": [["read_case", "def read_case ( f ) : NEW_LINE INDENT return read_letters ( f ) NEW_LINE DEDENT"], ["solve_small", "def solve_small ( case ) : NEW_LINE INDENT S = case NEW_LINE S . append ( ' + ' ) NEW_LINE return sum ( S [ i ] != S [ i + 1 ] for i in range ( len ( S ) - 1 ) ) NEW_LINE DEDENT"], ["solve_large", "def solve_large ( case ) : NEW_LINE INDENT return solve_small ( case ) NEW_LINE DEDENT"], ["write_case", "def write_case ( f , i , res ) : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 ' % i ) NEW_LINE f . write ( ' % s ' % res ) NEW_LINE f . write ( ' \\n ' ) NEW_LINE DEDENT"], ["read_word", "def read_word ( f ) : NEW_LINE INDENT return next ( f ) . strip ( ) NEW_LINE DEDENT"], ["read_int", "def read_int ( f , b = 10 ) : NEW_LINE INDENT return int ( read_word ( f ) , b ) NEW_LINE DEDENT"], ["read_letters", "def read_letters ( f ) : NEW_LINE INDENT return list ( read_word ( f ) ) NEW_LINE DEDENT"], ["read_digits", "def read_digits ( f , b = 10 ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_letters ( f ) ] NEW_LINE DEDENT"], ["read_words", "def read_words ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return read_word ( f ) . split ( d ) NEW_LINE DEDENT"], ["read_ints", "def read_ints ( f , b = 10 , d = ' \u2581 ' ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_words ( f , d ) ] NEW_LINE DEDENT"], ["read_floats", "def read_floats ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return [ float ( x ) for x in read_words ( f , d ) ] NEW_LINE DEDENT"], ["read_arr", "def read_arr ( f , R , reader = read_ints , * args , ** kwargs ) : NEW_LINE INDENT return [ reader ( f , * args , ** kwargs ) for i in range ( R ) ] NEW_LINE DEDENT"], ["solve", "def solve ( solver , fn , out_fn = None ) : NEW_LINE INDENT in_fn = fn + ' . in ' NEW_LINE if out_fn is None : NEW_LINE INDENT out_fn = fn + ' . out ' NEW_LINE DEDENT with open ( in_fn , ' r ' ) as fi : NEW_LINE INDENT with open ( out_fn , ' w ' ) as fo : NEW_LINE INDENT T = read_int ( fi ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT case = read_case ( fi ) NEW_LINE res = solver ( case ) NEW_LINE write_case ( fo , i , res ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "4", "code": "TEST = ' large ' NEW_LINE IN = ' B - { } . in ' . format ( TEST ) NEW_LINE OUT = ' B - { } . out ' . format ( TEST ) NEW_LINE def run ( stack ) : NEW_LINE INDENT n = len ( stack ) NEW_LINE stack += ' + ' NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if stack [ i ] != stack [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( IN ) as fin , open ( OUT , ' w ' ) as fout : NEW_LINE INDENT t = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT stack = fin . readline ( ) . strip ( ) NEW_LINE res = run ( stack ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , res ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["run", "def run ( stack ) : NEW_LINE INDENT n = len ( stack ) NEW_LINE stack += ' + ' NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if stack [ i ] != stack [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT with open ( IN ) as fin , open ( OUT , ' w ' ) as fout : NEW_LINE INDENT t = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT stack = fin . readline ( ) . strip ( ) NEW_LINE res = run ( stack ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , res ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_11", "java": [{"id": "9", "code": "import java . util . ArrayDeque ; import java . util . Deque ; import java . util . Scanner ; public class A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { String S = sc . next ( ) ; char ch = S . charAt ( 0 ) ; Deque < Character > chars = new ArrayDeque < > ( ) ; chars . addLast ( S . charAt ( 0 ) ) ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { char next = S . charAt ( i ) ; if ( next >= chars . getFirst ( ) ) { chars . addFirst ( next ) ; } else { chars . addLast ( next ) ; } } System . out . print ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" ) ; for ( Character c : chars ) { System . out . print ( c ) ; } System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { String S = sc . next ( ) ; char ch = S . charAt ( 0 ) ; Deque < Character > chars = new ArrayDeque < > ( ) ; chars . addLast ( S . charAt ( 0 ) ) ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { char next = S . charAt ( i ) ; if ( next >= chars . getFirst ( ) ) { chars . addFirst ( next ) ; } else { chars . addLast ( next ) ; } } System . out . print ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" ) ; for ( Character c : chars ) { System . out . print ( c ) ; } System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "15", "code": "package cj2016 . r1a ; import java . io . * ; import java . util . * ; public class A { Scanner sc ; PrintWriter pw ; char [ ] S ; public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" A - large \" ; try { new A ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } } public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; } void read ( Scanner sc ) { S = sc . next ( ) . toCharArray ( ) ; } void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; } void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; } public void solve ( ) { String ans = \" \" ; for ( char c : S ) { String s1 = ans + c ; String s2 = c + ans ; ans = s1 . compareTo ( s2 ) < 0 ? s2 : s1 ; } println ( ans ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" A - large \" ; try { new A ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } }"]], "functions_class": [["run", "public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; }"], ["read", "void read ( Scanner sc ) { S = sc . next ( ) . toCharArray ( ) ; }"], ["print", "void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; }"], ["println", "void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; }"], ["solve", "public void solve ( ) { String ans = \" \" ; for ( char c : S ) { String s1 = ans + c ; String s2 = c + ans ; ans = s1 . compareTo ( s2 ) < 0 ? s2 : s1 ; } println ( ans ) ; }"]]}, {"id": "12", "code": "package lab6zp ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Lab6ZP { public static String solve ( String s , int x ) { if ( s . equals ( \" . \" ) ) { return \" \" ; } String t = \" \" ; char c = ' Z ' ; c -= x ; String [ ] u = s . split ( Character . toString ( c ) ) ; for ( int i = 0 ; i < u . length - 1 ; i ++ ) { t += c ; } for ( int i = 0 ; i < u . length ; i ++ ) { if ( i == 0 ) { t += solve ( u [ i ] , x + 1 ) ; } else { t += remove ( u [ i ] ) ; } } return t ; } public static String remove ( String s ) { String t = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != ' . ' ) { t += s . charAt ( i ) ; } } return t ; } public static String interlace ( String s ) { String t = \" . \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { t += s . charAt ( i ) ; t += \" . \" ; } return t ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = Integer . parseInt ( in . next ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; s = interlace ( s ) ; System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + solve ( s , 0 ) ) ; } } }", "functions_standalone": [["solve", "public static String solve ( String s , int x ) { if ( s . equals ( \" . \" ) ) { return \" \" ; } String t = \" \" ; char c = ' Z ' ; c -= x ; String [ ] u = s . split ( Character . toString ( c ) ) ; for ( int i = 0 ; i < u . length - 1 ; i ++ ) { t += c ; } for ( int i = 0 ; i < u . length ; i ++ ) { if ( i == 0 ) { t += solve ( u [ i ] , x + 1 ) ; } else { t += remove ( u [ i ] ) ; } } return t ; }"], ["remove", "public static String remove ( String s ) { String t = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != ' . ' ) { t += s . charAt ( i ) ; } } return t ; }"], ["interlace", "public static String interlace ( String s ) { String t = \" . \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { t += s . charAt ( i ) ; t += \" . \" ; } return t ; }"], ["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = Integer . parseInt ( in . next ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; s = interlace ( s ) ; System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + solve ( s , 0 ) ) ; } }"]], "functions_class": []}, {"id": "14", "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . PrintWriter ; public class Round1A { public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( \" A . txt \" ) ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int c = 1 ; c <= T ; c ++ ) { String s = in . readLine ( ) ; int [ ] fl = new int [ s . length ( ) ] ; int nfl = 0 ; while ( nfl < s . length ( ) ) { char last = ( char ) ( ' A ' - 1 ) ; int firstL = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( fl [ i ] == 0 && s . charAt ( i ) > last ) { last = s . charAt ( i ) ; firstL = i ; } } for ( int i = firstL ; i < s . length ( ) ; i ++ ) { if ( fl [ i ] == 0 ) { nfl ++ ; if ( s . charAt ( i ) == last ) { fl [ i ] = 1 ; } else fl [ i ] = - 1 ; } } } String ans = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( fl [ i ] == 1 ) { ans = s . charAt ( i ) + ans ; } else if ( fl [ i ] == - 1 ) { ans = ans + s . charAt ( i ) ; } } pw . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + ans ) ; } pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( \" A . txt \" ) ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int c = 1 ; c <= T ; c ++ ) { String s = in . readLine ( ) ; int [ ] fl = new int [ s . length ( ) ] ; int nfl = 0 ; while ( nfl < s . length ( ) ) { char last = ( char ) ( ' A ' - 1 ) ; int firstL = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( fl [ i ] == 0 && s . charAt ( i ) > last ) { last = s . charAt ( i ) ; firstL = i ; } } for ( int i = firstL ; i < s . length ( ) ; i ++ ) { if ( fl [ i ] == 0 ) { nfl ++ ; if ( s . charAt ( i ) == last ) { fl [ i ] = 1 ; } else fl [ i ] = - 1 ; } } } String ans = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( fl [ i ] == 1 ) { ans = s . charAt ( i ) + ans ; } else if ( fl [ i ] == - 1 ) { ans = ans + s . charAt ( i ) ; } } pw . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + ans ) ; } pw . close ( ) ; }"]], "functions_class": []}, {"id": "1", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class a { public static void main ( String [ ] Args ) throws Exception { FS sc = new FS ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" a . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { out . printf ( \" Case \u2581 # % d : \u2581 \" , ++ cc ) ; String s = sc . next ( ) ; out . printf ( \" % s \" , foo ( s ) ) ; out . println ( \" \" ) ; } out . close ( ) ; } public static String foo ( String s ) throws Exception { if ( s . length ( ) == 0 ) return \" \" ; int last = ' A ' ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { last = Math . max ( last , s . charAt ( i ) ) ; } for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == last ) { return ( char ) ( last ) + foo ( s . substring ( 0 , i ) ) + s . substring ( i + 1 ) ; } } throw new Exception ( \" BANANAS \" ) ; } public static class FS { BufferedReader br ; StringTokenizer st ; FS ( InputStream in ) throws Exception { br = new BufferedReader ( new InputStreamReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; } FS ( File in ) throws Exception { br = new BufferedReader ( new FileReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; } String next ( ) throws Exception { if ( st . hasMoreTokens ( ) ) return st . nextToken ( ) ; st = new StringTokenizer ( br . readLine ( ) ) ; return next ( ) ; } int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] Args ) throws Exception { FS sc = new FS ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" a . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { out . printf ( \" Case \u2581 # % d : \u2581 \" , ++ cc ) ; String s = sc . next ( ) ; out . printf ( \" % s \" , foo ( s ) ) ; out . println ( \" \" ) ; } out . close ( ) ; }"], ["foo", "public static String foo ( String s ) throws Exception { if ( s . length ( ) == 0 ) return \" \" ; int last = ' A ' ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { last = Math . max ( last , s . charAt ( i ) ) ; } for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == last ) { return ( char ) ( last ) + foo ( s . substring ( 0 , i ) ) + s . substring ( i + 1 ) ; } } throw new Exception ( \" BANANAS \" ) ; }"]], "functions_class": [["FS", "FS ( InputStream in ) throws Exception { br = new BufferedReader ( new InputStreamReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; }"], ["FS", "FS ( File in ) throws Exception { br = new BufferedReader ( new FileReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; }"], ["next", "String next ( ) throws Exception { if ( st . hasMoreTokens ( ) ) return st . nextToken ( ) ; st = new StringTokenizer ( br . readLine ( ) ) ; return next ( ) ; }"], ["nextInt", "int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; }"]]}], "python": [{"id": "11", "code": "class Case : NEW_LINE INDENT def __init__ ( self , fin , fout , n ) : NEW_LINE INDENT self . _fin = fin NEW_LINE self . _fout = fout NEW_LINE self . _n = n NEW_LINE self . _line = None NEW_LINE DEDENT def readInt ( self ) : NEW_LINE INDENT if self . _line is None : NEW_LINE INDENT self . _line = self . _fin . readline ( ) . split ( \" \u2581 \" ) NEW_LINE DEDENT result = int ( self . _line . pop ( 0 ) ) NEW_LINE if len ( self . _line ) == 0 : NEW_LINE INDENT self . _line = None NEW_LINE DEDENT return result NEW_LINE DEDENT def readLine ( self ) : NEW_LINE INDENT line = self . _fin . readline ( ) NEW_LINE if line [ - 1 ] == \" \\n \" : NEW_LINE INDENT return line [ : - 1 ] NEW_LINE DEDENT return line NEW_LINE DEDENT def output ( self , s ) : NEW_LINE INDENT if s is None : NEW_LINE INDENT return NEW_LINE DEDENT s = str ( s ) NEW_LINE if \" \\n \" in s : NEW_LINE INDENT self . _fout . write ( \" Case \u2581 # % d : % s \" % ( self . _n , s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . _fout . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( self . _n , s ) ) NEW_LINE DEDENT DEDENT DEDENT def run ( fileName , solve ) : NEW_LINE INDENT fin = open ( fileName ) NEW_LINE fout = open ( fileName + \" . out \" , \" w \" ) NEW_LINE caseCount = int ( fin . readline ( ) ) NEW_LINE for i in range ( caseCount ) : NEW_LINE INDENT case = Case ( fin , fout , i + 1 ) NEW_LINE case . output ( solve ( case ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["run", "def run ( fileName , solve ) : NEW_LINE INDENT fin = open ( fileName ) NEW_LINE fout = open ( fileName + \" . out \" , \" w \" ) NEW_LINE caseCount = int ( fin . readline ( ) ) NEW_LINE for i in range ( caseCount ) : NEW_LINE INDENT case = Case ( fin , fout , i + 1 ) NEW_LINE case . output ( solve ( case ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": [["__init__", "def __init__ ( self , fin , fout , n ) : NEW_LINE INDENT self . _fin = fin NEW_LINE self . _fout = fout NEW_LINE self . _n = n NEW_LINE self . _line = None NEW_LINE DEDENT"], ["readInt", "def readInt ( self ) : NEW_LINE INDENT if self . _line is None : NEW_LINE INDENT self . _line = self . _fin . readline ( ) . split ( \" \u2581 \" ) NEW_LINE DEDENT result = int ( self . _line . pop ( 0 ) ) NEW_LINE if len ( self . _line ) == 0 : NEW_LINE INDENT self . _line = None NEW_LINE DEDENT return result NEW_LINE DEDENT"], ["readLine", "def readLine ( self ) : NEW_LINE INDENT line = self . _fin . readline ( ) NEW_LINE if line [ - 1 ] == \" \\n \" : NEW_LINE INDENT return line [ : - 1 ] NEW_LINE DEDENT return line NEW_LINE DEDENT"], ["output", "def output ( self , s ) : NEW_LINE INDENT if s is None : NEW_LINE INDENT return NEW_LINE DEDENT s = str ( s ) NEW_LINE if \" \\n \" in s : NEW_LINE INDENT self . _fout . write ( \" Case \u2581 # % d : % s \" % ( self . _n , s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . _fout . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( self . _n , s ) ) NEW_LINE DEDENT DEDENT"]]}, {"id": "18", "code": "import io , sys NEW_LINE import datetime , copy NEW_LINE fin = None NEW_LINE def solve ( ) : NEW_LINE INDENT s = sstrip ( ) NEW_LINE res = ' ' NEW_LINE for c in s : NEW_LINE INDENT res = max ( c + res , res + c ) NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT fname = ' a . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . out ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT s = sstrip ( ) NEW_LINE res = ' ' NEW_LINE for c in s : NEW_LINE INDENT res = max ( c + res , res + c ) NEW_LINE DEDENT return res NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT fname = ' a . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . out ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT"], ["nums", "def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["fnums", "def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["num", "def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT"], ["sstrip", "def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT"], ["strs", "def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT"], ["arrstr", "def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "task = ' A ' NEW_LINE type = 2 NEW_LINE if type == 0 : NEW_LINE INDENT inp = open ( ' sample . in ' , ' r ' ) NEW_LINE DEDENT elif type == 1 : NEW_LINE INDENT inp = open ( ' % s - small . in ' % ( task , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT inp = open ( ' % s - large . in ' % ( task ) , ) NEW_LINE DEDENT outp = open ( ' % s . out ' % ( task , ) , ' w ' ) NEW_LINE T = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT ans = ' ' NEW_LINE st = inp . readline ( ) [ : - 1 ] NEW_LINE curmax = 0 NEW_LINE for c in st : NEW_LINE INDENT if ord ( c ) >= curmax : NEW_LINE INDENT ans = c + ans NEW_LINE curmax = ord ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + c NEW_LINE DEDENT DEDENT outp . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "3", "code": "def one_test ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE res = \" \" NEW_LINE for c in s : NEW_LINE INDENT res = max ( c + res , res + c ) NEW_LINE DEDENT return res NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i , one_test ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["one_test", "def one_test ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE res = \" \" NEW_LINE for c in s : NEW_LINE INDENT res = max ( c + res , res + c ) NEW_LINE DEDENT return res NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE fin = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fout = open ( \" p1 . out \" , \" w \" ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for tt in xrange ( T ) : NEW_LINE INDENT S = fin . readline ( ) . strip ( ) NEW_LINE ans = ' ' NEW_LINE for c in S : NEW_LINE INDENT if c + ans < ans + c : NEW_LINE INDENT ans = ans + c NEW_LINE DEDENT else : NEW_LINE INDENT ans = c + ans NEW_LINE DEDENT DEDENT fout . write ( \" Case \u2581 # \" + str ( tt + 1 ) + \" : \u2581 \" + ans + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_16_42", "java": [{"id": "10", "code": "import java . util . * ; import java . io . * ; public class B { static int N ; static double ans ; public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { N = input . nextInt ( ) ; int K = input . nextInt ( ) ; double [ ] ps = new double [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ps [ i ] = input . nextDouble ( ) ; ans = 0 ; solve ( new ArrayList < Double > ( ) , ps , K , 0 ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( ans ) ; } } static void solve ( List < Double > keep , double [ ] ps , int K , int index ) { if ( index == ps . length ) { if ( keep . size ( ) == K ) check ( keep , K ) ; return ; } solve ( keep , ps , K , index + 1 ) ; keep . add ( ps [ index ] ) ; solve ( keep , ps , K , index + 1 ) ; keep . remove ( keep . size ( ) - 1 ) ; } static void check ( List < Double > keep , int K ) { double [ ] [ ] table = new double [ K + 1 ] [ K + 1 ] ; table [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) for ( int yes = 0 ; yes <= i ; yes ++ ) { table [ i ] [ yes ] = table [ i - 1 ] [ yes ] * ( 1 - keep . get ( i - 1 ) ) ; if ( yes > 0 ) table [ i ] [ yes ] += table [ i - 1 ] [ yes - 1 ] * keep . get ( i - 1 ) ; } if ( table [ K ] [ K / 2 ] > ans ) ans = table [ K ] [ K / 2 ] ; } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { N = input . nextInt ( ) ; int K = input . nextInt ( ) ; double [ ] ps = new double [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ps [ i ] = input . nextDouble ( ) ; ans = 0 ; solve ( new ArrayList < Double > ( ) , ps , K , 0 ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( ans ) ; } }"], ["solve", "static void solve ( List < Double > keep , double [ ] ps , int K , int index ) { if ( index == ps . length ) { if ( keep . size ( ) == K ) check ( keep , K ) ; return ; } solve ( keep , ps , K , index + 1 ) ; keep . add ( ps [ index ] ) ; solve ( keep , ps , K , index + 1 ) ; keep . remove ( keep . size ( ) - 1 ) ; }"], ["check", "static void check ( List < Double > keep , int K ) { double [ ] [ ] table = new double [ K + 1 ] [ K + 1 ] ; table [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) for ( int yes = 0 ; yes <= i ; yes ++ ) { table [ i ] [ yes ] = table [ i - 1 ] [ yes ] * ( 1 - keep . get ( i - 1 ) ) ; if ( yes > 0 ) table [ i ] [ yes ] += table [ i - 1 ] [ yes - 1 ] * keep . get ( i - 1 ) ; } if ( table [ K ] [ K / 2 ] > ans ) ans = table [ K ] [ K / 2 ] ; }"]], "functions_class": []}, {"id": "20", "code": "import java . util . Arrays ; import java . util . Scanner ; public class B { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; System . out . printf ( \" % .9f \\n \" , solve ( ) ) ; } } static double solve ( ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; double [ ] Pt = new double [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { Pt [ i ] = sc . nextDouble ( ) ; } Arrays . sort ( Pt ) ; double [ ] P = new double [ K ] ; double ans = 0 ; for ( int u = 0 ; u <= K ; ++ u ) { for ( int i = 0 ; i < u ; ++ i ) { P [ i ] = Pt [ i ] ; } for ( int i = u ; i < K ; ++ i ) { P [ i ] = Pt [ N - 1 - ( i - u ) ] ; } double [ ] [ ] dp = new double [ K + 1 ] [ K + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { if ( j == 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] * ( 1 - P [ i - 1 ] ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] * ( 1 - P [ i - 1 ] ) + dp [ i - 1 ] [ j - 1 ] * P [ i - 1 ] ) ; } } } ans = Math . max ( ans , dp [ K ] [ K / 2 ] ) ; } return ans ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; System . out . printf ( \" % .9f \\n \" , solve ( ) ) ; } }"], ["solve", "static double solve ( ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; double [ ] Pt = new double [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { Pt [ i ] = sc . nextDouble ( ) ; } Arrays . sort ( Pt ) ; double [ ] P = new double [ K ] ; double ans = 0 ; for ( int u = 0 ; u <= K ; ++ u ) { for ( int i = 0 ; i < u ; ++ i ) { P [ i ] = Pt [ i ] ; } for ( int i = u ; i < K ; ++ i ) { P [ i ] = Pt [ N - 1 - ( i - u ) ] ; } double [ ] [ ] dp = new double [ K + 1 ] [ K + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { if ( j == 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] * ( 1 - P [ i - 1 ] ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] * ( 1 - P [ i - 1 ] ) + dp [ i - 1 ] [ j - 1 ] * P [ i - 1 ] ) ; } } } ans = Math . max ( ans , dp [ K ] [ K / 2 ] ) ; } return ans ; }"]], "functions_class": []}], "python": [{"id": "10", "code": "__author__ = ' Tianren \u2581 Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( Choose , Target , p , dis ) : NEW_LINE INDENT if len ( dis ) - 1 + Choose < Target : NEW_LINE INDENT return 0. NEW_LINE DEDENT if Choose == 0 : NEW_LINE INDENT return dis [ Target ] NEW_LINE DEDENT if Choose > len ( p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ndis = np . zeros ( len ( dis ) + 1 ) NEW_LINE ndis [ : len ( dis ) ] += dis * ( 1 - p [ 0 ] ) NEW_LINE ndis [ 1 : ] += dis * p [ 0 ] NEW_LINE res = max ( solve ( Choose - 1 , Target , p [ 1 : ] , ndis ) , solve ( Choose , Target , p [ 1 : ] , dis ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , K = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE p = [ float ( f ) for f in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( t + 1 , solve ( K , K // 2 , p , np . array ( [ 1. ] ) ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solve", "def solve ( Choose , Target , p , dis ) : NEW_LINE INDENT if len ( dis ) - 1 + Choose < Target : NEW_LINE INDENT return 0. NEW_LINE DEDENT if Choose == 0 : NEW_LINE INDENT return dis [ Target ] NEW_LINE DEDENT if Choose > len ( p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ndis = np . zeros ( len ( dis ) + 1 ) NEW_LINE ndis [ : len ( dis ) ] += dis * ( 1 - p [ 0 ] ) NEW_LINE ndis [ 1 : ] += dis * p [ 0 ] NEW_LINE res = max ( solve ( Choose - 1 , Target , p [ 1 : ] , ndis ) , solve ( Choose , Target , p [ 1 : ] , dis ) ) NEW_LINE return res NEW_LINE DEDENT"]], "functions_class": []}, {"id": "12", "code": "from multiprocessing import Pool NEW_LINE from pprint import pprint NEW_LINE import sys NEW_LINE def calcprob ( p ) : NEW_LINE INDENT prob = { } NEW_LINE k = len ( p ) NEW_LINE assert k % 2 == 0 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT prob [ ( 0 , j ) ] = 0 NEW_LINE DEDENT prob [ ( 0 , 0 ) ] = 1 NEW_LINE i = 0 NEW_LINE for pp in p : NEW_LINE INDENT i += 1 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT res = prob [ ( i - 1 , j ) ] * ( 1 - pp ) NEW_LINE if j > 0 : NEW_LINE INDENT res = res + prob [ ( i - 1 , j - 1 ) ] * pp NEW_LINE DEDENT prob [ ( i , j ) ] = res NEW_LINE DEDENT DEDENT return prob [ ( i , k // 2 ) ] NEW_LINE DEDENT def solve_test ( data ) : NEW_LINE INDENT n , k , p = data NEW_LINE p = sorted ( p ) NEW_LINE ans = - 1 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT left = i NEW_LINE right = k - i NEW_LINE pp = p [ : i ] + p [ n - right : ] NEW_LINE assert len ( pp ) == k NEW_LINE prob = calcprob ( pp ) NEW_LINE if prob > ans : NEW_LINE INDENT ans = prob NEW_LINE DEDENT DEDENT sys . stderr . write ( ' . ' ) NEW_LINE return ans NEW_LINE DEDENT tests = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for test in range ( tests ) : NEW_LINE INDENT sys . stderr . write ( str ( test ) ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE data . append ( ( n , k , p ) ) NEW_LINE DEDENT with Pool ( 6 ) as p : NEW_LINE INDENT res = p . map ( solve_test , data ) NEW_LINE DEDENT for test in range ( tests ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 % 0.8f \" % ( test + 1 , res [ test ] ) ) NEW_LINE DEDENT", "functions_standalone": [["calcprob", "def calcprob ( p ) : NEW_LINE INDENT prob = { } NEW_LINE k = len ( p ) NEW_LINE assert k % 2 == 0 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT prob [ ( 0 , j ) ] = 0 NEW_LINE DEDENT prob [ ( 0 , 0 ) ] = 1 NEW_LINE i = 0 NEW_LINE for pp in p : NEW_LINE INDENT i += 1 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT res = prob [ ( i - 1 , j ) ] * ( 1 - pp ) NEW_LINE if j > 0 : NEW_LINE INDENT res = res + prob [ ( i - 1 , j - 1 ) ] * pp NEW_LINE DEDENT prob [ ( i , j ) ] = res NEW_LINE DEDENT DEDENT return prob [ ( i , k // 2 ) ] NEW_LINE DEDENT"], ["solve_test", "def solve_test ( data ) : NEW_LINE INDENT n , k , p = data NEW_LINE p = sorted ( p ) NEW_LINE ans = - 1 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT left = i NEW_LINE right = k - i NEW_LINE pp = p [ : i ] + p [ n - right : ] NEW_LINE assert len ( pp ) == k NEW_LINE prob = calcprob ( pp ) NEW_LINE if prob > ans : NEW_LINE INDENT ans = prob NEW_LINE DEDENT DEDENT sys . stderr . write ( ' . ' ) NEW_LINE return ans NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "prob = [ ] NEW_LINE dp = [ [ ] ] NEW_LINE def func ( cur , rem ) : NEW_LINE INDENT if cur < 0 : NEW_LINE INDENT if rem > 0 or rem < 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT DEDENT if rem < 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT if dp [ cur ] [ rem ] < 0 : NEW_LINE INDENT dp [ cur ] [ rem ] = func ( cur - 1 , rem - 1 ) * ( 1 - prob [ cur ] ) NEW_LINE dp [ cur ] [ rem ] += func ( cur - 1 , rem ) * prob [ cur ] NEW_LINE DEDENT return dp [ cur ] [ rem ] NEW_LINE DEDENT t = input ( ) NEW_LINE for tcase in range ( 1 , t + 1 ) : NEW_LINE INDENT n , k = map ( int , raw_input ( ) . split ( ) ) NEW_LINE ar = [ float ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE ar . sort ( ) NEW_LINE res = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prob = [ ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT prob . append ( ar [ j ] ) NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT prob . append ( ar [ j ] ) NEW_LINE DEDENT dp = [ [ - 1 for i1 in range ( n + 1 ) ] for j1 in range ( n + 1 ) ] NEW_LINE res = max ( res , func ( k - 1 , k / 2 ) ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % 0.9lf \" % ( tcase , res ) ) NEW_LINE DEDENT", "functions_standalone": [["func", "def func ( cur , rem ) : NEW_LINE INDENT if cur < 0 : NEW_LINE INDENT if rem > 0 or rem < 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT DEDENT if rem < 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT if dp [ cur ] [ rem ] < 0 : NEW_LINE INDENT dp [ cur ] [ rem ] = func ( cur - 1 , rem - 1 ) * ( 1 - prob [ cur ] ) NEW_LINE dp [ cur ] [ rem ] += func ( cur - 1 , rem ) * prob [ cur ] NEW_LINE DEDENT return dp [ cur ] [ rem ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "14", "code": "def m ( p ) : NEW_LINE INDENT return lambda x : x * p NEW_LINE DEDENT def aa ( u , v ) : NEW_LINE INDENT for x , y in zip ( u , v ) : NEW_LINE INDENT yield x + y NEW_LINE DEDENT DEDENT def get_p ( a ) : NEW_LINE INDENT u = [ 1 ] NEW_LINE for x in a : NEW_LINE INDENT u = list ( aa ( [ 0 , 0 ] + list ( map ( m ( x ) , u ) ) , list ( map ( m ( 1 - x ) , u ) ) + [ 0 , 0 ] ) ) NEW_LINE DEDENT return u [ len ( u ) >> 1 ] NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = sorted ( list ( map ( float , input ( ) . split ( ) ) ) ) NEW_LINE r = 0 NEW_LINE for j in range ( k + 1 ) : NEW_LINE INDENT v = p [ : j ] + p [ : : - 1 ] [ : k - j ] NEW_LINE assert ( len ( v ) == k ) NEW_LINE r = max ( r , get_p ( v ) ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % .12f \" % ( i + 1 , r ) ) NEW_LINE DEDENT", "functions_standalone": [["m", "def m ( p ) : NEW_LINE INDENT return lambda x : x * p NEW_LINE DEDENT"], ["aa", "def aa ( u , v ) : NEW_LINE INDENT for x , y in zip ( u , v ) : NEW_LINE INDENT yield x + y NEW_LINE DEDENT DEDENT"], ["get_p", "def get_p ( a ) : NEW_LINE INDENT u = [ 1 ] NEW_LINE for x in a : NEW_LINE INDENT u = list ( aa ( [ 0 , 0 ] + list ( map ( m ( x ) , u ) ) , list ( map ( m ( 1 - x ) , u ) ) + [ 0 , 0 ] ) ) NEW_LINE DEDENT return u [ len ( u ) >> 1 ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "import sys NEW_LINE from itertools import combinations NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , K = list ( map ( int , fin . readline ( ) . split ( ) ) ) NEW_LINE P = list ( map ( float , fin . readline ( ) . split ( ) ) ) NEW_LINE P . sort ( ) NEW_LINE M = K // 2 + 1 NEW_LINE best = ( 0 , [ ] ) NEW_LINE for c in range ( K + 1 ) : NEW_LINE INDENT combination = P [ : c ] NEW_LINE if c < K : NEW_LINE INDENT combination += P [ - ( K - c ) : ] NEW_LINE DEDENT s = [ 0 ] * M NEW_LINE s [ 0 ] = 1 NEW_LINE for a1 in combination : NEW_LINE INDENT a0 = 1 - a1 NEW_LINE ss = [ 0 ] * M NEW_LINE ss [ 0 ] = s [ 0 ] * a0 NEW_LINE for k in range ( M ) : NEW_LINE INDENT ss [ k ] = s [ k - 1 ] * a1 + s [ k ] * a0 NEW_LINE DEDENT s = ss NEW_LINE DEDENT best = max ( best , ( s [ - 1 ] , combination ) ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , best [ 0 ] ) ) NEW_LINE DEDENT", "functions_standalone": [["debug", "def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_21", "java": [{"id": "9", "code": "import java . util . * ; import static java . lang . Math . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; int [ ] num = { 0 , 6 , 2 , 8 , 3 , 4 , 5 , 7 , 1 , 9 } ; char [ ] ch = { ' Z ' , ' X ' , ' W ' , ' G ' , ' H ' , ' R ' , ' F ' , ' V ' , ' O ' , ' E ' } ; String [ ] word = { \" ZERO \" , \" SIX \" , \" TWO \" , \" EIGHT \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SEVEN \" , \" ONE \" , \" NINE \" } ; for ( int zz = 1 ; zz <= T ; zz ++ ) { String S = in . next ( ) ; int [ ] C = new int [ 26 ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { C [ ( int ) ( S . charAt ( i ) - ' A ' ) ] ++ ; } int [ ] ans = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int count = C [ ( int ) ( ch [ i ] - ' A ' ) ] ; ans [ num [ i ] ] += count ; for ( int j = 0 ; j < word [ i ] . length ( ) ; j ++ ) { C [ ( int ) ( word [ i ] . charAt ( j ) - ' A ' ) ] -= count ; } } for ( int i = 0 ; i < 10 ; i ++ ) { if ( C [ i ] != 0 ) { throw new RuntimeException ( ) ; } } System . out . format ( \" Case \u2581 # % d : \u2581 \" , zz ) ; for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 0 ; j < ans [ i ] ; j ++ ) System . out . print ( i ) ; System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; int [ ] num = { 0 , 6 , 2 , 8 , 3 , 4 , 5 , 7 , 1 , 9 } ; char [ ] ch = { ' Z ' , ' X ' , ' W ' , ' G ' , ' H ' , ' R ' , ' F ' , ' V ' , ' O ' , ' E ' } ; String [ ] word = { \" ZERO \" , \" SIX \" , \" TWO \" , \" EIGHT \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SEVEN \" , \" ONE \" , \" NINE \" } ; for ( int zz = 1 ; zz <= T ; zz ++ ) { String S = in . next ( ) ; int [ ] C = new int [ 26 ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { C [ ( int ) ( S . charAt ( i ) - ' A ' ) ] ++ ; } int [ ] ans = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { int count = C [ ( int ) ( ch [ i ] - ' A ' ) ] ; ans [ num [ i ] ] += count ; for ( int j = 0 ; j < word [ i ] . length ( ) ; j ++ ) { C [ ( int ) ( word [ i ] . charAt ( j ) - ' A ' ) ] -= count ; } } for ( int i = 0 ; i < 10 ; i ++ ) { if ( C [ i ] != 0 ) { throw new RuntimeException ( ) ; } } System . out . format ( \" Case \u2581 # % d : \u2581 \" , zz ) ; for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 0 ; j < ans [ i ] ; j ++ ) System . out . print ( i ) ; System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "18", "code": "package r1b2016 ; import java . io . File ; import java . io . PrintWriter ; import java . util . Scanner ; public class A { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; for ( int t = Integer . valueOf ( in . nextLine ( ) ) , cs = 1 ; t > 0 ; t -- , cs ++ ) { out . print ( \" Case \u2581 # \" + cs + \" : \u2581 \" ) ; int [ ] cnt = new int [ 256 ] ; char [ ] s = in . next ( ) . toCharArray ( ) ; for ( char c : s ) { cnt [ c ] ++ ; } int [ ] ans = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { while ( cnt [ oo [ i ] ] > 0 ) { ans [ dd [ i ] ] ++ ; for ( int j = 0 ; j < ss [ i ] . length ( ) ; j ++ ) { cnt [ ss [ i ] . charAt ( j ) ] -- ; } } } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < ans [ i ] ; j ++ ) { out . print ( i ) ; } } out . println ( ) ; } out . flush ( ) ; } static char [ ] oo = { ' X ' , ' G ' , ' U ' , ' W ' , ' Z ' , ' F ' , ' V ' , ' R ' , ' I ' , ' O ' } ; static String [ ] ss = { \" SIX \" , \" EIGHT \" , \" FOUR \" , \" TWO \" , \" ZERO \" , \" FIVE \" , \" SEVEN \" , \" THREE \" , \" NINE \" , \" ONE \" } ; static int [ ] dd = { 6 , 8 , 4 , 2 , 0 , 5 , 7 , 3 , 9 , 1 } ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; for ( int t = Integer . valueOf ( in . nextLine ( ) ) , cs = 1 ; t > 0 ; t -- , cs ++ ) { out . print ( \" Case \u2581 # \" + cs + \" : \u2581 \" ) ; int [ ] cnt = new int [ 256 ] ; char [ ] s = in . next ( ) . toCharArray ( ) ; for ( char c : s ) { cnt [ c ] ++ ; } int [ ] ans = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { while ( cnt [ oo [ i ] ] > 0 ) { ans [ dd [ i ] ] ++ ; for ( int j = 0 ; j < ss [ i ] . length ( ) ; j ++ ) { cnt [ ss [ i ] . charAt ( j ) ] -- ; } } } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < ans [ i ] ; j ++ ) { out . print ( i ) ; } } out . println ( ) ; } out . flush ( ) ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE inp = sys . stdin NEW_LINE outp = sys . stdout NEW_LINE words = [ \" ZERO \" , \" ONE \" , \" TWO \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SIX \" , \" SEVEN \" , \" EIGHT \" , \" NINE \" ] NEW_LINE m = [ ( 0 , ' Z ' ) , ( 2 , ' W ' ) , ( 4 , ' U ' ) , ( 6 , ' X ' ) , ( 7 , ' S ' ) , ( 5 , ' V ' ) , ( 1 , ' O ' ) , ( 3 , ' R ' ) , ( 8 , ' H ' ) , ( 9 , ' E ' ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT x = sys . stdin . readline ( ) . strip ( ) NEW_LINE f = [ 0 ] * 10 NEW_LINE for ( d , c ) in m : NEW_LINE INDENT cnt = x . count ( c ) NEW_LINE f [ d ] += cnt NEW_LINE for c2 in words [ d ] : NEW_LINE INDENT x = x . replace ( c2 , ' ' , cnt ) NEW_LINE DEDENT DEDENT assert x == ' ' NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT outp . write ( ( ' % d ' % i ) * f [ i ] ) NEW_LINE DEDENT print NEW_LINE DEDENT T = int ( inp . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT outp . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE solve ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "13", "code": "from collections import Counter NEW_LINE T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT c = Counter ( input ( ) ) NEW_LINE res = { d : 0 for d in range ( 10 ) } NEW_LINE res [ 8 ] = c [ ' G ' ] NEW_LINE for let in ' EIGHT ' : NEW_LINE INDENT c [ let ] -= res [ 8 ] NEW_LINE DEDENT res [ 3 ] = c [ ' H ' ] NEW_LINE for let in ' THREE ' : NEW_LINE INDENT c [ let ] -= res [ 3 ] NEW_LINE DEDENT res [ 4 ] = c [ ' U ' ] NEW_LINE for let in ' FOUR ' : NEW_LINE INDENT c [ let ] -= res [ 4 ] NEW_LINE DEDENT res [ 2 ] = c [ ' W ' ] NEW_LINE for let in ' TWO ' : NEW_LINE INDENT c [ let ] -= res [ 2 ] NEW_LINE DEDENT res [ 6 ] = c [ ' X ' ] NEW_LINE for let in ' SIX ' : NEW_LINE INDENT c [ let ] -= res [ 6 ] NEW_LINE DEDENT res [ 5 ] = c [ ' F ' ] NEW_LINE for let in ' FIVE ' : NEW_LINE INDENT c [ let ] -= res [ 5 ] NEW_LINE DEDENT res [ 7 ] = c [ ' V ' ] NEW_LINE for let in ' SEVEN ' : NEW_LINE INDENT c [ let ] -= res [ 7 ] NEW_LINE DEDENT res [ 0 ] = c [ ' Z ' ] NEW_LINE for let in ' ZERO ' : NEW_LINE INDENT c [ let ] -= res [ 0 ] NEW_LINE DEDENT res [ 1 ] = c [ ' O ' ] NEW_LINE for let in ' ONE ' : NEW_LINE INDENT c [ let ] -= res [ 1 ] NEW_LINE DEDENT res [ 9 ] = c [ ' I ' ] NEW_LINE for let in ' NINE ' : NEW_LINE INDENT c [ let ] -= res [ 9 ] NEW_LINE DEDENT ans = ' ' . join ( str ( d ) * res [ d ] for d in range ( 10 ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( t + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "11", "code": "import sys NEW_LINE sys . stdin = open ( \" A - large . in \" , \" r \" ) NEW_LINE nn = [ \" ZERO \" , \" ONE \" , \" TWO \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SIX \" , \" SEVEN \" , \" EIGHT \" , \" NINE \" ] NEW_LINE tn = int ( input ( ) ) NEW_LINE for test in range ( 1 , tn + 1 ) : NEW_LINE INDENT s = input ( ) NEW_LINE v = { } NEW_LINE for x in s : NEW_LINE INDENT if x not in v : NEW_LINE INDENT v [ x ] = 0 NEW_LINE DEDENT v [ x ] += 1 NEW_LINE DEDENT cnt = [ 0 ] * 10 NEW_LINE used = set ( ) NEW_LINE while len ( used ) < 10 : NEW_LINE INDENT for x in nn : NEW_LINE INDENT if x not in used : NEW_LINE INDENT good = ' $ ' NEW_LINE for t in x : NEW_LINE INDENT canT = True NEW_LINE for z in nn : NEW_LINE INDENT if z not in used and z != x and t in z : NEW_LINE INDENT canT = False NEW_LINE DEDENT DEDENT if canT : NEW_LINE INDENT good = t NEW_LINE break NEW_LINE DEDENT DEDENT if good != ' $ ' : NEW_LINE INDENT used . add ( x ) NEW_LINE for z in range ( len ( nn ) ) : NEW_LINE INDENT if nn [ z ] == x : NEW_LINE INDENT ind = z NEW_LINE break NEW_LINE DEDENT DEDENT if good in v : NEW_LINE INDENT cnt [ z ] = v [ good ] NEW_LINE for c in x : NEW_LINE INDENT if c in v : NEW_LINE INDENT v [ c ] -= cnt [ z ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( \" Case \u2581 # % d : \" % test , \" \" . join ( [ str ( x ) * cnt [ x ] for x in range ( 10 ) ] ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE cnt = { } NEW_LINE for c in ' QWERTYUIOPASDFGHJKLZXCVBNM ' : NEW_LINE INDENT cnt [ c ] = 0 NEW_LINE DEDENT for a in s : NEW_LINE INDENT cnt [ a ] += 1 NEW_LINE DEDENT a = [ ' ZERO ' , ' TWO ' , ' EIGHT ' , ' SIX ' , ' FOUR ' , ' FIVE ' , ' SEVEN ' , ' THREE ' , ' NINE ' , ' ONE ' ] NEW_LINE b = [ ' Z ' , ' W ' , ' G ' , ' X ' , ' U ' , ' F ' , ' V ' , ' R ' , ' I ' , ' O ' ] NEW_LINE d = [ '0' , '2' , '8' , '6' , '4' , '5' , '7' , '3' , '9' , '1' ] NEW_LINE res = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT x = cnt [ b [ i ] ] NEW_LINE for c in a [ i ] : NEW_LINE INDENT cnt [ c ] -= x NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT res . append ( d [ i ] ) NEW_LINE DEDENT DEDENT res . sort ( ) NEW_LINE ans = ' ' NEW_LINE for d in res : NEW_LINE INDENT ans += str ( d ) NEW_LINE DEDENT return ans NEW_LINE DEDENT nt = int ( input ( ) ) NEW_LINE for tt in range ( nt ) : NEW_LINE INDENT print ( ' Case \u2581 # ' + str ( tt + 1 ) + ' : \u2581 ' + str ( solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE cnt = { } NEW_LINE for c in ' QWERTYUIOPASDFGHJKLZXCVBNM ' : NEW_LINE INDENT cnt [ c ] = 0 NEW_LINE DEDENT for a in s : NEW_LINE INDENT cnt [ a ] += 1 NEW_LINE DEDENT a = [ ' ZERO ' , ' TWO ' , ' EIGHT ' , ' SIX ' , ' FOUR ' , ' FIVE ' , ' SEVEN ' , ' THREE ' , ' NINE ' , ' ONE ' ] NEW_LINE b = [ ' Z ' , ' W ' , ' G ' , ' X ' , ' U ' , ' F ' , ' V ' , ' R ' , ' I ' , ' O ' ] NEW_LINE d = [ '0' , '2' , '8' , '6' , '4' , '5' , '7' , '3' , '9' , '1' ] NEW_LINE res = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT x = cnt [ b [ i ] ] NEW_LINE for c in a [ i ] : NEW_LINE INDENT cnt [ c ] -= x NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT res . append ( d [ i ] ) NEW_LINE DEDENT DEDENT res . sort ( ) NEW_LINE ans = ' ' NEW_LINE for d in res : NEW_LINE INDENT ans += str ( d ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "import sys NEW_LINE import heapq NEW_LINE import bisect NEW_LINE import operator NEW_LINE from itertools import * NEW_LINE import numpy as np NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE DEDENT T = read ( ) NEW_LINE dic = [ \" ZERO \" , \" ONE \" , \" TWO \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SIX \" , \" SEVEN \" , \" EIGHT \" , \" NINE \" ] NEW_LINE chars = sorted ( set ( \" \" . join ( dic ) ) ) NEW_LINE R = len ( chars ) NEW_LINE M = np . array ( [ [ sum ( chars [ i ] == c for c in dic [ j ] ) for j in range ( 10 ) ] for i in range ( R ) ] ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT S = input ( ) NEW_LINE b = np . array ( [ sum ( chars [ i ] == c for c in S ) for i in range ( R ) ] ) NEW_LINE sol = [ int ( x + 0.5 ) for x in np . linalg . lstsq ( M , b ) [ 0 ] ] NEW_LINE result = \" \" . join ( str ( i ) * sol [ i ] for i in range ( 10 ) ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , result ) ) NEW_LINE DEDENT", "functions_standalone": [["read", "def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT"], ["reads", "def reads ( ) : NEW_LINE INDENT return [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_31", "java": [{"id": "4", "code": "import java . util . * ; public class A { static Scanner in ; public static void main ( String [ ] args ) { in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . println ( \" Case \u2581 # \" + C + \" : \" + solve ( ) ) ; } } public static String solve ( ) { String out = \" \" ; int n = in . nextInt ( ) ; int [ ] count = new int [ n ] ; int remaining = 0 ; for ( int i = 0 ; i < n ; i ++ ) { count [ i ] = in . nextInt ( ) ; remaining += count [ i ] ; } while ( remaining > 0 ) { out += \" \u2581 \" ; int maxIdx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ i ] > 0 && ( maxIdx == - 1 || count [ i ] > count [ maxIdx ] ) ) { maxIdx = i ; } } out += ( char ) ( maxIdx + ' A ' ) ; count [ maxIdx ] -- ; remaining -- ; if ( remaining <= 0 ) break ; maxIdx = - 1 ; int gT0 = 0 ; boolean tie = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ i ] > 0 ) { gT0 ++ ; } if ( count [ i ] > 0 && ( maxIdx == - 1 || count [ i ] > count [ maxIdx ] ) ) { maxIdx = i ; } else if ( count [ i ] > 0 && gT0 == 2 && count [ i ] == count [ maxIdx ] ) { tie = true ; } } boolean skip = tie && gT0 == 2 ; if ( ! skip ) { out += ( char ) ( maxIdx + ' A ' ) ; count [ maxIdx ] -- ; remaining -- ; } } return out ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . println ( \" Case \u2581 # \" + C + \" : \" + solve ( ) ) ; } }"], ["solve", "public static String solve ( ) { String out = \" \" ; int n = in . nextInt ( ) ; int [ ] count = new int [ n ] ; int remaining = 0 ; for ( int i = 0 ; i < n ; i ++ ) { count [ i ] = in . nextInt ( ) ; remaining += count [ i ] ; } while ( remaining > 0 ) { out += \" \u2581 \" ; int maxIdx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ i ] > 0 && ( maxIdx == - 1 || count [ i ] > count [ maxIdx ] ) ) { maxIdx = i ; } } out += ( char ) ( maxIdx + ' A ' ) ; count [ maxIdx ] -- ; remaining -- ; if ( remaining <= 0 ) break ; maxIdx = - 1 ; int gT0 = 0 ; boolean tie = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ i ] > 0 ) { gT0 ++ ; } if ( count [ i ] > 0 && ( maxIdx == - 1 || count [ i ] > count [ maxIdx ] ) ) { maxIdx = i ; } else if ( count [ i ] > 0 && gT0 == 2 && count [ i ] == count [ maxIdx ] ) { tie = true ; } } boolean skip = tie && gT0 == 2 ; if ( ! skip ) { out += ( char ) ( maxIdx + ' A ' ) ; count [ maxIdx ] -- ; remaining -- ; } } return out ; }"]], "functions_class": []}, {"id": "2", "code": "import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) ; } public Main ( ) throws IOException { Scanner sc = new Scanner ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A - large . out \" ) ) ; int amountOfTasks = sc . nextInt ( ) ; for ( int task = 1 ; task <= amountOfTasks ; task ++ ) { int amount = sc . nextInt ( ) ; int [ ] counts = new int [ amount ] ; int sum = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { counts [ i ] = sc . nextInt ( ) ; sum += counts [ i ] ; } String sol = \" \" ; if ( sum % 2 == 1 ) { int max1 = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { if ( counts [ i ] > counts [ max1 ] ) { max1 = i ; } } counts [ max1 ] -- ; char first = ( char ) ( max1 + ' A ' ) ; sol += first ; sum -- ; } while ( sum > 0 ) { int max1 = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { if ( counts [ i ] > counts [ max1 ] ) { max1 = i ; } } counts [ max1 ] -- ; int max2 = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { if ( counts [ i ] > counts [ max2 ] ) { max2 = i ; } } counts [ max2 ] -- ; char first = ( char ) ( max1 + ' A ' ) ; char second = ( char ) ( max2 + ' A ' ) ; if ( sol . length ( ) > 0 ) { sol += \" \u2581 \" ; } sol += first ; sol += second ; sum -= 2 ; } String solution = \" Case \u2581 # \" + task + \" : \u2581 \" + sol ; System . out . println ( solution ) ; out . println ( solution ) ; } out . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Main ( ) ; }"]], "functions_class": [["Main", "public Main ( ) throws IOException { Scanner sc = new Scanner ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A - large . out \" ) ) ; int amountOfTasks = sc . nextInt ( ) ; for ( int task = 1 ; task <= amountOfTasks ; task ++ ) { int amount = sc . nextInt ( ) ; int [ ] counts = new int [ amount ] ; int sum = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { counts [ i ] = sc . nextInt ( ) ; sum += counts [ i ] ; } String sol = \" \" ; if ( sum % 2 == 1 ) { int max1 = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { if ( counts [ i ] > counts [ max1 ] ) { max1 = i ; } } counts [ max1 ] -- ; char first = ( char ) ( max1 + ' A ' ) ; sol += first ; sum -- ; } while ( sum > 0 ) { int max1 = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { if ( counts [ i ] > counts [ max1 ] ) { max1 = i ; } } counts [ max1 ] -- ; int max2 = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { if ( counts [ i ] > counts [ max2 ] ) { max2 = i ; } } counts [ max2 ] -- ; char first = ( char ) ( max1 + ' A ' ) ; char second = ( char ) ( max2 + ' A ' ) ; if ( sol . length ( ) > 0 ) { sol += \" \u2581 \" ; } sol += first ; sol += second ; sum -= 2 ; } String solution = \" Case \u2581 # \" + task + \" : \u2581 \" + sol ; System . out . println ( solution ) ; out . println ( solution ) ; } out . close ( ) ; sc . close ( ) ; }"]]}, {"id": "10", "code": "package com . mavtushenko . Gcj1C ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class TaskA { public static void main ( String [ ] args ) { String fileName = \" A - large . in \" ; try ( BufferedReader br = new BufferedReader ( new FileReader ( fileName ) ) ) { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( fileName + \" . out \" ) ) ) { int tests = Integer . valueOf ( br . readLine ( ) ) ; for ( int test = 1 ; test <= tests ; ++ test ) { int n = new Scanner ( br . readLine ( ) ) . nextInt ( ) ; Scanner scanner = new Scanner ( br . readLine ( ) ) ; int s [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) s [ i ] = scanner . nextInt ( ) ; bw . write ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; while ( true ) { int max = 0 ; for ( int ss : s ) max = Math . max ( max , ss ) ; if ( max == 0 ) break ; ArrayList < Integer > pos = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == max ) pos . add ( i ) ; } int ps = pos . size ( ) ; if ( pos . size ( ) % 2 == 1 ) { ps -- ; int cur = pos . get ( pos . size ( ) - 1 ) ; s [ cur ] -- ; bw . write ( \" \" + ( char ) ( ' A ' + cur ) + \" \u2581 \" ) ; } for ( int i = 0 ; i < ps ; i += 2 ) { int c1 = pos . get ( i ) ; int c2 = pos . get ( i + 1 ) ; s [ c1 ] -- ; s [ c2 ] -- ; bw . write ( \" \" + ( char ) ( ' A ' + c1 ) + ( char ) ( ' A ' + c2 ) + \" \u2581 \" ) ; } } bw . write ( \" \\n \" ) ; } bw . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { String fileName = \" A - large . in \" ; try ( BufferedReader br = new BufferedReader ( new FileReader ( fileName ) ) ) { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( fileName + \" . out \" ) ) ) { int tests = Integer . valueOf ( br . readLine ( ) ) ; for ( int test = 1 ; test <= tests ; ++ test ) { int n = new Scanner ( br . readLine ( ) ) . nextInt ( ) ; Scanner scanner = new Scanner ( br . readLine ( ) ) ; int s [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) s [ i ] = scanner . nextInt ( ) ; bw . write ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; while ( true ) { int max = 0 ; for ( int ss : s ) max = Math . max ( max , ss ) ; if ( max == 0 ) break ; ArrayList < Integer > pos = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == max ) pos . add ( i ) ; } int ps = pos . size ( ) ; if ( pos . size ( ) % 2 == 1 ) { ps -- ; int cur = pos . get ( pos . size ( ) - 1 ) ; s [ cur ] -- ; bw . write ( \" \" + ( char ) ( ' A ' + cur ) + \" \u2581 \" ) ; } for ( int i = 0 ; i < ps ; i += 2 ) { int c1 = pos . get ( i ) ; int c2 = pos . get ( i + 1 ) ; s [ c1 ] -- ; s [ c2 ] -- ; bw . write ( \" \" + ( char ) ( ' A ' + c1 ) + ( char ) ( ' A ' + c2 ) + \" \u2581 \" ) ; } } bw . write ( \" \\n \" ) ; } bw . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "7", "code": "package Round1 ; import java . io . * ; public class A { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" / Users / chao / Downloads / A - large . in \" ) ) ; FileWriter out = new FileWriter ( \" / Users / chao / Desktop / A - large . txt \" ) ; String s = in . readLine ( ) ; int m = Integer . parseInt ( s ) ; int [ ] a = new int [ 26 ] ; for ( int cases = 1 ; cases <= m ; cases ++ ) { int n = Integer . parseInt ( in . readLine ( ) ) ; int cnt = n ; String [ ] ss = in . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < ss . length ; i ++ ) { a [ i ] = Integer . parseInt ( ss [ i ] ) ; } out . write ( \" Case \u2581 # \" + cases + \" : \" ) ; while ( cnt > 2 ) { int k = findMaxIndex ( a , n ) ; out . write ( \" \u2581 \" + ( char ) ( ' A ' + k ) ) ; if ( -- a [ k ] == 0 ) cnt -- ; } while ( cnt > 0 ) { int k = findMaxIndex ( a , n ) ; out . write ( \" \u2581 \" + ( char ) ( ' A ' + k ) ) ; if ( -- a [ k ] == 0 ) cnt -- ; k = findMaxIndex ( a , n ) ; out . write ( ( char ) ( ' A ' + k ) ) ; if ( -- a [ k ] == 0 ) cnt -- ; } out . write ( \" \\n \" ) ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; } private static int findMaxIndex ( int [ ] a , int n ) { int num = - 1 ; int k = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > num ) { num = a [ i ] ; k = i ; } } return k ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" / Users / chao / Downloads / A - large . in \" ) ) ; FileWriter out = new FileWriter ( \" / Users / chao / Desktop / A - large . txt \" ) ; String s = in . readLine ( ) ; int m = Integer . parseInt ( s ) ; int [ ] a = new int [ 26 ] ; for ( int cases = 1 ; cases <= m ; cases ++ ) { int n = Integer . parseInt ( in . readLine ( ) ) ; int cnt = n ; String [ ] ss = in . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < ss . length ; i ++ ) { a [ i ] = Integer . parseInt ( ss [ i ] ) ; } out . write ( \" Case \u2581 # \" + cases + \" : \" ) ; while ( cnt > 2 ) { int k = findMaxIndex ( a , n ) ; out . write ( \" \u2581 \" + ( char ) ( ' A ' + k ) ) ; if ( -- a [ k ] == 0 ) cnt -- ; } while ( cnt > 0 ) { int k = findMaxIndex ( a , n ) ; out . write ( \" \u2581 \" + ( char ) ( ' A ' + k ) ) ; if ( -- a [ k ] == 0 ) cnt -- ; k = findMaxIndex ( a , n ) ; out . write ( ( char ) ( ' A ' + k ) ) ; if ( -- a [ k ] == 0 ) cnt -- ; } out . write ( \" \\n \" ) ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }"], ["findMaxIndex", "private static int findMaxIndex ( int [ ] a , int n ) { int num = - 1 ; int k = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > num ) { num = a [ i ] ; k = i ; } } return k ; }"]], "functions_class": []}, {"id": "0", "code": "import java . util . * ; import java . io . * ; public class A { static int N ; static int ans ; public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { N = input . nextInt ( ) ; int [ ] nums = new int [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { nums [ i ] = input . nextInt ( ) ; sum += nums [ i ] ; } List < String > steps = new ArrayList < String > ( ) ; while ( sum > 0 ) { String s = \" \" ; s += add ( nums , false ) ; s += add ( nums , true ) ; steps . add ( s ) ; sum -= s . length ( ) ; } System . out . printf ( \" Case \u2581 # % d : \" , n + 1 ) ; for ( String s : steps ) System . out . print ( \" \u2581 \" + s ) ; System . out . println ( ) ; } } static String add ( int [ ] nums , boolean check ) { int most = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) if ( nums [ i ] > nums [ most ] ) most = i ; nums [ most ] -- ; int sum = 0 ; for ( int num : nums ) sum += num ; if ( check ) for ( int num : nums ) if ( num > sum / 2 ) { nums [ most ] ++ ; return \" \" ; } return ( char ) ( ' A ' + most ) + \" \" ; } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { N = input . nextInt ( ) ; int [ ] nums = new int [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { nums [ i ] = input . nextInt ( ) ; sum += nums [ i ] ; } List < String > steps = new ArrayList < String > ( ) ; while ( sum > 0 ) { String s = \" \" ; s += add ( nums , false ) ; s += add ( nums , true ) ; steps . add ( s ) ; sum -= s . length ( ) ; } System . out . printf ( \" Case \u2581 # % d : \" , n + 1 ) ; for ( String s : steps ) System . out . print ( \" \u2581 \" + s ) ; System . out . println ( ) ; } }"], ["add", "static String add ( int [ ] nums , boolean check ) { int most = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) if ( nums [ i ] > nums [ most ] ) most = i ; nums [ most ] -- ; int sum = 0 ; for ( int num : nums ) sum += num ; if ( check ) for ( int num : nums ) if ( num > sum / 2 ) { nums [ most ] ++ ; return \" \" ; } return ( char ) ( ' A ' + most ) + \" \" ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "from __future__ import print_function NEW_LINE import numpy NEW_LINE import string NEW_LINE T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \" % i , end = ' ' ) NEW_LINE n = int ( raw_input ( ) ) NEW_LINE p = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE while True : NEW_LINE INDENT pp = [ x for x in range ( len ( p ) ) if p [ x ] != 0 ] NEW_LINE if len ( pp ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT elif len ( pp ) == 2 and p [ pp [ 0 ] ] == p [ pp [ 1 ] ] : NEW_LINE INDENT print ( ' \u2581 ' , end = ' ' ) NEW_LINE print ( string . uppercase [ pp [ 0 ] ] , end = ' ' ) NEW_LINE print ( string . uppercase [ pp [ 1 ] ] , end = ' ' ) NEW_LINE p [ pp [ 0 ] ] -= 1 NEW_LINE p [ pp [ 1 ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT q = numpy . argmax ( p ) NEW_LINE print ( ' \u2581 ' , end = ' ' ) NEW_LINE print ( string . uppercase [ q ] , end = ' ' ) NEW_LINE p [ q ] -= 1 NEW_LINE DEDENT DEDENT print ( ' ' ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "10", "code": "def executer_calcul ( entrees ) : NEW_LINE INDENT N = entrees [ 0 ] NEW_LINE parties = entrees [ 1 ] NEW_LINE Case = entrees [ 2 ] NEW_LINE result = ' ' NEW_LINE while ( sum ( parties ) > 0 ) : NEW_LINE INDENT evac1 = maximum ( parties ) NEW_LINE parties [ evac1 ] = parties [ evac1 ] - 1 NEW_LINE evac2 = maximum ( parties ) NEW_LINE if ( 2 * parties [ evac2 ] > sum ( parties ) ) : NEW_LINE INDENT parties [ evac2 ] = parties [ evac2 ] - 1 NEW_LINE result = result + ' \u2581 ' + chr ( evac1 + 65 ) + chr ( evac2 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ' \u2581 ' + chr ( evac1 + 65 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def maximum ( liste ) : NEW_LINE INDENT maximum = 0 NEW_LINE for i in range ( len ( liste ) ) : NEW_LINE INDENT if ( liste [ i ] > liste [ maximum ] ) : maximum = i NEW_LINE DEDENT return maximum NEW_LINE DEDENT multiprocessed = False NEW_LINE if ( multiprocessed ) : from multiprocessing import Pool NEW_LINE else : output = open ( ' Output . txt ' , ' w ' ) NEW_LINE if ( ( not multiprocessed ) or __name__ == ' _ _ main _ _ ' ) : NEW_LINE INDENT with open ( \" Input . txt \" , \" r \" ) as input : NEW_LINE INDENT lines = input . readlines ( ) NEW_LINE DEDENT T = int ( lines [ 0 ] ) NEW_LINE line = 1 NEW_LINE Case = 1 NEW_LINE calculs = [ ] NEW_LINE while ( line < len ( lines ) ) : NEW_LINE INDENT N = int ( lines [ line ] ) NEW_LINE line = line + 1 NEW_LINE parties = list ( map ( int , lines [ line ] . split ( ' \u2581 ' ) ) ) NEW_LINE line = line + 1 NEW_LINE entrees = [ N , parties , Case ] NEW_LINE if ( not multiprocessed ) : output . write ( ' Case \u2581 # ' + str ( Case ) + ' : ' + executer_calcul ( entrees ) + ' \\n ' ) NEW_LINE else : calculs . append ( entrees ) NEW_LINE Case = Case + 1 NEW_LINE DEDENT if ( multiprocessed ) : NEW_LINE INDENT pool = Pool ( 3 ) NEW_LINE results = pool . map ( executer_calcul , calculs ) NEW_LINE output = open ( ' Output . txt ' , ' w ' ) NEW_LINE for case in range ( len ( results ) ) : NEW_LINE INDENT output . write ( ' Case \u2581 # ' + str ( case + 1 ) + ' : \u2581 ' + results [ case ] + ' \\n ' ) NEW_LINE DEDENT DEDENT output . close ( ) NEW_LINE DEDENT", "functions_standalone": [["executer_calcul", "def executer_calcul ( entrees ) : NEW_LINE INDENT N = entrees [ 0 ] NEW_LINE parties = entrees [ 1 ] NEW_LINE Case = entrees [ 2 ] NEW_LINE result = ' ' NEW_LINE while ( sum ( parties ) > 0 ) : NEW_LINE INDENT evac1 = maximum ( parties ) NEW_LINE parties [ evac1 ] = parties [ evac1 ] - 1 NEW_LINE evac2 = maximum ( parties ) NEW_LINE if ( 2 * parties [ evac2 ] > sum ( parties ) ) : NEW_LINE INDENT parties [ evac2 ] = parties [ evac2 ] - 1 NEW_LINE result = result + ' \u2581 ' + chr ( evac1 + 65 ) + chr ( evac2 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ' \u2581 ' + chr ( evac1 + 65 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT"], ["maximum", "def maximum ( liste ) : NEW_LINE INDENT maximum = 0 NEW_LINE for i in range ( len ( liste ) ) : NEW_LINE INDENT if ( liste [ i ] > liste [ maximum ] ) : maximum = i NEW_LINE DEDENT return maximum NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "import sys NEW_LINE def letter ( x ) : NEW_LINE INDENT return chr ( ord ( ' A ' ) + x ) NEW_LINE DEDENT def solve_test ( inp ) : NEW_LINE INDENT n = int ( inp . readline ( ) ) NEW_LINE ans = [ ] NEW_LINE counts = [ int ( x ) for x in inp . readline ( ) . split ( ) ] NEW_LINE total = sum ( counts ) NEW_LINE if total % 2 == 1 : NEW_LINE INDENT winner = counts . index ( max ( counts ) ) NEW_LINE ans . append ( letter ( winner ) ) NEW_LINE counts [ winner ] -= 1 NEW_LINE DEDENT while sum ( counts ) > 0 : NEW_LINE INDENT winner1 = counts . index ( max ( counts ) ) NEW_LINE counts [ winner1 ] -= 1 NEW_LINE winner2 = counts . index ( max ( counts ) ) NEW_LINE counts [ winner2 ] -= 1 NEW_LINE ans . append ( letter ( winner1 ) + letter ( winner2 ) ) NEW_LINE DEDENT return ' \u2581 ' . join ( ans ) NEW_LINE DEDENT def solve_dumb ( inp ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT inp = open ( sys . argv [ 1 ] ) NEW_LINE inp_dumb = open ( sys . argv [ 1 ] ) NEW_LINE out = open ( sys . argv [ 1 ] . rsplit ( ' . ' , 1 ) [ 0 ] + ' . out ' , ' w ' ) NEW_LINE out_dumb = open ( sys . argv [ 1 ] . rsplit ( ' . ' , 1 ) [ 0 ] + ' . dumb . out ' , ' w ' ) NEW_LINE n_tests = int ( inp . readline ( ) ) NEW_LINE for i in range ( n_tests ) : NEW_LINE INDENT ans = solve_test ( inp ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) + ans , file = out ) NEW_LINE ans_dumb = solve_dumb ( inp_dumb ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) + ans_dumb , file = out_dumb ) NEW_LINE if ans != ans_dumb : NEW_LINE INDENT print ( ' Wrong ' , i + 1 , file = sys . stderr ) NEW_LINE DEDENT DEDENT out . close ( ) NEW_LINE", "functions_standalone": [["letter", "def letter ( x ) : NEW_LINE INDENT return chr ( ord ( ' A ' ) + x ) NEW_LINE DEDENT"], ["solve_test", "def solve_test ( inp ) : NEW_LINE INDENT n = int ( inp . readline ( ) ) NEW_LINE ans = [ ] NEW_LINE counts = [ int ( x ) for x in inp . readline ( ) . split ( ) ] NEW_LINE total = sum ( counts ) NEW_LINE if total % 2 == 1 : NEW_LINE INDENT winner = counts . index ( max ( counts ) ) NEW_LINE ans . append ( letter ( winner ) ) NEW_LINE counts [ winner ] -= 1 NEW_LINE DEDENT while sum ( counts ) > 0 : NEW_LINE INDENT winner1 = counts . index ( max ( counts ) ) NEW_LINE counts [ winner1 ] -= 1 NEW_LINE winner2 = counts . index ( max ( counts ) ) NEW_LINE counts [ winner2 ] -= 1 NEW_LINE ans . append ( letter ( winner1 ) + letter ( winner2 ) ) NEW_LINE DEDENT return ' \u2581 ' . join ( ans ) NEW_LINE DEDENT"], ["solve_dumb", "def solve_dumb ( inp ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT"]], "functions_class": []}, {"id": "7", "code": "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE line = input ( ) NEW_LINE t = line . split ( ) NEW_LINE a = [ [ chr ( ord ( ' A ' ) + i ) , int ( t [ i ] ) ] for i in range ( len ( t ) ) ] NEW_LINE tot = sum ( [ x [ 1 ] for x in a ] ) NEW_LINE res = [ ] NEW_LINE while tot > 0 : NEW_LINE INDENT a . sort ( reverse = True , key = lambda x : x [ 1 ] ) NEW_LINE if 2 * a [ 1 ] [ 1 ] <= tot - 1 : NEW_LINE INDENT a [ 0 ] [ 1 ] -= 1 NEW_LINE tot -= 1 NEW_LINE res . append ( a [ 0 ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] [ 1 ] -= 1 NEW_LINE a [ 1 ] [ 1 ] -= 1 NEW_LINE tot -= 2 NEW_LINE res . append ( a [ 0 ] [ 0 ] + a [ 1 ] [ 0 ] ) NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , ' \u2581 ' . join ( res ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "3", "code": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \" , end = \" \u2581 \" ) NEW_LINE n = int ( input ( ) ) NEW_LINE members = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE while max ( members ) > 0 : NEW_LINE INDENT r = max ( members ) NEW_LINE l = [ i for i in range ( len ( members ) ) if members [ i ] == r ] NEW_LINE if len ( l ) == 2 : NEW_LINE INDENT out = l NEW_LINE DEDENT else : NEW_LINE INDENT out = [ l [ 0 ] ] NEW_LINE DEDENT print ( \" \" . join ( chr ( i + ord ( ' A ' ) ) for i in out ) , end = \" \u2581 \" ) NEW_LINE for i in out : NEW_LINE INDENT members [ i ] -= 1 NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_16_54", "java": [{"id": "9", "code": "import java . util . Arrays ; import java . util . Scanner ; public class D { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solve ( ) ) ; } } static String solve ( ) { int N = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; String [ ] G = new String [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { G [ i ] = sc . next ( ) ; } String B = sc . next ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( G [ i ] . equals ( B ) ) { return \" IMPOSSIBLE \" ; } } if ( L == 1 ) { return \" ? \u2581 0\" ; } char [ ] p1 = new char [ L - 1 ] ; Arrays . fill ( p1 , ' ? ' ) ; StringBuilder p2 = new StringBuilder ( ) ; for ( int i = 0 ; i < 49 ; ++ i ) { p2 . append ( ( char ) ( '0' + i % 2 ) ) ; } p2 . append ( ' ? ' ) ; for ( int i = 0 ; i < 49 ; ++ i ) { p2 . append ( ( char ) ( '0' + ( i + 1 ) % 2 ) ) ; } return String . valueOf ( p1 ) + \" \u2581 \" + p2 . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solve ( ) ) ; } }"], ["solve", "static String solve ( ) { int N = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; String [ ] G = new String [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { G [ i ] = sc . next ( ) ; } String B = sc . next ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( G [ i ] . equals ( B ) ) { return \" IMPOSSIBLE \" ; } } if ( L == 1 ) { return \" ? \u2581 0\" ; } char [ ] p1 = new char [ L - 1 ] ; Arrays . fill ( p1 , ' ? ' ) ; StringBuilder p2 = new StringBuilder ( ) ; for ( int i = 0 ; i < 49 ; ++ i ) { p2 . append ( ( char ) ( '0' + i % 2 ) ) ; } p2 . append ( ' ? ' ) ; for ( int i = 0 ; i < 49 ; ++ i ) { p2 . append ( ( char ) ( '0' + ( i + 1 ) % 2 ) ) ; } return String . valueOf ( p1 ) + \" \u2581 \" + p2 . toString ( ) ; }"]], "functions_class": []}, {"id": "19", "code": "import java . util . * ; import java . io . * ; import static lib . Util . * ; public class D { static int ans ; public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; int L = input . nextInt ( ) ; String [ ] Gs = new String [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Gs [ i ] = input . next ( ) ; String B = input . next ( ) ; boolean bad = false ; for ( String G : Gs ) if ( G . equals ( B ) ) bad = true ; if ( bad ) { System . out . printf ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE \\n \" , n + 1 ) ; continue ; } if ( L == 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 0 \u2581 ? \\n \" , n + 1 ) ; continue ; } StringBuilder p1 = new StringBuilder ( ) ; StringBuilder p2 = new StringBuilder ( ) ; for ( int i = 0 ; i < L ; i ++ ) { if ( i == L - 1 ) { if ( i % 2 == 0 ) p2 . append ( \" ? 1\" ) ; else p1 . append ( \" ? 1\" ) ; } else if ( i % 2 == 0 ) { p1 . append ( \"10\" ) ; p2 . append ( \" ? \" ) ; } else { p1 . append ( \" ? \" ) ; p2 . append ( \"10\" ) ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % s \u2581 % s \\n \" , n + 1 , p1 , p2 ) ; } } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; int L = input . nextInt ( ) ; String [ ] Gs = new String [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Gs [ i ] = input . next ( ) ; String B = input . next ( ) ; boolean bad = false ; for ( String G : Gs ) if ( G . equals ( B ) ) bad = true ; if ( bad ) { System . out . printf ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE \\n \" , n + 1 ) ; continue ; } if ( L == 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 0 \u2581 ? \\n \" , n + 1 ) ; continue ; } StringBuilder p1 = new StringBuilder ( ) ; StringBuilder p2 = new StringBuilder ( ) ; for ( int i = 0 ; i < L ; i ++ ) { if ( i == L - 1 ) { if ( i % 2 == 0 ) p2 . append ( \" ? 1\" ) ; else p1 . append ( \" ? 1\" ) ; } else if ( i % 2 == 0 ) { p1 . append ( \"10\" ) ; p2 . append ( \" ? \" ) ; } else { p1 . append ( \" ? \" ) ; p2 . append ( \"10\" ) ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % s \u2581 % s \\n \" , n + 1 , p1 , p2 ) ; } }"]], "functions_class": []}, {"id": "14", "code": "import java . io . * ; import java . util . * ; public class D { String solveOne ( Scanner in ) { int size = in . nextInt ( ) ; int len = in . nextInt ( ) ; String g [ ] = new String [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { g [ i ] = in . next ( ) ; } String bad = in . next ( ) ; if ( bad . contains ( \"0\" ) ) { throw new Error ( ) ; } for ( String s : g ) { if ( ! s . contains ( \"0\" ) ) { return \" IMPOSSIBLE \" ; } } String ans = \"0\" ; for ( int i = 1 ; i < len ; i ++ ) { ans += \"1\" ; } ans += \" \u2581 \" ; for ( int i = 0 ; i < len ; i ++ ) { ans += \"0 ? \" ; } return ans ; } void solve ( Scanner in , PrintWriter out ) { int nTests = in . nextInt ( ) ; for ( int iTest = 1 ; iTest <= nTests ; iTest ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , iTest , solveOne ( in ) ) ; } } void run ( ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; ) { solve ( in , out ) ; } } public static void main ( String args [ ] ) { new D ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { new D ( ) . run ( ) ; }"]], "functions_class": [["solveOne", "String solveOne ( Scanner in ) { int size = in . nextInt ( ) ; int len = in . nextInt ( ) ; String g [ ] = new String [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { g [ i ] = in . next ( ) ; } String bad = in . next ( ) ; if ( bad . contains ( \"0\" ) ) { throw new Error ( ) ; } for ( String s : g ) { if ( ! s . contains ( \"0\" ) ) { return \" IMPOSSIBLE \" ; } } String ans = \"0\" ; for ( int i = 1 ; i < len ; i ++ ) { ans += \"1\" ; } ans += \" \u2581 \" ; for ( int i = 0 ; i < len ; i ++ ) { ans += \"0 ? \" ; } return ans ; }"], ["solve", "void solve ( Scanner in , PrintWriter out ) { int nTests = in . nextInt ( ) ; for ( int iTest = 1 ; iTest <= nTests ; iTest ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , iTest , solveOne ( in ) ) ; } }"], ["run", "void run ( ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; ) { solve ( in , out ) ; } }"]]}, {"id": "18", "code": "import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . PrintWriter ; import java . io . StreamTokenizer ; import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; public class Go implements Runnable { private static final String NAME = \" go \" ; private StreamTokenizer in ; int nextInt ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; } long nextLong ( ) throws Exception { in . nextToken ( ) ; return ( long ) in . nval ; } @ Override public void run ( ) { try { Scanner in = new Scanner ( new File ( NAME + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( NAME + \" . out \" ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int n = in . nextInt ( ) ; int l = in . nextInt ( ) ; Set < String > s = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( in . next ( ) ) ; } String b = in . next ( ) ; if ( b . contains ( \"0\" ) ) { throw new IllegalStateException ( ) ; } if ( s . contains ( b ) ) { out . println ( \" Case \u2581 # \" + test + \" : \u2581 IMPOSSIBLE \" ) ; } else { String r1 = \" \" ; String r2 = \" \" ; for ( int i = 0 ; i < l ; i ++ ) { r1 += \"0 ? \" ; } r2 += \"0\" ; for ( int i = 0 ; i < l - 1 ; i ++ ) { r2 += \"01\" ; } r2 += \"0\" ; out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r1 + \" \u2581 \" + r2 ) ; } } out . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static void main ( String [ ] args ) { new Thread ( new Go ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Thread ( new Go ( ) ) . start ( ) ; }"]], "functions_class": [["nextInt", "int nextInt ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; }"], ["nextLong", "long nextLong ( ) throws Exception { in . nextToken ( ) ; return ( long ) in . nval ; }"], ["run", "public void run ( ) { try { Scanner in = new Scanner ( new File ( NAME + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( NAME + \" . out \" ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int n = in . nextInt ( ) ; int l = in . nextInt ( ) ; Set < String > s = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( in . next ( ) ) ; } String b = in . next ( ) ; if ( b . contains ( \"0\" ) ) { throw new IllegalStateException ( ) ; } if ( s . contains ( b ) ) { out . println ( \" Case \u2581 # \" + test + \" : \u2581 IMPOSSIBLE \" ) ; } else { String r1 = \" \" ; String r2 = \" \" ; for ( int i = 0 ; i < l ; i ++ ) { r1 += \"0 ? \" ; } r2 += \"0\" ; for ( int i = 0 ; i < l - 1 ; i ++ ) { r2 += \"01\" ; } r2 += \"0\" ; out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r1 + \" \u2581 \" + r2 ) ; } } out . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }"]]}, {"id": "16", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintStream ; import java . util . Arrays ; import java . util . Scanner ; public class GoPlusPlus { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner cin = new Scanner ( new File ( \" D - small - attempt0 . in \" ) ) ; PrintStream cout = new PrintStream ( \" D - small - attempt0 . out \" ) ; int _case = 0 ; for ( int T = cin . nextInt ( ) ; T > 0 ; T -- ) { _case ++ ; StringBuilder ans = new StringBuilder ( ) ; int N = cin . nextInt ( ) ; int L = cin . nextInt ( ) ; String [ ] a = new String [ N ] ; boolean impossible = false ; for ( int i = 0 ; i < N ; i ++ ) a [ i ] = cin . next ( ) ; String shit = cin . next ( ) ; for ( String each : a ) if ( each . equals ( shit ) ) impossible = true ; if ( impossible ) ans . append ( \" IMPOSSIBLE \" ) ; else { String one = \"0\" ; for ( int i = 0 ; i < L - 1 ; i ++ ) one += \"1\" ; String two = \" \" ; for ( int i = 0 ; i < L ; i ++ ) two += \"0 ? \" ; ans . append ( one ) ; ans . append ( \" \u2581 \" ) ; ans . append ( two ) ; } cout . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , _case , ans . toString ( ) ) ; } cin . close ( ) ; cout . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner cin = new Scanner ( new File ( \" D - small - attempt0 . in \" ) ) ; PrintStream cout = new PrintStream ( \" D - small - attempt0 . out \" ) ; int _case = 0 ; for ( int T = cin . nextInt ( ) ; T > 0 ; T -- ) { _case ++ ; StringBuilder ans = new StringBuilder ( ) ; int N = cin . nextInt ( ) ; int L = cin . nextInt ( ) ; String [ ] a = new String [ N ] ; boolean impossible = false ; for ( int i = 0 ; i < N ; i ++ ) a [ i ] = cin . next ( ) ; String shit = cin . next ( ) ; for ( String each : a ) if ( each . equals ( shit ) ) impossible = true ; if ( impossible ) ans . append ( \" IMPOSSIBLE \" ) ; else { String one = \"0\" ; for ( int i = 0 ; i < L - 1 ; i ++ ) one += \"1\" ; String two = \" \" ; for ( int i = 0 ; i < L ; i ++ ) two += \"0 ? \" ; ans . append ( one ) ; ans . append ( \" \u2581 \" ) ; ans . append ( two ) ; } cout . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , _case , ans . toString ( ) ) ; } cin . close ( ) ; cout . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "def run ( ) : NEW_LINE INDENT n , l = tuple ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE G = input ( ) . split ( ) NEW_LINE B = input ( ) . strip ( ) NEW_LINE if B in G : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT p1 = \" ? \" NEW_LINE p2 = \"0\" NEW_LINE DEDENT else : NEW_LINE INDENT p1 = \" ? \" * ( l - 1 ) NEW_LINE p2 = \"10 ? \" + \"10\" * l NEW_LINE DEDENT return \" % s \u2581 % s \" % ( p1 , p2 ) NEW_LINE DEDENT tc = int ( input ( ) ) NEW_LINE for i in range ( tc ) : NEW_LINE INDENT res = run ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , res ) ) NEW_LINE DEDENT", "functions_standalone": [["run", "def run ( ) : NEW_LINE INDENT n , l = tuple ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE G = input ( ) . split ( ) NEW_LINE B = input ( ) . strip ( ) NEW_LINE if B in G : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT p1 = \" ? \" NEW_LINE p2 = \"0\" NEW_LINE DEDENT else : NEW_LINE INDENT p1 = \" ? \" * ( l - 1 ) NEW_LINE p2 = \"10 ? \" + \"10\" * l NEW_LINE DEDENT return \" % s \u2581 % s \" % ( p1 , p2 ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "3", "code": "def initialize_solver ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT def solve_testcase ( ) : NEW_LINE INDENT n , l = read ( ) NEW_LINE g = read ( rettype = str ) NEW_LINE b = read ( False , str ) NEW_LINE if b in g : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT return [ \" ? 0\" * l , \"1\" * ( l - 1 ) + \"0\" ] NEW_LINE DEDENT output_format = \" Case \u2581 # % d : \u2581 \" NEW_LINE filename = input ( ) . strip ( ) NEW_LINE sfile = None NEW_LINE tfile = None NEW_LINE if filename != \" \" : NEW_LINE INDENT sfile = open ( filename + \" . in \" , \" r \" ) NEW_LINE sfile . seek ( 0 ) NEW_LINE tfile = open ( filename + \" . out \" , \" w \" ) NEW_LINE DEDENT def read ( split = True , rettype = int ) : NEW_LINE INDENT if sfile : NEW_LINE INDENT input_line = sfile . readline ( ) . strip ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input_line = input ( ) . strip ( ) NEW_LINE DEDENT if split : NEW_LINE INDENT return list ( map ( rettype , input_line . split ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return rettype ( input_line ) NEW_LINE DEDENT DEDENT def write ( s = \" \\n \" ) : NEW_LINE INDENT if s is None : s = \" \" NEW_LINE if isinstance ( s , list ) : s = \" \u2581 \" . join ( map ( str , s ) ) NEW_LINE s = str ( s ) NEW_LINE if tfile : NEW_LINE INDENT tfile . write ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s , end = \" \" ) NEW_LINE DEDENT DEDENT if output_format == 0 : NEW_LINE INDENT solve_testcase ( ) NEW_LINE DEDENT else : NEW_LINE INDENT initialize_solver ( ) NEW_LINE total_cases = read ( split = False ) NEW_LINE for case_number in range ( 1 , total_cases + 1 ) : NEW_LINE INDENT write ( output_format . replace ( \" % d \" , str ( case_number ) ) ) NEW_LINE write ( solve_testcase ( ) ) NEW_LINE write ( \" \\n \" ) NEW_LINE DEDENT DEDENT if tfile is not None : tfile . close ( ) NEW_LINE", "functions_standalone": [["initialize_solver", "def initialize_solver ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT"], ["solve_testcase", "def solve_testcase ( ) : NEW_LINE INDENT n , l = read ( ) NEW_LINE g = read ( rettype = str ) NEW_LINE b = read ( False , str ) NEW_LINE if b in g : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT return [ \" ? 0\" * l , \"1\" * ( l - 1 ) + \"0\" ] NEW_LINE DEDENT"], ["read", "def read ( split = True , rettype = int ) : NEW_LINE INDENT if sfile : NEW_LINE INDENT input_line = sfile . readline ( ) . strip ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input_line = input ( ) . strip ( ) NEW_LINE DEDENT if split : NEW_LINE INDENT return list ( map ( rettype , input_line . split ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return rettype ( input_line ) NEW_LINE DEDENT DEDENT"], ["write", "def write ( s = \" \\n \" ) : NEW_LINE INDENT if s is None : s = \" \" NEW_LINE if isinstance ( s , list ) : s = \" \u2581 \" . join ( map ( str , s ) ) NEW_LINE s = str ( s ) NEW_LINE if tfile : NEW_LINE INDENT tfile . write ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s , end = \" \" ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "4", "code": "T = int ( input ( ) ) NEW_LINE for tc in range ( 1 , T + 1 ) : NEW_LINE INDENT N , L = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE G = list ( input ( ) . split ( ) ) NEW_LINE B = input ( ) . strip ( ) NEW_LINE if B in G : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 IMPOSSIBLE ' . format ( tc ) ) NEW_LINE continue NEW_LINE DEDENT if L == 1 : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } \u2581 { } ' . format ( tc , '0' , ' ? ' ) ) NEW_LINE continue NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } \u2581 { } ' . format ( tc , '10' * 27 + ' ? ' + '10' * 27 , ' ? ' * ( L - 1 ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "5", "code": "import io , sys NEW_LINE import datetime NEW_LINE import random NEW_LINE fin = None NEW_LINE def solve ( ) : NEW_LINE INDENT n , l = nums ( ) NEW_LINE good = strs ( ) NEW_LINE bad = sstrip ( ) NEW_LINE if '1' * l in good : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT return '0 \u2581 ? ' NEW_LINE DEDENT return '0 % s ? % s \u2581 % s ' % ( '10' * l , '1' * ( l - 1 ) , ' ? ' * ( l - 1 ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT fname = ' test . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . out ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT n , l = nums ( ) NEW_LINE good = strs ( ) NEW_LINE bad = sstrip ( ) NEW_LINE if '1' * l in good : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT return '0 \u2581 ? ' NEW_LINE DEDENT return '0 % s ? % s \u2581 % s ' % ( '10' * l , '1' * ( l - 1 ) , ' ? ' * ( l - 1 ) ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT fname = ' test . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . out ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT"], ["nums", "def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["fnums", "def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["num", "def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT"], ["sstrip", "def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT"], ["strs", "def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT"], ["arrstr", "def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "import sys NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT def invert ( char ) : NEW_LINE INDENT if char == '1' : NEW_LINE INDENT return '0' NEW_LINE DEDENT elif char == '0' : NEW_LINE INDENT return '1' NEW_LINE DEDENT else : NEW_LINE INDENT raise Exception ( char ) NEW_LINE DEDENT DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , L = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE G = fin . readline ( ) . split ( ) NEW_LINE B = fin . readline ( ) . strip ( ) NEW_LINE if B in G : NEW_LINE INDENT result = ' IMPOSSIBLE ' NEW_LINE DEDENT elif L == 1 : NEW_LINE INDENT if B == '0' : NEW_LINE INDENT result = '1 \u2581 1 ? ' NEW_LINE DEDENT else : NEW_LINE INDENT result = '0 \u2581 0 ? ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = ' ' NEW_LINE b = ' ' NEW_LINE for c in B : NEW_LINE INDENT b += invert ( c ) + ' ? ' NEW_LINE if c == '1' : NEW_LINE INDENT a += '01' NEW_LINE DEDENT else : NEW_LINE INDENT a += '10' NEW_LINE DEDENT DEDENT a = a [ : - 2 ] NEW_LINE if len ( a ) + len ( b ) > 4 * L : NEW_LINE INDENT raise Exception ( \" Too \u2581 large \" ) NEW_LINE DEDENT result = a + ' \u2581 ' + b NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , result ) ) NEW_LINE DEDENT", "functions_standalone": [["debug", "def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT"], ["invert", "def invert ( char ) : NEW_LINE INDENT if char == '1' : NEW_LINE INDENT return '0' NEW_LINE DEDENT elif char == '0' : NEW_LINE INDENT return '1' NEW_LINE DEDENT else : NEW_LINE INDENT raise Exception ( char ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_01", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class Round0A { int cases ; long calc ( long N ) { boolean seen [ ] = new boolean [ 10 ] ; int nSeen = 0 ; long x = N ; while ( true ) { String s = \" \" + x ; for ( int n = 0 ; n < s . length ( ) ; n ++ ) { char c = s . charAt ( n ) ; if ( ! seen [ c - '0' ] ) { seen [ c - '0' ] = true ; nSeen ++ ; } } if ( nSeen == 10 ) break ; x += N ; } return x ; } String calcS ( long N ) { if ( N == 0 ) return \" INSOMNIA \" ; return \" \" + calc ( N ) ; } void process ( Scanner scanner , PrintStream out ) throws IOException { cases = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int curCase = 0 ; curCase < cases ; curCase ++ ) { long N = scanner . nextLong ( ) ; out . println ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \u2581 \" + calcS ( N ) ) ; } } Round0A ( ) throws IOException { Scanner in = new Scanner ( new File ( \" C : \\\\ Users \\\\ Olaf \\\\ Downloads \\\\ A - large . in \" ) ) ; PrintStream out = new PrintStream ( \" out - A - large . txt \" ) ; process ( in , out ) ; in . close ( ) ; out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new Round0A ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Round0A ( ) ; }"]], "functions_class": [["calc", "long calc ( long N ) { boolean seen [ ] = new boolean [ 10 ] ; int nSeen = 0 ; long x = N ; while ( true ) { String s = \" \" + x ; for ( int n = 0 ; n < s . length ( ) ; n ++ ) { char c = s . charAt ( n ) ; if ( ! seen [ c - '0' ] ) { seen [ c - '0' ] = true ; nSeen ++ ; } } if ( nSeen == 10 ) break ; x += N ; } return x ; }"], ["calcS", "String calcS ( long N ) { if ( N == 0 ) return \" INSOMNIA \" ; return \" \" + calc ( N ) ; }"], ["process", "void process ( Scanner scanner , PrintStream out ) throws IOException { cases = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int curCase = 0 ; curCase < cases ; curCase ++ ) { long N = scanner . nextLong ( ) ; out . println ( \" Case \u2581 # \" + ( curCase + 1 ) + \" : \u2581 \" + calcS ( N ) ) ; } }"], ["Round0A", "Round0A ( ) throws IOException { Scanner in = new Scanner ( new File ( \" C : \\\\ Users \\\\ Olaf \\\\ Downloads \\\\ A - large . in \" ) ) ; PrintStream out = new PrintStream ( \" out - A - large . txt \" ) ; process ( in , out ) ; in . close ( ) ; out . close ( ) ; }"]]}, {"id": "8", "code": "package gcj2016 . qualif ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ExoA { public static void main ( final String [ ] args ) { final String base = \" / home / jfortin / workspace - gcj / Codejam2016 / q / ExoA / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoA . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } private static void test ( final Scanner sc , final PrintWriter pw ) { int N = sc . nextInt ( ) ; if ( N == 0 ) { pw . print ( \" INSOMNIA \" ) ; return ; } int i = 0 ; long n = 0 ; boolean digits [ ] = new boolean [ 10 ] ; while ( notFull ( digits ) ) { i ++ ; n += N ; if ( i > 100000 || n < 0 ) { pw . print ( \" INSOMNIA \" ) ; return ; } fillDigits ( n , digits ) ; } pw . print ( n ) ; } private static void fillDigits ( long n , final boolean [ ] digits ) { while ( n > 0 ) { long d = n % 10 ; digits [ ( int ) d ] = true ; n = n / 10 ; } } private static boolean notFull ( final boolean [ ] digits ) { for ( boolean b : digits ) { if ( ! b ) { return true ; } } return false ; } }", "functions_standalone": [["main", "public static void main ( final String [ ] args ) { final String base = \" / home / jfortin / workspace - gcj / Codejam2016 / q / ExoA / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoA . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"], ["test", "private static void test ( final Scanner sc , final PrintWriter pw ) { int N = sc . nextInt ( ) ; if ( N == 0 ) { pw . print ( \" INSOMNIA \" ) ; return ; } int i = 0 ; long n = 0 ; boolean digits [ ] = new boolean [ 10 ] ; while ( notFull ( digits ) ) { i ++ ; n += N ; if ( i > 100000 || n < 0 ) { pw . print ( \" INSOMNIA \" ) ; return ; } fillDigits ( n , digits ) ; } pw . print ( n ) ; }"], ["fillDigits", "private static void fillDigits ( long n , final boolean [ ] digits ) { while ( n > 0 ) { long d = n % 10 ; digits [ ( int ) d ] = true ; n = n / 10 ; } }"], ["notFull", "private static boolean notFull ( final boolean [ ] digits ) { for ( boolean b : digits ) { if ( ! b ) { return true ; } } return false ; }"]], "functions_class": []}, {"id": "0", "code": "import java . io . * ; import java . util . * ; public class countingsheep { private static InputReader in ; private static PrintWriter out ; public static boolean SUBMIT = true ; public static final String NAME = \" A - large \" ; private static void main2 ( ) throws IOException { int n = in . nextInt ( ) ; if ( n == 0 ) { out . println ( \" INSOMNIA \" ) ; return ; } HashSet < Integer > seen = new HashSet < > ( ) ; int cur = n ; while ( true ) { int m = cur ; while ( m > 0 ) { seen . add ( m % 10 ) ; m /= 10 ; } boolean ok = true ; for ( int i = 0 ; i <= 9 ; i ++ ) { if ( ! seen . contains ( i ) ) { ok = false ; } } if ( ok ) break ; cur += n ; } out . println ( cur ) ; } public static void main ( String [ ] args ) throws IOException { if ( SUBMIT ) { in = new InputReader ( new FileInputStream ( new File ( NAME + \" . in \" ) ) ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ) ; } else { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out , true ) ; } int numCases = in . nextInt ( ) ; for ( int test = 1 ; test <= numCases ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; main2 ( ) ; } out . close ( ) ; System . exit ( 0 ) ; } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "functions_standalone": [["main2", "private static void main2 ( ) throws IOException { int n = in . nextInt ( ) ; if ( n == 0 ) { out . println ( \" INSOMNIA \" ) ; return ; } HashSet < Integer > seen = new HashSet < > ( ) ; int cur = n ; while ( true ) { int m = cur ; while ( m > 0 ) { seen . add ( m % 10 ) ; m /= 10 ; } boolean ok = true ; for ( int i = 0 ; i <= 9 ; i ++ ) { if ( ! seen . contains ( i ) ) { ok = false ; } } if ( ok ) break ; cur += n ; } out . println ( cur ) ; }"], ["main", "public static void main ( String [ ] args ) throws IOException { if ( SUBMIT ) { in = new InputReader ( new FileInputStream ( new File ( NAME + \" . in \" ) ) ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ) ; } else { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out , true ) ; } int numCases = in . nextInt ( ) ; for ( int test = 1 ; test <= numCases ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; main2 ( ) ; } out . close ( ) ; System . exit ( 0 ) ; }"]], "functions_class": [["InputReader", "public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; }"], ["next", "public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }"]]}, {"id": "14", "code": "package qualification ; import java . io . * ; public class A_CountingSheep { private static final String FILENAME = \" data / qualification / A - large \" ; private static final boolean STANDARD_OUTPUT = false ; private static BufferedReader in = null ; private static PrintWriter out = null ; public static void main ( String [ ] args ) throws Throwable { try ( BufferedReader reader = in = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ) { try ( PrintWriter writer = out = ! STANDARD_OUTPUT ? new PrintWriter ( FILENAME + \" . out \" ) : new PrintWriter ( System . out ) ) { process ( ) ; } } } private static void process ( ) throws Throwable { for ( int caseNumber = 1 , T = Integer . parseInt ( in . readLine ( ) ) ; caseNumber <= T ; caseNumber ++ ) { long N = Long . parseLong ( in . readLine ( ) ) ; long n = 0L , m = 0L ; if ( N > 0 ) { boolean [ ] visited = new boolean [ 10 ] ; int visitedCount = 0 ; loop : for ( n = N ; visitedCount < 10 ; n += N ) { for ( m = n ; m > 0 ; m /= 10 ) { if ( ! visited [ ( int ) ( m % 10 ) ] ) { visited [ ( int ) ( m % 10 ) ] = true ; visitedCount ++ ; if ( visitedCount == 10 ) break loop ; } } } } out . println ( \" Case \u2581 # \" + caseNumber + \" : \u2581 \" + ( n == 0L ? \" INSOMNIA \" : n ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { try ( BufferedReader reader = in = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ) { try ( PrintWriter writer = out = ! STANDARD_OUTPUT ? new PrintWriter ( FILENAME + \" . out \" ) : new PrintWriter ( System . out ) ) { process ( ) ; } } }"], ["process", "private static void process ( ) throws Throwable { for ( int caseNumber = 1 , T = Integer . parseInt ( in . readLine ( ) ) ; caseNumber <= T ; caseNumber ++ ) { long N = Long . parseLong ( in . readLine ( ) ) ; long n = 0L , m = 0L ; if ( N > 0 ) { boolean [ ] visited = new boolean [ 10 ] ; int visitedCount = 0 ; loop : for ( n = N ; visitedCount < 10 ; n += N ) { for ( m = n ; m > 0 ; m /= 10 ) { if ( ! visited [ ( int ) ( m % 10 ) ] ) { visited [ ( int ) ( m % 10 ) ] = true ; visitedCount ++ ; if ( visitedCount == 10 ) break loop ; } } } } out . println ( \" Case \u2581 # \" + caseNumber + \" : \u2581 \" + ( n == 0L ? \" INSOMNIA \" : n ) ) ; } }"]], "functions_class": []}, {"id": "12", "code": "import java . io . * ; public class A { static void mark ( boolean [ ] bb , int n ) { if ( n > 0 ) { bb [ n % 10 ] = true ; mark ( bb , n / 10 ) ; } } static boolean check ( boolean [ ] bb ) { for ( int d = 0 ; d <= 9 ; d ++ ) if ( ! bb [ d ] ) return false ; return true ; } static int count ( int n ) { boolean [ ] bb = new boolean [ 10 ] ; for ( int i = 1 ; ; i ++ ) { mark ( bb , n * i ) ; if ( check ( bb ) ) return n * i ; } } public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = Integer . parseInt ( br . readLine ( ) ) ; pw . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + ( n == 0 ? \" INSOMNIA \" : count ( n ) ) ) ; } pw . close ( ) ; } }", "functions_standalone": [["mark", "static void mark ( boolean [ ] bb , int n ) { if ( n > 0 ) { bb [ n % 10 ] = true ; mark ( bb , n / 10 ) ; } }"], ["check", "static boolean check ( boolean [ ] bb ) { for ( int d = 0 ; d <= 9 ; d ++ ) if ( ! bb [ d ] ) return false ; return true ; }"], ["count", "static int count ( int n ) { boolean [ ] bb = new boolean [ 10 ] ; for ( int i = 1 ; ; i ++ ) { mark ( bb , n * i ) ; if ( check ( bb ) ) return n * i ; } }"], ["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = Integer . parseInt ( br . readLine ( ) ) ; pw . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + ( n == 0 ? \" INSOMNIA \" : count ( n ) ) ) ; } pw . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "filename = \" A - large \" NEW_LINE fin = open ( filename + \" . in \" , \" r \" ) NEW_LINE fout = open ( filename + \" . out \" , \" w \" ) NEW_LINE casenum = int ( fin . readline ( ) ) NEW_LINE for ite in range ( casenum ) : NEW_LINE INDENT num_count = int ( fin . readline ( ) ) NEW_LINE fulllist = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] NEW_LINE currlist = [ ] NEW_LINE total_num = 0 NEW_LINE if num_count == 0 : NEW_LINE INDENT return_str = ' INSOMNIA ' NEW_LINE DEDENT else : NEW_LINE INDENT while len ( currlist ) < len ( fulllist ) : NEW_LINE INDENT total_num += num_count NEW_LINE numstr = str ( total_num ) NEW_LINE for s in numstr : NEW_LINE INDENT if s not in currlist : NEW_LINE INDENT currlist . append ( s ) NEW_LINE DEDENT DEDENT DEDENT return_str = numstr NEW_LINE DEDENT fout . write ( \" Case \u2581 # { 0 } : \u2581 { 1 } \\n \" . format ( ite + 1 , return_str ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "7", "code": "import sys NEW_LINE sys . stdin = open ( \" data . txt \" ) NEW_LINE sys . stdout = open ( \" out . txt \" , \" w \" ) NEW_LINE input = sys . stdin . readline NEW_LINE for case in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( \" Case \u2581 # % s : \u2581 INSOMNIA \" % ( case + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT left = [ 1 ] * 10 NEW_LINE count = 10 NEW_LINE for i in range ( 1 , 10000000 ) : NEW_LINE INDENT for ch in map ( int , str ( n * i ) ) : NEW_LINE INDENT if left [ ch ] : NEW_LINE INDENT left [ ch ] = 0 NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT print ( \" Case \u2581 # % s : \u2581 % s \" % ( case + 1 , n * i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "6", "code": "import os , inspect NEW_LINE problemName = ' counting _ sheep ' NEW_LINE runOnRealData = False NEW_LINE def digits ( N ) : NEW_LINE INDENT return set ( map ( int , str ( N ) ) ) NEW_LINE DEDENT def solution ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' INSOMNIA ' NEW_LINE DEDENT allDigits = set ( range ( 10 ) ) NEW_LINE multiple = 0 NEW_LINE while len ( allDigits ) > 0 : NEW_LINE INDENT multiple += N NEW_LINE allDigits = allDigits . difference ( digits ( multiple ) ) NEW_LINE DEDENT return multiple NEW_LINE DEDENT currentDir = os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) NEW_LINE inputString = ' A - large . in ' NEW_LINE outputString = problemName + ' _ output ' NEW_LINE inFile = os . path . join ( currentDir , ' inputfiles ' , inputString ) NEW_LINE outFile = os . path . join ( currentDir , ' outputfiles ' , ' % s . txt ' % outputString ) NEW_LINE if os . path . exists ( outFile ) : NEW_LINE INDENT os . remove ( outFile ) NEW_LINE DEDENT with open ( inFile , ' r ' ) as inputfile : NEW_LINE INDENT numberOfCases = int ( inputfile . readline ( ) ) NEW_LINE for case in xrange ( 1 , numberOfCases + 1 ) : NEW_LINE INDENT N = int ( inputfile . readline ( ) ) NEW_LINE result = solution ( N ) NEW_LINE with open ( outFile , ' a ' ) as f : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( case , str ( result ) ) ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["digits", "def digits ( N ) : NEW_LINE INDENT return set ( map ( int , str ( N ) ) ) NEW_LINE DEDENT"], ["solution", "def solution ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' INSOMNIA ' NEW_LINE DEDENT allDigits = set ( range ( 10 ) ) NEW_LINE multiple = 0 NEW_LINE while len ( allDigits ) > 0 : NEW_LINE INDENT multiple += N NEW_LINE allDigits = allDigits . difference ( digits ( multiple ) ) NEW_LINE DEDENT return multiple NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import math NEW_LINE import sys NEW_LINE def base10 ( N ) : NEW_LINE INDENT t = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT t . append ( N % 10 ) NEW_LINE N = int ( ( N - t [ - 1 ] ) / 10 ) NEW_LINE DEDENT return t NEW_LINE DEDENT def findsol ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return ' INSOMNIA ' NEW_LINE DEDENT z = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE f = 0 NEW_LINE b = 1 NEW_LINE while 1 : NEW_LINE INDENT a = base10 ( N * b ) NEW_LINE for jj in a : NEW_LINE INDENT if ( z [ jj ] == 0 ) : NEW_LINE INDENT f += 1 NEW_LINE DEDENT z [ jj ] = 1 NEW_LINE DEDENT if ( f == 10 ) : NEW_LINE INDENT return N * b NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return b NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT fidi = open ( ' A - large . in ' , ' r ' ) NEW_LINE fido = open ( ' a . out ' , ' w ' ) NEW_LINE T = fidi . readline ( ) NEW_LINE T = int ( T ) NEW_LINE for ii in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( fidi . readline ( ) ) NEW_LINE a = findsol ( N ) NEW_LINE fido . write ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' + str ( a ) + ' \\n ' ) NEW_LINE print ( ' Case \u2581 # ' + str ( ii ) , ' : \u2581 ' , str ( a ) ) NEW_LINE DEDENT fidi . close ( ) NEW_LINE fido . close ( ) NEW_LINE", "functions_standalone": [["base10", "def base10 ( N ) : NEW_LINE INDENT t = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT t . append ( N % 10 ) NEW_LINE N = int ( ( N - t [ - 1 ] ) / 10 ) NEW_LINE DEDENT return t NEW_LINE DEDENT"], ["findsol", "def findsol ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return ' INSOMNIA ' NEW_LINE DEDENT z = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE f = 0 NEW_LINE b = 1 NEW_LINE while 1 : NEW_LINE INDENT a = base10 ( N * b ) NEW_LINE for jj in a : NEW_LINE INDENT if ( z [ jj ] == 0 ) : NEW_LINE INDENT f += 1 NEW_LINE DEDENT z [ jj ] = 1 NEW_LINE DEDENT if ( f == 10 ) : NEW_LINE INDENT return N * b NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return b NEW_LINE DEDENT"], ["convertnums", "def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT"]], "functions_class": []}, {"id": "14", "code": "import os , sys , ljqpy , time NEW_LINE time . clock ( ) NEW_LINE def Run ( N ) : NEW_LINE INDENT st = set ( ) NEW_LINE m = 0 NEW_LINE for i in range ( 10000000 ) : NEW_LINE INDENT m += N NEW_LINE for ch in str ( m ) : st . add ( ch ) NEW_LINE if len ( st ) == 10 : NEW_LINE INDENT return str ( m ) NEW_LINE DEDENT DEDENT return ' INSOMNIA ' NEW_LINE DEDENT lst = ljqpy . LoadList ( ' A - large . in ' ) NEW_LINE with open ( ' A - large . out ' , ' w ' ) as fout : NEW_LINE INDENT for k , v in enumerate ( lst [ 1 : ] ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( 1 + k , Run ( int ( v ) ) ) ) NEW_LINE DEDENT DEDENT print ( ' completed ' ) NEW_LINE", "functions_standalone": [["Run", "def Run ( N ) : NEW_LINE INDENT st = set ( ) NEW_LINE m = 0 NEW_LINE for i in range ( 10000000 ) : NEW_LINE INDENT m += N NEW_LINE for ch in str ( m ) : st . add ( ch ) NEW_LINE if len ( st ) == 10 : NEW_LINE INDENT return str ( m ) NEW_LINE DEDENT DEDENT return ' INSOMNIA ' NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_41", "java": [{"id": "19", "code": "import java . util . Scanner ; public class A { static Scanner sc = new Scanner ( System . in ) ; static char [ ] cs = { ' P ' , ' R ' , ' S ' } ; static String [ ] [ ] dp = new String [ 3 ] [ 13 ] ; public static void main ( String [ ] args ) { dp [ 0 ] [ 0 ] = \" P \" ; dp [ 1 ] [ 0 ] = \" R \" ; dp [ 2 ] [ 0 ] = \" S \" ; for ( int i = 1 ; i < dp [ 0 ] . length ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { dp [ j ] [ i ] = dp [ j ] [ i - 1 ] + dp [ ( j + 1 ) % 3 ] [ i - 1 ] ; String o = dp [ ( j + 1 ) % 3 ] [ i - 1 ] + dp [ j ] [ i - 1 ] ; if ( o . compareTo ( dp [ j ] [ i ] ) < 0 ) dp [ j ] [ i ] = o ; } } int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; System . out . println ( solve ( ) ) ; } } static String solve ( ) { int N = sc . nextInt ( ) ; int R = sc . nextInt ( ) ; int P = sc . nextInt ( ) ; int S = sc . nextInt ( ) ; String ret = null ; for ( int i = 0 ; i < 3 ; ++ i ) { int [ ] c = new int [ 3 ] ; for ( char ch : dp [ i ] [ N ] . toCharArray ( ) ) { if ( ch == ' P ' ) c [ 0 ] ++ ; if ( ch == ' R ' ) c [ 1 ] ++ ; if ( ch == ' S ' ) c [ 2 ] ++ ; } if ( c [ 0 ] == P && c [ 1 ] == R && c [ 2 ] == S ) { ret = dp [ i ] [ N ] ; } } return ret == null ? \" IMPOSSIBLE \" : ret ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { dp [ 0 ] [ 0 ] = \" P \" ; dp [ 1 ] [ 0 ] = \" R \" ; dp [ 2 ] [ 0 ] = \" S \" ; for ( int i = 1 ; i < dp [ 0 ] . length ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { dp [ j ] [ i ] = dp [ j ] [ i - 1 ] + dp [ ( j + 1 ) % 3 ] [ i - 1 ] ; String o = dp [ ( j + 1 ) % 3 ] [ i - 1 ] + dp [ j ] [ i - 1 ] ; if ( o . compareTo ( dp [ j ] [ i ] ) < 0 ) dp [ j ] [ i ] = o ; } } int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; System . out . println ( solve ( ) ) ; } }"], ["solve", "static String solve ( ) { int N = sc . nextInt ( ) ; int R = sc . nextInt ( ) ; int P = sc . nextInt ( ) ; int S = sc . nextInt ( ) ; String ret = null ; for ( int i = 0 ; i < 3 ; ++ i ) { int [ ] c = new int [ 3 ] ; for ( char ch : dp [ i ] [ N ] . toCharArray ( ) ) { if ( ch == ' P ' ) c [ 0 ] ++ ; if ( ch == ' R ' ) c [ 1 ] ++ ; if ( ch == ' S ' ) c [ 2 ] ++ ; } if ( c [ 0 ] == P && c [ 1 ] == R && c [ 2 ] == S ) { ret = dp [ i ] [ N ] ; } } return ret == null ? \" IMPOSSIBLE \" : ret ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "__author__ = ' Tianren \u2581 Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( R , P , S ) : NEW_LINE INDENT if ( R < 0 or P < 0 or S < 0 ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if R + P + S == 1 : NEW_LINE INDENT return ' R ' if R > 0 else ' P ' if P > 0 else ' S ' NEW_LINE DEDENT Rn , Pn , Sn = ( R + S - P ) // 2 , ( P - S + R ) // 2 , ( - R + S + P ) // 2 NEW_LINE if ( Rn > R or Pn > P or Sn > S ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT res = solve ( Rn , Pn , Sn ) NEW_LINE if res == \" IMPOSSIBLE \" : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT nres = ' ' NEW_LINE m = { ' R ' : ' RS ' , ' S ' : ' SP ' , ' P ' : ' PR ' } NEW_LINE for c in res : NEW_LINE INDENT nres += m [ c ] NEW_LINE DEDENT return nres NEW_LINE DEDENT DEDENT def asort ( S ) : NEW_LINE INDENT if S == \" IMPOSSIBLE \" : NEW_LINE INDENT return S NEW_LINE DEDENT l = len ( S ) NEW_LINE if l > 1 : NEW_LINE INDENT Sl = asort ( S [ : l // 2 ] ) NEW_LINE Sh = asort ( S [ l // 2 : ] ) NEW_LINE S = Sl + Sh if Sl < Sh else Sh + Sl NEW_LINE DEDENT return S NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , R , P , S = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( t + 1 , asort ( solve ( R , P , S ) ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solve", "def solve ( R , P , S ) : NEW_LINE INDENT if ( R < 0 or P < 0 or S < 0 ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if R + P + S == 1 : NEW_LINE INDENT return ' R ' if R > 0 else ' P ' if P > 0 else ' S ' NEW_LINE DEDENT Rn , Pn , Sn = ( R + S - P ) // 2 , ( P - S + R ) // 2 , ( - R + S + P ) // 2 NEW_LINE if ( Rn > R or Pn > P or Sn > S ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT res = solve ( Rn , Pn , Sn ) NEW_LINE if res == \" IMPOSSIBLE \" : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT nres = ' ' NEW_LINE m = { ' R ' : ' RS ' , ' S ' : ' SP ' , ' P ' : ' PR ' } NEW_LINE for c in res : NEW_LINE INDENT nres += m [ c ] NEW_LINE DEDENT return nres NEW_LINE DEDENT DEDENT"], ["asort", "def asort ( S ) : NEW_LINE INDENT if S == \" IMPOSSIBLE \" : NEW_LINE INDENT return S NEW_LINE DEDENT l = len ( S ) NEW_LINE if l > 1 : NEW_LINE INDENT Sl = asort ( S [ : l // 2 ] ) NEW_LINE Sh = asort ( S [ l // 2 : ] ) NEW_LINE S = Sl + Sh if Sl < Sh else Sh + Sl NEW_LINE DEDENT return S NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "wins_over = { \" R \" : \" S \" , \" S \" : \" P \" , \" P \" : \" R \" } NEW_LINE def reorder ( foo ) : NEW_LINE INDENT if len ( foo ) == 1 : NEW_LINE INDENT return foo NEW_LINE DEDENT l = reorder ( foo [ : len ( foo ) // 2 ] ) NEW_LINE r = reorder ( foo [ len ( foo ) // 2 : ] ) NEW_LINE return \" \" . join ( sorted ( [ l , r ] ) ) NEW_LINE DEDENT def reverse ( n , start ) : NEW_LINE INDENT lineup = [ start ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT new_lineup = [ ] NEW_LINE for c in lineup : NEW_LINE INDENT new_lineup . extend ( [ c , wins_over [ c ] ] ) NEW_LINE DEDENT lineup = new_lineup NEW_LINE DEDENT return reorder ( \" \" . join ( lineup ) ) NEW_LINE DEDENT def run ( ) : NEW_LINE INDENT n , r , p , s = tuple ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE ress = set ( ) NEW_LINE for c in wins_over : NEW_LINE INDENT foo = reverse ( n , c ) NEW_LINE if foo . count ( \" R \" ) == r and foo . count ( \" P \" ) == p and foo . count ( \" S \" ) == s : NEW_LINE INDENT ress . add ( foo ) NEW_LINE DEDENT DEDENT if len ( ress ) == 0 : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT return min ( ress ) NEW_LINE DEDENT DEDENT tc = int ( input ( ) ) NEW_LINE for i in range ( tc ) : NEW_LINE INDENT res = run ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , res ) ) NEW_LINE DEDENT", "functions_standalone": [["reorder", "def reorder ( foo ) : NEW_LINE INDENT if len ( foo ) == 1 : NEW_LINE INDENT return foo NEW_LINE DEDENT l = reorder ( foo [ : len ( foo ) // 2 ] ) NEW_LINE r = reorder ( foo [ len ( foo ) // 2 : ] ) NEW_LINE return \" \" . join ( sorted ( [ l , r ] ) ) NEW_LINE DEDENT"], ["reverse", "def reverse ( n , start ) : NEW_LINE INDENT lineup = [ start ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT new_lineup = [ ] NEW_LINE for c in lineup : NEW_LINE INDENT new_lineup . extend ( [ c , wins_over [ c ] ] ) NEW_LINE DEDENT lineup = new_lineup NEW_LINE DEDENT return reorder ( \" \" . join ( lineup ) ) NEW_LINE DEDENT"], ["run", "def run ( ) : NEW_LINE INDENT n , r , p , s = tuple ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE ress = set ( ) NEW_LINE for c in wins_over : NEW_LINE INDENT foo = reverse ( n , c ) NEW_LINE if foo . count ( \" R \" ) == r and foo . count ( \" P \" ) == p and foo . count ( \" S \" ) == s : NEW_LINE INDENT ress . add ( foo ) NEW_LINE DEDENT DEDENT if len ( ress ) == 0 : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT return min ( ress ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "19", "code": "a = [ [ ' P ' , ' R ' , ' S ' ] ] NEW_LINE u = ' PRS ' NEW_LINE for n in range ( 1 , 13 ) : NEW_LINE INDENT v = [ ] NEW_LINE for t in range ( 3 ) : NEW_LINE INDENT x , y = a [ n - 1 ] [ t ] , a [ n - 1 ] [ ( t + 1 ) % 3 ] NEW_LINE v . append ( min ( x + y , y + x ) ) NEW_LINE DEDENT a . append ( v ) NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT N , r , p , s = map ( int , input ( ) . split ( ) ) NEW_LINE res = ' IMPOSSIBLE ' NEW_LINE for u in a [ N ] : NEW_LINE INDENT if u . count ( ' R ' ) == r and u . count ( ' S ' ) == s and u . count ( ' P ' ) == p : NEW_LINE INDENT if res == ' IMPOSSIBLE ' : NEW_LINE INDENT res = u NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , u ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Case \u2581 # % d : \" % ( i + 1 ) , res ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "from pprint import pprint NEW_LINE MAXN = 14 ; NEW_LINE tests = int ( input ( ) ) NEW_LINE src = { } NEW_LINE chars = ( ' R ' , ' P ' , ' S ' ) NEW_LINE nxt = { ' R ' : ' S ' , ' S ' : ' P ' , ' P ' : ' R ' } NEW_LINE for ch in chars : NEW_LINE INDENT src [ ( ch , 1 ) ] = ch NEW_LINE DEDENT for i in range ( 2 , MAXN + 1 ) : NEW_LINE INDENT for ch in chars : NEW_LINE INDENT s1 = src [ ( ch , i - 1 ) ] NEW_LINE s2 = src [ ( nxt [ ch ] , i - 1 ) ] NEW_LINE s = ' ' NEW_LINE if s1 < s2 : NEW_LINE INDENT s = s1 + s2 NEW_LINE DEDENT else : NEW_LINE INDENT s = s2 + s1 NEW_LINE DEDENT src [ ( ch , i ) ] = s NEW_LINE DEDENT DEDENT count = { } NEW_LINE for i in range ( 1 , MAXN + 1 ) : NEW_LINE INDENT for ch in chars : NEW_LINE INDENT s = src [ ( ch , i ) ] NEW_LINE count [ ( ch , i ) ] = tuple ( s . count ( x ) for x in chars ) NEW_LINE DEDENT DEDENT for test in range ( tests ) : NEW_LINE INDENT n , r , p , s , = map ( int , input ( ) . split ( ) ) NEW_LINE n += 1 NEW_LINE ans = ' Z ' NEW_LINE for ch in chars : NEW_LINE INDENT if count [ ( ch , n ) ] == ( r , p , s ) : NEW_LINE INDENT if src [ ( ch , n ) ] < ans : NEW_LINE INDENT ans = src [ ( ch , n ) ] NEW_LINE DEDENT DEDENT DEDENT if ans == ' Z ' : NEW_LINE INDENT ans = ' IMPOSSIBLE ' NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( test + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_16_23", "java": [{"id": "2", "code": "package round1b ; import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Kattio extends PrintWriter { public Kattio ( InputStream i ) { super ( new BufferedOutputStream ( System . out ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public Kattio ( InputStream i , OutputStream o ) { super ( new BufferedOutputStream ( o ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public boolean hasMoreTokens ( ) { return peekToken ( ) != null ; } public int getInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } public double getDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } public long getLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } public String getWord ( ) { return nextToken ( ) ; } private BufferedReader r ; private String line ; private StringTokenizer st ; private String token ; private String peekToken ( ) { if ( token == null ) try { while ( st == null || ! st . hasMoreTokens ( ) ) { line = r . readLine ( ) ; if ( line == null ) return null ; st = new StringTokenizer ( line ) ; } token = st . nextToken ( ) ; } catch ( IOException e ) { } return token ; } private String nextToken ( ) { String ans = peekToken ( ) ; token = null ; return ans ; } }", "functions_standalone": [], "functions_class": [["Kattio", "public Kattio ( InputStream i ) { super ( new BufferedOutputStream ( System . out ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; }"], ["Kattio", "public Kattio ( InputStream i , OutputStream o ) { super ( new BufferedOutputStream ( o ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; }"], ["hasMoreTokens", "public boolean hasMoreTokens ( ) { return peekToken ( ) != null ; }"], ["getInt", "public int getInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["getDouble", "public double getDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; }"], ["getLong", "public long getLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["getWord", "public String getWord ( ) { return nextToken ( ) ; }"], ["peekToken", "private String peekToken ( ) { if ( token == null ) try { while ( st == null || ! st . hasMoreTokens ( ) ) { line = r . readLine ( ) ; if ( line == null ) return null ; st = new StringTokenizer ( line ) ; } token = st . nextToken ( ) ; } catch ( IOException e ) { } return token ; }"], ["nextToken", "private String nextToken ( ) { String ans = peekToken ( ) ; token = null ; return ans ; }"]]}, {"id": "17", "code": "package round1B ; import java . io . File ; import java . io . FileNotFoundException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Locale ; import java . util . Scanner ; import round1B . PushRelabelNodeEdge . Node ; public class ProblemC { public static void solve ( Scanner sc ) { int n = sc . nextInt ( ) ; HashMap < String , Node > map1 = new HashMap < > ( ) ; HashMap < String , Node > map2 = new HashMap < > ( ) ; Node start = new Node ( \" start \" ) ; Node end = new Node ( \" end \" ) ; for ( int i = 0 ; i < n ; i ++ ) { String firstWord = sc . next ( ) ; String secondWord = sc . next ( ) ; if ( ! map1 . containsKey ( firstWord ) ) { Node node = new Node ( firstWord ) ; map1 . put ( firstWord , node ) ; PushRelabelNodeEdge . addDirectedEdge ( start , node , 1 ) ; } if ( ! map2 . containsKey ( secondWord ) ) { Node node = new Node ( secondWord ) ; map2 . put ( secondWord , node ) ; PushRelabelNodeEdge . addDirectedEdge ( node , end , 1 ) ; } PushRelabelNodeEdge . addDirectedEdge ( map1 . get ( firstWord ) , map2 . get ( secondWord ) , 1 ) ; } ArrayList < Node > nodes = new ArrayList < > ( ) ; nodes . add ( start ) ; nodes . add ( end ) ; nodes . addAll ( map1 . values ( ) ) ; nodes . addAll ( map2 . values ( ) ) ; int flow = PushRelabelNodeEdge . getMaxFlow ( nodes , start , end ) ; int greedy = nodes . size ( ) - 2 - 2 * flow ; System . out . println ( n - flow - greedy ) ; } public static void main ( String [ ] args ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( \" C - large . in \" ) ) ; sc . useLocale ( Locale . US ) ; int cases = sc . nextInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { System . out . format ( Locale . US , \" Case \u2581 # % d : \u2581 \" , i ) ; solve ( sc ) ; } sc . close ( ) ; } }", "functions_standalone": [["solve", "public static void solve ( Scanner sc ) { int n = sc . nextInt ( ) ; HashMap < String , Node > map1 = new HashMap < > ( ) ; HashMap < String , Node > map2 = new HashMap < > ( ) ; Node start = new Node ( \" start \" ) ; Node end = new Node ( \" end \" ) ; for ( int i = 0 ; i < n ; i ++ ) { String firstWord = sc . next ( ) ; String secondWord = sc . next ( ) ; if ( ! map1 . containsKey ( firstWord ) ) { Node node = new Node ( firstWord ) ; map1 . put ( firstWord , node ) ; PushRelabelNodeEdge . addDirectedEdge ( start , node , 1 ) ; } if ( ! map2 . containsKey ( secondWord ) ) { Node node = new Node ( secondWord ) ; map2 . put ( secondWord , node ) ; PushRelabelNodeEdge . addDirectedEdge ( node , end , 1 ) ; } PushRelabelNodeEdge . addDirectedEdge ( map1 . get ( firstWord ) , map2 . get ( secondWord ) , 1 ) ; } ArrayList < Node > nodes = new ArrayList < > ( ) ; nodes . add ( start ) ; nodes . add ( end ) ; nodes . addAll ( map1 . values ( ) ) ; nodes . addAll ( map2 . values ( ) ) ; int flow = PushRelabelNodeEdge . getMaxFlow ( nodes , start , end ) ; int greedy = nodes . size ( ) - 2 - 2 * flow ; System . out . println ( n - flow - greedy ) ; }"], ["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( \" C - large . in \" ) ) ; sc . useLocale ( Locale . US ) ; int cases = sc . nextInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { System . out . format ( Locale . US , \" Case \u2581 # % d : \u2581 \" , i ) ; solve ( sc ) ; } sc . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "9", "code": "from __future__ import division NEW_LINE from gcj import * NEW_LINE FLAGS = ' ' NEW_LINE def case ( ) : NEW_LINE INDENT N , = ints ( ) NEW_LINE titles = [ line ( ) . split ( ) for i in range ( N ) ] NEW_LINE for t in titles : NEW_LINE INDENT a , b = t NEW_LINE t [ : ] = [ ' a : ' + a , ' b : ' + b ] NEW_LINE DEDENT pprint ( titles ) NEW_LINE source = 0 NEW_LINE sink = 1 NEW_LINE node2id = dict ( source = source , sink = sink ) NEW_LINE wordcounts = { } NEW_LINE for a , b in titles : NEW_LINE INDENT for x in a , b : NEW_LINE INDENT node2id . setdefault ( x , len ( node2id ) ) NEW_LINE wordcounts . setdefault ( x , 0 ) NEW_LINE wordcounts [ x ] += 1 NEW_LINE DEDENT DEDENT pprint ( node2id ) NEW_LINE pprint ( wordcounts ) NEW_LINE N = len ( node2id ) NEW_LINE capacity = [ [ 0 ] * N for i in range ( N ) ] NEW_LINE for word , count in wordcounts . items ( ) : NEW_LINE INDENT if word . startswith ( ' a ' ) : NEW_LINE INDENT capacity [ source ] [ node2id [ word ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT capacity [ node2id [ word ] ] [ sink ] = count - 1 NEW_LINE DEDENT DEDENT for a , b in titles : NEW_LINE INDENT assert capacity [ node2id [ a ] ] [ node2id [ b ] ] == 0 NEW_LINE capacity [ node2id [ a ] ] [ node2id [ b ] ] = 1 NEW_LINE DEDENT def dfs ( pos , visited ) : NEW_LINE INDENT if pos == sink : NEW_LINE INDENT return True NEW_LINE DEDENT for t in range ( N ) : NEW_LINE INDENT if capacity [ pos ] [ t ] : NEW_LINE INDENT if t in visited : continue NEW_LINE visited . add ( t ) NEW_LINE capacity [ pos ] [ t ] -= 1 NEW_LINE capacity [ t ] [ pos ] += 1 NEW_LINE res = dfs ( t , visited ) NEW_LINE if res : NEW_LINE INDENT return res NEW_LINE DEDENT capacity [ t ] [ pos ] -= 1 NEW_LINE capacity [ pos ] [ t ] += 1 NEW_LINE DEDENT DEDENT DEDENT n = 0 NEW_LINE while True : NEW_LINE INDENT res = dfs ( source , set ( ) ) NEW_LINE if not res : break NEW_LINE n += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["case", "def case ( ) : NEW_LINE INDENT N , = ints ( ) NEW_LINE titles = [ line ( ) . split ( ) for i in range ( N ) ] NEW_LINE for t in titles : NEW_LINE INDENT a , b = t NEW_LINE t [ : ] = [ ' a : ' + a , ' b : ' + b ] NEW_LINE DEDENT pprint ( titles ) NEW_LINE source = 0 NEW_LINE sink = 1 NEW_LINE node2id = dict ( source = source , sink = sink ) NEW_LINE wordcounts = { } NEW_LINE for a , b in titles : NEW_LINE INDENT for x in a , b : NEW_LINE INDENT node2id . setdefault ( x , len ( node2id ) ) NEW_LINE wordcounts . setdefault ( x , 0 ) NEW_LINE wordcounts [ x ] += 1 NEW_LINE DEDENT DEDENT pprint ( node2id ) NEW_LINE pprint ( wordcounts ) NEW_LINE N = len ( node2id ) NEW_LINE capacity = [ [ 0 ] * N for i in range ( N ) ] NEW_LINE for word , count in wordcounts . items ( ) : NEW_LINE INDENT if word . startswith ( ' a ' ) : NEW_LINE INDENT capacity [ source ] [ node2id [ word ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT capacity [ node2id [ word ] ] [ sink ] = count - 1 NEW_LINE DEDENT DEDENT for a , b in titles : NEW_LINE INDENT assert capacity [ node2id [ a ] ] [ node2id [ b ] ] == 0 NEW_LINE capacity [ node2id [ a ] ] [ node2id [ b ] ] = 1 NEW_LINE DEDENT def dfs ( pos , visited ) : NEW_LINE INDENT if pos == sink : NEW_LINE INDENT return True NEW_LINE DEDENT for t in range ( N ) : NEW_LINE INDENT if capacity [ pos ] [ t ] : NEW_LINE INDENT if t in visited : continue NEW_LINE visited . add ( t ) NEW_LINE capacity [ pos ] [ t ] -= 1 NEW_LINE capacity [ t ] [ pos ] += 1 NEW_LINE res = dfs ( t , visited ) NEW_LINE if res : NEW_LINE INDENT return res NEW_LINE DEDENT capacity [ t ] [ pos ] -= 1 NEW_LINE capacity [ pos ] [ t ] += 1 NEW_LINE DEDENT DEDENT DEDENT n = 0 NEW_LINE while True : NEW_LINE INDENT res = dfs ( source , set ( ) ) NEW_LINE if not res : break NEW_LINE n += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "import sys NEW_LINE import heapq NEW_LINE import bisect NEW_LINE import operator NEW_LINE from itertools import * NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE DEDENT T = read ( ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = read ( ) NEW_LINE G = dict ( ) NEW_LINE V = set ( ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT ( S , T ) = input ( ) . split ( ) NEW_LINE V . add ( ( S , 0 ) ) ; V . add ( ( T , 1 ) ) NEW_LINE if not ( S , 0 ) in G : NEW_LINE INDENT G [ ( S , 0 ) ] = [ ] NEW_LINE DEDENT G [ ( S , 0 ) ] . append ( ( T , 1 ) ) NEW_LINE if not ( T , 1 ) in G : NEW_LINE INDENT G [ ( T , 1 ) ] = [ ] NEW_LINE DEDENT G [ ( T , 1 ) ] . append ( ( S , 0 ) ) NEW_LINE DEDENT res = 0 NEW_LINE match = { v : - 1 for v in V } NEW_LINE def dfs ( v , used ) : NEW_LINE INDENT used [ v ] = True NEW_LINE for u in G [ v ] : NEW_LINE INDENT w = match [ u ] NEW_LINE if ( w == - 1 ) or ( not used [ w ] ) and dfs ( w , used ) : NEW_LINE INDENT match [ v ] = u NEW_LINE match [ u ] = v NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for v in V : NEW_LINE INDENT if match [ v ] == - 1 : NEW_LINE INDENT used = { v : 0 for v in V } NEW_LINE if dfs ( v , used ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT result = N - ( res + sum ( match [ v ] == - 1 for v in V ) ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , result ) ) NEW_LINE DEDENT", "functions_standalone": [["read", "def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT"], ["reads", "def reads ( ) : NEW_LINE INDENT return [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE DEDENT"], ["dfs", "def dfs ( v , used ) : NEW_LINE INDENT used [ v ] = True NEW_LINE for u in G [ v ] : NEW_LINE INDENT w = match [ u ] NEW_LINE if ( w == - 1 ) or ( not used [ w ] ) and dfs ( w , used ) : NEW_LINE INDENT match [ v ] = u NEW_LINE match [ u ] = v NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import sys NEW_LINE import re NEW_LINE import bipartite_matching NEW_LINE input_file = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE nb_tests = int ( input_file . readline ( ) ) NEW_LINE for i in range ( nb_tests ) : NEW_LINE INDENT nb_titles = int ( input_file . readline ( ) ) NEW_LINE titles = { } NEW_LINE first_titles = set ( { } ) NEW_LINE second_titles = set ( { } ) NEW_LINE for j in range ( nb_titles ) : NEW_LINE INDENT title = input_file . readline ( ) [ : - 1 ] . split ( ' \u2581 ' ) NEW_LINE first_titles = first_titles | { title [ 0 ] } NEW_LINE second_titles = second_titles | { title [ 1 ] } NEW_LINE if title [ 0 ] in titles : NEW_LINE INDENT titles [ title [ 0 ] ] . append ( title [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT titles [ title [ 0 ] ] = [ title [ 1 ] ] NEW_LINE DEDENT DEDENT matching = bipartite_matching . bipartiteMatch ( titles ) [ 0 ] NEW_LINE len_m = len ( matching ) NEW_LINE len_f = len ( first_titles ) NEW_LINE len_s = len ( second_titles ) NEW_LINE cover = len_f + len_s - len_m NEW_LINE print ( ' Case \u2581 # ' , i + 1 , ' : \u2581 ' , nb_titles - cover , sep = ' ' ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "def DFS ( G , U , V , x ) : NEW_LINE INDENT V [ x ] = True NEW_LINE for y in G [ x ] : NEW_LINE INDENT if U [ y ] == - 1 or ( not V [ U [ y ] ] and DFS ( G , U , V , U [ y ] ) ) : NEW_LINE INDENT U [ y ] = x NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def maximum_matching ( G , na , nb ) : NEW_LINE INDENT U = [ - 1 ] * nb NEW_LINE size = 0 NEW_LINE for i in range ( na ) : NEW_LINE INDENT V = [ False ] * na NEW_LINE if DFS ( G , U , V , i ) : NEW_LINE INDENT size += 1 NEW_LINE DEDENT DEDENT return size NEW_LINE DEDENT def get_index ( M , x ) : NEW_LINE INDENT if x in M : NEW_LINE INDENT return M [ x ] NEW_LINE DEDENT y = len ( M ) NEW_LINE M [ x ] = y NEW_LINE return y NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE MA = { } NEW_LINE MB = { } NEW_LINE E = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE xa = get_index ( MA , a ) NEW_LINE xb = get_index ( MB , b ) NEW_LINE E . append ( ( xa , xb ) ) NEW_LINE DEDENT G = [ [ ] for _ in range ( len ( MA ) ) ] NEW_LINE for u , v in E : NEW_LINE INDENT G [ u ] . append ( v ) NEW_LINE DEDENT return m - len ( MA ) - len ( MB ) + maximum_matching ( G , len ( MA ) , len ( MB ) ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["DFS", "def DFS ( G , U , V , x ) : NEW_LINE INDENT V [ x ] = True NEW_LINE for y in G [ x ] : NEW_LINE INDENT if U [ y ] == - 1 or ( not V [ U [ y ] ] and DFS ( G , U , V , U [ y ] ) ) : NEW_LINE INDENT U [ y ] = x NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"], ["maximum_matching", "def maximum_matching ( G , na , nb ) : NEW_LINE INDENT U = [ - 1 ] * nb NEW_LINE size = 0 NEW_LINE for i in range ( na ) : NEW_LINE INDENT V = [ False ] * na NEW_LINE if DFS ( G , U , V , i ) : NEW_LINE INDENT size += 1 NEW_LINE DEDENT DEDENT return size NEW_LINE DEDENT"], ["get_index", "def get_index ( M , x ) : NEW_LINE INDENT if x in M : NEW_LINE INDENT return M [ x ] NEW_LINE DEDENT y = len ( M ) NEW_LINE M [ x ] = y NEW_LINE return y NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE MA = { } NEW_LINE MB = { } NEW_LINE E = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE xa = get_index ( MA , a ) NEW_LINE xb = get_index ( MB , b ) NEW_LINE E . append ( ( xa , xb ) ) NEW_LINE DEDENT G = [ [ ] for _ in range ( len ( MA ) ) ] NEW_LINE for u , v in E : NEW_LINE INDENT G [ u ] . append ( v ) NEW_LINE DEDENT return m - len ( MA ) - len ( MB ) + maximum_matching ( G , len ( MA ) , len ( MB ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "def dfs ( e , ma , u , v ) : NEW_LINE INDENT if v in u : NEW_LINE INDENT return False NEW_LINE DEDENT u [ v ] = True NEW_LINE for x in e [ v ] : NEW_LINE INDENT if ( not x in ma ) or dfs ( e , ma , u , ma [ x ] ) : NEW_LINE INDENT ma [ x ] = v NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE e = { } NEW_LINE av = { } NEW_LINE bv = { } NEW_LINE ac = 0 NEW_LINE bc = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = list ( input ( ) . split ( ) ) NEW_LINE if not a in e : NEW_LINE INDENT e [ a ] = [ ] NEW_LINE DEDENT e [ a ] . append ( b ) NEW_LINE if not a in av : NEW_LINE INDENT av [ a ] = True NEW_LINE ac += 1 NEW_LINE DEDENT if not b in bv : NEW_LINE INDENT bv [ b ] = True NEW_LINE bc += 1 NEW_LINE DEDENT DEDENT m = 0 NEW_LINE ma = { } NEW_LINE for a in av : NEW_LINE INDENT u = { } NEW_LINE if dfs ( e , ma , u , a ) : NEW_LINE INDENT m += 1 NEW_LINE DEDENT DEDENT return str ( n - ( ac + bc - m ) ) NEW_LINE DEDENT nt = int ( input ( ) ) NEW_LINE for tt in range ( nt ) : NEW_LINE INDENT print ( ' Case \u2581 # ' + str ( tt + 1 ) + ' : \u2581 ' + str ( solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["dfs", "def dfs ( e , ma , u , v ) : NEW_LINE INDENT if v in u : NEW_LINE INDENT return False NEW_LINE DEDENT u [ v ] = True NEW_LINE for x in e [ v ] : NEW_LINE INDENT if ( not x in ma ) or dfs ( e , ma , u , ma [ x ] ) : NEW_LINE INDENT ma [ x ] = v NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE e = { } NEW_LINE av = { } NEW_LINE bv = { } NEW_LINE ac = 0 NEW_LINE bc = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = list ( input ( ) . split ( ) ) NEW_LINE if not a in e : NEW_LINE INDENT e [ a ] = [ ] NEW_LINE DEDENT e [ a ] . append ( b ) NEW_LINE if not a in av : NEW_LINE INDENT av [ a ] = True NEW_LINE ac += 1 NEW_LINE DEDENT if not b in bv : NEW_LINE INDENT bv [ b ] = True NEW_LINE bc += 1 NEW_LINE DEDENT DEDENT m = 0 NEW_LINE ma = { } NEW_LINE for a in av : NEW_LINE INDENT u = { } NEW_LINE if dfs ( e , ma , u , a ) : NEW_LINE INDENT m += 1 NEW_LINE DEDENT DEDENT return str ( n - ( ac + bc - m ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_12", "java": [{"id": "9", "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { int N = sc . nextInt ( ) ; Map < Integer , Integer > counts = new HashMap < > ( ) ; for ( int i = 0 ; i < 2 * N - 1 ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int height = sc . nextInt ( ) ; if ( counts . containsKey ( height ) ) { counts . put ( height , counts . get ( height ) + 1 ) ; } else { counts . put ( height , 1 ) ; } } } List < Integer > heights = new ArrayList < > ( ) ; for ( Map . Entry < Integer , Integer > entry : counts . entrySet ( ) ) { if ( entry . getValue ( ) % 2 != 0 ) { heights . add ( entry . getKey ( ) ) ; } } Collections . sort ( heights ) ; System . out . print ( \" Case \u2581 # \" + caseNum + \" : \" ) ; for ( int h : heights ) { System . out . print ( \" \u2581 \" + h ) ; } System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { int N = sc . nextInt ( ) ; Map < Integer , Integer > counts = new HashMap < > ( ) ; for ( int i = 0 ; i < 2 * N - 1 ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int height = sc . nextInt ( ) ; if ( counts . containsKey ( height ) ) { counts . put ( height , counts . get ( height ) + 1 ) ; } else { counts . put ( height , 1 ) ; } } } List < Integer > heights = new ArrayList < > ( ) ; for ( Map . Entry < Integer , Integer > entry : counts . entrySet ( ) ) { if ( entry . getValue ( ) % 2 != 0 ) { heights . add ( entry . getKey ( ) ) ; } } Collections . sort ( heights ) ; System . out . print ( \" Case \u2581 # \" + caseNum + \" : \" ) ; for ( int h : heights ) { System . out . print ( \" \u2581 \" + h ) ; } System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "7", "code": "import java . io . * ; import java . util . * ; public class B { String solveOne ( Scanner in ) { boolean odd [ ] = new boolean [ 2501 ] ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < 2 * n - 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int value = in . nextInt ( ) ; odd [ value ] = ! odd [ value ] ; } } String res = \" \" ; for ( int i = 0 ; i < odd . length ; i ++ ) { if ( odd [ i ] ) { res += \" \u2581 \" + i ; } } return res ; } void solve ( Scanner in , PrintWriter out ) { int nTests = in . nextInt ( ) ; for ( int iTest = 1 ; iTest <= nTests ; iTest ++ ) { out . printf ( \" Case \u2581 # % d : % s % n \" , iTest , solveOne ( in ) ) ; } } void run ( ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; ) { solve ( in , out ) ; } } public static void main ( String args [ ] ) { new B ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { new B ( ) . run ( ) ; }"]], "functions_class": [["solveOne", "String solveOne ( Scanner in ) { boolean odd [ ] = new boolean [ 2501 ] ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < 2 * n - 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int value = in . nextInt ( ) ; odd [ value ] = ! odd [ value ] ; } } String res = \" \" ; for ( int i = 0 ; i < odd . length ; i ++ ) { if ( odd [ i ] ) { res += \" \u2581 \" + i ; } } return res ; }"], ["solve", "void solve ( Scanner in , PrintWriter out ) { int nTests = in . nextInt ( ) ; for ( int iTest = 1 ; iTest <= nTests ; iTest ++ ) { out . printf ( \" Case \u2581 # % d : % s % n \" , iTest , solveOne ( in ) ) ; } }"], ["run", "void run ( ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; ) { solve ( in , out ) ; } }"]]}, {"id": "10", "code": "package Round1A2016 ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= T ; ++ testCase ) { final int n = sc . nextInt ( ) ; final int [ ] count = new int [ 2500 + 1 ] ; for ( int i = 0 ; i < n * ( 2 * n - 1 ) ; ++ i ) count [ sc . nextInt ( ) ] ++ ; int [ ] row = new int [ n ] ; int rowInd = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) { if ( count [ i ] % 2 == 1 ) { row [ rowInd ++ ] = i ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 \" , testCase ) ; for ( int x : row ) { System . out . print ( x + \" \u2581 \" ) ; } System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= T ; ++ testCase ) { final int n = sc . nextInt ( ) ; final int [ ] count = new int [ 2500 + 1 ] ; for ( int i = 0 ; i < n * ( 2 * n - 1 ) ; ++ i ) count [ sc . nextInt ( ) ] ++ ; int [ ] row = new int [ n ] ; int rowInd = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) { if ( count [ i ] % 2 == 1 ) { row [ rowInd ++ ] = i ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 \" , testCase ) ; for ( int x : row ) { System . out . print ( x + \" \u2581 \" ) ; } System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "1", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class b { public static void main ( String [ ] Args ) throws Exception { FS sc = new FS ( new File ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" b . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; boolean [ ] con = new boolean [ 2501 ] ; for ( int i = 0 ; i < ( n * 2 - 1 ) * n ; i ++ ) { int k = sc . nextInt ( ) ; con [ k ] = ! con [ k ] ; } out . printf ( \" Case \u2581 # % d : \" , ++ cc ) ; for ( int i = 0 ; i < 2501 ; i ++ ) { if ( con [ i ] ) { out . printf ( \" \u2581 % d \" , i ) ; } } out . println ( ) ; } out . close ( ) ; } public static class FS { BufferedReader br ; StringTokenizer st ; FS ( InputStream in ) throws Exception { br = new BufferedReader ( new InputStreamReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; } FS ( File in ) throws Exception { br = new BufferedReader ( new FileReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; } String next ( ) throws Exception { if ( st . hasMoreTokens ( ) ) return st . nextToken ( ) ; st = new StringTokenizer ( br . readLine ( ) ) ; return next ( ) ; } int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] Args ) throws Exception { FS sc = new FS ( new File ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" b . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; boolean [ ] con = new boolean [ 2501 ] ; for ( int i = 0 ; i < ( n * 2 - 1 ) * n ; i ++ ) { int k = sc . nextInt ( ) ; con [ k ] = ! con [ k ] ; } out . printf ( \" Case \u2581 # % d : \" , ++ cc ) ; for ( int i = 0 ; i < 2501 ; i ++ ) { if ( con [ i ] ) { out . printf ( \" \u2581 % d \" , i ) ; } } out . println ( ) ; } out . close ( ) ; }"]], "functions_class": [["FS", "FS ( InputStream in ) throws Exception { br = new BufferedReader ( new InputStreamReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; }"], ["FS", "FS ( File in ) throws Exception { br = new BufferedReader ( new FileReader ( in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; }"], ["next", "String next ( ) throws Exception { if ( st . hasMoreTokens ( ) ) return st . nextToken ( ) ; st = new StringTokenizer ( br . readLine ( ) ) ; return next ( ) ; }"], ["nextInt", "int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; }"]]}, {"id": "20", "code": "import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class Rank { public static void main ( String [ ] args ) throws IOException { Scanner input = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" output . txt \" ) ) ; int cs = input . nextInt ( ) ; for ( int i = 1 ; i <= cs ; i ++ ) { int [ ] arr = new int [ 2501 ] ; int sz = input . nextInt ( ) ; for ( int x = 0 ; x < sz * ( 2 * sz - 1 ) ; x ++ ) { arr [ input . nextInt ( ) ] ++ ; } out . printf ( \" Case \u2581 # % d : \" , i ) ; for ( int j = 0 ; j < arr . length ; j ++ ) if ( arr [ j ] % 2 == 1 ) out . print ( \" \u2581 \" + j ) ; out . println ( ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner input = new Scanner ( new File ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" output . txt \" ) ) ; int cs = input . nextInt ( ) ; for ( int i = 1 ; i <= cs ; i ++ ) { int [ ] arr = new int [ 2501 ] ; int sz = input . nextInt ( ) ; for ( int x = 0 ; x < sz * ( 2 * sz - 1 ) ; x ++ ) { arr [ input . nextInt ( ) ] ++ ; } out . printf ( \" Case \u2581 # % d : \" , i ) ; for ( int j = 0 ; j < arr . length ; j ++ ) if ( arr [ j ] % 2 == 1 ) out . print ( \" \u2581 \" + j ) ; out . println ( ) ; } out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "9", "code": "import collections NEW_LINE def solve ( rows ) : NEW_LINE INDENT cnt = collections . Counter ( ) NEW_LINE for i in rows : NEW_LINE INDENT cnt . update ( i ) NEW_LINE DEDENT rst = [ ] NEW_LINE for k , v in cnt . items ( ) : NEW_LINE INDENT if v % 2 : NEW_LINE INDENT rst . append ( k ) NEW_LINE DEDENT DEDENT return ' \u2581 ' . join ( map ( str , sorted ( rst ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT nr_case = int ( input ( ) ) NEW_LINE for case in range ( nr_case ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE rows = [ ] NEW_LINE for i in range ( N * 2 - 1 ) : NEW_LINE INDENT rows . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( case + 1 , solve ( rows ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( rows ) : NEW_LINE INDENT cnt = collections . Counter ( ) NEW_LINE for i in rows : NEW_LINE INDENT cnt . update ( i ) NEW_LINE DEDENT rst = [ ] NEW_LINE for k , v in cnt . items ( ) : NEW_LINE INDENT if v % 2 : NEW_LINE INDENT rst . append ( k ) NEW_LINE DEDENT DEDENT return ' \u2581 ' . join ( map ( str , sorted ( rst ) ) ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT nr_case = int ( input ( ) ) NEW_LINE for case in range ( nr_case ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE rows = [ ] NEW_LINE for i in range ( N * 2 - 1 ) : NEW_LINE INDENT rows . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( case + 1 , solve ( rows ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "5", "code": "task = ' B ' NEW_LINE type = 2 NEW_LINE from collections import Counter NEW_LINE if type == 0 : NEW_LINE INDENT inp = open ( ' sample . in ' , ' r ' ) NEW_LINE DEDENT elif type == 1 : NEW_LINE INDENT inp = open ( ' % s - small . in ' % ( task , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT inp = open ( ' % s - large . in ' % ( task ) , ) NEW_LINE DEDENT outp = open ( ' % s . out ' % ( task , ) , ' w ' ) NEW_LINE T = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT ans = [ ] NEW_LINE N = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE c = Counter ( ) NEW_LINE for j in range ( 2 * N - 1 ) : NEW_LINE INDENT s = inp . readline ( ) [ : - 1 ] . split ( ) NEW_LINE for k in s : NEW_LINE INDENT c [ k ] += 1 NEW_LINE DEDENT DEDENT for val in c . items ( ) : NEW_LINE INDENT if val [ 1 ] % 2 == 1 : NEW_LINE INDENT ans . append ( val [ 0 ] ) NEW_LINE DEDENT DEDENT ans . sort ( key = int ) NEW_LINE outp . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , \" \u2581 \" . join ( ans ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE fin = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fout = open ( \" p2 . out \" , \" w \" ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for tt in xrange ( T ) : NEW_LINE INDENT N = int ( fin . readline ( ) ) NEW_LINE times = { } NEW_LINE for i in xrange ( 2 * N - 1 ) : NEW_LINE INDENT info = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE for x in info : NEW_LINE INDENT if x not in times : NEW_LINE INDENT times [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT times [ x ] += 1 NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for x in times : NEW_LINE INDENT if times [ x ] % 2 == 1 : NEW_LINE INDENT ans . append ( x ) NEW_LINE DEDENT DEDENT ans = ' \u2581 ' . join ( map ( str , sorted ( ans ) ) ) NEW_LINE fout . write ( \" Case \u2581 # \" + str ( tt + 1 ) + \" : \u2581 \" + ans + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "import io , sys NEW_LINE import datetime , copy NEW_LINE fin = None NEW_LINE def solve ( ) : NEW_LINE INDENT n = num ( ) NEW_LINE cnts = { } NEW_LINE for _ in range ( 2 * n - 1 ) : NEW_LINE INDENT t = nums ( ) NEW_LINE for x in t : NEW_LINE INDENT if x in cnts : NEW_LINE INDENT cnts [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnts [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT res = [ ] NEW_LINE for k , v in cnts . items ( ) : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT res . append ( k ) NEW_LINE DEDENT DEDENT res . sort ( ) NEW_LINE return ' \u2581 ' . join ( [ str ( x ) for x in res ] ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT fname = ' a . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . out ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT n = num ( ) NEW_LINE cnts = { } NEW_LINE for _ in range ( 2 * n - 1 ) : NEW_LINE INDENT t = nums ( ) NEW_LINE for x in t : NEW_LINE INDENT if x in cnts : NEW_LINE INDENT cnts [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnts [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT res = [ ] NEW_LINE for k , v in cnts . items ( ) : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT res . append ( k ) NEW_LINE DEDENT DEDENT res . sort ( ) NEW_LINE return ' \u2581 ' . join ( [ str ( x ) for x in res ] ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT fname = ' a . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . out ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT"], ["nums", "def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["fnums", "def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["num", "def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT"], ["sstrip", "def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT"], ["strs", "def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT"], ["arrstr", "def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "3", "code": "from collections import Counter NEW_LINE def one_test ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 2 * n - 1 ) : NEW_LINE INDENT a . extend ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT c = Counter ( a ) NEW_LINE ans = sorted ( k for k , v in c . items ( ) if v % 2 == 1 ) NEW_LINE return ' \u2581 ' . join ( map ( str , ans ) ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i , one_test ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["one_test", "def one_test ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 2 * n - 1 ) : NEW_LINE INDENT a . extend ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT c = Counter ( a ) NEW_LINE ans = sorted ( k for k , v in c . items ( ) if v % 2 == 1 ) NEW_LINE return ' \u2581 ' . join ( map ( str , ans ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_16_13", "java": [{"id": "14", "code": "import java . util . * ; public class C { private static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int C = in . nextInt ( ) ; for ( int thisCase = 1 ; thisCase <= C ; thisCase ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , thisCase , largestCircle ( ) ) ; } } private static int largestCircle ( ) { int N = in . nextInt ( ) ; int bff [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { bff [ i ] = in . nextInt ( ) - 1 ; } int status [ ] = new int [ N ] ; int chainLength [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { status [ i ] = - 2 ; chainLength [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( bff [ bff [ i ] ] == i ) { status [ i ] = - 1 ; } } int maxLoopSize = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] != - 1 ) { int current = bff [ i ] ; status [ i ] = i ; int steps = 1 ; boolean done = false ; while ( ! done ) { if ( current == i ) { if ( steps > maxLoopSize ) { maxLoopSize = steps ; } done = true ; } else if ( status [ current ] == i ) { done = true ; } else if ( status [ current ] == - 1 ) { if ( steps > chainLength [ current ] ) { chainLength [ current ] = steps ; } done = true ; } else { steps ++ ; status [ current ] = i ; current = bff [ current ] ; } } } } int frankenCircle = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] == - 1 ) { frankenCircle += ( chainLength [ i ] + 1 ) ; } } return Math . max ( frankenCircle , maxLoopSize ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int C = in . nextInt ( ) ; for ( int thisCase = 1 ; thisCase <= C ; thisCase ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , thisCase , largestCircle ( ) ) ; } }"], ["largestCircle", "private static int largestCircle ( ) { int N = in . nextInt ( ) ; int bff [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { bff [ i ] = in . nextInt ( ) - 1 ; } int status [ ] = new int [ N ] ; int chainLength [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { status [ i ] = - 2 ; chainLength [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( bff [ bff [ i ] ] == i ) { status [ i ] = - 1 ; } } int maxLoopSize = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] != - 1 ) { int current = bff [ i ] ; status [ i ] = i ; int steps = 1 ; boolean done = false ; while ( ! done ) { if ( current == i ) { if ( steps > maxLoopSize ) { maxLoopSize = steps ; } done = true ; } else if ( status [ current ] == i ) { done = true ; } else if ( status [ current ] == - 1 ) { if ( steps > chainLength [ current ] ) { chainLength [ current ] = steps ; } done = true ; } else { steps ++ ; status [ current ] = i ; current = bff [ current ] ; } } } } int frankenCircle = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] == - 1 ) { frankenCircle += ( chainLength [ i ] + 1 ) ; } } return Math . max ( frankenCircle , maxLoopSize ) ; }"]], "functions_class": []}, {"id": "8", "code": "import java . io . * ; import java . util . * ; public class C { int solveOne ( Scanner in ) { int n = in . nextInt ( ) ; int f [ ] = new int [ 1 + n ] ; for ( int i = 1 ; i <= n ; i ++ ) { f [ i ] = in . nextInt ( ) ; } boolean inPair [ ] = new boolean [ 1 + n ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( f [ f [ i ] ] == i ) { inPair [ i ] = true ; } } int chainLen [ ] = new int [ 1 + n ] ; boolean used [ ] = new boolean [ 1 + n ] ; int maxCircleLen = 0 ; for ( int first = 1 ; first <= n ; first ++ ) { if ( inPair [ first ] ) { continue ; } Arrays . fill ( used , false ) ; used [ first ] = true ; int cur = first ; int len = 1 ; while ( true ) { int next = f [ cur ] ; if ( inPair [ next ] ) { chainLen [ next ] = Math . max ( chainLen [ next ] , len ) ; break ; } if ( next == first ) { maxCircleLen = Math . max ( maxCircleLen , len ) ; break ; } if ( used [ next ] ) { break ; } used [ next ] = true ; len ++ ; cur = next ; } } int joinLen = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( inPair [ i ] ) { joinLen += 1 + chainLen [ i ] ; } } return Math . max ( maxCircleLen , joinLen ) ; } void solve ( Scanner in , PrintWriter out ) { int nTests = in . nextInt ( ) ; for ( int iTest = 1 ; iTest <= nTests ; iTest ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , iTest , solveOne ( in ) ) ; } } void run ( ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; ) { solve ( in , out ) ; } } public static void main ( String args [ ] ) { new C ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { new C ( ) . run ( ) ; }"]], "functions_class": [["solveOne", "int solveOne ( Scanner in ) { int n = in . nextInt ( ) ; int f [ ] = new int [ 1 + n ] ; for ( int i = 1 ; i <= n ; i ++ ) { f [ i ] = in . nextInt ( ) ; } boolean inPair [ ] = new boolean [ 1 + n ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( f [ f [ i ] ] == i ) { inPair [ i ] = true ; } } int chainLen [ ] = new int [ 1 + n ] ; boolean used [ ] = new boolean [ 1 + n ] ; int maxCircleLen = 0 ; for ( int first = 1 ; first <= n ; first ++ ) { if ( inPair [ first ] ) { continue ; } Arrays . fill ( used , false ) ; used [ first ] = true ; int cur = first ; int len = 1 ; while ( true ) { int next = f [ cur ] ; if ( inPair [ next ] ) { chainLen [ next ] = Math . max ( chainLen [ next ] , len ) ; break ; } if ( next == first ) { maxCircleLen = Math . max ( maxCircleLen , len ) ; break ; } if ( used [ next ] ) { break ; } used [ next ] = true ; len ++ ; cur = next ; } } int joinLen = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( inPair [ i ] ) { joinLen += 1 + chainLen [ i ] ; } } return Math . max ( maxCircleLen , joinLen ) ; }"], ["solve", "void solve ( Scanner in , PrintWriter out ) { int nTests = in . nextInt ( ) ; for ( int iTest = 1 ; iTest <= nTests ; iTest ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , iTest , solveOne ( in ) ) ; } }"], ["run", "void run ( ) { try ( Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; ) { solve ( in , out ) ; } }"]]}, {"id": "13", "code": "package lab6zp ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Lab6ZP { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = Integer . parseInt ( in . next ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { boolean is = false ; int m = Integer . parseInt ( in . next ( ) ) ; int [ ] k = new int [ m ] ; int [ ] h = new int [ m ] ; int min = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { h [ j ] = 0 ; k [ j ] = Integer . parseInt ( in . next ( ) ) - 1 ; } System . out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; int fullcounter = 0 ; ArrayList < Integer > q = new ArrayList < > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { int p = j ; for ( int z = 0 ; z < m + 2 ; z ++ ) { if ( k [ k [ p ] ] == p ) { if ( z > h [ p ] || ! q . contains ( p ) ) { fullcounter -= h [ p ] ; fullcounter += z ; if ( ! q . contains ( p ) ) { q . add ( p ) ; fullcounter ++ ; } h [ p ] = z ; } if ( min < fullcounter ) { min = fullcounter ; } z = m + 1 ; continue ; } p = k [ p ] ; if ( z > 0 && p == k [ j ] ) { if ( min < z ) { min = z ; } z = m + 1 ; } } } System . out . println ( min ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = Integer . parseInt ( in . next ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { boolean is = false ; int m = Integer . parseInt ( in . next ( ) ) ; int [ ] k = new int [ m ] ; int [ ] h = new int [ m ] ; int min = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { h [ j ] = 0 ; k [ j ] = Integer . parseInt ( in . next ( ) ) - 1 ; } System . out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; int fullcounter = 0 ; ArrayList < Integer > q = new ArrayList < > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { int p = j ; for ( int z = 0 ; z < m + 2 ; z ++ ) { if ( k [ k [ p ] ] == p ) { if ( z > h [ p ] || ! q . contains ( p ) ) { fullcounter -= h [ p ] ; fullcounter += z ; if ( ! q . contains ( p ) ) { q . add ( p ) ; fullcounter ++ ; } h [ p ] = z ; } if ( min < fullcounter ) { min = fullcounter ; } z = m + 1 ; continue ; } p = k [ p ] ; if ( z > 0 && p == k [ j ] ) { if ( min < z ) { min = z ; } z = m + 1 ; } } } System . out . println ( min ) ; } }"]], "functions_class": []}, {"id": "11", "code": "package Round1A2016 ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Scanner ; public class C { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= T ; ++ testCase ) { final int n = sc . nextInt ( ) ; int [ ] bff = new int [ n ] ; boolean [ ] hasIncoming = new boolean [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { bff [ i ] = sc . nextInt ( ) - 1 ; hasIncoming [ bff [ i ] ] = true ; } int [ ] loop = new int [ n ] ; int maxPeriod = 0 ; for ( int i = 0 ; i < n ; ++ i ) { boolean [ ] visited = new boolean [ n ] ; int cur = 0 ; int [ ] index = new int [ n ] ; int j = i ; while ( ! visited [ j ] ) { visited [ j ] = true ; index [ j ] = cur ++ ; j = bff [ j ] ; } final int period = cur - index [ j ] ; for ( int k = 0 ; k < period ; ++ k ) { loop [ j ] = period ; j = bff [ j ] ; } maxPeriod = Math . max ( maxPeriod , period ) ; } int [ ] maxChain = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( hasIncoming [ i ] ) continue ; int j = i ; int chain = 0 ; while ( loop [ j ] == 0 ) { ++ chain ; j = bff [ j ] ; } maxChain [ j ] = Math . max ( maxChain [ j ] , chain ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( loop [ i ] == 2 ) { sum += 1 + maxChain [ i ] ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , testCase , Math . max ( sum , maxPeriod ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= T ; ++ testCase ) { final int n = sc . nextInt ( ) ; int [ ] bff = new int [ n ] ; boolean [ ] hasIncoming = new boolean [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { bff [ i ] = sc . nextInt ( ) - 1 ; hasIncoming [ bff [ i ] ] = true ; } int [ ] loop = new int [ n ] ; int maxPeriod = 0 ; for ( int i = 0 ; i < n ; ++ i ) { boolean [ ] visited = new boolean [ n ] ; int cur = 0 ; int [ ] index = new int [ n ] ; int j = i ; while ( ! visited [ j ] ) { visited [ j ] = true ; index [ j ] = cur ++ ; j = bff [ j ] ; } final int period = cur - index [ j ] ; for ( int k = 0 ; k < period ; ++ k ) { loop [ j ] = period ; j = bff [ j ] ; } maxPeriod = Math . max ( maxPeriod , period ) ; } int [ ] maxChain = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( hasIncoming [ i ] ) continue ; int j = i ; int chain = 0 ; while ( loop [ j ] == 0 ) { ++ chain ; j = bff [ j ] ; } maxChain [ j ] = Math . max ( maxChain [ j ] , chain ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( loop [ i ] == 2 ) { sum += 1 + maxChain [ i ] ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , testCase , Math . max ( sum , maxPeriod ) ) ; } }"]], "functions_class": []}, {"id": "7", "code": "import java . util . * ; class C { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int tcc = sc . nextInt ( ) ; for ( int tc = 1 ; tc <= tcc ; ++ tc ) { int n = sc . nextInt ( ) ; Kid [ ] kids = new Kid [ n ] ; for ( int i = 0 ; i < n ; ++ i ) kids [ i ] = new Kid ( i + 1 ) ; for ( int i = 0 ; i < n ; ++ i ) kids [ i ] . bff = kids [ sc . nextInt ( ) - 1 ] ; int maxCycle = 0 ; for ( Kid first : kids ) { Set < Kid > set = new HashSet < Kid > ( ) ; Kid k = first ; for ( ; ; ) { if ( set . contains ( k ) ) { if ( k == first ) { first . cycle = set . size ( ) ; maxCycle = Math . max ( maxCycle , first . cycle ) ; } break ; } set . add ( k ) ; k = k . bff ; } } for ( Kid first : kids ) { Set < Kid > set = new HashSet < Kid > ( ) ; Kid k = first ; for ( ; ; ) { if ( set . contains ( k ) ) { if ( k . cycle == 2 ) { k . brings = Math . max ( k . brings , set . size ( ) - 1 ) ; } break ; } set . add ( k ) ; k = k . bff ; } } int brings = 0 ; for ( Kid k : kids ) if ( k . cycle == 2 ) brings += k . brings ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , tc , Math . max ( maxCycle , brings ) ) ; } } } class Kid { public Kid bff ; public int index ; public int cycle = 0 ; public int brings = 0 ; public Kid ( int index ) { this . index = index ; } public String toString ( ) { return this . index + \" ( \" + this . cycle + \" , \" + this . brings + \" ) \" ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int tcc = sc . nextInt ( ) ; for ( int tc = 1 ; tc <= tcc ; ++ tc ) { int n = sc . nextInt ( ) ; Kid [ ] kids = new Kid [ n ] ; for ( int i = 0 ; i < n ; ++ i ) kids [ i ] = new Kid ( i + 1 ) ; for ( int i = 0 ; i < n ; ++ i ) kids [ i ] . bff = kids [ sc . nextInt ( ) - 1 ] ; int maxCycle = 0 ; for ( Kid first : kids ) { Set < Kid > set = new HashSet < Kid > ( ) ; Kid k = first ; for ( ; ; ) { if ( set . contains ( k ) ) { if ( k == first ) { first . cycle = set . size ( ) ; maxCycle = Math . max ( maxCycle , first . cycle ) ; } break ; } set . add ( k ) ; k = k . bff ; } } for ( Kid first : kids ) { Set < Kid > set = new HashSet < Kid > ( ) ; Kid k = first ; for ( ; ; ) { if ( set . contains ( k ) ) { if ( k . cycle == 2 ) { k . brings = Math . max ( k . brings , set . size ( ) - 1 ) ; } break ; } set . add ( k ) ; k = k . bff ; } } int brings = 0 ; for ( Kid k : kids ) if ( k . cycle == 2 ) brings += k . brings ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , tc , Math . max ( maxCycle , brings ) ) ; } }"]], "functions_class": [["Kid", "public Kid ( int index ) { this . index = index ; }"], ["toString", "public String toString ( ) { return this . index + \" ( \" + this . cycle + \" , \" + this . brings + \" ) \" ; }"]]}], "python": [{"id": "14", "code": "def find_longest ( node ) : NEW_LINE INDENT global visited NEW_LINE visited [ node ] = True NEW_LINE if node not in graph : NEW_LINE INDENT return 1 NEW_LINE DEDENT max_child = 0 NEW_LINE for i in graph [ node ] : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT max_child = max ( max_child , find_longest ( i ) ) NEW_LINE DEDENT return max_child + 1 NEW_LINE DEDENT def dfs ( node ) : NEW_LINE INDENT vis = [ 0 for i in range ( len ( FF ) ) ] NEW_LINE vis [ node ] = 1 NEW_LINE size = 1 NEW_LINE tmp = node NEW_LINE while True : NEW_LINE INDENT tmp = FF [ tmp ] NEW_LINE if tmp == node : NEW_LINE INDENT return size NEW_LINE DEDENT if vis [ tmp ] == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT vis [ tmp ] = 1 NEW_LINE size += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT visited = [ ] NEW_LINE graph = { } NEW_LINE Q = int ( input ( ) ) NEW_LINE for q in range ( Q ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE FF = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE FF . insert ( 0 , - 1 ) NEW_LINE graph = { } NEW_LINE visited = [ False for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , len ( FF ) ) : NEW_LINE INDENT if FF [ i ] not in graph : NEW_LINE INDENT graph [ FF [ i ] ] = [ ] NEW_LINE DEDENT graph [ FF [ i ] ] . append ( i ) NEW_LINE DEDENT double = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i == FF [ FF [ i ] ] and not visited [ i ] : NEW_LINE INDENT visited [ i ] = True NEW_LINE visited [ FF [ i ] ] = True NEW_LINE dou = find_longest ( i ) + find_longest ( FF [ i ] ) NEW_LINE double += dou NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT double = max ( double , dfs ( i ) ) NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( q + 1 , double ) ) NEW_LINE DEDENT", "functions_standalone": [["find_longest", "def find_longest ( node ) : NEW_LINE INDENT global visited NEW_LINE visited [ node ] = True NEW_LINE if node not in graph : NEW_LINE INDENT return 1 NEW_LINE DEDENT max_child = 0 NEW_LINE for i in graph [ node ] : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT max_child = max ( max_child , find_longest ( i ) ) NEW_LINE DEDENT return max_child + 1 NEW_LINE DEDENT"], ["dfs", "def dfs ( node ) : NEW_LINE INDENT vis = [ 0 for i in range ( len ( FF ) ) ] NEW_LINE vis [ node ] = 1 NEW_LINE size = 1 NEW_LINE tmp = node NEW_LINE while True : NEW_LINE INDENT tmp = FF [ tmp ] NEW_LINE if tmp == node : NEW_LINE INDENT return size NEW_LINE DEDENT if vis [ tmp ] == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT vis [ tmp ] = 1 NEW_LINE size += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "import sys NEW_LINE sys . stdin = open ( \" data . txt \" ) NEW_LINE sys . stdout = open ( \" out . txt \" , \" w \" ) NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE g = [ ] NEW_LINE friend = [ ] NEW_LINE def dfs ( u , n ) : NEW_LINE INDENT v = u NEW_LINE for i in range ( 1 , n + 2 ) : NEW_LINE INDENT v = friend [ v ] NEW_LINE if u == v : return i NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def depth ( u , bad ) : NEW_LINE INDENT out = 0 NEW_LINE for v in g [ u ] : NEW_LINE INDENT if v != bad : NEW_LINE INDENT out = max ( out , depth ( v , bad ) ) NEW_LINE DEDENT DEDENT return out + 1 NEW_LINE DEDENT def getpairs ( ) : NEW_LINE INDENT out = 0 NEW_LINE for i in range ( len ( g ) ) : NEW_LINE INDENT if friend [ friend [ i ] ] == i : NEW_LINE INDENT out += depth ( i , friend [ i ] ) + depth ( friend [ i ] , i ) NEW_LINE DEDENT DEDENT return out // 2 NEW_LINE DEDENT for c in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE friend = list ( map ( lambda s : int ( s ) - 1 , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE g = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT g [ friend [ i ] ] . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dfs ( i , n ) ) NEW_LINE DEDENT ans = max ( ans , getpairs ( ) ) NEW_LINE print ( \" Case \u2581 # % s : \u2581 % s \" % ( c + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [["dfs", "def dfs ( u , n ) : NEW_LINE INDENT v = u NEW_LINE for i in range ( 1 , n + 2 ) : NEW_LINE INDENT v = friend [ v ] NEW_LINE if u == v : return i NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT"], ["depth", "def depth ( u , bad ) : NEW_LINE INDENT out = 0 NEW_LINE for v in g [ u ] : NEW_LINE INDENT if v != bad : NEW_LINE INDENT out = max ( out , depth ( v , bad ) ) NEW_LINE DEDENT DEDENT return out + 1 NEW_LINE DEDENT"], ["getpairs", "def getpairs ( ) : NEW_LINE INDENT out = 0 NEW_LINE for i in range ( len ( g ) ) : NEW_LINE INDENT if friend [ friend [ i ] ] == i : NEW_LINE INDENT out += depth ( i , friend [ i ] ) + depth ( friend [ i ] , i ) NEW_LINE DEDENT DEDENT return out // 2 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "task = ' C ' NEW_LINE type = 2 NEW_LINE if type == 0 : NEW_LINE INDENT inp = open ( ' sample . in ' , ' r ' ) NEW_LINE DEDENT elif type == 1 : NEW_LINE INDENT inp = open ( ' % s - small . in ' % ( task , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT inp = open ( ' % s - large . in ' % ( task ) , ) NEW_LINE DEDENT outp = open ( ' % s . out ' % ( task , ) , ' w ' ) NEW_LINE T = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE edges = [ - 1 for i in range ( N ) ] NEW_LINE revedges = [ list ( ) for i in range ( N ) ] NEW_LINE st = inp . readline ( ) [ : - 1 ] . split ( ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT anses = [ 0 ] NEW_LINE for v2 in revedges [ v ] : NEW_LINE INDENT anses . append ( dfs ( v2 ) + 1 ) NEW_LINE DEDENT return max ( anses ) NEW_LINE DEDENT for j , a in zip ( range ( N ) , st ) : NEW_LINE INDENT a = int ( a ) - 1 NEW_LINE edges [ j ] = a NEW_LINE revedges [ a ] . append ( j ) NEW_LINE DEDENT pairs = set ( ) NEW_LINE loncyc = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT used = [ - 1 for i in range ( N ) ] NEW_LINE cur = i NEW_LINE curs = 0 NEW_LINE while used [ cur ] == - 1 : NEW_LINE INDENT used [ cur ] = curs NEW_LINE curs += 1 NEW_LINE cur = edges [ cur ] NEW_LINE DEDENT if curs - used [ cur ] == 2 : NEW_LINE INDENT pairs . add ( cur ) NEW_LINE DEDENT loncyc = max ( loncyc , curs - used [ cur ] ) NEW_LINE DEDENT pairtokens_sum = 0 NEW_LINE while len ( pairs ) > 0 : NEW_LINE INDENT cur1 = pairs . pop ( ) NEW_LINE cur2 = edges [ cur1 ] NEW_LINE revedges [ cur1 ] . remove ( cur2 ) NEW_LINE revedges [ cur2 ] . remove ( cur1 ) NEW_LINE pairs . remove ( cur2 ) NEW_LINE curs = 2 + dfs ( cur1 ) + dfs ( cur2 ) NEW_LINE pairtokens_sum += curs NEW_LINE DEDENT ans = max ( pairtokens_sum , loncyc ) NEW_LINE outp . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( t + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [["dfs", "def dfs ( v ) : NEW_LINE INDENT anses = [ 0 ] NEW_LINE for v2 in revedges [ v ] : NEW_LINE INDENT anses . append ( dfs ( v2 ) + 1 ) NEW_LINE DEDENT return max ( anses ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "def longestdfs ( inedges , start , seen ) : NEW_LINE INDENT seen . add ( start ) NEW_LINE if not inedges [ start ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT candidates = [ ] NEW_LINE for inedge in inedges [ start ] : NEW_LINE INDENT candidates . append ( longestdfs ( inedges , inedge , seen ) ) NEW_LINE DEDENT return max ( candidates ) + 1 NEW_LINE DEDENT cases = int ( input ( ) ) NEW_LINE for case in range ( cases ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE toedges = [ int ( x ) - 1 for x in input ( ) . split ( ) ] NEW_LINE inedges = [ [ ] for x in toedges ] NEW_LINE for i , to in enumerate ( toedges ) : NEW_LINE INDENT inedges [ to ] . append ( i ) NEW_LINE DEDENT mutuals = [ ] NEW_LINE for i , to in enumerate ( toedges ) : NEW_LINE INDENT if toedges [ to ] == i and to > i : NEW_LINE INDENT mutuals . append ( ( to , i ) ) NEW_LINE inedges [ to ] . remove ( i ) NEW_LINE inedges [ i ] . remove ( to ) NEW_LINE DEDENT DEDENT mdepths = [ ] NEW_LINE seen = set ( ) NEW_LINE for a , b in mutuals : NEW_LINE INDENT mdepths . append ( longestdfs ( inedges , a , seen ) + longestdfs ( inedges , b , seen ) ) NEW_LINE DEDENT cyclemax = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . add ( i ) NEW_LINE length = 1 NEW_LINE tempi = toedges [ i ] NEW_LINE path = [ i , tempi ] NEW_LINE while tempi != i : NEW_LINE INDENT if tempi in seen : NEW_LINE INDENT length -= path . index ( tempi ) NEW_LINE break NEW_LINE DEDENT seen . add ( tempi ) NEW_LINE length += 1 NEW_LINE tempi = toedges [ tempi ] NEW_LINE path . append ( tempi ) NEW_LINE DEDENT cyclemax = max ( length , cyclemax ) NEW_LINE DEDENT ans = max ( sum ( mdepths ) , cyclemax ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [["longestdfs", "def longestdfs ( inedges , start , seen ) : NEW_LINE INDENT seen . add ( start ) NEW_LINE if not inedges [ start ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT candidates = [ ] NEW_LINE for inedge in inedges [ start ] : NEW_LINE INDENT candidates . append ( longestdfs ( inedges , inedge , seen ) ) NEW_LINE DEDENT return max ( candidates ) + 1 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE fin = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fout = open ( \" p3 . out \" , \" w \" ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for tt in xrange ( T ) : NEW_LINE INDENT N = int ( fin . readline ( ) ) NEW_LINE out = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE out = map ( lambda x : x - 1 , out ) NEW_LINE ans = 0 NEW_LINE best = [ 0 for j in xrange ( N ) ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT cur = i NEW_LINE vis = [ 0 for j in xrange ( N ) ] NEW_LINE vis [ cur ] = 1 NEW_LINE while vis [ out [ cur ] ] == 0 : NEW_LINE INDENT vis [ out [ cur ] ] = 1 NEW_LINE cur = out [ cur ] NEW_LINE DEDENT if out [ cur ] == i : NEW_LINE INDENT ans = max ( ans , sum ( vis ) ) NEW_LINE DEDENT if out [ out [ cur ] ] == cur : NEW_LINE INDENT best [ cur ] = max ( best [ cur ] , sum ( vis ) ) NEW_LINE DEDENT DEDENT tot = 0 NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT if out [ out [ i ] ] == i : NEW_LINE INDENT tot += best [ i ] + best [ out [ i ] ] - 2 NEW_LINE DEDENT DEDENT tot /= 2 NEW_LINE ans = max ( ans , tot ) NEW_LINE fout . write ( \" Case \u2581 # \" + str ( tt + 1 ) + \" : \u2581 \" + str ( ans ) + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_17_03", "java": [{"id": "19", "code": "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . util . Scanner ; public class c { public static void main ( String [ ] Args ) throws Exception { Scanner sc = new Scanner ( new File ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" c . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long n = sc . nextLong ( ) ; long pos = sc . nextLong ( ) ; int dep = 0 ; long v = 0 ; while ( pos > ( ( v << 1 ) | 1 ) ) { v = ( ( v << 1 ) | 1 ) ; dep ++ ; } n -= v ; pos -= v + 1 ; v ++ ; if ( n % v > pos ) n = n / v + 1 ; else n = n / v ; out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d % n \" , ++ cc , n >> 1 , ( n - 1 ) >> 1 ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] Args ) throws Exception { Scanner sc = new Scanner ( new File ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" c . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long n = sc . nextLong ( ) ; long pos = sc . nextLong ( ) ; int dep = 0 ; long v = 0 ; while ( pos > ( ( v << 1 ) | 1 ) ) { v = ( ( v << 1 ) | 1 ) ; dep ++ ; } n -= v ; pos -= v + 1 ; v ++ ; if ( n % v > pos ) n = n / v + 1 ; else n = n / v ; out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d % n \" , ++ cc , n >> 1 , ( n - 1 ) >> 1 ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "3", "code": "import java . math . BigInteger ; import java . util . * ; import java . io . * ; public class Main { private static BigInteger solve ( BigInteger n , BigInteger m ) { if ( m . equals ( BigInteger . ONE ) ) return n ; n = n . subtract ( BigInteger . ONE ) ; m = m . subtract ( BigInteger . ONE ) ; BigInteger x , y , sumX , sumY ; y = n . shiftRight ( 1 ) ; x = n . subtract ( y ) ; sumX = sumY = BigInteger . ONE ; for ( ; m . compareTo ( sumX . add ( sumY ) ) > 0 ; ) { m = m . subtract ( sumX . add ( sumY ) ) ; x = x . subtract ( BigInteger . ONE ) ; y = y . subtract ( BigInteger . ONE ) ; BigInteger tx , ty , tSumX = sumX , tSumY = sumY ; tx = x . shiftRight ( 1 ) ; x = x . subtract ( tx ) ; ty = y . subtract ( y . shiftRight ( 1 ) ) ; y = y . shiftRight ( 1 ) ; if ( tx . equals ( x ) ) { sumX = sumX . add ( tSumX ) ; } else { sumY = sumY . add ( tSumX ) ; } if ( ty . equals ( x ) ) { sumX = sumX . add ( tSumY ) ; } else { sumY = sumY . add ( tSumY ) ; } } return m . compareTo ( sumX ) <= 0 ? x : y ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int t = in . nextInt ( ) ; for ( int i = 1 ; i <= t ; ++ i ) { BigInteger n = in . nextBigInteger ( ) ; BigInteger m = in . nextBigInteger ( ) ; BigInteger sum = solve ( n , m ) ; sum = sum . subtract ( BigInteger . ONE ) ; BigInteger div = sum . shiftRight ( 1 ) ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + sum . subtract ( div ) + \" \u2581 \" + div ) ; } } }", "functions_standalone": [["solve", "private static BigInteger solve ( BigInteger n , BigInteger m ) { if ( m . equals ( BigInteger . ONE ) ) return n ; n = n . subtract ( BigInteger . ONE ) ; m = m . subtract ( BigInteger . ONE ) ; BigInteger x , y , sumX , sumY ; y = n . shiftRight ( 1 ) ; x = n . subtract ( y ) ; sumX = sumY = BigInteger . ONE ; for ( ; m . compareTo ( sumX . add ( sumY ) ) > 0 ; ) { m = m . subtract ( sumX . add ( sumY ) ) ; x = x . subtract ( BigInteger . ONE ) ; y = y . subtract ( BigInteger . ONE ) ; BigInteger tx , ty , tSumX = sumX , tSumY = sumY ; tx = x . shiftRight ( 1 ) ; x = x . subtract ( tx ) ; ty = y . subtract ( y . shiftRight ( 1 ) ) ; y = y . shiftRight ( 1 ) ; if ( tx . equals ( x ) ) { sumX = sumX . add ( tSumX ) ; } else { sumY = sumY . add ( tSumX ) ; } if ( ty . equals ( x ) ) { sumX = sumX . add ( tSumY ) ; } else { sumY = sumY . add ( tSumY ) ; } } return m . compareTo ( sumX ) <= 0 ? x : y ; }"], ["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int t = in . nextInt ( ) ; for ( int i = 1 ; i <= t ; ++ i ) { BigInteger n = in . nextBigInteger ( ) ; BigInteger m = in . nextBigInteger ( ) ; BigInteger sum = solve ( n , m ) ; sum = sum . subtract ( BigInteger . ONE ) ; BigInteger div = sum . shiftRight ( 1 ) ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + sum . subtract ( div ) + \" \u2581 \" + div ) ; } }"]], "functions_class": []}, {"id": "18", "code": "package zhang00000 ; import com . sun . tools . javac . jvm . Code ; import org . apache . commons . math3 . complex . Complex ; import java . io . * ; import java . util . * ; import java . util . stream . * ; import static java . util . stream . Collectors . * ; public class App { final int di [ ] = { 1 , - 1 , 0 , 0 , 1 , - 1 , 1 , - 1 } ; final int dj [ ] = { 0 , 0 , 1 , - 1 , 1 , - 1 , - 1 , 1 } ; final int diK [ ] = { - 2 , - 2 , - 1 , 1 , 2 , 2 , 1 , - 1 } ; final int djK [ ] = { - 1 , 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 } ; public static void main ( String [ ] args ) { if ( args . length == 1 ) { String filename = \" src / main / java / zhang00000 / \" + args [ 0 ] + \" . in \" ; if ( ! filename . isEmpty ( ) ) try { System . setIn ( new FileInputStream ( filename ) ) ; } catch ( FileNotFoundException e ) { System . out . println ( e . getMessage ( ) ) ; System . exit ( 1 ) ; } } Scanner in = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int t = Integer . valueOf ( in . nextLine ( ) ) ; for ( int number = 1 ; number <= t ; number ++ ) { long n = in . nextLong ( ) ; long k = in . nextLong ( ) ; int d = Long . toBinaryString ( k ) . length ( ) - 1 ; long prev = ( n - k + Long . highestOneBit ( k ) ) >> d ; long max = prev / 2 ; long min = ( prev - 1 ) / 2 ; System . out . println ( \" Case \u2581 # \" + number + \" : \u2581 \" + max + \" \u2581 \" + min ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { if ( args . length == 1 ) { String filename = \" src / main / java / zhang00000 / \" + args [ 0 ] + \" . in \" ; if ( ! filename . isEmpty ( ) ) try { System . setIn ( new FileInputStream ( filename ) ) ; } catch ( FileNotFoundException e ) { System . out . println ( e . getMessage ( ) ) ; System . exit ( 1 ) ; } } Scanner in = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int t = Integer . valueOf ( in . nextLine ( ) ) ; for ( int number = 1 ; number <= t ; number ++ ) { long n = in . nextLong ( ) ; long k = in . nextLong ( ) ; int d = Long . toBinaryString ( k ) . length ( ) - 1 ; long prev = ( n - k + Long . highestOneBit ( k ) ) >> d ; long max = prev / 2 ; long min = ( prev - 1 ) / 2 ; System . out . println ( \" Case \u2581 # \" + number + \" : \u2581 \" + max + \" \u2581 \" + min ) ; } }"]], "functions_class": []}, {"id": "4", "code": "import java . util . * ; import java . io . * ; public class Main { public static long [ ] solve ( long N , long K ) { if ( K == 1 ) { long [ ] arr = new long [ 2 ] ; arr [ 0 ] = N / 2 ; arr [ 1 ] = ( N - 1 ) / 2 ; return arr ; } if ( K % 2 == 0 ) { return solve ( N / 2 , K / 2 ) ; } return solve ( ( N - 1 ) / 2 , K / 2 ) ; } public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" solve . txt \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; StringTokenizer s ; for ( int i = 1 ; i <= T ; i ++ ) { bw . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; long N = Long . parseLong ( s . nextToken ( ) ) ; long K = Long . parseLong ( s . nextToken ( ) ) ; long [ ] arr = solve ( N , K ) ; bw . write ( arr [ 0 ] + \" \u2581 \" + arr [ 1 ] + \" \\n \" ) ; } br . close ( ) ; bw . close ( ) ; return ; } }", "functions_standalone": [["solve", "public static long [ ] solve ( long N , long K ) { if ( K == 1 ) { long [ ] arr = new long [ 2 ] ; arr [ 0 ] = N / 2 ; arr [ 1 ] = ( N - 1 ) / 2 ; return arr ; } if ( K % 2 == 0 ) { return solve ( N / 2 , K / 2 ) ; } return solve ( ( N - 1 ) / 2 , K / 2 ) ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" solve . txt \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; StringTokenizer s ; for ( int i = 1 ; i <= T ; i ++ ) { bw . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; long N = Long . parseLong ( s . nextToken ( ) ) ; long K = Long . parseLong ( s . nextToken ( ) ) ; long [ ] arr = solve ( N , K ) ; bw . write ( arr [ 0 ] + \" \u2581 \" + arr [ 1 ] + \" \\n \" ) ; } br . close ( ) ; bw . close ( ) ; return ; }"]], "functions_class": []}, {"id": "1", "code": "import java . util . Map ; import java . util . Scanner ; import java . util . TreeMap ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int testCount = in . nextInt ( ) ; for ( int testNo = 1 ; testNo <= testCount ; testNo ++ ) { solve ( testNo , in ) ; } } private static void solve ( int testNo , Scanner in ) { long n = in . nextLong ( ) ; long k = in . nextLong ( ) ; System . out . println ( \" Case \u2581 # \" + testNo + \" : \u2581 \" + calc ( n , k ) ) ; } private static String calc ( long n , long k ) { TreeMap < Long , Long > treeMap = new TreeMap < > ( ) ; treeMap . put ( n , 1L ) ; while ( k > 0 ) { Map . Entry < Long , Long > entry = treeMap . lastEntry ( ) ; treeMap . remove ( entry . getKey ( ) ) ; if ( k <= entry . getValue ( ) ) { return entry . getKey ( ) / 2 + \" \u2581 \" + ( entry . getKey ( ) - 1 ) / 2 ; } else { k -= entry . getValue ( ) ; if ( entry . getKey ( ) / 2 > 0 ) { long key = entry . getKey ( ) / 2 ; treeMap . put ( key , treeMap . getOrDefault ( key , 0L ) + entry . getValue ( ) ) ; } if ( ( entry . getKey ( ) - 1 ) / 2 > 0 ) { long key = ( entry . getKey ( ) - 1 ) / 2 ; treeMap . put ( key , treeMap . getOrDefault ( key , 0L ) + entry . getValue ( ) ) ; } } } throw new RuntimeException ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int testCount = in . nextInt ( ) ; for ( int testNo = 1 ; testNo <= testCount ; testNo ++ ) { solve ( testNo , in ) ; } }"], ["solve", "private static void solve ( int testNo , Scanner in ) { long n = in . nextLong ( ) ; long k = in . nextLong ( ) ; System . out . println ( \" Case \u2581 # \" + testNo + \" : \u2581 \" + calc ( n , k ) ) ; }"], ["calc", "private static String calc ( long n , long k ) { TreeMap < Long , Long > treeMap = new TreeMap < > ( ) ; treeMap . put ( n , 1L ) ; while ( k > 0 ) { Map . Entry < Long , Long > entry = treeMap . lastEntry ( ) ; treeMap . remove ( entry . getKey ( ) ) ; if ( k <= entry . getValue ( ) ) { return entry . getKey ( ) / 2 + \" \u2581 \" + ( entry . getKey ( ) - 1 ) / 2 ; } else { k -= entry . getValue ( ) ; if ( entry . getKey ( ) / 2 > 0 ) { long key = entry . getKey ( ) / 2 ; treeMap . put ( key , treeMap . getOrDefault ( key , 0L ) + entry . getValue ( ) ) ; } if ( ( entry . getKey ( ) - 1 ) / 2 > 0 ) { long key = ( entry . getKey ( ) - 1 ) / 2 ; treeMap . put ( key , treeMap . getOrDefault ( key , 0L ) + entry . getValue ( ) ) ; } } } throw new RuntimeException ( ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "infilecode = \" CLI \" NEW_LINE import sys NEW_LINE mapping = { \" A \" : \" A \" , \" B \" : \" B \" , \" C \" : \" C \" , \" D \" : \" D \" , \" E \" : \" E \" , \" X \" : \" example \" , \" S \" : \" - small \" , \" L \" : \" - large \" , \" P \" : \" - practice \" , \"0\" : \" - attempt0\" , \"1\" : \" - attempt1\" , \"2\" : \" - attempt2\" , \" z \" : \" - 1\" , \" Z \" : \" - 2\" , \" I \" : \" . in \" , \" T \" : \" . txt \" } NEW_LINE infile = \" \" . join ( mapping [ c ] for c in infilecode ) NEW_LINE outfile = infile . replace ( \" . in \" , \" \" ) + \" . out . txt \" NEW_LINE sys . stdin = open ( infile , ' r ' ) NEW_LINE output = open ( outfile , ' w ' ) NEW_LINE T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N , K ) NEW_LINE sizes = [ N , N + 1 ] NEW_LINE num = [ 1 , 0 ] NEW_LINE while K > sum ( num ) : NEW_LINE INDENT a , b = sizes NEW_LINE K -= sum ( num ) NEW_LINE sizes = [ ( a - 1 ) // 2 , b // 2 ] NEW_LINE if a % 2 == 0 : NEW_LINE INDENT num = [ num [ 0 ] , num [ 0 ] + num [ 1 ] * 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT num = [ num [ 0 ] * 2 + num [ 1 ] , num [ 1 ] ] NEW_LINE DEDENT print ( sizes , num , K ) NEW_LINE DEDENT if K <= num [ 1 ] : NEW_LINE INDENT size = sizes [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT size = sizes [ 0 ] NEW_LINE DEDENT R = size // 2 NEW_LINE L = ( size - 1 ) // 2 NEW_LINE answer = str ( R ) + \" \u2581 \" + str ( L ) NEW_LINE print ( \" Case \u2581 # % d : \" % case , answer ) NEW_LINE print ( \" Case \u2581 # % d : \" % case , answer , file = output ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "def split ( n ) : NEW_LINE INDENT return n // 2 , ( n - 1 ) // 2 NEW_LINE DEDENT def merge ( a , n1 , n2 , b , m1 , m2 ) : NEW_LINE INDENT if n1 == m1 : NEW_LINE INDENT return a + a + b , n1 , b , m2 NEW_LINE DEDENT elif n2 == m2 : NEW_LINE INDENT return a , n1 , a + b + b , m2 NEW_LINE DEDENT else : NEW_LINE INDENT raise Exception ( \" Can ' t \u2581 reduce \u2581 { } \" . format ( ( n1 , n2 , m1 , m2 ) ) ) NEW_LINE DEDENT DEDENT def solve ( a , n , b , m , k ) : NEW_LINE INDENT if k <= a : NEW_LINE INDENT return split ( n ) NEW_LINE DEDENT elif k <= a + b : NEW_LINE INDENT return split ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT def t ( * args ) : NEW_LINE INDENT return tuple ( args ) NEW_LINE DEDENT return solve ( * ( merge ( * ( t ( a ) + split ( n ) + t ( b ) + split ( m ) ) ) + t ( k - a - b ) ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for ti in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( ti + 1 , ' \u2581 ' . join ( map ( str , sorted ( solve ( 1 , n , 0 , n - 1 , k ) , reverse = True ) ) ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["split", "def split ( n ) : NEW_LINE INDENT return n // 2 , ( n - 1 ) // 2 NEW_LINE DEDENT"], ["merge", "def merge ( a , n1 , n2 , b , m1 , m2 ) : NEW_LINE INDENT if n1 == m1 : NEW_LINE INDENT return a + a + b , n1 , b , m2 NEW_LINE DEDENT elif n2 == m2 : NEW_LINE INDENT return a , n1 , a + b + b , m2 NEW_LINE DEDENT else : NEW_LINE INDENT raise Exception ( \" Can ' t \u2581 reduce \u2581 { } \" . format ( ( n1 , n2 , m1 , m2 ) ) ) NEW_LINE DEDENT DEDENT"], ["solve", "def solve ( a , n , b , m , k ) : NEW_LINE INDENT if k <= a : NEW_LINE INDENT return split ( n ) NEW_LINE DEDENT elif k <= a + b : NEW_LINE INDENT return split ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT def t ( * args ) : NEW_LINE INDENT return tuple ( args ) NEW_LINE DEDENT return solve ( * ( merge ( * ( t ( a ) + split ( n ) + t ( b ) + split ( m ) ) ) + t ( k - a - b ) ) ) NEW_LINE DEDENT DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for ti in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( ti + 1 , ' \u2581 ' . join ( map ( str , sorted ( solve ( 1 , n , 0 , n - 1 , k ) , reverse = True ) ) ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "17", "code": "import sys NEW_LINE import numpy as np NEW_LINE import heapq NEW_LINE def solve ( n , k ) : NEW_LINE INDENT intervals = { n : 1 } NEW_LINE lens = [ - n ] NEW_LINE ls = 0 NEW_LINE rs = 0 NEW_LINE while k > 0 : NEW_LINE INDENT val = - heapq . heappop ( lens ) NEW_LINE num = intervals [ val ] NEW_LINE del intervals [ val ] NEW_LINE k = k - num NEW_LINE ls = int ( ( val - 1 ) / 2 ) NEW_LINE rs = val - ls - 1 NEW_LINE if not ls in intervals : NEW_LINE INDENT intervals [ ls ] = 0 NEW_LINE heapq . heappush ( lens , - ls ) NEW_LINE DEDENT if not rs in intervals : NEW_LINE INDENT intervals [ rs ] = 0 NEW_LINE heapq . heappush ( lens , - rs ) NEW_LINE DEDENT intervals [ rs ] = intervals [ rs ] + num NEW_LINE intervals [ ls ] = intervals [ ls ] + num NEW_LINE DEDENT return ( max ( ls , rs ) , min ( ls , rs ) ) NEW_LINE DEDENT t = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT n , m = [ s for s in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE data = [ int ( a ) for a in list ( str ( n ) ) ] NEW_LINE result = solve ( int ( n ) , int ( m ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \u2581 { } \" . format ( i , result [ 0 ] , result [ 1 ] ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( n , k ) : NEW_LINE INDENT intervals = { n : 1 } NEW_LINE lens = [ - n ] NEW_LINE ls = 0 NEW_LINE rs = 0 NEW_LINE while k > 0 : NEW_LINE INDENT val = - heapq . heappop ( lens ) NEW_LINE num = intervals [ val ] NEW_LINE del intervals [ val ] NEW_LINE k = k - num NEW_LINE ls = int ( ( val - 1 ) / 2 ) NEW_LINE rs = val - ls - 1 NEW_LINE if not ls in intervals : NEW_LINE INDENT intervals [ ls ] = 0 NEW_LINE heapq . heappush ( lens , - ls ) NEW_LINE DEDENT if not rs in intervals : NEW_LINE INDENT intervals [ rs ] = 0 NEW_LINE heapq . heappush ( lens , - rs ) NEW_LINE DEDENT intervals [ rs ] = intervals [ rs ] + num NEW_LINE intervals [ ls ] = intervals [ ls ] + num NEW_LINE DEDENT return ( max ( ls , rs ) , min ( ls , rs ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "3", "code": "from __future__ import print_function NEW_LINE import sys NEW_LINE from sys import stdin NEW_LINE def eprint ( * args , ** kwargs ) : NEW_LINE INDENT print ( * args , file = sys . stderr , ** kwargs ) NEW_LINE DEDENT def ln ( f = int ) : NEW_LINE INDENT return list ( map ( f , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT T , = ln ( ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE for test in range ( T ) : NEW_LINE INDENT N , K = ln ( ) NEW_LINE xs = [ ( N , 1 ) ] NEW_LINE h = { } NEW_LINE h [ N ] = 1 NEW_LINE while True : NEW_LINE INDENT n , q = max ( h . items ( ) ) NEW_LINE a = n // 2 NEW_LINE b = n - a - 1 NEW_LINE del h [ n ] NEW_LINE if not a in h : NEW_LINE INDENT h [ a ] = 0 NEW_LINE DEDENT if not b in h : NEW_LINE INDENT h [ b ] = 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT h [ a ] += 2 * q NEW_LINE DEDENT else : NEW_LINE INDENT h [ a ] += q NEW_LINE h [ b ] += q NEW_LINE DEDENT if K <= q : NEW_LINE INDENT res_mx = max ( a , b ) NEW_LINE res_mn = min ( a , b ) NEW_LINE break NEW_LINE DEDENT K -= q NEW_LINE DEDENT print ( \" Case \u2581 # \" + str ( test + 1 ) + \" : \u2581 \" + str ( res_mx ) + \" \u2581 \" + str ( res_mn ) ) NEW_LINE DEDENT", "functions_standalone": [["eprint", "def eprint ( * args , ** kwargs ) : NEW_LINE INDENT print ( * args , file = sys . stderr , ** kwargs ) NEW_LINE DEDENT"], ["ln", "def ln ( f = int ) : NEW_LINE INDENT return list ( map ( f , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "from itertools import groupby NEW_LINE def solve ( ) : NEW_LINE INDENT n , k = [ int ( w ) for w in input ( ) . split ( ) ] NEW_LINE a = [ ( n , 1 ) ] NEW_LINE while True : NEW_LINE INDENT b = [ ] NEW_LINE for d , cnt in a : NEW_LINE INDENT if cnt < k : NEW_LINE INDENT k -= cnt NEW_LINE b . append ( ( ( d - 1 ) // 2 , cnt ) ) NEW_LINE b . append ( ( d // 2 , cnt ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return \" { } \u2581 { } \" . format ( d // 2 , ( d - 1 ) // 2 ) NEW_LINE DEDENT DEDENT a = [ ( f , sum ( s for _ , s in g ) ) for f , g in groupby ( sorted ( b ) , key = lambda t : t [ 0 ] ) ] NEW_LINE a = list ( reversed ( [ x for x in a if x [ 0 ] > 0 ] ) ) NEW_LINE DEDENT DEDENT def prepare_input ( ) : NEW_LINE INDENT local = False NEW_LINE task = ' C ' NEW_LINE attempt = - 1 NEW_LINE import sys NEW_LINE if local : NEW_LINE INDENT sys . stdin = open ( \" . . / input . txt \" , \" r \" ) NEW_LINE DEDENT else : NEW_LINE INDENT filename = \" . . / { } - small - 2 - attempt { } \" . format ( task , attempt ) if attempt >= 0 else \" . . / { } - large \" . format ( task ) NEW_LINE sys . stdin = open ( filename + \" . in \" , \" r \" ) NEW_LINE sys . stdout = open ( filename + \" . out \" , \" w \" ) NEW_LINE print ( \" filename : \" , filename [ 3 : ] , file = sys . stderr ) NEW_LINE DEDENT DEDENT prepare_input ( ) NEW_LINE tests = int ( input ( ) ) NEW_LINE for test in range ( 1 , tests + 1 ) : NEW_LINE INDENT res = solve ( ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( test , res ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT n , k = [ int ( w ) for w in input ( ) . split ( ) ] NEW_LINE a = [ ( n , 1 ) ] NEW_LINE while True : NEW_LINE INDENT b = [ ] NEW_LINE for d , cnt in a : NEW_LINE INDENT if cnt < k : NEW_LINE INDENT k -= cnt NEW_LINE b . append ( ( ( d - 1 ) // 2 , cnt ) ) NEW_LINE b . append ( ( d // 2 , cnt ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return \" { } \u2581 { } \" . format ( d // 2 , ( d - 1 ) // 2 ) NEW_LINE DEDENT DEDENT a = [ ( f , sum ( s for _ , s in g ) ) for f , g in groupby ( sorted ( b ) , key = lambda t : t [ 0 ] ) ] NEW_LINE a = list ( reversed ( [ x for x in a if x [ 0 ] > 0 ] ) ) NEW_LINE DEDENT DEDENT"], ["prepare_input", "def prepare_input ( ) : NEW_LINE INDENT local = False NEW_LINE task = ' C ' NEW_LINE attempt = - 1 NEW_LINE import sys NEW_LINE if local : NEW_LINE INDENT sys . stdin = open ( \" . . / input . txt \" , \" r \" ) NEW_LINE DEDENT else : NEW_LINE INDENT filename = \" . . / { } - small - 2 - attempt { } \" . format ( task , attempt ) if attempt >= 0 else \" . . / { } - large \" . format ( task ) NEW_LINE sys . stdin = open ( filename + \" . in \" , \" r \" ) NEW_LINE sys . stdout = open ( filename + \" . out \" , \" w \" ) NEW_LINE print ( \" filename : \" , filename [ 3 : ] , file = sys . stderr ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_17_33", "java": [{"id": "9", "code": "import java . util . Arrays ; import java . util . Scanner ; public class ProblemC { public static void main ( String [ ] args ) throws Exception { try ( Scanner sc = new Scanner ( System . in ) ) { int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { solve ( sc , caseNum ) ; } } } static void solve ( Scanner sc , int caseNum ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; double U = sc . nextDouble ( ) ; double [ ] P = new double [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = sc . nextDouble ( ) ; } Arrays . sort ( P ) ; double eps = 1e-8 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { double add = P [ i + 1 ] - P [ i ] ; if ( add * ( i + 1 ) > U + eps ) { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += U / ( i + 1 ) ; } U = 0 ; break ; } else { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += add ; } U -= add * ( i + 1 ) ; } } if ( U > 0 ) { for ( int j = 0 ; j < N ; j ++ ) { P [ j ] += U / N ; } } double res = 1 ; for ( int j = 0 ; j < N ; j ++ ) { res *= P [ j ] ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % .8f \\n \" , caseNum , res ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { try ( Scanner sc = new Scanner ( System . in ) ) { int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { solve ( sc , caseNum ) ; } } }"], ["solve", "static void solve ( Scanner sc , int caseNum ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; double U = sc . nextDouble ( ) ; double [ ] P = new double [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = sc . nextDouble ( ) ; } Arrays . sort ( P ) ; double eps = 1e-8 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { double add = P [ i + 1 ] - P [ i ] ; if ( add * ( i + 1 ) > U + eps ) { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += U / ( i + 1 ) ; } U = 0 ; break ; } else { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += add ; } U -= add * ( i + 1 ) ; } } if ( U > 0 ) { for ( int j = 0 ; j < N ; j ++ ) { P [ j ] += U / N ; } } double res = 1 ; for ( int j = 0 ; j < N ; j ++ ) { res *= P [ j ] ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % .8f \\n \" , caseNum , res ) ; }"]], "functions_class": []}, {"id": "15", "code": "package round1c ; import java . util . Arrays ; public class ProbC extends Prob { void setup ( ) { bin = true ; bout = true ; in = \" C - small - 1 - attempt0 . in \" ; out = \" cout . txt \" ; } @ Override public void main ( ) { setup ( ) ; reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { double ans = run ( ) ; System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % f \" , cas , ans ) ) ; } } double run ( ) { int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; double u = scanner . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = scanner . nextDouble ( ) ; } Arrays . sort ( p ) ; double limit = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == n - 1 || ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) > u ) { limit = u / ( i + 1 ) + p [ i ] ; break ; } else { u -= ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) ; } } double poss = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] < limit ) poss *= limit ; else poss *= p [ i ] ; } return poss ; } }", "functions_standalone": [], "functions_class": [["setup", "void setup ( ) { bin = true ; bout = true ; in = \" C - small - 1 - attempt0 . in \" ; out = \" cout . txt \" ; }"], ["main", "public void main ( ) { setup ( ) ; reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { double ans = run ( ) ; System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % f \" , cas , ans ) ) ; } }"], ["run", "double run ( ) { int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; double u = scanner . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = scanner . nextDouble ( ) ; } Arrays . sort ( p ) ; double limit = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == n - 1 || ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) > u ) { limit = u / ( i + 1 ) + p [ i ] ; break ; } else { u -= ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) ; } } double poss = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] < limit ) poss *= limit ; else poss *= p [ i ] ; } return poss ; }"]]}, {"id": "14", "code": "package gcj2017 . r1c ; import java . io . * ; import java . util . Arrays ; import java . util . Scanner ; public class Training { static PrintWriter out ; public static void main ( String [ ] args ) throws IOException { String name = \" gcj2017 / r1c / C - small - 1\" ; Scanner s = new Scanner ( new File ( name + \" . in \" ) ) ; int count = s . nextInt ( ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( name + \" . out \" ) ) ) ; for ( int ii = 1 ; ii <= count ; ii ++ ) { out . print ( \" Case \u2581 # \" + ii + \" : \u2581 \" ) ; int n = s . nextInt ( ) ; int k = s . nextInt ( ) ; double u = s . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = s . nextDouble ( ) ; } double res = solve ( n , k , u , p ) ; out . print ( String . format ( \" % .8f \" , res ) ) ; out . println ( ) ; } out . close ( ) ; } static double solve ( int n , int k , double u , double [ ] p ) { Arrays . sort ( p ) ; while ( u > 0.000000001 ) { double min = p [ 0 ] ; int ni = n ; double np = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] == min ) { continue ; } np = p [ i ] ; ni = i ; break ; } if ( ni * ( np - min ) <= u ) { for ( int i = 0 ; i < ni ; i ++ ) { p [ i ] = np ; } u -= ni * ( np - min ) ; } else { double d = u / ni ; for ( int i = 0 ; i < ni ; i ++ ) { p [ i ] += d ; } u = 0 ; } } double res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { res *= p [ i ] ; } return res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { String name = \" gcj2017 / r1c / C - small - 1\" ; Scanner s = new Scanner ( new File ( name + \" . in \" ) ) ; int count = s . nextInt ( ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( name + \" . out \" ) ) ) ; for ( int ii = 1 ; ii <= count ; ii ++ ) { out . print ( \" Case \u2581 # \" + ii + \" : \u2581 \" ) ; int n = s . nextInt ( ) ; int k = s . nextInt ( ) ; double u = s . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = s . nextDouble ( ) ; } double res = solve ( n , k , u , p ) ; out . print ( String . format ( \" % .8f \" , res ) ) ; out . println ( ) ; } out . close ( ) ; }"], ["solve", "static double solve ( int n , int k , double u , double [ ] p ) { Arrays . sort ( p ) ; while ( u > 0.000000001 ) { double min = p [ 0 ] ; int ni = n ; double np = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] == min ) { continue ; } np = p [ i ] ; ni = i ; break ; } if ( ni * ( np - min ) <= u ) { for ( int i = 0 ; i < ni ; i ++ ) { p [ i ] = np ; } u -= ni * ( np - min ) ; } else { double d = u / ni ; for ( int i = 0 ; i < ni ; i ++ ) { p [ i ] += d ; } u = 0 ; } } double res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { res *= p [ i ] ; } return res ; }"]], "functions_class": []}, {"id": "17", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( new File ( \" output . txt \" ) ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; double budget = in . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = in . nextDouble ( ) ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + calc ( p , budget ) ) ; } out . close ( ) ; } static double calc ( double [ ] p , double budget ) { double ans = 1.0 ; int n = p . length ; Arrays . sort ( p ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { double d = p [ i + 1 ] - p [ i ] ; double need = d * ( i + 1 ) ; if ( budget < need ) { double minP = p [ i ] + budget / ( i + 1 ) ; for ( int j = 0 ; j <= i ; j ++ ) { ans *= minP ; } for ( int j = i + 1 ; j < n ; j ++ ) { ans *= p [ j ] ; } return ans ; } budget -= need ; } double minP = p [ n - 1 ] + budget / n ; return Math . pow ( minP , n ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( new File ( \" output . txt \" ) ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; double budget = in . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = in . nextDouble ( ) ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + calc ( p , budget ) ) ; } out . close ( ) ; }"], ["calc", "static double calc ( double [ ] p , double budget ) { double ans = 1.0 ; int n = p . length ; Arrays . sort ( p ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { double d = p [ i + 1 ] - p [ i ] ; double need = d * ( i + 1 ) ; if ( budget < need ) { double minP = p [ i ] + budget / ( i + 1 ) ; for ( int j = 0 ; j <= i ; j ++ ) { ans *= minP ; } for ( int j = i + 1 ; j < n ; j ++ ) { ans *= p [ j ] ; } return ans ; } budget -= need ; } double minP = p [ n - 1 ] + budget / n ; return Math . pow ( minP , n ) ; }"]], "functions_class": []}, {"id": "10", "code": "import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" C - small - 1 - attempt2 . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" solve . txt \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; StringTokenizer s ; for ( int t = 1 ; t <= T ; t ++ ) { s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; int N = Integer . parseInt ( s . nextToken ( ) ) ; int K = Integer . parseInt ( s . nextToken ( ) ) ; double [ ] arr = new double [ N ] ; double U = Double . parseDouble ( br . readLine ( ) . trim ( ) ) ; s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = Double . parseDouble ( s . nextToken ( ) ) ; } Arrays . sort ( arr ) ; double pro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != N - 1 ) { if ( U > ( ( i + 1 ) * ( arr [ i + 1 ] - arr [ i ] ) ) ) { U -= ( ( i + 1 ) * ( arr [ i + 1 ] - arr [ i ] ) ) ; } else { pro = Math . pow ( ( arr [ i ] + ( U / ( i + 1 ) ) ) , i + 1 ) ; for ( int j = i + 1 ; j < N ; j ++ ) { pro *= arr [ j ] ; } break ; } } else { pro = Math . pow ( ( U / N ) + arr [ i ] , N ) ; } } bw . write ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; bw . write ( String . format ( \" % .6f \\n \" , pro ) ) ; } br . close ( ) ; bw . close ( ) ; return ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" C - small - 1 - attempt2 . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" solve . txt \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; StringTokenizer s ; for ( int t = 1 ; t <= T ; t ++ ) { s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; int N = Integer . parseInt ( s . nextToken ( ) ) ; int K = Integer . parseInt ( s . nextToken ( ) ) ; double [ ] arr = new double [ N ] ; double U = Double . parseDouble ( br . readLine ( ) . trim ( ) ) ; s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = Double . parseDouble ( s . nextToken ( ) ) ; } Arrays . sort ( arr ) ; double pro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != N - 1 ) { if ( U > ( ( i + 1 ) * ( arr [ i + 1 ] - arr [ i ] ) ) ) { U -= ( ( i + 1 ) * ( arr [ i + 1 ] - arr [ i ] ) ) ; } else { pro = Math . pow ( ( arr [ i ] + ( U / ( i + 1 ) ) ) , i + 1 ) ; for ( int j = i + 1 ; j < N ; j ++ ) { pro *= arr [ j ] ; } break ; } } else { pro = Math . pow ( ( U / N ) + arr [ i ] , N ) ; } } bw . write ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; bw . write ( String . format ( \" % .6f \\n \" , pro ) ) ; } br . close ( ) ; bw . close ( ) ; return ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "import math NEW_LINE CONVERT = 10000 NEW_LINE def f ( nums , power , k ) : NEW_LINE INDENT for i in range ( power ) : NEW_LINE INDENT nums [ nums . index ( min ( nums ) ) ] += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for n in nums : NEW_LINE INDENT ans *= n / CONVERT NEW_LINE DEDENT return ans NEW_LINE DEDENT def logs ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return - 100000 NEW_LINE DEDENT return math . log ( x ) NEW_LINE DEDENT def logadd ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return a + logs ( 1 + math . exp ( b - a ) ) NEW_LINE DEDENT def p ( nums , K ) : NEW_LINE INDENT store = [ ] NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT store . append ( [ 0 ] * len ( nums ) ) NEW_LINE DEDENT for k in range ( K + 1 ) : NEW_LINE INDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT store [ k ] [ i ] = 0 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT store [ k ] [ i ] = - 100000 NEW_LINE DEDENT else : NEW_LINE INDENT store [ k ] [ i ] = logadd ( store [ k - 1 ] [ i - 1 ] + logs ( nums [ i ] ) , store [ k ] [ i - 1 ] + logs ( 1 - nums [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT return store [ K ] [ len ( nums ) - 1 ] NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE power = float ( input ( ) ) NEW_LINE power *= CONVERT NEW_LINE power = round ( power ) NEW_LINE starts = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( starts ) ) : NEW_LINE INDENT starts [ i ] = round ( starts [ i ] * CONVERT ) NEW_LINE DEDENT ans = f ( starts , power , k ) NEW_LINE print ( \" Case \u2581 # % s : \u2581 % s \" % ( case , ans ) ) NEW_LINE DEDENT", "functions_standalone": [["f", "def f ( nums , power , k ) : NEW_LINE INDENT for i in range ( power ) : NEW_LINE INDENT nums [ nums . index ( min ( nums ) ) ] += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for n in nums : NEW_LINE INDENT ans *= n / CONVERT NEW_LINE DEDENT return ans NEW_LINE DEDENT"], ["logs", "def logs ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return - 100000 NEW_LINE DEDENT return math . log ( x ) NEW_LINE DEDENT"], ["logadd", "def logadd ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return a + logs ( 1 + math . exp ( b - a ) ) NEW_LINE DEDENT"], ["p", "def p ( nums , K ) : NEW_LINE INDENT store = [ ] NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT store . append ( [ 0 ] * len ( nums ) ) NEW_LINE DEDENT for k in range ( K + 1 ) : NEW_LINE INDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT store [ k ] [ i ] = 0 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT store [ k ] [ i ] = - 100000 NEW_LINE DEDENT else : NEW_LINE INDENT store [ k ] [ i ] = logadd ( store [ k - 1 ] [ i - 1 ] + logs ( nums [ i ] ) , store [ k ] [ i - 1 ] + logs ( 1 - nums [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT return store [ K ] [ len ( nums ) - 1 ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "import sys NEW_LINE import math NEW_LINE from functools import reduce NEW_LINE lines = [ l . strip ( ) for l in sys . stdin . readlines ( ) ] NEW_LINE T = int ( lines [ 0 ] ) NEW_LINE i = 1 NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , K = map ( int , lines [ i ] . split ( ' \u2581 ' ) ) NEW_LINE i += 1 NEW_LINE U = float ( lines [ i ] ) NEW_LINE i += 1 NEW_LINE P = list ( map ( float , lines [ i ] . split ( ' \u2581 ' ) ) ) NEW_LINE i += 1 NEW_LINE P . sort ( ) NEW_LINE j = 0 NEW_LINE while j < N and U > 0.000000000001 : NEW_LINE INDENT while j < N - 1 and P [ j ] == P [ j + 1 ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT target = P [ j + 1 ] if j < N - 1 else 1 NEW_LINE required = ( target - P [ j ] ) * ( j + 1 ) NEW_LINE if required <= U : NEW_LINE INDENT U -= required NEW_LINE P [ 0 : j + 1 ] = [ target ] * ( j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT target = P [ j ] + U / ( j + 1 ) NEW_LINE U = 0 NEW_LINE P [ 0 : j + 1 ] = [ target ] * ( j + 1 ) NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % f \" % ( t + 1 , reduce ( lambda x , y : x * y , P , 1.0 ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "19", "code": "with open ( ' C - small - 1 - attempt0 . in ' ) as infile : NEW_LINE INDENT with open ( ' C - small - 1 - attempt0 . out ' , ' w ' ) as outfile : NEW_LINE INDENT cases = int ( next ( infile ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT n , k = map ( int , next ( infile ) . split ( ) ) NEW_LINE u = round ( float ( next ( infile ) ) * 10000 ) NEW_LINE p = list ( map ( lambda x : round ( float ( x ) * 10000 ) , next ( infile ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE p . append ( 10000 ) NEW_LINE i = 0 NEW_LINE while u > 0 and i < len ( p ) : NEW_LINE INDENT while i < len ( p ) and p [ i ] == p [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT x = min ( ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) , u ) NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT p [ j ] += x / ( i + 1 ) NEW_LINE DEDENT u -= x NEW_LINE DEDENT product = 1 NEW_LINE for x in p : NEW_LINE INDENT product *= x / 10000 NEW_LINE DEDENT print ( case , product ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , product ) , file = outfile ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "6", "code": "import sys NEW_LINE def problem ( success , units , cores ) : NEW_LINE INDENT cores . sort ( ) NEW_LINE cores . append ( 1.0 ) NEW_LINE spent = 0.0 NEW_LINE min_prob = 0.0 NEW_LINE for i , core in enumerate ( cores ) : NEW_LINE INDENT if core == 1.0 : NEW_LINE INDENT min_prob = 1.0 NEW_LINE break NEW_LINE DEDENT plan = ( cores [ i + 1 ] - cores [ i ] ) * ( i + 1 ) NEW_LINE if plan > units - spent : NEW_LINE INDENT min_prob = core + ( units - spent ) / ( i + 1 ) NEW_LINE break NEW_LINE DEDENT spent += plan NEW_LINE DEDENT prob = 1.0 NEW_LINE for n in cores : NEW_LINE INDENT prob *= max ( min_prob , n ) NEW_LINE DEDENT return prob NEW_LINE DEDENT def nextline ( input_file ) : NEW_LINE INDENT data = \" \" NEW_LINE while not data : NEW_LINE INDENT data = input_file . readline ( ) NEW_LINE DEDENT return data [ : - 1 ] NEW_LINE DEDENT def intsplit ( s ) : NEW_LINE INDENT return [ int ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT def floatsplit ( s ) : NEW_LINE INDENT return [ float ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT result = \" \" NEW_LINE with sys . stdin if len ( sys . argv ) == 1 else open ( sys . argv [ 1 ] , ' r ' ) as infile : NEW_LINE INDENT number = int ( nextline ( infile ) ) NEW_LINE for run in range ( number ) : NEW_LINE INDENT case = nextline ( infile ) NEW_LINE total , success = intsplit ( case ) NEW_LINE units = float ( nextline ( infile ) ) NEW_LINE cores = floatsplit ( nextline ( infile ) ) NEW_LINE result += ' Case \u2581 # { } : \u2581 { } \\n ' . format ( 1 + run , problem ( success , units , cores ) ) NEW_LINE DEDENT DEDENT if len ( sys . argv ) == 1 : NEW_LINE INDENT print ( result , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT with open ( sys . argv [ 1 ] . replace ( ' in ' , ' sol ' ) , ' w ' ) as result_file : NEW_LINE INDENT result_file . write ( result ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["problem", "def problem ( success , units , cores ) : NEW_LINE INDENT cores . sort ( ) NEW_LINE cores . append ( 1.0 ) NEW_LINE spent = 0.0 NEW_LINE min_prob = 0.0 NEW_LINE for i , core in enumerate ( cores ) : NEW_LINE INDENT if core == 1.0 : NEW_LINE INDENT min_prob = 1.0 NEW_LINE break NEW_LINE DEDENT plan = ( cores [ i + 1 ] - cores [ i ] ) * ( i + 1 ) NEW_LINE if plan > units - spent : NEW_LINE INDENT min_prob = core + ( units - spent ) / ( i + 1 ) NEW_LINE break NEW_LINE DEDENT spent += plan NEW_LINE DEDENT prob = 1.0 NEW_LINE for n in cores : NEW_LINE INDENT prob *= max ( min_prob , n ) NEW_LINE DEDENT return prob NEW_LINE DEDENT"], ["nextline", "def nextline ( input_file ) : NEW_LINE INDENT data = \" \" NEW_LINE while not data : NEW_LINE INDENT data = input_file . readline ( ) NEW_LINE DEDENT return data [ : - 1 ] NEW_LINE DEDENT"], ["intsplit", "def intsplit ( s ) : NEW_LINE INDENT return [ int ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT"], ["floatsplit", "def floatsplit ( s ) : NEW_LINE INDENT return [ float ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT result = \" \" NEW_LINE with sys . stdin if len ( sys . argv ) == 1 else open ( sys . argv [ 1 ] , ' r ' ) as infile : NEW_LINE INDENT number = int ( nextline ( infile ) ) NEW_LINE for run in range ( number ) : NEW_LINE INDENT case = nextline ( infile ) NEW_LINE total , success = intsplit ( case ) NEW_LINE units = float ( nextline ( infile ) ) NEW_LINE cores = floatsplit ( nextline ( infile ) ) NEW_LINE result += ' Case \u2581 # { } : \u2581 { } \\n ' . format ( 1 + run , problem ( success , units , cores ) ) NEW_LINE DEDENT DEDENT if len ( sys . argv ) == 1 : NEW_LINE INDENT print ( result , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT with open ( sys . argv [ 1 ] . replace ( ' in ' , ' sol ' ) , ' w ' ) as result_file : NEW_LINE INDENT result_file . write ( result ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "14", "code": "import functools NEW_LINE import operator NEW_LINE def work ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE u = float ( input ( ) ) NEW_LINE ps = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def f ( v ) : NEW_LINE INDENT return functools . reduce ( operator . mul , ( max ( p , v ) for p in ps ) ) NEW_LINE DEDENT def search ( a , b , it ) : NEW_LINE INDENT if it == 100 : NEW_LINE INDENT return a NEW_LINE DEDENT c = 0.5 * ( a + b ) NEW_LINE return search ( c , b , it + 1 ) if sum ( max ( 0 , c - p ) for p in ps ) <= u else search ( a , c , it + 1 ) NEW_LINE DEDENT return f ( search ( 0 , 1 , 0 ) ) NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { : . 7f } ' . format ( t + 1 , work ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["work", "def work ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE u = float ( input ( ) ) NEW_LINE ps = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def f ( v ) : NEW_LINE INDENT return functools . reduce ( operator . mul , ( max ( p , v ) for p in ps ) ) NEW_LINE DEDENT def search ( a , b , it ) : NEW_LINE INDENT if it == 100 : NEW_LINE INDENT return a NEW_LINE DEDENT c = 0.5 * ( a + b ) NEW_LINE return search ( c , b , it + 1 ) if sum ( max ( 0 , c - p ) for p in ps ) <= u else search ( a , c , it + 1 ) NEW_LINE DEDENT return f ( search ( 0 , 1 , 0 ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_17_02", "java": [{"id": "15", "code": "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . util . Scanner ; public class b { public static void main ( String [ ] Args ) throws Exception { Scanner sc = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" b . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String x = sc . next ( ) ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) for ( int j = 0 ; j + 1 < x . length ( ) ; j ++ ) if ( x . charAt ( j ) > x . charAt ( j + 1 ) ) { String nx = x . substring ( 0 , j ) ; nx = nx + ( char ) ( x . charAt ( j ) - 1 ) ; while ( nx . length ( ) < x . length ( ) ) nx = nx + \"9\" ; x = nx ; } while ( x . length ( ) > 1 && x . charAt ( 0 ) == '0' ) x = x . substring ( 1 ) ; out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , ++ cc , x ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] Args ) throws Exception { Scanner sc = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" b . out \" ) ) ) ) ; int cc = 0 ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { String x = sc . next ( ) ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) for ( int j = 0 ; j + 1 < x . length ( ) ; j ++ ) if ( x . charAt ( j ) > x . charAt ( j + 1 ) ) { String nx = x . substring ( 0 , j ) ; nx = nx + ( char ) ( x . charAt ( j ) - 1 ) ; while ( nx . length ( ) < x . length ( ) ) nx = nx + \"9\" ; x = nx ; } while ( x . length ( ) > 1 && x . charAt ( 0 ) == '0' ) x = x . substring ( 1 ) ; out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , ++ cc , x ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "0", "code": "import java . io . * ; import java . util . StringTokenizer ; public class B { private String solveTest ( ) throws IOException { String s = next ( ) ; int i = 0 ; while ( i < s . length ( ) - 1 && s . charAt ( i + 1 ) >= s . charAt ( i ) ) { i ++ ; } if ( i == s . length ( ) - 1 ) return s ; while ( i > 0 && s . charAt ( i - 1 ) == s . charAt ( i ) ) i -- ; String res = \" \" ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { res += j < i ? s . charAt ( j ) : j == i ? ( char ) ( s . charAt ( j ) - 1 ) : '9' ; } if ( res . charAt ( 0 ) == '0' ) res = res . substring ( 1 ) ; return res ; } private void solve ( ) throws IOException { int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String res = solveTest ( ) ; System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + res ) ; out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + res ) ; } } BufferedReader br ; StringTokenizer st ; PrintWriter out ; String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; } int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public static void main ( String [ ] args ) throws FileNotFoundException { new B ( ) . run ( ) ; } private void run ( ) throws FileNotFoundException { br = new BufferedReader ( new FileReader ( this . getClass ( ) . getSimpleName ( ) . substring ( 0 , 1 ) + \" . in \" ) ) ; out = new PrintWriter ( this . getClass ( ) . getSimpleName ( ) . substring ( 0 , 1 ) + \" . out \" ) ; try { solve ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { new B ( ) . run ( ) ; }"]], "functions_class": [["solveTest", "private String solveTest ( ) throws IOException { String s = next ( ) ; int i = 0 ; while ( i < s . length ( ) - 1 && s . charAt ( i + 1 ) >= s . charAt ( i ) ) { i ++ ; } if ( i == s . length ( ) - 1 ) return s ; while ( i > 0 && s . charAt ( i - 1 ) == s . charAt ( i ) ) i -- ; String res = \" \" ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { res += j < i ? s . charAt ( j ) : j == i ? ( char ) ( s . charAt ( j ) - 1 ) : '9' ; } if ( res . charAt ( 0 ) == '0' ) res = res . substring ( 1 ) ; return res ; }"], ["solve", "private void solve ( ) throws IOException { int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String res = solveTest ( ) ; System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + res ) ; out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + res ) ; } }"], ["next", "String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }"], ["run", "private void run ( ) throws FileNotFoundException { br = new BufferedReader ( new FileReader ( this . getClass ( ) . getSimpleName ( ) . substring ( 0 , 1 ) + \" . in \" ) ) ; out = new PrintWriter ( this . getClass ( ) . getSimpleName ( ) . substring ( 0 , 1 ) + \" . out \" ) ; try { solve ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } out . close ( ) ; }"]]}, {"id": "7", "code": "package qualification ; import java . io . * ; import java . util . * ; public class B_TidyNumbers { private static final String FILENAME = \" B - large \" ; private static final boolean STANDARD_OUTPUT = false ; public static void main ( String [ ] args ) throws Throwable { try ( BufferedReader in = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ) { try ( PrintStream out = ! STANDARD_OUTPUT ? new PrintStream ( FILENAME + \" . out \" ) : System . out ) { for ( int t = 1 , T = Integer . parseInt ( in . readLine ( ) ) ; t <= T ; t ++ ) { char [ ] N = in . readLine ( ) . toCharArray ( ) ; int i = 1 , k = 0 ; for ( i = 1 ; i < N . length && N [ i ] >= N [ i - 1 ] ; i ++ ) { } if ( i < N . length ) { for ( k = i - 1 ; k >= 0 && N [ k ] == N [ i - 1 ] ; k -- ) { } N [ ++ k ] -- ; Arrays . fill ( N , k + 1 , N . length , '9' ) ; k = k == 0 && N [ 0 ] == '0' ? 1 : 0 ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + new String ( N , k , N . length - k ) ) ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { try ( BufferedReader in = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ) { try ( PrintStream out = ! STANDARD_OUTPUT ? new PrintStream ( FILENAME + \" . out \" ) : System . out ) { for ( int t = 1 , T = Integer . parseInt ( in . readLine ( ) ) ; t <= T ; t ++ ) { char [ ] N = in . readLine ( ) . toCharArray ( ) ; int i = 1 , k = 0 ; for ( i = 1 ; i < N . length && N [ i ] >= N [ i - 1 ] ; i ++ ) { } if ( i < N . length ) { for ( k = i - 1 ; k >= 0 && N [ k ] == N [ i - 1 ] ; k -- ) { } N [ ++ k ] -- ; Arrays . fill ( N , k + 1 , N . length , '9' ) ; k = k == 0 && N [ 0 ] == '0' ? 1 : 0 ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + new String ( N , k , N . length - k ) ) ; } } } }"]], "functions_class": []}, {"id": "18", "code": "package com . company ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . PrintStream ; import java . util . Arrays ; import java . util . Scanner ; public class ProbB { private Scanner scanner = new Scanner ( System . in ) ; public void main ( ) { reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { long ans = run ( ) ; System . out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + ans ) ; } } private long run ( ) { long input = scanner . nextLong ( ) ; char [ ] arr = Long . valueOf ( input ) . toString ( ) . toCharArray ( ) ; int x = arr . length ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { x = i + 1 ; break ; } } if ( x == arr . length ) { return input ; } int y = x - 1 ; while ( y > 0 && arr [ y ] == arr [ y - 1 ] ) y -- ; arr [ y ] -- ; for ( int i = y + 1 ; i < arr . length ; i ++ ) { arr [ i ] = '9' ; } return Long . valueOf ( new String ( arr ) ) ; } private void reDirect ( ) { try { FileInputStream fileInputStream = new FileInputStream ( \" B - large . in \" ) ; scanner = new Scanner ( fileInputStream ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" bout - large . txt \" ) ) ; System . setOut ( ps ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [], "functions_class": [["main", "public void main ( ) { reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { long ans = run ( ) ; System . out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + ans ) ; } }"], ["run", "private long run ( ) { long input = scanner . nextLong ( ) ; char [ ] arr = Long . valueOf ( input ) . toString ( ) . toCharArray ( ) ; int x = arr . length ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { x = i + 1 ; break ; } } if ( x == arr . length ) { return input ; } int y = x - 1 ; while ( y > 0 && arr [ y ] == arr [ y - 1 ] ) y -- ; arr [ y ] -- ; for ( int i = y + 1 ; i < arr . length ; i ++ ) { arr [ i ] = '9' ; } return Long . valueOf ( new String ( arr ) ) ; }"], ["reDirect", "private void reDirect ( ) { try { FileInputStream fileInputStream = new FileInputStream ( \" B - large . in \" ) ; scanner = new Scanner ( fileInputStream ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" bout - large . txt \" ) ) ; System . setOut ( ps ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }"]]}, {"id": "2", "code": "package qualifier ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; public class BTidyNumbers { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ) { int tests = sc . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { int [ ] digits = sc . next ( ) . chars ( ) . map ( i -> i - '0' ) . toArray ( ) ; for ( int x = 0 ; x < digits . length - 1 ; x ++ ) { if ( digits [ x ] > digits [ x + 1 ] ) { digits [ x ] -- ; for ( int y = x + 1 ; y < digits . length ; y ++ ) digits [ y ] = 9 ; while ( digits [ x ] < 0 || ( x > 0 && digits [ x ] < digits [ x - 1 ] ) ) { digits [ x ] = 9 ; digits [ x - 1 ] -- ; x -- ; } break ; } } int start = 0 ; while ( digits [ start ] == 0 ) start ++ ; StringBuilder sb = new StringBuilder ( ) ; for ( int x = start ; x < digits . length ; x ++ ) sb . append ( ( char ) ( digits [ x ] + '0' ) ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , t , sb . toString ( ) ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ) { int tests = sc . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { int [ ] digits = sc . next ( ) . chars ( ) . map ( i -> i - '0' ) . toArray ( ) ; for ( int x = 0 ; x < digits . length - 1 ; x ++ ) { if ( digits [ x ] > digits [ x + 1 ] ) { digits [ x ] -- ; for ( int y = x + 1 ; y < digits . length ; y ++ ) digits [ y ] = 9 ; while ( digits [ x ] < 0 || ( x > 0 && digits [ x ] < digits [ x - 1 ] ) ) { digits [ x ] = 9 ; digits [ x - 1 ] -- ; x -- ; } break ; } } int start = 0 ; while ( digits [ start ] == 0 ) start ++ ; StringBuilder sb = new StringBuilder ( ) ; for ( int x = start ; x < digits . length ; x ++ ) sb . append ( ( char ) ( digits [ x ] + '0' ) ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , t , sb . toString ( ) ) ; } } }"]], "functions_class": []}], "python": [{"id": "15", "code": "def tidy ( N ) : NEW_LINE INDENT return list ( N ) == sorted ( N ) NEW_LINE DEDENT def solve ( N ) : NEW_LINE INDENT if N == '0' : NEW_LINE INDENT return ' ' NEW_LINE DEDENT if tidy ( N ) or len ( N ) <= 1 : NEW_LINE INDENT return N NEW_LINE DEDENT return solve ( str ( int ( N [ : - 1 ] ) - 1 ) ) + '9' NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for case_number in range ( 1 , T + 1 ) : NEW_LINE INDENT N = input ( ) NEW_LINE print ( ' Case \u2581 # % d : ' % case_number , solve ( N ) ) NEW_LINE DEDENT", "functions_standalone": [["tidy", "def tidy ( N ) : NEW_LINE INDENT return list ( N ) == sorted ( N ) NEW_LINE DEDENT"], ["solve", "def solve ( N ) : NEW_LINE INDENT if N == '0' : NEW_LINE INDENT return ' ' NEW_LINE DEDENT if tidy ( N ) or len ( N ) <= 1 : NEW_LINE INDENT return N NEW_LINE DEDENT return solve ( str ( int ( N [ : - 1 ] ) - 1 ) ) + '9' NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "infilecode = \" BLI \" NEW_LINE import sys NEW_LINE mapping = { \" A \" : \" A \" , \" B \" : \" B \" , \" C \" : \" C \" , \" D \" : \" D \" , \" E \" : \" E \" , \" X \" : \" example \" , \" S \" : \" - small \" , \" L \" : \" - large \" , \" P \" : \" - practice \" , \"0\" : \" - attempt0\" , \"1\" : \" - attempt1\" , \"2\" : \" - attempt2\" , \" I \" : \" . in \" , \" T \" : \" . txt \" } NEW_LINE infile = \" \" . join ( mapping [ c ] for c in infilecode ) NEW_LINE outfile = infile . replace ( \" . in \" , \" \" ) + \" . out . txt \" NEW_LINE sys . stdin = open ( infile , ' r ' ) NEW_LINE output = open ( outfile , ' w ' ) NEW_LINE T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE print ( N ) NEW_LINE a = str ( N ) NEW_LINE l = len ( a ) NEW_LINE for i in range ( l - 1 , 0 , - 1 ) : NEW_LINE INDENT if a [ i ] >= a [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT a = a [ : i ] + \"0\" * ( l - i ) NEW_LINE N = int ( a ) - 1 NEW_LINE a = str ( N ) NEW_LINE DEDENT answer = a NEW_LINE print ( \" Case \u2581 # % d : \" % case , answer ) NEW_LINE print ( \" Case \u2581 # % d : \" % case , answer , file = output ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "12", "code": "def solve ( n ) : NEW_LINE INDENT digits = [ ] NEW_LINE while n : NEW_LINE INDENT digits . append ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT digits = list ( reversed ( digits ) ) NEW_LINE ans = None NEW_LINE for i in range ( len ( digits ) ) : NEW_LINE INDENT if i and digits [ i ] < digits [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT if i == 0 or digits [ i ] - 1 >= digits [ i - 1 ] : NEW_LINE INDENT if digits [ i ] - 1 == 0 : NEW_LINE INDENT ans = [ 9 ] * ( len ( digits ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = digits [ : i ] + [ digits [ i ] - 1 ] + [ 9 ] * ( len ( digits ) - i - 1 ) NEW_LINE DEDENT DEDENT if i == len ( digits ) - 1 : NEW_LINE INDENT ans = digits NEW_LINE DEDENT DEDENT return ' ' . join ( map ( str , ans ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ntest = int ( input ( ) ) NEW_LINE for i in range ( ntest ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = solve ( n ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , ans ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( n ) : NEW_LINE INDENT digits = [ ] NEW_LINE while n : NEW_LINE INDENT digits . append ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT digits = list ( reversed ( digits ) ) NEW_LINE ans = None NEW_LINE for i in range ( len ( digits ) ) : NEW_LINE INDENT if i and digits [ i ] < digits [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT if i == 0 or digits [ i ] - 1 >= digits [ i - 1 ] : NEW_LINE INDENT if digits [ i ] - 1 == 0 : NEW_LINE INDENT ans = [ 9 ] * ( len ( digits ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = digits [ : i ] + [ digits [ i ] - 1 ] + [ 9 ] * ( len ( digits ) - i - 1 ) NEW_LINE DEDENT DEDENT if i == len ( digits ) - 1 : NEW_LINE INDENT ans = digits NEW_LINE DEDENT DEDENT return ' ' . join ( map ( str , ans ) ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT ntest = int ( input ( ) ) NEW_LINE for i in range ( ntest ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = solve ( n ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , ans ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "3", "code": "from __future__ import print_function NEW_LINE import sys NEW_LINE from sys import stdin NEW_LINE def eprint ( * args , ** kwargs ) : NEW_LINE INDENT print ( * args , file = sys . stderr , ** kwargs ) NEW_LINE DEDENT def ln ( f = int ) : NEW_LINE INDENT return list ( map ( f , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT T , = ln ( ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE for test in range ( T ) : NEW_LINE INDENT s , = ln ( str ) NEW_LINE s = list ( map ( int , list ( s ) ) ) NEW_LINE prev = 9 NEW_LINE res = \" \" NEW_LINE ind = None NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] < s [ i - 1 ] : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ind != None : NEW_LINE INDENT for i in range ( ind + 1 , len ( s ) ) : NEW_LINE INDENT s [ i ] = 9 NEW_LINE DEDENT while ind != 0 and s [ ind ] < s [ ind - 1 ] : NEW_LINE INDENT s [ ind - 1 ] -= 1 NEW_LINE s [ ind ] = 9 NEW_LINE ind -= 1 NEW_LINE DEDENT DEDENT res = int ( \" \" . join ( list ( map ( str , s ) ) ) ) NEW_LINE print ( \" Case \u2581 # \" + str ( test + 1 ) + \" : \u2581 \" + str ( res ) ) NEW_LINE DEDENT", "functions_standalone": [["eprint", "def eprint ( * args , ** kwargs ) : NEW_LINE INDENT print ( * args , file = sys . stderr , ** kwargs ) NEW_LINE DEDENT"], ["ln", "def ln ( f = int ) : NEW_LINE INDENT return list ( map ( f , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "0", "code": "def to_int ( l ) : NEW_LINE INDENT out = 0 NEW_LINE for d in l : NEW_LINE INDENT out = out * 10 + d NEW_LINE DEDENT return out NEW_LINE DEDENT def run_test ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE n = [ int ( c ) for c in str ( n ) ] NEW_LINE assert len ( n ) >= 1 NEW_LINE start = 0 NEW_LINE for i in range ( 1 , len ( n ) ) : NEW_LINE INDENT if n [ i ] < n [ start ] : NEW_LINE INDENT break NEW_LINE DEDENT elif n [ i ] > n [ start ] : NEW_LINE INDENT start = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return to_int ( n ) NEW_LINE DEDENT for j in range ( start + 1 , len ( n ) ) : NEW_LINE INDENT n [ j ] = 0 NEW_LINE DEDENT return to_int ( n ) - 1 NEW_LINE DEDENT for i in range ( 1 , int ( input ( ) ) + 1 ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i , run_test ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["to_int", "def to_int ( l ) : NEW_LINE INDENT out = 0 NEW_LINE for d in l : NEW_LINE INDENT out = out * 10 + d NEW_LINE DEDENT return out NEW_LINE DEDENT"], ["run_test", "def run_test ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE n = [ int ( c ) for c in str ( n ) ] NEW_LINE assert len ( n ) >= 1 NEW_LINE start = 0 NEW_LINE for i in range ( 1 , len ( n ) ) : NEW_LINE INDENT if n [ i ] < n [ start ] : NEW_LINE INDENT break NEW_LINE DEDENT elif n [ i ] > n [ start ] : NEW_LINE INDENT start = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return to_int ( n ) NEW_LINE DEDENT for j in range ( start + 1 , len ( n ) ) : NEW_LINE INDENT n [ j ] = 0 NEW_LINE DEDENT return to_int ( n ) - 1 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_17_42", "java": [{"id": "19", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintStream ; import java . util . Scanner ; public class RollerCoasterScheduling { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner cin = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintStream cout = new PrintStream ( \" B - large . out \" ) ; int _case = 0 ; for ( int T = cin . nextInt ( ) ; T > 0 ; T -- ) { _case ++ ; int N = cin . nextInt ( ) ; int C = cin . nextInt ( ) ; int M = cin . nextInt ( ) ; int [ ] [ ] a = new int [ C + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { int p = cin . nextInt ( ) ; int b = cin . nextInt ( ) ; a [ b ] [ p ] ++ ; } int totalTrains = 0 ; for ( int i = 1 ; i <= C ; i ++ ) { int sum = 0 ; for ( int j = 1 ; j <= N ; j ++ ) sum += a [ i ] [ j ] ; totalTrains = Math . max ( totalTrains , sum ) ; } int prefixColSum = 0 ; for ( int j = 1 ; j <= N ; j ++ ) { for ( int i = 1 ; i <= C ; i ++ ) prefixColSum += a [ i ] [ j ] ; totalTrains = Math . max ( totalTrains , ( prefixColSum + j - 1 ) / j ) ; } int promotion = 0 ; for ( int j = N ; j >= 1 ; j -- ) { int sum = 0 ; for ( int i = 1 ; i <= C ; i ++ ) sum += a [ i ] [ j ] ; int extra = Math . max ( 0 , sum - totalTrains ) ; promotion += extra ; } String ans = \" \" + totalTrains + \" \u2581 \" + promotion ; cout . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , _case , ans ) ; } cin . close ( ) ; cout . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner cin = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintStream cout = new PrintStream ( \" B - large . out \" ) ; int _case = 0 ; for ( int T = cin . nextInt ( ) ; T > 0 ; T -- ) { _case ++ ; int N = cin . nextInt ( ) ; int C = cin . nextInt ( ) ; int M = cin . nextInt ( ) ; int [ ] [ ] a = new int [ C + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { int p = cin . nextInt ( ) ; int b = cin . nextInt ( ) ; a [ b ] [ p ] ++ ; } int totalTrains = 0 ; for ( int i = 1 ; i <= C ; i ++ ) { int sum = 0 ; for ( int j = 1 ; j <= N ; j ++ ) sum += a [ i ] [ j ] ; totalTrains = Math . max ( totalTrains , sum ) ; } int prefixColSum = 0 ; for ( int j = 1 ; j <= N ; j ++ ) { for ( int i = 1 ; i <= C ; i ++ ) prefixColSum += a [ i ] [ j ] ; totalTrains = Math . max ( totalTrains , ( prefixColSum + j - 1 ) / j ) ; } int promotion = 0 ; for ( int j = N ; j >= 1 ; j -- ) { int sum = 0 ; for ( int i = 1 ; i <= C ; i ++ ) sum += a [ i ] [ j ] ; int extra = Math . max ( 0 , sum - totalTrains ) ; promotion += extra ; } String ans = \" \" + totalTrains + \" \u2581 \" + promotion ; cout . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , _case , ans ) ; } cin . close ( ) ; cout . close ( ) ; }"]], "functions_class": []}, {"id": "18", "code": "import java . util . * ; public class cjB { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cas = sc . nextInt ( ) ; for ( int cass = 1 ; cass <= cas ; cass ++ ) { System . out . print ( \" Case \u2581 # \" + cass + \" : \u2581 \" ) ; int seats = sc . nextInt ( ) ; int customers = sc . nextInt ( ) ; int tickets = sc . nextInt ( ) ; int [ ] perCust = new int [ customers ] ; int [ ] perSeat = new int [ seats ] ; int maxPerCust = 0 ; for ( int ttt = 0 ; ttt < tickets ; ttt ++ ) { int ssss = sc . nextInt ( ) - 1 ; int cccc = sc . nextInt ( ) - 1 ; perCust [ cccc ] ++ ; perSeat [ ssss ] ++ ; if ( perCust [ cccc ] > maxPerCust ) { maxPerCust = perCust [ cccc ] ; } } int tt = tickets ; int minCoast = 0 ; while ( tt > 0 ) { minCoast ++ ; tt -= seats ; } if ( minCoast < maxPerCust ) minCoast = maxPerCust ; int tot = 0 ; for ( int qw = 0 ; qw < seats ; qw ++ ) { tot += perSeat [ qw ] ; while ( ( minCoast * ( qw + 1 ) < tot ) ) { minCoast ++ ; } } int promo = 0 ; for ( int qq = 0 ; qq < seats ; qq ++ ) { if ( perSeat [ qq ] > minCoast ) { promo += ( perSeat [ qq ] - minCoast ) ; } } System . out . println ( minCoast + \" \u2581 \" + promo ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cas = sc . nextInt ( ) ; for ( int cass = 1 ; cass <= cas ; cass ++ ) { System . out . print ( \" Case \u2581 # \" + cass + \" : \u2581 \" ) ; int seats = sc . nextInt ( ) ; int customers = sc . nextInt ( ) ; int tickets = sc . nextInt ( ) ; int [ ] perCust = new int [ customers ] ; int [ ] perSeat = new int [ seats ] ; int maxPerCust = 0 ; for ( int ttt = 0 ; ttt < tickets ; ttt ++ ) { int ssss = sc . nextInt ( ) - 1 ; int cccc = sc . nextInt ( ) - 1 ; perCust [ cccc ] ++ ; perSeat [ ssss ] ++ ; if ( perCust [ cccc ] > maxPerCust ) { maxPerCust = perCust [ cccc ] ; } } int tt = tickets ; int minCoast = 0 ; while ( tt > 0 ) { minCoast ++ ; tt -= seats ; } if ( minCoast < maxPerCust ) minCoast = maxPerCust ; int tot = 0 ; for ( int qw = 0 ; qw < seats ; qw ++ ) { tot += perSeat [ qw ] ; while ( ( minCoast * ( qw + 1 ) < tot ) ) { minCoast ++ ; } } int promo = 0 ; for ( int qq = 0 ; qq < seats ; qq ++ ) { if ( perSeat [ qq ] > minCoast ) { promo += ( perSeat [ qq ] - minCoast ) ; } } System . out . println ( minCoast + \" \u2581 \" + promo ) ; } }"]], "functions_class": []}, {"id": "10", "code": "package round2 ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int [ ] seats = new int [ N ] ; int [ ] clients = new int [ C ] ; for ( int i = 0 ; i < M ; i ++ ) { int pos = sc . nextInt ( ) - 1 ; int client = sc . nextInt ( ) - 1 ; seats [ pos ] ++ ; clients [ client ] ++ ; } int ansA = 0 ; for ( int i = 0 ; i < clients . length ; i ++ ) { int client = clients [ i ] ; ansA = Math . max ( ansA , client ) ; } int acum = 0 ; for ( int i = 0 ; i < seats . length ; i ++ ) { int seat = seats [ i ] ; acum += seat ; ansA = Math . max ( ansA , ( acum + i ) / ( i + 1 ) ) ; } int ansB = 0 ; for ( int i = 0 ; i < seats . length ; i ++ ) { int seat = seats [ i ] ; if ( seat > ansA ) ansB += seat - ansA ; } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ansA + \" \u2581 \" + ansB ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int [ ] seats = new int [ N ] ; int [ ] clients = new int [ C ] ; for ( int i = 0 ; i < M ; i ++ ) { int pos = sc . nextInt ( ) - 1 ; int client = sc . nextInt ( ) - 1 ; seats [ pos ] ++ ; clients [ client ] ++ ; } int ansA = 0 ; for ( int i = 0 ; i < clients . length ; i ++ ) { int client = clients [ i ] ; ansA = Math . max ( ansA , client ) ; } int acum = 0 ; for ( int i = 0 ; i < seats . length ; i ++ ) { int seat = seats [ i ] ; acum += seat ; ansA = Math . max ( ansA , ( acum + i ) / ( i + 1 ) ) ; } int ansB = 0 ; for ( int i = 0 ; i < seats . length ; i ++ ) { int seat = seats [ i ] ; if ( seat > ansA ) ansB += seat - ansA ; } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ansA + \" \u2581 \" + ansB ) ; } }"]], "functions_class": []}, {"id": "16", "code": "import java . util . * ; class B { public static void main ( String [ ] arg ) { Scanner sc = new Scanner ( System . in ) ; int TT = sc . nextInt ( ) ; for ( int ii = 1 ; ii <= TT ; ++ ii ) { int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int [ ] COUNT = new int [ C + 1 ] ; int [ ] coast = new int [ N + 1 ] ; for ( int i = 0 ; i < M ; ++ i ) { int pos = sc . nextInt ( ) ; int buyer = sc . nextInt ( ) ; COUNT [ buyer ] ++ ; coast [ pos ] ++ ; } int min = 0 ; for ( int i = 0 ; i < COUNT . length ; ++ i ) { if ( COUNT [ i ] > min ) min = COUNT [ i ] ; } min = Math . max ( min , coast [ 1 ] ) ; int max = M ; while ( min < max ) { int piv = ( min + max ) / 2 ; int promotions = canDo ( coast , piv ) ; if ( promotions >= 0 ) { if ( max == piv ) System . err . println ( \" whoops \" ) ; max = piv ; } else { min = piv + 1 ; } } if ( min != max ) System . err . println ( \" never \" ) ; int ans = canDo ( coast , max ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , ii , max , ans ) ; } } public static int canDo ( int [ ] coast , int R ) { int slots_available = 0 ; int promotions = 0 ; for ( int i = 1 ; i < coast . length ; ++ i ) { if ( coast [ i ] > R ) { if ( coast [ i ] - R > slots_available ) { return - 1 ; } int p = ( coast [ i ] - R ) ; slots_available -= p ; promotions += p ; } else if ( coast [ i ] == R ) { } else { slots_available += R - coast [ i ] ; } } return promotions ; } }", "functions_standalone": [["main", "public static void main ( String [ ] arg ) { Scanner sc = new Scanner ( System . in ) ; int TT = sc . nextInt ( ) ; for ( int ii = 1 ; ii <= TT ; ++ ii ) { int N = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int [ ] COUNT = new int [ C + 1 ] ; int [ ] coast = new int [ N + 1 ] ; for ( int i = 0 ; i < M ; ++ i ) { int pos = sc . nextInt ( ) ; int buyer = sc . nextInt ( ) ; COUNT [ buyer ] ++ ; coast [ pos ] ++ ; } int min = 0 ; for ( int i = 0 ; i < COUNT . length ; ++ i ) { if ( COUNT [ i ] > min ) min = COUNT [ i ] ; } min = Math . max ( min , coast [ 1 ] ) ; int max = M ; while ( min < max ) { int piv = ( min + max ) / 2 ; int promotions = canDo ( coast , piv ) ; if ( promotions >= 0 ) { if ( max == piv ) System . err . println ( \" whoops \" ) ; max = piv ; } else { min = piv + 1 ; } } if ( min != max ) System . err . println ( \" never \" ) ; int ans = canDo ( coast , max ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , ii , max , ans ) ; } }"], ["canDo", "public static int canDo ( int [ ] coast , int R ) { int slots_available = 0 ; int promotions = 0 ; for ( int i = 1 ; i < coast . length ; ++ i ) { if ( coast [ i ] > R ) { if ( coast [ i ] - R > slots_available ) { return - 1 ; } int p = ( coast [ i ] - R ) ; slots_available -= p ; promotions += p ; } else if ( coast [ i ] == R ) { } else { slots_available += R - coast [ i ] ; } } return promotions ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "import numpy as np NEW_LINE import math NEW_LINE inname = \" input . txt \" NEW_LINE outname = \" output . txt \" NEW_LINE with open ( inname , ' r ' ) as f : NEW_LINE INDENT cases = int ( f . readline ( ) ) NEW_LINE for tc in range ( 1 , cases + 1 ) : NEW_LINE INDENT line = f . readline ( ) . strip ( ) . split ( ' \u2581 ' ) NEW_LINE N = int ( line [ 0 ] ) NEW_LINE C = int ( line [ 1 ] ) NEW_LINE M = int ( line [ 2 ] ) NEW_LINE Cnum = [ 0 ] * C NEW_LINE Nnum = [ 0 ] * N NEW_LINE for i in range ( M ) : NEW_LINE INDENT line = f . readline ( ) . strip ( ) . split ( ' \u2581 ' ) NEW_LINE p = int ( line [ 0 ] ) NEW_LINE b = int ( line [ 1 ] ) NEW_LINE Nnum [ p - 1 ] += 1 NEW_LINE Cnum [ b - 1 ] += 1 NEW_LINE DEDENT Nsum = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT Nsum [ i + 1 ] = Nsum [ i ] + Nnum [ i ] NEW_LINE DEDENT y = 0 NEW_LINE for i in range ( C ) : NEW_LINE INDENT if Cnum [ i ] > y : NEW_LINE INDENT y = Cnum [ i ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT a = math . ceil ( Nsum [ i + 1 ] / ( i + 1 ) ) NEW_LINE if a > y : NEW_LINE INDENT y = a NEW_LINE DEDENT DEDENT z = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if Nnum [ i ] > y : NEW_LINE INDENT z += Nnum [ i ] - y NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \" % ( tc , y , z ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "10", "code": "def optimalResult ( N , C , positionsByPerson ) : NEW_LINE INDENT fewestRides = 0 NEW_LINE for position in xrange ( 1 , N + 1 ) : NEW_LINE INDENT totalRides = 0 NEW_LINE for B in positionsByPerson : NEW_LINE INDENT rides = 0 NEW_LINE for P in positionsByPerson [ B ] : NEW_LINE INDENT if P <= position : NEW_LINE INDENT rides += 1 NEW_LINE DEDENT DEDENT fewestRides = max ( rides , fewestRides ) NEW_LINE totalRides += rides NEW_LINE DEDENT fewestRides = max ( fewestRides , ( totalRides + position - 1 ) / position ) NEW_LINE DEDENT upgrades = 0 NEW_LINE for position in xrange ( 1 , N + 1 ) : NEW_LINE INDENT frequency = 0 NEW_LINE for B in positionsByPerson : NEW_LINE INDENT for P in positionsByPerson [ B ] : NEW_LINE INDENT if P == position : NEW_LINE INDENT frequency += 1 NEW_LINE DEDENT DEDENT DEDENT upgrades += max ( 0 , frequency - fewestRides ) NEW_LINE DEDENT return ' \u2581 ' . join ( map ( str , [ fewestRides , upgrades ] ) ) NEW_LINE DEDENT with open ( ' . . / inputs / B - large . in ' ) as infile : NEW_LINE INDENT with open ( ' . . / outputs / B - large . out ' , ' wb ' ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for i in xrange ( cases ) : NEW_LINE INDENT [ N , C , M ] = map ( int , infile . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE positionsByPerson = { } NEW_LINE for _ in xrange ( M ) : NEW_LINE INDENT [ P , B ] = map ( int , infile . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE positionsByPerson [ B ] = positionsByPerson . get ( B , [ ] ) + [ P ] NEW_LINE DEDENT for B in positionsByPerson : NEW_LINE INDENT positionsByPerson [ B ] = sorted ( positionsByPerson [ B ] ) NEW_LINE DEDENT outfile . write ( ' Case \u2581 # ' + str ( i + 1 ) + ' : \u2581 ' ) NEW_LINE outfile . write ( optimalResult ( N , C , positionsByPerson ) ) NEW_LINE outfile . write ( ' \\n ' ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "import numpy as np NEW_LINE LINES_PARAM = 2 NEW_LINE INPUT_FILE_NAME = ' B - large . in ' NEW_LINE OUTPUT_FILE_NAME = ' B - large . out ' NEW_LINE def do_case ( parsed ) : NEW_LINE INDENT n = parsed [ 0 ] [ 0 ] NEW_LINE c = parsed [ 0 ] [ 1 ] NEW_LINE seat = [ 0 for i in range ( n ) ] NEW_LINE rider = [ 0 for i in range ( c ) ] NEW_LINE for l in parsed [ 1 : ] : NEW_LINE INDENT rider [ l [ 1 ] - 1 ] += 1 NEW_LINE seat [ l [ 0 ] - 1 ] += 1 NEW_LINE DEDENT s = np . cumsum ( seat ) NEW_LINE m = max ( rider ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , ( s [ i ] + i ) // ( i + 1 ) ) NEW_LINE DEDENT pr = sum ( [ max ( 0 , se - m ) for se in seat ] ) NEW_LINE return str ( m ) + ' \u2581 ' + str ( pr ) NEW_LINE DEDENT def do_parse ( input ) : NEW_LINE INDENT return [ [ int ( num ) for num in line . rstrip ( ) . split ( \" \u2581 \" ) ] for line in input ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT input_f = open ( INPUT_FILE_NAME , ' r ' ) NEW_LINE output = [ ] NEW_LINE num_of_test_cases = int ( input_f . readline ( ) , 10 ) NEW_LINE temp = input_f . readlines ( ) NEW_LINE index = 0 NEW_LINE for test_case in range ( num_of_test_cases ) : NEW_LINE INDENT lines = int ( temp [ index ] . rstrip ( ) . split ( \" \u2581 \" ) [ LINES_PARAM ] ) NEW_LINE parsed_input = do_parse ( temp [ index : index + lines + 1 ] ) NEW_LINE index = index + 1 + lines NEW_LINE output . append ( ' Case \u2581 # ' + str ( test_case + 1 ) + ' : \u2581 ' + do_case ( parsed_input ) ) NEW_LINE DEDENT output_f = open ( OUTPUT_FILE_NAME , ' w ' ) NEW_LINE output_f . write ( ' \\n ' . join ( output ) ) NEW_LINE input_f . close ( ) NEW_LINE output_f . close ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["do_case", "def do_case ( parsed ) : NEW_LINE INDENT n = parsed [ 0 ] [ 0 ] NEW_LINE c = parsed [ 0 ] [ 1 ] NEW_LINE seat = [ 0 for i in range ( n ) ] NEW_LINE rider = [ 0 for i in range ( c ) ] NEW_LINE for l in parsed [ 1 : ] : NEW_LINE INDENT rider [ l [ 1 ] - 1 ] += 1 NEW_LINE seat [ l [ 0 ] - 1 ] += 1 NEW_LINE DEDENT s = np . cumsum ( seat ) NEW_LINE m = max ( rider ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , ( s [ i ] + i ) // ( i + 1 ) ) NEW_LINE DEDENT pr = sum ( [ max ( 0 , se - m ) for se in seat ] ) NEW_LINE return str ( m ) + ' \u2581 ' + str ( pr ) NEW_LINE DEDENT"], ["do_parse", "def do_parse ( input ) : NEW_LINE INDENT return [ [ int ( num ) for num in line . rstrip ( ) . split ( \" \u2581 \" ) ] for line in input ] NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT input_f = open ( INPUT_FILE_NAME , ' r ' ) NEW_LINE output = [ ] NEW_LINE num_of_test_cases = int ( input_f . readline ( ) , 10 ) NEW_LINE temp = input_f . readlines ( ) NEW_LINE index = 0 NEW_LINE for test_case in range ( num_of_test_cases ) : NEW_LINE INDENT lines = int ( temp [ index ] . rstrip ( ) . split ( \" \u2581 \" ) [ LINES_PARAM ] ) NEW_LINE parsed_input = do_parse ( temp [ index : index + lines + 1 ] ) NEW_LINE index = index + 1 + lines NEW_LINE output . append ( ' Case \u2581 # ' + str ( test_case + 1 ) + ' : \u2581 ' + do_case ( parsed_input ) ) NEW_LINE DEDENT output_f = open ( OUTPUT_FILE_NAME , ' w ' ) NEW_LINE output_f . write ( ' \\n ' . join ( output ) ) NEW_LINE input_f . close ( ) NEW_LINE output_f . close ( ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "8", "code": "numInputs = int ( input ( ) ) NEW_LINE for i in range ( numInputs ) : NEW_LINE INDENT N , C , M = [ int ( num ) for num in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE custSeats = [ { } , { } ] NEW_LINE seatsBought = set ( ) NEW_LINE for _ in range ( M ) : NEW_LINE INDENT seatNum , custNum = [ int ( num ) for num in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE seatsBought . add ( seatNum ) NEW_LINE if seatNum in custSeats [ custNum - 1 ] . keys ( ) : NEW_LINE INDENT custSeats [ custNum - 1 ] [ seatNum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT custSeats [ custNum - 1 ] [ seatNum ] = 1 NEW_LINE DEDENT DEDENT numTicketsBought = [ 0 , 0 ] NEW_LINE for custNum in range ( 2 ) : NEW_LINE INDENT for seatNum in custSeats [ custNum ] . keys ( ) : NEW_LINE INDENT numTicketsBought [ custNum ] += custSeats [ custNum ] [ seatNum ] NEW_LINE DEDENT DEDENT larger = max ( numTicketsBought ) NEW_LINE smaller = min ( numTicketsBought ) NEW_LINE numRides = larger NEW_LINE numPromotions = 0 NEW_LINE for seatNum in seatsBought : NEW_LINE INDENT if seatNum not in custSeats [ 0 ] . keys ( ) or seatNum not in custSeats [ 1 ] . keys ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT if custSeats [ 0 ] [ seatNum ] + custSeats [ 1 ] [ seatNum ] <= larger : NEW_LINE INDENT continue NEW_LINE DEDENT if seatNum == 1 : NEW_LINE INDENT numRides = custSeats [ 0 ] [ seatNum ] + custSeats [ 1 ] [ seatNum ] NEW_LINE DEDENT else : NEW_LINE INDENT numPromotions += custSeats [ 0 ] [ seatNum ] + custSeats [ 1 ] [ seatNum ] - larger NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( numRides ) + \" \u2581 \" + str ( numPromotions ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "5", "code": "from itertools import * NEW_LINE from collections import * NEW_LINE from functools import * NEW_LINE from math import * NEW_LINE T = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 \" . format ( t + 1 ) , end = \" \" ) NEW_LINE coasterLength , nCustomers , ticketsSold = map ( int , input ( ) . strip ( ) . split ( \" \u2581 \" ) ) NEW_LINE tickets = [ tuple ( map ( int , input ( ) . strip ( ) . split ( \" \u2581 \" ) ) ) for i in range ( ticketsSold ) ] NEW_LINE customers = list ( repeat ( 0 , nCustomers ) ) NEW_LINE positions = list ( repeat ( 0 , coasterLength ) ) NEW_LINE for position , customer in tickets : NEW_LINE INDENT customers [ customer - 1 ] += 1 NEW_LINE positions [ position - 1 ] += 1 NEW_LINE DEDENT lowerBound = max ( customers ) NEW_LINE for position , totalTickets in zip ( count ( 1 ) , accumulate ( positions ) ) : NEW_LINE INDENT lowerBound = max ( ceil ( totalTickets / position ) , lowerBound ) NEW_LINE DEDENT promotions = sum ( max ( 0 , i - lowerBound ) for i in positions ) NEW_LINE print ( \" { } \u2581 { } \" . format ( lowerBound , promotions ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_17_21", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class A { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" in . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" out . txt \" ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; for ( int pp = 0 ; pp < N ; pp ++ ) { String [ ] ss = br . readLine ( ) . split ( \" \u2581 \" ) ; int d = Integer . parseInt ( ss [ 0 ] ) ; int n = Integer . parseInt ( ss [ 1 ] ) ; double max = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { ss = br . readLine ( ) . split ( \" \u2581 \" ) ; int k = Integer . parseInt ( ss [ 0 ] ) ; int s = Integer . parseInt ( ss [ 1 ] ) ; double time = ( d - k ) / ( ( double ) s ) ; System . out . println ( d + \" \u2581 \" + k + \" \u2581 \" + s + \" \u2581 \" + time ) ; max = Math . max ( max , time ) ; } double ret = d / max ; pw . println ( \" Case \u2581 # \" + ( pp + 1 ) + \" : \u2581 \" + ret ) ; } pw . flush ( ) ; pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" in . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" out . txt \" ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; for ( int pp = 0 ; pp < N ; pp ++ ) { String [ ] ss = br . readLine ( ) . split ( \" \u2581 \" ) ; int d = Integer . parseInt ( ss [ 0 ] ) ; int n = Integer . parseInt ( ss [ 1 ] ) ; double max = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { ss = br . readLine ( ) . split ( \" \u2581 \" ) ; int k = Integer . parseInt ( ss [ 0 ] ) ; int s = Integer . parseInt ( ss [ 1 ] ) ; double time = ( d - k ) / ( ( double ) s ) ; System . out . println ( d + \" \u2581 \" + k + \" \u2581 \" + s + \" \u2581 \" + time ) ; max = Math . max ( max , time ) ; } double ret = d / max ; pw . println ( \" Case \u2581 # \" + ( pp + 1 ) + \" : \u2581 \" + ret ) ; } pw . flush ( ) ; pw . close ( ) ; }"]], "functions_class": []}, {"id": "5", "code": "package year2017 . round1b ; import java . io . File ; import java . io . PrintWriter ; import java . util . Scanner ; public class CruiseControl { public static void main ( String [ ] args ) throws Exception { File inputFile = new File ( \" A - large . in \" ) ; Scanner in = new Scanner ( inputFile ) ; File outputFile = new File ( \" output . txt \" ) ; PrintWriter out = new PrintWriter ( outputFile ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { double D = in . nextDouble ( ) ; int N = in . nextInt ( ) ; double maxTime = 0 ; for ( int n = 0 ; n < N ; n ++ ) { double K = in . nextDouble ( ) ; double S = in . nextDouble ( ) ; double time = ( D - K ) / S ; maxTime = Math . max ( time , maxTime ) ; } double speed = D / maxTime ; out . println ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + speed ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { File inputFile = new File ( \" A - large . in \" ) ; Scanner in = new Scanner ( inputFile ) ; File outputFile = new File ( \" output . txt \" ) ; PrintWriter out = new PrintWriter ( outputFile ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { double D = in . nextDouble ( ) ; int N = in . nextInt ( ) ; double maxTime = 0 ; for ( int n = 0 ; n < N ; n ++ ) { double K = in . nextDouble ( ) ; double S = in . nextDouble ( ) ; double time = ( D - K ) / S ; maxTime = Math . max ( time , maxTime ) ; } double speed = D / maxTime ; out . println ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + speed ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "3", "code": "import static java . lang . Double . parseDouble ; import static java . lang . Integer . parseInt ; import static java . lang . Long . parseLong ; import static java . lang . Math . max ; import static java . lang . System . exit ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . util . Locale ; import java . util . StringTokenizer ; public class A { static BufferedReader in ; static PrintWriter out ; static StringTokenizer tok ; static int test ; static void solve ( ) throws Exception { int d = nextInt ( ) ; int n = nextInt ( ) ; double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int k = nextInt ( ) ; int s = nextInt ( ) ; ans = max ( ans , ( double ) ( d - k ) / s ) ; } printCase ( ) ; out . printf ( Locale . US , \" % .9f \\n \" , d / ans ) ; } static void printCase ( ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; } static void printlnCase ( ) { out . println ( \" Case \u2581 # \" + test + \" : \" ) ; } static int nextInt ( ) throws IOException { return parseInt ( next ( ) ) ; } static long nextLong ( ) throws IOException { return parseLong ( next ( ) ) ; } static double nextDouble ( ) throws IOException { return parseDouble ( next ( ) ) ; } static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) ) ; } return tok . nextToken ( ) ; } public static void main ( String [ ] args ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int tests = nextInt ( ) ; for ( test = 1 ; test <= tests ; test ++ ) { solve ( ) ; } in . close ( ) ; out . close ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; exit ( 1 ) ; } } }", "functions_standalone": [["solve", "static void solve ( ) throws Exception { int d = nextInt ( ) ; int n = nextInt ( ) ; double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int k = nextInt ( ) ; int s = nextInt ( ) ; ans = max ( ans , ( double ) ( d - k ) / s ) ; } printCase ( ) ; out . printf ( Locale . US , \" % .9f \\n \" , d / ans ) ; }"], ["printCase", "static void printCase ( ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; }"], ["printlnCase", "static void printlnCase ( ) { out . println ( \" Case \u2581 # \" + test + \" : \" ) ; }"], ["nextInt", "static int nextInt ( ) throws IOException { return parseInt ( next ( ) ) ; }"], ["nextLong", "static long nextLong ( ) throws IOException { return parseLong ( next ( ) ) ; }"], ["nextDouble", "static double nextDouble ( ) throws IOException { return parseDouble ( next ( ) ) ; }"], ["next", "static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) ) ; } return tok . nextToken ( ) ; }"], ["main", "public static void main ( String [ ] args ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int tests = nextInt ( ) ; for ( test = 1 ; test <= tests ; test ++ ) { solve ( ) ; } in . close ( ) ; out . close ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; exit ( 1 ) ; } }"]], "functions_class": []}, {"id": "17", "code": "package codejam ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Paths ; public class Horse { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" src / codejam / A - large . in \" ) ) ; StringBuilder sb = new StringBuilder ( ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int t_i = 1 ; t_i <= T ; t_i ++ ) { String [ ] split = br . readLine ( ) . split ( \" \u2581 \" ) ; int D = Integer . parseInt ( split [ 0 ] ) ; int N = Integer . parseInt ( split [ 1 ] ) ; int [ ] k = new int [ N ] ; int [ ] s = new int [ N ] ; double latest = 0 ; for ( int n_i = 0 ; n_i < N ; n_i ++ ) { split = br . readLine ( ) . split ( \" \u2581 \" ) ; k [ n_i ] = Integer . parseInt ( split [ 0 ] ) ; s [ n_i ] = Integer . parseInt ( split [ 1 ] ) ; double time = 1. * ( D - k [ n_i ] ) / s [ n_i ] ; if ( time > latest ) latest = time ; } sb . append ( \" Case \u2581 # \" ) . append ( t_i ) . append ( \" : \u2581 \" ) . append ( D / latest ) . append ( \" \\n \" ) ; } Files . write ( Paths . get ( \" src / codejam / horse . out \" ) , sb . toString ( ) . getBytes ( ) ) ; System . out . println ( sb . toString ( ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" src / codejam / A - large . in \" ) ) ; StringBuilder sb = new StringBuilder ( ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int t_i = 1 ; t_i <= T ; t_i ++ ) { String [ ] split = br . readLine ( ) . split ( \" \u2581 \" ) ; int D = Integer . parseInt ( split [ 0 ] ) ; int N = Integer . parseInt ( split [ 1 ] ) ; int [ ] k = new int [ N ] ; int [ ] s = new int [ N ] ; double latest = 0 ; for ( int n_i = 0 ; n_i < N ; n_i ++ ) { split = br . readLine ( ) . split ( \" \u2581 \" ) ; k [ n_i ] = Integer . parseInt ( split [ 0 ] ) ; s [ n_i ] = Integer . parseInt ( split [ 1 ] ) ; double time = 1. * ( D - k [ n_i ] ) / s [ n_i ] ; if ( time > latest ) latest = time ; } sb . append ( \" Case \u2581 # \" ) . append ( t_i ) . append ( \" : \u2581 \" ) . append ( D / latest ) . append ( \" \\n \" ) ; } Files . write ( Paths . get ( \" src / codejam / horse . out \" ) , sb . toString ( ) . getBytes ( ) ) ; System . out . println ( sb . toString ( ) ) ; }"]], "functions_class": []}, {"id": "18", "code": "package Y2017 . r1b ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Scanner ; public class CruiseControl { public static void main ( String [ ] args ) throws FileNotFoundException , UnsupportedEncodingException { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; scanner . nextLine ( ) ; try ( PrintWriter writer = new PrintWriter ( \" solution . txt \" , \" UTF - 8\" ) ) { for ( int i = 1 ; i <= n ; ++ i ) { writer . print ( String . format ( \" Case \u2581 # % d : \u2581 \" , i ) ) ; solve ( scanner , writer ) ; } } } public static void solve ( Scanner scanner , PrintWriter writer ) { int D = scanner . nextInt ( ) ; int N = scanner . nextInt ( ) ; double duration = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int K = scanner . nextInt ( ) ; int S = scanner . nextInt ( ) ; double d = ( D - K ) / ( ( double ) S ) ; duration = Math . max ( duration , d ) ; } writer . println ( D / duration ) ; } }", "functions_standalone": [["solve", "public static void solve ( Scanner scanner , PrintWriter writer ) { int D = scanner . nextInt ( ) ; int N = scanner . nextInt ( ) ; double duration = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int K = scanner . nextInt ( ) ; int S = scanner . nextInt ( ) ; double d = ( D - K ) / ( ( double ) S ) ; duration = Math . max ( duration , d ) ; } writer . println ( D / duration ) ; }"]], "functions_class": [["try", "try ( PrintWriter writer = new PrintWriter ( \" solution . txt \" , \" UTF - 8\" ) ) { for ( int i = 1 ; i <= n ; ++ i ) { writer . print ( String . format ( \" Case \u2581 # % d : \u2581 \" , i ) ) ; solve ( scanner , writer ) ; } }"]]}], "python": [{"id": "15", "code": "def solve ( ) : NEW_LINE INDENT d , n = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 10 ** 100 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k , s = map ( int , input ( ) . split ( ) ) NEW_LINE ans = min ( ans , d * s / ( d - k ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 % .20f \" % ( i + 1 , solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT d , n = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 10 ** 100 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k , s = map ( int , input ( ) . split ( ) ) NEW_LINE ans = min ( ans , d * s / ( d - k ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "def initialize_solver ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT def solve_testcase ( ) : NEW_LINE INDENT d , n = read ( ) NEW_LINE mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k , s = read ( ) NEW_LINE mx = max ( ( d - k ) / s , mx ) NEW_LINE DEDENT return str ( d / mx ) NEW_LINE DEDENT def read ( callback = int , split = True ) : NEW_LINE INDENT if sfile : NEW_LINE INDENT input_line = sfile . readline ( ) . strip ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input_line = input ( ) . strip ( ) NEW_LINE DEDENT if split : NEW_LINE INDENT return list ( map ( callback , input_line . split ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return callback ( input_line ) NEW_LINE DEDENT DEDENT def write ( value = \" \\n \" ) : NEW_LINE INDENT if value is None : return NEW_LINE try : NEW_LINE INDENT if not isinstance ( value , str ) : NEW_LINE INDENT value = \" \u2581 \" . join ( map ( str , value ) ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT if tfile : NEW_LINE INDENT tfile . write ( value ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( value , end = \" \" ) NEW_LINE DEDENT DEDENT output_format = \" Case \u2581 # % d : \u2581 \" NEW_LINE filename = input ( ) . strip ( ) NEW_LINE sfile = None NEW_LINE tfile = None NEW_LINE if filename != \" \" : NEW_LINE INDENT sfile = open ( filename + \" . in \" , \" r \" ) NEW_LINE sfile . seek ( 0 ) NEW_LINE tfile = open ( filename + \" . out \" , \" w \" ) NEW_LINE DEDENT if output_format == None : NEW_LINE INDENT solve_testcase ( ) NEW_LINE DEDENT else : NEW_LINE INDENT initialize_solver ( ) NEW_LINE total_cases , = read ( ) NEW_LINE for case_number in range ( 1 , total_cases + 1 ) : NEW_LINE INDENT write ( output_format . replace ( \" % d \" , str ( case_number ) ) ) NEW_LINE write ( solve_testcase ( ) ) NEW_LINE write ( ) NEW_LINE DEDENT DEDENT if tfile is not None : tfile . close ( ) NEW_LINE", "functions_standalone": [["initialize_solver", "def initialize_solver ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT"], ["solve_testcase", "def solve_testcase ( ) : NEW_LINE INDENT d , n = read ( ) NEW_LINE mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k , s = read ( ) NEW_LINE mx = max ( ( d - k ) / s , mx ) NEW_LINE DEDENT return str ( d / mx ) NEW_LINE DEDENT"], ["read", "def read ( callback = int , split = True ) : NEW_LINE INDENT if sfile : NEW_LINE INDENT input_line = sfile . readline ( ) . strip ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input_line = input ( ) . strip ( ) NEW_LINE DEDENT if split : NEW_LINE INDENT return list ( map ( callback , input_line . split ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return callback ( input_line ) NEW_LINE DEDENT DEDENT"], ["write", "def write ( value = \" \\n \" ) : NEW_LINE INDENT if value is None : return NEW_LINE try : NEW_LINE INDENT if not isinstance ( value , str ) : NEW_LINE INDENT value = \" \u2581 \" . join ( map ( str , value ) ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT if tfile : NEW_LINE INDENT tfile . write ( value ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( value , end = \" \" ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "2", "code": "TEST = ' large ' NEW_LINE IN = ' A - { } . in ' . format ( TEST ) NEW_LINE OUT = ' A - { } . out ' . format ( TEST ) NEW_LINE def run ( d , h ) : NEW_LINE INDENT t = max ( ( d - k ) / s for k , s in h ) NEW_LINE return d / t NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( IN ) as fin , open ( OUT , ' w ' ) as fout : NEW_LINE INDENT t = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT d , n = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE h = [ tuple ( map ( int , fin . readline ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE res = run ( d , h ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , res ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["run", "def run ( d , h ) : NEW_LINE INDENT t = max ( ( d - k ) / s for k , s in h ) NEW_LINE return d / t NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT with open ( IN ) as fin , open ( OUT , ' w ' ) as fout : NEW_LINE INDENT t = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT d , n = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE h = [ tuple ( map ( int , fin . readline ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE res = run ( d , h ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , res ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "16", "code": "with open ( ' A - large . in ' , ' r ' ) as f , open ( ' out . txt ' , ' w ' ) as fout : NEW_LINE INDENT t = int ( f . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , t + 1 ) : NEW_LINE INDENT d , n = [ int ( s ) for s in f . readline ( ) . strip ( ) . split ( ) ] NEW_LINE last_arrive = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ki , si = [ int ( s ) for s in f . readline ( ) . strip ( ) . split ( ) ] NEW_LINE last_arrive = max ( last_arrive , ( ( d - ki ) / si ) ) NEW_LINE DEDENT print ( ' Case \u2581 # % d : \u2581 % .6f ' % ( case , d / last_arrive ) , file = fout ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "6", "code": "def process_test ( test_id ) : NEW_LINE INDENT d , n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE horses = list ( map ( int , input ( ) . split ( ) ) for i in range ( n ) ) NEW_LINE dest_time = max ( ( d - k ) / s for k , s in horses ) NEW_LINE ans = d / dest_time NEW_LINE print ( ' Case \u2581 # { : d } : \u2581 { : . 8f } ' . format ( test_id , ans ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT process_test ( i + 1 ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["process_test", "def process_test ( test_id ) : NEW_LINE INDENT d , n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE horses = list ( map ( int , input ( ) . split ( ) ) for i in range ( n ) ) NEW_LINE dest_time = max ( ( d - k ) / s for k , s in horses ) NEW_LINE ans = d / dest_time NEW_LINE print ( ' Case \u2581 # { : d } : \u2581 { : . 8f } ' . format ( test_id , ans ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_17_31", "java": [{"id": "9", "code": "import java . math . BigDecimal ; import java . util . Arrays ; import java . util . Scanner ; public class ProblemA { public static void main ( String [ ] args ) throws Exception { try ( Scanner sc = new Scanner ( System . in ) ) { int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { solve ( sc , caseNum ) ; } } } static void solve ( Scanner sc , int caseNum ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; P [ ] ps = new P [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { ps [ i ] = new P ( sc . nextInt ( ) , sc . nextInt ( ) ) ; } Arrays . sort ( ps ) ; double max = - 1 ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) { P [ ] ps2 = Arrays . copyOfRange ( ps , i + 1 , N ) ; Arrays . sort ( ps2 , ( p1 , p2 ) -> ( Long . compare ( p2 . H * p2 . R , p1 . H * p1 . R ) ) ) ; double area = Math . PI * ps [ i ] . R * ps [ i ] . R ; area += Math . PI * ps [ i ] . H * ps [ i ] . R * 2 ; for ( int j = 0 ; j < K - 1 ; j ++ ) { area += Math . PI * ps2 [ j ] . H * ps2 [ j ] . R * 2 ; } max = Math . max ( area , max ) ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % .8f \\n \" , caseNum , max ) ; } static class P implements Comparable < P > { long R , H ; public P ( long r , long h ) { super ( ) ; R = r ; H = h ; } @ Override public int compareTo ( P arg0 ) { return Long . compare ( arg0 . R , R ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { try ( Scanner sc = new Scanner ( System . in ) ) { int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { solve ( sc , caseNum ) ; } } }"], ["solve", "static void solve ( Scanner sc , int caseNum ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; P [ ] ps = new P [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { ps [ i ] = new P ( sc . nextInt ( ) , sc . nextInt ( ) ) ; } Arrays . sort ( ps ) ; double max = - 1 ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) { P [ ] ps2 = Arrays . copyOfRange ( ps , i + 1 , N ) ; Arrays . sort ( ps2 , ( p1 , p2 ) -> ( Long . compare ( p2 . H * p2 . R , p1 . H * p1 . R ) ) ) ; double area = Math . PI * ps [ i ] . R * ps [ i ] . R ; area += Math . PI * ps [ i ] . H * ps [ i ] . R * 2 ; for ( int j = 0 ; j < K - 1 ; j ++ ) { area += Math . PI * ps2 [ j ] . H * ps2 [ j ] . R * 2 ; } max = Math . max ( area , max ) ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % .8f \\n \" , caseNum , max ) ; }"]], "functions_class": [["P", "public P ( long r , long h ) { super ( ) ; R = r ; H = h ; }"], ["compareTo", "public int compareTo ( P arg0 ) { return Long . compare ( arg0 . R , R ) ; }"]]}, {"id": "15", "code": "package round1c ; import java . util . ArrayList ; import java . util . List ; public class ProbA extends Prob { void setup ( ) { bin = true ; bout = true ; in = \" A - large . in \" ; out = \" aout - large . txt \" ; } @ Override public void main ( ) { setup ( ) ; reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { double ans = run ( ) ; System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % .9f \" , cas , ans ) ) ; } } double run ( ) { int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; int [ ] [ ] pancake = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { pancake [ i ] [ 0 ] = scanner . nextInt ( ) ; pancake [ i ] [ 1 ] = scanner . nextInt ( ) ; } double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double curr = calcSide ( pancake [ i ] ) + calcArea ( pancake [ i ] [ 0 ] ) ; List < Double > arr = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) if ( j != i ) { if ( pancake [ j ] [ 0 ] <= pancake [ i ] [ 0 ] ) { arr . add ( calcSide ( pancake [ j ] ) ) ; } } if ( arr . size ( ) < k - 1 ) { continue ; } arr . sort ( ( a , b ) -> - Double . compare ( a , b ) ) ; for ( int j = 0 ; j < k - 1 ; j ++ ) { curr += arr . get ( j ) ; } if ( curr > ans ) { ans = curr ; } } return ans ; } private double calcSide ( int [ ] pancake ) { double r = ( double ) pancake [ 0 ] ; double h = ( double ) pancake [ 1 ] ; return 2.0 * r * h * Math . PI ; } private double calcArea ( int r ) { return Math . PI * ( double ) r * ( double ) r ; } }", "functions_standalone": [], "functions_class": [["setup", "void setup ( ) { bin = true ; bout = true ; in = \" A - large . in \" ; out = \" aout - large . txt \" ; }"], ["main", "public void main ( ) { setup ( ) ; reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { double ans = run ( ) ; System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % .9f \" , cas , ans ) ) ; } }"], ["run", "double run ( ) { int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; int [ ] [ ] pancake = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { pancake [ i ] [ 0 ] = scanner . nextInt ( ) ; pancake [ i ] [ 1 ] = scanner . nextInt ( ) ; } double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double curr = calcSide ( pancake [ i ] ) + calcArea ( pancake [ i ] [ 0 ] ) ; List < Double > arr = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) if ( j != i ) { if ( pancake [ j ] [ 0 ] <= pancake [ i ] [ 0 ] ) { arr . add ( calcSide ( pancake [ j ] ) ) ; } } if ( arr . size ( ) < k - 1 ) { continue ; } arr . sort ( ( a , b ) -> - Double . compare ( a , b ) ) ; for ( int j = 0 ; j < k - 1 ; j ++ ) { curr += arr . get ( j ) ; } if ( curr > ans ) { ans = curr ; } } return ans ; }"], ["calcSide", "private double calcSide ( int [ ] pancake ) { double r = ( double ) pancake [ 0 ] ; double h = ( double ) pancake [ 1 ] ; return 2.0 * r * h * Math . PI ; }"], ["calcArea", "private double calcArea ( int r ) { return Math . PI * ( double ) r * ( double ) r ; }"]]}, {"id": "18", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class A { static Pancake [ ] p ; static Double [ ] [ ] memo ; public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; int T = sc . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; memo = new Double [ N + 1 ] [ K + 1 ] ; p = new Pancake [ N ] ; for ( int a = 0 ; a < N ; a ++ ) { p [ a ] = new Pancake ( sc . nextInt ( ) , sc . nextInt ( ) ) ; } Arrays . sort ( p ) ; double ans = DP ( N - 1 , K ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .12f % n \" , t , ans ) ; out . printf ( \" Case \u2581 # % d : \u2581 % .12f % n \" , t , ans ) ; } out . close ( ) ; } private static double DP ( int i , int k ) { if ( i < 0 || k <= 0 ) return 0 ; if ( memo [ i ] [ k ] != null ) return memo [ i ] [ k ] ; double ans = DP ( i - 1 , k - 1 ) ; if ( k == 1 ) { ans += Math . PI * p [ i ] . R * p [ i ] . R ; } ans += 2.0 * Math . PI * p [ i ] . R * p [ i ] . H ; ans = Math . max ( ans , DP ( i - 1 , k ) ) ; return memo [ i ] [ k ] = ans ; } static class Pancake implements Comparable < Pancake > { int R , H ; Pancake ( int a , int b ) { R = a ; H = b ; } @ Override public int compareTo ( Pancake that ) { return ( that . R - this . R ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; int T = sc . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; memo = new Double [ N + 1 ] [ K + 1 ] ; p = new Pancake [ N ] ; for ( int a = 0 ; a < N ; a ++ ) { p [ a ] = new Pancake ( sc . nextInt ( ) , sc . nextInt ( ) ) ; } Arrays . sort ( p ) ; double ans = DP ( N - 1 , K ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .12f % n \" , t , ans ) ; out . printf ( \" Case \u2581 # % d : \u2581 % .12f % n \" , t , ans ) ; } out . close ( ) ; }"], ["DP", "private static double DP ( int i , int k ) { if ( i < 0 || k <= 0 ) return 0 ; if ( memo [ i ] [ k ] != null ) return memo [ i ] [ k ] ; double ans = DP ( i - 1 , k - 1 ) ; if ( k == 1 ) { ans += Math . PI * p [ i ] . R * p [ i ] . R ; } ans += 2.0 * Math . PI * p [ i ] . R * p [ i ] . H ; ans = Math . max ( ans , DP ( i - 1 , k ) ) ; return memo [ i ] [ k ] = ans ; }"]], "functions_class": [["Pancake", "Pancake ( int a , int b ) { R = a ; H = b ; }"], ["compareTo", "public int compareTo ( Pancake that ) { return ( that . R - this . R ) ; }"]]}], "python": [{"id": "15", "code": "import math NEW_LINE class pannukakku : NEW_LINE INDENT radius = 0 NEW_LINE height = 0 NEW_LINE size_h = 0 NEW_LINE size_r = 0 NEW_LINE def size ( self , current_r ) : NEW_LINE INDENT if ( self . radius > current_r ) : NEW_LINE INDENT return self . size_h + self . size_r - math . pi * current_r * current_r ; NEW_LINE DEDENT return self . size_h ; NEW_LINE DEDENT DEDENT def poista_isoin ( kakut , current_r ) : NEW_LINE INDENT isoin_index = 0 ; NEW_LINE isoin_size = kakut [ 0 ] . size ( current_r ) ; NEW_LINE for p in range ( 1 , len ( kakut ) ) : NEW_LINE INDENT if ( kakut [ p ] . size ( current_r ) > isoin_size ) : NEW_LINE INDENT isoin_index = p ; NEW_LINE isoin_size = kakut [ p ] . size ( current_r ) ; NEW_LINE DEDENT DEDENT return kakut . pop ( isoin_index ) ; NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT pannukakkuja , tilauksen_koko = [ int ( s ) for s in input ( ) . split ( \" \u2581 \" ) ] ; NEW_LINE radiuses = [ 0 for h in range ( pannukakkuja ) ] NEW_LINE heigths = [ 0 for h in range ( pannukakkuja ) ] NEW_LINE sizes = [ 0 for h in range ( pannukakkuja ) ] NEW_LINE kakut = [ pannukakku ( ) for h in range ( pannukakkuja ) ] NEW_LINE for h in range ( 0 , pannukakkuja ) : NEW_LINE INDENT r , s = [ int ( s ) for s in input ( ) . split ( \" \u2581 \" ) ] ; NEW_LINE kakut [ h ] . radius = r ; NEW_LINE kakut [ h ] . heigth = s ; NEW_LINE kakut [ h ] . size_h = math . pi * 2 * r * s ; NEW_LINE kakut [ h ] . size_r = math . pi * r * r ; NEW_LINE DEDENT total = 0 ; NEW_LINE current_r = 0 ; NEW_LINE for p in range ( tilauksen_koko ) : NEW_LINE INDENT isoin = poista_isoin ( kakut , current_r ) ; NEW_LINE total += isoin . size ( current_r ) ; NEW_LINE current_r = max ( current_r , isoin . radius ) ; NEW_LINE DEDENT print ( \" Case \u2581 # { 0 : . 0f } : \u2581 { 1 : . 6f } \" . format ( i , total ) ) ; NEW_LINE DEDENT", "functions_standalone": [["poista_isoin", "def poista_isoin ( kakut , current_r ) : NEW_LINE INDENT isoin_index = 0 ; NEW_LINE isoin_size = kakut [ 0 ] . size ( current_r ) ; NEW_LINE for p in range ( 1 , len ( kakut ) ) : NEW_LINE INDENT if ( kakut [ p ] . size ( current_r ) > isoin_size ) : NEW_LINE INDENT isoin_index = p ; NEW_LINE isoin_size = kakut [ p ] . size ( current_r ) ; NEW_LINE DEDENT DEDENT return kakut . pop ( isoin_index ) ; NEW_LINE DEDENT"]], "functions_class": [["size", "def size ( self , current_r ) : NEW_LINE INDENT if ( self . radius > current_r ) : NEW_LINE INDENT return self . size_h + self . size_r - math . pi * current_r * current_r ; NEW_LINE DEDENT return self . size_h ; NEW_LINE DEDENT"]]}, {"id": "19", "code": "import itertools NEW_LINE import math NEW_LINE def score ( stack ) : NEW_LINE INDENT syrup = math . pi * max ( x [ 0 ] for x in stack ) ** 2 NEW_LINE for item in stack : NEW_LINE INDENT syrup += 2 * math . pi * item [ 0 ] * item [ 1 ] NEW_LINE DEDENT return syrup NEW_LINE DEDENT def ring_score ( item ) : NEW_LINE INDENT return 2 * math . pi * item [ 0 ] * item [ 1 ] NEW_LINE DEDENT def solve ( pancakes , k ) : NEW_LINE INDENT return max ( itertools . combinations ( pancakes , k ) , key = score ) NEW_LINE DEDENT with open ( ' A - large . in ' ) as infile : NEW_LINE INDENT with open ( ' A - large . out ' , ' w ' ) as outfile : NEW_LINE INDENT cases = int ( next ( infile ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT n , k = map ( int , next ( infile ) . split ( ) ) NEW_LINE pancakes = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT pancakes . append ( tuple ( map ( int , next ( infile ) . split ( ) ) ) ) NEW_LINE DEDENT pancakes . sort ( key = ring_score , reverse = True ) NEW_LINE preliminary = pancakes [ : k ] NEW_LINE remaining = pancakes [ k : ] NEW_LINE curr_score = score ( preliminary ) NEW_LINE if remaining : NEW_LINE INDENT other_score = score ( preliminary [ : - 1 ] + [ max ( remaining ) ] ) NEW_LINE if other_score > curr_score : NEW_LINE INDENT curr_score = other_score NEW_LINE DEDENT DEDENT print ( case , curr_score ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , curr_score ) , file = outfile ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["score", "def score ( stack ) : NEW_LINE INDENT syrup = math . pi * max ( x [ 0 ] for x in stack ) ** 2 NEW_LINE for item in stack : NEW_LINE INDENT syrup += 2 * math . pi * item [ 0 ] * item [ 1 ] NEW_LINE DEDENT return syrup NEW_LINE DEDENT"], ["ring_score", "def ring_score ( item ) : NEW_LINE INDENT return 2 * math . pi * item [ 0 ] * item [ 1 ] NEW_LINE DEDENT"], ["solve", "def solve ( pancakes , k ) : NEW_LINE INDENT return max ( itertools . combinations ( pancakes , k ) , key = score ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT tt = I ( ) NEW_LINE rr = [ ] NEW_LINE for ti in range ( 1 , tt + 1 ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT b , c = LI ( ) NEW_LINE m = b * b * math . pi NEW_LINE l = b * 2 * math . pi * c NEW_LINE a . append ( [ b , m , l ] ) NEW_LINE DEDENT a = sorted ( a , reverse = True ) NEW_LINE r = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT tr = a [ i ] [ 1 ] + a [ i ] [ 2 ] NEW_LINE ta = sorted ( a [ i + 1 : ] , key = lambda x : - x [ 2 ] ) NEW_LINE tr += sum ( map ( lambda x : x [ 2 ] , ta [ : k - 1 ] ) ) NEW_LINE if r < tr : NEW_LINE INDENT r = tr NEW_LINE DEDENT DEDENT rr . append ( ' Case \u2581 # { } : \u2581 { } ' . format ( ti , r ) ) NEW_LINE DEDENT return ' \\n ' . join ( rr ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE", "functions_standalone": [["LI", "def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT tt = I ( ) NEW_LINE rr = [ ] NEW_LINE for ti in range ( 1 , tt + 1 ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT b , c = LI ( ) NEW_LINE m = b * b * math . pi NEW_LINE l = b * 2 * math . pi * c NEW_LINE a . append ( [ b , m , l ] ) NEW_LINE DEDENT a = sorted ( a , reverse = True ) NEW_LINE r = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT tr = a [ i ] [ 1 ] + a [ i ] [ 2 ] NEW_LINE ta = sorted ( a [ i + 1 : ] , key = lambda x : - x [ 2 ] ) NEW_LINE tr += sum ( map ( lambda x : x [ 2 ] , ta [ : k - 1 ] ) ) NEW_LINE if r < tr : NEW_LINE INDENT r = tr NEW_LINE DEDENT DEDENT rr . append ( ' Case \u2581 # { } : \u2581 { } ' . format ( ti , r ) ) NEW_LINE DEDENT return ' \\n ' . join ( rr ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "import math NEW_LINE filename = \" A - large . in \" NEW_LINE f = open ( filename , ' r ' ) NEW_LINE out = open ( \" output . txt \" , ' w ' ) NEW_LINE Cases = int ( f . readline ( ) ) NEW_LINE for T in range ( Cases ) : NEW_LINE INDENT [ N , K ] = [ int ( j ) for j in f . readline ( ) . split ( \" \u2581 \" ) ] NEW_LINE C = [ [ int ( j ) for j in f . readline ( ) . split ( \" \u2581 \" ) ] for i in range ( N ) ] NEW_LINE C = [ [ C [ i ] [ 0 ] , C [ i ] [ 1 ] , 2 * C [ i ] [ 0 ] * C [ i ] [ 1 ] ] for i in range ( len ( C ) ) ] NEW_LINE C = sorted ( C , key = lambda x : - x [ 2 ] ) NEW_LINE maxR = 0 NEW_LINE side = 0 NEW_LINE for i in range ( K - 1 ) : NEW_LINE INDENT maxR = max ( maxR , C [ i ] [ 0 ] ) NEW_LINE side += C [ i ] [ 2 ] NEW_LINE DEDENT cura = maxR ** 2 + side NEW_LINE maxA = cura NEW_LINE for i in range ( K - 1 , N ) : NEW_LINE INDENT maxA = max ( maxA , cura + C [ i ] [ 2 ] + max ( 0 , C [ i ] [ 0 ] ** 2 - maxR ** 2 ) ) NEW_LINE DEDENT ret = str ( math . pi * maxA ) NEW_LINE ret = \" Case \u2581 # \" + str ( T + 1 ) + \" : \u2581 \" + ret NEW_LINE print ( ret ) NEW_LINE out . write ( ret + \" \\n \" ) NEW_LINE DEDENT f . close ( ) NEW_LINE out . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "5", "code": "import sys NEW_LINE import math NEW_LINE def problem ( pancakes , order_size ) : NEW_LINE INDENT pancakes . sort ( key = lambda x : 2 * math . pi * x [ 0 ] * x [ 1 ] , reverse = True ) NEW_LINE take = pancakes [ : order_size - 1 ] NEW_LINE if len ( take ) != 0 : NEW_LINE INDENT max_radius = max ( x [ 0 ] for x in take ) NEW_LINE DEDENT else : NEW_LINE INDENT max_radius = 0 NEW_LINE DEDENT outsides = sum ( 2 * math . pi * x [ 0 ] * x [ 1 ] for x in take ) NEW_LINE best = 0 NEW_LINE for n in pancakes [ order_size - 1 : ] : NEW_LINE INDENT radius = max ( max_radius , n [ 0 ] ) NEW_LINE size = outsides + 2 * math . pi * n [ 0 ] * n [ 1 ] + math . pi * radius * radius NEW_LINE best = max ( best , size ) NEW_LINE DEDENT return best NEW_LINE DEDENT def nextline ( input_file ) : NEW_LINE INDENT data = \" \" NEW_LINE while not data : NEW_LINE INDENT data = input_file . readline ( ) NEW_LINE DEDENT return data [ : - 1 ] NEW_LINE DEDENT def intsplit ( s ) : NEW_LINE INDENT return [ int ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT result = \" \" NEW_LINE with sys . stdin if len ( sys . argv ) == 1 else open ( sys . argv [ 1 ] , ' r ' ) as infile : NEW_LINE INDENT number = int ( nextline ( infile ) ) NEW_LINE for run in range ( number ) : NEW_LINE INDENT case = nextline ( infile ) NEW_LINE size , order_size = intsplit ( case ) NEW_LINE pancakes = [ ] NEW_LINE for _ in range ( size ) : NEW_LINE INDENT pancakes . append ( intsplit ( nextline ( infile ) ) ) NEW_LINE DEDENT result += ' Case \u2581 # { } : \u2581 { } \\n ' . format ( 1 + run , problem ( pancakes , order_size ) ) NEW_LINE DEDENT DEDENT if len ( sys . argv ) == 1 : NEW_LINE INDENT print ( result , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT with open ( sys . argv [ 1 ] . replace ( ' in ' , ' sol ' ) , ' w ' ) as result_file : NEW_LINE INDENT result_file . write ( result ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["problem", "def problem ( pancakes , order_size ) : NEW_LINE INDENT pancakes . sort ( key = lambda x : 2 * math . pi * x [ 0 ] * x [ 1 ] , reverse = True ) NEW_LINE take = pancakes [ : order_size - 1 ] NEW_LINE if len ( take ) != 0 : NEW_LINE INDENT max_radius = max ( x [ 0 ] for x in take ) NEW_LINE DEDENT else : NEW_LINE INDENT max_radius = 0 NEW_LINE DEDENT outsides = sum ( 2 * math . pi * x [ 0 ] * x [ 1 ] for x in take ) NEW_LINE best = 0 NEW_LINE for n in pancakes [ order_size - 1 : ] : NEW_LINE INDENT radius = max ( max_radius , n [ 0 ] ) NEW_LINE size = outsides + 2 * math . pi * n [ 0 ] * n [ 1 ] + math . pi * radius * radius NEW_LINE best = max ( best , size ) NEW_LINE DEDENT return best NEW_LINE DEDENT"], ["nextline", "def nextline ( input_file ) : NEW_LINE INDENT data = \" \" NEW_LINE while not data : NEW_LINE INDENT data = input_file . readline ( ) NEW_LINE DEDENT return data [ : - 1 ] NEW_LINE DEDENT"], ["intsplit", "def intsplit ( s ) : NEW_LINE INDENT return [ int ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT result = \" \" NEW_LINE with sys . stdin if len ( sys . argv ) == 1 else open ( sys . argv [ 1 ] , ' r ' ) as infile : NEW_LINE INDENT number = int ( nextline ( infile ) ) NEW_LINE for run in range ( number ) : NEW_LINE INDENT case = nextline ( infile ) NEW_LINE size , order_size = intsplit ( case ) NEW_LINE pancakes = [ ] NEW_LINE for _ in range ( size ) : NEW_LINE INDENT pancakes . append ( intsplit ( nextline ( infile ) ) ) NEW_LINE DEDENT result += ' Case \u2581 # { } : \u2581 { } \\n ' . format ( 1 + run , problem ( pancakes , order_size ) ) NEW_LINE DEDENT DEDENT if len ( sys . argv ) == 1 : NEW_LINE INDENT print ( result , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT with open ( sys . argv [ 1 ] . replace ( ' in ' , ' sol ' ) , ' w ' ) as result_file : NEW_LINE INDENT result_file . write ( result ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_17_01", "java": [{"id": "5", "code": "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; int testCount = Integer . parseInt ( in . next ( ) ) ; for ( int i = 1 ; i <= testCount ; i ++ ) solver . solve ( i , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , InputReader in , PrintWriter out ) { char [ ] s = in . next ( ) . toCharArray ( ) ; int k = in . nextInt ( ) ; int n = s . length ; int ret = 0 ; for ( int i = 0 ; i + k <= n ; i ++ ) { if ( s [ i ] == ' - ' ) { ++ ret ; for ( int j = 0 ; j < k ; j ++ ) { s [ i + j ] = ( char ) ( ' + ' + ' - ' - s [ i + j ] ) ; } } } out . printf ( \" Case \u2581 # % d : \u2581 \" , testNumber ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' + ' ) { out . println ( \" IMPOSSIBLE \" ) ; return ; } } out . println ( ret ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; int testCount = Integer . parseInt ( in . next ( ) ) ; for ( int i = 1 ; i <= testCount ; i ++ ) solver . solve ( i , in , out ) ; out . close ( ) ; }"]], "functions_class": [["solve", "public void solve ( int testNumber , InputReader in , PrintWriter out ) { char [ ] s = in . next ( ) . toCharArray ( ) ; int k = in . nextInt ( ) ; int n = s . length ; int ret = 0 ; for ( int i = 0 ; i + k <= n ; i ++ ) { if ( s [ i ] == ' - ' ) { ++ ret ; for ( int j = 0 ; j < k ; j ++ ) { s [ i + j ] = ( char ) ( ' + ' + ' - ' - s [ i + j ] ) ; } } } out . printf ( \" Case \u2581 # % d : \u2581 \" , testNumber ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' + ' ) { out . println ( \" IMPOSSIBLE \" ) ; return ; } } out . println ( ret ) ; }"], ["InputReader", "public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; }"], ["next", "public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }"]]}, {"id": "6", "code": "import java . util . * ; class A { static int solve ( ) { int [ ] str = in . next ( ) . chars ( ) . map ( ( i ) -> i == ' + ' ? 0 : 1 ) . toArray ( ) ; int size = in . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < str . length - size + 1 ; ++ i ) { if ( str [ i ] != 0 ) { count ++ ; for ( int j = i ; j < i + size ; ++ j ) { str [ j ] = str [ j ] == 1 ? 0 : 1 ; } } } for ( int i = str . length - size + 1 ; i < str . length ; ++ i ) { if ( str [ i ] != 0 ) return - 1 ; } return count ; } static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; ++ t ) { int c = solve ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , t + 1 , c >= 0 ? Integer . toString ( c ) : \" IMPOSSIBLE \" ) ; } } }", "functions_standalone": [["solve", "static int solve ( ) { int [ ] str = in . next ( ) . chars ( ) . map ( ( i ) -> i == ' + ' ? 0 : 1 ) . toArray ( ) ; int size = in . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < str . length - size + 1 ; ++ i ) { if ( str [ i ] != 0 ) { count ++ ; for ( int j = i ; j < i + size ; ++ j ) { str [ j ] = str [ j ] == 1 ? 0 : 1 ; } } } for ( int i = str . length - size + 1 ; i < str . length ; ++ i ) { if ( str [ i ] != 0 ) return - 1 ; } return count ; }"], ["main", "public static void main ( String [ ] args ) { int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; ++ t ) { int c = solve ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , t + 1 , c >= 0 ? Integer . toString ( c ) : \" IMPOSSIBLE \" ) ; } }"]], "functions_class": []}, {"id": "18", "code": "package com . company ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . PrintStream ; import java . util . Scanner ; public class Main { private static Scanner scanner = new Scanner ( System . in ) ; static private void reDirect ( ) { try { FileInputStream fileInputStream = new FileInputStream ( \" A - large . in \" ) ; scanner = new Scanner ( fileInputStream ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" a - out - large . txt \" ) ) ; System . setOut ( ps ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) { reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { int ans = run ( ) ; System . out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + ( ans < 0 ? \" IMPOSSIBLE \" : ans ) ) ; } } static private int run ( ) { String s = scanner . next ( ) ; int k = scanner . nextInt ( ) ; char [ ] arr = s . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == ' - ' ) { if ( i + k > arr . length ) { return - 1 ; } count ++ ; for ( int j = i ; j < i + k ; j ++ ) { arr [ j ] = ( arr [ j ] == ' + ' ? ' - ' : ' + ' ) ; } } } return count ; } }", "functions_standalone": [["reDirect", "static private void reDirect ( ) { try { FileInputStream fileInputStream = new FileInputStream ( \" A - large . in \" ) ; scanner = new Scanner ( fileInputStream ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" a - out - large . txt \" ) ) ; System . setOut ( ps ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }"], ["main", "public static void main ( String [ ] args ) { reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { int ans = run ( ) ; System . out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + ( ans < 0 ? \" IMPOSSIBLE \" : ans ) ) ; } }"], ["run", "static private int run ( ) { String s = scanner . next ( ) ; int k = scanner . nextInt ( ) ; char [ ] arr = s . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == ' - ' ) { if ( i + k > arr . length ) { return - 1 ; } count ++ ; for ( int j = i ; j < i + k ; j ++ ) { arr [ j ] = ( arr [ j ] == ' + ' ? ' - ' : ' + ' ) ; } } } return count ; }"]], "functions_class": []}, {"id": "2", "code": "package qualifier ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; public class AOversizedPancakeFlipper { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ) { int tests = sc . nextInt ( ) ; outer : for ( int t = 1 ; t <= tests ; t ++ ) { char [ ] happyChars = sc . next ( ) . toCharArray ( ) ; int spatWidth = sc . nextInt ( ) ; boolean [ ] happy = new boolean [ happyChars . length ] ; for ( int x = 0 ; x < happy . length ; x ++ ) happy [ x ] = happyChars [ x ] == ' + ' ; List < Integer > flipPoints = new LinkedList < Integer > ( ) ; int flipCount = 0 ; boolean flipped = false ; for ( int x = 0 ; x <= happy . length - spatWidth ; x ++ ) { if ( ! flipPoints . isEmpty ( ) && flipPoints . get ( 0 ) == x ) { flipPoints . remove ( 0 ) ; flipped = ! flipped ; } boolean current = happy [ x ] != flipped ; if ( ! current ) { flipped = ! flipped ; flipCount ++ ; flipPoints . add ( x + spatWidth ) ; } } for ( int x = happy . length - spatWidth + 1 ; x < happy . length ; x ++ ) { if ( ! flipPoints . isEmpty ( ) && flipPoints . get ( 0 ) == x ) { flipPoints . remove ( 0 ) ; flipped = ! flipped ; } if ( happy [ x ] == flipped ) { System . out . printf ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE % n \" , t ) ; continue outer ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , t , flipCount ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ) { int tests = sc . nextInt ( ) ; outer : for ( int t = 1 ; t <= tests ; t ++ ) { char [ ] happyChars = sc . next ( ) . toCharArray ( ) ; int spatWidth = sc . nextInt ( ) ; boolean [ ] happy = new boolean [ happyChars . length ] ; for ( int x = 0 ; x < happy . length ; x ++ ) happy [ x ] = happyChars [ x ] == ' + ' ; List < Integer > flipPoints = new LinkedList < Integer > ( ) ; int flipCount = 0 ; boolean flipped = false ; for ( int x = 0 ; x <= happy . length - spatWidth ; x ++ ) { if ( ! flipPoints . isEmpty ( ) && flipPoints . get ( 0 ) == x ) { flipPoints . remove ( 0 ) ; flipped = ! flipped ; } boolean current = happy [ x ] != flipped ; if ( ! current ) { flipped = ! flipped ; flipCount ++ ; flipPoints . add ( x + spatWidth ) ; } } for ( int x = happy . length - spatWidth + 1 ; x < happy . length ; x ++ ) { if ( ! flipPoints . isEmpty ( ) && flipPoints . get ( 0 ) == x ) { flipPoints . remove ( 0 ) ; flipped = ! flipped ; } if ( happy [ x ] == flipped ) { System . out . printf ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE % n \" , t ) ; continue outer ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , t , flipCount ) ; } } }"]], "functions_class": []}, {"id": "3", "code": "import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" solve . txt \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; StringTokenizer s ; for ( int i = 1 ; i <= T ; i ++ ) { s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; String S = s . nextToken ( ) ; int K = Integer . parseInt ( s . nextToken ( ) ) ; int len = S . length ( ) ; int num = 0 ; boolean ok = true ; int [ ] data = new int [ len ] ; for ( int j = 0 ; j <= len - K ; j ++ ) { if ( ( S . charAt ( j ) == ' - ' && data [ j ] % 2 == 0 ) || ( S . charAt ( j ) == ' + ' && data [ j ] % 2 == 1 ) ) { num ++ ; for ( int k = 1 ; k < K ; k ++ ) { data [ j + k ] ++ ; } } } for ( int j = len - K + 1 ; j < len ; j ++ ) { if ( ( S . charAt ( j ) == ' - ' && data [ j ] % 2 == 0 ) || ( S . charAt ( j ) == ' + ' && data [ j ] % 2 == 1 ) ) { ok = false ; break ; } } bw . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; if ( ok ) { bw . write ( num + \" \\n \" ) ; } else { bw . write ( \" IMPOSSIBLE \\n \" ) ; } } br . close ( ) ; bw . close ( ) ; return ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" solve . txt \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; StringTokenizer s ; for ( int i = 1 ; i <= T ; i ++ ) { s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; String S = s . nextToken ( ) ; int K = Integer . parseInt ( s . nextToken ( ) ) ; int len = S . length ( ) ; int num = 0 ; boolean ok = true ; int [ ] data = new int [ len ] ; for ( int j = 0 ; j <= len - K ; j ++ ) { if ( ( S . charAt ( j ) == ' - ' && data [ j ] % 2 == 0 ) || ( S . charAt ( j ) == ' + ' && data [ j ] % 2 == 1 ) ) { num ++ ; for ( int k = 1 ; k < K ; k ++ ) { data [ j + k ] ++ ; } } } for ( int j = len - K + 1 ; j < len ; j ++ ) { if ( ( S . charAt ( j ) == ' - ' && data [ j ] % 2 == 0 ) || ( S . charAt ( j ) == ' + ' && data [ j ] % 2 == 1 ) ) { ok = false ; break ; } } bw . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; if ( ok ) { bw . write ( num + \" \\n \" ) ; } else { bw . write ( \" IMPOSSIBLE \\n \" ) ; } } br . close ( ) ; bw . close ( ) ; return ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "infilecode = \" ALI \" NEW_LINE import sys NEW_LINE mapping = { \" A \" : \" A \" , \" B \" : \" B \" , \" C \" : \" C \" , \" D \" : \" D \" , \" E \" : \" E \" , \" X \" : \" example \" , \" S \" : \" - small \" , \" L \" : \" - large \" , \" P \" : \" - practice \" , \"0\" : \" - attempt0\" , \"1\" : \" - attempt1\" , \"2\" : \" - attempt2\" , \" I \" : \" . in \" , \" T \" : \" . txt \" } NEW_LINE infile = \" \" . join ( mapping [ c ] for c in infilecode ) NEW_LINE outfile = infile . replace ( \" . in \" , \" \" ) + \" . out . txt \" NEW_LINE sys . stdin = open ( infile , ' r ' ) NEW_LINE output = open ( outfile , ' w ' ) NEW_LINE T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT S , K = input ( ) . split ( ) NEW_LINE print ( S , K ) NEW_LINE K = int ( K ) NEW_LINE S = list ( S ) NEW_LINE L = len ( S ) NEW_LINE flips = 0 NEW_LINE for i in range ( L - K + 1 ) : NEW_LINE INDENT if S [ i ] == \" - \" : NEW_LINE INDENT flips += 1 NEW_LINE for j in range ( i , i + K ) : NEW_LINE INDENT S [ j ] = { \" + \" : \" - \" , \" - \" : \" + \" } [ S [ j ] ] NEW_LINE DEDENT DEDENT DEDENT if S == [ \" + \" ] * L : NEW_LINE INDENT answer = flips NEW_LINE DEDENT else : NEW_LINE INDENT answer = \" IMPOSSIBLE \" NEW_LINE DEDENT print ( \" Case \u2581 # % d : \" % case , answer ) NEW_LINE print ( \" Case \u2581 # % d : \" % case , answer , file = output ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "def flip ( row ) : NEW_LINE INDENT return row . translate ( str . maketrans ( ' - + ' , ' + - ' ) ) NEW_LINE DEDENT def solve ( row , k ) : NEW_LINE INDENT flips = 0 NEW_LINE for i in range ( len ( row ) ) : NEW_LINE INDENT if row [ i ] == ' - ' and i + k <= len ( row ) : NEW_LINE INDENT row = row [ : i ] + flip ( row [ i : i + k ] ) + row [ i + k : ] NEW_LINE flips += 1 NEW_LINE DEDENT DEDENT if ' - ' in row : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT return flips NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for ti in range ( t ) : NEW_LINE INDENT row , k = input ( ) . split ( \" \u2581 \" ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( ti + 1 , solve ( row , int ( k ) ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["flip", "def flip ( row ) : NEW_LINE INDENT return row . translate ( str . maketrans ( ' - + ' , ' + - ' ) ) NEW_LINE DEDENT"], ["solve", "def solve ( row , k ) : NEW_LINE INDENT flips = 0 NEW_LINE for i in range ( len ( row ) ) : NEW_LINE INDENT if row [ i ] == ' - ' and i + k <= len ( row ) : NEW_LINE INDENT row = row [ : i ] + flip ( row [ i : i + k ] ) + row [ i + k : ] NEW_LINE flips += 1 NEW_LINE DEDENT DEDENT if ' - ' in row : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT return flips NEW_LINE DEDENT DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for ti in range ( t ) : NEW_LINE INDENT row , k = input ( ) . split ( \" \u2581 \" ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( ti + 1 , solve ( row , int ( k ) ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "3", "code": "from __future__ import print_function NEW_LINE import sys NEW_LINE from sys import stdin NEW_LINE def eprint ( * args , ** kwargs ) : NEW_LINE INDENT print ( * args , file = sys . stderr , ** kwargs ) NEW_LINE DEDENT def ln ( f = int ) : NEW_LINE INDENT return list ( map ( f , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT T , = ln ( ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE for test in range ( T ) : NEW_LINE INDENT s , K = ln ( str ) NEW_LINE K = int ( K ) NEW_LINE s = [ 0 if c == \" + \" else 1 for c in s ] NEW_LINE best = 0 NEW_LINE for i in range ( len ( s ) - K + 1 ) : NEW_LINE INDENT if s [ i ] != 0 : NEW_LINE INDENT for j in range ( i , i + K ) : NEW_LINE INDENT s [ j ] ^= 1 NEW_LINE DEDENT best += 1 NEW_LINE DEDENT DEDENT if sum ( s ) != 0 : NEW_LINE INDENT best = \" IMPOSSIBLE \" NEW_LINE DEDENT print ( \" Case \u2581 # \" + str ( test + 1 ) + \" : \u2581 \" + str ( best ) ) NEW_LINE DEDENT", "functions_standalone": [["eprint", "def eprint ( * args , ** kwargs ) : NEW_LINE INDENT print ( * args , file = sys . stderr , ** kwargs ) NEW_LINE DEDENT"], ["ln", "def ln ( f = int ) : NEW_LINE INDENT return list ( map ( f , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "import sys NEW_LINE import numpy as np NEW_LINE def solve ( state , K ) : NEW_LINE INDENT N = len ( state ) NEW_LINE xs = np . array ( [ 1 if s == ' + ' else 0 for s in state ] ) NEW_LINE ret = 0 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT if xs [ i ] == 0 : NEW_LINE INDENT ret += 1 NEW_LINE xs [ i : i + K ] = 1 - xs [ i : i + K ] NEW_LINE DEDENT DEDENT if xs [ - K : ] . sum ( ) == K : NEW_LINE INDENT return \" % d \" % ret NEW_LINE DEDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fd_input = open ( sys . argv [ 1 ] ) NEW_LINE fd_output = open ( sys . argv [ 1 ] . replace ( \" . in \" , \" . out \" ) , \" w \" ) NEW_LINE T = int ( fd_input . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = fd_input . readline ( ) . strip ( ) . split ( \" \u2581 \" ) NEW_LINE sol = solve ( line [ 0 ] , int ( line [ 1 ] ) ) NEW_LINE fd_output . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( t + 1 , sol ) ) NEW_LINE DEDENT fd_input . close ( ) NEW_LINE fd_output . close ( ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( state , K ) : NEW_LINE INDENT N = len ( state ) NEW_LINE xs = np . array ( [ 1 if s == ' + ' else 0 for s in state ] ) NEW_LINE ret = 0 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT if xs [ i ] == 0 : NEW_LINE INDENT ret += 1 NEW_LINE xs [ i : i + K ] = 1 - xs [ i : i + K ] NEW_LINE DEDENT DEDENT if xs [ - K : ] . sum ( ) == K : NEW_LINE INDENT return \" % d \" % ret NEW_LINE DEDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def solve ( data , k ) : NEW_LINE INDENT l = len ( data ) NEW_LINE if l == k : NEW_LINE INDENT if data == [ \" + \" ] * k : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif data == [ \" - \" ] * k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if l < k : NEW_LINE INDENT if data == [ \" + \" ] * l : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT flips = 0 NEW_LINE if data [ 0 ] == ' - ' : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT if data [ i ] == \" + \" : NEW_LINE INDENT data [ i ] = \" - \" NEW_LINE DEDENT else : NEW_LINE INDENT data [ i ] = \" + \" NEW_LINE DEDENT DEDENT flips = 1 NEW_LINE DEDENT result = solve ( data [ 1 : ] , k ) NEW_LINE if result < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result + flips NEW_LINE DEDENT t = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT n , m = [ s for s in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE data = list ( str ( n ) ) NEW_LINE k = int ( m ) NEW_LINE result = solve ( data , k ) NEW_LINE if result == - 1 : NEW_LINE INDENT result = \" IMPOSSIBLE \" NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i , result ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( data , k ) : NEW_LINE INDENT l = len ( data ) NEW_LINE if l == k : NEW_LINE INDENT if data == [ \" + \" ] * k : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif data == [ \" - \" ] * k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if l < k : NEW_LINE INDENT if data == [ \" + \" ] * l : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT flips = 0 NEW_LINE if data [ 0 ] == ' - ' : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT if data [ i ] == \" + \" : NEW_LINE INDENT data [ i ] = \" - \" NEW_LINE DEDENT else : NEW_LINE INDENT data [ i ] = \" + \" NEW_LINE DEDENT DEDENT flips = 1 NEW_LINE DEDENT result = solve ( data [ 1 : ] , k ) NEW_LINE if result < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result + flips NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_17_41", "java": [{"id": "11", "code": "package round2 ; import java . util . Scanner ; public class A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int P = sc . nextInt ( ) ; int [ ] cant = new int [ P ] ; for ( int i = 0 ; i < N ; i ++ ) { cant [ sc . nextInt ( ) % P ] ++ ; } int ans = cant [ 0 ] ; if ( P == 2 ) { ans += ( cant [ 1 ] + 1 ) / 2 ; } else if ( P == 3 ) { ans += Math . min ( cant [ 1 ] , cant [ 2 ] ) ; int left = Math . max ( cant [ 1 ] , cant [ 2 ] ) - Math . min ( cant [ 1 ] , cant [ 2 ] ) ; ans += ( left + 2 ) / 3 ; } else { ans += Math . min ( cant [ 1 ] , cant [ 3 ] ) ; int left = Math . max ( cant [ 1 ] , cant [ 3 ] ) - Math . min ( cant [ 1 ] , cant [ 3 ] ) ; ans += cant [ 2 ] / 2 ; boolean extra2 = cant [ 2 ] % 2 == 1 ; if ( left >= 2 && extra2 ) { ans ++ ; left -= 2 ; extra2 = false ; } if ( extra2 ) left ++ ; ans += ( left + 3 ) / 4 ; } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int P = sc . nextInt ( ) ; int [ ] cant = new int [ P ] ; for ( int i = 0 ; i < N ; i ++ ) { cant [ sc . nextInt ( ) % P ] ++ ; } int ans = cant [ 0 ] ; if ( P == 2 ) { ans += ( cant [ 1 ] + 1 ) / 2 ; } else if ( P == 3 ) { ans += Math . min ( cant [ 1 ] , cant [ 2 ] ) ; int left = Math . max ( cant [ 1 ] , cant [ 2 ] ) - Math . min ( cant [ 1 ] , cant [ 2 ] ) ; ans += ( left + 2 ) / 3 ; } else { ans += Math . min ( cant [ 1 ] , cant [ 3 ] ) ; int left = Math . max ( cant [ 1 ] , cant [ 3 ] ) - Math . min ( cant [ 1 ] , cant [ 3 ] ) ; ans += cant [ 2 ] / 2 ; boolean extra2 = cant [ 2 ] % 2 == 1 ; if ( left >= 2 && extra2 ) { ans ++ ; left -= 2 ; extra2 = false ; } if ( extra2 ) left ++ ; ans += ( left + 3 ) / 4 ; } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ans ) ; } }"]], "functions_class": []}, {"id": "17", "code": "import java . util . * ; class A { public static void main ( String [ ] arg ) { Scanner sc = new Scanner ( System . in ) ; int TT = sc . nextInt ( ) ; for ( int ii = 1 ; ii <= TT ; ++ ii ) { int N = sc . nextInt ( ) ; int P = sc . nextInt ( ) ; int [ ] M = new int [ 5 ] ; for ( int i = 0 ; i < N ; ++ i ) { int G = sc . nextInt ( ) ; M [ G % P ] ++ ; } int ans = 1 + M [ 0 ] ; if ( P == 2 ) { ans += M [ 1 ] / 2 ; if ( M [ 1 ] % 2 == 0 ) ans -- ; } else if ( P == 3 ) { int min = Math . min ( M [ 1 ] , M [ 2 ] ) ; int left = Math . max ( M [ 1 ] , M [ 2 ] ) - min ; if ( left % 3 == 0 ) ans -- ; left /= 3 ; ans += min + left ; } else if ( P == 4 ) { while ( M [ 2 ] >= 2 ) { ans ++ ; M [ 2 ] -= 2 ; } while ( M [ 1 ] > 0 && M [ 3 ] > 0 ) { ans ++ ; M [ 1 ] -- ; M [ 3 ] -- ; } if ( M [ 2 ] == 1 ) { if ( M [ 1 ] % 4 >= 2 ) { ans ++ ; M [ 1 ] -= 2 ; M [ 2 ] -- ; } else if ( M [ 3 ] % 4 >= 2 ) { ans ++ ; M [ 3 ] -= 2 ; M [ 2 ] -- ; } } int threes = M [ 3 ] / 4 ; int ones = M [ 1 ] / 4 ; ans += threes + ones ; if ( M [ 1 ] % 4 == 0 && M [ 3 ] % 4 == 0 && M [ 2 ] % 2 == 0 ) { ans -- ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , ii , ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] arg ) { Scanner sc = new Scanner ( System . in ) ; int TT = sc . nextInt ( ) ; for ( int ii = 1 ; ii <= TT ; ++ ii ) { int N = sc . nextInt ( ) ; int P = sc . nextInt ( ) ; int [ ] M = new int [ 5 ] ; for ( int i = 0 ; i < N ; ++ i ) { int G = sc . nextInt ( ) ; M [ G % P ] ++ ; } int ans = 1 + M [ 0 ] ; if ( P == 2 ) { ans += M [ 1 ] / 2 ; if ( M [ 1 ] % 2 == 0 ) ans -- ; } else if ( P == 3 ) { int min = Math . min ( M [ 1 ] , M [ 2 ] ) ; int left = Math . max ( M [ 1 ] , M [ 2 ] ) - min ; if ( left % 3 == 0 ) ans -- ; left /= 3 ; ans += min + left ; } else if ( P == 4 ) { while ( M [ 2 ] >= 2 ) { ans ++ ; M [ 2 ] -= 2 ; } while ( M [ 1 ] > 0 && M [ 3 ] > 0 ) { ans ++ ; M [ 1 ] -- ; M [ 3 ] -- ; } if ( M [ 2 ] == 1 ) { if ( M [ 1 ] % 4 >= 2 ) { ans ++ ; M [ 1 ] -= 2 ; M [ 2 ] -- ; } else if ( M [ 3 ] % 4 >= 2 ) { ans ++ ; M [ 3 ] -= 2 ; M [ 2 ] -- ; } } int threes = M [ 3 ] / 4 ; int ones = M [ 1 ] / 4 ; ans += threes + ones ; if ( M [ 1 ] % 4 == 0 && M [ 3 ] % 4 == 0 && M [ 2 ] % 2 == 0 ) { ans -- ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , ii , ans ) ; } }"]], "functions_class": []}, {"id": "6", "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; } void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { int N = cin . nextInt ( ) ; int P = cin . nextInt ( ) ; int count [ ] = new int [ P ] ; for ( int i = 0 ; i < N ; ++ i ) { ++ count [ cin . nextInt ( ) % P ] ; } int ret = count [ 0 ] ; count [ 0 ] = 0 ; if ( P == 2 ) { ret += ( count [ 1 ] + 1 ) / 2 ; } else if ( P == 3 ) { int min = Math . min ( count [ 1 ] , count [ 2 ] ) ; ret += min ; count [ 1 ] -= min ; count [ 2 ] -= min ; ret += ( count [ 1 ] + 2 ) / 3 ; ret += ( count [ 2 ] + 2 ) / 3 ; } else if ( P == 4 ) { { int two = Math . min ( count [ 1 ] , count [ 3 ] ) ; ret += two ; count [ 1 ] -= two ; count [ 3 ] -= two ; } { int two = count [ 2 ] / 2 ; ret += two ; count [ 2 ] -= two * 2 ; } { int three = Math . min ( count [ 2 ] , Math . max ( count [ 1 ] / 2 , count [ 3 ] / 2 ) ) ; ret += three ; count [ 2 ] -= three ; if ( count [ 1 ] > 0 ) { count [ 1 ] -= three * 2 ; } if ( count [ 3 ] > 0 ) { count [ 3 ] -= three * 2 ; } } { if ( count [ 1 ] > 0 || count [ 2 ] > 0 || count [ 3 ] > 0 ) { ++ ret ; } } } System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + ret ) ; } cin . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { int N = cin . nextInt ( ) ; int P = cin . nextInt ( ) ; int count [ ] = new int [ P ] ; for ( int i = 0 ; i < N ; ++ i ) { ++ count [ cin . nextInt ( ) % P ] ; } int ret = count [ 0 ] ; count [ 0 ] = 0 ; if ( P == 2 ) { ret += ( count [ 1 ] + 1 ) / 2 ; } else if ( P == 3 ) { int min = Math . min ( count [ 1 ] , count [ 2 ] ) ; ret += min ; count [ 1 ] -= min ; count [ 2 ] -= min ; ret += ( count [ 1 ] + 2 ) / 3 ; ret += ( count [ 2 ] + 2 ) / 3 ; } else if ( P == 4 ) { { int two = Math . min ( count [ 1 ] , count [ 3 ] ) ; ret += two ; count [ 1 ] -= two ; count [ 3 ] -= two ; } { int two = count [ 2 ] / 2 ; ret += two ; count [ 2 ] -= two * 2 ; } { int three = Math . min ( count [ 2 ] , Math . max ( count [ 1 ] / 2 , count [ 3 ] / 2 ) ) ; ret += three ; count [ 2 ] -= three ; if ( count [ 1 ] > 0 ) { count [ 1 ] -= three * 2 ; } if ( count [ 3 ] > 0 ) { count [ 3 ] -= three * 2 ; } } { if ( count [ 1 ] > 0 || count [ 2 ] > 0 || count [ 3 ] > 0 ) { ++ ret ; } } } System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + ret ) ; } cin . close ( ) ; }"]]}], "python": [{"id": "15", "code": "import numpy as np NEW_LINE inname = \" input . txt \" NEW_LINE outname = \" output . txt \" NEW_LINE with open ( inname , ' r ' ) as f : NEW_LINE INDENT cases = int ( f . readline ( ) ) NEW_LINE for tc in range ( 1 , cases + 1 ) : NEW_LINE INDENT line = f . readline ( ) . strip ( ) . split ( ' \u2581 ' ) NEW_LINE N = int ( line [ 0 ] ) NEW_LINE P = int ( line [ 1 ] ) NEW_LINE Pi = [ ] NEW_LINE R = [ 0 ] * P NEW_LINE line = f . readline ( ) . strip ( ) . split ( ' \u2581 ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT Pi . append ( int ( line [ i ] ) ) NEW_LINE R [ Pi [ i ] % P ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE if P == 2 : NEW_LINE INDENT ans = R [ 0 ] + ( R [ 1 ] + 1 ) // 2 NEW_LINE DEDENT elif P == 3 : NEW_LINE INDENT ans = R [ 0 ] NEW_LINE if R [ 1 ] < R [ 2 ] : NEW_LINE INDENT a = R [ 1 ] NEW_LINE b = R [ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = R [ 2 ] NEW_LINE b = R [ 1 ] NEW_LINE DEDENT ans += a NEW_LINE b -= a NEW_LINE ans += ( b + 2 ) // 3 NEW_LINE DEDENT else : NEW_LINE INDENT ans = R [ 0 ] NEW_LINE if R [ 1 ] < R [ 3 ] : NEW_LINE INDENT a = R [ 1 ] NEW_LINE b = R [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = R [ 3 ] NEW_LINE b = R [ 1 ] NEW_LINE DEDENT c = R [ 2 ] NEW_LINE ans += c // 2 NEW_LINE c %= 2 NEW_LINE ans += a NEW_LINE b -= a NEW_LINE if c == 1 and b >= 2 : NEW_LINE INDENT c -= 1 NEW_LINE b -= 2 NEW_LINE ans += 1 NEW_LINE DEDENT ans += b // 4 NEW_LINE b %= 4 NEW_LINE if c + b > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( tc , ans ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "10", "code": "def maximizeFreshChocolate ( N , P , groups ) : NEW_LINE INDENT remainingGroups = groups NEW_LINE result = 0 NEW_LINE while len ( remainingGroups ) > 0 : NEW_LINE INDENT optimalSets = { } NEW_LINE optimalCounts = { } NEW_LINE for index in xrange ( len ( remainingGroups ) ) : NEW_LINE INDENT tempOptimalSets = { } NEW_LINE tempOptimalCounts = { } NEW_LINE for remainder in optimalCounts : NEW_LINE INDENT possibleRemainder = ( remainder + remainingGroups [ index ] ) % P NEW_LINE if optimalCounts [ remainder ] + 1 < tempOptimalCounts . get ( possibleRemainder , 10 ** 18 ) : NEW_LINE INDENT tempOptimalSets [ possibleRemainder ] = optimalSets [ remainder ] + [ index ] NEW_LINE tempOptimalCounts [ possibleRemainder ] = optimalCounts [ remainder ] + 1 NEW_LINE DEDENT DEDENT tempOptimalSets [ remainingGroups [ index ] % P ] = [ index ] NEW_LINE tempOptimalCounts [ remainingGroups [ index ] % P ] = 1 NEW_LINE for remainder in tempOptimalCounts : NEW_LINE INDENT if tempOptimalCounts [ remainder ] < optimalCounts . get ( remainder , 10 ** 18 ) : NEW_LINE INDENT optimalSets [ remainder ] = tempOptimalSets [ remainder ] NEW_LINE optimalCounts [ remainder ] = tempOptimalCounts [ remainder ] NEW_LINE DEDENT DEDENT DEDENT if 0 in optimalCounts : NEW_LINE INDENT result += 1 NEW_LINE remainingGroups = [ remainingGroups [ i ] for i in xrange ( len ( remainingGroups ) ) if i not in optimalSets [ 0 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT return result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT with open ( ' . . / inputs / A - large . in ' ) as infile : NEW_LINE INDENT with open ( ' . . / outputs / A - large . out ' , ' wb ' ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for i in xrange ( cases ) : NEW_LINE INDENT [ N , P ] = map ( int , infile . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE groups = map ( int , infile . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE outfile . write ( ' Case \u2581 # ' + str ( i + 1 ) + ' : \u2581 ' ) NEW_LINE outfile . write ( str ( maximizeFreshChocolate ( N , P , groups ) ) ) NEW_LINE outfile . write ( ' \\n ' ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "14", "code": "inputF = open ( ' A - large . in ' , ' r ' ) NEW_LINE output = open ( ' A - large . out ' , ' w ' ) NEW_LINE numCases = int ( inputF . readline ( ) ) NEW_LINE def getFreshGroups ( groups , p ) : NEW_LINE INDENT count = 0 NEW_LINE groups = [ i % p for i in groups ] NEW_LINE count += groups . count ( 0 ) NEW_LINE groups = [ g for g in groups if g != 0 ] NEW_LINE if p == 2 and len ( groups ) > 0 : NEW_LINE INDENT count += ( len ( groups ) + 1 ) / 2 NEW_LINE DEDENT elif p == 3 and len ( groups ) > 0 : NEW_LINE INDENT minMod = min ( groups . count ( 1 ) , groups . count ( 2 ) ) NEW_LINE count += minMod NEW_LINE remaining = max ( groups . count ( 1 ) , groups . count ( 2 ) ) - min ( groups . count ( 1 ) , groups . count ( 2 ) ) NEW_LINE count += ( remaining + 2 ) / 3 NEW_LINE DEDENT elif p == 4 and len ( groups ) > 0 : NEW_LINE INDENT count += ( groups . count ( 2 ) ) / 2 NEW_LINE extraTwo = ( ( groups . count ( 2 ) % 2 ) == 1 ) NEW_LINE minMod = min ( groups . count ( 1 ) , groups . count ( 3 ) ) NEW_LINE count += minMod NEW_LINE remaining = max ( groups . count ( 1 ) , groups . count ( 3 ) ) - min ( groups . count ( 1 ) , groups . count ( 3 ) ) NEW_LINE if extraTwo : NEW_LINE INDENT count += 1 + ( remaining + 1 ) / 4 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( remaining + 3 ) / 4 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( numCases ) : NEW_LINE INDENT n , p = inputF . readline ( ) . split ( ) NEW_LINE groups = [ int ( j ) for j in inputF . readline ( ) . split ( ) ] NEW_LINE numFresh = getFreshGroups ( groups , int ( p ) ) NEW_LINE output . write ( ' Case \u2581 # ' + str ( i + 1 ) + ' : \u2581 ' + str ( numFresh ) + ' \\n ' ) NEW_LINE DEDENT inputF . close ( ) NEW_LINE output . close ( ) NEW_LINE", "functions_standalone": [["getFreshGroups", "def getFreshGroups ( groups , p ) : NEW_LINE INDENT count = 0 NEW_LINE groups = [ i % p for i in groups ] NEW_LINE count += groups . count ( 0 ) NEW_LINE groups = [ g for g in groups if g != 0 ] NEW_LINE if p == 2 and len ( groups ) > 0 : NEW_LINE INDENT count += ( len ( groups ) + 1 ) / 2 NEW_LINE DEDENT elif p == 3 and len ( groups ) > 0 : NEW_LINE INDENT minMod = min ( groups . count ( 1 ) , groups . count ( 2 ) ) NEW_LINE count += minMod NEW_LINE remaining = max ( groups . count ( 1 ) , groups . count ( 2 ) ) - min ( groups . count ( 1 ) , groups . count ( 2 ) ) NEW_LINE count += ( remaining + 2 ) / 3 NEW_LINE DEDENT elif p == 4 and len ( groups ) > 0 : NEW_LINE INDENT count += ( groups . count ( 2 ) ) / 2 NEW_LINE extraTwo = ( ( groups . count ( 2 ) % 2 ) == 1 ) NEW_LINE minMod = min ( groups . count ( 1 ) , groups . count ( 3 ) ) NEW_LINE count += minMod NEW_LINE remaining = max ( groups . count ( 1 ) , groups . count ( 3 ) ) - min ( groups . count ( 1 ) , groups . count ( 3 ) ) NEW_LINE if extraTwo : NEW_LINE INDENT count += 1 + ( remaining + 1 ) / 4 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( remaining + 3 ) / 4 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "from itertools import * NEW_LINE from collections import * NEW_LINE from functools import * NEW_LINE from operator import floordiv , mul , sub NEW_LINE strategies = { 2 : [ ( 1 , ( 1 , 0 ) ) , ( 1 , ( 0 , 2 ) ) ] , 3 : [ ( 1 , ( 1 , 0 , 0 ) ) , ( 1 , ( 0 , 1 , 1 ) ) , ( 1 , ( 0 , 3 , 0 ) ) , ( 1 , ( 0 , 0 , 3 ) ) ] , 4 : [ ( 1 , ( 1 , 0 , 0 , 0 ) ) , ( 1 , ( 0 , 1 , 0 , 1 ) ) , ( 1 , ( 0 , 0 , 2 , 0 ) ) , ( 1 , ( 0 , 2 , 1 , 0 ) ) , ( 1 , ( 0 , 0 , 1 , 2 ) ) , ( 1 , ( 0 , 4 , 0 , 0 ) ) , ( 1 , ( 0 , 0 , 0 , 4 ) ) , ] } NEW_LINE T = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 \" . format ( t + 1 ) , end = \" \" ) NEW_LINE ngroups , packsize = map ( int , input ( ) . strip ( ) . split ( \" \u2581 \" ) ) NEW_LINE groups = map ( int , input ( ) . strip ( ) . split ( \" \u2581 \" ) ) NEW_LINE strategy = strategies [ packsize ] NEW_LINE modgroups = list ( repeat ( 0 , packsize ) ) NEW_LINE for i in groups : NEW_LINE INDENT modgroups [ i % packsize ] += 1 NEW_LINE DEDENT score = 0 NEW_LINE for value , operation in strategy : NEW_LINE INDENT repetitions = min ( map ( lambda a , b : a // b if b != 0 else float ( ' inf ' ) , modgroups , operation ) ) NEW_LINE modgroups = list ( map ( sub , modgroups , map ( mul , operation , repeat ( repetitions ) ) ) ) NEW_LINE score += value * repetitions NEW_LINE DEDENT if sum ( modgroups ) > 0 : NEW_LINE INDENT score += 1 NEW_LINE DEDENT print ( score ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "8", "code": "from math import ceil , floor NEW_LINE numInputs = int ( input ( ) ) NEW_LINE for i in range ( numInputs ) : NEW_LINE INDENT N , P = [ int ( num ) for num in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE G = [ int ( num ) for num in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE numsMod = { } NEW_LINE for j in range ( P ) : NEW_LINE INDENT numsMod [ j ] = 0 NEW_LINE DEDENT for g in G : NEW_LINE INDENT numsMod [ g % P ] += 1 NEW_LINE DEDENT if P == 2 : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( numsMod [ 0 ] + ceil ( numsMod [ 1 ] / 2.0 ) ) ) NEW_LINE continue NEW_LINE DEDENT if P == 3 : NEW_LINE INDENT smaller = min ( numsMod [ 1 ] , numsMod [ 2 ] ) NEW_LINE larger = max ( numsMod [ 1 ] , numsMod [ 2 ] ) NEW_LINE diff = larger - smaller NEW_LINE print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( numsMod [ 0 ] + smaller + ceil ( diff / 3.0 ) ) ) NEW_LINE continue NEW_LINE DEDENT total = numsMod [ 0 ] NEW_LINE total += floor ( numsMod [ 2 ] / 2.0 ) NEW_LINE smaller = min ( numsMod [ 1 ] , numsMod [ 3 ] ) NEW_LINE larger = max ( numsMod [ 1 ] , numsMod [ 3 ] ) NEW_LINE diff = larger - smaller NEW_LINE total += smaller NEW_LINE if numsMod [ 2 ] % 2 == 1 : NEW_LINE INDENT total += 1 NEW_LINE if diff > 2 : NEW_LINE INDENT total += ceil ( ( diff - 2 ) / 4.0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT total += ceil ( diff / 4.0 ) NEW_LINE DEDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( total ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_10_03", "java": [{"id": "4", "code": "package qualification . c ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintStream ; import java . util . Scanner ; public class CLarge { Scanner in ; public CLarge ( ) { in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int l = 1 ; l <= t ; l ++ ) { int r = in . nextInt ( ) ; int k = in . nextInt ( ) ; int n = in . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . nextInt ( ) ; } int [ ] nextGroup = new int [ n ] ; long [ ] money = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { long space = k ; int pointer = i ; long total = 0 ; int srcPointer = pointer ; while ( space >= arr [ pointer ] ) { space -= arr [ pointer ] ; total += arr [ pointer ] ; if ( ( pointer + 1 ) % n == srcPointer ) { break ; } pointer = ( pointer + 1 ) % n ; } nextGroup [ i ] = pointer ; money [ i ] = total ; } int group = 0 ; long total = 0 ; for ( int i = 0 ; i < r ; i ++ ) { total += money [ group ] ; group = nextGroup [ group ] ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , l , total ) ; } } public static void main ( String [ ] args ) { try { String p = \" C - large - practice \" ; System . setIn ( CLarge . class . getResourceAsStream ( p + \" . in \" ) ) ; System . setOut ( new PrintStream ( new File ( \" src / qualification / c / \" + p + \" . out \" ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } new CLarge ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { String p = \" C - large - practice \" ; System . setIn ( CLarge . class . getResourceAsStream ( p + \" . in \" ) ) ; System . setOut ( new PrintStream ( new File ( \" src / qualification / c / \" + p + \" . out \" ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } new CLarge ( ) ; }"]], "functions_class": [["CLarge", "public CLarge ( ) { in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int l = 1 ; l <= t ; l ++ ) { int r = in . nextInt ( ) ; int k = in . nextInt ( ) ; int n = in . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . nextInt ( ) ; } int [ ] nextGroup = new int [ n ] ; long [ ] money = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { long space = k ; int pointer = i ; long total = 0 ; int srcPointer = pointer ; while ( space >= arr [ pointer ] ) { space -= arr [ pointer ] ; total += arr [ pointer ] ; if ( ( pointer + 1 ) % n == srcPointer ) { break ; } pointer = ( pointer + 1 ) % n ; } nextGroup [ i ] = pointer ; money [ i ] = total ; } int group = 0 ; long total = 0 ; for ( int i = 0 ; i < r ; i ++ ) { total += money [ group ] ; group = nextGroup [ group ] ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , l , total ) ; } }"]]}, {"id": "10", "code": "import java . io . IOException ; public class ProblemC extends CodeJammer { @ Override public void process ( ) throws IOException { long [ ] line1 = reader . readLongArray ( ) ; long r = line1 [ 0 ] ; long k = line1 [ 1 ] ; int n = ( int ) line1 [ 2 ] ; long [ ] g = reader . readLongArray ( ) ; int depth = ( int ) ( Math . log ( r ) / Math . log ( 2 ) ) + 2 ; int [ ] [ ] indexReached = new int [ depth ] [ n ] ; long [ ] [ ] riders = new long [ depth ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { long boarded = 0 ; int next = i ; do { boarded += g [ next ] ; next ++ ; if ( next >= n ) next -= n ; } while ( next != i && boarded + g [ next ] <= k ) ; indexReached [ 0 ] [ i ] = next ; riders [ 0 ] [ i ] = boarded ; } for ( int d = 1 ; d < depth ; d ++ ) { for ( int i = 0 ; i < n ; i ++ ) { int middleIndex = indexReached [ d - 1 ] [ i ] ; indexReached [ d ] [ i ] = indexReached [ d - 1 ] [ middleIndex ] ; riders [ d ] [ i ] = riders [ d - 1 ] [ i ] + riders [ d - 1 ] [ middleIndex ] ; } } long ridesLeft = r ; long total = 0 ; int nextIndex = 0 ; while ( ridesLeft > 0 ) { long chunk = 1 ; int d = 0 ; while ( 2 * chunk <= ridesLeft ) { chunk *= 2 ; d += 1 ; } ridesLeft -= chunk ; total += riders [ d ] [ nextIndex ] ; nextIndex = indexReached [ d ] [ nextIndex ] ; } output ( total ) ; } public static void main ( String [ ] args ) { ProblemC p = new ProblemC ( ) ; p . run ( args ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { ProblemC p = new ProblemC ( ) ; p . run ( args ) ; }"]], "functions_class": [["process", "public void process ( ) throws IOException { long [ ] line1 = reader . readLongArray ( ) ; long r = line1 [ 0 ] ; long k = line1 [ 1 ] ; int n = ( int ) line1 [ 2 ] ; long [ ] g = reader . readLongArray ( ) ; int depth = ( int ) ( Math . log ( r ) / Math . log ( 2 ) ) + 2 ; int [ ] [ ] indexReached = new int [ depth ] [ n ] ; long [ ] [ ] riders = new long [ depth ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { long boarded = 0 ; int next = i ; do { boarded += g [ next ] ; next ++ ; if ( next >= n ) next -= n ; } while ( next != i && boarded + g [ next ] <= k ) ; indexReached [ 0 ] [ i ] = next ; riders [ 0 ] [ i ] = boarded ; } for ( int d = 1 ; d < depth ; d ++ ) { for ( int i = 0 ; i < n ; i ++ ) { int middleIndex = indexReached [ d - 1 ] [ i ] ; indexReached [ d ] [ i ] = indexReached [ d - 1 ] [ middleIndex ] ; riders [ d ] [ i ] = riders [ d - 1 ] [ i ] + riders [ d - 1 ] [ middleIndex ] ; } } long ridesLeft = r ; long total = 0 ; int nextIndex = 0 ; while ( ridesLeft > 0 ) { long chunk = 1 ; int d = 0 ; while ( 2 * chunk <= ridesLeft ) { chunk *= 2 ; d += 1 ; } ridesLeft -= chunk ; total += riders [ d ] [ nextIndex ] ; nextIndex = indexReached [ d ] [ nextIndex ] ; } output ( total ) ; }"]]}, {"id": "12", "code": "import java . io . * ; import java . lang . * ; public class ThemePark { public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintStream out = new PrintStream ( new FileOutputStream ( \" C - large . out \" ) ) ; long T = Integer . parseInt ( in . readLine ( ) ) ; String [ ] s ; long R , k ; int N ; long [ ] g = new long [ 1000 ] , value = new long [ 1000 ] ; int [ ] next = new int [ 1000 ] ; for ( int cas = 1 ; cas <= T ; ++ cas ) { s = in . readLine ( ) . split ( \" \u2581 \" ) ; R = Long . parseLong ( s [ 0 ] ) ; k = Long . parseLong ( s [ 1 ] ) ; N = Integer . parseInt ( s [ 2 ] ) ; s = in . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < N ; ++ i ) g [ i ] = Long . parseLong ( s [ i ] ) ; for ( int i = 0 ; i < N ; ++ i ) { value [ i ] = g [ i ] ; next [ i ] = ( i + 1 ) % N ; while ( next [ i ] != i && value [ i ] + g [ next [ i ] ] <= k ) { value [ i ] += g [ next [ i ] ] ; next [ i ] = ( next [ i ] + 1 ) % N ; } } long euros = 0 ; int group = 0 ; for ( int i = 0 ; i < R ; ++ i ) { euros += value [ group ] ; group = next [ group ] ; } out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + euros ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintStream out = new PrintStream ( new FileOutputStream ( \" C - large . out \" ) ) ; long T = Integer . parseInt ( in . readLine ( ) ) ; String [ ] s ; long R , k ; int N ; long [ ] g = new long [ 1000 ] , value = new long [ 1000 ] ; int [ ] next = new int [ 1000 ] ; for ( int cas = 1 ; cas <= T ; ++ cas ) { s = in . readLine ( ) . split ( \" \u2581 \" ) ; R = Long . parseLong ( s [ 0 ] ) ; k = Long . parseLong ( s [ 1 ] ) ; N = Integer . parseInt ( s [ 2 ] ) ; s = in . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < N ; ++ i ) g [ i ] = Long . parseLong ( s [ i ] ) ; for ( int i = 0 ; i < N ; ++ i ) { value [ i ] = g [ i ] ; next [ i ] = ( i + 1 ) % N ; while ( next [ i ] != i && value [ i ] + g [ next [ i ] ] <= k ) { value [ i ] += g [ next [ i ] ] ; next [ i ] = ( next [ i ] + 1 ) % N ; } } long euros = 0 ; int group = 0 ; for ( int i = 0 ; i < R ; ++ i ) { euros += value [ group ] ; group = next [ group ] ; } out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + euros ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": []}, {"id": "3", "code": "import java . util . * ; import java . io . * ; public class Solution { public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int T = sc . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { System . out . println ( \" case \u2581 \" + t ) ; pw . print ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" ) ; int R = sc . nextInt ( ) ; long k = sc . nextLong ( ) ; int N = sc . nextInt ( ) ; long [ ] g = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) g [ i ] = sc . nextLong ( ) ; int [ ] next = new int [ N ] ; long [ ] add = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int cur = i ; long free = k ; while ( free >= g [ cur ] ) { free -= g [ cur ] ; cur ++ ; if ( cur == N ) cur = 0 ; if ( cur == i ) break ; } next [ i ] = cur ; add [ i ] = k - free ; } long res = 0 ; int cur = 0 ; for ( int i = 0 ; i < R ; i ++ ) { res += add [ cur ] ; cur = next [ cur ] ; } pw . println ( res ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; }"]], "functions_class": [["doMain", "public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int T = sc . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { System . out . println ( \" case \u2581 \" + t ) ; pw . print ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" ) ; int R = sc . nextInt ( ) ; long k = sc . nextLong ( ) ; int N = sc . nextInt ( ) ; long [ ] g = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) g [ i ] = sc . nextLong ( ) ; int [ ] next = new int [ N ] ; long [ ] add = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int cur = i ; long free = k ; while ( free >= g [ cur ] ) { free -= g [ cur ] ; cur ++ ; if ( cur == N ) cur = 0 ; if ( cur == i ) break ; } next [ i ] = cur ; add [ i ] = k - free ; } long res = 0 ; int cur = 0 ; for ( int i = 0 ; i < R ; i ++ ) { res += add [ cur ] ; cur = next [ cur ] ; } pw . println ( res ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]]}, {"id": "6", "code": "import static java . lang . System . * ; import java . util . * ; class Main { public static void main ( String [ ] arg ) { Scanner sc = new Scanner ( in ) ; int tcc = sc . nextInt ( ) ; for ( int tc = 1 ; tc <= tcc ; ++ tc ) { int r = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = sc . nextInt ( ) ; long ans = 0 ; long [ ] score = new long [ n ] ; int [ ] vis = new int [ n ] ; int pos = 0 ; while ( r > 0 ) { if ( vis != null && score != null ) { if ( vis [ pos ] != 0 ) { int len = vis [ pos ] - r ; long change = ans - score [ pos ] ; int reps = r / len ; if ( reps > 0 ) { r -= len * reps ; ans += change * reps ; } vis = null ; score = null ; continue ; } score [ pos ] = ans ; vis [ pos ] = r ; } int s = k ; int g = 0 ; while ( s >= arr [ pos ] && g < n ) { s -= arr [ pos ] ; pos = ( pos + 1 ) % n ; ++ g ; } ans += k - s ; -- r ; } out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , tc , ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] arg ) { Scanner sc = new Scanner ( in ) ; int tcc = sc . nextInt ( ) ; for ( int tc = 1 ; tc <= tcc ; ++ tc ) { int r = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = sc . nextInt ( ) ; long ans = 0 ; long [ ] score = new long [ n ] ; int [ ] vis = new int [ n ] ; int pos = 0 ; while ( r > 0 ) { if ( vis != null && score != null ) { if ( vis [ pos ] != 0 ) { int len = vis [ pos ] - r ; long change = ans - score [ pos ] ; int reps = r / len ; if ( reps > 0 ) { r -= len * reps ; ans += change * reps ; } vis = null ; score = null ; continue ; } score [ pos ] = ans ; vis [ pos ] = r ; } int s = k ; int g = 0 ; while ( s >= arr [ pos ] && g < n ) { s -= arr [ pos ] ; pos = ( pos + 1 ) % n ; ++ g ; } ans += k - s ; -- r ; } out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , tc , ans ) ; } }"]], "functions_class": []}], "python": [{"id": "19", "code": "from __future__ import division NEW_LINE from __future__ import print_function NEW_LINE import sys NEW_LINE def solve ( R , k , N , groups ) : NEW_LINE INDENT groups = list ( groups ) NEW_LINE total = sum ( groups ) NEW_LINE if total < k : NEW_LINE INDENT return total * R NEW_LINE DEDENT d = { } NEW_LINE for i , g in enumerate ( groups ) : NEW_LINE INDENT current = g NEW_LINE j = i NEW_LINE while True : NEW_LINE INDENT j = ( j + 1 ) % N NEW_LINE nextg = groups [ j ] NEW_LINE if ( current + nextg > k ) or ( j == i ) : NEW_LINE INDENT break NEW_LINE DEDENT current += nextg NEW_LINE DEDENT d [ i ] = current , j NEW_LINE DEDENT money = 0 NEW_LINE start = 0 NEW_LINE history = [ ] NEW_LINE moneyhistory = [ ] NEW_LINE for i in xrange ( R ) : NEW_LINE INDENT history . append ( start ) NEW_LINE moneyhistory . append ( money ) NEW_LINE dmoney , dstart = d [ start ] NEW_LINE money += dmoney NEW_LINE start = dstart NEW_LINE if start in history : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return money NEW_LINE DEDENT index = history . index ( start ) NEW_LINE initmoney = moneyhistory [ index ] NEW_LINE cyclemoney = money - initmoney NEW_LINE cyclesize = len ( history ) - index NEW_LINE numcycles = int ( ( R - index ) / cyclesize ) NEW_LINE money = initmoney + cyclemoney * numcycles NEW_LINE for i in xrange ( R - numcycles * cyclesize - index ) : NEW_LINE INDENT dmoney , dstart = d [ start ] NEW_LINE money += dmoney NEW_LINE start = dstart NEW_LINE DEDENT return money NEW_LINE DEDENT def main ( filename ) : NEW_LINE INDENT with open ( filename , \" r \" ) as f : NEW_LINE INDENT for case , line in enumerate ( f ) : NEW_LINE INDENT if not case : NEW_LINE INDENT T = int ( line . strip ( ) ) NEW_LINE continue NEW_LINE DEDENT if case > T : NEW_LINE INDENT break NEW_LINE DEDENT R , k , N = ( int ( c ) for c in line . split ( ) ) NEW_LINE line = next ( f ) NEW_LINE groups = ( int ( c ) for c in line . split ( ) ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , solve ( R , k , N , groups ) ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( sys . argv [ 1 ] ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT", "functions_standalone": [["main", "def main ( filename ) : NEW_LINE INDENT with open ( filename , \" r \" ) as f : NEW_LINE INDENT for case , line in enumerate ( f ) : NEW_LINE INDENT if not case : NEW_LINE INDENT T = int ( line . strip ( ) ) NEW_LINE continue NEW_LINE DEDENT if case > T : NEW_LINE INDENT break NEW_LINE DEDENT R , k , N = ( int ( c ) for c in line . split ( ) ) NEW_LINE line = next ( f ) NEW_LINE groups = ( int ( c ) for c in line . split ( ) ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , solve ( R , k , N , groups ) ) ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "16", "code": "def calc ( r , k , size ) : NEW_LINE INDENT n = len ( size ) NEW_LINE history = { } NEW_LINE money = [ ] NEW_LINE pos = 0 NEW_LINE for round in xrange ( r ) : NEW_LINE INDENT if pos in history : NEW_LINE INDENT repeat = money [ history [ pos ] : ] NEW_LINE l = len ( repeat ) NEW_LINE remain = r - round NEW_LINE final = ( remain / l ) * sum ( repeat ) + sum ( repeat [ : remain % l ] ) + sum ( money ) NEW_LINE return final NEW_LINE DEDENT history [ pos ] = len ( money ) NEW_LINE m = 0 NEW_LINE start = pos NEW_LINE while True : NEW_LINE INDENT if m + size [ pos ] > k : NEW_LINE INDENT break NEW_LINE DEDENT m += size [ pos ] NEW_LINE pos = ( pos + 1 ) % n NEW_LINE if pos == start : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT money . append ( m ) NEW_LINE DEDENT return sum ( money ) NEW_LINE DEDENT def work ( name ) : NEW_LINE INDENT f = open ( name + \" . in \" ) NEW_LINE out = open ( name + \" . out \" , ' w ' ) NEW_LINE case_max = int ( f . readline ( ) ) NEW_LINE for caseno in xrange ( 1 , case_max + 1 ) : NEW_LINE INDENT out . write ( \" Case \u2581 # % d : \u2581 \" % caseno ) NEW_LINE r , k , n = map ( int , f . readline ( ) . split ( ) ) NEW_LINE size = map ( int , f . readline ( ) . split ( ) ) NEW_LINE out . write ( \" % d \\n \" % calc ( r , k , size ) ) NEW_LINE DEDENT f . close ( ) NEW_LINE out . close ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT work ( \" C - large \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_10_32", "java": [{"id": "19", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class b { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; String str ; int numCases = Integer . parseInt ( br . readLine ( ) ) ; for ( int nCase = 1 ; nCase <= numCases ; nCase ++ ) { String [ ] sa = br . readLine ( ) . split ( \" \u2581 \" ) ; int L = Integer . parseInt ( sa [ 0 ] ) ; int P = Integer . parseInt ( sa [ 1 ] ) ; int C = Integer . parseInt ( sa [ 2 ] ) ; double R = ( double ) P / L ; int count = 0 ; while ( R > C ) { R = Math . sqrt ( R ) ; count ++ ; } System . out . println ( \" Case \u2581 # \" + nCase + \" : \u2581 \" + count ) ; } br . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; String str ; int numCases = Integer . parseInt ( br . readLine ( ) ) ; for ( int nCase = 1 ; nCase <= numCases ; nCase ++ ) { String [ ] sa = br . readLine ( ) . split ( \" \u2581 \" ) ; int L = Integer . parseInt ( sa [ 0 ] ) ; int P = Integer . parseInt ( sa [ 1 ] ) ; int C = Integer . parseInt ( sa [ 2 ] ) ; double R = ( double ) P / L ; int count = 0 ; while ( R > C ) { R = Math . sqrt ( R ) ; count ++ ; } System . out . println ( \" Case \u2581 # \" + nCase + \" : \u2581 \" + count ) ; } br . close ( ) ; }"]], "functions_class": []}, {"id": "11", "code": "package round_1B_2010 ; import java . io . File ; import java . io . FileWriter ; import java . util . Scanner ; public class LoadTestingR { public static void main ( String [ ] args ) { Scanner reader = new Scanner ( System . in ) ; try { FileWriter writer = new FileWriter ( new File ( \" D : / ltrout _ large . txt \" ) ) ; int t = reader . nextInt ( ) ; for ( int cc = 1 ; cc <= t ; ++ cc ) { long l = reader . nextInt ( ) ; long p = reader . nextInt ( ) ; int c = reader . nextInt ( ) ; int sum = 0 ; long now = p ; if ( l * c >= p ) { writer . write ( \" Case \u2581 # \" + cc + \" : \u2581 0 \\r \\n \" ) ; } else { while ( true ) { sum ++ ; now = ( now + c - 1 ) / c ; if ( l * c >= now ) break ; } int result = ( int ) Math . ceil ( Math . log ( sum + 1 ) / Math . log ( 2 ) ) ; writer . write ( \" Case \u2581 # \" + cc + \" : \u2581 \" + result + \" \\r \\n \" ) ; } writer . flush ( ) ; } writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner reader = new Scanner ( System . in ) ; try { FileWriter writer = new FileWriter ( new File ( \" D : / ltrout _ large . txt \" ) ) ; int t = reader . nextInt ( ) ; for ( int cc = 1 ; cc <= t ; ++ cc ) { long l = reader . nextInt ( ) ; long p = reader . nextInt ( ) ; int c = reader . nextInt ( ) ; int sum = 0 ; long now = p ; if ( l * c >= p ) { writer . write ( \" Case \u2581 # \" + cc + \" : \u2581 0 \\r \\n \" ) ; } else { while ( true ) { sum ++ ; now = ( now + c - 1 ) / c ; if ( l * c >= now ) break ; } int result = ( int ) Math . ceil ( Math . log ( sum + 1 ) / Math . log ( 2 ) ) ; writer . write ( \" Case \u2581 # \" + cc + \" : \u2581 \" + result + \" \\r \\n \" ) ; } writer . flush ( ) ; } writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "13", "code": "import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . LinkedList ; import java . util . List ; public class LoadTesting { public static List < Integer > ans = new LinkedList < Integer > ( ) ; public static void main ( String [ ] args ) throws IOException { ans . clear ( ) ; for ( int i = 0 ; i < 40 ; i ++ ) { ans . add ( pToTestCount ( i ) ) ; System . out . println ( i + \" : \" + pToTestCount ( i ) ) ; } RandomAccessFile in = new RandomAccessFile ( args [ 0 ] , \" r \" ) ; RandomAccessFile out = new RandomAccessFile ( args [ 1 ] , \" rw \" ) ; int caseCount = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 1 ; i <= caseCount ; i ++ ) { long L , P , C ; String temp [ ] = in . readLine ( ) . trim ( ) . split ( \" \u2581 \" ) ; L = Integer . parseInt ( temp [ 0 ] ) ; P = Integer . parseInt ( temp [ 1 ] ) ; C = Integer . parseInt ( temp [ 2 ] ) ; int p = 0 ; while ( L < P ) { p ++ ; L = L * C ; } p -- ; String result = \" Case \u2581 # \" ; int retCode = ans . get ( p ) ; result = result + i + \" : \u2581 \" + retCode + \" \\n \" ; out . writeBytes ( result ) ; } } public static int pToTestCount ( int p ) { if ( p == 0 ) return 0 ; int ret = 1 ; return ret + pToTestCount ( p / 2 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { ans . clear ( ) ; for ( int i = 0 ; i < 40 ; i ++ ) { ans . add ( pToTestCount ( i ) ) ; System . out . println ( i + \" : \" + pToTestCount ( i ) ) ; } RandomAccessFile in = new RandomAccessFile ( args [ 0 ] , \" r \" ) ; RandomAccessFile out = new RandomAccessFile ( args [ 1 ] , \" rw \" ) ; int caseCount = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 1 ; i <= caseCount ; i ++ ) { long L , P , C ; String temp [ ] = in . readLine ( ) . trim ( ) . split ( \" \u2581 \" ) ; L = Integer . parseInt ( temp [ 0 ] ) ; P = Integer . parseInt ( temp [ 1 ] ) ; C = Integer . parseInt ( temp [ 2 ] ) ; int p = 0 ; while ( L < P ) { p ++ ; L = L * C ; } p -- ; String result = \" Case \u2581 # \" ; int retCode = ans . get ( p ) ; result = result + i + \" : \u2581 \" + retCode + \" \\n \" ; out . writeBytes ( result ) ; } }"], ["pToTestCount", "public static int pToTestCount ( int p ) { if ( p == 0 ) return 0 ; int ret = 1 ; return ret + pToTestCount ( p / 2 ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . util . Scanner ; import java . util . Locale ; import java . util . Arrays ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; public class Load implements Runnable { private final Scanner scanner ; private final PrintWriter printer ; private String solveSingle ( ) { int l = scanner . nextInt ( ) ; int p = scanner . nextInt ( ) ; int c = scanner . nextInt ( ) ; int mults = 0 ; long ll = l ; while ( ll * c < p ) { ll *= c ; mults ++ ; } int naive = 0 ; while ( ( 1 << naive ) <= mults ) { naive ++ ; } return String . valueOf ( naive ) ; } private void solve ( ) throws Exception { int cases = scanner . nextInt ( ) ; for ( int test = 1 ; test <= cases ; test ++ ) { printer . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + solveSingle ( ) ) ; } } private Load ( ) throws FileNotFoundException { scanner = new Scanner ( new File ( \" b - large . in \" ) ) ; printer = new PrintWriter ( new File ( \" b - large . out \" ) ) ; } public void run ( ) { try { solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } finally { printer . close ( ) ; } } public static void main ( String [ ] args ) throws FileNotFoundException { Locale . setDefault ( Locale . US ) ; new Thread ( new Load ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Locale . setDefault ( Locale . US ) ; new Thread ( new Load ( ) ) . start ( ) ; }"]], "functions_class": [["solveSingle", "private String solveSingle ( ) { int l = scanner . nextInt ( ) ; int p = scanner . nextInt ( ) ; int c = scanner . nextInt ( ) ; int mults = 0 ; long ll = l ; while ( ll * c < p ) { ll *= c ; mults ++ ; } int naive = 0 ; while ( ( 1 << naive ) <= mults ) { naive ++ ; } return String . valueOf ( naive ) ; }"], ["solve", "private void solve ( ) throws Exception { int cases = scanner . nextInt ( ) ; for ( int test = 1 ; test <= cases ; test ++ ) { printer . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + solveSingle ( ) ) ; } }"], ["Load", "private Load ( ) throws FileNotFoundException { scanner = new Scanner ( new File ( \" b - large . in \" ) ) ; printer = new PrintWriter ( new File ( \" b - large . out \" ) ) ; }"], ["run", "public void run ( ) { try { solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } finally { printer . close ( ) ; } }"]]}, {"id": "17", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . StringTokenizer ; public class ab { public static void main ( String args [ ] ) throws Exception { BufferedReader f = new BufferedReader ( new FileReader ( \" A . in \" ) ) ; BufferedWriter w = new BufferedWriter ( new FileWriter ( \" A . txt \" ) ) ; int t = Integer . parseInt ( f . readLine ( ) ) ; StringTokenizer g ; int l , p , c ; for ( int d = 1 ; d <= t ; d ++ ) { g = new StringTokenizer ( f . readLine ( ) ) ; l = Integer . parseInt ( g . nextToken ( ) ) ; p = Integer . parseInt ( g . nextToken ( ) ) ; c = Integer . parseInt ( g . nextToken ( ) ) ; int ans = ( int ) ( ( Math . ceil ( Math . log ( Math . ceil ( Math . log ( p / ( double ) l ) / Math . log ( c ) ) ) ) / Math . log ( 2 ) ) ) ; w . write ( \" Case \u2581 # \" + d + \" : \u2581 \" + \" \" + ans + \" \\n \" ) ; } w . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { BufferedReader f = new BufferedReader ( new FileReader ( \" A . in \" ) ) ; BufferedWriter w = new BufferedWriter ( new FileWriter ( \" A . txt \" ) ) ; int t = Integer . parseInt ( f . readLine ( ) ) ; StringTokenizer g ; int l , p , c ; for ( int d = 1 ; d <= t ; d ++ ) { g = new StringTokenizer ( f . readLine ( ) ) ; l = Integer . parseInt ( g . nextToken ( ) ) ; p = Integer . parseInt ( g . nextToken ( ) ) ; c = Integer . parseInt ( g . nextToken ( ) ) ; int ans = ( int ) ( ( Math . ceil ( Math . log ( Math . ceil ( Math . log ( p / ( double ) l ) / Math . log ( c ) ) ) ) / Math . log ( 2 ) ) ) ; w . write ( \" Case \u2581 # \" + d + \" : \u2581 \" + \" \" + ans + \" \\n \" ) ; } w . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "import sys NEW_LINE def ntests ( L , P , C ) : NEW_LINE INDENT ratio = P * 1.0 / L NEW_LINE if ratio <= C : return 0 NEW_LINE if L == 1 and P == 3 : return 1 NEW_LINE testpoint = int ( L * ( ratio ** 0.5 ) ) NEW_LINE count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) ) NEW_LINE if ( testpoint * testpoint == L * P or testpoint + 1 == P ) : NEW_LINE INDENT return count NEW_LINE DEDENT count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) ) NEW_LINE return min ( count , count2 ) NEW_LINE DEDENT infile = sys . stdin NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT L , P , C = map ( int , infile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE result = ntests ( L , P , C ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , str ( result ) ) ) NEW_LINE DEDENT", "functions_standalone": [["ntests", "def ntests ( L , P , C ) : NEW_LINE INDENT ratio = P * 1.0 / L NEW_LINE if ratio <= C : return 0 NEW_LINE if L == 1 and P == 3 : return 1 NEW_LINE testpoint = int ( L * ( ratio ** 0.5 ) ) NEW_LINE count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) ) NEW_LINE if ( testpoint * testpoint == L * P or testpoint + 1 == P ) : NEW_LINE INDENT return count NEW_LINE DEDENT count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) ) NEW_LINE return min ( count , count2 ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "6", "code": "import math NEW_LINE T = int ( input ( ) ) NEW_LINE for testCase in range ( 0 , T ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE L = int ( line [ 0 ] ) NEW_LINE P = int ( line [ 1 ] ) NEW_LINE C = int ( line [ 2 ] ) NEW_LINE a = math . log ( P / L , C ) NEW_LINE a = math . ceil ( a ) NEW_LINE b = math . ceil ( math . log ( a , 2 ) ) NEW_LINE print ( ' Case \u2581 # { 0 } : \u2581 { 1 } ' . format ( testCase + 1 , b ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "0", "code": "from math import log , ceil NEW_LINE def solve_problem ( L , P , C ) : NEW_LINE INDENT intervals = int ( ceil ( log ( ( P + L - 1 ) / L , C ) ) ) NEW_LINE tests = 0 NEW_LINE while intervals > 1 : NEW_LINE INDENT tests += 1 NEW_LINE intervals = ( intervals + 1 ) / 2 NEW_LINE DEDENT return tests NEW_LINE DEDENT def run_process ( args ) : NEW_LINE INDENT return solve_problem ( * args ) NEW_LINE DEDENT def process_file ( fin , fout ) : NEW_LINE INDENT def get_problem ( ) : NEW_LINE INDENT return map ( int , fin . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE DEDENT numLines = int ( fin . readline ( ) ) NEW_LINE problem_list = [ get_problem ( ) for i in range ( numLines ) ] NEW_LINE if False : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE p = Pool ( 8 ) NEW_LINE solution_list = p . map ( run_process , problem_list ) NEW_LINE DEDENT else : NEW_LINE INDENT solution_list = map ( run_process , problem_list ) NEW_LINE DEDENT for i , s in enumerate ( solution_list ) : NEW_LINE INDENT fout . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , s ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT from sys import argv NEW_LINE process_file ( open ( argv [ 1 ] ) , open ( argv [ 1 ] . replace ( \" in \" , \" out \" ) , \" w \" ) ) NEW_LINE DEDENT", "functions_standalone": [["solve_problem", "def solve_problem ( L , P , C ) : NEW_LINE INDENT intervals = int ( ceil ( log ( ( P + L - 1 ) / L , C ) ) ) NEW_LINE tests = 0 NEW_LINE while intervals > 1 : NEW_LINE INDENT tests += 1 NEW_LINE intervals = ( intervals + 1 ) / 2 NEW_LINE DEDENT return tests NEW_LINE DEDENT"], ["run_process", "def run_process ( args ) : NEW_LINE INDENT return solve_problem ( * args ) NEW_LINE DEDENT"], ["process_file", "def process_file ( fin , fout ) : NEW_LINE INDENT def get_problem ( ) : NEW_LINE INDENT return map ( int , fin . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE DEDENT numLines = int ( fin . readline ( ) ) NEW_LINE problem_list = [ get_problem ( ) for i in range ( numLines ) ] NEW_LINE if False : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE p = Pool ( 8 ) NEW_LINE solution_list = p . map ( run_process , problem_list ) NEW_LINE DEDENT else : NEW_LINE INDENT solution_list = map ( run_process , problem_list ) NEW_LINE DEDENT for i , s in enumerate ( solution_list ) : NEW_LINE INDENT fout . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , s ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "10", "code": "import math NEW_LINE inf = ' B - large . in ' NEW_LINE f_in = open ( inf ) NEW_LINE f_out = open ( ' out . txt ' , ' w ' ) NEW_LINE def find_parts ( l , p , c ) : NEW_LINE INDENT parts = 1 NEW_LINE t = l * c NEW_LINE while t < p : NEW_LINE INDENT parts += 1 NEW_LINE t *= c NEW_LINE DEDENT return parts NEW_LINE DEDENT def slove ( case ) : NEW_LINE INDENT ln = f_in . next ( ) . split ( ' \u2581 ' ) NEW_LINE l , p , c = int ( ln [ 0 ] ) , int ( ln [ 1 ] ) , int ( ln [ 2 ] ) NEW_LINE ans = int ( math . ceil ( math . log ( find_parts ( l , p , c ) , 2 ) ) ) NEW_LINE print >> f_out , ' Case \u2581 # ' + str ( case ) + \" : \u2581 \" + str ( ans ) NEW_LINE DEDENT T = int ( f_in . next ( ) ) NEW_LINE for case in xrange ( 1 , T + 1 ) : NEW_LINE INDENT slove ( case ) NEW_LINE DEDENT f_out . close ( ) NEW_LINE f_in . close ( ) NEW_LINE", "functions_standalone": [["find_parts", "def find_parts ( l , p , c ) : NEW_LINE INDENT parts = 1 NEW_LINE t = l * c NEW_LINE while t < p : NEW_LINE INDENT parts += 1 NEW_LINE t *= c NEW_LINE DEDENT return parts NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "import sys , itertools NEW_LINE from pprint import pprint NEW_LINE from collections import namedtuple NEW_LINE import math NEW_LINE from decimal import Decimal NEW_LINE from fractions import Fraction NEW_LINE output_line = \" Case \u2581 # { X : d } : \u2581 { Y : d } \" NEW_LINE Rope = namedtuple ( \" Rope \" , \" a \u2581 b \" ) NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT infile , outfile = sys . argv [ 1 : ] NEW_LINE with open ( infile , \" r \" ) as inhandle , open ( outfile , \" w \" ) as outhandle : NEW_LINE INDENT T = int ( inhandle . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT L , P , C = map ( int , inhandle . readline ( ) . split ( ) ) NEW_LINE stage1 = math . log ( Fraction ( P , L ) , C ) NEW_LINE stage2 = math . log ( stage1 , 2 ) NEW_LINE num_tests = max ( 0 , math . ceil ( stage2 ) ) NEW_LINE print ( stage1 , stage2 , num_tests ) NEW_LINE print ( output_line . format ( X = t + 1 , Y = num_tests ) , file = outhandle ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_10_02", "java": [{"id": "19", "code": "import java . util . * ; import java . math . * ; public class B { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int caseN = cin . nextInt ( ) ; for ( int caseI = 1 ; caseI <= caseN ; caseI ++ ) { int n = cin . nextInt ( ) ; BigInteger [ ] times = new BigInteger [ n ] ; for ( int i = 0 ; i < n ; i ++ ) times [ i ] = new BigInteger ( cin . next ( ) ) ; BigInteger ans = times [ 0 ] . subtract ( times [ 1 ] ) . abs ( ) ; for ( int i = 2 ; i < n ; i ++ ) ans = ans . gcd ( times [ i ] . subtract ( times [ i - 1 ] ) . abs ( ) ) ; ans = ans . subtract ( times [ 0 ] . mod ( ans ) ) . mod ( ans ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s \" , caseI , ans . toString ( ) ) ; System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int caseN = cin . nextInt ( ) ; for ( int caseI = 1 ; caseI <= caseN ; caseI ++ ) { int n = cin . nextInt ( ) ; BigInteger [ ] times = new BigInteger [ n ] ; for ( int i = 0 ; i < n ; i ++ ) times [ i ] = new BigInteger ( cin . next ( ) ) ; BigInteger ans = times [ 0 ] . subtract ( times [ 1 ] ) . abs ( ) ; for ( int i = 2 ; i < n ; i ++ ) ans = ans . gcd ( times [ i ] . subtract ( times [ i - 1 ] ) . abs ( ) ) ; ans = ans . subtract ( times [ 0 ] . mod ( ans ) ) . mod ( ans ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s \" , caseI , ans . toString ( ) ) ; System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "20", "code": "import java . math . BigInteger ; import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; BigInteger [ ] data ; BigInteger solve ( ) { int N = in . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) data [ i ] = in . nextBigInteger ( ) ; Arrays . sort ( data , 0 , N ) ; BigInteger g = data [ 1 ] . subtract ( data [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) g = g . gcd ( data [ i ] . subtract ( data [ i - 1 ] ) ) ; return g . subtract ( data [ 0 ] . remainder ( g ) ) . remainder ( g ) ; } void cases ( ) { data = new BigInteger [ 1000 ] ; int T = in . nextInt ( ) ; for ( int c = 1 ; c <= T ; c ++ ) System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + solve ( ) ) ; } public static void main ( String [ ] args ) throws Exception { ( new Main ( ) ) . cases ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new Main ( ) ) . cases ( ) ; }"]], "functions_class": [["solve", "BigInteger solve ( ) { int N = in . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) data [ i ] = in . nextBigInteger ( ) ; Arrays . sort ( data , 0 , N ) ; BigInteger g = data [ 1 ] . subtract ( data [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) g = g . gcd ( data [ i ] . subtract ( data [ i - 1 ] ) ) ; return g . subtract ( data [ 0 ] . remainder ( g ) ) . remainder ( g ) ; }"], ["cases", "void cases ( ) { data = new BigInteger [ 1000 ] ; int T = in . nextInt ( ) ; for ( int c = 1 ; c <= T ; c ++ ) System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + solve ( ) ) ; }"]]}, {"id": "16", "code": "import java . io . * ; import java . math . * ; import java . util . * ; public class Main { Scanner in ; BufferedReader br ; PrintWriter out ; public void run ( ) throws Exception { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { TreeSet < BigInteger > hs = new TreeSet < BigInteger > ( ) ; int nnn = in . nextInt ( ) ; for ( int i = 0 ; i < nnn ; i ++ ) hs . add ( in . nextBigInteger ( ) ) ; int n = hs . size ( ) ; BigInteger [ ] a = new BigInteger [ n ] ; nnn = 0 ; for ( BigInteger x : hs ) a [ nnn ++ ] = x ; BigInteger g = a [ 1 ] . subtract ( a [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { g = g . gcd ( a [ j ] . subtract ( a [ i ] ) ) ; } } BigInteger mn = BigInteger . valueOf ( 10 ) . pow ( 100 ) ; BigInteger g1 = g . subtract ( BigInteger . ONE ) ; for ( int i = 0 ; i < n ; i ++ ) { BigInteger cur = a [ i ] . add ( g1 ) . divide ( g ) . multiply ( g ) . subtract ( a [ i ] ) ; mn = mn . min ( cur ) ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + mn ) ; } out . close ( ) ; } public static void main ( String [ ] args ) throws Exception { new Main ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new Main ( ) . run ( ) ; }"]], "functions_class": [["run", "public void run ( ) throws Exception { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { TreeSet < BigInteger > hs = new TreeSet < BigInteger > ( ) ; int nnn = in . nextInt ( ) ; for ( int i = 0 ; i < nnn ; i ++ ) hs . add ( in . nextBigInteger ( ) ) ; int n = hs . size ( ) ; BigInteger [ ] a = new BigInteger [ n ] ; nnn = 0 ; for ( BigInteger x : hs ) a [ nnn ++ ] = x ; BigInteger g = a [ 1 ] . subtract ( a [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { g = g . gcd ( a [ j ] . subtract ( a [ i ] ) ) ; } } BigInteger mn = BigInteger . valueOf ( 10 ) . pow ( 100 ) ; BigInteger g1 = g . subtract ( BigInteger . ONE ) ; for ( int i = 0 ; i < n ; i ++ ) { BigInteger cur = a [ i ] . add ( g1 ) . divide ( g ) . multiply ( g ) . subtract ( a [ i ] ) ; mn = mn . min ( cur ) ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + mn ) ; } out . close ( ) ; }"]]}, {"id": "3", "code": "import java . io . * ; import java . util . * ; import java . math . * ; public class Main implements Runnable { static Scanner scanner ; static BufferedReader input ; static PrintWriter pw ; public static void main ( String [ ] args ) throws Exception { new Thread ( new Main ( ) ) . start ( ) ; } public void run ( ) { try { input = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; scanner = new Scanner ( input ) ; pw = new PrintWriter ( new File ( \" output . txt \" ) ) ; solve ( ) ; pw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public void solve ( ) throws Exception { int qq = scanner . nextInt ( ) ; for ( int ii = 0 ; ii < qq ; ii ++ ) { int n = scanner . nextInt ( ) ; BigInteger [ ] a = new BigInteger [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextBigInteger ( ) ; } BigInteger x = BigInteger . ZERO ; for ( int i = 1 ; i < n ; i ++ ) { x = x . gcd ( a [ i ] . subtract ( a [ 0 ] ) ) ; } BigInteger ans = ( x . subtract ( a [ 0 ] . mod ( x ) ) ) . mod ( x ) ; pw . println ( \" Case \u2581 # \" + ( ii + 1 ) + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new Thread ( new Main ( ) ) . start ( ) ; }"]], "functions_class": [["run", "public void run ( ) { try { input = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; scanner = new Scanner ( input ) ; pw = new PrintWriter ( new File ( \" output . txt \" ) ) ; solve ( ) ; pw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }"], ["solve", "public void solve ( ) throws Exception { int qq = scanner . nextInt ( ) ; for ( int ii = 0 ; ii < qq ; ii ++ ) { int n = scanner . nextInt ( ) ; BigInteger [ ] a = new BigInteger [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextBigInteger ( ) ; } BigInteger x = BigInteger . ZERO ; for ( int i = 1 ; i < n ; i ++ ) { x = x . gcd ( a [ i ] . subtract ( a [ 0 ] ) ) ; } BigInteger ans = ( x . subtract ( a [ 0 ] . mod ( x ) ) ) . mod ( x ) ; pw . println ( \" Case \u2581 # \" + ( ii + 1 ) + \" : \u2581 \" + ans ) ; } }"]]}, {"id": "15", "code": "import java . util . Arrays ; import java . util . Scanner ; import java . io . * ; import java . math . BigInteger ; public class Main { public static BigInteger gcd ( BigInteger aa , BigInteger bb ) { BigInteger a = aa , b = bb , c ; while ( true ) { c = a . mod ( b ) ; if ( c == BigInteger . ZERO ) break ; a = b ; b = c ; } return b ; } public static void main ( String [ ] args ) throws FileNotFoundException { Scanner cin = new Scanner ( System . in ) ; cin = new Scanner ( new File ( \" E : \\\\ Program \u2581 Files \\\\ WinZip \\\\ Source \\\\ \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \\\\ JAVA \\\\ src \\\\ B - large . in \" ) ) ; BigInteger [ ] s ; int n , t = cin . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; ++ tt ) { n = cin . nextInt ( ) ; s = new BigInteger [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { s [ i ] = cin . nextBigInteger ( ) ; } Arrays . sort ( s ) ; for ( int i = 1 ; i < n ; ++ i ) { s [ i ] = s [ i ] . subtract ( s [ 0 ] ) ; } BigInteger tmp = s [ 1 ] , ans ; for ( int i = 2 ; i < n ; ++ i ) { if ( s [ i ] == BigInteger . ZERO ) continue ; tmp = gcd ( tmp , s [ i ] ) ; } ans = s [ 0 ] . mod ( tmp ) ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + tmp . subtract ( ans ) . mod ( tmp ) ) ; } } }", "functions_standalone": [["gcd", "public static BigInteger gcd ( BigInteger aa , BigInteger bb ) { BigInteger a = aa , b = bb , c ; while ( true ) { c = a . mod ( b ) ; if ( c == BigInteger . ZERO ) break ; a = b ; b = c ; } return b ; }"], ["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner cin = new Scanner ( System . in ) ; cin = new Scanner ( new File ( \" E : \\\\ Program \u2581 Files \\\\ WinZip \\\\ Source \\\\ \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \\\\ JAVA \\\\ src \\\\ B - large . in \" ) ) ; BigInteger [ ] s ; int n , t = cin . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; ++ tt ) { n = cin . nextInt ( ) ; s = new BigInteger [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { s [ i ] = cin . nextBigInteger ( ) ; } Arrays . sort ( s ) ; for ( int i = 1 ; i < n ; ++ i ) { s [ i ] = s [ i ] . subtract ( s [ 0 ] ) ; } BigInteger tmp = s [ 1 ] , ans ; for ( int i = 2 ; i < n ; ++ i ) { if ( s [ i ] == BigInteger . ZERO ) continue ; tmp = gcd ( tmp , s [ i ] ) ; } ans = s [ 0 ] . mod ( tmp ) ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + tmp . subtract ( ans ) . mod ( tmp ) ) ; } }"]], "functions_class": []}], "python": [{"id": "4", "code": "import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT input = sys . stdin . readlines ( ) NEW_LINE tc = int ( input [ 0 ] ) NEW_LINE for cs in range ( tc ) : NEW_LINE INDENT ls = input [ cs + 1 ] . split ( ' \u2581 ' ) NEW_LINE n = int ( ls [ 0 ] ) NEW_LINE t = [ int ( x ) for x in ls [ 1 : ] ] NEW_LINE t . sort ( ) NEW_LINE g = t [ 1 ] - t [ 0 ] NEW_LINE for i in range ( 2 , len ( t ) ) : NEW_LINE INDENT g = gcd ( g , t [ i ] - t [ i - 1 ] ) NEW_LINE DEDENT print ( \" Case \u2581 # % s : \u2581 % s \" % ( str ( cs + 1 ) , str ( ( - t [ 0 ] ) % g ) ) ) NEW_LINE DEDENT", "functions_standalone": [["gcd", "def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "MAXN = 1005 NEW_LINE def GCD ( a , b ) : NEW_LINE INDENT while ( b > 0 ) : NEW_LINE INDENT c = a % b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return a NEW_LINE DEDENT fi = open ( ' warning . in ' , ' r ' ) NEW_LINE T = int ( fi . readline ( ) ) NEW_LINE for iT in range ( T ) : NEW_LINE INDENT s = fi . readline ( ) NEW_LINE s2 = s . split ( ) NEW_LINE N = int ( s2 [ 0 ] ) NEW_LINE data = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT data . append ( int ( s2 [ i + 1 ] ) ) NEW_LINE DEDENT a = [ ] NEW_LINE ac = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < N ) : NEW_LINE INDENT a . append ( abs ( data [ i ] - data [ j ] ) ) NEW_LINE ac = ac + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT for i in range ( ac - 1 ) : NEW_LINE INDENT a [ i + 1 ] = GCD ( a [ i ] , a [ i + 1 ] ) NEW_LINE DEDENT T = a [ ac - 1 ] NEW_LINE S = data [ 0 ] % T NEW_LINE if ( S > 0 ) : NEW_LINE INDENT S = T - S NEW_LINE DEDENT res = ' Case \u2581 # ' + str ( iT + 1 ) + ' : \u2581 ' + str ( S ) NEW_LINE print ( res ) NEW_LINE DEDENT", "functions_standalone": [["GCD", "def GCD ( a , b ) : NEW_LINE INDENT while ( b > 0 ) : NEW_LINE INDENT c = a % b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return a NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_10_21", "java": [{"id": "5", "code": "import java . io . * ; import java . math . * ; import java . util . * ; public class Main { static class Tree { final String name ; final ArrayList < Tree > a = new ArrayList < Tree > ( ) ; Tree ( String name ) { this . name = name ; } int size ( ) { if ( a . size ( ) == 0 ) return 1 ; int ans = 1 ; for ( Tree t : a ) ans += t . size ( ) ; return ans ; } void out ( String s ) { System . out . println ( s + name ) ; for ( Tree t : a ) t . out ( s + \" \u2581 \u2581 \" ) ; } void out ( ) { out ( \" \" ) ; } } static void add ( Tree t , String d ) { String [ ] ss = d . substring ( 1 ) . split ( \" / \" ) ; for ( String s : ss ) { Tree w = null ; for ( Tree r : t . a ) if ( r . name . equals ( s ) ) { w = r ; break ; } if ( w == null ) { w = new Tree ( s ) ; t . a . add ( w ) ; } t = w ; } } public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" Main . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" Main . out \" ) ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; in . nextLine ( ) ; Tree t = new Tree ( \" \" ) ; for ( int i = 0 ; i < n ; i ++ ) { String d = in . nextLine ( ) ; add ( t , d ) ; } int was = t . size ( ) ; for ( int i = 0 ; i < m ; i ++ ) { String d = in . nextLine ( ) ; add ( t , d ) ; } out . println ( t . size ( ) - was ) ; } out . close ( ) ; } }", "functions_standalone": [["add", "static void add ( Tree t , String d ) { String [ ] ss = d . substring ( 1 ) . split ( \" / \" ) ; for ( String s : ss ) { Tree w = null ; for ( Tree r : t . a ) if ( r . name . equals ( s ) ) { w = r ; break ; } if ( w == null ) { w = new Tree ( s ) ; t . a . add ( w ) ; } t = w ; } }"], ["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" Main . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" Main . out \" ) ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; in . nextLine ( ) ; Tree t = new Tree ( \" \" ) ; for ( int i = 0 ; i < n ; i ++ ) { String d = in . nextLine ( ) ; add ( t , d ) ; } int was = t . size ( ) ; for ( int i = 0 ; i < m ; i ++ ) { String d = in . nextLine ( ) ; add ( t , d ) ; } out . println ( t . size ( ) - was ) ; } out . close ( ) ; }"]], "functions_class": [["Tree", "Tree ( String name ) { this . name = name ; }"], ["size", "int size ( ) { if ( a . size ( ) == 0 ) return 1 ; int ans = 1 ; for ( Tree t : a ) ans += t . size ( ) ; return ans ; }"], ["out", "void out ( String s ) { System . out . println ( s + name ) ; for ( Tree t : a ) t . out ( s + \" \u2581 \u2581 \" ) ; }"], ["out", "void out ( ) { out ( \" \" ) ; }"]]}, {"id": "1", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class Solution { class Tree { Map < String , Tree > mp = new HashMap < String , Tree > ( ) ; public Tree ( ) { } } Tree root ; int res ; void process ( String s , boolean add ) { s = s . substring ( 1 ) ; String [ ] items = s . split ( \" / \" ) ; Tree cur = root ; for ( int i = 0 ; i < items . length ; i ++ ) { if ( ! cur . mp . containsKey ( items [ i ] ) ) { cur . mp . put ( items [ i ] , new Tree ( ) ) ; if ( add ) res ++ ; } cur = cur . mp . get ( items [ i ] ) ; } } public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; long time = System . currentTimeMillis ( ) ; for ( int caseNum = 1 ; caseNum <= caseCnt ; caseNum ++ ) { int have = sc . nextInt ( ) , next = sc . nextInt ( ) ; root = new Tree ( ) ; res = 0 ; for ( int i = 0 ; i < have ; i ++ ) { process ( sc . next ( ) , false ) ; } for ( int i = 0 ; i < next ; i ++ ) process ( sc . next ( ) , true ) ; pw . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + res ) ; System . out . println ( \" Finished \u2581 testcase \u2581 \" + caseNum + \" , \u2581 time \u2581 = \u2581 \" + ( System . currentTimeMillis ( ) - time ) ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; }"]], "functions_class": [["Tree", "public Tree ( ) { }"], ["process", "void process ( String s , boolean add ) { s = s . substring ( 1 ) ; String [ ] items = s . split ( \" / \" ) ; Tree cur = root ; for ( int i = 0 ; i < items . length ; i ++ ) { if ( ! cur . mp . containsKey ( items [ i ] ) ) { cur . mp . put ( items [ i ] , new Tree ( ) ) ; if ( add ) res ++ ; } cur = cur . mp . get ( items [ i ] ) ; } }"], ["doMain", "public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; long time = System . currentTimeMillis ( ) ; for ( int caseNum = 1 ; caseNum <= caseCnt ; caseNum ++ ) { int have = sc . nextInt ( ) , next = sc . nextInt ( ) ; root = new Tree ( ) ; res = 0 ; for ( int i = 0 ; i < have ; i ++ ) { process ( sc . next ( ) , false ) ; } for ( int i = 0 ; i < next ; i ++ ) process ( sc . next ( ) , true ) ; pw . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + res ) ; System . out . println ( \" Finished \u2581 testcase \u2581 \" + caseNum + \" , \u2581 time \u2581 = \u2581 \" + ( System . currentTimeMillis ( ) - time ) ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]]}, {"id": "0", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . * ; public class A { public void solve ( ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" A - large . out \" ) ; int testN = in . nextInt ( ) ; for ( int test = 1 ; test <= testN ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; String [ ] exists = new String [ n ] ; String [ ] create = new String [ m ] ; Set < String > ex = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { exists [ i ] = in . next ( ) ; String [ ] t = exists [ i ] . split ( \" / \" ) ; String r = \" \" ; for ( int j = 1 ; j < t . length ; j ++ ) { r = r + \" / \" + t [ j ] ; ex . add ( r ) ; } } Set < String > need = new TreeSet < String > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { create [ i ] = in . next ( ) ; String [ ] t = create [ i ] . split ( \" / \" ) ; String r = \" \" ; for ( int j = 1 ; j < t . length ; j ++ ) { r = r + \" / \" + t [ j ] ; need . add ( r ) ; } } int res = 0 ; for ( String s : need ) { if ( ! ex . contains ( s ) ) { res ++ ; ex . add ( s ) ; } } out . println ( res ) ; } in . close ( ) ; out . close ( ) ; } public static void main ( String [ ] args ) throws FileNotFoundException { new A ( ) . solve ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { new A ( ) . solve ( ) ; }"]], "functions_class": [["solve", "public void solve ( ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" A - large . out \" ) ; int testN = in . nextInt ( ) ; for ( int test = 1 ; test <= testN ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; String [ ] exists = new String [ n ] ; String [ ] create = new String [ m ] ; Set < String > ex = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { exists [ i ] = in . next ( ) ; String [ ] t = exists [ i ] . split ( \" / \" ) ; String r = \" \" ; for ( int j = 1 ; j < t . length ; j ++ ) { r = r + \" / \" + t [ j ] ; ex . add ( r ) ; } } Set < String > need = new TreeSet < String > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { create [ i ] = in . next ( ) ; String [ ] t = create [ i ] . split ( \" / \" ) ; String r = \" \" ; for ( int j = 1 ; j < t . length ; j ++ ) { r = r + \" / \" + t [ j ] ; need . add ( r ) ; } } int res = 0 ; for ( String s : need ) { if ( ! ex . contains ( s ) ) { res ++ ; ex . add ( s ) ; } } out . println ( res ) ; } in . close ( ) ; out . close ( ) ; }"]]}, {"id": "11", "code": "import java . util . * ; import java . io . * ; public class Main implements Runnable { public Scanner in ; public PrintWriter out ; Main ( ) throws IOException { in = new Scanner ( new File ( \" in \" ) ) ; out = new PrintWriter ( new File ( \" out \" ) ) ; } void close ( ) throws IOException { out . close ( ) ; } void check ( boolean f , String msg ) { if ( ! f ) { out . close ( ) ; throw new RuntimeException ( msg ) ; } } public void run ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int old = in . nextInt ( ) ; int create = in . nextInt ( ) ; in . nextLine ( ) ; Node root = new Node ( ) ; for ( int i = 0 ; i < old ; i ++ ) { add ( root , in . nextLine ( ) . split ( \" / \" ) , 1 ) ; } int r = 0 ; for ( int i = 0 ; i < create ; i ++ ) { r += add ( root , in . nextLine ( ) . split ( \" / \" ) , 1 ) ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r ) ; } try { close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } int add ( Node node , String [ ] tokens , int p ) { if ( p >= tokens . length ) { return 0 ; } int r = 0 ; if ( node . children . get ( tokens [ p ] ) == null ) { node . children . put ( tokens [ p ] , new Node ( ) ) ; r = 1 ; } return r + add ( node . children . get ( tokens [ p ] ) , tokens , p + 1 ) ; } public class Node { Map < String , Node > children ; Node ( ) { children = new TreeMap < String , Node > ( ) ; } } public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; }"]], "functions_class": [["Main", "Main ( ) throws IOException { in = new Scanner ( new File ( \" in \" ) ) ; out = new PrintWriter ( new File ( \" out \" ) ) ; }"], ["close", "void close ( ) throws IOException { out . close ( ) ; }"], ["check", "void check ( boolean f , String msg ) { if ( ! f ) { out . close ( ) ; throw new RuntimeException ( msg ) ; } }"], ["run", "public void run ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int old = in . nextInt ( ) ; int create = in . nextInt ( ) ; in . nextLine ( ) ; Node root = new Node ( ) ; for ( int i = 0 ; i < old ; i ++ ) { add ( root , in . nextLine ( ) . split ( \" / \" ) , 1 ) ; } int r = 0 ; for ( int i = 0 ; i < create ; i ++ ) { r += add ( root , in . nextLine ( ) . split ( \" / \" ) , 1 ) ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r ) ; } try { close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"], ["add", "int add ( Node node , String [ ] tokens , int p ) { if ( p >= tokens . length ) { return 0 ; } int r = 0 ; if ( node . children . get ( tokens [ p ] ) == null ) { node . children . put ( tokens [ p ] , new Node ( ) ) ; r = 1 ; } return r + add ( node . children . get ( tokens [ p ] ) , tokens , p + 1 ) ; }"], ["Node", "Node ( ) { children = new TreeMap < String , Node > ( ) ; }"]]}, {"id": "4", "code": "import java . util . * ; import java . io . * ; public class x { static class Directory { int st ; HashMap < String , Directory > h ; Directory ( int cst ) { h = new HashMap < String , Directory > ( ) ; st = cst ; } Directory create ( String name , int sst ) { Directory c = h . get ( name ) ; if ( c != null ) return c ; c = new Directory ( sst ) ; h . put ( name , c ) ; return c ; } int count ( int lst ) { int cur = 0 ; if ( st > lst ) ++ cur ; for ( Directory z : h . values ( ) ) cur += z . count ( lst ) ; return cur ; } } public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { Directory r = new Directory ( 0 ) ; int n = in . nextInt ( ) , m = in . nextInt ( ) ; for ( int i = 1 ; i <= n + m ; i ++ ) { String [ ] a = in . next ( ) . split ( \" / \" ) ; Directory c = r ; for ( int j = 1 ; j < a . length ; j ++ ) { c = c . create ( a [ j ] , i ) ; } } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + r . count ( n ) ) ; } ; } ; } ;", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { Directory r = new Directory ( 0 ) ; int n = in . nextInt ( ) , m = in . nextInt ( ) ; for ( int i = 1 ; i <= n + m ; i ++ ) { String [ ] a = in . next ( ) . split ( \" / \" ) ; Directory c = r ; for ( int j = 1 ; j < a . length ; j ++ ) { c = c . create ( a [ j ] , i ) ; } } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + r . count ( n ) ) ; } ; }"]], "functions_class": [["Directory", "Directory ( int cst ) { h = new HashMap < String , Directory > ( ) ; st = cst ; }"], ["create", "Directory create ( String name , int sst ) { Directory c = h . get ( name ) ; if ( c != null ) return c ; c = new Directory ( sst ) ; h . put ( name , c ) ; return c ; }"], ["count", "int count ( int lst ) { int cur = 0 ; if ( st > lst ) ++ cur ; for ( Directory z : h . values ( ) ) cur += z . count ( lst ) ; return cur ; }"]]}], "python": [{"id": "9", "code": "from scanf import * NEW_LINE opers = 0 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children = { } NEW_LINE DEDENT def addPath ( self , path ) : NEW_LINE INDENT if len ( path ) == 0 : return NEW_LINE if not path [ 0 ] in self . children : NEW_LINE INDENT global opers NEW_LINE opers += 1 NEW_LINE self . children [ path [ 0 ] ] = Node ( ) NEW_LINE DEDENT self . children [ path [ 0 ] ] . addPath ( path [ 1 : ] ) NEW_LINE DEDENT DEDENT def solveCase ( cas ) : NEW_LINE INDENT global opers NEW_LINE n , m = scanf ( \" % d % d \" ) NEW_LINE root = Node ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT root . addPath ( scanf ( \" % s \" ) [ 0 ] . split ( \" / \" ) [ 1 : ] ) NEW_LINE DEDENT opers = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT root . addPath ( scanf ( \" % s \" ) [ 0 ] . split ( \" / \" ) [ 1 : ] ) NEW_LINE DEDENT print ( \" Case \u2581 # \" + str ( cas ) + \" : \u2581 \" + str ( opers ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT tests = scanf ( \" % d \" ) [ 0 ] NEW_LINE for i in range ( tests ) : NEW_LINE INDENT solveCase ( i + 1 ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solveCase", "def solveCase ( cas ) : NEW_LINE INDENT global opers NEW_LINE n , m = scanf ( \" % d % d \" ) NEW_LINE root = Node ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT root . addPath ( scanf ( \" % s \" ) [ 0 ] . split ( \" / \" ) [ 1 : ] ) NEW_LINE DEDENT opers = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT root . addPath ( scanf ( \" % s \" ) [ 0 ] . split ( \" / \" ) [ 1 : ] ) NEW_LINE DEDENT print ( \" Case \u2581 # \" + str ( cas ) + \" : \u2581 \" + str ( opers ) ) NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self ) : NEW_LINE INDENT self . children = { } NEW_LINE DEDENT"], ["addPath", "def addPath ( self , path ) : NEW_LINE INDENT if len ( path ) == 0 : return NEW_LINE if not path [ 0 ] in self . children : NEW_LINE INDENT global opers NEW_LINE opers += 1 NEW_LINE self . children [ path [ 0 ] ] = Node ( ) NEW_LINE DEDENT self . children [ path [ 0 ] ] . addPath ( path [ 1 : ] ) NEW_LINE DEDENT"]]}, {"id": "17", "code": "ntests = int ( input ( ) ) NEW_LINE for tt in range ( 1 , ntests + 1 ) : NEW_LINE INDENT [ N , M ] = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE dirs = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT p = input ( ) + \" / \" NEW_LINE for z in range ( len ( p ) - 1 ) : NEW_LINE INDENT if ( p [ z + 1 ] == ' / ' ) : NEW_LINE INDENT dirs . add ( p [ : ( z + 1 ) ] ) NEW_LINE DEDENT DEDENT DEDENT k = len ( dirs ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT p = input ( ) + \" / \" NEW_LINE for z in range ( len ( p ) - 1 ) : NEW_LINE INDENT if ( p [ z + 1 ] == ' / ' ) : NEW_LINE INDENT dirs . add ( p [ : ( z + 1 ) ] ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Case \u2581 # \" + str ( tt ) + \" : \u2581 \" + str ( len ( dirs ) - k ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "12", "code": "import sys NEW_LINE if ( len ( sys . argv ) < 2 ) : NEW_LINE INDENT print ( \" No \u2581 file \u2581 specified \" ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT infile = open ( sys . argv [ 1 ] ) NEW_LINE outfile = open ( sys . argv [ 1 ] + \" . out \" , \" w \" ) NEW_LINE num_cases = int ( infile . readline ( ) . strip ( ) ) NEW_LINE def add_dir ( dirs , new_dir ) : NEW_LINE INDENT result = 0 NEW_LINE if len ( new_dir ) > 0 : NEW_LINE INDENT child_dir = new_dir [ 0 ] NEW_LINE if child_dir not in dirs : NEW_LINE INDENT result = 1 NEW_LINE dirs [ child_dir ] = { } NEW_LINE DEDENT result += add_dir ( dirs [ child_dir ] , new_dir [ 1 : ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT for case in range ( 1 , num_cases + 1 ) : NEW_LINE INDENT n , m = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE directories = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT dir = infile . readline ( ) . strip ( ) . split ( \" / \" ) [ 1 : ] NEW_LINE add_dir ( directories , dir ) NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT dir = infile . readline ( ) . strip ( ) . split ( \" / \" ) [ 1 : ] NEW_LINE result += add_dir ( directories , dir ) NEW_LINE DEDENT outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( case , result ) ) NEW_LINE if case % 100 == 0 : NEW_LINE INDENT print ( \" Completed \u2581 case \u2581 % d \" % case ) NEW_LINE DEDENT DEDENT outfile . close ( ) NEW_LINE infile . close ( ) NEW_LINE", "functions_standalone": [["add_dir", "def add_dir ( dirs , new_dir ) : NEW_LINE INDENT result = 0 NEW_LINE if len ( new_dir ) > 0 : NEW_LINE INDENT child_dir = new_dir [ 0 ] NEW_LINE if child_dir not in dirs : NEW_LINE INDENT result = 1 NEW_LINE dirs [ child_dir ] = { } NEW_LINE DEDENT result += add_dir ( dirs [ child_dir ] , new_dir [ 1 : ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_10_43", "java": [{"id": "19", "code": "import java . io . IOException ; public class ProblemC extends CodeJammer { public void print ( boolean [ ] [ ] g , int l ) { for ( int i = 0 ; i < l ; i ++ ) { String s = \" \" ; for ( int j = 0 ; j < l ; j ++ ) { if ( g [ i ] [ j ] ) { s += \"1\" ; } else { s += \"0\" ; } } System . out . println ( s ) ; } } @ Override public void process ( ) throws IOException { int r = reader . readInt ( ) ; boolean [ ] [ ] g = new boolean [ 101 ] [ 101 ] ; for ( int i = 0 ; i < 101 ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { g [ i ] [ j ] = false ; } } for ( int n = 0 ; n < r ; n ++ ) { int [ ] data = reader . readArray ( ) ; for ( int i = data [ 0 ] ; i <= data [ 2 ] ; i ++ ) { for ( int j = data [ 1 ] ; j <= data [ 3 ] ; j ++ ) { g [ i ] [ j ] = true ; } } } long alive = 1 ; int turns = 0 ; while ( alive > 0 ) { alive = 0 ; for ( int s = 200 ; s >= 0 ; s -- ) { for ( int i = 0 ; i <= s && i <= 100 ; i ++ ) { int j = s - i ; if ( j >= 0 && j <= 100 ) { int neighs = 0 ; if ( i > 0 && g [ i - 1 ] [ j ] ) neighs ++ ; if ( j > 0 && g [ i ] [ j - 1 ] ) neighs ++ ; if ( neighs == 0 ) g [ i ] [ j ] = false ; if ( neighs == 2 ) g [ i ] [ j ] = true ; if ( g [ i ] [ j ] ) alive ++ ; } } } turns ++ ; } output ( turns ) ; } public static void main ( String [ ] args ) { ProblemC p = new ProblemC ( ) ; p . run ( args ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { ProblemC p = new ProblemC ( ) ; p . run ( args ) ; }"]], "functions_class": [["print", "public void print ( boolean [ ] [ ] g , int l ) { for ( int i = 0 ; i < l ; i ++ ) { String s = \" \" ; for ( int j = 0 ; j < l ; j ++ ) { if ( g [ i ] [ j ] ) { s += \"1\" ; } else { s += \"0\" ; } } System . out . println ( s ) ; } }"], ["process", "public void process ( ) throws IOException { int r = reader . readInt ( ) ; boolean [ ] [ ] g = new boolean [ 101 ] [ 101 ] ; for ( int i = 0 ; i < 101 ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { g [ i ] [ j ] = false ; } } for ( int n = 0 ; n < r ; n ++ ) { int [ ] data = reader . readArray ( ) ; for ( int i = data [ 0 ] ; i <= data [ 2 ] ; i ++ ) { for ( int j = data [ 1 ] ; j <= data [ 3 ] ; j ++ ) { g [ i ] [ j ] = true ; } } } long alive = 1 ; int turns = 0 ; while ( alive > 0 ) { alive = 0 ; for ( int s = 200 ; s >= 0 ; s -- ) { for ( int i = 0 ; i <= s && i <= 100 ; i ++ ) { int j = s - i ; if ( j >= 0 && j <= 100 ) { int neighs = 0 ; if ( i > 0 && g [ i - 1 ] [ j ] ) neighs ++ ; if ( j > 0 && g [ i ] [ j - 1 ] ) neighs ++ ; if ( neighs == 0 ) g [ i ] [ j ] = false ; if ( neighs == 2 ) g [ i ] [ j ] = true ; if ( g [ i ] [ j ] ) alive ++ ; } } } turns ++ ; } output ( turns ) ; }"]]}, {"id": "8", "code": "import java . util . * ; import java . io . * ; public class x { public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { boolean [ ] [ ] z = new boolean [ 101 ] [ 101 ] ; int r = in . nextInt ( ) , cnt = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int x1 = in . nextInt ( ) , y1 = in . nextInt ( ) , x2 = in . nextInt ( ) , y2 = in . nextInt ( ) ; for ( int a = x1 ; a <= x2 ; a ++ ) for ( int b = y1 ; b <= y2 ; b ++ ) { if ( ! z [ a ] [ b ] ) ++ cnt ; z [ a ] [ b ] = true ; } } int s ; for ( s = 1 ; ; s ++ ) { for ( int i = 100 ; i >= 1 ; i -- ) for ( int j = 100 ; j >= 1 ; j -- ) { if ( z [ i - 1 ] [ j ] && z [ i ] [ j - 1 ] && ! z [ i ] [ j ] ) { z [ i ] [ j ] = true ; ++ cnt ; } if ( ! z [ i - 1 ] [ j ] && ! z [ i ] [ j - 1 ] && z [ i ] [ j ] ) { z [ i ] [ j ] = false ; -- cnt ; } } if ( cnt == 0 ) break ; } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + s ) ; } ; } ; } ;", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { boolean [ ] [ ] z = new boolean [ 101 ] [ 101 ] ; int r = in . nextInt ( ) , cnt = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int x1 = in . nextInt ( ) , y1 = in . nextInt ( ) , x2 = in . nextInt ( ) , y2 = in . nextInt ( ) ; for ( int a = x1 ; a <= x2 ; a ++ ) for ( int b = y1 ; b <= y2 ; b ++ ) { if ( ! z [ a ] [ b ] ) ++ cnt ; z [ a ] [ b ] = true ; } } int s ; for ( s = 1 ; ; s ++ ) { for ( int i = 100 ; i >= 1 ; i -- ) for ( int j = 100 ; j >= 1 ; j -- ) { if ( z [ i - 1 ] [ j ] && z [ i ] [ j - 1 ] && ! z [ i ] [ j ] ) { z [ i ] [ j ] = true ; ++ cnt ; } if ( ! z [ i - 1 ] [ j ] && ! z [ i ] [ j - 1 ] && z [ i ] [ j ] ) { z [ i ] [ j ] = false ; -- cnt ; } } if ( cnt == 0 ) break ; } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + s ) ; } ; }"]], "functions_class": []}, {"id": "13", "code": "import java . util . * ; public class Bacteria { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solveCase ( ) ) ; } } static int solveCase ( ) { boolean [ ] [ ] grid = new boolean [ 300 ] [ 300 ] ; boolean [ ] [ ] temp = new boolean [ 300 ] [ 300 ] ; int R = sc . nextInt ( ) ; for ( int i = 0 ; i < R ; i ++ ) { int x1 = sc . nextInt ( ) , y1 = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) , y2 = sc . nextInt ( ) ; x1 -- ; x2 -- ; y1 -- ; y2 -- ; for ( int x = x1 ; x <= x2 ; x ++ ) for ( int y = y1 ; y <= y2 ; y ++ ) grid [ y ] [ x ] = true ; } int res = 0 ; while ( true ) { boolean alive = false ; for ( int i = 0 ; i < grid . length ; i ++ ) for ( int j = 0 ; j < grid [ i ] . length ; j ++ ) alive |= grid [ i ] [ j ] ; if ( ! alive ) break ; for ( boolean [ ] arr : temp ) Arrays . fill ( arr , false ) ; for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ i ] . length ; j ++ ) { boolean north = i > 0 && grid [ i - 1 ] [ j ] ; boolean west = j > 0 && grid [ i ] [ j - 1 ] ; temp [ i ] [ j ] = ( grid [ i ] [ j ] && ( north || west ) ) || ( north && west ) ; } } boolean [ ] [ ] t = temp ; temp = grid ; grid = t ; res ++ ; } return res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solveCase ( ) ) ; } }"], ["solveCase", "static int solveCase ( ) { boolean [ ] [ ] grid = new boolean [ 300 ] [ 300 ] ; boolean [ ] [ ] temp = new boolean [ 300 ] [ 300 ] ; int R = sc . nextInt ( ) ; for ( int i = 0 ; i < R ; i ++ ) { int x1 = sc . nextInt ( ) , y1 = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) , y2 = sc . nextInt ( ) ; x1 -- ; x2 -- ; y1 -- ; y2 -- ; for ( int x = x1 ; x <= x2 ; x ++ ) for ( int y = y1 ; y <= y2 ; y ++ ) grid [ y ] [ x ] = true ; } int res = 0 ; while ( true ) { boolean alive = false ; for ( int i = 0 ; i < grid . length ; i ++ ) for ( int j = 0 ; j < grid [ i ] . length ; j ++ ) alive |= grid [ i ] [ j ] ; if ( ! alive ) break ; for ( boolean [ ] arr : temp ) Arrays . fill ( arr , false ) ; for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ i ] . length ; j ++ ) { boolean north = i > 0 && grid [ i - 1 ] [ j ] ; boolean west = j > 0 && grid [ i ] [ j - 1 ] ; temp [ i ] [ j ] = ( grid [ i ] [ j ] && ( north || west ) ) || ( north && west ) ; } } boolean [ ] [ ] t = temp ; temp = grid ; grid = t ; res ++ ; } return res ; }"]], "functions_class": []}, {"id": "17", "code": "import java . io . * ; import java . util . Scanner ; public class C { public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" C - small - attempt0 . in \" ) ) ; PrintWriter out = new PrintWriter ( \" c . out \" ) ; int C = in . nextInt ( ) ; for ( int c = 1 ; c <= C ; c ++ ) { int R = in . nextInt ( ) ; boolean [ ] [ ] gr = new boolean [ 110 ] [ 110 ] ; int k = 0 ; for ( int i = 0 ; i < R ; i ++ ) { int x1 = in . nextInt ( ) ; int y1 = in . nextInt ( ) ; int x2 = in . nextInt ( ) ; int y2 = in . nextInt ( ) ; for ( int x = x1 ; x <= x2 ; x ++ ) { for ( int y = y1 ; y <= y2 ; y ++ ) { if ( ! gr [ x ] [ y ] ) k ++ ; gr [ x ] [ y ] = true ; } } } int t = 0 ; boolean [ ] [ ] gr2 = new boolean [ 110 ] [ 110 ] , tt ; while ( k > 0 ) { for ( int x = 0 ; x < gr . length ; x ++ ) { for ( int y = 0 ; y < gr [ 0 ] . length ; y ++ ) { if ( x == 0 || y == 0 ) gr2 [ x ] [ y ] = false ; else { gr2 [ x ] [ y ] = gr [ x ] [ y ] && ( gr [ x - 1 ] [ y ] || gr [ x ] [ y - 1 ] ) || ! gr [ x ] [ y ] && gr [ x - 1 ] [ y ] && gr [ x ] [ y - 1 ] ; } if ( gr2 [ x ] [ y ] && ! gr [ x ] [ y ] ) k ++ ; if ( ! gr2 [ x ] [ y ] && gr [ x ] [ y ] ) k -- ; } } tt = gr ; gr = gr2 ; gr2 = tt ; t ++ ; } out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + t ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" C - small - attempt0 . in \" ) ) ; PrintWriter out = new PrintWriter ( \" c . out \" ) ; int C = in . nextInt ( ) ; for ( int c = 1 ; c <= C ; c ++ ) { int R = in . nextInt ( ) ; boolean [ ] [ ] gr = new boolean [ 110 ] [ 110 ] ; int k = 0 ; for ( int i = 0 ; i < R ; i ++ ) { int x1 = in . nextInt ( ) ; int y1 = in . nextInt ( ) ; int x2 = in . nextInt ( ) ; int y2 = in . nextInt ( ) ; for ( int x = x1 ; x <= x2 ; x ++ ) { for ( int y = y1 ; y <= y2 ; y ++ ) { if ( ! gr [ x ] [ y ] ) k ++ ; gr [ x ] [ y ] = true ; } } } int t = 0 ; boolean [ ] [ ] gr2 = new boolean [ 110 ] [ 110 ] , tt ; while ( k > 0 ) { for ( int x = 0 ; x < gr . length ; x ++ ) { for ( int y = 0 ; y < gr [ 0 ] . length ; y ++ ) { if ( x == 0 || y == 0 ) gr2 [ x ] [ y ] = false ; else { gr2 [ x ] [ y ] = gr [ x ] [ y ] && ( gr [ x - 1 ] [ y ] || gr [ x ] [ y - 1 ] ) || ! gr [ x ] [ y ] && gr [ x - 1 ] [ y ] && gr [ x ] [ y - 1 ] ; } if ( gr2 [ x ] [ y ] && ! gr [ x ] [ y ] ) k ++ ; if ( ! gr2 [ x ] [ y ] && gr [ x ] [ y ] ) k -- ; } } tt = gr ; gr = gr2 ; gr2 = tt ; t ++ ; } out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + t ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "16", "code": "import sys NEW_LINE def solve ( grid ) : NEW_LINE INDENT count = 0 NEW_LINE while True : NEW_LINE INDENT done = True NEW_LINE for i in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT north = i > 0 and grid [ i - 1 ] [ j ] NEW_LINE west = j > 0 and grid [ i ] [ j - 1 ] NEW_LINE if grid [ i ] [ j ] : NEW_LINE INDENT done = False NEW_LINE if not ( north or west ) : NEW_LINE INDENT grid [ i ] [ j ] = False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if north and west : NEW_LINE INDENT grid [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if done : NEW_LINE INDENT return count NEW_LINE DEDENT count += 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for x in range ( 1 , T + 1 ) : NEW_LINE INDENT grid = [ [ False for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE R = int ( input ( ) ) NEW_LINE for k in range ( R ) : NEW_LINE INDENT X1 , Y1 , X2 , Y2 = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( Y1 - 1 , Y2 ) : NEW_LINE INDENT for j in range ( X1 - 1 , X2 ) : NEW_LINE INDENT grid [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT print ( \" Case \u2581 # { } : \" . format ( x ) , solve ( grid ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT with open ( \" C - small - attempt0 . in \" ) as sys . stdin : NEW_LINE INDENT main ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solve", "def solve ( grid ) : NEW_LINE INDENT count = 0 NEW_LINE while True : NEW_LINE INDENT done = True NEW_LINE for i in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT north = i > 0 and grid [ i - 1 ] [ j ] NEW_LINE west = j > 0 and grid [ i ] [ j - 1 ] NEW_LINE if grid [ i ] [ j ] : NEW_LINE INDENT done = False NEW_LINE if not ( north or west ) : NEW_LINE INDENT grid [ i ] [ j ] = False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if north and west : NEW_LINE INDENT grid [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if done : NEW_LINE INDENT return count NEW_LINE DEDENT count += 1 NEW_LINE DEDENT DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for x in range ( 1 , T + 1 ) : NEW_LINE INDENT grid = [ [ False for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE R = int ( input ( ) ) NEW_LINE for k in range ( R ) : NEW_LINE INDENT X1 , Y1 , X2 , Y2 = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( Y1 - 1 , Y2 ) : NEW_LINE INDENT for j in range ( X1 - 1 , X2 ) : NEW_LINE INDENT grid [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT print ( \" Case \u2581 # { } : \" . format ( x ) , solve ( grid ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_10_31", "java": [{"id": "19", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class a { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; String str ; int numCases = Integer . parseInt ( br . readLine ( ) ) ; for ( int nCase = 1 ; nCase <= numCases ; nCase ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; int [ ] [ ] lines = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] sa = br . readLine ( ) . split ( \" \u2581 \" ) ; lines [ i ] [ 0 ] = Integer . parseInt ( sa [ 0 ] ) ; lines [ i ] [ 1 ] = Integer . parseInt ( sa [ 1 ] ) ; } int answer = 0 ; if ( N == 1 ) answer = 0 ; else if ( N == 2 ) { if ( ( lines [ 0 ] [ 0 ] < lines [ 1 ] [ 0 ] && lines [ 0 ] [ 1 ] > lines [ 1 ] [ 1 ] ) || ( lines [ 0 ] [ 0 ] > lines [ 1 ] [ 0 ] && lines [ 0 ] [ 1 ] < lines [ 1 ] [ 1 ] ) ) answer = 1 ; } else answer = 666 ; System . out . println ( \" Case \u2581 # \" + nCase + \" : \u2581 \" + answer ) ; } br . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; String str ; int numCases = Integer . parseInt ( br . readLine ( ) ) ; for ( int nCase = 1 ; nCase <= numCases ; nCase ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; int [ ] [ ] lines = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] sa = br . readLine ( ) . split ( \" \u2581 \" ) ; lines [ i ] [ 0 ] = Integer . parseInt ( sa [ 0 ] ) ; lines [ i ] [ 1 ] = Integer . parseInt ( sa [ 1 ] ) ; } int answer = 0 ; if ( N == 1 ) answer = 0 ; else if ( N == 2 ) { if ( ( lines [ 0 ] [ 0 ] < lines [ 1 ] [ 0 ] && lines [ 0 ] [ 1 ] > lines [ 1 ] [ 1 ] ) || ( lines [ 0 ] [ 0 ] > lines [ 1 ] [ 0 ] && lines [ 0 ] [ 1 ] < lines [ 1 ] [ 1 ] ) ) answer = 1 ; } else answer = 666 ; System . out . println ( \" Case \u2581 # \" + nCase + \" : \u2581 \" + answer ) ; } br . close ( ) ; }"]], "functions_class": []}, {"id": "13", "code": "import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . LinkedList ; import java . util . List ; public class RopeIntranet { public static void main ( String [ ] args ) throws IOException { RandomAccessFile in = new RandomAccessFile ( args [ 0 ] , \" r \" ) ; RandomAccessFile out = new RandomAccessFile ( args [ 1 ] , \" rw \" ) ; int caseCount = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 1 ; i <= caseCount ; i ++ ) { List < Integer > A = new LinkedList < Integer > ( ) ; List < Integer > B = new LinkedList < Integer > ( ) ; int N = Integer . parseInt ( in . readLine ( ) . trim ( ) ) ; for ( int j = 0 ; j < N ; j ++ ) { String [ ] temp = in . readLine ( ) . trim ( ) . split ( \" \u2581 \" ) ; A . add ( Integer . parseInt ( temp [ 0 ] ) ) ; B . add ( Integer . parseInt ( temp [ 1 ] ) ) ; } String result = \" Case \u2581 # \" ; int retCode = calculate ( A , B ) ; result = result + i + \" : \u2581 \" + retCode + \" \\n \" ; out . writeBytes ( result ) ; } } public static int calculate ( List < Integer > A , List < Integer > B ) { int ret = 0 ; int length = A . size ( ) ; for ( int i = 1 ; i < length ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) { if ( ( A . get ( i ) - A . get ( j ) ) * ( B . get ( i ) - B . get ( j ) ) < 0 ) { ret ++ ; } } return ret ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { RandomAccessFile in = new RandomAccessFile ( args [ 0 ] , \" r \" ) ; RandomAccessFile out = new RandomAccessFile ( args [ 1 ] , \" rw \" ) ; int caseCount = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 1 ; i <= caseCount ; i ++ ) { List < Integer > A = new LinkedList < Integer > ( ) ; List < Integer > B = new LinkedList < Integer > ( ) ; int N = Integer . parseInt ( in . readLine ( ) . trim ( ) ) ; for ( int j = 0 ; j < N ; j ++ ) { String [ ] temp = in . readLine ( ) . trim ( ) . split ( \" \u2581 \" ) ; A . add ( Integer . parseInt ( temp [ 0 ] ) ) ; B . add ( Integer . parseInt ( temp [ 1 ] ) ) ; } String result = \" Case \u2581 # \" ; int retCode = calculate ( A , B ) ; result = result + i + \" : \u2581 \" + retCode + \" \\n \" ; out . writeBytes ( result ) ; } }"], ["calculate", "public static int calculate ( List < Integer > A , List < Integer > B ) { int ret = 0 ; int length = A . size ( ) ; for ( int i = 1 ; i < length ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) { if ( ( A . get ( i ) - A . get ( j ) ) * ( B . get ( i ) - B . get ( j ) ) < 0 ) { ret ++ ; } } return ret ; }"]], "functions_class": []}, {"id": "10", "code": "package QualC2010 ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Rope { public static void main ( String [ ] args ) throws Exception { BufferedReader B = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; PrintWriter A = new PrintWriter ( new FileWriter ( \" A - large . out \" ) ) ; int N , n , x , y , i , j , k ; StringTokenizer st ; int [ ] [ ] wire ; int t = Integer . parseInt ( B . readLine ( ) ) ; for ( int T = 0 ; T < t ; T ++ ) { n = 0 ; N = Integer . parseInt ( B . readLine ( ) ) ; wire = new int [ N ] [ 2 ] ; for ( i = 0 ; i < N ; i ++ ) { st = new StringTokenizer ( B . readLine ( ) ) ; wire [ i ] [ 0 ] = Integer . parseInt ( st . nextToken ( ) ) ; wire [ i ] [ 1 ] = Integer . parseInt ( st . nextToken ( ) ) ; } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { if ( ( wire [ i ] [ 0 ] - wire [ j ] [ 0 ] ) * ( wire [ i ] [ 1 ] - wire [ j ] [ 1 ] ) < 0 ) { n ++ ; } } } A . println ( \" Case \u2581 # \" + ( T + 1 ) + \" : \u2581 \" + n ) ; } A . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader B = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; PrintWriter A = new PrintWriter ( new FileWriter ( \" A - large . out \" ) ) ; int N , n , x , y , i , j , k ; StringTokenizer st ; int [ ] [ ] wire ; int t = Integer . parseInt ( B . readLine ( ) ) ; for ( int T = 0 ; T < t ; T ++ ) { n = 0 ; N = Integer . parseInt ( B . readLine ( ) ) ; wire = new int [ N ] [ 2 ] ; for ( i = 0 ; i < N ; i ++ ) { st = new StringTokenizer ( B . readLine ( ) ) ; wire [ i ] [ 0 ] = Integer . parseInt ( st . nextToken ( ) ) ; wire [ i ] [ 1 ] = Integer . parseInt ( st . nextToken ( ) ) ; } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { if ( ( wire [ i ] [ 0 ] - wire [ j ] [ 0 ] ) * ( wire [ i ] [ 1 ] - wire [ j ] [ 1 ] ) < 0 ) { n ++ ; } } } A . println ( \" Case \u2581 # \" + ( T + 1 ) + \" : \u2581 \" + n ) ; } A . close ( ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . util . Scanner ; import java . util . Locale ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; public class Problem implements Runnable { private final Scanner scanner ; private final PrintWriter printer ; private String solveSingle ( ) { int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; b [ i ] = scanner . nextInt ( ) ; } int isect = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] > a [ j ] && b [ i ] < b [ j ] ) { isect ++ ; } } } return String . valueOf ( isect ) ; } private void solve ( ) throws Exception { int cases = scanner . nextInt ( ) ; for ( int test = 1 ; test <= cases ; test ++ ) { printer . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + solveSingle ( ) ) ; } } private Problem ( ) throws FileNotFoundException { scanner = new Scanner ( new File ( \" a - large . in \" ) ) ; printer = new PrintWriter ( new File ( \" a - large . out \" ) ) ; } public void run ( ) { try { solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } finally { printer . close ( ) ; } } public static void main ( String [ ] args ) throws FileNotFoundException { Locale . setDefault ( Locale . US ) ; new Thread ( new Problem ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Locale . setDefault ( Locale . US ) ; new Thread ( new Problem ( ) ) . start ( ) ; }"]], "functions_class": [["solveSingle", "private String solveSingle ( ) { int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; b [ i ] = scanner . nextInt ( ) ; } int isect = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] > a [ j ] && b [ i ] < b [ j ] ) { isect ++ ; } } } return String . valueOf ( isect ) ; }"], ["solve", "private void solve ( ) throws Exception { int cases = scanner . nextInt ( ) ; for ( int test = 1 ; test <= cases ; test ++ ) { printer . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + solveSingle ( ) ) ; } }"], ["Problem", "private Problem ( ) throws FileNotFoundException { scanner = new Scanner ( new File ( \" a - large . in \" ) ) ; printer = new PrintWriter ( new File ( \" a - large . out \" ) ) ; }"], ["run", "public void run ( ) { try { solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } finally { printer . close ( ) ; } }"]]}, {"id": "15", "code": "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . util . Scanner ; public class A { A ( ) throws Exception { File input = new File ( \" input . txt \" ) , output = new File ( \" output . txt \" ) ; Scanner scanner = new Scanner ( input ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( output ) ) ; int TestCases = scanner . nextInt ( ) ; for ( int Case = 1 ; Case <= TestCases ; Case ++ ) { writer . write ( \" Case \u2581 # \" + Case + \" : \u2581 \" ) ; int Wires = scanner . nextInt ( ) ; int [ ] A = new int [ Wires ] , B = new int [ Wires ] ; int count = 0 ; for ( int i = 0 ; i < Wires ; i ++ ) { A [ i ] = scanner . nextInt ( ) ; B [ i ] = scanner . nextInt ( ) ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ i ] > A [ j ] && B [ i ] < B [ j ] || A [ i ] < A [ j ] && B [ i ] > B [ j ] ) count ++ ; } } writer . write ( count + \" \" ) ; writer . newLine ( ) ; } scanner . close ( ) ; writer . close ( ) ; } public static void main ( String [ ] args ) throws Exception { new A ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new A ( ) ; }"]], "functions_class": [["A", "A ( ) throws Exception { File input = new File ( \" input . txt \" ) , output = new File ( \" output . txt \" ) ; Scanner scanner = new Scanner ( input ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( output ) ) ; int TestCases = scanner . nextInt ( ) ; for ( int Case = 1 ; Case <= TestCases ; Case ++ ) { writer . write ( \" Case \u2581 # \" + Case + \" : \u2581 \" ) ; int Wires = scanner . nextInt ( ) ; int [ ] A = new int [ Wires ] , B = new int [ Wires ] ; int count = 0 ; for ( int i = 0 ; i < Wires ; i ++ ) { A [ i ] = scanner . nextInt ( ) ; B [ i ] = scanner . nextInt ( ) ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ i ] > A [ j ] && B [ i ] < B [ j ] || A [ i ] < A [ j ] && B [ i ] > B [ j ] ) count ++ ; } } writer . write ( count + \" \" ) ; writer . newLine ( ) ; } scanner . close ( ) ; writer . close ( ) ; }"]]}], "python": [{"id": "11", "code": "import sys NEW_LINE class Rope : NEW_LINE INDENT def __init__ ( self , point1 , point2 ) : NEW_LINE INDENT self . A = point1 NEW_LINE self . B = point2 NEW_LINE DEDENT def intersects ( self , rope ) : NEW_LINE INDENT if ( ( self . A - rope . A ) * ( self . B - rope . B ) ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT def main ( argv ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE ropes = [ ] NEW_LINE intersects = 0 NEW_LINE for j in range ( T ) : NEW_LINE INDENT line = sys . stdin . readline ( ) . split ( \" \u2581 \" ) NEW_LINE thisRope = Rope ( int ( line [ 0 ] ) , int ( line [ 1 ] ) ) NEW_LINE for otherRope in ropes : NEW_LINE INDENT if thisRope . intersects ( otherRope ) : NEW_LINE INDENT intersects += 1 NEW_LINE DEDENT DEDENT ropes . append ( thisRope ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( i , intersects ) ) NEW_LINE DEDENT DEDENT main ( sys . argv ) NEW_LINE", "functions_standalone": [["main", "def main ( argv ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE ropes = [ ] NEW_LINE intersects = 0 NEW_LINE for j in range ( T ) : NEW_LINE INDENT line = sys . stdin . readline ( ) . split ( \" \u2581 \" ) NEW_LINE thisRope = Rope ( int ( line [ 0 ] ) , int ( line [ 1 ] ) ) NEW_LINE for otherRope in ropes : NEW_LINE INDENT if thisRope . intersects ( otherRope ) : NEW_LINE INDENT intersects += 1 NEW_LINE DEDENT DEDENT ropes . append ( thisRope ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( i , intersects ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": [["__init__", "def __init__ ( self , point1 , point2 ) : NEW_LINE INDENT self . A = point1 NEW_LINE self . B = point2 NEW_LINE DEDENT"], ["intersects", "def intersects ( self , rope ) : NEW_LINE INDENT if ( ( self . A - rope . A ) * ( self . B - rope . B ) ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT"]]}, {"id": "0", "code": "def debug ( * args ) : NEW_LINE INDENT return NEW_LINE DEDENT def memoizing ( func ) : NEW_LINE INDENT memos = dict ( ) NEW_LINE def memoize ( * args ) : NEW_LINE INDENT if args in memos : NEW_LINE INDENT return memos [ args ] NEW_LINE DEDENT res = func ( * args ) NEW_LINE memos [ args ] = res NEW_LINE return res NEW_LINE DEDENT return memoize NEW_LINE DEDENT def run_process ( args ) : NEW_LINE INDENT res = solve_problem ( * args ) NEW_LINE return res NEW_LINE DEDENT def process_file ( fin , fout ) : NEW_LINE INDENT def get_problem ( ) : NEW_LINE INDENT N = int ( fin . readline ( ) . strip ( ' \\n ' ) ) NEW_LINE W = [ list ( map ( int , fin . readline ( ) . split ( ' \u2581 ' ) ) ) for n in range ( N ) ] NEW_LINE return ( W , ) NEW_LINE DEDENT numLines = int ( fin . readline ( ) ) NEW_LINE problem_list = [ get_problem ( ) for i in range ( numLines ) ] NEW_LINE if False : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE p = Pool ( 8 ) NEW_LINE solution_list = p . map ( run_process , problem_list ) NEW_LINE DEDENT else : NEW_LINE INDENT solution_list = map ( run_process , problem_list ) NEW_LINE DEDENT for i , s in enumerate ( solution_list ) : NEW_LINE INDENT fout . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , s ) ) NEW_LINE DEDENT DEDENT def wires_intersect ( a , b ) : NEW_LINE INDENT c = ( a [ 0 ] - b [ 0 ] , a [ 1 ] - b [ 1 ] ) NEW_LINE return ( c [ 0 ] < 0 ) ^ ( c [ 1 ] < 0 ) NEW_LINE DEDENT def solve_problem ( W ) : NEW_LINE INDENT L = list ( ) NEW_LINE intersections = 0 NEW_LINE for w in W : NEW_LINE INDENT for l in L : NEW_LINE INDENT if wires_intersect ( w , l ) : NEW_LINE INDENT intersections += 1 NEW_LINE DEDENT DEDENT L . append ( w ) NEW_LINE DEDENT return intersections NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT from sys import argv NEW_LINE process_file ( open ( argv [ 1 ] ) , open ( argv [ 1 ] . replace ( \" in \" , \" out \" ) , \" w \" ) ) NEW_LINE DEDENT", "functions_standalone": [["debug", "def debug ( * args ) : NEW_LINE INDENT return NEW_LINE DEDENT"], ["memoizing", "def memoizing ( func ) : NEW_LINE INDENT memos = dict ( ) NEW_LINE def memoize ( * args ) : NEW_LINE INDENT if args in memos : NEW_LINE INDENT return memos [ args ] NEW_LINE DEDENT res = func ( * args ) NEW_LINE memos [ args ] = res NEW_LINE return res NEW_LINE DEDENT return memoize NEW_LINE DEDENT"], ["run_process", "def run_process ( args ) : NEW_LINE INDENT res = solve_problem ( * args ) NEW_LINE return res NEW_LINE DEDENT"], ["process_file", "def process_file ( fin , fout ) : NEW_LINE INDENT def get_problem ( ) : NEW_LINE INDENT N = int ( fin . readline ( ) . strip ( ' \\n ' ) ) NEW_LINE W = [ list ( map ( int , fin . readline ( ) . split ( ' \u2581 ' ) ) ) for n in range ( N ) ] NEW_LINE return ( W , ) NEW_LINE DEDENT numLines = int ( fin . readline ( ) ) NEW_LINE problem_list = [ get_problem ( ) for i in range ( numLines ) ] NEW_LINE if False : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE p = Pool ( 8 ) NEW_LINE solution_list = p . map ( run_process , problem_list ) NEW_LINE DEDENT else : NEW_LINE INDENT solution_list = map ( run_process , problem_list ) NEW_LINE DEDENT for i , s in enumerate ( solution_list ) : NEW_LINE INDENT fout . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( i + 1 , s ) ) NEW_LINE DEDENT DEDENT"], ["wires_intersect", "def wires_intersect ( a , b ) : NEW_LINE INDENT c = ( a [ 0 ] - b [ 0 ] , a [ 1 ] - b [ 1 ] ) NEW_LINE return ( c [ 0 ] < 0 ) ^ ( c [ 1 ] < 0 ) NEW_LINE DEDENT"], ["solve_problem", "def solve_problem ( W ) : NEW_LINE INDENT L = list ( ) NEW_LINE intersections = 0 NEW_LINE for w in W : NEW_LINE INDENT for l in L : NEW_LINE INDENT if wires_intersect ( w , l ) : NEW_LINE INDENT intersections += 1 NEW_LINE DEDENT DEDENT L . append ( w ) NEW_LINE DEDENT return intersections NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = open ( \" A - large . in \" , \" r \" ) NEW_LINE fout = open ( \" A - large . out \" , \" w \" ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT N = int ( f . readline ( ) ) NEW_LINE a_list = [ ] NEW_LINE b_list = [ ] NEW_LINE for j in xrange ( N ) : NEW_LINE INDENT a , b = [ int ( x ) for x in f . readline ( ) . split ( ) ] NEW_LINE a_list . append ( a ) NEW_LINE b_list . append ( b ) NEW_LINE DEDENT result = 0 NEW_LINE for j in xrange ( N ) : NEW_LINE INDENT for k in xrange ( j + 1 , N ) : NEW_LINE INDENT if a_list [ j ] < a_list [ k ] and b_list [ j ] > b_list [ k ] : result += 1 NEW_LINE if a_list [ j ] > a_list [ k ] and b_list [ j ] < b_list [ k ] : result += 1 NEW_LINE DEDENT DEDENT fout . write ( ' ' . join ( ( ' Case \u2581 # ' , str ( i + 1 ) , ' : \u2581 ' , str ( result ) , ' \\n ' ) ) ) NEW_LINE DEDENT fout . close ( ) NEW_LINE f . close ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "14", "code": "import sys , itertools NEW_LINE from pprint import pprint NEW_LINE from collections import namedtuple NEW_LINE output_line = \" Case \u2581 # { X : d } : \u2581 { Y : d } \" NEW_LINE Rope = namedtuple ( \" Rope \" , \" a \u2581 b \" ) NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT infile , outfile = sys . argv [ 1 : ] NEW_LINE with open ( infile , \" r \" ) as inhandle , open ( outfile , \" w \" ) as outhandle : NEW_LINE INDENT T = int ( inhandle . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N = int ( inhandle . readline ( ) ) NEW_LINE ropes = [ Rope ( * map ( int , inhandle . readline ( ) . split ( ) ) ) for n in range ( N ) ] NEW_LINE ropes . sort ( ) NEW_LINE total = 0 NEW_LINE for ropeA in ropes : NEW_LINE INDENT for ropeB in ropes : NEW_LINE INDENT if ( ( ropeA . a < ropeB . a and ropeA . b > ropeB . b ) or ( ropeA . a > ropeB . a and ropeA . b < ropeB . b ) ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT DEDENT assert ( total % 2 == 0 ) NEW_LINE total = total // 2 NEW_LINE print ( output_line . format ( X = t + 1 , Y = total ) , file = outhandle ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "T = int ( input ( ) ) NEW_LINE for testCase in range ( 0 , T ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE for n in range ( 0 , N ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE A . append ( ( int ( line [ 0 ] ) , int ( line [ 1 ] ) ) ) NEW_LINE DEDENT A . sort ( ) NEW_LINE s = 0 NEW_LINE for a0 , b0 in A : NEW_LINE INDENT i = 0 NEW_LINE while A [ i ] [ 0 ] < a0 : NEW_LINE INDENT if A [ i ] [ 1 ] > b0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT print ( ' Case \u2581 # { 0 } : \u2581 { 1 } ' . format ( testCase + 1 , s ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_10_54", "java": [{"id": "2", "code": "package round3 ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class D { private int s ; private boolean [ ] [ ] z ; private int d ; public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( D . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( D . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new D ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; } private String solve ( Scanner in ) { int n = in . nextInt ( ) ; d = in . nextInt ( ) ; s = 0 ; z = new boolean [ 10 ] [ d ] ; calc ( n , 0 ) ; return \" \" + s ; } private void calc ( int n , int p ) { if ( n == 0 ) { s ++ ; return ; } for ( int i = p + 1 ; i <= n ; i ++ ) { int j = i ; int k = 0 ; boolean ok = true ; while ( j > 0 ) { if ( z [ k ] [ j % d ] ) { ok = false ; break ; } j /= d ; k ++ ; } if ( ok ) { j = i ; k = 0 ; while ( j > 0 ) { z [ k ] [ j % d ] = true ; j /= d ; k ++ ; } calc ( n - i , i ) ; j = i ; k = 0 ; while ( j > 0 ) { z [ k ] [ j % d ] = false ; j /= d ; k ++ ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( D . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( D . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new D ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private String solve ( Scanner in ) { int n = in . nextInt ( ) ; d = in . nextInt ( ) ; s = 0 ; z = new boolean [ 10 ] [ d ] ; calc ( n , 0 ) ; return \" \" + s ; }"], ["calc", "private void calc ( int n , int p ) { if ( n == 0 ) { s ++ ; return ; } for ( int i = p + 1 ; i <= n ; i ++ ) { int j = i ; int k = 0 ; boolean ok = true ; while ( j > 0 ) { if ( z [ k ] [ j % d ] ) { ok = false ; break ; } j /= d ; k ++ ; } if ( ok ) { j = i ; k = 0 ; while ( j > 0 ) { z [ k ] [ j % d ] = true ; j /= d ; k ++ ; } calc ( n - i , i ) ; j = i ; k = 0 ; while ( j > 0 ) { z [ k ] [ j % d ] = false ; j /= d ; k ++ ; } } } }"]]}], "python": [{"id": "0", "code": "n = 0 NEW_LINE b = 0 NEW_LINE used = set ( [ ] ) NEW_LINE counter = 0 NEW_LINE def count ( n , minnum , b ) : NEW_LINE INDENT global counter NEW_LINE for num in range ( minnum , n + 1 ) : NEW_LINE INDENT rep = [ ] NEW_LINE nnum = num NEW_LINE while nnum > 0 : NEW_LINE INDENT rep . append ( nnum % b ) NEW_LINE nnum = nnum / b NEW_LINE DEDENT ok = True NEW_LINE for i in range ( len ( rep ) ) : NEW_LINE INDENT if ( i , rep [ i ] ) in used : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT if ok : NEW_LINE INDENT for i in range ( len ( rep ) ) : NEW_LINE INDENT used . add ( ( i , rep [ i ] ) ) NEW_LINE DEDENT if n - num == 0 : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count ( n - num , num + 1 , b ) NEW_LINE DEDENT for i in range ( len ( rep ) ) : NEW_LINE INDENT used . remove ( ( i , rep [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT [ n , b ] = map ( lambda x : int ( x ) , raw_input ( ) . split ( ) ) NEW_LINE counter = 0 NEW_LINE used = set ( [ ] ) NEW_LINE count ( n , 1 , b ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \" % ( i + 1 , counter ) ) NEW_LINE DEDENT", "functions_standalone": [["count", "def count ( n , minnum , b ) : NEW_LINE INDENT global counter NEW_LINE for num in range ( minnum , n + 1 ) : NEW_LINE INDENT rep = [ ] NEW_LINE nnum = num NEW_LINE while nnum > 0 : NEW_LINE INDENT rep . append ( nnum % b ) NEW_LINE nnum = nnum / b NEW_LINE DEDENT ok = True NEW_LINE for i in range ( len ( rep ) ) : NEW_LINE INDENT if ( i , rep [ i ] ) in used : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT if ok : NEW_LINE INDENT for i in range ( len ( rep ) ) : NEW_LINE INDENT used . add ( ( i , rep [ i ] ) ) NEW_LINE DEDENT if n - num == 0 : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count ( n - num , num + 1 , b ) NEW_LINE DEDENT for i in range ( len ( rep ) ) : NEW_LINE INDENT used . remove ( ( i , rep [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_10_01", "java": [{"id": "19", "code": "package code10 . qualification ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; public class A { public static String solve ( int N , long K , int [ ] times ) { String result = \" \" ; int time = times [ N ] ; if ( K < time ) { result = \" OFF \" ; } else if ( K == time ) { result = \" ON \" ; } else { long remain = K - time ; if ( remain % ( time + 1 ) == 0 ) { result = \" ON \" ; } else { result = \" OFF \" ; } } return result ; } public static void initTimes ( int [ ] times ) { times [ 1 ] = 1 ; for ( int i = 2 ; i < times . length ; i ++ ) { times [ i ] = times [ i - 1 ] * 2 + 1 ; } } public static void main ( String [ ] args ) throws Exception { String fileName = \" A - large \" ; File inputFile = new File ( fileName + \" . in \" ) ; File outputFile = new File ( fileName + \" . out \" ) ; FileReader reader = new FileReader ( inputFile ) ; FileWriter writer = new FileWriter ( outputFile ) ; StringBuilder inputLine = new StringBuilder ( ) ; String [ ] inputPart ; int totalCase ; char c = 0 ; int N = 0 ; long K = 0 ; int [ ] times = new int [ 31 ] ; initTimes ( times ) ; while ( ( c = ( char ) reader . read ( ) ) != ' \\n ' ) { inputLine . append ( c ) ; } totalCase = Integer . parseInt ( inputLine . toString ( ) ) ; for ( int caseIndex = 1 ; caseIndex <= totalCase ; caseIndex ++ ) { inputLine = new StringBuilder ( ) ; while ( ( c = ( char ) reader . read ( ) ) != ' \\n ' ) { inputLine . append ( c ) ; } inputPart = inputLine . toString ( ) . split ( \" \u2581 \" ) ; N = Integer . parseInt ( inputPart [ 0 ] ) ; K = Long . parseLong ( inputPart [ 1 ] ) ; String output = \" Case \u2581 # \" + caseIndex + \" : \u2581 \" + solve ( N , K , times ) ; System . out . println ( output ) ; writer . write ( output + \" \\n \" ) ; } reader . close ( ) ; writer . close ( ) ; } }", "functions_standalone": [["solve", "public static String solve ( int N , long K , int [ ] times ) { String result = \" \" ; int time = times [ N ] ; if ( K < time ) { result = \" OFF \" ; } else if ( K == time ) { result = \" ON \" ; } else { long remain = K - time ; if ( remain % ( time + 1 ) == 0 ) { result = \" ON \" ; } else { result = \" OFF \" ; } } return result ; }"], ["initTimes", "public static void initTimes ( int [ ] times ) { times [ 1 ] = 1 ; for ( int i = 2 ; i < times . length ; i ++ ) { times [ i ] = times [ i - 1 ] * 2 + 1 ; } }"], ["main", "public static void main ( String [ ] args ) throws Exception { String fileName = \" A - large \" ; File inputFile = new File ( fileName + \" . in \" ) ; File outputFile = new File ( fileName + \" . out \" ) ; FileReader reader = new FileReader ( inputFile ) ; FileWriter writer = new FileWriter ( outputFile ) ; StringBuilder inputLine = new StringBuilder ( ) ; String [ ] inputPart ; int totalCase ; char c = 0 ; int N = 0 ; long K = 0 ; int [ ] times = new int [ 31 ] ; initTimes ( times ) ; while ( ( c = ( char ) reader . read ( ) ) != ' \\n ' ) { inputLine . append ( c ) ; } totalCase = Integer . parseInt ( inputLine . toString ( ) ) ; for ( int caseIndex = 1 ; caseIndex <= totalCase ; caseIndex ++ ) { inputLine = new StringBuilder ( ) ; while ( ( c = ( char ) reader . read ( ) ) != ' \\n ' ) { inputLine . append ( c ) ; } inputPart = inputLine . toString ( ) . split ( \" \u2581 \" ) ; N = Integer . parseInt ( inputPart [ 0 ] ) ; K = Long . parseLong ( inputPart [ 1 ] ) ; String output = \" Case \u2581 # \" + caseIndex + \" : \u2581 \" + solve ( N , K , times ) ; System . out . println ( output ) ; writer . write ( output + \" \\n \" ) ; } reader . close ( ) ; writer . close ( ) ; }"]], "functions_class": []}, {"id": "5", "code": "import java . io . * ; import java . util . * ; import java . text . * ; public class SnapperChain { public PrintStream out = System . out ; public PrintStream err = System . err ; public Scanner in = new Scanner ( System . in ) ; public DecimalFormat fmt = new DecimalFormat ( \"0.000000000\" ) ; public void main ( ) { try { int TCase , cc ; TCase = in . nextInt ( ) ; for ( cc = 1 ; cc <= TCase ; ++ cc ) { long n , K , L ; n = in . nextLong ( ) ; K = in . nextLong ( ) ; L = ( 1L << n ) ; out . println ( \" Case \u2581 # \" + cc + \" : \u2581 \" + ( ( K % ( L ) == ( L ) - 1 ) ? \" ON \" : \" OFF \" ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } public int iInt ( ) { return in . nextInt ( ) ; } public long iLong ( ) { return in . nextLong ( ) ; } public String iToken ( ) { return in . next ( ) ; } public String iLine ( ) { return in . nextLine ( ) ; } public static void main ( String [ ] args ) { long startTime = System . currentTimeMillis ( ) ; ( new SnapperChain ( ) ) . main ( ) ; long endTime = System . currentTimeMillis ( ) ; long ms = endTime - startTime ; long sec = ms / 1000 ; ms = ms % 1000 ; long min = sec / 60 ; sec = sec % 60 ; System . err . println ( \" Time \u2581 Spent : \u2581 \" + min + \" \u2581 minute ( s ) \u2581 \" + sec + \" \u2581 second ( s ) \u2581 \" + ms + \" \u2581 ( ms ) \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { long startTime = System . currentTimeMillis ( ) ; ( new SnapperChain ( ) ) . main ( ) ; long endTime = System . currentTimeMillis ( ) ; long ms = endTime - startTime ; long sec = ms / 1000 ; ms = ms % 1000 ; long min = sec / 60 ; sec = sec % 60 ; System . err . println ( \" Time \u2581 Spent : \u2581 \" + min + \" \u2581 minute ( s ) \u2581 \" + sec + \" \u2581 second ( s ) \u2581 \" + ms + \" \u2581 ( ms ) \" ) ; }"]], "functions_class": [["main", "public void main ( ) { try { int TCase , cc ; TCase = in . nextInt ( ) ; for ( cc = 1 ; cc <= TCase ; ++ cc ) { long n , K , L ; n = in . nextLong ( ) ; K = in . nextLong ( ) ; L = ( 1L << n ) ; out . println ( \" Case \u2581 # \" + cc + \" : \u2581 \" + ( ( K % ( L ) == ( L ) - 1 ) ? \" ON \" : \" OFF \" ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }"], ["iInt", "public int iInt ( ) { return in . nextInt ( ) ; }"], ["iLong", "public long iLong ( ) { return in . nextLong ( ) ; }"], ["iToken", "public String iToken ( ) { return in . next ( ) ; }"], ["iLine", "public String iLine ( ) { return in . nextLine ( ) ; }"]]}, {"id": "1", "code": "import java . util . * ; import java . io . * ; public class AChain { public static void main ( String [ ] args ) { if ( args . length < 1 ) { System . out . println ( \" Usage : \u2581 < fnIn > \" ) ; } String fn = args [ 0 ] ; String fnOut = toFnOut ( fn ) ; try { BufferedReader br = new BufferedReader ( new FileReader ( fn ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( fnOut ) ) ; String line = null ; int NCase = Integer . valueOf ( br . readLine ( ) . trim ( ) ) ; long stime = System . currentTimeMillis ( ) ; for ( int icase = 0 ; icase < NCase ; icase ++ ) { int [ ] a = toIntArray ( br . readLine ( ) ) ; String buf = process ( a [ 0 ] , a [ 1 ] ) ; String out = \" Case \u2581 # \" + ( icase + 1 ) + \" : \u2581 \" + buf ; bw . write ( out , 0 , out . length ( ) ) ; bw . newLine ( ) ; long ctime = System . currentTimeMillis ( ) ; System . out . println ( String . format ( \" - - - \u2581 Done : \u2581 # %2d , %3.0fs , \u2581 ends \u2581 in : %2.1fm \" , ( icase + 1 ) , ( ctime - stime ) * 0.001 , ( ctime - stime ) * 0.001 / 60 * NCase / ( icase + 1 ) ) ) ; } br . close ( ) ; bw . close ( ) ; } catch ( IOException ex ) { System . out . println ( ex ) ; } } static String process ( int N , int K ) { int x = ( 1 << N ) ; while ( K >= x ) { K %= x ; } if ( K == x - 1 ) return \" ON \" ; return \" OFF \" ; } static int [ ] toIntArray ( String line ) { String [ ] p = line . trim ( ) . split ( \" \\\\ s + \" ) ; int [ ] out = new int [ p . length ] ; for ( int i = 0 ; i < out . length ; i ++ ) out [ i ] = Integer . valueOf ( p [ i ] ) ; return out ; } static String toFnOut ( String fn ) { if ( fn . lastIndexOf ( ' . ' ) != - 1 ) { return fn . substring ( 0 , fn . lastIndexOf ( ' . ' ) ) + \" . out \" ; } else return fn + \" . out \" ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { if ( args . length < 1 ) { System . out . println ( \" Usage : \u2581 < fnIn > \" ) ; } String fn = args [ 0 ] ; String fnOut = toFnOut ( fn ) ; try { BufferedReader br = new BufferedReader ( new FileReader ( fn ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( fnOut ) ) ; String line = null ; int NCase = Integer . valueOf ( br . readLine ( ) . trim ( ) ) ; long stime = System . currentTimeMillis ( ) ; for ( int icase = 0 ; icase < NCase ; icase ++ ) { int [ ] a = toIntArray ( br . readLine ( ) ) ; String buf = process ( a [ 0 ] , a [ 1 ] ) ; String out = \" Case \u2581 # \" + ( icase + 1 ) + \" : \u2581 \" + buf ; bw . write ( out , 0 , out . length ( ) ) ; bw . newLine ( ) ; long ctime = System . currentTimeMillis ( ) ; System . out . println ( String . format ( \" - - - \u2581 Done : \u2581 # %2d , %3.0fs , \u2581 ends \u2581 in : %2.1fm \" , ( icase + 1 ) , ( ctime - stime ) * 0.001 , ( ctime - stime ) * 0.001 / 60 * NCase / ( icase + 1 ) ) ) ; } br . close ( ) ; bw . close ( ) ; } catch ( IOException ex ) { System . out . println ( ex ) ; } }"], ["process", "static String process ( int N , int K ) { int x = ( 1 << N ) ; while ( K >= x ) { K %= x ; } if ( K == x - 1 ) return \" ON \" ; return \" OFF \" ; }"], ["toIntArray", "static int [ ] toIntArray ( String line ) { String [ ] p = line . trim ( ) . split ( \" \\\\ s + \" ) ; int [ ] out = new int [ p . length ] ; for ( int i = 0 ; i < out . length ; i ++ ) out [ i ] = Integer . valueOf ( p [ i ] ) ; return out ; }"], ["toFnOut", "static String toFnOut ( String fn ) { if ( fn . lastIndexOf ( ' . ' ) != - 1 ) { return fn . substring ( 0 , fn . lastIndexOf ( ' . ' ) ) + \" . out \" ; } else return fn + \" . out \" ; }"]], "functions_class": []}, {"id": "15", "code": "package codejam2010 . qualification ; import java . io . BufferedReader ; import java . io . Closeable ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; public class ProblemA { public static void main ( String [ ] args ) { BufferedReader reader = null ; PrintWriter writer = null ; try { String fileName = \" A - large \" ; File folder = new File ( new File ( \" files \" , \" codejam2010\" ) , \" qualification \" ) ; File inputFile = new File ( folder , fileName + \" . in \" ) ; File outputFile = new File ( folder , fileName + \" . out \" ) ; reader = new BufferedReader ( new FileReader ( inputFile ) ) ; writer = new PrintWriter ( new FileWriter ( outputFile ) ) ; int count = Integer . parseInt ( reader . readLine ( ) ) ; for ( int i = 0 ; i < count ; i ++ ) { String [ ] parameters = reader . readLine ( ) . split ( \" \\\\ s \" ) ; writer . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , solveIt ( Integer . parseInt ( parameters [ 0 ] ) , Integer . parseInt ( parameters [ 1 ] ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { close ( reader ) ; close ( writer ) ; } System . out . println ( \" Done . \" ) ; } private static String solveIt ( int n , int k ) { int allOn = ( 1 << n ) - 1 ; return ( ( allOn & k ) == allOn ) ? \" ON \" : \" OFF \" ; } private static void close ( Closeable file ) { if ( file != null ) { try { file . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { BufferedReader reader = null ; PrintWriter writer = null ; try { String fileName = \" A - large \" ; File folder = new File ( new File ( \" files \" , \" codejam2010\" ) , \" qualification \" ) ; File inputFile = new File ( folder , fileName + \" . in \" ) ; File outputFile = new File ( folder , fileName + \" . out \" ) ; reader = new BufferedReader ( new FileReader ( inputFile ) ) ; writer = new PrintWriter ( new FileWriter ( outputFile ) ) ; int count = Integer . parseInt ( reader . readLine ( ) ) ; for ( int i = 0 ; i < count ; i ++ ) { String [ ] parameters = reader . readLine ( ) . split ( \" \\\\ s \" ) ; writer . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , solveIt ( Integer . parseInt ( parameters [ 0 ] ) , Integer . parseInt ( parameters [ 1 ] ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { close ( reader ) ; close ( writer ) ; } System . out . println ( \" Done . \" ) ; }"], ["solveIt", "private static String solveIt ( int n , int k ) { int allOn = ( 1 << n ) - 1 ; return ( ( allOn & k ) == allOn ) ? \" ON \" : \" OFF \" ; }"], ["close", "private static void close ( Closeable file ) { if ( file != null ) { try { file . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }"]], "functions_class": []}, {"id": "7", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class A extends SolutionT { public static void main ( String [ ] args ) { ( new A ( ) ) . run ( ) ; } @ Override void runOneTest ( Scanner input , PrintWriter output ) { int n = input . nextInt ( ) ; int k = input . nextInt ( ) ; k = k % ( 1 << n ) ; if ( ( k + 1 ) == ( 1 << n ) ) { output . println ( \" ON \" ) ; } else { output . println ( \" OFF \" ) ; } } } abstract class Solution implements Runnable { abstract void runOneTest ( Scanner input , PrintWriter output ) ; public void run ( ) { Scanner input = null ; PrintWriter output = null ; try { input = new Scanner ( new File ( \" input . txt \" ) ) ; output = new PrintWriter ( new File ( \" output . txt \" ) ) ; } catch ( FileNotFoundException e ) { } int testCount = input . nextInt ( ) ; for ( int test = 1 ; test <= testCount ; test ++ ) { output . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; runOneTest ( input , output ) ; } input . close ( ) ; output . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { ( new A ( ) ) . run ( ) ; }"]], "functions_class": [["runOneTest", "void runOneTest ( Scanner input , PrintWriter output ) { int n = input . nextInt ( ) ; int k = input . nextInt ( ) ; k = k % ( 1 << n ) ; if ( ( k + 1 ) == ( 1 << n ) ) { output . println ( \" ON \" ) ; } else { output . println ( \" OFF \" ) ; } }"], ["run", "public void run ( ) { Scanner input = null ; PrintWriter output = null ; try { input = new Scanner ( new File ( \" input . txt \" ) ) ; output = new PrintWriter ( new File ( \" output . txt \" ) ) ; } catch ( FileNotFoundException e ) { } int testCount = input . nextInt ( ) ; for ( int test = 1 ; test <= testCount ; test ++ ) { output . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; runOneTest ( input , output ) ; } input . close ( ) ; output . close ( ) ; }"]]}], "python": [{"id": "14", "code": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inFile = open ( \" A - large . in \" , \" r \" ) NEW_LINE outFile = open ( \" realtest . out \" , \" w \" ) NEW_LINE caseNum = int ( inFile . readline ( ) ) NEW_LINE for i in range ( 1 , caseNum + 1 ) : NEW_LINE INDENT items = inFile . readline ( ) . replace ( \" \\n \" , \" \" ) . split ( \" \u2581 \" ) NEW_LINE N = int ( items [ 0 ] ) NEW_LINE K = int ( items [ 1 ] ) NEW_LINE lightFlag = 1 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if K % 2 == 0 : NEW_LINE INDENT lightFlag = 0 NEW_LINE break ; NEW_LINE DEDENT else : NEW_LINE INDENT K /= 2 NEW_LINE DEDENT DEDENT if lightFlag == 1 : NEW_LINE INDENT outFile . write ( \" Case \u2581 # % d : \u2581 ON \\n \" % ( i , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT outFile . write ( \" Case \u2581 # % d : \u2581 OFF \\n \" % ( i , ) ) NEW_LINE DEDENT DEDENT outFile . close ( ) NEW_LINE inFile . close ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "16", "code": "from __future__ import print_function NEW_LINE import sys NEW_LINE def main ( filename ) : NEW_LINE INDENT with open ( filename , \" r \" ) as f : NEW_LINE INDENT for case , line in enumerate ( f ) : NEW_LINE INDENT if not case : NEW_LINE INDENT T = int ( line . strip ( ) ) NEW_LINE continue NEW_LINE DEDENT if case > T : NEW_LINE INDENT break NEW_LINE DEDENT N , K = ( int ( c ) for c in line . split ( ) ) NEW_LINE state = K % ( 2 ** N ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , ( \" ON \" if state == ( 2 ** N ) - 1 else \" OFF \" ) ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( sys . argv [ 1 ] ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT", "functions_standalone": [["main", "def main ( filename ) : NEW_LINE INDENT with open ( filename , \" r \" ) as f : NEW_LINE INDENT for case , line in enumerate ( f ) : NEW_LINE INDENT if not case : NEW_LINE INDENT T = int ( line . strip ( ) ) NEW_LINE continue NEW_LINE DEDENT if case > T : NEW_LINE INDENT break NEW_LINE DEDENT N , K = ( int ( c ) for c in line . split ( ) ) NEW_LINE state = K % ( 2 ** N ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( case , ( \" ON \" if state == ( 2 ** N ) - 1 else \" OFF \" ) ) ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_10_23", "java": [{"id": "5", "code": "import java . io . * ; import java . math . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" Main . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" Main . out \" ) ) ; int tests = in . nextInt ( ) ; final int MOD = 100003 ; int [ ] [ ] f = new int [ 512 ] [ 512 ] ; for ( int m = 0 ; m < 512 ; m ++ ) f [ 0 ] [ m ] = 1 ; for ( int n = 1 ; n < 512 ; n ++ ) { for ( int m = 1 ; m <= n ; m ++ ) { f [ n ] [ m ] = 0 ; for ( int k = 1 ; k <= m ; k ++ ) { f [ n ] [ m ] = ( f [ n ] [ m ] + f [ n - k ] [ m ] ) % MOD ; } } } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) System . out . print ( f [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int ans = 0 ; for ( int h = 2 ; h <= n ; h ++ ) ans = ( ans + f [ n - 1 ] [ h - 1 ] ) % MOD ; out . println ( ans ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" Main . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" Main . out \" ) ) ; int tests = in . nextInt ( ) ; final int MOD = 100003 ; int [ ] [ ] f = new int [ 512 ] [ 512 ] ; for ( int m = 0 ; m < 512 ; m ++ ) f [ 0 ] [ m ] = 1 ; for ( int n = 1 ; n < 512 ; n ++ ) { for ( int m = 1 ; m <= n ; m ++ ) { f [ n ] [ m ] = 0 ; for ( int k = 1 ; k <= m ; k ++ ) { f [ n ] [ m ] = ( f [ n ] [ m ] + f [ n - k ] [ m ] ) % MOD ; } } } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) System . out . print ( f [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int ans = 0 ; for ( int h = 2 ; h <= n ; h ++ ) ans = ( ans + f [ n - 1 ] [ h - 1 ] ) % MOD ; out . println ( ans ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "4", "code": "import java . util . * ; import java . io . * ; public class x { static final int MOD = 100003 ; static final int MAXN = 500 ; public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; int [ ] [ ] C = new int [ MAXN + 1 ] [ MAXN + 1 ] ; for ( int i = 0 ; i <= MAXN ; i ++ ) { C [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) % MOD ; } } int [ ] [ ] D = new int [ MAXN + 1 ] [ MAXN + 1 ] ; int [ ] A = new int [ MAXN + 1 ] ; D [ 1 ] [ 0 ] = 1 ; for ( int i = 2 ; i <= MAXN ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) if ( j - k - 1 >= 0 && j - k - 1 <= i - j - 1 ) { long cur = D [ j ] [ k ] ; cur = ( D [ i ] [ j ] + cur * C [ i - j - 1 ] [ j - k - 1 ] ) % MOD ; D [ i ] [ j ] = ( int ) cur ; } A [ i ] = ( A [ i ] + D [ i ] [ j ] ) % MOD ; } } for ( int tt = 1 ; tt <= t ; tt ++ ) { int n = in . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + A [ n ] ) ; } ; } ; } ;", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; int [ ] [ ] C = new int [ MAXN + 1 ] [ MAXN + 1 ] ; for ( int i = 0 ; i <= MAXN ; i ++ ) { C [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) % MOD ; } } int [ ] [ ] D = new int [ MAXN + 1 ] [ MAXN + 1 ] ; int [ ] A = new int [ MAXN + 1 ] ; D [ 1 ] [ 0 ] = 1 ; for ( int i = 2 ; i <= MAXN ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) if ( j - k - 1 >= 0 && j - k - 1 <= i - j - 1 ) { long cur = D [ j ] [ k ] ; cur = ( D [ i ] [ j ] + cur * C [ i - j - 1 ] [ j - k - 1 ] ) % MOD ; D [ i ] [ j ] = ( int ) cur ; } A [ i ] = ( A [ i ] + D [ i ] [ j ] ) % MOD ; } } for ( int tt = 1 ; tt <= t ; tt ++ ) { int n = in . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + A [ n ] ) ; } ; }"]], "functions_class": []}, {"id": "18", "code": "import java . io . BufferedInputStream ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintStream ; import java . io . FileOutputStream ; public class Main { public static void main ( String [ ] args ) { try { File file = new File ( \" C - large . in \" ) ; FileInputStream fis = new FileInputStream ( file ) ; BufferedInputStream bis = new BufferedInputStream ( fis ) ; BufferedReader dis = new BufferedReader ( new InputStreamReader ( bis ) ) ; File ofile = new File ( \" C - large . out \" ) ; if ( ! ofile . exists ( ) ) { ofile . createNewFile ( ) ; } PrintStream out = new PrintStream ( new FileOutputStream ( ofile ) ) ; int [ ] [ ] f = new int [ 501 ] [ 501 ] ; for ( int i = 0 ; i < 501 ; i ++ ) { for ( int j = 0 ; j < 501 ; j ++ ) { if ( i == 0 ) { f [ i ] [ j ] = 1 ; } else { for ( int k = 1 ; k <= j ; k ++ ) { if ( k > i ) break ; f [ i ] [ j ] += f [ i - k ] [ j ] ; } f [ i ] [ j ] %= 100003 ; } } } int [ ] f2 = new int [ 501 ] ; for ( int i = 1 ; i < 501 ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { f2 [ i ] += f [ j ] [ i - j ] ; f2 [ i ] %= 100003 ; } } int T = Integer . parseInt ( dis . readLine ( ) ) ; int c = 0 ; while ( c ++ < T ) { out . print ( \" Case \u2581 # \" + c + \" : \u2581 \" ) ; out . println ( f2 [ Integer . parseInt ( dis . readLine ( ) ) - 1 ] ) ; } fis . close ( ) ; bis . close ( ) ; dis . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { File file = new File ( \" C - large . in \" ) ; FileInputStream fis = new FileInputStream ( file ) ; BufferedInputStream bis = new BufferedInputStream ( fis ) ; BufferedReader dis = new BufferedReader ( new InputStreamReader ( bis ) ) ; File ofile = new File ( \" C - large . out \" ) ; if ( ! ofile . exists ( ) ) { ofile . createNewFile ( ) ; } PrintStream out = new PrintStream ( new FileOutputStream ( ofile ) ) ; int [ ] [ ] f = new int [ 501 ] [ 501 ] ; for ( int i = 0 ; i < 501 ; i ++ ) { for ( int j = 0 ; j < 501 ; j ++ ) { if ( i == 0 ) { f [ i ] [ j ] = 1 ; } else { for ( int k = 1 ; k <= j ; k ++ ) { if ( k > i ) break ; f [ i ] [ j ] += f [ i - k ] [ j ] ; } f [ i ] [ j ] %= 100003 ; } } } int [ ] f2 = new int [ 501 ] ; for ( int i = 1 ; i < 501 ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { f2 [ i ] += f [ j ] [ i - j ] ; f2 [ i ] %= 100003 ; } } int T = Integer . parseInt ( dis . readLine ( ) ) ; int c = 0 ; while ( c ++ < T ) { out . print ( \" Case \u2581 # \" + c + \" : \u2581 \" ) ; out . println ( f2 [ Integer . parseInt ( dis . readLine ( ) ) - 1 ] ) ; } fis . close ( ) ; bis . close ( ) ; dis . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "12", "code": "import java . io . * ; import java . math . * ; import java . util . * ; public class C { public static void main ( String [ ] args ) { BigInteger [ ] [ ] combine = new BigInteger [ 512 ] [ 512 ] ; BigInteger [ ] [ ] a = new BigInteger [ 512 ] [ 512 ] ; BigInteger [ ] s = new BigInteger [ 512 ] ; for ( int i = 0 ; i < 512 ; i ++ ) { combine [ i ] [ 0 ] = BigInteger . ONE ; combine [ i ] [ i ] = BigInteger . ONE ; for ( int j = 1 ; j < i ; j ++ ) { combine [ i ] [ j ] = combine [ i - 1 ] [ j ] . add ( combine [ i - 1 ] [ j - 1 ] ) ; } for ( int j = 0 ; j < 512 ; j ++ ) a [ i ] [ j ] = BigInteger . ZERO ; s [ i ] = BigInteger . ZERO ; } for ( int n = 2 ; n < 512 ; n ++ ) { a [ n ] [ 1 ] = BigInteger . ONE ; for ( int m = 2 ; m < n ; m ++ ) { a [ n ] [ m ] = BigInteger . ZERO ; for ( int k = 1 ; k < m ; k ++ ) { int N = n - m - 1 ; int M = m - k - 1 ; if ( M >= 0 && M <= N ) { a [ n ] [ m ] = a [ n ] [ m ] . add ( combine [ N ] [ M ] . multiply ( a [ m ] [ k ] ) ) ; } } } for ( int m = 1 ; m < n ; m ++ ) { s [ n ] = s [ n ] . add ( a [ n ] [ m ] ) ; } } Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int cas = 1 ; cas <= tests ; cas ++ ) { int n = sc . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + ( s [ n ] . mod ( BigInteger . valueOf ( 100003 ) ) ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { BigInteger [ ] [ ] combine = new BigInteger [ 512 ] [ 512 ] ; BigInteger [ ] [ ] a = new BigInteger [ 512 ] [ 512 ] ; BigInteger [ ] s = new BigInteger [ 512 ] ; for ( int i = 0 ; i < 512 ; i ++ ) { combine [ i ] [ 0 ] = BigInteger . ONE ; combine [ i ] [ i ] = BigInteger . ONE ; for ( int j = 1 ; j < i ; j ++ ) { combine [ i ] [ j ] = combine [ i - 1 ] [ j ] . add ( combine [ i - 1 ] [ j - 1 ] ) ; } for ( int j = 0 ; j < 512 ; j ++ ) a [ i ] [ j ] = BigInteger . ZERO ; s [ i ] = BigInteger . ZERO ; } for ( int n = 2 ; n < 512 ; n ++ ) { a [ n ] [ 1 ] = BigInteger . ONE ; for ( int m = 2 ; m < n ; m ++ ) { a [ n ] [ m ] = BigInteger . ZERO ; for ( int k = 1 ; k < m ; k ++ ) { int N = n - m - 1 ; int M = m - k - 1 ; if ( M >= 0 && M <= N ) { a [ n ] [ m ] = a [ n ] [ m ] . add ( combine [ N ] [ M ] . multiply ( a [ m ] [ k ] ) ) ; } } } for ( int m = 1 ; m < n ; m ++ ) { s [ n ] = s [ n ] . add ( a [ n ] [ m ] ) ; } } Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int cas = 1 ; cas <= tests ; cas ++ ) { int n = sc . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + cas + \" : \u2581 \" + ( s [ n ] . mod ( BigInteger . valueOf ( 100003 ) ) ) ) ; } }"]], "functions_class": []}, {"id": "7", "code": "import java . io . * ; import java . util . * ; public class C implements Runnable { private String IFILE = \" C - large . in \" ; private Scanner in ; private PrintWriter out ; private int MOD = 100003 ; public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; long [ ] [ ] c = new long [ n + 1 ] [ n + 1 ] ; c [ 0 ] [ 0 ] = 1 ; for ( int j = 1 ; j <= n ; j ++ ) { c [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) c [ i ] [ j ] = ( c [ i - 1 ] [ j - 1 ] + c [ i ] [ j - 1 ] ) % MOD ; } long [ ] [ ] mas = new long [ n + 1 ] [ n + 1 ] ; for ( int j = 2 ; j <= n ; j ++ ) mas [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) { for ( int k = 1 ; k < i ; k ++ ) { mas [ i ] [ j ] = ( mas [ i ] [ j ] + mas [ k ] [ i ] * c [ j - i - 1 ] [ i - k - 1 ] ) % MOD ; } } long result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result + mas [ i ] [ n ] ) % MOD ; out . println ( result ) ; } in . close ( ) ; out . close ( ) ; } public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } } public static void main ( String [ ] args ) throws IOException { new C ( ) . Run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new C ( ) . Run ( ) ; }"]], "functions_class": [["Run", "public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; long [ ] [ ] c = new long [ n + 1 ] [ n + 1 ] ; c [ 0 ] [ 0 ] = 1 ; for ( int j = 1 ; j <= n ; j ++ ) { c [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) c [ i ] [ j ] = ( c [ i - 1 ] [ j - 1 ] + c [ i ] [ j - 1 ] ) % MOD ; } long [ ] [ ] mas = new long [ n + 1 ] [ n + 1 ] ; for ( int j = 2 ; j <= n ; j ++ ) mas [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) { for ( int k = 1 ; k < i ; k ++ ) { mas [ i ] [ j ] = ( mas [ i ] [ j ] + mas [ k ] [ i ] * c [ j - i - 1 ] [ i - k - 1 ] ) % MOD ; } } long result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result + mas [ i ] [ n ] ) % MOD ; out . println ( result ) ; } in . close ( ) ; out . close ( ) ; }"], ["run", "public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } }"]]}], "python": [{"id": "15", "code": "from sys import stdin , stdout NEW_LINE nCk = [ [ int ( ) ] * 501 for i in range ( 501 ) ] NEW_LINE for n in range ( 0 , 501 ) : NEW_LINE INDENT nCk [ n ] [ 0 ] = 1 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT nCk [ n ] [ k ] = nCk [ n ] [ k - 1 ] * ( n + 1 - k ) / k NEW_LINE DEDENT DEDENT for n in range ( 0 , 501 ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT nCk [ n ] [ k ] %= 100003 NEW_LINE DEDENT DEDENT Y = [ [ int ( ) ] * 501 for i in range ( 501 ) ] NEW_LINE y = [ int ( ) ] * 501 NEW_LINE for i in range ( 2 , 501 ) : NEW_LINE INDENT Y [ i ] [ 1 ] = 1 NEW_LINE y [ i ] = 1 NEW_LINE for j in range ( 2 , i ) : NEW_LINE INDENT for k in range ( 1 , j ) : NEW_LINE INDENT Y [ i ] [ j ] += Y [ j ] [ k ] * nCk [ i - j - 1 ] [ j - k - 1 ] NEW_LINE DEDENT y [ i ] += Y [ i ] [ j ] NEW_LINE DEDENT y [ i ] %= 100003 NEW_LINE DEDENT for x in range ( 1 , int ( stdin . readline ( ) ) + 1 ) : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE stdout . write ( ' Case \u2581 # % i : \u2581 % i \\n ' % ( x , y [ n ] ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "5", "code": "import sys NEW_LINE if ( len ( sys . argv ) < 2 ) : NEW_LINE INDENT print ( \" No \u2581 file \u2581 specified \" ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT infile = open ( sys . argv [ 1 ] ) NEW_LINE outfile = open ( sys . argv [ 1 ] + \" . out \" , \" w \" ) NEW_LINE num_cases = int ( infile . readline ( ) . strip ( ) ) NEW_LINE modulus = 100003 NEW_LINE factorial = [ 1 ] NEW_LINE for i in range ( 1 , 501 ) : NEW_LINE INDENT factorial . append ( i * factorial [ i - 1 ] ) NEW_LINE DEDENT def choose ( n , r ) : NEW_LINE INDENT return factorial [ n ] / ( factorial [ r ] * factorial [ n - r ] ) NEW_LINE DEDENT cached_results = { } NEW_LINE def calculate_perms ( num , length ) : NEW_LINE INDENT key = \" % d - % d \" % ( num , length ) NEW_LINE if key not in cached_results : NEW_LINE INDENT if length == 1 : NEW_LINE INDENT new_result = 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_result = 0 NEW_LINE min_pos = max ( 0 , 2 * length - 1 - num ) NEW_LINE max_pos = length - 1 NEW_LINE for i in range ( min_pos , max_pos ) : NEW_LINE INDENT new_result += choose ( num - length - 1 , length - i - 2 ) * calculate_perms ( length , i + 1 ) NEW_LINE DEDENT DEDENT cached_results [ key ] = new_result NEW_LINE DEDENT return cached_results [ key ] NEW_LINE DEDENT for case in range ( 1 , num_cases + 1 ) : NEW_LINE INDENT n = int ( infile . readline ( ) ) NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result += calculate_perms ( n , i ) % modulus NEW_LINE DEDENT result %= modulus NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( case , result ) ) NEW_LINE if case % 10 == 0 : NEW_LINE INDENT print ( \" Completed \u2581 case \u2581 % d \" % case ) NEW_LINE DEDENT DEDENT outfile . close ( ) NEW_LINE infile . close ( ) NEW_LINE", "functions_standalone": [["choose", "def choose ( n , r ) : NEW_LINE INDENT return factorial [ n ] / ( factorial [ r ] * factorial [ n - r ] ) NEW_LINE DEDENT"], ["calculate_perms", "def calculate_perms ( num , length ) : NEW_LINE INDENT key = \" % d - % d \" % ( num , length ) NEW_LINE if key not in cached_results : NEW_LINE INDENT if length == 1 : NEW_LINE INDENT new_result = 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_result = 0 NEW_LINE min_pos = max ( 0 , 2 * length - 1 - num ) NEW_LINE max_pos = length - 1 NEW_LINE for i in range ( min_pos , max_pos ) : NEW_LINE INDENT new_result += choose ( num - length - 1 , length - i - 2 ) * calculate_perms ( length , i + 1 ) NEW_LINE DEDENT DEDENT cached_results [ key ] = new_result NEW_LINE DEDENT return cached_results [ key ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_10_12", "java": [{"id": "18", "code": "import java . util . * ; public class Smooth { static Scanner sc = new Scanner ( System . in ) ; static int [ ] [ ] memo = new int [ 100 ] [ 257 ] ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solveCase ( ) ; } } static final int SPC = 256 ; static void solveCase ( ) { del = sc . nextInt ( ) ; ins = sc . nextInt ( ) ; maxDist = sc . nextInt ( ) ; n = sc . nextInt ( ) ; arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; for ( int [ ] arr : memo ) Arrays . fill ( arr , - 1 ) ; System . out . println ( solve ( 0 , SPC ) ) ; } static int del , ins , maxDist , n ; static int [ ] arr ; static int solve ( int index , int prev ) { if ( index >= n ) return 0 ; if ( memo [ index ] [ prev ] == - 1 ) { int res = del + solve ( index + 1 , prev ) ; for ( int val = 0 ; val < SPC ; val ++ ) { res = Math . min ( res , Math . abs ( arr [ index ] - val ) + insCost ( val , prev ) + solve ( index + 1 , val ) ) ; } memo [ index ] [ prev ] = res ; } return memo [ index ] [ prev ] ; } static int insCost ( int cur , int prev ) { if ( prev == SPC || cur == prev ) return 0 ; if ( maxDist == 0 ) return 100000000 ; return ins * ( ( Math . abs ( cur - prev ) + maxDist - 1 ) / maxDist - 1 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solveCase ( ) ; } }"], ["solveCase", "static void solveCase ( ) { del = sc . nextInt ( ) ; ins = sc . nextInt ( ) ; maxDist = sc . nextInt ( ) ; n = sc . nextInt ( ) ; arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; for ( int [ ] arr : memo ) Arrays . fill ( arr , - 1 ) ; System . out . println ( solve ( 0 , SPC ) ) ; }"], ["solve", "static int solve ( int index , int prev ) { if ( index >= n ) return 0 ; if ( memo [ index ] [ prev ] == - 1 ) { int res = del + solve ( index + 1 , prev ) ; for ( int val = 0 ; val < SPC ; val ++ ) { res = Math . min ( res , Math . abs ( arr [ index ] - val ) + insCost ( val , prev ) + solve ( index + 1 , val ) ) ; } memo [ index ] [ prev ] = res ; } return memo [ index ] [ prev ] ; }"], ["insCost", "static int insCost ( int cur , int prev ) { if ( prev == SPC || cur == prev ) return 0 ; if ( maxDist == 0 ) return 100000000 ; return ins * ( ( Math . abs ( cur - prev ) + maxDist - 1 ) / maxDist - 1 ) ; }"]], "functions_class": []}, {"id": "13", "code": "import java . util . * ; import static java . lang . Math . * ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int D = sc . nextInt ( ) ; int I = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = sc . nextInt ( ) ; int [ ] DP = new int [ 256 ] ; Arrays . fill ( DP , 0 ) ; int [ ] CUR = new int [ 256 ] ; for ( int at = N - 1 ; at >= 0 ; at -- ) { for ( int i = 0 ; i < 1000 ; i ++ ) { int prev ; if ( i % 2 == 0 ) prev = A [ at ] + i / 2 ; else prev = A [ at ] - ( i + 1 ) / 2 ; if ( prev < 0 || prev >= 256 ) continue ; int cost = DP [ prev ] + D ; for ( int j = 0 ; j < 256 ; j ++ ) { if ( abs ( j - prev ) <= M || prev == - 1 ) cost = min ( cost , DP [ j ] + abs ( j - A [ at ] ) ) ; if ( abs ( j - A [ at ] ) < abs ( A [ at ] - prev ) && ( prev == - 1 || abs ( j - prev ) <= M ) ) cost = min ( cost , CUR [ j ] + I ) ; } CUR [ prev ] = cost ; } for ( int j = 0 ; j < 256 ; j ++ ) DP [ j ] = CUR [ j ] ; Arrays . fill ( CUR , 0 ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < DP . length ; i ++ ) ans = min ( ans , DP [ i ] ) ; System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , t , ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int D = sc . nextInt ( ) ; int I = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = sc . nextInt ( ) ; int [ ] DP = new int [ 256 ] ; Arrays . fill ( DP , 0 ) ; int [ ] CUR = new int [ 256 ] ; for ( int at = N - 1 ; at >= 0 ; at -- ) { for ( int i = 0 ; i < 1000 ; i ++ ) { int prev ; if ( i % 2 == 0 ) prev = A [ at ] + i / 2 ; else prev = A [ at ] - ( i + 1 ) / 2 ; if ( prev < 0 || prev >= 256 ) continue ; int cost = DP [ prev ] + D ; for ( int j = 0 ; j < 256 ; j ++ ) { if ( abs ( j - prev ) <= M || prev == - 1 ) cost = min ( cost , DP [ j ] + abs ( j - A [ at ] ) ) ; if ( abs ( j - A [ at ] ) < abs ( A [ at ] - prev ) && ( prev == - 1 || abs ( j - prev ) <= M ) ) cost = min ( cost , CUR [ j ] + I ) ; } CUR [ prev ] = cost ; } for ( int j = 0 ; j < 256 ; j ++ ) DP [ j ] = CUR [ j ] ; Arrays . fill ( CUR , 0 ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < DP . length ; i ++ ) ans = min ( ans , DP [ i ] ) ; System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , t , ans ) ; } }"]], "functions_class": []}], "python": [{"id": "5", "code": "T = int ( input ( ) ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT D , I , M , N = input ( ) . split ( ' \u2581 ' ) NEW_LINE D , I , M , N = int ( D ) , int ( I ) , int ( M ) , int ( N ) NEW_LINE x = input ( ) . split ( ' \u2581 ' ) NEW_LINE r = [ 0 ] * 256 NEW_LINE for q in x : NEW_LINE INDENT nr = list ( map ( lambda i : i + D , r ) ) NEW_LINE q = int ( q ) NEW_LINE if M == 0 : NEW_LINE INDENT for i in range ( 256 ) : NEW_LINE INDENT nr [ i ] = min ( nr [ i ] , r [ i ] + abs ( q - i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 256 ) : NEW_LINE INDENT for j in range ( 256 ) : NEW_LINE INDENT nr [ j ] = min ( nr [ j ] , r [ i ] + abs ( q - j ) + ( max ( 0 , abs ( i - j ) - 1 ) // M ) * I ) NEW_LINE DEDENT DEDENT DEDENT r = nr NEW_LINE DEDENT print ( ' Case \u2581 # % d : \u2581 % s ' % ( C , min ( r ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_10_13", "java": [{"id": "19", "code": "import java . io . * ; import java . util . * ; import java . text . * ; public class CS { public PrintStream out = System . out ; public PrintStream err = System . err ; public Scanner in = new Scanner ( System . in ) ; public DecimalFormat fmt = new DecimalFormat ( \"0.000000000\" ) ; public int Amin , Amax , Bmin , Bmax ; public void main ( ) { try { int TCase , cc ; int i , j , k ; int A , B ; TCase = in . nextInt ( ) ; for ( cc = 1 ; cc <= TCase ; ++ cc ) { Amin = in . nextInt ( ) ; Amax = in . nextInt ( ) ; Bmin = in . nextInt ( ) ; Bmax = in . nextInt ( ) ; int res = 0 ; for ( A = Amin ; A <= Amax ; ++ A ) for ( B = Bmin ; B <= Bmax ; ++ B ) { res += sim ( A , B ) ; } out . println ( \" Case \u2581 # \" + cc + \" : \u2581 \" + res ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } public int sim ( int A , int B ) { if ( A == B ) return 0 ; if ( A < B ) return sim ( B , A ) ; if ( A >= 2 * B ) return 1 ; return 1 - sim ( B , A - B ) ; } public static void main ( String [ ] args ) { long startTime = System . currentTimeMillis ( ) ; ( new CS ( ) ) . main ( ) ; long endTime = System . currentTimeMillis ( ) ; long ms = endTime - startTime ; long sec = ms / 1000 ; ms = ms % 1000 ; long min = sec / 60 ; sec = sec % 60 ; System . err . println ( \" Time \u2581 Spent : \u2581 \" + min + \" \u2581 minute ( s ) \u2581 \" + sec + \" \u2581 second ( s ) \u2581 \" + ms + \" \u2581 ( ms ) \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { long startTime = System . currentTimeMillis ( ) ; ( new CS ( ) ) . main ( ) ; long endTime = System . currentTimeMillis ( ) ; long ms = endTime - startTime ; long sec = ms / 1000 ; ms = ms % 1000 ; long min = sec / 60 ; sec = sec % 60 ; System . err . println ( \" Time \u2581 Spent : \u2581 \" + min + \" \u2581 minute ( s ) \u2581 \" + sec + \" \u2581 second ( s ) \u2581 \" + ms + \" \u2581 ( ms ) \" ) ; }"]], "functions_class": [["main", "public void main ( ) { try { int TCase , cc ; int i , j , k ; int A , B ; TCase = in . nextInt ( ) ; for ( cc = 1 ; cc <= TCase ; ++ cc ) { Amin = in . nextInt ( ) ; Amax = in . nextInt ( ) ; Bmin = in . nextInt ( ) ; Bmax = in . nextInt ( ) ; int res = 0 ; for ( A = Amin ; A <= Amax ; ++ A ) for ( B = Bmin ; B <= Bmax ; ++ B ) { res += sim ( A , B ) ; } out . println ( \" Case \u2581 # \" + cc + \" : \u2581 \" + res ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }"], ["sim", "public int sim ( int A , int B ) { if ( A == B ) return 0 ; if ( A < B ) return sim ( B , A ) ; if ( A >= 2 * B ) return 1 ; return 1 - sim ( B , A - B ) ; }"]]}, {"id": "7", "code": "import java . math . * ; import java . util . * ; public class C { public static int [ ] a ; public static int find ( int k , int x ) { int low = 1 ; int up = k ; while ( low < up ) { int mid = ( low + up ) / 2 ; if ( a [ mid ] <= x ) low = mid + 1 ; else up = mid ; } return low ; } public static void main ( String args [ ] ) { a = new int [ 1000001 ] ; a [ 1 ] = 2 ; a [ 2 ] = 4 ; for ( int i = 3 ; i <= 1000000 ; ++ i ) a [ i ] = find ( i - 1 , i ) + i ; Scanner scanner = new Scanner ( System . in ) ; int caseNumber = scanner . nextInt ( ) ; for ( int cases = 0 ; cases < caseNumber ; ++ cases ) { int a1 = scanner . nextInt ( ) ; int a2 = scanner . nextInt ( ) ; int b1 = scanner . nextInt ( ) ; int b2 = scanner . nextInt ( ) ; BigInteger ans = new BigInteger ( \"0\" ) ; for ( int i = a1 ; i <= a2 ; ++ i ) { int up = b2 ; int low = a [ i ] ; if ( b1 > low ) low = b1 ; if ( low > up ) continue ; ans = ans . add ( new BigInteger ( Integer . toString ( up - low + 1 ) ) ) ; } for ( int i = b1 ; i <= b2 ; ++ i ) { int up = a2 ; int low = a [ i ] ; if ( a1 > low ) low = a1 ; if ( low > up ) continue ; ans = ans . add ( new BigInteger ( Integer . toString ( up - low + 1 ) ) ) ; } System . out . println ( \" Case \u2581 # \" + ( cases + 1 ) + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["find", "public static int find ( int k , int x ) { int low = 1 ; int up = k ; while ( low < up ) { int mid = ( low + up ) / 2 ; if ( a [ mid ] <= x ) low = mid + 1 ; else up = mid ; } return low ; }"], ["main", "public static void main ( String args [ ] ) { a = new int [ 1000001 ] ; a [ 1 ] = 2 ; a [ 2 ] = 4 ; for ( int i = 3 ; i <= 1000000 ; ++ i ) a [ i ] = find ( i - 1 , i ) + i ; Scanner scanner = new Scanner ( System . in ) ; int caseNumber = scanner . nextInt ( ) ; for ( int cases = 0 ; cases < caseNumber ; ++ cases ) { int a1 = scanner . nextInt ( ) ; int a2 = scanner . nextInt ( ) ; int b1 = scanner . nextInt ( ) ; int b2 = scanner . nextInt ( ) ; BigInteger ans = new BigInteger ( \"0\" ) ; for ( int i = a1 ; i <= a2 ; ++ i ) { int up = b2 ; int low = a [ i ] ; if ( b1 > low ) low = b1 ; if ( low > up ) continue ; ans = ans . add ( new BigInteger ( Integer . toString ( up - low + 1 ) ) ) ; } for ( int i = b1 ; i <= b2 ; ++ i ) { int up = a2 ; int low = a [ i ] ; if ( a1 > low ) low = a1 ; if ( low > up ) continue ; ans = ans . add ( new BigInteger ( Integer . toString ( up - low + 1 ) ) ) ; } System . out . println ( \" Case \u2581 # \" + ( cases + 1 ) + \" : \u2581 \" + ans ) ; } }"]], "functions_class": []}, {"id": "17", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class NumberGame { public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" C . out \" ) ) ) ; long alow , ahigh , blow , bhigh , cases ; cases = Integer . parseInt ( in . readLine ( ) ) ; double gold = ( 1 + Math . sqrt ( 5 ) ) / 2 ; for ( int i = 1 ; i <= cases ; i ++ ) { StringTokenizer st = new StringTokenizer ( in . readLine ( ) ) ; alow = Integer . parseInt ( st . nextToken ( ) ) ; ahigh = Integer . parseInt ( st . nextToken ( ) ) ; blow = Integer . parseInt ( st . nextToken ( ) ) ; bhigh = Integer . parseInt ( st . nextToken ( ) ) ; long count = ( ahigh - alow + 1 ) * ( bhigh - blow + 1 ) ; for ( long a = alow ; a <= ahigh ; a ++ ) { long low = Math . max ( ( long ) ( a / gold + 1 ) , blow ) ; long high = Math . min ( bhigh , ( long ) ( a * gold ) ) ; if ( low <= bhigh && high >= blow ) count -= high - low + 1 ; } out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + count ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" C . out \" ) ) ) ; long alow , ahigh , blow , bhigh , cases ; cases = Integer . parseInt ( in . readLine ( ) ) ; double gold = ( 1 + Math . sqrt ( 5 ) ) / 2 ; for ( int i = 1 ; i <= cases ; i ++ ) { StringTokenizer st = new StringTokenizer ( in . readLine ( ) ) ; alow = Integer . parseInt ( st . nextToken ( ) ) ; ahigh = Integer . parseInt ( st . nextToken ( ) ) ; blow = Integer . parseInt ( st . nextToken ( ) ) ; bhigh = Integer . parseInt ( st . nextToken ( ) ) ; long count = ( ahigh - alow + 1 ) * ( bhigh - blow + 1 ) ; for ( long a = alow ; a <= ahigh ; a ++ ) { long low = Math . max ( ( long ) ( a / gold + 1 ) , blow ) ; long high = Math . min ( bhigh , ( long ) ( a * gold ) ) ; if ( low <= bhigh && high >= blow ) count -= high - low + 1 ; } out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + count ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "0", "code": "import static java . lang . Math . * ; import static java . util . Arrays . * ; import java . util . * ; public class C { boolean TIME = false ; Scanner sc ; void solve ( ) { int A1 = sc . nextInt ( ) , A2 = sc . nextInt ( ) ; int B1 = sc . nextInt ( ) , B2 = sc . nextInt ( ) ; long res = 0 ; for ( int b = B1 ; b <= B2 ; b ++ ) { int min = ( int ) ( ceil ( 1.0 / R * b ) ) ; int max = ( int ) ( floor ( R * b ) ) ; min = max ( min , A1 ) ; max = min ( max , A2 ) ; res += A2 - A1 + 1 ; if ( min <= max ) { res -= max - min + 1 ; } } System . out . println ( res ) ; } double R = ( sqrt ( 5 ) + 1 ) / 2 ; void run ( ) { long time = System . currentTimeMillis ( ) ; sc = new Scanner ( System . in ) ; int on = sc . nextInt ( ) ; for ( int o = 1 ; o <= on ; o ++ ) { double t = ( System . currentTimeMillis ( ) - time ) * 1e-3 ; if ( TIME ) System . err . printf ( \" % 03d / %03d \u2581 % .3f / % . 3f % n \" , o , on , t , t / ( o - 1 ) * on ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , o ) ; solve ( ) ; System . out . flush ( ) ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new C ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new C ( ) . run ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { int A1 = sc . nextInt ( ) , A2 = sc . nextInt ( ) ; int B1 = sc . nextInt ( ) , B2 = sc . nextInt ( ) ; long res = 0 ; for ( int b = B1 ; b <= B2 ; b ++ ) { int min = ( int ) ( ceil ( 1.0 / R * b ) ) ; int max = ( int ) ( floor ( R * b ) ) ; min = max ( min , A1 ) ; max = min ( max , A2 ) ; res += A2 - A1 + 1 ; if ( min <= max ) { res -= max - min + 1 ; } } System . out . println ( res ) ; }"], ["run", "void run ( ) { long time = System . currentTimeMillis ( ) ; sc = new Scanner ( System . in ) ; int on = sc . nextInt ( ) ; for ( int o = 1 ; o <= on ; o ++ ) { double t = ( System . currentTimeMillis ( ) - time ) * 1e-3 ; if ( TIME ) System . err . printf ( \" % 03d / %03d \u2581 % .3f / % . 3f % n \" , o , on , t , t / ( o - 1 ) * on ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , o ) ; solve ( ) ; System . out . flush ( ) ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "14", "code": "import java . io . FileInputStream ; import java . io . PrintStream ; import java . util . Scanner ; public class Number { private Scanner fin ; private PrintStream fout ; public Number ( String in , String out ) { try { fin = new Scanner ( new FileInputStream ( in ) ) ; fout = new PrintStream ( out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void run ( ) { int cas = fin . nextInt ( ) ; for ( int t = 1 ; t <= cas ; ++ t ) { fout . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + process ( ) ) ; } } private int startpos [ ] ; private long process ( ) { int a1 , a2 , b1 , b2 ; a1 = fin . nextInt ( ) ; a2 = fin . nextInt ( ) ; b1 = fin . nextInt ( ) ; b2 = fin . nextInt ( ) ; startpos = new int [ a2 + 1 ] ; if ( a2 >= 1 ) startpos [ 1 ] = 1 ; if ( a2 >= 2 ) startpos [ 2 ] = 2 ; int k = 1 ; for ( int i = 3 ; i <= a2 ; ++ i ) { while ( i >= startpos [ k ] + k ) k ++ ; startpos [ i ] = k ; } long res = 0 ; for ( int i = a1 ; i <= a2 ; ++ i ) { res += count ( i , b1 , b2 ) ; } return res ; } private long count ( int id , int b1 , int b2 ) { long res = b2 - b1 + 1 ; if ( b1 < startpos [ id ] ) { if ( b2 < startpos [ id ] ) return res ; else if ( b2 < startpos [ id ] + id ) { return res - ( b2 - startpos [ id ] + 1 ) ; } else { return res - id ; } } else if ( b1 < startpos [ id ] + id ) { if ( b2 < startpos [ id ] + id ) { return 0 ; } else { return b2 - ( startpos [ id ] + id ) + 1 ; } } else { return res ; } } public static void main ( String [ ] args ) { new Number ( \" c . in \" , \" c . out \" ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Number ( \" c . in \" , \" c . out \" ) . run ( ) ; }"]], "functions_class": [["Number", "public Number ( String in , String out ) { try { fin = new Scanner ( new FileInputStream ( in ) ) ; fout = new PrintStream ( out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"], ["run", "private void run ( ) { int cas = fin . nextInt ( ) ; for ( int t = 1 ; t <= cas ; ++ t ) { fout . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + process ( ) ) ; } }"], ["process", "private long process ( ) { int a1 , a2 , b1 , b2 ; a1 = fin . nextInt ( ) ; a2 = fin . nextInt ( ) ; b1 = fin . nextInt ( ) ; b2 = fin . nextInt ( ) ; startpos = new int [ a2 + 1 ] ; if ( a2 >= 1 ) startpos [ 1 ] = 1 ; if ( a2 >= 2 ) startpos [ 2 ] = 2 ; int k = 1 ; for ( int i = 3 ; i <= a2 ; ++ i ) { while ( i >= startpos [ k ] + k ) k ++ ; startpos [ i ] = k ; } long res = 0 ; for ( int i = a1 ; i <= a2 ; ++ i ) { res += count ( i , b1 , b2 ) ; } return res ; }"], ["count", "private long count ( int id , int b1 , int b2 ) { long res = b2 - b1 + 1 ; if ( b1 < startpos [ id ] ) { if ( b2 < startpos [ id ] ) return res ; else if ( b2 < startpos [ id ] + id ) { return res - ( b2 - startpos [ id ] + 1 ) ; } else { return res - id ; } } else if ( b1 < startpos [ id ] + id ) { if ( b2 < startpos [ id ] + id ) { return 0 ; } else { return b2 - ( startpos [ id ] + id ) + 1 ; } } else { return res ; } }"]]}], "python": [{"id": "7", "code": "import sys NEW_LINE import math NEW_LINE phi = 0.5 * ( 1.0 + math . sqrt ( 5.0 ) ) NEW_LINE def countWinners ( minA , maxA , minB , maxB ) : NEW_LINE INDENT result = 0 NEW_LINE numberOfBs = maxB - minB + 1 NEW_LINE for A in range ( minA , maxA + 1 ) : NEW_LINE INDENT minLosingB = math . ceil ( A / phi ) NEW_LINE maxLosingB = math . floor ( A * phi ) NEW_LINE loosers = min ( maxB , maxLosingB ) - max ( minB , minLosingB ) + 1 NEW_LINE if loosers < 0 : NEW_LINE INDENT loosers = 0 NEW_LINE DEDENT result += numberOfBs - loosers NEW_LINE DEDENT return result NEW_LINE DEDENT def invalidInput ( ) : NEW_LINE INDENT sys . exit ( ' Invalid \u2581 input ' ) NEW_LINE DEDENT firstLine = next ( sys . stdin ) NEW_LINE numbers = [ int ( s ) for s in firstLine . split ( ) ] NEW_LINE if len ( numbers ) != 1 : NEW_LINE INDENT invalidInput ( ) NEW_LINE DEDENT T = numbers [ 0 ] NEW_LINE for caseNumber in range ( 1 , T + 1 ) : NEW_LINE INDENT thisLine = next ( sys . stdin ) NEW_LINE numbers = [ int ( s ) for s in thisLine . split ( ) ] NEW_LINE if len ( numbers ) != 4 : NEW_LINE INDENT invalidInput ( ) NEW_LINE DEDENT ( minA , maxA , minB , maxB ) = tuple ( numbers ) NEW_LINE assert ( 1 <= minA <= maxA <= 10 ** 6 ) NEW_LINE assert ( 1 <= minB <= maxB <= 10 ** 6 ) NEW_LINE result = countWinners ( minA , maxA , minB , maxB ) NEW_LINE print ( ' Case \u2581 # { 0 } : \u2581 { 1 } ' . format ( caseNumber , result ) ) NEW_LINE DEDENT", "functions_standalone": [["countWinners", "def countWinners ( minA , maxA , minB , maxB ) : NEW_LINE INDENT result = 0 NEW_LINE numberOfBs = maxB - minB + 1 NEW_LINE for A in range ( minA , maxA + 1 ) : NEW_LINE INDENT minLosingB = math . ceil ( A / phi ) NEW_LINE maxLosingB = math . floor ( A * phi ) NEW_LINE loosers = min ( maxB , maxLosingB ) - max ( minB , minLosingB ) + 1 NEW_LINE if loosers < 0 : NEW_LINE INDENT loosers = 0 NEW_LINE DEDENT result += numberOfBs - loosers NEW_LINE DEDENT return result NEW_LINE DEDENT"], ["invalidInput", "def invalidInput ( ) : NEW_LINE INDENT sys . exit ( ' Invalid \u2581 input ' ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "4", "code": "T = int ( input ( ) ) NEW_LINE def win ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT if x == y : NEW_LINE INDENT return False NEW_LINE DEDENT if x >= 2 * y : NEW_LINE INDENT return True NEW_LINE DEDENT return not win ( y , x - y ) NEW_LINE DEDENT for C in range ( 1 , T + 1 ) : NEW_LINE INDENT A1 , A2 , B1 , B2 = input ( ) . split ( ' \u2581 ' ) NEW_LINE A1 , A2 , B1 , B2 = int ( A1 ) , int ( A2 ) , int ( B1 ) , int ( B2 ) NEW_LINE cnt = 0 NEW_LINE for A in range ( A1 , A2 + 1 ) : NEW_LINE INDENT for B in range ( B1 , B2 + 1 ) : NEW_LINE INDENT if win ( A , B ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' Case \u2581 # % d : \u2581 % s ' % ( C , cnt ) ) NEW_LINE DEDENT", "functions_standalone": [["win", "def win ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT if x == y : NEW_LINE INDENT return False NEW_LINE DEDENT if x >= 2 * y : NEW_LINE INDENT return True NEW_LINE DEDENT return not win ( y , x - y ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "import sys NEW_LINE def readline ( ) : NEW_LINE INDENT return next ( sys . stdin ) . strip ( ) NEW_LINE DEDENT def readvals ( t ) : NEW_LINE INDENT return map ( t , readline ( ) . split ( ) ) NEW_LINE DEDENT wcache = { } NEW_LINE def winning ( a , b ) : NEW_LINE INDENT global wcache NEW_LINE if a == b : NEW_LINE INDENT return False NEW_LINE DEDENT a , b = sorted ( ( a , b ) ) NEW_LINE if b % a == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if ( a , b ) in wcache : NEW_LINE INDENT return wcache [ a , b ] NEW_LINE DEDENT res = any ( not winning ( a , b - i * a ) for i in reversed ( range ( 1 , b // a + 1 ) ) ) NEW_LINE if len ( wcache ) > 10000000 : NEW_LINE INDENT wcache = { } NEW_LINE DEDENT wcache [ a , b ] = res NEW_LINE return res NEW_LINE DEDENT ncases = int ( readline ( ) ) NEW_LINE for caseno in range ( ncases ) : NEW_LINE INDENT a1 , a2 , b1 , b2 = readvals ( int ) NEW_LINE res = sum ( winning ( i , j ) for i in range ( a1 , a2 + 1 ) for j in range ( b1 , b2 + 1 ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( caseno + 1 , res ) ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT", "functions_standalone": [["readline", "def readline ( ) : NEW_LINE INDENT return next ( sys . stdin ) . strip ( ) NEW_LINE DEDENT"], ["readvals", "def readvals ( t ) : NEW_LINE INDENT return map ( t , readline ( ) . split ( ) ) NEW_LINE DEDENT"], ["winning", "def winning ( a , b ) : NEW_LINE INDENT global wcache NEW_LINE if a == b : NEW_LINE INDENT return False NEW_LINE DEDENT a , b = sorted ( ( a , b ) ) NEW_LINE if b % a == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if ( a , b ) in wcache : NEW_LINE INDENT return wcache [ a , b ] NEW_LINE DEDENT res = any ( not winning ( a , b - i * a ) for i in reversed ( range ( 1 , b // a + 1 ) ) ) NEW_LINE if len ( wcache ) > 10000000 : NEW_LINE INDENT wcache = { } NEW_LINE DEDENT wcache [ a , b ] = res NEW_LINE return res NEW_LINE DEDENT"]], "functions_class": []}, {"id": "13", "code": "TASK = \" C \" NEW_LINE print ( \" Precalculation . . . \" ) NEW_LINE NUM = 1000001 NEW_LINE top = [ 0 ] * NUM NEW_LINE btm = [ 0 ] * NUM NEW_LINE cbtm = 0 NEW_LINE for i in range ( 1 , NUM ) : NEW_LINE INDENT if top [ cbtm ] < i : NEW_LINE INDENT cbtm += 1 NEW_LINE DEDENT btm [ i ] = cbtm NEW_LINE top [ i ] = cbtm + i NEW_LINE DEDENT print ( \" Precalculation \u2581 done . \" ) NEW_LINE with open ( TASK + \" . in \" ) as infile : NEW_LINE INDENT with open ( TASK + \" . out \" , mode = \" wt \" ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for ncase in range ( cases ) : NEW_LINE INDENT A1 , A2 , B1 , B2 = ( int ( s ) for s in infile . readline ( ) . split ( ) ) NEW_LINE lost = 0 NEW_LINE print ( \" Now : \" , ncase + 1 ) NEW_LINE for i in range ( A1 , A2 + 1 ) : NEW_LINE INDENT b = max ( B1 , btm [ i - 1 ] + 1 ) NEW_LINE t = min ( B2 , top [ i - 1 ] + 1 ) NEW_LINE lost += max ( 0 , t - b + 1 ) NEW_LINE DEDENT outfile . write ( \" Case \u2581 # { nc } : \u2581 { data } \\n \" . format ( nc = ncase + 1 , data = ( A2 - A1 + 1 ) * ( B2 - B1 + 1 ) - lost ) ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Ready \" ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_10_22", "java": [{"id": "5", "code": "import java . io . * ; import java . math . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" Main . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" Main . out \" ) ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; int B = in . nextInt ( ) ; int T = in . nextInt ( ) ; int [ ] x = new int [ n ] ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = in . nextInt ( ) ; boolean [ ] can = new boolean [ n ] ; int z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { can [ i ] = x [ i ] + v [ i ] * T >= B ; if ( can [ i ] ) z ++ ; } if ( z < k ) { out . println ( \" IMPOSSIBLE \" ) ; continue ; } int ans = 0 ; z = 0 ; for ( int i = n - 1 ; i >= 0 && k > 0 ; i -- ) if ( can [ i ] ) { ans += z ; k -- ; } else z ++ ; out . println ( ans ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" Main . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" Main . out \" ) ) ; int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; int B = in . nextInt ( ) ; int T = in . nextInt ( ) ; int [ ] x = new int [ n ] ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = in . nextInt ( ) ; boolean [ ] can = new boolean [ n ] ; int z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { can [ i ] = x [ i ] + v [ i ] * T >= B ; if ( can [ i ] ) z ++ ; } if ( z < k ) { out . println ( \" IMPOSSIBLE \" ) ; continue ; } int ans = 0 ; z = 0 ; for ( int i = n - 1 ; i >= 0 && k > 0 ; i -- ) if ( can [ i ] ) { ans += z ; k -- ; } else z ++ ; out . println ( ans ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "16", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Scanner ; public class B extends AbstractCodeJamSolver { int n , k , b , t ; int [ ] x = new int [ 50 ] ; int [ ] v = new int [ 50 ] ; void input ( ) { n = in . nextInt ( ) ; k = in . nextInt ( ) ; b = in . nextInt ( ) ; t = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = in . nextInt ( ) ; } public void solve ( ) { int casen = in . nextInt ( ) ; for ( int casei = 1 ; casei <= casen ; casei ++ ) { input ( ) ; int pass = 0 ; int nopass = 0 ; int swap = 0 ; for ( int i = n - 1 ; i >= 0 && pass < k ; i -- ) { if ( v [ i ] * t >= b - x [ i ] ) { pass ++ ; swap += nopass ; } else { nopass ++ ; } } out . print ( \" Case \u2581 # \" + casei + \" : \u2581 \" ) ; if ( pass >= k ) { out . println ( swap ) ; } else { out . println ( \" IMPOSSIBLE \" ) ; } } } static public void main ( String [ ] args ) throws IOException { new B ( ) . launch ( \" B . txt \" ) ; } } abstract class AbstractCodeJamSolver { protected Scanner in ; protected PrintStream out = System . out ; abstract public void solve ( ) ; protected void print ( Object o ) { out . print ( o ) ; } protected void println ( ) { out . println ( ) ; } protected void println ( Object o ) { out . println ( o ) ; } protected void printf ( String f , Object ... o ) { out . format ( f , o ) ; } final public void launch ( String inputFileName ) throws FileNotFoundException { in = new Scanner ( new File ( inputFileName ) ) ; solve ( ) ; } }", "functions_standalone": [["main", "static public void main ( String [ ] args ) throws IOException { new B ( ) . launch ( \" B . txt \" ) ; }"]], "functions_class": [["input", "void input ( ) { n = in . nextInt ( ) ; k = in . nextInt ( ) ; b = in . nextInt ( ) ; t = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = in . nextInt ( ) ; }"], ["solve", "public void solve ( ) { int casen = in . nextInt ( ) ; for ( int casei = 1 ; casei <= casen ; casei ++ ) { input ( ) ; int pass = 0 ; int nopass = 0 ; int swap = 0 ; for ( int i = n - 1 ; i >= 0 && pass < k ; i -- ) { if ( v [ i ] * t >= b - x [ i ] ) { pass ++ ; swap += nopass ; } else { nopass ++ ; } } out . print ( \" Case \u2581 # \" + casei + \" : \u2581 \" ) ; if ( pass >= k ) { out . println ( swap ) ; } else { out . println ( \" IMPOSSIBLE \" ) ; } } }"], ["print", "protected void print ( Object o ) { out . print ( o ) ; }"], ["println", "protected void println ( ) { out . println ( ) ; }"], ["println", "protected void println ( Object o ) { out . println ( o ) ; }"], ["printf", "protected void printf ( String f , Object ... o ) { out . format ( f , o ) ; }"], ["launch", "final public void launch ( String inputFileName ) throws FileNotFoundException { in = new Scanner ( new File ( inputFileName ) ) ; solve ( ) ; }"]]}, {"id": "17", "code": "import java . util . * ; import java . io . * ; public class R1B { public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintStream out = new PrintStream ( new File ( \" B - large . out \" ) ) ; int cas = in . nextInt ( ) ; for ( int iii = 0 ; iii < cas ; iii ++ ) { int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; int B = in . nextInt ( ) ; int T = in . nextInt ( ) ; int pos [ ] = new int [ N ] ; int speed [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) pos [ i ] = B - in . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) speed [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) pos [ i ] = ( ( pos [ i ] - 1 ) / speed [ i ] ) + 1 ; int count = 0 ; int seen = 0 ; int done = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( pos [ i ] > T ) { seen ++ ; } else { count += seen ; done ++ ; if ( done == K ) break ; } } out . println ( \" Case \u2581 # \" + ( iii + 1 ) + \" : \u2581 \" + ( done >= K ? \" \" + count : \" IMPOSSIBLE \" ) ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintStream out = new PrintStream ( new File ( \" B - large . out \" ) ) ; int cas = in . nextInt ( ) ; for ( int iii = 0 ; iii < cas ; iii ++ ) { int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; int B = in . nextInt ( ) ; int T = in . nextInt ( ) ; int pos [ ] = new int [ N ] ; int speed [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) pos [ i ] = B - in . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) speed [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) pos [ i ] = ( ( pos [ i ] - 1 ) / speed [ i ] ) + 1 ; int count = 0 ; int seen = 0 ; int done = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( pos [ i ] > T ) { seen ++ ; } else { count += seen ; done ++ ; if ( done == K ) break ; } } out . println ( \" Case \u2581 # \" + ( iii + 1 ) + \" : \u2581 \" + ( done >= K ? \" \" + count : \" IMPOSSIBLE \" ) ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "1", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class Solution { public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; long time = System . currentTimeMillis ( ) ; for ( int caseNum = 1 ; caseNum <= caseCnt ; caseNum ++ ) { pw . print ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" ) ; int N = sc . nextInt ( ) , K = sc . nextInt ( ) ; long B = sc . nextLong ( ) , T = sc . nextInt ( ) ; long [ ] X = new long [ N ] ; long [ ] V = new long [ N ] ; boolean [ ] can = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) X [ i ] = sc . nextLong ( ) ; for ( int i = 0 ; i < N ; i ++ ) { V [ i ] = sc . nextLong ( ) ; can [ i ] = X [ i ] + T * V [ i ] >= B ; } int good = 0 ; int swaps = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) if ( can [ i ] && good < K ) { good ++ ; for ( int j = i + 1 ; j < N ; j ++ ) if ( ! can [ j ] ) swaps ++ ; } if ( good < K ) pw . println ( \" IMPOSSIBLE \" ) ; else pw . println ( swaps ) ; System . out . println ( \" Finished \u2581 testcase \u2581 \" + caseNum + \" , \u2581 time \u2581 = \u2581 \" + ( System . currentTimeMillis ( ) - time ) ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { ( new Solution ( ) ) . doMain ( ) ; }"]], "functions_class": [["doMain", "public void doMain ( ) throws Exception { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; long time = System . currentTimeMillis ( ) ; for ( int caseNum = 1 ; caseNum <= caseCnt ; caseNum ++ ) { pw . print ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" ) ; int N = sc . nextInt ( ) , K = sc . nextInt ( ) ; long B = sc . nextLong ( ) , T = sc . nextInt ( ) ; long [ ] X = new long [ N ] ; long [ ] V = new long [ N ] ; boolean [ ] can = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) X [ i ] = sc . nextLong ( ) ; for ( int i = 0 ; i < N ; i ++ ) { V [ i ] = sc . nextLong ( ) ; can [ i ] = X [ i ] + T * V [ i ] >= B ; } int good = 0 ; int swaps = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) if ( can [ i ] && good < K ) { good ++ ; for ( int j = i + 1 ; j < N ; j ++ ) if ( ! can [ j ] ) swaps ++ ; } if ( good < K ) pw . println ( \" IMPOSSIBLE \" ) ; else pw . println ( swaps ) ; System . out . println ( \" Finished \u2581 testcase \u2581 \" + caseNum + \" , \u2581 time \u2581 = \u2581 \" + ( System . currentTimeMillis ( ) - time ) ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]]}, {"id": "2", "code": "package round1 ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( B . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( B . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( in ) ) ; } out . close ( ) ; } private String solve ( Scanner in ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; int b = in . nextInt ( ) ; int t = in . nextInt ( ) ; int [ ] x = new int [ n ] ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = in . nextInt ( ) ; } boolean [ ] z = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { z [ i ] = x [ i ] + v [ i ] * t >= b ; } int [ ] q = new int [ n ] ; int m = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( z [ i ] ) { q [ m ++ ] = i ; } } if ( m < k ) return \" IMPOSSIBLE \" ; int s = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j = n - i - 1 ; s += ( j - q [ i ] ) ; } return \" \" + s ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( B . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( B . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( in ) ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private String solve ( Scanner in ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; int b = in . nextInt ( ) ; int t = in . nextInt ( ) ; int [ ] x = new int [ n ] ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = in . nextInt ( ) ; } boolean [ ] z = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { z [ i ] = x [ i ] + v [ i ] * t >= b ; } int [ ] q = new int [ n ] ; int m = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( z [ i ] ) { q [ m ++ ] = i ; } } if ( m < k ) return \" IMPOSSIBLE \" ; int s = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j = n - i - 1 ; s += ( j - q [ i ] ) ; } return \" \" + s ; }"]]}], "python": [{"id": "8", "code": "import sys NEW_LINE if ( len ( sys . argv ) < 2 ) : NEW_LINE INDENT print ( \" No \u2581 file \u2581 specified \" ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT infile = open ( sys . argv [ 1 ] ) NEW_LINE outfile = open ( sys . argv [ 1 ] + \" . out \" , \" w \" ) NEW_LINE num_cases = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , num_cases + 1 ) : NEW_LINE INDENT n , k , b , t = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE positions = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE speeds = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE positions . reverse ( ) NEW_LINE speeds . reverse ( ) NEW_LINE swaps = 0 NEW_LINE chick_idx = 0 NEW_LINE found_completers = 0 NEW_LINE while chick_idx < n and found_completers < k : NEW_LINE INDENT if speeds [ chick_idx ] * t >= ( b - positions [ chick_idx ] ) : NEW_LINE INDENT swaps += chick_idx - found_completers NEW_LINE found_completers += 1 NEW_LINE DEDENT chick_idx += 1 NEW_LINE DEDENT if found_completers < k : NEW_LINE INDENT result = \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT result = \" % d \" % swaps NEW_LINE DEDENT outfile . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( case , result ) ) NEW_LINE if case % 100 == 0 : NEW_LINE INDENT print ( \" Completed \u2581 case \u2581 % d \" % case ) NEW_LINE DEDENT DEDENT outfile . close ( ) NEW_LINE infile . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inFile = open ( \" B - large . in \" , \" r \" ) NEW_LINE outFile = open ( \" practice . out \" , \" w \" ) NEW_LINE caseNum = int ( inFile . readline ( ) ) NEW_LINE for i in xrange ( 1 , caseNum + 1 ) : NEW_LINE INDENT rtv = 0 NEW_LINE N , K , B , T = tuple ( map ( int , inFile . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE X = map ( int , inFile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE V = map ( int , inFile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE tc = [ ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT tmp_t = ( B - X [ j ] ) / float ( V [ j ] ) NEW_LINE tc . append ( ( B - X [ j ] ) / float ( V [ j ] ) ) NEW_LINE DEDENT rtv = 0 NEW_LINE fg = 0 NEW_LINE lg = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT h = N - j - 1 NEW_LINE if tc [ h ] > T : NEW_LINE INDENT lg += 1 NEW_LINE DEDENT else : NEW_LINE INDENT fg += 1 NEW_LINE rtv += lg NEW_LINE if fg >= K : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if fg < K : NEW_LINE INDENT outFile . write ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE \\n \" % ( i , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT outFile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i , rtv ) ) NEW_LINE DEDENT DEDENT outFile . close ( ) NEW_LINE inFile . close ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "from sys import stdin , stdout NEW_LINE C = int ( stdin . readline ( ) ) NEW_LINE for x in range ( 1 , C + 1 ) : NEW_LINE INDENT ( N , K , B , T ) = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE Xi = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE Vi = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE assert ( len ( Xi ) == len ( Vi ) == N ) NEW_LINE i = 0 NEW_LINE S = 0 NEW_LINE while i < K : NEW_LINE INDENT k = N - i - 1 NEW_LINE for j in range ( k , - 1 , - 1 ) : NEW_LINE INDENT if Xi [ j ] + Vi [ j ] * T >= B : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if Xi [ j ] + Vi [ j ] * T < B : NEW_LINE INDENT break NEW_LINE DEDENT ( Xi [ k ] , Xi [ j ] , Vi [ k ] , Vi [ j ] ) = ( Xi [ j ] , Xi [ k ] , Vi [ j ] , Vi [ k ] ) NEW_LINE S += ( k - j ) NEW_LINE i += 1 NEW_LINE DEDENT if i < K : NEW_LINE INDENT stdout . write ( ' Case \u2581 # % i : \u2581 IMPOSSIBLE \\n ' % x ) NEW_LINE DEDENT else : NEW_LINE INDENT stdout . write ( ' Case \u2581 # % i : \u2581 % i \\n ' % ( x , S ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_09_03", "java": [{"id": "9", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Welcome { public static void main ( String [ ] args ) throws Exception { int i , j , k , p ; char c ; int res ; String score ; String line ; String sentence ; String original = \" welcome \u2581 to \u2581 code \u2581 jam \" ; int N , M ; BufferedReader br = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" C - large . out \" ) ) ) ; StringTokenizer st ; line = br . readLine ( ) ; N = Integer . parseInt ( line ) ; for ( k = 1 ; k <= N ; k ++ ) { sentence = br . readLine ( ) ; M = sentence . length ( ) ; int opt [ ] [ ] = new int [ M ] [ 19 ] ; for ( i = 0 ; i < M ; i ++ ) { c = sentence . charAt ( i ) ; if ( c == ' w ' ) { opt [ i ] [ 0 ] = 1 ; } for ( j = 1 ; j < 19 ; j ++ ) { if ( c == original . charAt ( j ) ) { for ( p = 0 ; p < i ; p ++ ) { opt [ i ] [ j ] = ( opt [ i ] [ j ] + opt [ p ] [ j - 1 ] ) % 10000 ; } } } } res = 0 ; for ( i = 0 ; i < M ; i ++ ) { res = ( res + opt [ i ] [ 18 ] ) % 10000 ; } score = Integer . toString ( res ) ; while ( score . length ( ) < 4 ) { score = '0' + score ; } out . println ( \" Case \u2581 # \" + k + \" : \u2581 \" + score ) ; } out . close ( ) ; System . exit ( 0 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { int i , j , k , p ; char c ; int res ; String score ; String line ; String sentence ; String original = \" welcome \u2581 to \u2581 code \u2581 jam \" ; int N , M ; BufferedReader br = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" C - large . out \" ) ) ) ; StringTokenizer st ; line = br . readLine ( ) ; N = Integer . parseInt ( line ) ; for ( k = 1 ; k <= N ; k ++ ) { sentence = br . readLine ( ) ; M = sentence . length ( ) ; int opt [ ] [ ] = new int [ M ] [ 19 ] ; for ( i = 0 ; i < M ; i ++ ) { c = sentence . charAt ( i ) ; if ( c == ' w ' ) { opt [ i ] [ 0 ] = 1 ; } for ( j = 1 ; j < 19 ; j ++ ) { if ( c == original . charAt ( j ) ) { for ( p = 0 ; p < i ; p ++ ) { opt [ i ] [ j ] = ( opt [ i ] [ j ] + opt [ p ] [ j - 1 ] ) % 10000 ; } } } } res = 0 ; for ( i = 0 ; i < M ; i ++ ) { res = ( res + opt [ i ] [ 18 ] ) % 10000 ; } score = Integer . toString ( res ) ; while ( score . length ( ) < 4 ) { score = '0' + score ; } out . println ( \" Case \u2581 # \" + k + \" : \u2581 \" + score ) ; } out . close ( ) ; System . exit ( 0 ) ; }"]], "functions_class": []}, {"id": "10", "code": "package gcj2009 . qual ; import java . io . * ; import java . util . * ; import static java . lang . Math . * ; public class C { static final int INF = 1 << 20 ; static final int [ ] di = { - 1 , 0 , 0 , 1 } ; static final int [ ] dj = { 0 , - 1 , 1 , 0 } ; static final char [ ] key = \" welcome \u2581 to \u2581 code \u2581 jam \" . toCharArray ( ) ; static final int mod = 10000 ; public void run ( ) { char [ ] input = sc . nextLine ( ) . toCharArray ( ) ; int [ ] dp = new int [ key . length + 1 ] ; dp [ 0 ] = 1 ; for ( char c : input ) for ( int i = key . length - 1 ; i >= 0 ; i -- ) if ( key [ i ] == c ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i ] ) % mod ; System . out . printf ( \" % 04d % n \" , dp [ key . length ] ) ; } public static void main ( String ... args ) { try { System . setIn ( new FileInputStream ( \" C - large . in \" ) ) ; System . setOut ( new PrintStream ( \" C - large . out \" ) ) ; } catch ( Exception e ) { } sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t ) ; new C ( ) . run ( ) ; } } static Scanner sc ; }", "functions_standalone": [["main", "public static void main ( String ... args ) { try { System . setIn ( new FileInputStream ( \" C - large . in \" ) ) ; System . setOut ( new PrintStream ( \" C - large . out \" ) ) ; } catch ( Exception e ) { } sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t ) ; new C ( ) . run ( ) ; } }"]], "functions_class": [["run", "public void run ( ) { char [ ] input = sc . nextLine ( ) . toCharArray ( ) ; int [ ] dp = new int [ key . length + 1 ] ; dp [ 0 ] = 1 ; for ( char c : input ) for ( int i = key . length - 1 ; i >= 0 ; i -- ) if ( key [ i ] == c ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i ] ) % mod ; System . out . printf ( \" % 04d % n \" , dp [ key . length ] ) ; }"]]}, {"id": "19", "code": "package qualifiers ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . math . BigInteger ; public class WelcomeToCodeJam { private char [ ] input ; private char [ ] target ; private BigInteger [ ] [ ] memo ; private BigInteger solve ( int inputIdx , int targetIdx ) { if ( memo [ inputIdx ] [ targetIdx ] != null ) return memo [ inputIdx ] [ targetIdx ] ; else { BigInteger ret = BigInteger . ZERO ; if ( inputIdx >= input . length ) { if ( targetIdx >= target . length ) { ret = BigInteger . ONE ; } else ret = BigInteger . ZERO ; } else { if ( targetIdx < target . length ) { char c1 = target [ targetIdx ] ; char c2 = input [ inputIdx ] ; if ( c1 == c2 ) ret = ret . add ( solve ( inputIdx + 1 , targetIdx + 1 ) ) ; } ret = ret . add ( solve ( inputIdx + 1 , targetIdx ) ) ; } memo [ inputIdx ] [ targetIdx ] = ret ; return ret ; } } public String getWelcome ( String inp , String target ) { this . input = inp . toCharArray ( ) ; this . target = target . toCharArray ( ) ; this . memo = new BigInteger [ input . length + 1 ] [ this . target . length + 1 ] ; BigInteger val = solve ( 0 , 0 ) ; String ret = val . toString ( ) ; if ( ret . length ( ) < 4 ) { for ( int i = ret . length ( ) ; i < 4 ; ++ i ) ret = \"0\" + ret ; } else ret = ret . substring ( ret . length ( ) - 4 ) ; return ret ; } public static void main ( String [ ] args ) throws NumberFormatException , IOException { WelcomeToCodeJam obj = new WelcomeToCodeJam ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . valueOf ( br . readLine ( ) ) ; String target = \" welcome \u2581 to \u2581 code \u2581 jam \" ; for ( int i = 1 ; i <= N ; ++ i ) { String inp = br . readLine ( ) ; String ret = obj . getWelcome ( inp , target ) ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + ret ) ; } } }", "functions_standalone": [], "functions_class": [["solve", "private BigInteger solve ( int inputIdx , int targetIdx ) { if ( memo [ inputIdx ] [ targetIdx ] != null ) return memo [ inputIdx ] [ targetIdx ] ; else { BigInteger ret = BigInteger . ZERO ; if ( inputIdx >= input . length ) { if ( targetIdx >= target . length ) { ret = BigInteger . ONE ; } else ret = BigInteger . ZERO ; } else { if ( targetIdx < target . length ) { char c1 = target [ targetIdx ] ; char c2 = input [ inputIdx ] ; if ( c1 == c2 ) ret = ret . add ( solve ( inputIdx + 1 , targetIdx + 1 ) ) ; } ret = ret . add ( solve ( inputIdx + 1 , targetIdx ) ) ; } memo [ inputIdx ] [ targetIdx ] = ret ; return ret ; } }"], ["getWelcome", "public String getWelcome ( String inp , String target ) { this . input = inp . toCharArray ( ) ; this . target = target . toCharArray ( ) ; this . memo = new BigInteger [ input . length + 1 ] [ this . target . length + 1 ] ; BigInteger val = solve ( 0 , 0 ) ; String ret = val . toString ( ) ; if ( ret . length ( ) < 4 ) { for ( int i = ret . length ( ) ; i < 4 ; ++ i ) ret = \"0\" + ret ; } else ret = ret . substring ( ret . length ( ) - 4 ) ; return ret ; }"], ["readLine", "++ i ) { String inp = br . readLine ( ) ; String ret = obj . getWelcome ( inp , target ) ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + ret ) ; }"]]}, {"id": "12", "code": "import java . io . * ; public class Welcome { static int current [ ] ; static void inc ( int index ) { current [ index ] = ( current [ index ] + 1 ) % 10000 ; } static void move ( int index ) { current [ index + 1 ] = ( current [ index ] + current [ index + 1 ] ) % 10000 ; } private static int solve ( String line ) { String wel = \" welcome \u2581 to \u2581 code \u2581 jam \" ; int length = wel . length ( ) ; current = new int [ length ] ; int i , j ; for ( i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; for ( j = 0 ; j < length ; j ++ ) { if ( c == wel . charAt ( j ) ) { if ( j > 0 ) { move ( j - 1 ) ; } else { inc ( j ) ; } } } } return current [ length - 1 ] ; } public static void main ( String args [ ] ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( \" src / C - large . in \" ) ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( \" output \" ) ) ; int n = Integer . parseInt ( reader . readLine ( ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { String line = reader . readLine ( ) ; int result = solve ( line ) ; writer . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; if ( result < 1000 ) { writer . write ( \"0\" ) ; } if ( result < 100 ) { writer . write ( \"0\" ) ; } if ( result < 10 ) { writer . write ( \"0\" ) ; } writer . write ( result + \" \" ) ; writer . newLine ( ) ; } reader . close ( ) ; writer . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } }", "functions_standalone": [["inc", "static void inc ( int index ) { current [ index ] = ( current [ index ] + 1 ) % 10000 ; }"], ["move", "static void move ( int index ) { current [ index + 1 ] = ( current [ index ] + current [ index + 1 ] ) % 10000 ; }"], ["solve", "private static int solve ( String line ) { String wel = \" welcome \u2581 to \u2581 code \u2581 jam \" ; int length = wel . length ( ) ; current = new int [ length ] ; int i , j ; for ( i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; for ( j = 0 ; j < length ; j ++ ) { if ( c == wel . charAt ( j ) ) { if ( j > 0 ) { move ( j - 1 ) ; } else { inc ( j ) ; } } } } return current [ length - 1 ] ; }"], ["main", "public static void main ( String args [ ] ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( \" src / C - large . in \" ) ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( \" output \" ) ) ; int n = Integer . parseInt ( reader . readLine ( ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { String line = reader . readLine ( ) ; int result = solve ( line ) ; writer . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; if ( result < 1000 ) { writer . write ( \"0\" ) ; } if ( result < 100 ) { writer . write ( \"0\" ) ; } if ( result < 10 ) { writer . write ( \"0\" ) ; } writer . write ( result + \" \" ) ; writer . newLine ( ) ; } reader . close ( ) ; writer . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "13", "code": "package gcj ; import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . StringTokenizer ; import java . util . regex . Pattern ; public class QR_Q3 { public static void main ( String [ ] args ) throws Exception { new QR_Q3 ( ) . run ( ) ; } int N ; int [ ] map = new int [ 256 ] ; int mod = 10000 ; void run ( ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintWriter pw = new PrintWriter ( \" QR _ Q3 . out \" ) ; N = Integer . parseInt ( br . readLine ( ) ) ; String ph = \" welcome \u2581 to \u2581 code \u2581 jam \" ; int l = ph . length ( ) ; digest ( ph ) ; for ( int n_case = 1 ; n_case <= N ; n_case ++ ) { String line = br . readLine ( ) ; int [ ] result = new int [ l + 1 ] ; result [ 0 ] = 1 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; int amap = map [ c ] ; for ( int i_p = 0 ; i_p < l ; i_p ++ ) { if ( ( amap & 1 << i_p ) == 0 ) { } else { result [ i_p + 1 ] = ( result [ i_p ] + result [ i_p + 1 ] ) % mod ; } } } pw . printf ( \" Case \u2581 # % d : \u2581 % 04d \" , n_case , result [ l ] ) ; pw . println ( ) ; } pw . close ( ) ; } private void digest ( String ph ) { for ( int i = 0 ; i < ph . length ( ) ; i ++ ) { char c = ph . charAt ( i ) ; map [ c ] |= 1 << i ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new QR_Q3 ( ) . run ( ) ; }"]], "functions_class": [["run", "void run ( ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" C - large . in \" ) ) ; PrintWriter pw = new PrintWriter ( \" QR _ Q3 . out \" ) ; N = Integer . parseInt ( br . readLine ( ) ) ; String ph = \" welcome \u2581 to \u2581 code \u2581 jam \" ; int l = ph . length ( ) ; digest ( ph ) ; for ( int n_case = 1 ; n_case <= N ; n_case ++ ) { String line = br . readLine ( ) ; int [ ] result = new int [ l + 1 ] ; result [ 0 ] = 1 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; int amap = map [ c ] ; for ( int i_p = 0 ; i_p < l ; i_p ++ ) { if ( ( amap & 1 << i_p ) == 0 ) { } else { result [ i_p + 1 ] = ( result [ i_p ] + result [ i_p + 1 ] ) % mod ; } } } pw . printf ( \" Case \u2581 # % d : \u2581 % 04d \" , n_case , result [ l ] ) ; pw . println ( ) ; } pw . close ( ) ; }"], ["digest", "private void digest ( String ph ) { for ( int i = 0 ; i < ph . length ( ) ; i ++ ) { char c = ph . charAt ( i ) ; map [ c ] |= 1 << i ; } }"]]}], "python": [{"id": "15", "code": "import sys NEW_LINE S = \" welcome \u2581 to \u2581 code \u2581 jam \" NEW_LINE LS = len ( S ) NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( raw_input ( ) . strip ( ) ) NEW_LINE for I in range ( n ) : NEW_LINE INDENT L = raw_input ( ) . strip ( ) NEW_LINE LL = len ( L ) NEW_LINE t = [ [ 0 ] * ( LL + 1 ) for _ in range ( LS + 1 ) ] NEW_LINE for j in range ( LL + 1 ) : NEW_LINE INDENT t [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , LS + 1 ) : NEW_LINE INDENT for j in range ( 1 , LL + 1 ) : NEW_LINE INDENT if S [ i - 1 ] == L [ j - 1 ] : NEW_LINE INDENT t [ i ] [ j ] = t [ i ] [ j - 1 ] + t [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] [ j ] = t [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT sys . stdout . write ( \" Case \u2581 # % d : \u2581 % 04d \\n \" % ( I + 1 , t [ LS ] [ LL ] % 10000 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["main", "def main ( ) : NEW_LINE INDENT n = int ( raw_input ( ) . strip ( ) ) NEW_LINE for I in range ( n ) : NEW_LINE INDENT L = raw_input ( ) . strip ( ) NEW_LINE LL = len ( L ) NEW_LINE t = [ [ 0 ] * ( LL + 1 ) for _ in range ( LS + 1 ) ] NEW_LINE for j in range ( LL + 1 ) : NEW_LINE INDENT t [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , LS + 1 ) : NEW_LINE INDENT for j in range ( 1 , LL + 1 ) : NEW_LINE INDENT if S [ i - 1 ] == L [ j - 1 ] : NEW_LINE INDENT t [ i ] [ j ] = t [ i ] [ j - 1 ] + t [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] [ j ] = t [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT sys . stdout . write ( \" Case \u2581 # % d : \u2581 % 04d \\n \" % ( I + 1 , t [ LS ] [ LL ] % 10000 ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "18", "code": "from sys import stdin NEW_LINE from sys import stdout NEW_LINE pattern = ' welcome \u2581 to \u2581 code \u2581 jam ' NEW_LINE ip = { } NEW_LINE for i , c in enumerate ( pattern ) : NEW_LINE INDENT ip . setdefault ( c , [ ] ) . append ( i ) NEW_LINE DEDENT n = len ( pattern ) NEW_LINE N = int ( stdin . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( 1 , N + 1 ) : NEW_LINE INDENT line = stdin . readline ( ) . strip ( ) NEW_LINE ans = [ ] NEW_LINE for p , c in enumerate ( line ) : NEW_LINE INDENT val = [ 0 ] * n NEW_LINE if c in ip : NEW_LINE INDENT for j in ip [ c ] : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT val [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for k in xrange ( p ) : NEW_LINE INDENT val [ j ] += ans [ k ] [ j - 1 ] NEW_LINE DEDENT val [ j ] %= 10000 NEW_LINE DEDENT DEDENT DEDENT ans . append ( val ) NEW_LINE DEDENT total = 0 NEW_LINE for val in ans : NEW_LINE INDENT total += val [ n - 1 ] NEW_LINE DEDENT stdout . write ( ' Case \u2581 # % d : \u2581 % 04d \\n ' % ( i , total % 10000 ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "20", "code": "import sys NEW_LINE def find_subsequences ( text , pattern , modulo ) : NEW_LINE INDENT n = len ( pattern ) NEW_LINE locations = { } NEW_LINE for char in pattern : NEW_LINE INDENT locations [ char ] = [ ] NEW_LINE DEDENT for i , char in enumerate ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT locations [ char ] . append ( i ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT curr_counts = [ 1 ] * len ( locations [ pattern [ 0 ] ] ) NEW_LINE for i in range ( 1 , len ( pattern ) ) : NEW_LINE INDENT curr_char = pattern [ i ] NEW_LINE last_char = pattern [ i - 1 ] NEW_LINE last_counts = curr_counts NEW_LINE curr_counts = [ 0 ] * len ( locations [ curr_char ] ) NEW_LINE for j in range ( len ( locations [ curr_char ] ) ) : NEW_LINE INDENT for k in range ( len ( locations [ last_char ] ) ) : NEW_LINE INDENT if locations [ last_char ] [ k ] > locations [ curr_char ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT curr_counts [ j ] += last_counts [ k ] % modulo NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ( curr_counts ) % modulo NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT if len ( sys . argv ) < 2 : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE DEDENT outfile = sys . stdout NEW_LINE pattern = ' welcome \u2581 to \u2581 code \u2581 jam ' NEW_LINE modulo = 10000 NEW_LINE num_cases = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( num_cases ) : NEW_LINE INDENT text = infile . readline ( ) . strip ( ) NEW_LINE matches = find_subsequences ( text , pattern , modulo ) NEW_LINE outfile . write ( ' Case \u2581 # % d : \u2581 % 04d \\n ' % ( case + 1 , matches ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["find_subsequences", "def find_subsequences ( text , pattern , modulo ) : NEW_LINE INDENT n = len ( pattern ) NEW_LINE locations = { } NEW_LINE for char in pattern : NEW_LINE INDENT locations [ char ] = [ ] NEW_LINE DEDENT for i , char in enumerate ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT locations [ char ] . append ( i ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT curr_counts = [ 1 ] * len ( locations [ pattern [ 0 ] ] ) NEW_LINE for i in range ( 1 , len ( pattern ) ) : NEW_LINE INDENT curr_char = pattern [ i ] NEW_LINE last_char = pattern [ i - 1 ] NEW_LINE last_counts = curr_counts NEW_LINE curr_counts = [ 0 ] * len ( locations [ curr_char ] ) NEW_LINE for j in range ( len ( locations [ curr_char ] ) ) : NEW_LINE INDENT for k in range ( len ( locations [ last_char ] ) ) : NEW_LINE INDENT if locations [ last_char ] [ k ] > locations [ curr_char ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT curr_counts [ j ] += last_counts [ k ] % modulo NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ( curr_counts ) % modulo NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT if len ( sys . argv ) < 2 : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE DEDENT outfile = sys . stdout NEW_LINE pattern = ' welcome \u2581 to \u2581 code \u2581 jam ' NEW_LINE modulo = 10000 NEW_LINE num_cases = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( num_cases ) : NEW_LINE INDENT text = infile . readline ( ) . strip ( ) NEW_LINE matches = find_subsequences ( text , pattern , modulo ) NEW_LINE outfile . write ( ' Case \u2581 # % d : \u2581 % 04d \\n ' % ( case + 1 , matches ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "1", "code": "filepath = ' ' NEW_LINE fileprefix = ' C - large ' NEW_LINE filepathname = filepath + fileprefix NEW_LINE infilename = filepathname + ' . in ' NEW_LINE outfilename = filepathname + ' . out ' NEW_LINE lines = open ( infilename , ' rU ' ) . read ( ) . split ( \" \\n \" ) NEW_LINE outfile = open ( outfilename , ' w + ' ) NEW_LINE cases = int ( lines [ 0 ] ) NEW_LINE linenum = 1 NEW_LINE def solve ( sentence ) : NEW_LINE INDENT fsen = \" \" NEW_LINE search = \" welcome \u2581 to \u2581 code \u2581 jam \" NEW_LINE slen = len ( search ) NEW_LINE for c in sentence : NEW_LINE INDENT if c in \" welcome \u2581 to \u2581 code \u2581 jam \" : NEW_LINE INDENT fsen += c NEW_LINE DEDENT DEDENT last = [ 0 for i in range ( slen ) ] NEW_LINE for c in fsen : NEW_LINE INDENT next = last [ : ] NEW_LINE for i in range ( slen ) : NEW_LINE INDENT schar = search [ i ] NEW_LINE if c == schar : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT next [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += last [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT last = next NEW_LINE DEDENT return \" % 04d \" % ( last [ slen - 1 ] % 10000 ) NEW_LINE DEDENT for casenum in range ( 1 , cases + 1 ) : NEW_LINE INDENT out = solve ( lines [ casenum ] ) NEW_LINE casestr = ' Case \u2581 # ' + str ( casenum ) + ' : \u2581 ' + str ( out ) NEW_LINE print ( casestr ) NEW_LINE outfile . write ( casestr + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( sentence ) : NEW_LINE INDENT fsen = \" \" NEW_LINE search = \" welcome \u2581 to \u2581 code \u2581 jam \" NEW_LINE slen = len ( search ) NEW_LINE for c in sentence : NEW_LINE INDENT if c in \" welcome \u2581 to \u2581 code \u2581 jam \" : NEW_LINE INDENT fsen += c NEW_LINE DEDENT DEDENT last = [ 0 for i in range ( slen ) ] NEW_LINE for c in fsen : NEW_LINE INDENT next = last [ : ] NEW_LINE for i in range ( slen ) : NEW_LINE INDENT schar = search [ i ] NEW_LINE if c == schar : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT next [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += last [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT last = next NEW_LINE DEDENT return \" % 04d \" % ( last [ slen - 1 ] % 10000 ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "import sys NEW_LINE keyword = \" welcome \u2581 to \u2581 code \u2581 jam \" NEW_LINE def solve ( text ) : NEW_LINE INDENT dynamic = [ ] NEW_LINE solution = 0 NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT cur = [ ] NEW_LINE dynamic . append ( cur ) NEW_LINE if text [ i ] == keyword [ 0 ] : NEW_LINE INDENT cur . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cur . append ( 0 ) NEW_LINE DEDENT for j in range ( 1 , len ( keyword ) ) : NEW_LINE INDENT cur . append ( 0 ) NEW_LINE if text [ i ] != keyword [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( 0 , i ) : NEW_LINE INDENT if text [ k ] != keyword [ j - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT cur [ j ] = ( cur [ j ] + dynamic [ k ] [ j - 1 ] ) % 10000 NEW_LINE DEDENT DEDENT solution = ( solution + cur [ len ( keyword ) - 1 ] ) % 10000 NEW_LINE DEDENT return solution NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT infile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE outfile = open ( \" resultC . txt \" , \" w \" ) NEW_LINE N = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( N ) : NEW_LINE INDENT text = infile . readline ( ) . strip ( ) NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % 04d \\n \" % ( case + 1 , solve ( text ) ) ) NEW_LINE DEDENT infile . close ( ) NEW_LINE outfile . close ( ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( text ) : NEW_LINE INDENT dynamic = [ ] NEW_LINE solution = 0 NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT cur = [ ] NEW_LINE dynamic . append ( cur ) NEW_LINE if text [ i ] == keyword [ 0 ] : NEW_LINE INDENT cur . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cur . append ( 0 ) NEW_LINE DEDENT for j in range ( 1 , len ( keyword ) ) : NEW_LINE INDENT cur . append ( 0 ) NEW_LINE if text [ i ] != keyword [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( 0 , i ) : NEW_LINE INDENT if text [ k ] != keyword [ j - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT cur [ j ] = ( cur [ j ] + dynamic [ k ] [ j - 1 ] ) % 10000 NEW_LINE DEDENT DEDENT solution = ( solution + cur [ len ( keyword ) - 1 ] ) % 10000 NEW_LINE DEDENT return solution NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_09_32", "java": [{"id": "5", "code": "package r1c ; import java . io . FileReader ; import java . util . Scanner ; public class B { public static void answer ( Scanner in ) { double sx , sy , sz , svx , svy , svz ; sx = 0 ; sy = 0 ; sz = 0 ; svx = 0 ; svy = 0 ; svz = 0 ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sx += in . nextDouble ( ) ; sy += in . nextDouble ( ) ; sz += in . nextDouble ( ) ; svx += in . nextDouble ( ) ; svy += in . nextDouble ( ) ; svz += in . nextDouble ( ) ; } double a , b , c ; a = svx * svx + svy * svy + svz * svz ; b = 2 * ( sx * svx + sy * svy + sz * svz ) ; c = sx * sx + sy * sy + sz * sz ; double outT ; if ( a != 0 ) { outT = - b / ( 2 * a ) ; if ( outT < 0 ) { outT = 0 ; } } else { outT = 0 ; } double outD = a * outT * outT + b * outT + c ; if ( outD < 0 ) { outD = 0 ; } outD = Math . sqrt ( outD ) / n ; System . out . println ( outD + \" \u2581 \" + outT ) ; } public static void main ( String [ ] args ) { try { Scanner infile = new Scanner ( new FileReader ( args [ 0 ] ) ) ; int t = infile . nextInt ( ) ; infile . nextLine ( ) ; for ( int i = 0 ; i < t ; i ++ ) { System . out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; answer ( infile ) ; } infile . close ( ) ; } catch ( Exception e ) { System . out . println ( \" Exception \u2581 occured , \u2581 stacktrace \u2581 to \u2581 follow . \" ) ; e . printStackTrace ( ) ; } } }", "functions_standalone": [["answer", "public static void answer ( Scanner in ) { double sx , sy , sz , svx , svy , svz ; sx = 0 ; sy = 0 ; sz = 0 ; svx = 0 ; svy = 0 ; svz = 0 ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sx += in . nextDouble ( ) ; sy += in . nextDouble ( ) ; sz += in . nextDouble ( ) ; svx += in . nextDouble ( ) ; svy += in . nextDouble ( ) ; svz += in . nextDouble ( ) ; } double a , b , c ; a = svx * svx + svy * svy + svz * svz ; b = 2 * ( sx * svx + sy * svy + sz * svz ) ; c = sx * sx + sy * sy + sz * sz ; double outT ; if ( a != 0 ) { outT = - b / ( 2 * a ) ; if ( outT < 0 ) { outT = 0 ; } } else { outT = 0 ; } double outD = a * outT * outT + b * outT + c ; if ( outD < 0 ) { outD = 0 ; } outD = Math . sqrt ( outD ) / n ; System . out . println ( outD + \" \u2581 \" + outT ) ; }"], ["main", "public static void main ( String [ ] args ) { try { Scanner infile = new Scanner ( new FileReader ( args [ 0 ] ) ) ; int t = infile . nextInt ( ) ; infile . nextLine ( ) ; for ( int i = 0 ; i < t ; i ++ ) { System . out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; answer ( infile ) ; } infile . close ( ) ; } catch ( Exception e ) { System . out . println ( \" Exception \u2581 occured , \u2581 stacktrace \u2581 to \u2581 follow . \" ) ; e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "2", "code": "import java . util . * ; import java . math . * ; class Main { public static void main ( String [ ] argv ) { Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { int n = sc . nextInt ( ) ; double x = 0. , y = 0 , z = 0 , dx = 0 , dy = 0 , dz = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += sc . nextDouble ( ) ; y += sc . nextDouble ( ) ; z += sc . nextDouble ( ) ; dx += sc . nextDouble ( ) ; dy += sc . nextDouble ( ) ; dz += sc . nextDouble ( ) ; } x /= n ; y /= n ; z /= n ; dx /= n ; dy /= n ; dz /= n ; double a = dx * dx + dy * dy + dz * dz ; double b = 2 * ( dx * x + dy * y + dz * z ) ; double c = x * x + y * y + z * z ; double s ; if ( a == 0 && b == 0 ) { s = 0 ; } else if ( a == 0 && b / c > 0 ) { s = 0 ; } else if ( a == 0 ) { s = - c / b ; } else if ( b / a > 0 ) { s = 0 ; } else { s = - b / a / 2 ; } double v = a * s * s + b * s + c ; if ( v < 0 ) { v = 0 ; } v = Math . sqrt ( v ) ; System . err . println ( t ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .08f \u2581 % .08f \\n \" , t , v , s ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] argv ) { Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { int n = sc . nextInt ( ) ; double x = 0. , y = 0 , z = 0 , dx = 0 , dy = 0 , dz = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += sc . nextDouble ( ) ; y += sc . nextDouble ( ) ; z += sc . nextDouble ( ) ; dx += sc . nextDouble ( ) ; dy += sc . nextDouble ( ) ; dz += sc . nextDouble ( ) ; } x /= n ; y /= n ; z /= n ; dx /= n ; dy /= n ; dz /= n ; double a = dx * dx + dy * dy + dz * dz ; double b = 2 * ( dx * x + dy * y + dz * z ) ; double c = x * x + y * y + z * z ; double s ; if ( a == 0 && b == 0 ) { s = 0 ; } else if ( a == 0 && b / c > 0 ) { s = 0 ; } else if ( a == 0 ) { s = - c / b ; } else if ( b / a > 0 ) { s = 0 ; } else { s = - b / a / 2 ; } double v = a * s * s + b * s + c ; if ( v < 0 ) { v = 0 ; } v = Math . sqrt ( v ) ; System . err . println ( t ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .08f \u2581 % .08f \\n \" , t , v , s ) ; } }"]], "functions_class": []}, {"id": "0", "code": "import java . io . * ; import java . util . * ; public class B { PrintWriter out ; Scanner in ; String testCase = \" b2\" ; public static void main ( String [ ] args ) throws Exception { new B ( ) . solve ( ) ; } long sqr ( long a ) { return a * a ; } double sqrt ( double a ) { if ( a < 1E-8 ) { return 0 ; } else { return Math . sqrt ( a ) ; } } void solve ( ) throws Exception { Locale . setDefault ( Locale . ENGLISH ) ; out = new PrintWriter ( new FileOutputStream ( testCase + \" . out \" ) ) ; in = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( testCase + \" . in \" ) ) ) ) ; int N = in . nextInt ( ) ; for ( int t = 1 ; t <= N ; ++ t ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; long x = 0 , y = 0 , z = 0 , vx = 0 , vy = 0 , vz = 0 ; for ( int i = 0 ; i < n ; ++ i ) { x += in . nextInt ( ) ; y += in . nextInt ( ) ; z += in . nextInt ( ) ; vx += in . nextInt ( ) ; vy += in . nextInt ( ) ; vz += in . nextInt ( ) ; } long a = sqr ( vx ) + sqr ( vy ) + sqr ( vz ) ; long b = 2 * ( x * vx + y * vy + z * vz ) ; long c = sqr ( x ) + sqr ( y ) + sqr ( z ) ; double time ; if ( a != 0 ) { time = - b / ( 2.0 * a ) ; } else { time = 0 ; } if ( time < 0 ) { time = 0 ; } double d = sqrt ( ( a * time * time + b * time + c ) ) / n ; out . println ( d + \" \u2581 \" + time ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new B ( ) . solve ( ) ; }"]], "functions_class": [["sqr", "long sqr ( long a ) { return a * a ; }"], ["sqrt", "double sqrt ( double a ) { if ( a < 1E-8 ) { return 0 ; } else { return Math . sqrt ( a ) ; } }"], ["solve", "void solve ( ) throws Exception { Locale . setDefault ( Locale . ENGLISH ) ; out = new PrintWriter ( new FileOutputStream ( testCase + \" . out \" ) ) ; in = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( testCase + \" . in \" ) ) ) ) ; int N = in . nextInt ( ) ; for ( int t = 1 ; t <= N ; ++ t ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; long x = 0 , y = 0 , z = 0 , vx = 0 , vy = 0 , vz = 0 ; for ( int i = 0 ; i < n ; ++ i ) { x += in . nextInt ( ) ; y += in . nextInt ( ) ; z += in . nextInt ( ) ; vx += in . nextInt ( ) ; vy += in . nextInt ( ) ; vz += in . nextInt ( ) ; } long a = sqr ( vx ) + sqr ( vy ) + sqr ( vz ) ; long b = 2 * ( x * vx + y * vy + z * vz ) ; long c = sqr ( x ) + sqr ( y ) + sqr ( z ) ; double time ; if ( a != 0 ) { time = - b / ( 2.0 * a ) ; } else { time = 0 ; } if ( time < 0 ) { time = 0 ; } double d = sqrt ( ( a * time * time + b * time + c ) ) / n ; out . println ( d + \" \u2581 \" + time ) ; } out . close ( ) ; }"]]}, {"id": "10", "code": "import java . io . * ; import java . util . * ; public class CenterOfMass { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" B . out \" ) ) ) ; StringTokenizer st ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { int N = Integer . parseInt ( in . readLine ( ) ) ; double xPos = 0.0 ; double yPos = 0.0 ; double zPos = 0.0 ; double xVel = 0.0 ; double yVel = 0.0 ; double zVel = 0.0 ; double time ; double distance ; for ( int i = 0 ; i < N ; i ++ ) { st = new StringTokenizer ( in . readLine ( ) ) ; xPos += Double . parseDouble ( st . nextToken ( ) ) ; yPos += Double . parseDouble ( st . nextToken ( ) ) ; zPos += Double . parseDouble ( st . nextToken ( ) ) ; xVel += Double . parseDouble ( st . nextToken ( ) ) ; yVel += Double . parseDouble ( st . nextToken ( ) ) ; zVel += Double . parseDouble ( st . nextToken ( ) ) ; } xPos /= ( double ) N ; yPos /= ( double ) N ; zPos /= ( double ) N ; xVel /= ( double ) N ; yVel /= ( double ) N ; zVel /= ( double ) N ; if ( xVel == 0.0 && yVel == 0.0 && zVel == 0.0 ) { time = 0 ; distance = Math . sqrt ( xPos * xPos + yPos * yPos + zPos * zPos ) ; } else { time = - ( xPos * xVel + yPos * yVel + zPos * zVel ) / ( xVel * xVel + yVel * yVel + zVel * zVel ) ; if ( time < 0 ) time = 0 ; double xNew = xPos + time * xVel ; double yNew = yPos + time * yVel ; double zNew = zPos + time * zVel ; distance = Math . sqrt ( xNew * xNew + yNew * yNew + zNew * zNew ) ; } out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + distance + \" \u2581 \" + time ) ; } in . close ( ) ; out . close ( ) ; System . exit ( 0 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" B . out \" ) ) ) ; StringTokenizer st ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { int N = Integer . parseInt ( in . readLine ( ) ) ; double xPos = 0.0 ; double yPos = 0.0 ; double zPos = 0.0 ; double xVel = 0.0 ; double yVel = 0.0 ; double zVel = 0.0 ; double time ; double distance ; for ( int i = 0 ; i < N ; i ++ ) { st = new StringTokenizer ( in . readLine ( ) ) ; xPos += Double . parseDouble ( st . nextToken ( ) ) ; yPos += Double . parseDouble ( st . nextToken ( ) ) ; zPos += Double . parseDouble ( st . nextToken ( ) ) ; xVel += Double . parseDouble ( st . nextToken ( ) ) ; yVel += Double . parseDouble ( st . nextToken ( ) ) ; zVel += Double . parseDouble ( st . nextToken ( ) ) ; } xPos /= ( double ) N ; yPos /= ( double ) N ; zPos /= ( double ) N ; xVel /= ( double ) N ; yVel /= ( double ) N ; zVel /= ( double ) N ; if ( xVel == 0.0 && yVel == 0.0 && zVel == 0.0 ) { time = 0 ; distance = Math . sqrt ( xPos * xPos + yPos * yPos + zPos * zPos ) ; } else { time = - ( xPos * xVel + yPos * yVel + zPos * zVel ) / ( xVel * xVel + yVel * yVel + zVel * zVel ) ; if ( time < 0 ) time = 0 ; double xNew = xPos + time * xVel ; double yNew = yPos + time * yVel ; double zNew = zPos + time * zVel ; distance = Math . sqrt ( xNew * xNew + yNew * yNew + zNew * zNew ) ; } out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + distance + \" \u2581 \" + time ) ; } in . close ( ) ; out . close ( ) ; System . exit ( 0 ) ; }"]], "functions_class": []}], "python": [{"id": "14", "code": "from gcjt import * NEW_LINE from math import sqrt NEW_LINE for t in tests ( ) : NEW_LINE INDENT n = int ( t . rl ( ) ) NEW_LINE a = [ 0 ] * 6 NEW_LINE for i in range ( n ) : NEW_LINE INDENT aa = tuple ( t . ri ( ) ) NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT a [ i ] += aa [ i ] NEW_LINE DEDENT DEDENT for i in range ( 6 ) : NEW_LINE INDENT a [ i ] /= n NEW_LINE DEDENT x , y , z , vx , vy , vz = a NEW_LINE d = vx ** 2 + vy ** 2 + vz ** 2 NEW_LINE if d == 0 : NEW_LINE INDENT tt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT tt = - ( x * vx + y * vy + z * vz ) / ( vx ** 2 + vy ** 2 + vz ** 2 ) NEW_LINE if tt < 0 : tt = 0 NEW_LINE DEDENT x , y , z = x + vx * tt , y + vy * tt , z + vz * tt NEW_LINE s = sqrt ( x ** 2 + y ** 2 + z ** 2 ) NEW_LINE t . answer ( ' { 0 : . 8f } \u2581 { 1 : . 8f } ' . format ( s , tt ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "5", "code": "def sq ( p ) : NEW_LINE INDENT return sum ( [ x * x for x in p ] ) NEW_LINE DEDENT def dist ( p ) : NEW_LINE INDENT return sq ( p ) ** .5 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for X in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE t0t = [ 0 , 0 , 0 ] NEW_LINE t1t = [ 0 , 0 , 0 ] NEW_LINE for f in range ( N ) : NEW_LINE INDENT x , y , z , vx , vy , vz = [ int ( w ) for w in input ( ) . split ( ) ] NEW_LINE t0t [ 0 ] += x NEW_LINE t0t [ 1 ] += y NEW_LINE t0t [ 2 ] += z NEW_LINE t1t [ 0 ] += x + vx NEW_LINE t1t [ 1 ] += y + vy NEW_LINE t1t [ 2 ] += z + vz NEW_LINE DEDENT t0m = [ float ( x ) / float ( N ) for x in t0t ] NEW_LINE t1m = [ float ( x ) / float ( N ) for x in t1t ] NEW_LINE U = [ t1m [ i ] - t0m [ i ] for i in range ( 3 ) ] NEW_LINE tmin = 0.0 NEW_LINE denom = sq ( U ) NEW_LINE if denom > 0 : NEW_LINE INDENT num = sum ( [ - t0m [ i ] * U [ i ] for i in range ( 3 ) ] ) NEW_LINE tmin = num / denom NEW_LINE DEDENT if tmin < 0 : NEW_LINE INDENT tmin = 0.0 NEW_LINE DEDENT newp = [ t0m [ i ] + tmin * U [ i ] for i in range ( 3 ) ] NEW_LINE dmin = dist ( newp ) NEW_LINE print ( \" Case \u2581 # \" + str ( X ) + \" : \u2581 \" + str ( dmin ) + \" \u2581 \" + str ( tmin ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["sq", "def sq ( p ) : NEW_LINE INDENT return sum ( [ x * x for x in p ] ) NEW_LINE DEDENT"], ["dist", "def dist ( p ) : NEW_LINE INDENT return sq ( p ) ** .5 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "13", "code": "import sys NEW_LINE import math NEW_LINE fin = open ( ' input . txt ' , ' r ' ) NEW_LINE fout = open ( ' output . txt ' , ' w ' ) NEW_LINE l = int ( fin . readline ( ) ) NEW_LINE for case in range ( l ) : NEW_LINE INDENT N = int ( fin . readline ( ) ) NEW_LINE px , py , pz = 0.0 , 0.0 , 0.0 NEW_LINE vx , vy , vz = 0.0 , 0.0 , 0.0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ix , iy , iz , ivx , ivy , ivz = map ( float , fin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE px += ix NEW_LINE py += iy NEW_LINE pz += iz NEW_LINE vx += ivx NEW_LINE vy += ivy NEW_LINE vz += ivz NEW_LINE DEDENT px /= N NEW_LINE py /= N NEW_LINE pz /= N NEW_LINE vx /= N NEW_LINE vy /= N NEW_LINE vz /= N NEW_LINE if vx == 0 and vy == 0 and vz == 0 : NEW_LINE INDENT fout . write ( \" Case \u2581 # % d : \u2581 % .8f \u2581 0.00000000 \\n \" % ( case + 1 , math . pow ( px * px + py * py + pz * pz , 0.5 ) ) ) NEW_LINE continue NEW_LINE DEDENT t = ( - px * vx - py * vy - pz * vz ) / ( vx * vx + vy * vy + vz * vz ) NEW_LINE if t < 0 : NEW_LINE INDENT fout . write ( \" Case \u2581 # % d : \u2581 % .8f \u2581 0.00000000 \\n \" % ( case + 1 , math . pow ( px * px + py * py + pz * pz , 0.5 ) ) ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT px += vx * t NEW_LINE py += vy * t NEW_LINE pz += vz * t NEW_LINE fout . write ( \" Case \u2581 # % d : \u2581 % .8f \u2581 % .8f \\n \" % ( case + 1 , math . pow ( px * px + py * py + pz * pz , 0.5 ) , t ) ) NEW_LINE DEDENT DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_09_33", "java": [{"id": "15", "code": "package bribetheprisoners ; import java . io . IOException ; import java . util . Arrays ; public class Main extends Base { int P , Q ; int free [ ] ; int bribe [ ] [ ] ; public static void main ( String [ ] args ) throws IOException { Main m = new Main ( ) ; m . run ( \" C \" , \" large \" ) ; } @ Override void init ( ) { } @ Override void load ( ) throws IOException { String s [ ] = br . readLine ( ) . split ( \" \u2581 \" ) ; P = Integer . parseInt ( s [ 0 ] ) ; Q = Integer . parseInt ( s [ 1 ] ) ; free = new int [ Q + 2 ] ; free [ 0 ] = 0 ; free [ Q + 1 ] = P + 1 ; s = br . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < Q ; i ++ ) { free [ i + 1 ] = Integer . parseInt ( s [ i ] ) ; } Arrays . sort ( free ) ; bribe = new int [ free . length ] [ free . length ] ; } void compute ( int i , int j ) { if ( i == j ) { bribe [ i ] [ j ] = 0 ; return ; } int best = - 1 ; for ( int k = i + 1 ; k < j ; k ++ ) { int cur = bribe [ i ] [ k ] + bribe [ k ] [ j ] + ( free [ j ] - free [ i ] - 2 ) ; if ( best == - 1 || cur <= best ) best = cur ; } if ( best == - 1 ) best = 0 ; bribe [ i ] [ j ] = best ; } @ Override void solve ( ) { for ( int iv = 0 ; iv < free . length ; iv ++ ) { for ( int i = 0 ; i < free . length ; i ++ ) { int j = i + iv ; if ( j >= free . length ) break ; compute ( i , j ) ; } } printResult ( \" \" + bribe [ 0 ] [ Q + 1 ] ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Main m = new Main ( ) ; m . run ( \" C \" , \" large \" ) ; }"]], "functions_class": [["init", "void init ( ) { }"], ["load", "void load ( ) throws IOException { String s [ ] = br . readLine ( ) . split ( \" \u2581 \" ) ; P = Integer . parseInt ( s [ 0 ] ) ; Q = Integer . parseInt ( s [ 1 ] ) ; free = new int [ Q + 2 ] ; free [ 0 ] = 0 ; free [ Q + 1 ] = P + 1 ; s = br . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < Q ; i ++ ) { free [ i + 1 ] = Integer . parseInt ( s [ i ] ) ; } Arrays . sort ( free ) ; bribe = new int [ free . length ] [ free . length ] ; }"], ["compute", "void compute ( int i , int j ) { if ( i == j ) { bribe [ i ] [ j ] = 0 ; return ; } int best = - 1 ; for ( int k = i + 1 ; k < j ; k ++ ) { int cur = bribe [ i ] [ k ] + bribe [ k ] [ j ] + ( free [ j ] - free [ i ] - 2 ) ; if ( best == - 1 || cur <= best ) best = cur ; } if ( best == - 1 ) best = 0 ; bribe [ i ] [ j ] = best ; }"], ["solve", "void solve ( ) { for ( int iv = 0 ; iv < free . length ; iv ++ ) { for ( int i = 0 ; i < free . length ; i ++ ) { int j = i + iv ; if ( j >= free . length ) break ; compute ( i , j ) ; } } printResult ( \" \" + bribe [ 0 ] [ Q + 1 ] ) ; }"]]}, {"id": "2", "code": "import java . util . * ; import java . math . * ; class Main { public static void main ( String [ ] argv ) { Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { int p = sc . nextInt ( ) , q = sc . nextInt ( ) ; int [ ] cells = new int [ q ] ; for ( int i = 0 ; i < q ; i ++ ) { cells [ i ] = sc . nextInt ( ) ; } int [ ] nums = new int [ q + 1 ] ; nums [ 0 ] = cells [ 0 ] - 1 ; for ( int i = 1 ; i < q ; i ++ ) { nums [ i ] = cells [ i ] - cells [ i - 1 ] - 1 ; } nums [ q ] = p - cells [ q - 1 ] ; int [ ] [ ] fromto = new int [ q + 1 ] [ q + 1 ] ; for ( int start = 0 ; start <= q ; start ++ ) { } for ( int d = 1 ; d <= q ; d ++ ) { for ( int start = 0 ; start <= q - d ; start ++ ) { int min = p * p ; int all = 0 ; for ( int i = 0 ; i <= d ; i ++ ) { all += nums [ start + i ] ; } all += d - 1 ; for ( int i = 0 ; i < d ; i ++ ) { int sum = all + fromto [ start ] [ start + i ] + fromto [ start + i + 1 ] [ start + d ] ; if ( sum < min ) { min = sum ; } } fromto [ start ] [ start + d ] = min ; } } for ( int i = 0 ; i <= q ; i ++ ) { for ( int j = i ; j <= q ; j ++ ) { } } System . err . println ( t ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , t , fromto [ 0 ] [ q ] ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] argv ) { Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { int p = sc . nextInt ( ) , q = sc . nextInt ( ) ; int [ ] cells = new int [ q ] ; for ( int i = 0 ; i < q ; i ++ ) { cells [ i ] = sc . nextInt ( ) ; } int [ ] nums = new int [ q + 1 ] ; nums [ 0 ] = cells [ 0 ] - 1 ; for ( int i = 1 ; i < q ; i ++ ) { nums [ i ] = cells [ i ] - cells [ i - 1 ] - 1 ; } nums [ q ] = p - cells [ q - 1 ] ; int [ ] [ ] fromto = new int [ q + 1 ] [ q + 1 ] ; for ( int start = 0 ; start <= q ; start ++ ) { } for ( int d = 1 ; d <= q ; d ++ ) { for ( int start = 0 ; start <= q - d ; start ++ ) { int min = p * p ; int all = 0 ; for ( int i = 0 ; i <= d ; i ++ ) { all += nums [ start + i ] ; } all += d - 1 ; for ( int i = 0 ; i < d ; i ++ ) { int sum = all + fromto [ start ] [ start + i ] + fromto [ start + i + 1 ] [ start + d ] ; if ( sum < min ) { min = sum ; } } fromto [ start ] [ start + d ] = min ; } } for ( int i = 0 ; i <= q ; i ++ ) { for ( int j = i ; j <= q ; j ++ ) { } } System . err . println ( t ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , t , fromto [ 0 ] [ q ] ) ; } }"]], "functions_class": []}, {"id": "11", "code": "import java . io . * ; import java . util . * ; public class Main extends Thread { Scanner in ; PrintWriter out ; final int MAX = 100000 ; int p ; int nq ; int [ ] q ; HashMap < Integer , Integer > [ ] h ; int rec ( int i , int j ) { if ( i > j ) return 0 ; if ( h [ i ] . containsKey ( j ) ) return h [ i ] . get ( j ) ; int l = - 1 ; for ( int k = 0 ; k < nq ; k ++ ) if ( q [ k ] >= i && q [ k ] <= j ) { l = k ; break ; } int ret = 0 ; if ( l != - 1 ) { ret = MAX ; for ( int k = l ; k < nq && q [ k ] <= j ; k ++ ) ret = Math . min ( ret , j - i + rec ( i , q [ k ] - 1 ) + rec ( q [ k ] + 1 , j ) ) ; } h [ i ] . put ( j , ret ) ; return ret ; } public void run ( ) { try { in = new Scanner ( new File ( \" small . in \" ) ) ; out = new PrintWriter ( \" small . out \" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } int test = in . nextInt ( ) ; for ( int nt = 1 ; nt <= test ; nt ++ ) { p = in . nextInt ( ) ; nq = in . nextInt ( ) ; q = new int [ nq ] ; for ( int i = 0 ; i < nq ; i ++ ) q [ i ] = in . nextInt ( ) ; Arrays . sort ( q ) ; h = new HashMap [ p + 1 ] ; for ( int i = 1 ; i <= p ; i ++ ) h [ i ] = new HashMap < Integer , Integer > ( ) ; int ret = rec ( 1 , p ) ; out . println ( \" Case \u2581 # \" + nt + \" : \u2581 \" + ret ) ; } in . close ( ) ; out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; }"]], "functions_class": [["rec", "int rec ( int i , int j ) { if ( i > j ) return 0 ; if ( h [ i ] . containsKey ( j ) ) return h [ i ] . get ( j ) ; int l = - 1 ; for ( int k = 0 ; k < nq ; k ++ ) if ( q [ k ] >= i && q [ k ] <= j ) { l = k ; break ; } int ret = 0 ; if ( l != - 1 ) { ret = MAX ; for ( int k = l ; k < nq && q [ k ] <= j ; k ++ ) ret = Math . min ( ret , j - i + rec ( i , q [ k ] - 1 ) + rec ( q [ k ] + 1 , j ) ) ; } h [ i ] . put ( j , ret ) ; return ret ; }"], ["run", "public void run ( ) { try { in = new Scanner ( new File ( \" small . in \" ) ) ; out = new PrintWriter ( \" small . out \" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } int test = in . nextInt ( ) ; for ( int nt = 1 ; nt <= test ; nt ++ ) { p = in . nextInt ( ) ; nq = in . nextInt ( ) ; q = new int [ nq ] ; for ( int i = 0 ; i < nq ; i ++ ) q [ i ] = in . nextInt ( ) ; Arrays . sort ( q ) ; h = new HashMap [ p + 1 ] ; for ( int i = 1 ; i <= p ; i ++ ) h [ i ] = new HashMap < Integer , Integer > ( ) ; int ret = rec ( 1 , p ) ; out . println ( \" Case \u2581 # \" + nt + \" : \u2581 \" + ret ) ; } in . close ( ) ; out . close ( ) ; }"]]}, {"id": "0", "code": "import java . io . * ; import java . util . * ; public class C { PrintWriter out ; Scanner in ; String testCase = \" c2\" ; public static void main ( String [ ] args ) throws Exception { new C ( ) . solve ( ) ; } int INF = 1000000000 ; int P , Q ; int [ ] a ; int [ ] [ ] mem ; int findMax ( int left , int right ) { if ( mem [ left ] [ right ] != INF ) { return mem [ left ] [ right ] ; } int ans = INF ; for ( int i = left + 1 ; i < right ; ++ i ) { int newSol = a [ right ] - a [ left ] - 2 + findMax ( left , i ) + findMax ( i , right ) ; ans = Math . min ( ans , newSol ) ; } if ( ans == INF ) { ans = 0 ; } mem [ left ] [ right ] = ans ; return ans ; } void solve ( ) throws Exception { Locale . setDefault ( Locale . ENGLISH ) ; out = new PrintWriter ( new FileOutputStream ( testCase + \" . out \" ) ) ; in = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( testCase + \" . in \" ) ) ) ) ; int N = in . nextInt ( ) ; for ( int t = 1 ; t <= N ; ++ t ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; P = in . nextInt ( ) ; Q = in . nextInt ( ) ; a = new int [ Q + 2 ] ; a [ 0 ] = 0 ; for ( int i = 0 ; i < Q ; ++ i ) { a [ i + 1 ] = in . nextInt ( ) ; } a [ Q + 1 ] = P + 1 ; Arrays . sort ( a ) ; mem = new int [ Q + 2 ] [ Q + 2 ] ; for ( int i = 0 ; i <= Q + 1 ; ++ i ) { for ( int j = 0 ; j <= Q + 1 ; ++ j ) { mem [ i ] [ j ] = INF ; } } out . println ( findMax ( 0 , Q + 1 ) ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new C ( ) . solve ( ) ; }"]], "functions_class": [["findMax", "int findMax ( int left , int right ) { if ( mem [ left ] [ right ] != INF ) { return mem [ left ] [ right ] ; } int ans = INF ; for ( int i = left + 1 ; i < right ; ++ i ) { int newSol = a [ right ] - a [ left ] - 2 + findMax ( left , i ) + findMax ( i , right ) ; ans = Math . min ( ans , newSol ) ; } if ( ans == INF ) { ans = 0 ; } mem [ left ] [ right ] = ans ; return ans ; }"], ["solve", "void solve ( ) throws Exception { Locale . setDefault ( Locale . ENGLISH ) ; out = new PrintWriter ( new FileOutputStream ( testCase + \" . out \" ) ) ; in = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( testCase + \" . in \" ) ) ) ) ; int N = in . nextInt ( ) ; for ( int t = 1 ; t <= N ; ++ t ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; P = in . nextInt ( ) ; Q = in . nextInt ( ) ; a = new int [ Q + 2 ] ; a [ 0 ] = 0 ; for ( int i = 0 ; i < Q ; ++ i ) { a [ i + 1 ] = in . nextInt ( ) ; } a [ Q + 1 ] = P + 1 ; Arrays . sort ( a ) ; mem = new int [ Q + 2 ] [ Q + 2 ] ; for ( int i = 0 ; i <= Q + 1 ; ++ i ) { for ( int j = 0 ; j <= Q + 1 ; ++ j ) { mem [ i ] [ j ] = INF ; } } out . println ( findMax ( 0 , Q + 1 ) ) ; } out . close ( ) ; }"]]}, {"id": "3", "code": "import java . util . * ; public class C { static Map < Prison , Integer > cache = new HashMap < Prison , Integer > ( ) ; static class Prison { int start , end ; Prison ( int s , int e ) { this . start = s ; this . end = e ; } public int hashCode ( ) { return start * 10001 + end ; } public boolean equals ( Object o ) { return o . hashCode ( ) == hashCode ( ) ; } int solve ( ) { Integer solution = cache . get ( this ) ; if ( solution != null ) return solution ; solution = solve0 ( ) ; cache . put ( this , solution ) ; return solution ; } int solve0 ( ) { if ( length ( ) == 0 ) return 0 ; int answer = Integer . MAX_VALUE ; for ( int q : Q ) { if ( q < start || q > end ) continue ; Prison left = new Prison ( start , q - 1 ) ; Prison right = new Prison ( q + 1 , end ) ; int sol = left . length ( ) + right . length ( ) + left . solve ( ) + right . solve ( ) ; if ( sol < answer ) answer = sol ; } if ( answer == Integer . MAX_VALUE ) return 0 ; return answer ; } int length ( ) { return end - start + 1 ; } } static List < Integer > Q = new ArrayList < Integer > ( ) ; public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; s . useDelimiter ( \" \\\\ s + \" ) ; int testCases = s . nextInt ( ) ; for ( int t = 0 ; t < testCases ; t ++ ) { Q . clear ( ) ; int p = s . nextInt ( ) ; int q = s . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { Q . add ( s . nextInt ( ) ) ; } Prison prison = new Prison ( 1 , p ) ; cache . clear ( ) ; int sol = prison . solve ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , t + 1 , sol ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; s . useDelimiter ( \" \\\\ s + \" ) ; int testCases = s . nextInt ( ) ; for ( int t = 0 ; t < testCases ; t ++ ) { Q . clear ( ) ; int p = s . nextInt ( ) ; int q = s . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { Q . add ( s . nextInt ( ) ) ; } Prison prison = new Prison ( 1 , p ) ; cache . clear ( ) ; int sol = prison . solve ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , t + 1 , sol ) ; } }"]], "functions_class": [["Prison", "Prison ( int s , int e ) { this . start = s ; this . end = e ; }"], ["hashCode", "public int hashCode ( ) { return start * 10001 + end ; }"], ["equals", "public boolean equals ( Object o ) { return o . hashCode ( ) == hashCode ( ) ; }"], ["solve", "int solve ( ) { Integer solution = cache . get ( this ) ; if ( solution != null ) return solution ; solution = solve0 ( ) ; cache . put ( this , solution ) ; return solution ; }"], ["solve0", "int solve0 ( ) { if ( length ( ) == 0 ) return 0 ; int answer = Integer . MAX_VALUE ; for ( int q : Q ) { if ( q < start || q > end ) continue ; Prison left = new Prison ( start , q - 1 ) ; Prison right = new Prison ( q + 1 , end ) ; int sol = left . length ( ) + right . length ( ) + left . solve ( ) + right . solve ( ) ; if ( sol < answer ) answer = sol ; } if ( answer == Integer . MAX_VALUE ) return 0 ; return answer ; }"], ["length", "int length ( ) { return end - start + 1 ; }"]]}], "python": [{"id": "15", "code": "import sys NEW_LINE import math NEW_LINE fin = open ( ' input . txt ' , ' r ' ) NEW_LINE fout = open ( ' output . txt ' , ' w ' ) NEW_LINE l = int ( fin . readline ( ) ) NEW_LINE for case in range ( l ) : NEW_LINE INDENT P , Q = map ( int , fin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE frees = map ( int , fin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE cache = { } NEW_LINE def rangeof ( lid , rid ) : NEW_LINE INDENT lrange = rrange = 0 NEW_LINE if lid == 0 : NEW_LINE INDENT lrange = 1 NEW_LINE DEDENT else : NEW_LINE INDENT lrange = frees [ lid - 1 ] + 1 NEW_LINE DEDENT if rid == len ( frees ) - 1 : NEW_LINE INDENT rrange = P NEW_LINE DEDENT else : NEW_LINE INDENT rrange = frees [ rid + 1 ] - 1 NEW_LINE DEDENT return rrange - lrange + 1 NEW_LINE DEDENT def getbetter ( lid , rid ) : NEW_LINE INDENT if lid > rid : NEW_LINE INDENT return 0 NEW_LINE DEDENT if lid == rid : NEW_LINE INDENT return rangeof ( lid , rid ) - 1 NEW_LINE DEDENT key = ( lid , rid ) NEW_LINE if key in cache : NEW_LINE INDENT return cache [ key ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( lid , rid + 1 ) : NEW_LINE INDENT cache [ key ] = rangeof ( lid , rid ) - 1 + min ( [ getbetter ( lid , i - 1 ) + getbetter ( i + 1 , rid ) for i in range ( lid , rid + 1 ) ] ) NEW_LINE DEDENT return cache [ key ] NEW_LINE DEDENT DEDENT fout . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( case + 1 , getbetter ( 0 , len ( frees ) - 1 ) ) ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [["rangeof", "def rangeof ( lid , rid ) : NEW_LINE INDENT lrange = rrange = 0 NEW_LINE if lid == 0 : NEW_LINE INDENT lrange = 1 NEW_LINE DEDENT else : NEW_LINE INDENT lrange = frees [ lid - 1 ] + 1 NEW_LINE DEDENT if rid == len ( frees ) - 1 : NEW_LINE INDENT rrange = P NEW_LINE DEDENT else : NEW_LINE INDENT rrange = frees [ rid + 1 ] - 1 NEW_LINE DEDENT return rrange - lrange + 1 NEW_LINE DEDENT"], ["getbetter", "def getbetter ( lid , rid ) : NEW_LINE INDENT if lid > rid : NEW_LINE INDENT return 0 NEW_LINE DEDENT if lid == rid : NEW_LINE INDENT return rangeof ( lid , rid ) - 1 NEW_LINE DEDENT key = ( lid , rid ) NEW_LINE if key in cache : NEW_LINE INDENT return cache [ key ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( lid , rid + 1 ) : NEW_LINE INDENT cache [ key ] = rangeof ( lid , rid ) - 1 + min ( [ getbetter ( lid , i - 1 ) + getbetter ( i + 1 , rid ) for i in range ( lid , rid + 1 ) ] ) NEW_LINE DEDENT return cache [ key ] NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "6", "code": "Infinity = 1e10000 NEW_LINE bests = { } NEW_LINE def best ( qs = [ 0 , 1 ] ) : NEW_LINE INDENT base = qs [ - 1 ] - qs [ 0 ] - 2 NEW_LINE if len ( qs ) == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif len ( qs ) == 3 : NEW_LINE INDENT return base NEW_LINE DEDENT else : NEW_LINE INDENT key = tuple ( qs ) NEW_LINE if key not in bests : NEW_LINE INDENT b = Infinity NEW_LINE for split in range ( 1 , len ( qs ) - 1 ) : NEW_LINE INDENT b = min ( b , best ( qs [ : split + 1 ] ) + best ( qs [ split : ] ) ) NEW_LINE DEDENT bests [ key ] = b + base NEW_LINE DEDENT return bests [ key ] NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE for case in range ( 1 , N + 1 ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE P = int ( line [ 0 ] ) NEW_LINE Q = int ( line [ 1 ] ) NEW_LINE pris = [ int ( w ) for w in input ( ) . split ( ) ] NEW_LINE cells = [ 0 ] + pris + [ P + 1 ] NEW_LINE ans = best ( cells ) NEW_LINE print ( \" Case \u2581 # \" + str ( case ) + \" : \u2581 \" + str ( ans ) ) NEW_LINE DEDENT", "functions_standalone": [["best", "def best ( qs = [ 0 , 1 ] ) : NEW_LINE INDENT base = qs [ - 1 ] - qs [ 0 ] - 2 NEW_LINE if len ( qs ) == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif len ( qs ) == 3 : NEW_LINE INDENT return base NEW_LINE DEDENT else : NEW_LINE INDENT key = tuple ( qs ) NEW_LINE if key not in bests : NEW_LINE INDENT b = Infinity NEW_LINE for split in range ( 1 , len ( qs ) - 1 ) : NEW_LINE INDENT b = min ( b , best ( qs [ : split + 1 ] ) + best ( qs [ split : ] ) ) NEW_LINE DEDENT bests [ key ] = b + base NEW_LINE DEDENT return bests [ key ] NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "16", "code": "from gcjt import * NEW_LINE for t in tests ( ) : NEW_LINE INDENT p , q = tuple ( t . ri ( ) ) NEW_LINE x = ( 0 , ) + tuple ( t . ri ( ) ) + ( p + 1 , ) NEW_LINE f = array ( q + 2 , q + 2 ) NEW_LINE for i in range ( 0 , q + 1 ) : NEW_LINE INDENT f [ i ] [ i + 1 ] = 0 NEW_LINE DEDENT for l in range ( 2 , q + 2 ) : NEW_LINE INDENT for i in range ( q + 2 - l ) : NEW_LINE INDENT f [ i ] [ i + l ] = x [ i + l ] - x [ i ] - 2 + min ( f [ i ] [ j ] + f [ j ] [ i + l ] for j in range ( i + 1 , i + l ) ) NEW_LINE DEDENT DEDENT t . answer ( f [ 0 ] [ q + 1 ] ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_09_11", "java": [{"id": "12", "code": "import java . io . * ; import java . util . * ; public class AAA { boolean getsum1 ( int n , int k ) { TreeSet < Integer > y = new TreeSet < Integer > ( ) ; while ( true ) { if ( y . contains ( n ) ) return false ; y . add ( n ) ; int res = 0 ; while ( n != 0 ) { res += ( n % k ) * ( n % k ) ; n /= k ; } n = res ; if ( n == 1 ) return true ; } } TreeMap < Integer , Integer > result = new TreeMap < Integer , Integer > ( ) ; void solve ( ) throws IOException { Scanner in = new Scanner ( new FileInputStream ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( new FileOutputStream ( \" output . txt \" ) ) ; String s ; int n = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= n ; ++ t ) { s = in . nextLine ( ) ; if ( s == null ) break ; ArrayList < Integer > a = new ArrayList < Integer > ( ) ; Scanner in2 = new Scanner ( s ) ; while ( in2 . hasNextInt ( ) ) a . add ( in2 . nextInt ( ) ) ; int mask = 0 ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) mask += 1 << a . get ( i ) ; if ( a . size ( ) == 9 ) result . put ( mask , 11814485 ) ; int tr = 2 ; if ( result . containsKey ( mask ) ) { tr = result . get ( mask ) ; } else { while ( true ) { boolean good = true ; for ( int i = a . size ( ) - 1 ; i >= 0 ; -- i ) if ( ! getsum1 ( tr , a . get ( i ) ) ) { good = false ; break ; } if ( good ) break ; tr ++ ; } result . put ( mask , tr ) ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + tr ) ; out . flush ( ) ; } out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { AAA a = new AAA ( ) ; a . solve ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { AAA a = new AAA ( ) ; a . solve ( ) ; }"]], "functions_class": [["getsum1", "boolean getsum1 ( int n , int k ) { TreeSet < Integer > y = new TreeSet < Integer > ( ) ; while ( true ) { if ( y . contains ( n ) ) return false ; y . add ( n ) ; int res = 0 ; while ( n != 0 ) { res += ( n % k ) * ( n % k ) ; n /= k ; } n = res ; if ( n == 1 ) return true ; } }"], ["solve", "void solve ( ) throws IOException { Scanner in = new Scanner ( new FileInputStream ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( new FileOutputStream ( \" output . txt \" ) ) ; String s ; int n = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= n ; ++ t ) { s = in . nextLine ( ) ; if ( s == null ) break ; ArrayList < Integer > a = new ArrayList < Integer > ( ) ; Scanner in2 = new Scanner ( s ) ; while ( in2 . hasNextInt ( ) ) a . add ( in2 . nextInt ( ) ) ; int mask = 0 ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) mask += 1 << a . get ( i ) ; if ( a . size ( ) == 9 ) result . put ( mask , 11814485 ) ; int tr = 2 ; if ( result . containsKey ( mask ) ) { tr = result . get ( mask ) ; } else { while ( true ) { boolean good = true ; for ( int i = a . size ( ) - 1 ; i >= 0 ; -- i ) if ( ! getsum1 ( tr , a . get ( i ) ) ) { good = false ; break ; } if ( good ) break ; tr ++ ; } result . put ( mask , tr ) ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + tr ) ; out . flush ( ) ; } out . close ( ) ; }"]]}], "python": [{"id": "11", "code": "import sys , os NEW_LINE in_file = None NEW_LINE out_file = None NEW_LINE def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in xrange ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in xrange ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT", "functions_standalone": [["run_main", "def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT"], ["readline", "def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT"], ["writeline", "def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT"], ["readinteger", "def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_09_44", "java": [{"id": "9", "code": "import java . util . * ; import java . io . * ; public class Main implements Runnable { public Scanner in ; public PrintWriter out ; Main ( ) throws IOException { in = new Scanner ( new File ( \" in \" ) ) ; out = new PrintWriter ( new File ( \" out \" ) ) ; } void close ( ) throws IOException { out . close ( ) ; } public void run ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int n = in . nextInt ( ) ; double [ ] x = new double [ n ] ; double [ ] y = new double [ n ] ; double [ ] r = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextDouble ( ) ; y [ i ] = in . nextDouble ( ) ; r [ i ] = in . nextDouble ( ) ; } double res = 1E100 ; if ( n == 1 ) { res = r [ 0 ] ; } else if ( n == 2 ) { res = Math . max ( r [ 0 ] , r [ 1 ] ) ; } else { for ( int i = 0 ; i < 3 ; i ++ ) { int j = ( i + 1 ) % 3 ; int k = ( i + 2 ) % 3 ; res = Math . min ( res , Math . max ( r [ i ] , 0.5 * ( Math . hypot ( x [ j ] - x [ k ] , y [ j ] - y [ k ] ) + r [ j ] + r [ k ] ) ) ) ; } } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + res ) ; } try { close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; }"]], "functions_class": [["Main", "Main ( ) throws IOException { in = new Scanner ( new File ( \" in \" ) ) ; out = new PrintWriter ( new File ( \" out \" ) ) ; }"], ["close", "void close ( ) throws IOException { out . close ( ) ; }"], ["run", "public void run ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int n = in . nextInt ( ) ; double [ ] x = new double [ n ] ; double [ ] y = new double [ n ] ; double [ ] r = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextDouble ( ) ; y [ i ] = in . nextDouble ( ) ; r [ i ] = in . nextDouble ( ) ; } double res = 1E100 ; if ( n == 1 ) { res = r [ 0 ] ; } else if ( n == 2 ) { res = Math . max ( r [ 0 ] , r [ 1 ] ) ; } else { for ( int i = 0 ; i < 3 ; i ++ ) { int j = ( i + 1 ) % 3 ; int k = ( i + 2 ) % 3 ; res = Math . min ( res , Math . max ( r [ i ] , 0.5 * ( Math . hypot ( x [ j ] - x [ k ] , y [ j ] - y [ k ] ) + r [ j ] + r [ k ] ) ) ) ; } } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + res ) ; } try { close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]]}, {"id": "13", "code": "import java . io . BufferedReader ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintStream ; public class D { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" D - small . in \" ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" D - small . out \" ) ) ; int cases = Integer . parseInt ( br . readLine ( ) ) ; for ( int itr = 1 ; itr <= cases ; itr ++ ) { int flowers = Integer . parseInt ( br . readLine ( ) ) ; int [ ] x = new int [ flowers ] ; int [ ] y = new int [ flowers ] ; int [ ] r = new int [ flowers ] ; for ( int i = 0 ; i < flowers ; i ++ ) { String [ ] sp = br . readLine ( ) . split ( \" \u2581 \" ) ; x [ i ] = Integer . parseInt ( sp [ 0 ] ) ; y [ i ] = Integer . parseInt ( sp [ 1 ] ) ; r [ i ] = Integer . parseInt ( sp [ 2 ] ) ; } double out = 0 ; if ( flowers < 3 ) out = Math . max ( r [ 0 ] , r [ flowers - 1 ] ) ; else { out = 1e100 ; for ( int i = 0 ; i < flowers ; i ++ ) { int j = ( i == 0 ) ? 1 : 0 ; int k = ( i == 2 ) ? 1 : 2 ; double d = Math . sqrt ( ( x [ j ] - x [ k ] ) * ( x [ j ] - x [ k ] ) + ( y [ j ] - y [ k ] ) * ( y [ j ] - y [ k ] ) ) ; out = Math . min ( out , Math . max ( r [ i ] , ( d + r [ j ] + r [ k ] ) / 2 ) ) ; } } ps . println ( \" Case \u2581 # \" + itr + \" : \u2581 \" + out ) ; } br . close ( ) ; ps . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" D - small . in \" ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" D - small . out \" ) ) ; int cases = Integer . parseInt ( br . readLine ( ) ) ; for ( int itr = 1 ; itr <= cases ; itr ++ ) { int flowers = Integer . parseInt ( br . readLine ( ) ) ; int [ ] x = new int [ flowers ] ; int [ ] y = new int [ flowers ] ; int [ ] r = new int [ flowers ] ; for ( int i = 0 ; i < flowers ; i ++ ) { String [ ] sp = br . readLine ( ) . split ( \" \u2581 \" ) ; x [ i ] = Integer . parseInt ( sp [ 0 ] ) ; y [ i ] = Integer . parseInt ( sp [ 1 ] ) ; r [ i ] = Integer . parseInt ( sp [ 2 ] ) ; } double out = 0 ; if ( flowers < 3 ) out = Math . max ( r [ 0 ] , r [ flowers - 1 ] ) ; else { out = 1e100 ; for ( int i = 0 ; i < flowers ; i ++ ) { int j = ( i == 0 ) ? 1 : 0 ; int k = ( i == 2 ) ? 1 : 2 ; double d = Math . sqrt ( ( x [ j ] - x [ k ] ) * ( x [ j ] - x [ k ] ) + ( y [ j ] - y [ k ] ) * ( y [ j ] - y [ k ] ) ) ; out = Math . min ( out , Math . max ( r [ i ] , ( d + r [ j ] + r [ k ] ) / 2 ) ) ; } } ps . println ( \" Case \u2581 # \" + itr + \" : \u2581 \" + out ) ; } br . close ( ) ; ps . close ( ) ; }"]], "functions_class": []}, {"id": "11", "code": "import java . util . * ; import java . io . * ; public class x { public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { int n = in . nextInt ( ) ; int [ ] x = new int [ n ] , y = new int [ n ] , r = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextInt ( ) ; y [ i ] = in . nextInt ( ) ; r [ i ] = in . nextInt ( ) ; } double ans = - 1 ; if ( n == 1 ) ans = r [ 0 ] ; else if ( n == 2 ) ans = Math . max ( r [ 0 ] , r [ 1 ] ) ; else if ( n == 3 ) { ans = Math . max ( r [ 0 ] , 0.5 * ( Math . hypot ( x [ 2 ] - x [ 1 ] , y [ 2 ] - y [ 1 ] ) + r [ 1 ] + r [ 2 ] ) ) ; ans = Math . min ( ans , Math . max ( r [ 1 ] , 0.5 * ( Math . hypot ( x [ 2 ] - x [ 0 ] , y [ 2 ] - y [ 0 ] ) + r [ 0 ] + r [ 2 ] ) ) ) ; ans = Math . min ( ans , Math . max ( r [ 2 ] , 0.5 * ( Math . hypot ( x [ 1 ] - x [ 0 ] , y [ 1 ] - y [ 0 ] ) + r [ 0 ] + r [ 1 ] ) ) ) ; } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + ans ) ; } ; } ; } ;", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { int n = in . nextInt ( ) ; int [ ] x = new int [ n ] , y = new int [ n ] , r = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = in . nextInt ( ) ; y [ i ] = in . nextInt ( ) ; r [ i ] = in . nextInt ( ) ; } double ans = - 1 ; if ( n == 1 ) ans = r [ 0 ] ; else if ( n == 2 ) ans = Math . max ( r [ 0 ] , r [ 1 ] ) ; else if ( n == 3 ) { ans = Math . max ( r [ 0 ] , 0.5 * ( Math . hypot ( x [ 2 ] - x [ 1 ] , y [ 2 ] - y [ 1 ] ) + r [ 1 ] + r [ 2 ] ) ) ; ans = Math . min ( ans , Math . max ( r [ 1 ] , 0.5 * ( Math . hypot ( x [ 2 ] - x [ 0 ] , y [ 2 ] - y [ 0 ] ) + r [ 0 ] + r [ 2 ] ) ) ) ; ans = Math . min ( ans , Math . max ( r [ 2 ] , 0.5 * ( Math . hypot ( x [ 1 ] - x [ 0 ] , y [ 1 ] - y [ 0 ] ) + r [ 0 ] + r [ 1 ] ) ) ) ; } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + ans ) ; } ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "import sys NEW_LINE import math NEW_LINE def best3 ( a , b , c ) : NEW_LINE INDENT ( ax , ay , ar ) = a NEW_LINE ( bx , by , br ) = b NEW_LINE ( cx , cy , cr ) = c NEW_LINE return ( max ( ar , ( math . sqrt ( ( bx - cx ) ** 2 + ( by - cy ) ** 2 ) + float ( br ) + float ( cr ) ) / 2.0 ) ) NEW_LINE DEDENT rdln = sys . stdin . readline NEW_LINE C = int ( rdln ( ) ) NEW_LINE for c in range ( C ) : NEW_LINE INDENT N = int ( rdln ( ) ) NEW_LINE p = [ [ int ( x ) for x in rdln ( ) . split ( ) ] for w in range ( N ) ] NEW_LINE ans = 0.0 NEW_LINE if N == 1 : NEW_LINE INDENT ans = p [ 0 ] [ 2 ] NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT ans = max ( p [ 0 ] [ 2 ] , p [ 1 ] [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ( N == 3 ) NEW_LINE ans = min ( best3 ( p [ 0 ] , p [ 1 ] , p [ 2 ] ) , best3 ( p [ 1 ] , p [ 2 ] , p [ 0 ] ) , best3 ( p [ 2 ] , p [ 0 ] , p [ 1 ] ) ) NEW_LINE DEDENT print ( \" Case \u2581 # \" , c + 1 , \" : \u2581 \" , ans , sep = \" \" ) NEW_LINE DEDENT", "functions_standalone": [["best3", "def best3 ( a , b , c ) : NEW_LINE INDENT ( ax , ay , ar ) = a NEW_LINE ( bx , by , br ) = b NEW_LINE ( cx , cy , cr ) = c NEW_LINE return ( max ( ar , ( math . sqrt ( ( bx - cx ) ** 2 + ( by - cy ) ** 2 ) + float ( br ) + float ( cr ) ) / 2.0 ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "import sys , math NEW_LINE fi = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fo = open ( sys . argv [ 2 ] , \" w \" ) NEW_LINE cases = int ( fi . readline ( ) ) NEW_LINE for C in range ( cases ) : NEW_LINE INDENT plants = int ( fi . readline ( ) ) NEW_LINE P = [ ] NEW_LINE for plant in range ( plants ) : NEW_LINE INDENT P . append ( map ( int , fi . readline ( ) . split ( ) ) ) NEW_LINE DEDENT R = { } NEW_LINE for a in range ( plants ) : NEW_LINE INDENT for b in range ( a , plants ) : NEW_LINE INDENT R [ ( a , b ) ] = math . sqrt ( ( P [ a ] [ 0 ] - P [ b ] [ 0 ] ) ** 2 + ( P [ a ] [ 1 ] - P [ b ] [ 1 ] ) ** 2 ) + P [ a ] [ 2 ] + P [ b ] [ 2 ] NEW_LINE DEDENT DEDENT if ( plants == 1 ) : fo . write ( \" Case : \u2581 # % d : \u2581 % f \\n \" % ( C + 1 , P [ 0 ] [ 2 ] ) ) NEW_LINE if ( plants == 2 ) : fo . write ( \" Case : \u2581 # % d : \u2581 % f \\n \" % ( C + 1 , max ( P [ 0 ] [ 2 ] , P [ 1 ] [ 2 ] ) ) ) NEW_LINE if ( plants == 3 ) : NEW_LINE INDENT m = min ( R [ ( 0 , 1 ) ] , R [ ( 0 , 2 ) ] , R [ ( 1 , 2 ) ] ) NEW_LINE if R [ ( 0 , 1 ) ] == m : fo . write ( \" Case \u2581 # % d : \u2581 % f \\n \" % ( C + 1 , max ( m / 2.0 , P [ 2 ] [ 2 ] ) ) ) NEW_LINE elif R [ ( 0 , 2 ) ] == m : fo . write ( \" Case \u2581 # % d : \u2581 % f \\n \" % ( C + 1 , max ( m / 2.0 , P [ 1 ] [ 2 ] ) ) ) NEW_LINE elif R [ ( 1 , 2 ) ] == m : fo . write ( \" Case \u2581 # % d : \u2581 % f \\n \" % ( C + 1 , max ( m / 2.0 , P [ 0 ] [ 2 ] ) ) ) NEW_LINE DEDENT DEDENT fi . close ( ) NEW_LINE fo . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "import math NEW_LINE def Cover ( C ) : NEW_LINE INDENT if len ( C ) == 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT if len ( C ) == 1 : NEW_LINE INDENT return C [ 0 ] [ 2 ] NEW_LINE DEDENT return ( C [ 0 ] [ 2 ] + C [ 1 ] [ 2 ] + math . sqrt ( ( C [ 0 ] [ 0 ] - C [ 1 ] [ 0 ] ) ** 2 + ( C [ 0 ] [ 1 ] - C [ 1 ] [ 1 ] ) ** 2 ) ) / 2.0 NEW_LINE DEDENT for tc in range ( 1 , int ( input ( ) ) + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE circles = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , r = map ( int , input ( ) . split ( ) ) NEW_LINE circles . append ( ( x , y , r ) ) NEW_LINE DEDENT ans = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT nans = max ( Cover ( circles [ i : i + 1 ] ) , Cover ( circles [ 0 : i ] + circles [ i + 1 : n ] ) ) NEW_LINE if ans is None or nans < ans : NEW_LINE INDENT ans = nans NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % .6f \" % ( tc , ans ) ) NEW_LINE DEDENT", "functions_standalone": [["Cover", "def Cover ( C ) : NEW_LINE INDENT if len ( C ) == 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT if len ( C ) == 1 : NEW_LINE INDENT return C [ 0 ] [ 2 ] NEW_LINE DEDENT return ( C [ 0 ] [ 2 ] + C [ 1 ] [ 2 ] + math . sqrt ( ( C [ 0 ] [ 0 ] - C [ 1 ] [ 0 ] ) ** 2 + ( C [ 0 ] [ 1 ] - C [ 1 ] [ 1 ] ) ** 2 ) ) / 2.0 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "import itertools NEW_LINE import math NEW_LINE def distance ( p1 , p2 ) : NEW_LINE INDENT return math . sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) NEW_LINE DEDENT def solve_third_case ( points ) : NEW_LINE INDENT solution = 10 ** 10 NEW_LINE for p in itertools . permutations ( [ 0 , 1 , 2 ] , 3 ) : NEW_LINE INDENT foobar = distance ( points [ p [ 0 ] ] , points [ p [ 1 ] ] ) NEW_LINE foobar = ( foobar + points [ p [ 0 ] ] [ 2 ] + points [ p [ 1 ] ] [ 2 ] ) / 2 NEW_LINE if foobar >= points [ p [ 2 ] ] [ 2 ] : NEW_LINE INDENT solution = min ( [ solution , foobar ] ) NEW_LINE DEDENT else : NEW_LINE INDENT solution = min ( [ solution , points [ p [ 2 ] ] [ 2 ] ] ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT def solve ( points ) : NEW_LINE INDENT if len ( points ) == 1 : NEW_LINE INDENT return points [ 0 ] [ 2 ] NEW_LINE DEDENT elif len ( points ) == 2 : NEW_LINE INDENT return max ( points [ 0 ] [ 2 ] , points [ 1 ] [ 2 ] ) NEW_LINE DEDENT elif len ( points ) == 3 : NEW_LINE INDENT return solve_third_case ( points ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT file = open ( \" input . in \" ) NEW_LINE tests = int ( file . readline ( ) ) NEW_LINE for case in range ( 1 , tests + 1 ) : NEW_LINE INDENT N = int ( file . readline ( ) ) NEW_LINE points = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT points . append ( [ int ( x ) for x in file . readline ( ) . split ( ) ] ) NEW_LINE DEDENT print ( \" Case \u2581 # \" , case , \" : \u2581 \" , solve ( points ) , sep = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["distance", "def distance ( p1 , p2 ) : NEW_LINE INDENT return math . sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) NEW_LINE DEDENT"], ["solve_third_case", "def solve_third_case ( points ) : NEW_LINE INDENT solution = 10 ** 10 NEW_LINE for p in itertools . permutations ( [ 0 , 1 , 2 ] , 3 ) : NEW_LINE INDENT foobar = distance ( points [ p [ 0 ] ] , points [ p [ 1 ] ] ) NEW_LINE foobar = ( foobar + points [ p [ 0 ] ] [ 2 ] + points [ p [ 1 ] ] [ 2 ] ) / 2 NEW_LINE if foobar >= points [ p [ 2 ] ] [ 2 ] : NEW_LINE INDENT solution = min ( [ solution , foobar ] ) NEW_LINE DEDENT else : NEW_LINE INDENT solution = min ( [ solution , points [ p [ 2 ] ] [ 2 ] ] ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT"], ["solve", "def solve ( points ) : NEW_LINE INDENT if len ( points ) == 1 : NEW_LINE INDENT return points [ 0 ] [ 2 ] NEW_LINE DEDENT elif len ( points ) == 2 : NEW_LINE INDENT return max ( points [ 0 ] [ 2 ] , points [ 1 ] [ 2 ] ) NEW_LINE DEDENT elif len ( points ) == 3 : NEW_LINE INDENT return solve_third_case ( points ) NEW_LINE DEDENT DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT file = open ( \" input . in \" ) NEW_LINE tests = int ( file . readline ( ) ) NEW_LINE for case in range ( 1 , tests + 1 ) : NEW_LINE INDENT N = int ( file . readline ( ) ) NEW_LINE points = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT points . append ( [ int ( x ) for x in file . readline ( ) . split ( ) ] ) NEW_LINE DEDENT print ( \" Case \u2581 # \" , case , \" : \u2581 \" , solve ( points ) , sep = \" \" ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_09_31", "java": [{"id": "9", "code": "import java . io . * ; import java . math . * ; public class a { public static void main ( String [ ] args ) { BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int cases = Integer . valueOf ( input . readLine ( ) ) ; for ( int cas = 1 ; cas <= cases ; cas ++ ) { String line = input . readLine ( ) ; int digit [ ] = new int [ 256 ] ; int base = 0 , i ; BigInteger num = new BigInteger ( \"0\" ) ; for ( i = 0 ; i < 256 ; i ++ ) digit [ i ] = - 1 ; for ( i = 0 ; i < line . length ( ) ; i ++ ) { if ( ( line . charAt ( i ) < '0' || line . charAt ( i ) > '9' ) && ( line . charAt ( i ) < ' a ' || line . charAt ( i ) > ' z ' ) ) continue ; if ( digit [ line . charAt ( i ) ] == - 1 ) { if ( base == 0 ) digit [ line . charAt ( i ) ] = 1 ; else if ( base == 1 ) digit [ line . charAt ( i ) ] = 0 ; else digit [ line . charAt ( i ) ] = base ; base ++ ; } } if ( base < 2 ) base = 2 ; int cnt = 0 ; for ( i = 0 ; i < line . length ( ) ; i ++ ) { if ( ( line . charAt ( i ) < '0' || line . charAt ( i ) > '9' ) && ( line . charAt ( i ) < ' a ' || line . charAt ( i ) > ' z ' ) ) continue ; num = num . multiply ( BigInteger . valueOf ( base ) ) ; num = num . add ( BigInteger . valueOf ( digit [ line . charAt ( i ) ] ) ) ; } System . out . printf ( \" Case \u2581 # % d : \u2581 \" , cas ) ; System . out . println ( num ) ; } } catch ( java . io . IOException e ) { } } } ;", "functions_standalone": [["main", "public static void main ( String [ ] args ) { BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int cases = Integer . valueOf ( input . readLine ( ) ) ; for ( int cas = 1 ; cas <= cases ; cas ++ ) { String line = input . readLine ( ) ; int digit [ ] = new int [ 256 ] ; int base = 0 , i ; BigInteger num = new BigInteger ( \"0\" ) ; for ( i = 0 ; i < 256 ; i ++ ) digit [ i ] = - 1 ; for ( i = 0 ; i < line . length ( ) ; i ++ ) { if ( ( line . charAt ( i ) < '0' || line . charAt ( i ) > '9' ) && ( line . charAt ( i ) < ' a ' || line . charAt ( i ) > ' z ' ) ) continue ; if ( digit [ line . charAt ( i ) ] == - 1 ) { if ( base == 0 ) digit [ line . charAt ( i ) ] = 1 ; else if ( base == 1 ) digit [ line . charAt ( i ) ] = 0 ; else digit [ line . charAt ( i ) ] = base ; base ++ ; } } if ( base < 2 ) base = 2 ; int cnt = 0 ; for ( i = 0 ; i < line . length ( ) ; i ++ ) { if ( ( line . charAt ( i ) < '0' || line . charAt ( i ) > '9' ) && ( line . charAt ( i ) < ' a ' || line . charAt ( i ) > ' z ' ) ) continue ; num = num . multiply ( BigInteger . valueOf ( base ) ) ; num = num . add ( BigInteger . valueOf ( digit [ line . charAt ( i ) ] ) ) ; } System . out . printf ( \" Case \u2581 # % d : \u2581 \" , cas ) ; System . out . println ( num ) ; } } catch ( java . io . IOException e ) { } }"]], "functions_class": []}, {"id": "16", "code": "package allyourbase ; import java . io . IOException ; public class Main extends Base { String alien ; char app [ ] ; int apos ; public static void main ( String [ ] args ) throws IOException { Main m = new Main ( ) ; m . run ( \" A \" , \" large \" ) ; } @ Override void init ( ) { } @ Override void load ( ) { } void insert ( char ch ) { int i = 0 ; while ( i < apos && app [ i ] != ch ) i ++ ; if ( i < apos ) return ; app [ apos ] = ch ; apos ++ ; } @ Override void solve ( ) throws IOException { System . out . println ( \" Case \u2581 \" + caseId ) ; alien = br . readLine ( ) ; System . out . println ( alien ) ; app = new char [ alien . length ( ) ] ; apos = 0 ; for ( int i = 0 ; i < alien . length ( ) ; i ++ ) { insert ( alien . charAt ( i ) ) ; } long base = apos ; if ( base == 1 ) base ++ ; long res [ ] = new long [ alien . length ( ) ] ; for ( int i = 0 ; i < apos ; i ++ ) { int digit = i ; if ( digit == 0 ) digit = 1 ; else if ( digit == 1 ) digit = 0 ; for ( int j = 0 ; j < alien . length ( ) ; j ++ ) { if ( app [ i ] == alien . charAt ( j ) ) { res [ j ] = digit ; } } } for ( int i = 0 ; i < alien . length ( ) ; i ++ ) { System . out . print ( res [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; long result = 0 ; long cur = 1 ; for ( int j = res . length - 1 ; j >= 0 ; j -- ) { result = result + cur * res [ j ] ; cur = cur * base ; } printResult ( \" \" + result ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Main m = new Main ( ) ; m . run ( \" A \" , \" large \" ) ; }"]], "functions_class": [["init", "void init ( ) { }"], ["load", "void load ( ) { }"], ["insert", "void insert ( char ch ) { int i = 0 ; while ( i < apos && app [ i ] != ch ) i ++ ; if ( i < apos ) return ; app [ apos ] = ch ; apos ++ ; }"], ["solve", "void solve ( ) throws IOException { System . out . println ( \" Case \u2581 \" + caseId ) ; alien = br . readLine ( ) ; System . out . println ( alien ) ; app = new char [ alien . length ( ) ] ; apos = 0 ; for ( int i = 0 ; i < alien . length ( ) ; i ++ ) { insert ( alien . charAt ( i ) ) ; } long base = apos ; if ( base == 1 ) base ++ ; long res [ ] = new long [ alien . length ( ) ] ; for ( int i = 0 ; i < apos ; i ++ ) { int digit = i ; if ( digit == 0 ) digit = 1 ; else if ( digit == 1 ) digit = 0 ; for ( int j = 0 ; j < alien . length ( ) ; j ++ ) { if ( app [ i ] == alien . charAt ( j ) ) { res [ j ] = digit ; } } } for ( int i = 0 ; i < alien . length ( ) ; i ++ ) { System . out . print ( res [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; long result = 0 ; long cur = 1 ; for ( int j = res . length - 1 ; j >= 0 ; j -- ) { result = result + cur * res [ j ] ; cur = cur * base ; } printResult ( \" \" + result ) ; }"]]}, {"id": "18", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . math . BigInteger ; import java . util . HashMap ; import java . util . Scanner ; public class AllYourBase { public static void main ( String [ ] args ) { try { BufferedReader in = new BufferedReader ( new FileReader ( \" A - small . in \" ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" x . txt \" ) ) ; Scanner scan = new Scanner ( in ) ; int T = scan . nextInt ( ) ; scan . nextLine ( ) ; for ( int ii = 0 ; ii < T ; ii ++ ) { String str = scan . nextLine ( ) ; HashMap < Character , Integer > hm = new HashMap < Character , Integer > ( ) ; hm . put ( str . charAt ( 0 ) , 1 ) ; int count = 1 ; while ( count < str . length ( ) ) { char c = str . charAt ( count ) ; if ( ! hm . containsKey ( c ) ) { hm . put ( c , 0 ) ; break ; } count ++ ; } count ++ ; int val = 2 ; while ( count < str . length ( ) ) { char c = str . charAt ( count ) ; if ( ! hm . containsKey ( c ) ) { hm . put ( c , val ++ ) ; } count ++ ; } String tgt = \" \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { tgt += hm . get ( str . charAt ( i ) ) ; } BigInteger x = new BigInteger ( tgt , val ) ; out . write ( \" Case \u2581 # \" + ( ii + 1 ) + \" : \u2581 \" + x . toString ( ) + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { BufferedReader in = new BufferedReader ( new FileReader ( \" A - small . in \" ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" x . txt \" ) ) ; Scanner scan = new Scanner ( in ) ; int T = scan . nextInt ( ) ; scan . nextLine ( ) ; for ( int ii = 0 ; ii < T ; ii ++ ) { String str = scan . nextLine ( ) ; HashMap < Character , Integer > hm = new HashMap < Character , Integer > ( ) ; hm . put ( str . charAt ( 0 ) , 1 ) ; int count = 1 ; while ( count < str . length ( ) ) { char c = str . charAt ( count ) ; if ( ! hm . containsKey ( c ) ) { hm . put ( c , 0 ) ; break ; } count ++ ; } count ++ ; int val = 2 ; while ( count < str . length ( ) ) { char c = str . charAt ( count ) ; if ( ! hm . containsKey ( c ) ) { hm . put ( c , val ++ ) ; } count ++ ; } String tgt = \" \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { tgt += hm . get ( str . charAt ( i ) ) ; } BigInteger x = new BigInteger ( tgt , val ) ; out . write ( \" Case \u2581 # \" + ( ii + 1 ) + \" : \u2581 \" + x . toString ( ) + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "0", "code": "import java . io . * ; import java . util . * ; public class A { PrintWriter out ; Scanner in ; String testCase = \" a2\" ; public static void main ( String [ ] args ) throws Exception { new A ( ) . solve ( ) ; } void solve ( ) throws Exception { Locale . setDefault ( Locale . ENGLISH ) ; out = new PrintWriter ( new FileOutputStream ( testCase + \" . out \" ) ) ; in = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( testCase + \" . in \" ) ) ) ) ; int N = in . nextInt ( ) ; for ( int t = 1 ; t <= N ; ++ t ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; String num = in . next ( ) ; Map < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( char c : num . toCharArray ( ) ) { if ( map . containsKey ( c ) ) { continue ; } if ( map . size ( ) == 0 ) { map . put ( c , 1 ) ; } else if ( map . size ( ) == 1 ) { map . put ( c , 0 ) ; } else { map . put ( c , map . size ( ) ) ; } } long result = 0 ; int base = map . size ( ) ; if ( base == 1 ) { base = 2 ; } for ( char c : num . toCharArray ( ) ) { result = result * base + map . get ( c ) ; } out . println ( result ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new A ( ) . solve ( ) ; }"]], "functions_class": [["solve", "void solve ( ) throws Exception { Locale . setDefault ( Locale . ENGLISH ) ; out = new PrintWriter ( new FileOutputStream ( testCase + \" . out \" ) ) ; in = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( testCase + \" . in \" ) ) ) ) ; int N = in . nextInt ( ) ; for ( int t = 1 ; t <= N ; ++ t ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; String num = in . next ( ) ; Map < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( char c : num . toCharArray ( ) ) { if ( map . containsKey ( c ) ) { continue ; } if ( map . size ( ) == 0 ) { map . put ( c , 1 ) ; } else if ( map . size ( ) == 1 ) { map . put ( c , 0 ) ; } else { map . put ( c , map . size ( ) ) ; } } long result = 0 ; int base = map . size ( ) ; if ( base == 1 ) { base = 2 ; } for ( char c : num . toCharArray ( ) ) { result = result * base + map . get ( c ) ; } out . println ( result ) ; } out . close ( ) ; }"]]}, {"id": "17", "code": "import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Scanner ; public class P1 { public static void main ( String args [ ] ) throws FileNotFoundException { Scanner s = new Scanner ( new FileInputStream ( \" A - large . in \" ) ) ; int cnt = s . nextInt ( ) ; for ( int cases = 0 ; cases < cnt ; cases ++ ) { String buf = s . next ( ) ; long num = 0 ; int bb = - 1 ; int [ ] ar = new int [ buf . length ( ) ] ; HashMap < String , Integer > set = new HashMap < String , Integer > ( ) ; set . put ( buf . substring ( 0 , 1 ) , 1 ) ; for ( int i = 0 ; i < buf . length ( ) ; i ++ ) { if ( set . containsKey ( buf . substring ( i , i + 1 ) ) ) { ar [ i ] = set . get ( buf . substring ( i , i + 1 ) ) ; } else { bb ++ ; if ( bb == 1 ) { bb = 2 ; } set . put ( buf . substring ( i , i + 1 ) , bb ) ; ar [ i ] = bb ; } } bb ++ ; if ( bb < 2 ) { bb = 2 ; } for ( int i = 0 ; i < buf . length ( ) ; i ++ ) { long temp = 1 ; for ( int j = 0 ; j < buf . length ( ) - i - 1 ; j ++ ) { temp = temp * ( long ) bb ; } num += ( long ) ar [ i ] * temp ; } System . out . println ( \" Case \u2581 # \" + ( cases + 1 ) + \" : \u2581 \" + num ) ; } } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws FileNotFoundException { Scanner s = new Scanner ( new FileInputStream ( \" A - large . in \" ) ) ; int cnt = s . nextInt ( ) ; for ( int cases = 0 ; cases < cnt ; cases ++ ) { String buf = s . next ( ) ; long num = 0 ; int bb = - 1 ; int [ ] ar = new int [ buf . length ( ) ] ; HashMap < String , Integer > set = new HashMap < String , Integer > ( ) ; set . put ( buf . substring ( 0 , 1 ) , 1 ) ; for ( int i = 0 ; i < buf . length ( ) ; i ++ ) { if ( set . containsKey ( buf . substring ( i , i + 1 ) ) ) { ar [ i ] = set . get ( buf . substring ( i , i + 1 ) ) ; } else { bb ++ ; if ( bb == 1 ) { bb = 2 ; } set . put ( buf . substring ( i , i + 1 ) , bb ) ; ar [ i ] = bb ; } } bb ++ ; if ( bb < 2 ) { bb = 2 ; } for ( int i = 0 ; i < buf . length ( ) ; i ++ ) { long temp = 1 ; for ( int j = 0 ; j < buf . length ( ) - i - 1 ; j ++ ) { temp = temp * ( long ) bb ; } num += ( long ) ar [ i ] * temp ; } System . out . println ( \" Case \u2581 # \" + ( cases + 1 ) + \" : \u2581 \" + num ) ; } }"]], "functions_class": []}], "python": [{"id": "10", "code": "import sys NEW_LINE def decode ( s , base ) : NEW_LINE INDENT c2v = { } NEW_LINE res = 0 NEW_LINE next = 1 NEW_LINE for c in s : NEW_LINE INDENT if not c in c2v : NEW_LINE INDENT if len ( c2v ) < base : NEW_LINE INDENT c2v [ c ] = next NEW_LINE if next == 1 : NEW_LINE INDENT next = 0 NEW_LINE DEDENT elif next == 0 : NEW_LINE INDENT next = 2 NEW_LINE DEDENT else : NEW_LINE INDENT next += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return ( False , ) NEW_LINE DEDENT DEDENT dig = c2v [ c ] NEW_LINE res = base * res + dig NEW_LINE DEDENT return ( True , res ) NEW_LINE DEDENT sIn = \" A - large ( 2 ) . in \" ; sOut = \" A - large ( 2 ) . out \" NEW_LINE fIn = open ( sIn , \" r \" ) NEW_LINE fOut = open ( sOut , \" w \" ) NEW_LINE nT = int ( fIn . readline ( ) . strip ( ) ) NEW_LINE for t in xrange ( nT ) : NEW_LINE INDENT inp = fIn . readline ( ) . strip ( ) NEW_LINE mn = - 1 NEW_LINE for base in xrange ( 2 , 100 ) : NEW_LINE INDENT dRes = decode ( inp , base ) NEW_LINE if dRes [ 0 ] : NEW_LINE INDENT if mn == - 1 or mn > dRes [ 1 ] : NEW_LINE INDENT mn = dRes [ 1 ] NEW_LINE DEDENT DEDENT DEDENT print >> fOut , \" Case \u2581 # % d : \u2581 % d \" % ( t + 1 , mn ) NEW_LINE DEDENT", "functions_standalone": [["decode", "def decode ( s , base ) : NEW_LINE INDENT c2v = { } NEW_LINE res = 0 NEW_LINE next = 1 NEW_LINE for c in s : NEW_LINE INDENT if not c in c2v : NEW_LINE INDENT if len ( c2v ) < base : NEW_LINE INDENT c2v [ c ] = next NEW_LINE if next == 1 : NEW_LINE INDENT next = 0 NEW_LINE DEDENT elif next == 0 : NEW_LINE INDENT next = 2 NEW_LINE DEDENT else : NEW_LINE INDENT next += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return ( False , ) NEW_LINE DEDENT DEDENT dig = c2v [ c ] NEW_LINE res = base * res + dig NEW_LINE DEDENT return ( True , res ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "class Gcjt ( object ) : NEW_LINE INDENT class Testcase ( object ) : NEW_LINE INDENT def __init__ ( self , num , gcjt ) : NEW_LINE INDENT self . num = num NEW_LINE self . gcjt = gcjt NEW_LINE DEDENT def answer ( self , answer ) : NEW_LINE INDENT self . gcjt . outs . write ( ' Case \u2581 # { num } : \u2581 { ans } ' . format ( num = self . num , ans = answer ) + ' \\n ' ) NEW_LINE DEDENT def ws ( self , string ) : NEW_LINE INDENT self . gcjt . outs . write ( string ) NEW_LINE DEDENT def rl ( self ) : NEW_LINE INDENT return self . gcjt . ins . readline ( ) NEW_LINE DEDENT def ri ( self ) : NEW_LINE INDENT return ( int ( s ) for s in self . rl ( ) . split ( ) ) NEW_LINE DEDENT DEDENT def __init__ ( self ) : NEW_LINE INDENT filename = input ( ' file \u2581 name \u2581 : \u2581 ' ) NEW_LINE self . fin = filename + ' . in ' NEW_LINE self . fout = filename + ' . out ' NEW_LINE DEDENT def __enter__ ( self ) : NEW_LINE INDENT self . ins = open ( self . fin ) NEW_LINE self . outs = open ( self . fout , ' w ' ) NEW_LINE DEDENT def __exit__ ( self , errtype = None , errvalu = None , errtrace = None ) : NEW_LINE INDENT self . ins . close ( ) NEW_LINE self . outs . close ( ) NEW_LINE DEDENT def tests ( self , num = None ) : NEW_LINE INDENT with self : NEW_LINE INDENT if num is None : num = int ( self . ins . readline ( ) ) NEW_LINE for t in range ( num ) : NEW_LINE INDENT yield self . Testcase ( t + 1 , self ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def array ( * dim ) : NEW_LINE INDENT if len ( dim ) == 1 : return [ None ] * ( dim [ 0 ] ) NEW_LINE else : return [ array ( * dim [ 1 : ] ) for i in range ( dim [ 0 ] ) ] NEW_LINE DEDENT def tests ( ) : NEW_LINE INDENT return Gcjt ( ) . tests ( ) NEW_LINE DEDENT", "functions_standalone": [["array", "def array ( * dim ) : NEW_LINE INDENT if len ( dim ) == 1 : return [ None ] * ( dim [ 0 ] ) NEW_LINE else : return [ array ( * dim [ 1 : ] ) for i in range ( dim [ 0 ] ) ] NEW_LINE DEDENT"], ["tests", "def tests ( ) : NEW_LINE INDENT return Gcjt ( ) . tests ( ) NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self , num , gcjt ) : NEW_LINE INDENT self . num = num NEW_LINE self . gcjt = gcjt NEW_LINE DEDENT"], ["answer", "def answer ( self , answer ) : NEW_LINE INDENT self . gcjt . outs . write ( ' Case \u2581 # { num } : \u2581 { ans } ' . format ( num = self . num , ans = answer ) + ' \\n ' ) NEW_LINE DEDENT"], ["ws", "def ws ( self , string ) : NEW_LINE INDENT self . gcjt . outs . write ( string ) NEW_LINE DEDENT"], ["rl", "def rl ( self ) : NEW_LINE INDENT return self . gcjt . ins . readline ( ) NEW_LINE DEDENT"], ["ri", "def ri ( self ) : NEW_LINE INDENT return ( int ( s ) for s in self . rl ( ) . split ( ) ) NEW_LINE DEDENT"], ["__init__", "def __init__ ( self ) : NEW_LINE INDENT filename = input ( ' file \u2581 name \u2581 : \u2581 ' ) NEW_LINE self . fin = filename + ' . in ' NEW_LINE self . fout = filename + ' . out ' NEW_LINE DEDENT"], ["__enter__", "def __enter__ ( self ) : NEW_LINE INDENT self . ins = open ( self . fin ) NEW_LINE self . outs = open ( self . fout , ' w ' ) NEW_LINE DEDENT"], ["__exit__", "def __exit__ ( self , errtype = None , errvalu = None , errtrace = None ) : NEW_LINE INDENT self . ins . close ( ) NEW_LINE self . outs . close ( ) NEW_LINE DEDENT"], ["tests", "def tests ( self , num = None ) : NEW_LINE INDENT with self : NEW_LINE INDENT if num is None : num = int ( self . ins . readline ( ) ) NEW_LINE for t in range ( num ) : NEW_LINE INDENT yield self . Testcase ( t + 1 , self ) NEW_LINE DEDENT DEDENT DEDENT"]]}, {"id": "5", "code": "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT i = input ( ) NEW_LINE chars = list ( \"1023456789abcdefghijklmnopqrstuvwxyz \" ) NEW_LINE oldnew = { } NEW_LINE s = \" \" NEW_LINE for ch in i : NEW_LINE INDENT if ch not in oldnew : NEW_LINE INDENT oldnew [ ch ] = chars . pop ( 0 ) NEW_LINE DEDENT s += oldnew [ ch ] NEW_LINE DEDENT base = len ( oldnew ) NEW_LINE base = max ( base , 2 ) NEW_LINE ans = int ( s , base ) NEW_LINE print ( \" Case \u2581 # \" + str ( case ) + \" : \u2581 \" + str ( ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "import sys NEW_LINE fin = open ( ' input . txt ' , ' r ' ) NEW_LINE fout = open ( ' output . txt ' , ' w ' ) NEW_LINE l = int ( fin . readline ( ) ) NEW_LINE for case in range ( l ) : NEW_LINE INDENT v = fin . readline ( ) . strip ( ) NEW_LINE alen = len ( set ( list ( v ) ) ) NEW_LINE if alen < 2 : NEW_LINE INDENT alen = 2 NEW_LINE DEDENT val = 0 NEW_LINE mapping = { } NEW_LINE usable = 0 NEW_LINE first = True NEW_LINE for i in v : NEW_LINE INDENT val *= alen NEW_LINE if i not in mapping : NEW_LINE INDENT if first : NEW_LINE INDENT mapping [ i ] = 1 NEW_LINE first = False NEW_LINE DEDENT else : NEW_LINE INDENT if usable == 0 : NEW_LINE INDENT mapping [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mapping [ i ] = usable + 1 NEW_LINE DEDENT usable += 1 NEW_LINE DEDENT DEDENT val += mapping [ i ] NEW_LINE DEDENT fout . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( case + 1 , val ) ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_09_01", "java": [{"id": "9", "code": "package gcj2009 . qual ; import java . io . * ; import java . util . * ; import static java . lang . Math . * ; public class A { static final int INF = 1 << 20 ; static char [ ] [ ] css ; public void run ( ) { char [ ] key = sc . next ( ) . toCharArray ( ) ; boolean [ ] [ ] b = new boolean [ L ] [ 127 ] ; for ( int i = 0 , j = 0 ; i < key . length ; i ++ , j ++ ) if ( key [ i ] == ' ( ' ) while ( key [ ++ i ] != ' ) ' ) b [ j ] [ key [ i ] ] = true ; else b [ j ] [ key [ i ] ] = true ; int ans = 0 ; loop : for ( char [ ] cs : css ) { for ( int i = 0 ; i < L ; i ++ ) if ( ! b [ i ] [ cs [ i ] ] ) continue loop ; ans ++ ; } System . out . println ( ans ) ; } public static void main ( String ... args ) { try { System . setIn ( new FileInputStream ( \" A - large . in \" ) ) ; System . setOut ( new PrintStream ( \" A - large . out \" ) ) ; } catch ( Exception e ) { } sc = new Scanner ( System . in ) ; L = sc . nextInt ( ) ; D = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; css = new char [ D ] [ ] ; for ( int i = 0 ; i < D ; i ++ ) css [ i ] = sc . next ( ) . toCharArray ( ) ; for ( int n = 1 ; n <= N ; n ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n ) ; new A ( ) . run ( ) ; } } static int L , D ; static Scanner sc ; }", "functions_standalone": [["main", "public static void main ( String ... args ) { try { System . setIn ( new FileInputStream ( \" A - large . in \" ) ) ; System . setOut ( new PrintStream ( \" A - large . out \" ) ) ; } catch ( Exception e ) { } sc = new Scanner ( System . in ) ; L = sc . nextInt ( ) ; D = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; css = new char [ D ] [ ] ; for ( int i = 0 ; i < D ; i ++ ) css [ i ] = sc . next ( ) . toCharArray ( ) ; for ( int n = 1 ; n <= N ; n ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n ) ; new A ( ) . run ( ) ; } }"]], "functions_class": [["run", "public void run ( ) { char [ ] key = sc . next ( ) . toCharArray ( ) ; boolean [ ] [ ] b = new boolean [ L ] [ 127 ] ; for ( int i = 0 , j = 0 ; i < key . length ; i ++ , j ++ ) if ( key [ i ] == ' ( ' ) while ( key [ ++ i ] != ' ) ' ) b [ j ] [ key [ i ] ] = true ; else b [ j ] [ key [ i ] ] = true ; int ans = 0 ; loop : for ( char [ ] cs : css ) { for ( int i = 0 ; i < L ; i ++ ) if ( ! b [ i ] [ cs [ i ] ] ) continue loop ; ans ++ ; } System . out . println ( ans ) ; }"]]}, {"id": "20", "code": "package de . measite . gcj ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . util . regex . Pattern ; public class Main1 { public static void main ( String [ ] args ) { try { LineNumberReader lnr = new LineNumberReader ( new InputStreamReader ( System . in ) ) ; String line [ ] = lnr . readLine ( ) . trim ( ) . split ( \" \u2581 \" ) ; final int d = Integer . parseInt ( line [ 1 ] ) ; final int n = Integer . parseInt ( line [ 2 ] ) ; String word [ ] = new String [ d ] ; for ( int i = 0 ; i < d ; i ++ ) { word [ i ] = lnr . readLine ( ) . trim ( ) ; } for ( int i = 1 ; i <= n ; i ++ ) { String m = lnr . readLine ( ) . trim ( ) . replace ( ' ( ' , ' [ ' ) . replace ( ' ) ' , ' ] ' ) ; Pattern pattern = Pattern . compile ( m ) ; int count = 0 ; for ( String w : word ) { if ( pattern . matcher ( w ) . matches ( ) ) { count ++ ; } } System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + count ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { LineNumberReader lnr = new LineNumberReader ( new InputStreamReader ( System . in ) ) ; String line [ ] = lnr . readLine ( ) . trim ( ) . split ( \" \u2581 \" ) ; final int d = Integer . parseInt ( line [ 1 ] ) ; final int n = Integer . parseInt ( line [ 2 ] ) ; String word [ ] = new String [ d ] ; for ( int i = 0 ; i < d ; i ++ ) { word [ i ] = lnr . readLine ( ) . trim ( ) ; } for ( int i = 1 ; i <= n ; i ++ ) { String m = lnr . readLine ( ) . trim ( ) . replace ( ' ( ' , ' [ ' ) . replace ( ' ) ' , ' ] ' ) ; Pattern pattern = Pattern . compile ( m ) ; int count = 0 ; for ( String w : word ) { if ( pattern . matcher ( w ) . matches ( ) ) { count ++ ; } } System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + count ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "3", "code": "import java . io . * ; import java . util . * ; public class Solution { public static BufferedReader cin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; public static StringTokenizer tok = null ; public static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( cin . readLine ( ) ) ; } return tok . nextToken ( ) ; } public static int nextInt ( ) throws NumberFormatException , IOException { return Integer . parseInt ( next ( ) ) ; } public static void main ( String [ ] args ) throws NumberFormatException , IOException { int L = nextInt ( ) ; int D = nextInt ( ) ; int N = nextInt ( ) ; String [ ] dict = new String [ D ] ; for ( int i = 0 ; i < D ; i ++ ) dict [ i ] = cin . readLine ( ) ; for ( int i = 0 ; i < N ; i ++ ) { String pat = cin . readLine ( ) ; TreeSet [ ] st = new TreeSet [ L ] ; for ( int j = 0 ; j < L ; j ++ ) { st [ j ] = new TreeSet ( ) ; } int k = 0 ; for ( int j = 0 ; j < pat . length ( ) ; j ++ ) { if ( pat . charAt ( j ) != ' ( ' ) { st [ k ] . add ( Character . valueOf ( pat . charAt ( j ) ) ) ; k ++ ; } else { j ++ ; while ( pat . charAt ( j ) != ' ) ' ) { st [ k ] . add ( Character . valueOf ( pat . charAt ( j ) ) ) ; j ++ ; } k ++ ; } } int ans = 0 ; for ( int j = 0 ; j < D ; j ++ ) { boolean ok = true ; for ( int t = 0 ; t < L ; t ++ ) { if ( ! st [ t ] . contains ( Character . valueOf ( dict [ j ] . charAt ( t ) ) ) ) { ok = false ; break ; } } if ( ok ) ans ++ ; } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["next", "public static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( cin . readLine ( ) ) ; } return tok . nextToken ( ) ; }"]], "functions_class": [["readLine", "i ++ ) { String pat = cin . readLine ( ) ; TreeSet [ ] st = new TreeSet [ L ] ; for ( int j = 0 ; j < L ; j ++ ) { st [ j ] = new TreeSet ( ) ; } int k = 0 ; for ( int j = 0 ; j < pat . length ( ) ; j ++ ) { if ( pat . charAt ( j ) != ' ( ' ) { st [ k ] . add ( Character . valueOf ( pat . charAt ( j ) ) ) ; k ++ ; } else { j ++ ; while ( pat . charAt ( j ) != ' ) ' ) { st [ k ] . add ( Character . valueOf ( pat . charAt ( j ) ) ) ; j ++ ; } k ++ ; } } int ans = 0 ; for ( int j = 0 ; j < D ; j ++ ) { boolean ok = true ; for ( int t = 0 ; t < L ; t ++ ) { if ( ! st [ t ] . contains ( Character . valueOf ( dict [ j ] . charAt ( t ) ) ) ) { ok = false ; break ; } } if ( ok ) ans ++ ; } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans ) ; }"]]}, {"id": "13", "code": "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public class A { public static void main ( String [ ] args ) throws IOException { BufferedReader buffer = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String entrada = buffer . readLine ( ) ; String ns [ ] = entrada . split ( \" \u2581 \" ) ; int l = Integer . parseInt ( ns [ 0 ] ) ; int d = Integer . parseInt ( ns [ 1 ] ) ; int n = Integer . parseInt ( ns [ 2 ] ) ; String palavras [ ] = new String [ d + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) { palavras [ i ] = buffer . readLine ( ) ; } for ( int k = 1 ; k <= n ; k ++ ) { List < Set < Character > > conjuntosAceitaveis = new ArrayList < Set < Character > > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { conjuntosAceitaveis . add ( new HashSet < Character > ( ) ) ; } String expressao = buffer . readLine ( ) ; int pt = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( expressao . charAt ( pt ) == ' ( ' ) { for ( pt ++ ; expressao . charAt ( pt ) != ' ) ' ; pt ++ ) { conjuntosAceitaveis . get ( i ) . add ( expressao . charAt ( pt ) ) ; } pt ++ ; } else { conjuntosAceitaveis . get ( i ) . add ( expressao . charAt ( pt ) ) ; pt ++ ; } } int cont = 0 ; for ( int i = 0 ; i < d ; i ++ ) { boolean pode = true ; for ( int j = 0 ; j < l ; j ++ ) { if ( ! conjuntosAceitaveis . get ( j ) . contains ( palavras [ i ] . charAt ( j ) ) ) { pode = false ; break ; } } if ( pode ) cont ++ ; } System . out . println ( \" Case \u2581 # \" + k + \" : \u2581 \" + cont ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader buffer = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String entrada = buffer . readLine ( ) ; String ns [ ] = entrada . split ( \" \u2581 \" ) ; int l = Integer . parseInt ( ns [ 0 ] ) ; int d = Integer . parseInt ( ns [ 1 ] ) ; int n = Integer . parseInt ( ns [ 2 ] ) ; String palavras [ ] = new String [ d + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) { palavras [ i ] = buffer . readLine ( ) ; } for ( int k = 1 ; k <= n ; k ++ ) { List < Set < Character > > conjuntosAceitaveis = new ArrayList < Set < Character > > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { conjuntosAceitaveis . add ( new HashSet < Character > ( ) ) ; } String expressao = buffer . readLine ( ) ; int pt = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( expressao . charAt ( pt ) == ' ( ' ) { for ( pt ++ ; expressao . charAt ( pt ) != ' ) ' ; pt ++ ) { conjuntosAceitaveis . get ( i ) . add ( expressao . charAt ( pt ) ) ; } pt ++ ; } else { conjuntosAceitaveis . get ( i ) . add ( expressao . charAt ( pt ) ) ; pt ++ ; } } int cont = 0 ; for ( int i = 0 ; i < d ; i ++ ) { boolean pode = true ; for ( int j = 0 ; j < l ; j ++ ) { if ( ! conjuntosAceitaveis . get ( j ) . contains ( palavras [ i ] . charAt ( j ) ) ) { pode = false ; break ; } } if ( pode ) cont ++ ; } System . out . println ( \" Case \u2581 # \" + k + \" : \u2581 \" + cont ) ; } }"]], "functions_class": []}, {"id": "4", "code": "package gcj2009 . qualification ; import java . io . File ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Scanner ; import java . util . regex . Pattern ; public class A_Alien_Language { private static boolean SMALL = false ; private static String PROBLEM = \" A \" ; public static void main ( String [ ] args ) { try { Scanner scan = new Scanner ( new File ( String . format ( \" % s - % s . in \" , PROBLEM , ( SMALL ? \" small \" : \" large \" ) ) ) ) ; PrintWriter pw = new PrintWriter ( new File ( String . format ( \" % s - % s . out \" , PROBLEM , ( SMALL ? \" small \" : \" large \" ) ) ) ) ; int L = scan . nextInt ( ) , D = scan . nextInt ( ) , N = scan . nextInt ( ) ; scan . nextLine ( ) ; String [ ] dictionary = new String [ D ] ; for ( int i = 0 ; i < D ; ++ i ) dictionary [ i ] = scan . nextLine ( ) ; System . out . println ( String . format ( \" % d \u2581 test \u2581 cases : \" , N ) ) ; long start = System . currentTimeMillis ( ) , t1 , left ; for ( int CASE = 1 ; CASE <= N ; ++ CASE ) { t1 = System . currentTimeMillis ( ) ; System . out . print ( String . format ( \" % d . [ % s ] \u2581 \" , CASE , new SimpleDateFormat ( \" HH : mm : ss . SSS \" ) . format ( new Date ( t1 ) ) ) ) ; String pattern = scan . nextLine ( ) ; pattern = pattern . replace ( ' ( ' , ' [ ' ) . replace ( ' ) ' , ' ] ' ) ; Pattern p = Pattern . compile ( pattern ) ; int cnt = 0 ; for ( int i = 0 ; i < D ; ++ i ) if ( p . matcher ( dictionary [ i ] ) . matches ( ) ) cnt ++ ; String res = String . valueOf ( cnt ) ; pw . println ( String . format ( \" Case \u2581 # % d : \u2581 % s \" , CASE , res ) ) ; left = ( System . currentTimeMillis ( ) - start ) * ( N - CASE ) / CASE ; System . out . println ( String . format ( \" % s \u2581 ( % dms , \u2581 ~ % dms \u2581 left ) \" , res , ( System . currentTimeMillis ( ) - t1 ) , left ) ) ; } pw . close ( ) ; scan . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { Scanner scan = new Scanner ( new File ( String . format ( \" % s - % s . in \" , PROBLEM , ( SMALL ? \" small \" : \" large \" ) ) ) ) ; PrintWriter pw = new PrintWriter ( new File ( String . format ( \" % s - % s . out \" , PROBLEM , ( SMALL ? \" small \" : \" large \" ) ) ) ) ; int L = scan . nextInt ( ) , D = scan . nextInt ( ) , N = scan . nextInt ( ) ; scan . nextLine ( ) ; String [ ] dictionary = new String [ D ] ; for ( int i = 0 ; i < D ; ++ i ) dictionary [ i ] = scan . nextLine ( ) ; System . out . println ( String . format ( \" % d \u2581 test \u2581 cases : \" , N ) ) ; long start = System . currentTimeMillis ( ) , t1 , left ; for ( int CASE = 1 ; CASE <= N ; ++ CASE ) { t1 = System . currentTimeMillis ( ) ; System . out . print ( String . format ( \" % d . [ % s ] \u2581 \" , CASE , new SimpleDateFormat ( \" HH : mm : ss . SSS \" ) . format ( new Date ( t1 ) ) ) ) ; String pattern = scan . nextLine ( ) ; pattern = pattern . replace ( ' ( ' , ' [ ' ) . replace ( ' ) ' , ' ] ' ) ; Pattern p = Pattern . compile ( pattern ) ; int cnt = 0 ; for ( int i = 0 ; i < D ; ++ i ) if ( p . matcher ( dictionary [ i ] ) . matches ( ) ) cnt ++ ; String res = String . valueOf ( cnt ) ; pw . println ( String . format ( \" Case \u2581 # % d : \u2581 % s \" , CASE , res ) ) ; left = ( System . currentTimeMillis ( ) - start ) * ( N - CASE ) / CASE ; System . out . println ( String . format ( \" % s \u2581 ( % dms , \u2581 ~ % dms \u2581 left ) \" , res , ( System . currentTimeMillis ( ) - t1 ) , left ) ) ; } pw . close ( ) ; scan . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}], "python": [{"id": "15", "code": "import re NEW_LINE import sys NEW_LINE r = re . compile ( r ' ( \\ ( [ a - z ] * \\ ) | [ a - z ] ) ' ) NEW_LINE def main ( ) : NEW_LINE INDENT [ l , d , n ] = [ int ( x ) for x in raw_input ( ) . strip ( ) . split ( ) ] NEW_LINE words = [ ] NEW_LINE for _ in range ( d ) : NEW_LINE INDENT words . append ( raw_input ( ) . strip ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT q = raw_input ( ) . strip ( ) NEW_LINE q = [ c for c in r . split ( q ) if c ] NEW_LINE w = words NEW_LINE for qq in q : NEW_LINE INDENT w = [ x [ 1 : ] for x in w if x [ 0 ] in qq ] NEW_LINE DEDENT sys . stdout . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i + 1 , len ( w ) ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["main", "def main ( ) : NEW_LINE INDENT [ l , d , n ] = [ int ( x ) for x in raw_input ( ) . strip ( ) . split ( ) ] NEW_LINE words = [ ] NEW_LINE for _ in range ( d ) : NEW_LINE INDENT words . append ( raw_input ( ) . strip ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT q = raw_input ( ) . strip ( ) NEW_LINE q = [ c for c in r . split ( q ) if c ] NEW_LINE w = words NEW_LINE for qq in q : NEW_LINE INDENT w = [ x [ 1 : ] for x in w if x [ 0 ] in qq ] NEW_LINE DEDENT sys . stdout . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i + 1 , len ( w ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "1", "code": "filepath = ' ' NEW_LINE fileprefix = ' A - large ' NEW_LINE filepathname = filepath + fileprefix NEW_LINE infilename = filepathname + ' . in ' NEW_LINE outfilename = filepathname + ' . out ' NEW_LINE lines = open ( infilename , ' rU ' ) . read ( ) . split ( \" \\n \" ) NEW_LINE outfile = open ( outfilename , ' w + ' ) NEW_LINE linenum = 1 NEW_LINE vars = lines [ 0 ] . split ( ' \u2581 ' ) NEW_LINE cases = int ( vars [ 2 ] ) NEW_LINE l = int ( vars [ 0 ] ) NEW_LINE d = int ( vars [ 1 ] ) NEW_LINE words = lines [ 1 : d + 1 ] NEW_LINE linenum = d + 1 NEW_LINE def explode ( word ) : NEW_LINE INDENT r = [ ] NEW_LINE curset = [ ] NEW_LINE inset = False NEW_LINE for c in word : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT inset = True NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT inset = False NEW_LINE r . append ( curset ) NEW_LINE curset = [ ] NEW_LINE DEDENT elif inset : NEW_LINE INDENT curset . append ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( [ c ] ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def solve ( word ) : NEW_LINE INDENT possible = words [ : ] NEW_LINE exploded = explode ( word ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT nposs = [ ] NEW_LINE for p in possible : NEW_LINE INDENT if p [ i ] in exploded [ i ] : NEW_LINE INDENT nposs . append ( p ) NEW_LINE DEDENT DEDENT possible = nposs NEW_LINE DEDENT return len ( possible ) NEW_LINE DEDENT for casenum in range ( 1 , cases + 1 ) : NEW_LINE INDENT out = solve ( lines [ linenum ] ) NEW_LINE linenum += 1 NEW_LINE casestr = ' Case \u2581 # ' + str ( casenum ) + ' : \u2581 ' + str ( out ) NEW_LINE print ( casestr ) NEW_LINE outfile . write ( casestr + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [["explode", "def explode ( word ) : NEW_LINE INDENT r = [ ] NEW_LINE curset = [ ] NEW_LINE inset = False NEW_LINE for c in word : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT inset = True NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT inset = False NEW_LINE r . append ( curset ) NEW_LINE curset = [ ] NEW_LINE DEDENT elif inset : NEW_LINE INDENT curset . append ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( [ c ] ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT"], ["solve", "def solve ( word ) : NEW_LINE INDENT possible = words [ : ] NEW_LINE exploded = explode ( word ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT nposs = [ ] NEW_LINE for p in possible : NEW_LINE INDENT if p [ i ] in exploded [ i ] : NEW_LINE INDENT nposs . append ( p ) NEW_LINE DEDENT DEDENT possible = nposs NEW_LINE DEDENT return len ( possible ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "from StringIO import StringIO NEW_LINE import re NEW_LINE def process ( f , out = None ) : NEW_LINE INDENT if isinstance ( f , str ) : NEW_LINE INDENT if not out : NEW_LINE INDENT out = open ( f + ' . out . txt ' , ' wb ' ) NEW_LINE DEDENT f = open ( f , ' rb ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if not out : NEW_LINE INDENT out = StringIO ( ) NEW_LINE DEDENT DEDENT l , d , n = map ( int , f . readline ( ) . strip ( ) . split ( ) ) NEW_LINE words = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT words . append ( f . readline ( ) . strip ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT pattern = f . readline ( ) . strip ( ) NEW_LINE pattern = pattern . replace ( ' ( ' , ' [ ' ) . replace ( ' ) ' , ' ] ' ) NEW_LINE expr = re . compile ( ' ^ ' + pattern + ' $ ' ) NEW_LINE count = len ( filter ( lambda x : expr . match ( x ) , words ) ) NEW_LINE out . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( i + 1 , count ) ) NEW_LINE DEDENT if isinstance ( out , StringIO ) : NEW_LINE INDENT return out . getvalue ( ) NEW_LINE DEDENT DEDENT TEST_DATA = ( \"\"\" 3 \u2581 5 \u2581 4 STRNEWLINE abc STRNEWLINE bca STRNEWLINE dac STRNEWLINE dbc STRNEWLINE cba STRNEWLINE ( ab ) ( bc ) ( ca ) STRNEWLINE abc STRNEWLINE ( abc ) ( abc ) ( abc ) STRNEWLINE ( zyx ) bc \"\"\" , \"\"\" Case \u2581 # 1 : \u2581 2 STRNEWLINE Case \u2581 # 2 : \u2581 1 STRNEWLINE Case \u2581 # 3 : \u2581 3 STRNEWLINE Case \u2581 # 4 : \u2581 0 STRNEWLINE \"\"\" ) NEW_LINE def go ( ) : NEW_LINE INDENT assert process ( StringIO ( TEST_DATA [ 0 ] ) ) == TEST_DATA [ 1 ] NEW_LINE for x in [ ' A - large . in . txt ' ] : NEW_LINE INDENT process ( x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT go ( ) NEW_LINE DEDENT", "functions_standalone": [["process", "def process ( f , out = None ) : NEW_LINE INDENT if isinstance ( f , str ) : NEW_LINE INDENT if not out : NEW_LINE INDENT out = open ( f + ' . out . txt ' , ' wb ' ) NEW_LINE DEDENT f = open ( f , ' rb ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if not out : NEW_LINE INDENT out = StringIO ( ) NEW_LINE DEDENT DEDENT l , d , n = map ( int , f . readline ( ) . strip ( ) . split ( ) ) NEW_LINE words = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT words . append ( f . readline ( ) . strip ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT pattern = f . readline ( ) . strip ( ) NEW_LINE pattern = pattern . replace ( ' ( ' , ' [ ' ) . replace ( ' ) ' , ' ] ' ) NEW_LINE expr = re . compile ( ' ^ ' + pattern + ' $ ' ) NEW_LINE count = len ( filter ( lambda x : expr . match ( x ) , words ) ) NEW_LINE out . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( i + 1 , count ) ) NEW_LINE DEDENT if isinstance ( out , StringIO ) : NEW_LINE INDENT return out . getvalue ( ) NEW_LINE DEDENT DEDENT"], ["go", "def go ( ) : NEW_LINE INDENT assert process ( StringIO ( TEST_DATA [ 0 ] ) ) == TEST_DATA [ 1 ] NEW_LINE for x in [ ' A - large . in . txt ' ] : NEW_LINE INDENT process ( x ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "17", "code": "import sys NEW_LINE import re NEW_LINE def solve ( dic , words ) : NEW_LINE INDENT ret = [ ] NEW_LINE for word in words : NEW_LINE INDENT modified = \" \" NEW_LINE paropen = False NEW_LINE for char in word : NEW_LINE INDENT if char == \" ) \" : NEW_LINE INDENT paropen = False NEW_LINE modified = modified [ : - 1 ] + char NEW_LINE DEDENT elif char == \" ( \" : NEW_LINE INDENT paropen = True NEW_LINE modified += char NEW_LINE DEDENT else : NEW_LINE INDENT if paropen : NEW_LINE INDENT modified += char + \" | \" NEW_LINE DEDENT else : NEW_LINE INDENT modified += char NEW_LINE DEDENT DEDENT DEDENT word = modified NEW_LINE pattern = re . compile ( word ) NEW_LINE cnt = 0 NEW_LINE for dic_word in dic : NEW_LINE INDENT if pattern . match ( dic_word ) is not None : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ret . append ( cnt ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT infile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE outfile = open ( \" resultA . txt \" , \" w \" ) NEW_LINE input = [ int ( item ) for item in infile . readline ( ) . strip ( ) . split ( \" \u2581 \" ) if item != \" \" ] NEW_LINE L , D , N = input [ 0 ] , input [ 1 ] , input [ 2 ] NEW_LINE dic = [ ] NEW_LINE for i in range ( D ) : NEW_LINE INDENT dic . append ( infile . readline ( ) . strip ( ) ) NEW_LINE DEDENT words = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT words . append ( infile . readline ( ) . strip ( ) ) NEW_LINE DEDENT solution = solve ( dic , words ) NEW_LINE for i in range ( len ( solution ) ) : NEW_LINE INDENT outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i + 1 , solution [ i ] ) ) NEW_LINE DEDENT infile . close ( ) NEW_LINE outfile . close ( ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( dic , words ) : NEW_LINE INDENT ret = [ ] NEW_LINE for word in words : NEW_LINE INDENT modified = \" \" NEW_LINE paropen = False NEW_LINE for char in word : NEW_LINE INDENT if char == \" ) \" : NEW_LINE INDENT paropen = False NEW_LINE modified = modified [ : - 1 ] + char NEW_LINE DEDENT elif char == \" ( \" : NEW_LINE INDENT paropen = True NEW_LINE modified += char NEW_LINE DEDENT else : NEW_LINE INDENT if paropen : NEW_LINE INDENT modified += char + \" | \" NEW_LINE DEDENT else : NEW_LINE INDENT modified += char NEW_LINE DEDENT DEDENT DEDENT word = modified NEW_LINE pattern = re . compile ( word ) NEW_LINE cnt = 0 NEW_LINE for dic_word in dic : NEW_LINE INDENT if pattern . match ( dic_word ) is not None : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ret . append ( cnt ) NEW_LINE DEDENT return ret NEW_LINE DEDENT"]], "functions_class": []}, {"id": "11", "code": "from sys import stdin , stdout , stderr NEW_LINE def solve_case ( case ) : NEW_LINE INDENT L , D , N , words , pattern = case NEW_LINE words = set ( words ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( pattern ) : NEW_LINE INDENT if pattern [ i ] == \" ( \" : NEW_LINE INDENT end = pattern . find ( \" ) \" , i ) NEW_LINE options = pattern [ i + 1 : end ] NEW_LINE i = end + 1 NEW_LINE DEDENT else : NEW_LINE INDENT options = pattern [ i ] NEW_LINE i += 1 NEW_LINE DEDENT remove = set ( ) NEW_LINE for word in words : NEW_LINE INDENT if word [ j ] not in options : NEW_LINE INDENT remove . add ( word ) NEW_LINE DEDENT DEDENT for word in remove : NEW_LINE INDENT words . remove ( word ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return len ( words ) NEW_LINE DEDENT def print_case ( i , ans ) : NEW_LINE INDENT s = \" Case \u2581 # % d : \u2581 % s \" % ( i , ans ) NEW_LINE print ( s ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT L , D , N = map ( int , input ( ) . split ( ) ) NEW_LINE words = [ input ( ) for i in range ( D ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT pattern = input ( ) NEW_LINE print_case ( i , solve_case ( ( L , D , N , words , pattern ) ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["solve_case", "def solve_case ( case ) : NEW_LINE INDENT L , D , N , words , pattern = case NEW_LINE words = set ( words ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( pattern ) : NEW_LINE INDENT if pattern [ i ] == \" ( \" : NEW_LINE INDENT end = pattern . find ( \" ) \" , i ) NEW_LINE options = pattern [ i + 1 : end ] NEW_LINE i = end + 1 NEW_LINE DEDENT else : NEW_LINE INDENT options = pattern [ i ] NEW_LINE i += 1 NEW_LINE DEDENT remove = set ( ) NEW_LINE for word in words : NEW_LINE INDENT if word [ j ] not in options : NEW_LINE INDENT remove . add ( word ) NEW_LINE DEDENT DEDENT for word in remove : NEW_LINE INDENT words . remove ( word ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return len ( words ) NEW_LINE DEDENT"], ["print_case", "def print_case ( i , ans ) : NEW_LINE INDENT s = \" Case \u2581 # % d : \u2581 % s \" % ( i , ans ) NEW_LINE print ( s ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT L , D , N = map ( int , input ( ) . split ( ) ) NEW_LINE words = [ input ( ) for i in range ( D ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT pattern = input ( ) NEW_LINE print_case ( i , solve_case ( ( L , D , N , words , pattern ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_09_41", "java": [{"id": "9", "code": "import java . util . * ; import java . io . * ; public class Main implements Runnable { public Scanner in ; public PrintWriter out ; Main ( ) throws IOException { in = new Scanner ( new File ( \" in \" ) ) ; out = new PrintWriter ( new File ( \" out \" ) ) ; } void close ( ) throws IOException { out . close ( ) ; } public void run ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; a [ i ] = s . lastIndexOf ( \"1\" ) ; } int r = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int j = i ; while ( a [ j ] > i ) { j ++ ; } r += j - i ; int t = a [ j ] ; while ( j > i ) { a [ j ] = a [ j - 1 ] ; j -- ; } a [ i ] = t ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r ) ; } try { close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; }"]], "functions_class": [["Main", "Main ( ) throws IOException { in = new Scanner ( new File ( \" in \" ) ) ; out = new PrintWriter ( new File ( \" out \" ) ) ; }"], ["close", "void close ( ) throws IOException { out . close ( ) ; }"], ["run", "public void run ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; a [ i ] = s . lastIndexOf ( \"1\" ) ; } int r = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int j = i ; while ( a [ j ] > i ) { j ++ ; } r += j - i ; int t = a [ j ] ; while ( j > i ) { a [ j ] = a [ j - 1 ] ; j -- ; } a [ i ] = t ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r ) ; } try { close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]]}, {"id": "12", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . PrintWriter ; public class A implements Runnable { public static void main ( String [ ] args ) { new Thread ( new A ( ) ) . start ( ) ; } public void run ( ) { try { solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void solve ( ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" a . in \" ) ) ; PrintWriter pw = new PrintWriter ( \" a . out \" ) ; int tests = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int n = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; String [ ] s = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = br . readLine ( ) . trim ( ) ; } int result = 0 ; for ( int row = 0 ; row < n ; row ++ ) { for ( int i = row ; i < n ; i ++ ) { boolean can = true ; for ( int k = row + 1 ; k < n ; k ++ ) { if ( s [ i ] . charAt ( k ) == '1' ) { can = false ; break ; } } if ( can ) { for ( int k = i - 1 ; k >= row ; k -- ) { String str = s [ k + 1 ] ; s [ k + 1 ] = s [ k ] ; s [ k ] = str ; result ++ ; } break ; } } } pw . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + result ) ; } br . close ( ) ; pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Thread ( new A ( ) ) . start ( ) ; }"]], "functions_class": [["run", "public void run ( ) { try { solve ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"], ["solve", "private void solve ( ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" a . in \" ) ) ; PrintWriter pw = new PrintWriter ( \" a . out \" ) ; int tests = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int n = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; String [ ] s = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = br . readLine ( ) . trim ( ) ; } int result = 0 ; for ( int row = 0 ; row < n ; row ++ ) { for ( int i = row ; i < n ; i ++ ) { boolean can = true ; for ( int k = row + 1 ; k < n ; k ++ ) { if ( s [ i ] . charAt ( k ) == '1' ) { can = false ; break ; } } if ( can ) { for ( int k = i - 1 ; k >= row ; k -- ) { String str = s [ k + 1 ] ; s [ k + 1 ] = s [ k ] ; s [ k ] = str ; result ++ ; } break ; } } } pw . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + result ) ; } br . close ( ) ; pw . close ( ) ; }"]]}, {"id": "13", "code": "import java . io . BufferedReader ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintStream ; public class A { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" A - large . out \" ) ) ; int cases = Integer . parseInt ( br . readLine ( ) ) ; for ( int itr = 1 ; itr <= cases ; itr ++ ) { int size = Integer . parseInt ( br . readLine ( ) ) ; int [ ] board = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { String s = br . readLine ( ) ; for ( int j = 0 ; j < size ; j ++ ) if ( s . charAt ( j ) == '1' ) board [ i ] = j ; } int out = 0 ; boolean done = false ; while ( ! done ) { done = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( board [ i ] > i ) { done = false ; int s = 0 ; for ( int j = i + 1 ; j < size ; j ++ ) if ( board [ j ] <= i ) { s = j ; break ; } for ( int j = s ; j > i ; j -- ) { int t = board [ j ] ; board [ j ] = board [ j - 1 ] ; board [ j - 1 ] = t ; out ++ ; } } } } ps . println ( \" Case \u2581 # \" + itr + \" : \u2581 \" + out ) ; } br . close ( ) ; ps . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( \" A - large . out \" ) ) ; int cases = Integer . parseInt ( br . readLine ( ) ) ; for ( int itr = 1 ; itr <= cases ; itr ++ ) { int size = Integer . parseInt ( br . readLine ( ) ) ; int [ ] board = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { String s = br . readLine ( ) ; for ( int j = 0 ; j < size ; j ++ ) if ( s . charAt ( j ) == '1' ) board [ i ] = j ; } int out = 0 ; boolean done = false ; while ( ! done ) { done = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( board [ i ] > i ) { done = false ; int s = 0 ; for ( int j = i + 1 ; j < size ; j ++ ) if ( board [ j ] <= i ) { s = j ; break ; } for ( int j = s ; j > i ; j -- ) { int t = board [ j ] ; board [ j ] = board [ j - 1 ] ; board [ j - 1 ] = t ; out ++ ; } } } } ps . println ( \" Case \u2581 # \" + itr + \" : \u2581 \" + out ) ; } br . close ( ) ; ps . close ( ) ; }"]], "functions_class": []}, {"id": "15", "code": "import java . io . * ; import java . util . * ; public class A implements Runnable { private static String fileName = A . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; private static Scanner in ; private static PrintWriter out ; private void solve ( ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) == '1' ) { a [ i ] = j ; } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i ; ; j ++ ) { if ( a [ j ] <= i ) break ; } for ( int k = j ; k > i ; k -- ) { ans ++ ; int t = a [ k ] ; a [ k ] = a [ k - 1 ] ; a [ k - 1 ] = t ; } } out . println ( ans ) ; } public void run ( ) { int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; solve ( ) ; } } public static void main ( String [ ] args ) throws IOException , InterruptedException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; Thread thread = new Thread ( new A ( ) ) ; thread . start ( ) ; thread . join ( ) ; in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [], "functions_class": [["solve", "private void solve ( ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) == '1' ) { a [ i ] = j ; } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i ; ; j ++ ) { if ( a [ j ] <= i ) break ; } for ( int k = j ; k > i ; k -- ) { ans ++ ; int t = a [ k ] ; a [ k ] = a [ k - 1 ] ; a [ k - 1 ] = t ; } } out . println ( ans ) ; }"], ["run", "public void run ( ) { int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; solve ( ) ; } }"], ["if", "if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; }"]]}, {"id": "4", "code": "import java . util . Scanner ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileNotFoundException ; public class A { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( \" A . out \" ) ; int t = in . nextInt ( ) ; in . nextLine ( ) ; for ( int tn = 0 ; tn < t ; tn ++ ) { out . println ( \" Case \u2581 # \" + ( tn + 1 ) + \" : \u2581 \" + solve ( in ) ) ; } out . close ( ) ; } private static String solve ( Scanner in ) { int n = in . nextInt ( ) ; in . nextLine ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . nextLine ( ) ; int j = n - 1 ; while ( s . charAt ( j ) == '0' && j > 0 ) j -- ; a [ i ] = j ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i ; while ( a [ j ] > i ) j ++ ; int t = a [ j ] ; for ( int k = j ; k > i ; k -- ) a [ k ] = a [ k - 1 ] ; a [ i ] = t ; res += ( j - i ) ; } return \" \" + res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( \" A . out \" ) ; int t = in . nextInt ( ) ; in . nextLine ( ) ; for ( int tn = 0 ; tn < t ; tn ++ ) { out . println ( \" Case \u2581 # \" + ( tn + 1 ) + \" : \u2581 \" + solve ( in ) ) ; } out . close ( ) ; }"], ["solve", "private static String solve ( Scanner in ) { int n = in . nextInt ( ) ; in . nextLine ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . nextLine ( ) ; int j = n - 1 ; while ( s . charAt ( j ) == '0' && j > 0 ) j -- ; a [ i ] = j ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i ; while ( a [ j ] > i ) j ++ ; int t = a [ j ] ; for ( int k = j ; k > i ; k -- ) a [ k ] = a [ k - 1 ] ; a [ i ] = t ; res += ( j - i ) ; } return \" \" + res ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "import sys NEW_LINE def max1 ( r ) : NEW_LINE INDENT z = [ i for i in range ( len ( r ) ) if r [ i ] == 1 ] NEW_LINE if ( z == [ ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( z ) NEW_LINE DEDENT DEDENT def solve ( inp ) : NEW_LINE INDENT inp = [ max1 ( s ) for s in inp ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( inp ) ) : NEW_LINE INDENT z = min ( [ q for q in range ( len ( inp ) ) if q >= i and inp [ q ] <= i ] ) NEW_LINE r = list ( range ( i , z ) ) NEW_LINE r . reverse ( ) NEW_LINE for j in r : NEW_LINE INDENT inp [ j ] , inp [ j + 1 ] = inp [ j + 1 ] , inp [ j ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT rdln = sys . stdin . readline NEW_LINE T = int ( rdln ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N = int ( rdln ( ) ) NEW_LINE print ( \" Case \u2581 # \" , t + 1 , \" : \u2581 \" , solve ( [ [ int ( c ) for c in rdln ( ) . strip ( ) ] for w in range ( N ) ] ) , sep = \" \" ) NEW_LINE DEDENT", "functions_standalone": [["max1", "def max1 ( r ) : NEW_LINE INDENT z = [ i for i in range ( len ( r ) ) if r [ i ] == 1 ] NEW_LINE if ( z == [ ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( z ) NEW_LINE DEDENT DEDENT"], ["solve", "def solve ( inp ) : NEW_LINE INDENT inp = [ max1 ( s ) for s in inp ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( inp ) ) : NEW_LINE INDENT z = min ( [ q for q in range ( len ( inp ) ) if q >= i and inp [ q ] <= i ] ) NEW_LINE r = list ( range ( i , z ) ) NEW_LINE r . reverse ( ) NEW_LINE for j in r : NEW_LINE INDENT inp [ j ] , inp [ j + 1 ] = inp [ j + 1 ] , inp [ j ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"]], "functions_class": []}, {"id": "8", "code": "def make_swaps ( matrix , i , j ) : NEW_LINE INDENT moves = 0 NEW_LINE while j > i : NEW_LINE INDENT matrix [ j ] , matrix [ j - 1 ] = matrix [ j - 1 ] , matrix [ j ] NEW_LINE j -= 1 NEW_LINE moves += 1 NEW_LINE DEDENT return moves NEW_LINE DEDENT def last_one ( row ) : NEW_LINE INDENT positions = [ pos for pos , num in enumerate ( row ) if num == '1' ] NEW_LINE return 0 if len ( positions ) == 0 else max ( positions ) NEW_LINE DEDENT def solve ( matrix ) : NEW_LINE INDENT moves = 0 NEW_LINE N = len ( matrix ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT if last_one ( matrix [ j ] ) <= i : NEW_LINE INDENT moves += make_swaps ( matrix , i , j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return moves NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT file = open ( \" input . in \" ) NEW_LINE tests = int ( file . readline ( ) ) NEW_LINE for case in range ( 1 , tests + 1 ) : NEW_LINE INDENT N = int ( file . readline ( ) ) NEW_LINE matrix = [ file . readline ( ) . strip ( ) for i in range ( N ) ] NEW_LINE print ( \" Case \u2581 # \" , case , \" : \u2581 \" , solve ( matrix ) , sep = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["make_swaps", "def make_swaps ( matrix , i , j ) : NEW_LINE INDENT moves = 0 NEW_LINE while j > i : NEW_LINE INDENT matrix [ j ] , matrix [ j - 1 ] = matrix [ j - 1 ] , matrix [ j ] NEW_LINE j -= 1 NEW_LINE moves += 1 NEW_LINE DEDENT return moves NEW_LINE DEDENT"], ["last_one", "def last_one ( row ) : NEW_LINE INDENT positions = [ pos for pos , num in enumerate ( row ) if num == '1' ] NEW_LINE return 0 if len ( positions ) == 0 else max ( positions ) NEW_LINE DEDENT"], ["solve", "def solve ( matrix ) : NEW_LINE INDENT moves = 0 NEW_LINE N = len ( matrix ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT if last_one ( matrix [ j ] ) <= i : NEW_LINE INDENT moves += make_swaps ( matrix , i , j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return moves NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT file = open ( \" input . in \" ) NEW_LINE tests = int ( file . readline ( ) ) NEW_LINE for case in range ( 1 , tests + 1 ) : NEW_LINE INDENT N = int ( file . readline ( ) ) NEW_LINE matrix = [ file . readline ( ) . strip ( ) for i in range ( N ) ] NEW_LINE print ( \" Case \u2581 # \" , case , \" : \u2581 \" , solve ( matrix ) , sep = \" \" ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "3", "code": "def Swap ( arr , i ) : NEW_LINE INDENT arr [ i - 1 ] , arr [ i ] = arr [ i ] , arr [ i - 1 ] NEW_LINE DEDENT for tc in range ( 1 , int ( input ( ) ) + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE nums = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE nums . append ( s . rfind ( \"1\" ) + 1 ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT upperBound = i + 1 NEW_LINE if nums [ i ] > upperBound : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if nums [ j ] <= upperBound : NEW_LINE INDENT for k in range ( j , i , - 1 ) : NEW_LINE INDENT Swap ( nums , k ) NEW_LINE ans += 1 NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( tc , ans ) ) NEW_LINE DEDENT", "functions_standalone": [["Swap", "def Swap ( arr , i ) : NEW_LINE INDENT arr [ i - 1 ] , arr [ i ] = arr [ i ] , arr [ i - 1 ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "name = ' A ' NEW_LINE typ = ' large ' NEW_LINE base = name + ' - ' + typ + ' . ' NEW_LINE lines = file ( base + ' in ' ) . readlines ( ) NEW_LINE lines = [ line . replace ( ' \\n ' , ' ' ) for line in lines ] NEW_LINE T = int ( lines [ 0 ] ) NEW_LINE fpos = 1 NEW_LINE def swap ( data , a , b ) : NEW_LINE INDENT temp = data [ a ] NEW_LINE data [ a ] = data [ b ] NEW_LINE data [ b ] = temp NEW_LINE DEDENT def solve ( data ) : NEW_LINE INDENT steps = 0 NEW_LINE for i in xrange ( len ( data ) ) : NEW_LINE INDENT if data [ i ] > i : NEW_LINE INDENT j = i + 1 NEW_LINE while data [ j ] > i : NEW_LINE INDENT j += 1 NEW_LINE DEDENT steps += j - i NEW_LINE for j in xrange ( j , i , - 1 ) : NEW_LINE INDENT swap ( data , j , j - 1 ) NEW_LINE DEDENT DEDENT DEDENT return steps NEW_LINE DEDENT out = file ( base + ' out ' , ' wb ' ) NEW_LINE for case in xrange ( 1 , T + 1 ) : NEW_LINE INDENT size = int ( lines [ fpos ] ) NEW_LINE fpos += 1 NEW_LINE data = [ line . rfind ( '1' ) for line in lines [ fpos : fpos + size ] ] NEW_LINE fpos += size NEW_LINE out . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( case , solve ( data ) ) ) NEW_LINE DEDENT out . close ( ) NEW_LINE", "functions_standalone": [["swap", "def swap ( data , a , b ) : NEW_LINE INDENT temp = data [ a ] NEW_LINE data [ a ] = data [ b ] NEW_LINE data [ b ] = temp NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_09_13", "java": [{"id": "9", "code": "import java . util . * ; import static java . lang . Math . * ; public class C { void p ( String s ) { System . out . println ( s ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { C = sc . nextInt ( ) ; N = sc . nextInt ( ) ; dp = new double [ C + 1 ] ; Arrays . fill ( dp , - 1.0 ) ; System . out . println ( \" Case \u2581 # \" + zz + \" : \u2581 \" + dp ( 0 ) ) ; } } static int C , N ; static double [ ] dp ; public static double dp ( int numDiff ) { if ( numDiff >= C ) return 0.0 ; if ( dp [ numDiff ] != - 1.0 ) return dp [ numDiff ] ; double pr0 = ( ( double ) choose ( numDiff , N ) ) / choose ( C , N ) ; double ev = 0.0 ; for ( int i = 1 ; i <= N ; i ++ ) { ev += ( 1.0 + dp ( numDiff + i ) ) * ( ( ( double ) choose ( numDiff , N - i ) * choose ( C - numDiff , i ) ) ) / ( choose ( C , N ) ) ; } double ans = ( pr0 + ev ) / ( 1 - pr0 ) ; dp [ numDiff ] = ans ; return ans ; } public static long choose ( int n , int k ) { long ans = 1 ; ArrayList < Integer > toDiv = new ArrayList < Integer > ( ) ; for ( int i = 2 ; i <= k ; i ++ ) toDiv . add ( i ) ; for ( int i = n ; i >= n - k + 1 ; i -- ) { ans *= i ; for ( int j = 0 ; j < toDiv . size ( ) ; j ++ ) { if ( ans % toDiv . get ( j ) == 0 ) { ans /= toDiv . get ( j ) ; toDiv . remove ( j ) ; j -- ; } } } return ans ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { C = sc . nextInt ( ) ; N = sc . nextInt ( ) ; dp = new double [ C + 1 ] ; Arrays . fill ( dp , - 1.0 ) ; System . out . println ( \" Case \u2581 # \" + zz + \" : \u2581 \" + dp ( 0 ) ) ; } }"], ["dp", "public static double dp ( int numDiff ) { if ( numDiff >= C ) return 0.0 ; if ( dp [ numDiff ] != - 1.0 ) return dp [ numDiff ] ; double pr0 = ( ( double ) choose ( numDiff , N ) ) / choose ( C , N ) ; double ev = 0.0 ; for ( int i = 1 ; i <= N ; i ++ ) { ev += ( 1.0 + dp ( numDiff + i ) ) * ( ( ( double ) choose ( numDiff , N - i ) * choose ( C - numDiff , i ) ) ) / ( choose ( C , N ) ) ; } double ans = ( pr0 + ev ) / ( 1 - pr0 ) ; dp [ numDiff ] = ans ; return ans ; }"], ["choose", "public static long choose ( int n , int k ) { long ans = 1 ; ArrayList < Integer > toDiv = new ArrayList < Integer > ( ) ; for ( int i = 2 ; i <= k ; i ++ ) toDiv . add ( i ) ; for ( int i = n ; i >= n - k + 1 ; i -- ) { ans *= i ; for ( int j = 0 ; j < toDiv . size ( ) ; j ++ ) { if ( ans % toDiv . get ( j ) == 0 ) { ans /= toDiv . get ( j ) ; toDiv . remove ( j ) ; j -- ; } } } return ans ; }"]], "functions_class": [["p", "void p ( String s ) { System . out . println ( s ) ; }"]]}, {"id": "5", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class x { public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; long [ ] [ ] C = new long [ 41 ] [ 41 ] ; for ( int i = 0 ; i <= 40 ; i ++ ) { C [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) C [ i ] [ j ] = C [ i - 1 ] [ j ] + C [ i - 1 ] [ j - 1 ] ; } MathContext mc = new MathContext ( 50 , RoundingMode . HALF_EVEN ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { int A = in . nextInt ( ) , N = in . nextInt ( ) ; BigDecimal [ ] E = new BigDecimal [ A + 1 ] ; E [ A ] = new BigDecimal ( 0 , mc ) ; for ( int i = A - 1 ; i >= 0 ; i -- ) { E [ i ] = new BigDecimal ( C [ A ] [ N ] , mc ) ; for ( int j = i + 1 ; j <= Math . min ( A , i + N ) ; j ++ ) { BigDecimal P = new BigDecimal ( C [ A - i ] [ j - i ] , mc ) ; P = P . multiply ( new BigDecimal ( C [ i ] [ N - j + i ] , mc ) , mc ) ; E [ i ] = E [ i ] . add ( P . multiply ( E [ j ] , mc ) , mc ) ; } BigDecimal D = new BigDecimal ( C [ A ] [ N ] , mc ) . subtract ( new BigDecimal ( C [ i ] [ N ] , mc ) , mc ) ; E [ i ] = E [ i ] . divide ( D , mc ) ; } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + E [ 0 ] ) ; } ; } ; } ;", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; long [ ] [ ] C = new long [ 41 ] [ 41 ] ; for ( int i = 0 ; i <= 40 ; i ++ ) { C [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) C [ i ] [ j ] = C [ i - 1 ] [ j ] + C [ i - 1 ] [ j - 1 ] ; } MathContext mc = new MathContext ( 50 , RoundingMode . HALF_EVEN ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { int A = in . nextInt ( ) , N = in . nextInt ( ) ; BigDecimal [ ] E = new BigDecimal [ A + 1 ] ; E [ A ] = new BigDecimal ( 0 , mc ) ; for ( int i = A - 1 ; i >= 0 ; i -- ) { E [ i ] = new BigDecimal ( C [ A ] [ N ] , mc ) ; for ( int j = i + 1 ; j <= Math . min ( A , i + N ) ; j ++ ) { BigDecimal P = new BigDecimal ( C [ A - i ] [ j - i ] , mc ) ; P = P . multiply ( new BigDecimal ( C [ i ] [ N - j + i ] , mc ) , mc ) ; E [ i ] = E [ i ] . add ( P . multiply ( E [ j ] , mc ) , mc ) ; } BigDecimal D = new BigDecimal ( C [ A ] [ N ] , mc ) . subtract ( new BigDecimal ( C [ i ] [ N ] , mc ) , mc ) ; E [ i ] = E [ i ] . divide ( D , mc ) ; } System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + E [ 0 ] ) ; } ; }"]], "functions_class": []}, {"id": "13", "code": "import java . util . Arrays ; import java . util . Scanner ; public class C { public static void main ( String [ ] args ) throws Exception { new C ( ) ; } final int oo = ( int ) 1e9 ; double [ ] [ ] choose = new double [ 50 ] [ 50 ] ; int N , C ; double D ; double [ ] memo = new double [ 50 ] ; C ( ) throws Exception { for ( double [ ] c : choose ) Arrays . fill ( c , - 1 ) ; Scanner in = new Scanner ( System . in ) ; for ( int T = in . nextInt ( ) , ds = 1 ; T -- > 0 ; ++ ds ) { C = in . nextInt ( ) ; N = in . nextInt ( ) ; D = choose ( C , N ) ; Arrays . fill ( memo , - 1 ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .9f % n \" , ds , go ( 0 ) ) ; } } double go ( int X ) { if ( X == C ) return 0 ; if ( memo [ X ] > - 0.5 ) return memo [ X ] ; double exp = 1 ; for ( int i = 1 ; i <= N ; ++ i ) { if ( X + i > C ) break ; exp += choose ( X , N - i ) * choose ( C - X , i ) / D * go ( X + i ) ; } exp /= ( 1 - choose ( X , N ) * choose ( C - X , 0 ) / D ) ; return memo [ X ] = exp ; } double choose ( int n , int k ) { if ( k == 0 || n == k ) return 1 ; if ( n < k ) return 0 ; if ( choose [ n ] [ k ] > - 0.5 ) return choose [ n ] [ k ] ; return choose [ n ] [ k ] = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new C ( ) ; }"]], "functions_class": [["C", "C ( ) throws Exception { for ( double [ ] c : choose ) Arrays . fill ( c , - 1 ) ; Scanner in = new Scanner ( System . in ) ; for ( int T = in . nextInt ( ) , ds = 1 ; T -- > 0 ; ++ ds ) { C = in . nextInt ( ) ; N = in . nextInt ( ) ; D = choose ( C , N ) ; Arrays . fill ( memo , - 1 ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .9f % n \" , ds , go ( 0 ) ) ; } }"], ["go", "double go ( int X ) { if ( X == C ) return 0 ; if ( memo [ X ] > - 0.5 ) return memo [ X ] ; double exp = 1 ; for ( int i = 1 ; i <= N ; ++ i ) { if ( X + i > C ) break ; exp += choose ( X , N - i ) * choose ( C - X , i ) / D * go ( X + i ) ; } exp /= ( 1 - choose ( X , N ) * choose ( C - X , 0 ) / D ) ; return memo [ X ] = exp ; }"], ["choose", "double choose ( int n , int k ) { if ( k == 0 || n == k ) return 1 ; if ( n < k ) return 0 ; if ( choose [ n ] [ k ] > - 0.5 ) return choose [ n ] [ k ] ; return choose [ n ] [ k ] = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) ; }"]]}, {"id": "17", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . PrintStream ; import java . util . Scanner ; public class C { private static String PNAME = \" C - large \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( PNAME + \" . in \" ) ) ; PrintStream out = new PrintStream ( PNAME + \" . out \" ) ; Scanner in = new Scanner ( br ) ; int TC = in . nextInt ( ) ; for ( int tc = 1 ; tc <= TC ; tc ++ ) { int c = in . nextInt ( ) ; int n = in . nextInt ( ) ; out . println ( \" Case \u2581 # \" + tc + \" : \u2581 \" + solve ( c , n ) ) ; } br . close ( ) ; out . close ( ) ; } private static double solve ( int c , int n ) { for ( int i = 0 ; i < memo . length ; i ++ ) memo [ i ] = - 1 ; return calc ( c , n , c ) ; } private static double calc ( int c , int n , int need ) { if ( need == 0 ) return 0 ; if ( memo [ need ] != - 1 ) return memo [ need ] ; double ret = 1 ; int have = c - need ; for ( int good = 1 ; good <= Math . min ( n , need ) ; good ++ ) { int bad = n - good ; double p = choose ( need , good ) ; p *= choose ( have , bad ) ; p /= choose ( c , n ) ; ret += p * calc ( c , n , need - good ) ; } if ( have >= n ) { double p = choose ( have , n ) * 1.0 / choose ( c , n ) ; ret /= 1 - p ; } memo [ need ] = ret ; return ret ; } private static long choose ( int n , int k ) { long ret = 1 ; for ( int i = 0 ; i < k ; i ++ ) { ret *= n - i ; ret /= i + 1 ; } return ret ; } static double [ ] memo = new double [ 64 ] ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( PNAME + \" . in \" ) ) ; PrintStream out = new PrintStream ( PNAME + \" . out \" ) ; Scanner in = new Scanner ( br ) ; int TC = in . nextInt ( ) ; for ( int tc = 1 ; tc <= TC ; tc ++ ) { int c = in . nextInt ( ) ; int n = in . nextInt ( ) ; out . println ( \" Case \u2581 # \" + tc + \" : \u2581 \" + solve ( c , n ) ) ; } br . close ( ) ; out . close ( ) ; }"], ["solve", "private static double solve ( int c , int n ) { for ( int i = 0 ; i < memo . length ; i ++ ) memo [ i ] = - 1 ; return calc ( c , n , c ) ; }"], ["calc", "private static double calc ( int c , int n , int need ) { if ( need == 0 ) return 0 ; if ( memo [ need ] != - 1 ) return memo [ need ] ; double ret = 1 ; int have = c - need ; for ( int good = 1 ; good <= Math . min ( n , need ) ; good ++ ) { int bad = n - good ; double p = choose ( need , good ) ; p *= choose ( have , bad ) ; p /= choose ( c , n ) ; ret += p * calc ( c , n , need - good ) ; } if ( have >= n ) { double p = choose ( have , n ) * 1.0 / choose ( c , n ) ; ret /= 1 - p ; } memo [ need ] = ret ; return ret ; }"], ["choose", "private static long choose ( int n , int k ) { long ret = 1 ; for ( int i = 0 ; i < k ; i ++ ) { ret *= n - i ; ret /= i + 1 ; } return ret ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "import sys , os NEW_LINE in_file = None NEW_LINE out_file = None NEW_LINE def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in xrange ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in xrange ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT", "functions_standalone": [["run_main", "def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT"], ["readline", "def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT"], ["writeline", "def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT"], ["readinteger", "def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_09_22", "java": [{"id": "9", "code": "import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class Number { private static boolean run ( final char [ ] s , final int [ ] d1 , final int [ ] d , final int k ) { if ( k == s . length ) { for ( int i = 1 ; i < 10 ; ++ i ) { if ( d1 [ i ] != d [ i ] ) { return false ; } } return true ; } while ( true ) { char c = s [ k ] ; if ( c > '9' ) { s [ k ] = '0' ; return false ; } int x = c - '0' ; if ( d1 [ x ] < d [ x ] ) { ++ d1 [ x ] ; if ( run ( s , d1 , d , k + 1 ) ) { return true ; } -- d1 [ x ] ; } ++ s [ k ] ; } } public static void main ( final String ... args ) throws IOException { final String fname = \" B - large \" ; final Scanner sc = new Scanner ( new File ( fname + \" . in \" ) ) ; final PrintWriter pw = new PrintWriter ( fname + \" . out \" ) ; final int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 0 ; i < t ; ++ i ) { final char [ ] s = ( '0' + sc . nextLine ( ) ) . toCharArray ( ) ; final int [ ] d = new int [ 10 ] ; for ( char c : s ) { d [ c - '0' ] ++ ; } ++ s [ s . length - 1 ] ; final int [ ] d1 = new int [ 10 ] ; if ( ! run ( s , d1 , d , 0 ) ) { throw new RuntimeException ( ) ; } final String r = String . valueOf ( s ) ; pw . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ( s [ 0 ] == '0' ? r . substring ( 1 ) : r ) ) ; } pw . close ( ) ; } }", "functions_standalone": [["run", "private static boolean run ( final char [ ] s , final int [ ] d1 , final int [ ] d , final int k ) { if ( k == s . length ) { for ( int i = 1 ; i < 10 ; ++ i ) { if ( d1 [ i ] != d [ i ] ) { return false ; } } return true ; } while ( true ) { char c = s [ k ] ; if ( c > '9' ) { s [ k ] = '0' ; return false ; } int x = c - '0' ; if ( d1 [ x ] < d [ x ] ) { ++ d1 [ x ] ; if ( run ( s , d1 , d , k + 1 ) ) { return true ; } -- d1 [ x ] ; } ++ s [ k ] ; } }"], ["main", "public static void main ( final String ... args ) throws IOException { final String fname = \" B - large \" ; final Scanner sc = new Scanner ( new File ( fname + \" . in \" ) ) ; final PrintWriter pw = new PrintWriter ( fname + \" . out \" ) ; final int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 0 ; i < t ; ++ i ) { final char [ ] s = ( '0' + sc . nextLine ( ) ) . toCharArray ( ) ; final int [ ] d = new int [ 10 ] ; for ( char c : s ) { d [ c - '0' ] ++ ; } ++ s [ s . length - 1 ] ; final int [ ] d1 = new int [ 10 ] ; if ( ! run ( s , d1 , d , 0 ) ) { throw new RuntimeException ( ) ; } final String r = String . valueOf ( s ) ; pw . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ( s [ 0 ] == '0' ? r . substring ( 1 ) : r ) ) ; } pw . close ( ) ; }"]], "functions_class": []}, {"id": "15", "code": "import java . util . Scanner ; import java . util . Arrays ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileNotFoundException ; public class B { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( \" B . out \" ) ; int t = in . nextInt ( ) ; in . nextLine ( ) ; for ( int tn = 0 ; tn < t ; tn ++ ) { out . println ( \" Case \u2581 # \" + ( tn + 1 ) + \" : \u2581 \" + solve ( in ) ) ; } out . close ( ) ; } private static String solve ( Scanner in ) { String s = in . nextLine ( ) . trim ( ) ; if ( s . length ( ) == 1 ) return s + \"0\" ; char [ ] a = s . toCharArray ( ) ; int i = s . length ( ) - 2 ; while ( i > - 1 && a [ i ] >= a [ i + 1 ] ) i -- ; if ( i == - 1 ) { Arrays . sort ( a ) ; i = 0 ; while ( a [ i ] == '0' ) i ++ ; char p = a [ i ] ; a [ i ] = '0' ; return p + new String ( a ) ; } else { int j = s . length ( ) - 1 ; while ( a [ j ] <= a [ i ] ) j -- ; char t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; Arrays . sort ( a , i + 1 , a . length ) ; return new String ( a ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( \" B . out \" ) ; int t = in . nextInt ( ) ; in . nextLine ( ) ; for ( int tn = 0 ; tn < t ; tn ++ ) { out . println ( \" Case \u2581 # \" + ( tn + 1 ) + \" : \u2581 \" + solve ( in ) ) ; } out . close ( ) ; }"], ["solve", "private static String solve ( Scanner in ) { String s = in . nextLine ( ) . trim ( ) ; if ( s . length ( ) == 1 ) return s + \"0\" ; char [ ] a = s . toCharArray ( ) ; int i = s . length ( ) - 2 ; while ( i > - 1 && a [ i ] >= a [ i + 1 ] ) i -- ; if ( i == - 1 ) { Arrays . sort ( a ) ; i = 0 ; while ( a [ i ] == '0' ) i ++ ; char p = a [ i ] ; a [ i ] = '0' ; return p + new String ( a ) ; } else { int j = s . length ( ) - 1 ; while ( a [ j ] <= a [ i ] ) j -- ; char t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; Arrays . sort ( a , i + 1 , a . length ) ; return new String ( a ) ; } }"]], "functions_class": []}, {"id": "18", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . Arrays ; public class B { public static final String FILE_NAME = \" B - large \" ; public static void main ( String [ ] args ) throws Exception { BufferedReader input = new BufferedReader ( new FileReader ( FILE_NAME + \" . in \" ) ) ; BufferedWriter output = new BufferedWriter ( new FileWriter ( FILE_NAME + \" . out \" ) ) ; final int T = Integer . parseInt ( input . readLine ( ) ) ; for ( int t = 0 ; t < T ; t ++ ) { output . append ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" ) ; char [ ] chars = input . readLine ( ) . trim ( ) . toCharArray ( ) ; int k = chars . length - 1 ; while ( k > 0 && chars [ k ] <= chars [ k - 1 ] ) k -- ; if ( k > 0 ) { int p = k ; char min = '9' + 1 ; for ( int q = k ; q < chars . length ; q ++ ) { if ( chars [ q ] > chars [ k - 1 ] && chars [ q ] < min ) { min = chars [ q ] ; p = q ; } } char c = chars [ p ] ; chars [ p ] = chars [ k - 1 ] ; chars [ k - 1 ] = c ; Arrays . sort ( chars , k , chars . length ) ; for ( int x = 0 ; x < chars . length ; x ++ ) output . append ( chars [ x ] ) ; } else { Arrays . sort ( chars ) ; int j = 0 ; while ( chars [ j ] == '0' ) j ++ ; output . append ( chars [ j ] ) ; for ( int x = 0 ; x < j + 1 ; x ++ ) output . append ( '0' ) ; for ( int x = j + 1 ; x < chars . length ; x ++ ) output . append ( chars [ x ] ) ; } output . append ( ' \\n ' ) ; } output . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader input = new BufferedReader ( new FileReader ( FILE_NAME + \" . in \" ) ) ; BufferedWriter output = new BufferedWriter ( new FileWriter ( FILE_NAME + \" . out \" ) ) ; final int T = Integer . parseInt ( input . readLine ( ) ) ; for ( int t = 0 ; t < T ; t ++ ) { output . append ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" ) ; char [ ] chars = input . readLine ( ) . trim ( ) . toCharArray ( ) ; int k = chars . length - 1 ; while ( k > 0 && chars [ k ] <= chars [ k - 1 ] ) k -- ; if ( k > 0 ) { int p = k ; char min = '9' + 1 ; for ( int q = k ; q < chars . length ; q ++ ) { if ( chars [ q ] > chars [ k - 1 ] && chars [ q ] < min ) { min = chars [ q ] ; p = q ; } } char c = chars [ p ] ; chars [ p ] = chars [ k - 1 ] ; chars [ k - 1 ] = c ; Arrays . sort ( chars , k , chars . length ) ; for ( int x = 0 ; x < chars . length ; x ++ ) output . append ( chars [ x ] ) ; } else { Arrays . sort ( chars ) ; int j = 0 ; while ( chars [ j ] == '0' ) j ++ ; output . append ( chars [ j ] ) ; for ( int x = 0 ; x < j + 1 ; x ++ ) output . append ( '0' ) ; for ( int x = j + 1 ; x < chars . length ; x ++ ) output . append ( chars [ x ] ) ; } output . append ( ' \\n ' ) ; } output . close ( ) ; }"]], "functions_class": []}, {"id": "3", "code": "import java . io . BufferedReader ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . StringTokenizer ; public class B { static BufferedReader in ; static PrintWriter out ; static StringTokenizer tok ; public static void main ( String args [ ] ) throws Exception { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" b . in \" ) ) ) ; out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( \" b . out \" ) ) ) ; int T = nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { String n = \"0\" + next ( ) ; int cnts [ ] = new int [ 10 ] ; String ans ; PLoop : for ( int p = n . length ( ) - 1 ; ; p -- ) { int c = n . charAt ( p ) - '0' ; ++ cnts [ c ] ; for ( int nc = c + 1 ; nc < 10 ; ++ nc ) { if ( cnts [ nc ] > 0 ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( n . substring ( 0 , p ) ) ; sb . append ( ( char ) ( '0' + nc ) ) ; -- cnts [ nc ] ; for ( int i = 0 ; i < 10 ; ++ i ) { while ( cnts [ i ] > 0 ) { sb . append ( ( char ) ( '0' + i ) ) ; -- cnts [ i ] ; } } ans = sb . toString ( ) ; break PLoop ; } } if ( p == 0 ) { throw new AssertionError ( ) ; } } out . println ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + new BigInteger ( ans ) . toString ( ) ) ; } in . close ( ) ; out . close ( ) ; } static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) ) ; } return tok . nextToken ( ) ; } static int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" b . in \" ) ) ) ; out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( \" b . out \" ) ) ) ; int T = nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { String n = \"0\" + next ( ) ; int cnts [ ] = new int [ 10 ] ; String ans ; PLoop : for ( int p = n . length ( ) - 1 ; ; p -- ) { int c = n . charAt ( p ) - '0' ; ++ cnts [ c ] ; for ( int nc = c + 1 ; nc < 10 ; ++ nc ) { if ( cnts [ nc ] > 0 ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( n . substring ( 0 , p ) ) ; sb . append ( ( char ) ( '0' + nc ) ) ; -- cnts [ nc ] ; for ( int i = 0 ; i < 10 ; ++ i ) { while ( cnts [ i ] > 0 ) { sb . append ( ( char ) ( '0' + i ) ) ; -- cnts [ i ] ; } } ans = sb . toString ( ) ; break PLoop ; } } if ( p == 0 ) { throw new AssertionError ( ) ; } } out . println ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + new BigInteger ( ans ) . toString ( ) ) ; } in . close ( ) ; out . close ( ) ; }"], ["next", "static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) ) ; } return tok . nextToken ( ) ; }"], ["nextInt", "static int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }"]], "functions_class": []}, {"id": "13", "code": "import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . StringTokenizer ; public class B { String test ( ) { char [ ] s = ( \"0\" + nextToken ( ) ) . toCharArray ( ) ; int [ ] cnt = new int [ 128 ] ; fori : for ( int i = s . length - 1 ; i >= 0 ; i -- ) { cnt [ s [ i ] ] ++ ; for ( char j = ( char ) ( s [ i ] + 1 ) ; j <= '9' ; j ++ ) { if ( cnt [ j ] > 0 ) { s [ i ] = j ; cnt [ j ] -- ; for ( int k = i + 1 ; k < cnt . length ; k ++ ) { for ( char d = '0' ; d <= '9' ; d ++ ) { if ( cnt [ d ] > 0 ) { s [ k ] = d ; cnt [ d ] -- ; break ; } } } break fori ; } } } return new BigInteger ( new String ( s ) ) . toString ( ) ; } private void solve ( ) { int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + test ( ) ) ; } } PrintWriter out ; BufferedReader br ; StringTokenizer st ; private void run ( ) { try { br = new BufferedReader ( new FileReader ( \" B - large . in \" ) ) ; out = new PrintWriter ( \" B - large . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } String nextToken ( ) { try { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; } catch ( IOException e ) { return \" \" ; } } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } public static void main ( String [ ] args ) { new B ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new B ( ) . run ( ) ; }"]], "functions_class": [["test", "String test ( ) { char [ ] s = ( \"0\" + nextToken ( ) ) . toCharArray ( ) ; int [ ] cnt = new int [ 128 ] ; fori : for ( int i = s . length - 1 ; i >= 0 ; i -- ) { cnt [ s [ i ] ] ++ ; for ( char j = ( char ) ( s [ i ] + 1 ) ; j <= '9' ; j ++ ) { if ( cnt [ j ] > 0 ) { s [ i ] = j ; cnt [ j ] -- ; for ( int k = i + 1 ; k < cnt . length ; k ++ ) { for ( char d = '0' ; d <= '9' ; d ++ ) { if ( cnt [ d ] > 0 ) { s [ k ] = d ; cnt [ d ] -- ; break ; } } } break fori ; } } } return new BigInteger ( new String ( s ) ) . toString ( ) ; }"], ["solve", "private void solve ( ) { int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + test ( ) ) ; } }"], ["run", "private void run ( ) { try { br = new BufferedReader ( new FileReader ( \" B - large . in \" ) ) ; out = new PrintWriter ( \" B - large . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }"], ["nextToken", "String nextToken ( ) { try { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; } catch ( IOException e ) { return \" \" ; } }"], ["nextInt", "int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"]]}], "python": [{"id": "11", "code": "from sys import stdin NEW_LINE from sys import stdout NEW_LINE def find_least ( s , p , x ) : NEW_LINE INDENT m = None NEW_LINE b = len ( s ) NEW_LINE for i in xrange ( p , len ( s ) ) : NEW_LINE INDENT if s [ i ] > x and ( m is None or s [ i ] < m ) : NEW_LINE INDENT m = s [ i ] NEW_LINE b = i NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT def next_number ( N ) : NEW_LINE INDENT for i in xrange ( len ( N ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if N [ i - 1 ] < N [ i ] : NEW_LINE INDENT K = N [ : i - 1 ] NEW_LINE p = find_least ( N , i , N [ i - 1 ] ) NEW_LINE d = N [ p ] NEW_LINE s = list ( N [ i - 1 : p ] + N [ p + 1 : ] ) NEW_LINE s . sort ( ) NEW_LINE K += d + ' ' . join ( s ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT p = find_least ( N , 0 , '0' ) NEW_LINE d = N [ p ] NEW_LINE s = list ( N [ : p ] + N [ p + 1 : ] ) NEW_LINE s . sort ( ) NEW_LINE K = d + '0' + ' ' . join ( s ) NEW_LINE DEDENT return K NEW_LINE DEDENT T = int ( stdin . readline ( ) . strip ( ) ) NEW_LINE for X in xrange ( 1 , T + 1 ) : NEW_LINE INDENT N = stdin . readline ( ) . strip ( ) NEW_LINE K = next_number ( N ) NEW_LINE stdout . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( X , K ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "20", "code": "from skynet . math . numbers import digits NEW_LINE def dijkstra_next_perm ( iterable ) : NEW_LINE INDENT iterable = list ( iterable ) NEW_LINE N = len ( iterable ) NEW_LINE i = len ( iterable ) - 1 NEW_LINE while iterable [ i - 1 ] >= iterable [ i ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT j = N NEW_LINE while iterable [ j - 1 ] <= iterable [ i - 1 ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT iterable [ i - 1 ] , iterable [ j - 1 ] = iterable [ j - 1 ] , iterable [ i - 1 ] NEW_LINE i += 1 NEW_LINE j = N NEW_LINE while i < j : NEW_LINE INDENT iterable [ i - 1 ] , iterable [ j - 1 ] = iterable [ j - 1 ] , iterable [ i - 1 ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return iterable NEW_LINE DEDENT def next_number ( n ) : NEW_LINE INDENT p = str ( n ) NEW_LINE try : NEW_LINE INDENT m = int ( ' ' . join ( dijkstra_next_perm ( p ) ) ) NEW_LINE DEDENT except IndexError : NEW_LINE INDENT return int ( ' ' . join ( dijkstra_next_perm ( p + '0' ) ) ) NEW_LINE DEDENT if m <= n : NEW_LINE INDENT return int ( ' ' . join ( dijkstra_next_perm ( p + '0' ) ) ) NEW_LINE DEDENT return m NEW_LINE DEDENT with open ( ' B - large . in ' ) as file : NEW_LINE INDENT t = int ( file . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( file . readline ( ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i + 1 , next_number ( n ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["dijkstra_next_perm", "def dijkstra_next_perm ( iterable ) : NEW_LINE INDENT iterable = list ( iterable ) NEW_LINE N = len ( iterable ) NEW_LINE i = len ( iterable ) - 1 NEW_LINE while iterable [ i - 1 ] >= iterable [ i ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT j = N NEW_LINE while iterable [ j - 1 ] <= iterable [ i - 1 ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT iterable [ i - 1 ] , iterable [ j - 1 ] = iterable [ j - 1 ] , iterable [ i - 1 ] NEW_LINE i += 1 NEW_LINE j = N NEW_LINE while i < j : NEW_LINE INDENT iterable [ i - 1 ] , iterable [ j - 1 ] = iterable [ j - 1 ] , iterable [ i - 1 ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return iterable NEW_LINE DEDENT"], ["next_number", "def next_number ( n ) : NEW_LINE INDENT p = str ( n ) NEW_LINE try : NEW_LINE INDENT m = int ( ' ' . join ( dijkstra_next_perm ( p ) ) ) NEW_LINE DEDENT except IndexError : NEW_LINE INDENT return int ( ' ' . join ( dijkstra_next_perm ( p + '0' ) ) ) NEW_LINE DEDENT if m <= n : NEW_LINE INDENT return int ( ' ' . join ( dijkstra_next_perm ( p + '0' ) ) ) NEW_LINE DEDENT return m NEW_LINE DEDENT"]], "functions_class": []}, {"id": "6", "code": "def next_number ( digits ) : NEW_LINE INDENT if len ( digits ) == 1 : NEW_LINE INDENT return None NEW_LINE DEDENT if len ( digits ) == 2 : NEW_LINE INDENT return ( digits [ 1 ] , digits [ 0 ] ) if digits [ 1 ] > digits [ 0 ] else None NEW_LINE DEDENT rearrange = next_number ( digits [ 1 : ] ) NEW_LINE if rearrange is not None : NEW_LINE INDENT digits [ 1 : ] = rearrange NEW_LINE return digits NEW_LINE DEDENT larger = [ d for d in digits if d > digits [ 0 ] ] NEW_LINE if larger : NEW_LINE INDENT min_larger = min ( larger ) NEW_LINE taildigits = delone ( digits [ : ] , min_larger ) NEW_LINE taildigits . sort ( ) NEW_LINE taildigits . insert ( 0 , min_larger ) NEW_LINE return taildigits NEW_LINE DEDENT return None NEW_LINE DEDENT def delone ( taildigits , n ) : NEW_LINE INDENT for i in range ( len ( taildigits ) ) : NEW_LINE INDENT if taildigits [ i ] == n : NEW_LINE INDENT del taildigits [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return taildigits NEW_LINE DEDENT with open ( ' B - large . in ' ) as f : NEW_LINE INDENT o = open ( ' bnumberout . txt ' , ' w ' ) NEW_LINE cases = int ( f . next ( ) ) NEW_LINE for i in range ( 1 , cases + 1 ) : NEW_LINE INDENT o . write ( ' Case \u2581 # % d : \u2581 ' % i ) NEW_LINE strn = f . next ( ) . strip ( ) NEW_LINE digits = [ int ( d ) for d in strn ] NEW_LINE nextdigits = next_number ( digits ) NEW_LINE if nextdigits is None : NEW_LINE INDENT leader = min ( [ d for d in digits if d > 0 ] ) NEW_LINE digits = delone ( digits , leader ) NEW_LINE digits . sort ( ) NEW_LINE nextdigits = [ leader , 0 ] + digits NEW_LINE DEDENT nextnumber = ' ' . join ( [ str ( d ) for d in nextdigits ] ) NEW_LINE o . write ( nextnumber + ' \\n ' ) NEW_LINE DEDENT o . close ( ) NEW_LINE DEDENT", "functions_standalone": [["next_number", "def next_number ( digits ) : NEW_LINE INDENT if len ( digits ) == 1 : NEW_LINE INDENT return None NEW_LINE DEDENT if len ( digits ) == 2 : NEW_LINE INDENT return ( digits [ 1 ] , digits [ 0 ] ) if digits [ 1 ] > digits [ 0 ] else None NEW_LINE DEDENT rearrange = next_number ( digits [ 1 : ] ) NEW_LINE if rearrange is not None : NEW_LINE INDENT digits [ 1 : ] = rearrange NEW_LINE return digits NEW_LINE DEDENT larger = [ d for d in digits if d > digits [ 0 ] ] NEW_LINE if larger : NEW_LINE INDENT min_larger = min ( larger ) NEW_LINE taildigits = delone ( digits [ : ] , min_larger ) NEW_LINE taildigits . sort ( ) NEW_LINE taildigits . insert ( 0 , min_larger ) NEW_LINE return taildigits NEW_LINE DEDENT return None NEW_LINE DEDENT"], ["delone", "def delone ( taildigits , n ) : NEW_LINE INDENT for i in range ( len ( taildigits ) ) : NEW_LINE INDENT if taildigits [ i ] == n : NEW_LINE INDENT del taildigits [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return taildigits NEW_LINE DEDENT"]], "functions_class": []}, {"id": "7", "code": "import sys NEW_LINE def findNext ( number ) : NEW_LINE INDENT digits = [ ch for ch in number . strip ( ) ] NEW_LINE sorted = list ( digits ) NEW_LINE sorted . sort ( ) NEW_LINE if len ( number ) == 1 : NEW_LINE INDENT return number + \"0\" NEW_LINE DEDENT cur = len ( digits ) - 2 NEW_LINE while cur >= 0 : NEW_LINE INDENT if digits [ cur ] < digits [ cur + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT cur -= 1 NEW_LINE DEDENT if cur == - 1 : NEW_LINE INDENT ret = \" \" . join ( sorted ) NEW_LINE ret = ret . replace ( \"0\" , \" \" ) NEW_LINE ret = ret [ 0 ] + \"0\" * ( digits . count ( \"0\" ) + 1 ) + ret [ 1 : ] NEW_LINE return ret NEW_LINE DEDENT else : NEW_LINE INDENT ret = number [ : cur ] NEW_LINE first = min ( [ dd for dd in digits [ cur : ] if dd > number [ cur ] ] ) NEW_LINE ret += first NEW_LINE remains = digits [ cur : ] NEW_LINE remains . sort ( ) NEW_LINE remains . remove ( first ) NEW_LINE ret += \" \" . join ( remains ) NEW_LINE return ret NEW_LINE DEDENT DEDENT def compare ( A , B ) : NEW_LINE INDENT pA = [ ch for ch in A . strip ( ) if ch != \"0\" ] NEW_LINE pB = [ ch for ch in B . strip ( ) if ch != \"0\" ] NEW_LINE pA . sort ( ) NEW_LINE pB . sort ( ) NEW_LINE return \" \" . join ( pA ) == \" \" . join ( pB ) NEW_LINE DEDENT def findNext2 ( number ) : NEW_LINE INDENT num = int ( number ) + 1 NEW_LINE while 1 : NEW_LINE INDENT if compare ( str ( num ) , number ) : NEW_LINE INDENT return str ( num ) NEW_LINE DEDENT num += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT infile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE outfile = open ( \" resultB . out \" , \" w \" ) NEW_LINE N = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 0 , N ) : NEW_LINE INDENT input = infile . readline ( ) . strip ( ) NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( case + 1 , findNext ( input ) ) ) NEW_LINE DEDENT infile . close ( ) NEW_LINE outfile . close ( ) NEW_LINE DEDENT", "functions_standalone": [["findNext", "def findNext ( number ) : NEW_LINE INDENT digits = [ ch for ch in number . strip ( ) ] NEW_LINE sorted = list ( digits ) NEW_LINE sorted . sort ( ) NEW_LINE if len ( number ) == 1 : NEW_LINE INDENT return number + \"0\" NEW_LINE DEDENT cur = len ( digits ) - 2 NEW_LINE while cur >= 0 : NEW_LINE INDENT if digits [ cur ] < digits [ cur + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT cur -= 1 NEW_LINE DEDENT if cur == - 1 : NEW_LINE INDENT ret = \" \" . join ( sorted ) NEW_LINE ret = ret . replace ( \"0\" , \" \" ) NEW_LINE ret = ret [ 0 ] + \"0\" * ( digits . count ( \"0\" ) + 1 ) + ret [ 1 : ] NEW_LINE return ret NEW_LINE DEDENT else : NEW_LINE INDENT ret = number [ : cur ] NEW_LINE first = min ( [ dd for dd in digits [ cur : ] if dd > number [ cur ] ] ) NEW_LINE ret += first NEW_LINE remains = digits [ cur : ] NEW_LINE remains . sort ( ) NEW_LINE remains . remove ( first ) NEW_LINE ret += \" \" . join ( remains ) NEW_LINE return ret NEW_LINE DEDENT DEDENT"], ["compare", "def compare ( A , B ) : NEW_LINE INDENT pA = [ ch for ch in A . strip ( ) if ch != \"0\" ] NEW_LINE pB = [ ch for ch in B . strip ( ) if ch != \"0\" ] NEW_LINE pA . sort ( ) NEW_LINE pB . sort ( ) NEW_LINE return \" \" . join ( pA ) == \" \" . join ( pB ) NEW_LINE DEDENT"], ["findNext2", "def findNext2 ( number ) : NEW_LINE INDENT num = int ( number ) + 1 NEW_LINE while 1 : NEW_LINE INDENT if compare ( str ( num ) , number ) : NEW_LINE INDENT return str ( num ) NEW_LINE DEDENT num += 1 NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_08_03", "java": [{"id": "18", "code": "package fly ; public class Point { public double x ; public double y ; public Point ( double x , double y ) { this . x = x ; this . y = y ; } }", "functions_standalone": [], "functions_class": [["Point", "public Point ( double x , double y ) { this . x = x ; this . y = y ; }"]]}], "python": [{"id": "19", "code": "from sys import stdin as input_file NEW_LINE from sys import stdout as output_file NEW_LINE from math import pi , sqrt NEW_LINE num_segments = 1000000 NEW_LINE def readline ( file ) : NEW_LINE INDENT return file . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT def hit_probability ( fly_radius , racquet_outer_radius , racquet_thickness , string_radius , string_gap ) : NEW_LINE INDENT racquet_thickness += fly_radius NEW_LINE string_radius += fly_radius NEW_LINE string_gap -= 2 * fly_radius NEW_LINE if string_gap <= 0.0 : NEW_LINE INDENT probability = 1.0 NEW_LINE DEDENT else : NEW_LINE INDENT hit_area = 0.0 NEW_LINE delta = racquet_outer_radius / num_segments NEW_LINE string_diameter = 2 * string_radius NEW_LINE unit = string_diameter + string_gap NEW_LINE lower = string_radius NEW_LINE upper = string_radius + string_gap NEW_LINE outer_square = racquet_outer_radius ** 2 NEW_LINE inner_square = ( racquet_outer_radius - racquet_thickness ) ** 2 NEW_LINE for i in xrange ( num_segments ) : NEW_LINE INDENT x = ( i + 0.5 ) / num_segments * racquet_outer_radius NEW_LINE x_square = x * x NEW_LINE difference = inner_square - x_square NEW_LINE x_div , x_mod = divmod ( x , unit ) NEW_LINE hit_length = sqrt ( outer_square - x_square ) NEW_LINE if ( difference > 0 ) and ( x_mod > lower ) and ( x_mod < upper ) : NEW_LINE INDENT sqrt_difference = sqrt ( difference ) NEW_LINE hit_length -= sqrt_difference NEW_LINE y_div , y_mod = divmod ( sqrt_difference , unit ) NEW_LINE hit_length += y_div * string_diameter NEW_LINE if y_mod < lower : NEW_LINE INDENT hit_length += y_mod NEW_LINE DEDENT elif y_mod < upper : NEW_LINE INDENT hit_length += string_radius NEW_LINE DEDENT else : NEW_LINE INDENT hit_length += y_mod - string_gap NEW_LINE DEDENT DEDENT hit_area += hit_length * delta NEW_LINE DEDENT probability = hit_area / ( pi / 4 * racquet_outer_radius ** 2 ) NEW_LINE DEDENT return probability NEW_LINE DEDENT num_cases = int ( readline ( input_file ) ) NEW_LINE for case_num in xrange ( num_cases ) : NEW_LINE INDENT entries = readline ( input_file ) . split ( ) NEW_LINE fly_radius = float ( entries [ 0 ] ) NEW_LINE racquet_outer_radius = float ( entries [ 1 ] ) NEW_LINE racquet_thickness = float ( entries [ 2 ] ) NEW_LINE string_radius = float ( entries [ 3 ] ) NEW_LINE string_gap = float ( entries [ 4 ] ) NEW_LINE probability = hit_probability ( fly_radius , racquet_outer_radius , racquet_thickness , string_radius , string_gap ) NEW_LINE output_file . write ( ' Case \u2581 # % d : \u2581 % f \\n ' % ( case_num + 1 , probability ) ) NEW_LINE DEDENT", "functions_standalone": [["readline", "def readline ( file ) : NEW_LINE INDENT return file . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_08_32", "java": [{"id": "10", "code": "import java . math . BigInteger ; import java . util . Scanner ; public class B { private static int parse ( String s ) { BigInteger integer = new BigInteger ( s ) ; integer = integer . mod ( BigInteger . valueOf ( 210 ) ) ; return integer . intValue ( ) ; } public static void main ( String [ ] args ) { final Scanner scanner = new Scanner ( System . in ) ; final int N = scanner . nextInt ( ) ; for ( int testCase = 1 ; testCase <= N ; ++ testCase ) { final String line = scanner . next ( ) ; final int n = line . length ( ) ; final int [ ] [ ] partsTable = new int [ n ] [ n + 1 ] ; for ( int begin = 0 ; begin < n ; ++ begin ) { for ( int end = begin + 1 ; end <= n ; ++ end ) { partsTable [ begin ] [ end ] = parse ( line . substring ( begin , end ) ) ; } } final long [ ] [ ] memo = new long [ n + 1 ] [ 210 ] ; ++ memo [ 0 ] [ 0 ] ; for ( int endIndex = 1 ; endIndex <= n ; ++ endIndex ) { for ( int beginIndex = 0 ; beginIndex < endIndex ; ++ beginIndex ) { { for ( int prevMod = 0 ; prevMod < 210 ; ++ prevMod ) { final int nextMod = ( prevMod + partsTable [ beginIndex ] [ endIndex ] ) % 210 ; memo [ endIndex ] [ nextMod ] += memo [ beginIndex ] [ prevMod ] ; } } if ( beginIndex != 0 ) { for ( int prevMod = 0 ; prevMod < 210 ; ++ prevMod ) { final int nextMod = ( prevMod - partsTable [ beginIndex ] [ endIndex ] + 210 ) % 210 ; memo [ endIndex ] [ nextMod ] += memo [ beginIndex ] [ prevMod ] ; } } } } long answer = 0 ; for ( int mod = 0 ; mod < 210 ; ++ mod ) { if ( mod % 2 == 0 || mod % 3 == 0 || mod % 5 == 0 || mod % 7 == 0 ) { answer += memo [ n ] [ mod ] ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , testCase , answer ) ; } } }", "functions_standalone": [["parse", "private static int parse ( String s ) { BigInteger integer = new BigInteger ( s ) ; integer = integer . mod ( BigInteger . valueOf ( 210 ) ) ; return integer . intValue ( ) ; }"], ["main", "public static void main ( String [ ] args ) { final Scanner scanner = new Scanner ( System . in ) ; final int N = scanner . nextInt ( ) ; for ( int testCase = 1 ; testCase <= N ; ++ testCase ) { final String line = scanner . next ( ) ; final int n = line . length ( ) ; final int [ ] [ ] partsTable = new int [ n ] [ n + 1 ] ; for ( int begin = 0 ; begin < n ; ++ begin ) { for ( int end = begin + 1 ; end <= n ; ++ end ) { partsTable [ begin ] [ end ] = parse ( line . substring ( begin , end ) ) ; } } final long [ ] [ ] memo = new long [ n + 1 ] [ 210 ] ; ++ memo [ 0 ] [ 0 ] ; for ( int endIndex = 1 ; endIndex <= n ; ++ endIndex ) { for ( int beginIndex = 0 ; beginIndex < endIndex ; ++ beginIndex ) { { for ( int prevMod = 0 ; prevMod < 210 ; ++ prevMod ) { final int nextMod = ( prevMod + partsTable [ beginIndex ] [ endIndex ] ) % 210 ; memo [ endIndex ] [ nextMod ] += memo [ beginIndex ] [ prevMod ] ; } } if ( beginIndex != 0 ) { for ( int prevMod = 0 ; prevMod < 210 ; ++ prevMod ) { final int nextMod = ( prevMod - partsTable [ beginIndex ] [ endIndex ] + 210 ) % 210 ; memo [ endIndex ] [ nextMod ] += memo [ beginIndex ] [ prevMod ] ; } } } } long answer = 0 ; for ( int mod = 0 ; mod < 210 ; ++ mod ) { if ( mod % 2 == 0 || mod % 3 == 0 || mod % 5 == 0 || mod % 7 == 0 ) { answer += memo [ n ] [ mod ] ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , testCase , answer ) ; } }"]], "functions_class": []}, {"id": "6", "code": "import java . io . * ; import java . util . * ; public class b { long sol = 0 ; String s ; long nrt ; long calc ( int lop , long bef , long now ) { switch ( lop ) { case 0 : return now ; case 1 : return bef + now ; case 2 : return bef - now ; } return 0 ; } boolean ugly ( long x ) { if ( x < 0 ) x = - x ; if ( x % 2 == 0 ) return true ; if ( x % 3 == 0 ) return true ; if ( x % 5 == 0 ) return true ; if ( x % 7 == 0 ) return true ; return false ; } void count ( int poz , int lop , long bef , long now ) { if ( poz == s . length ( ) - 1 ) { if ( ugly ( calc ( lop , bef , now ) ) ) sol ++ ; else { } } else { long c = ( long ) ( s . charAt ( poz + 1 ) - '0' ) ; count ( poz + 1 , lop , bef , 10 * now + c ) ; if ( poz != s . length ( ) - 1 ) { count ( poz + 1 , 1 , calc ( lop , bef , now ) , c ) ; count ( poz + 1 , 2 , calc ( lop , bef , now ) , c ) ; } } } b ( ) { try { File f = new File ( \" B - small - attempt1 . in \" ) ; BufferedReader input = new BufferedReader ( new FileReader ( f ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" small . out \" ) ) ; long nrtests = Integer . parseInt ( input . readLine ( ) ) ; for ( nrt = 0 ; nrt < nrtests ; nrt ++ ) { s = input . readLine ( ) ; sol = 0 ; count ( 0 , 0 , 0 , ( long ) ( s . charAt ( 0 ) - '0' ) ) ; out . write ( \" Case \u2581 # \" + ( nrt + 1 ) + \" : \u2581 \" + sol + \" \\n \" ) ; } out . close ( ) ; } catch ( IOException e ) { } } public static void main ( String [ ] args ) { new b ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new b ( ) ; }"]], "functions_class": [["calc", "long calc ( int lop , long bef , long now ) { switch ( lop ) { case 0 : return now ; case 1 : return bef + now ; case 2 : return bef - now ; } return 0 ; }"], ["ugly", "boolean ugly ( long x ) { if ( x < 0 ) x = - x ; if ( x % 2 == 0 ) return true ; if ( x % 3 == 0 ) return true ; if ( x % 5 == 0 ) return true ; if ( x % 7 == 0 ) return true ; return false ; }"], ["count", "void count ( int poz , int lop , long bef , long now ) { if ( poz == s . length ( ) - 1 ) { if ( ugly ( calc ( lop , bef , now ) ) ) sol ++ ; else { } } else { long c = ( long ) ( s . charAt ( poz + 1 ) - '0' ) ; count ( poz + 1 , lop , bef , 10 * now + c ) ; if ( poz != s . length ( ) - 1 ) { count ( poz + 1 , 1 , calc ( lop , bef , now ) , c ) ; count ( poz + 1 , 2 , calc ( lop , bef , now ) , c ) ; } } }"], ["b", "b ( ) { try { File f = new File ( \" B - small - attempt1 . in \" ) ; BufferedReader input = new BufferedReader ( new FileReader ( f ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" small . out \" ) ) ; long nrtests = Integer . parseInt ( input . readLine ( ) ) ; for ( nrt = 0 ; nrt < nrtests ; nrt ++ ) { s = input . readLine ( ) ; sol = 0 ; count ( 0 , 0 , 0 , ( long ) ( s . charAt ( 0 ) - '0' ) ) ; out . write ( \" Case \u2581 # \" + ( nrt + 1 ) + \" : \u2581 \" + sol + \" \\n \" ) ; } out . close ( ) ; } catch ( IOException e ) { } }"]]}], "python": [{"id": "14", "code": "FNAME = \" B - small - attempt0 . in \" NEW_LINE PRIMDIV = 2 , 3 , 5 , 7 NEW_LINE class Case ( object ) : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . num = num NEW_LINE DEDENT DEDENT def isugly ( n ) : NEW_LINE INDENT for i in PRIMDIV : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def getvals ( s ) : NEW_LINE INDENT vals = [ ] NEW_LINE for i in xrange ( len ( s ) ) : NEW_LINE INDENT v = int ( s [ : i + 1 ] ) NEW_LINE if not s [ i + 1 : ] : NEW_LINE INDENT prevvals = [ 0 ] NEW_LINE vals . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT prevvals = getvals ( s [ i + 1 : ] ) NEW_LINE vals . extend ( [ v + val for val in prevvals ] ) NEW_LINE vals . extend ( [ v - val for val in prevvals ] ) NEW_LINE DEDENT DEDENT return vals NEW_LINE DEDENT def getnugly ( s ) : NEW_LINE INDENT return len ( [ val for val in getvals ( s ) if isugly ( val ) ] ) NEW_LINE DEDENT def parse ( lines ) : NEW_LINE INDENT cases = [ ] NEW_LINE i = 1 NEW_LINE while i < len ( lines ) : NEW_LINE INDENT cases . append ( Case ( lines [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT return cases NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lines = file ( FNAME ) . read ( ) . splitlines ( ) NEW_LINE answers = [ getnugly ( case . num ) for case in parse ( lines ) ] NEW_LINE outlines = [ \" Case \u2581 # % d : \u2581 % d \\n \" % ( i + 1 , answer ) for i , answer in enumerate ( answers ) ] NEW_LINE file ( FNAME + \" . out \" , \" w \" ) . writelines ( outlines ) NEW_LINE DEDENT", "functions_standalone": [["isugly", "def isugly ( n ) : NEW_LINE INDENT for i in PRIMDIV : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"], ["getnugly", "def getnugly ( s ) : NEW_LINE INDENT return len ( [ val for val in getvals ( s ) if isugly ( val ) ] ) NEW_LINE DEDENT"], ["parse", "def parse ( lines ) : NEW_LINE INDENT cases = [ ] NEW_LINE i = 1 NEW_LINE while i < len ( lines ) : NEW_LINE INDENT cases . append ( Case ( lines [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT return cases NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self , num ) : NEW_LINE INDENT self . num = num NEW_LINE DEDENT"]]}, {"id": "5", "code": "def solve ( ) : NEW_LINE INDENT f = open ( ' B - large . in ' ) NEW_LINE g = open ( ' B . out ' , ' w ' ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s = f . readline ( ) . strip ( ) NEW_LINE D = len ( s ) NEW_LINE m = [ [ ] * 210 ] * D NEW_LINE def go ( j ) : NEW_LINE INDENT rn = [ 0 ] * 210 NEW_LINE if j == D : return rn NEW_LINE if m [ j ] != [ ] : return m [ j ] NEW_LINE t = int ( s [ j : D ] ) NEW_LINE rn [ t % 210 ] += 1 NEW_LINE for k in xrange ( j + 1 , D ) : NEW_LINE INDENT t = int ( s [ j : k ] ) NEW_LINE rs = go ( k ) NEW_LINE for ir in xrange ( 210 ) : NEW_LINE INDENT rn [ ( t + ir ) % 210 ] += rs [ ir ] NEW_LINE rn [ ( 210 + t - ir ) % 210 ] += rs [ ir ] NEW_LINE DEDENT DEDENT m [ j ] = rn NEW_LINE return rn NEW_LINE DEDENT rrr = go ( 0 ) NEW_LINE ret = 0 NEW_LINE for j in xrange ( 210 ) : NEW_LINE INDENT if j % 2 == 0 or j % 3 == 0 or j % 5 == 0 or j % 7 == 0 : NEW_LINE INDENT ret += rrr [ j ] NEW_LINE DEDENT DEDENT g . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( i + 1 , ret ) ) NEW_LINE DEDENT g . close ( ) NEW_LINE DEDENT solve ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "16", "code": "import sys NEW_LINE import math NEW_LINE def isugly ( n ) : NEW_LINE INDENT for p in [ 2 , 3 , 5 , 7 ] : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT output = [ ] NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE try : NEW_LINE INDENT for N in range ( 1 , int ( f . next ( ) ) + 1 ) : NEW_LINE INDENT digits = list ( f . next ( ) . strip ( ) ) NEW_LINE def foo ( n ) : NEW_LINE INDENT if len ( n ) == 1 : NEW_LINE INDENT return 1 if isugly ( n [ 0 ] ) else 0 NEW_LINE DEDENT a = [ n [ 0 ] + n [ 1 ] ] + n [ 2 : ] NEW_LINE b = [ n [ 0 ] - n [ 1 ] ] + n [ 2 : ] NEW_LINE return foo ( a ) + foo ( b ) NEW_LINE DEDENT def bar ( done , todo ) : NEW_LINE INDENT if len ( todo ) == 1 : NEW_LINE INDENT return [ map ( int , done + [ todo [ 0 ] ] ) ] NEW_LINE DEDENT a = bar ( done + todo [ : 1 ] , todo [ 1 : ] ) NEW_LINE b = bar ( list ( done ) , [ todo [ 0 ] + todo [ 1 ] ] + todo [ 2 : ] ) NEW_LINE return a + b NEW_LINE DEDENT output . append ( sum ( map ( foo , bar ( [ ] , digits ) ) ) ) NEW_LINE DEDENT DEDENT finally : NEW_LINE INDENT f . close ( ) NEW_LINE DEDENT f = open ( sys . argv [ 2 ] , ' w ' ) NEW_LINE try : NEW_LINE INDENT f . write ( ' \\n ' . join ( ' Case \u2581 # % s : \u2581 % s ' % ( i + 1 , n ) for i , n in enumerate ( output ) ) ) NEW_LINE DEDENT finally : NEW_LINE INDENT f . close ( ) NEW_LINE DEDENT", "functions_standalone": [["isugly", "def isugly ( n ) : NEW_LINE INDENT for p in [ 2 , 3 , 5 , 7 ] : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"], ["foo", "def foo ( n ) : NEW_LINE INDENT if len ( n ) == 1 : NEW_LINE INDENT return 1 if isugly ( n [ 0 ] ) else 0 NEW_LINE DEDENT a = [ n [ 0 ] + n [ 1 ] ] + n [ 2 : ] NEW_LINE b = [ n [ 0 ] - n [ 1 ] ] + n [ 2 : ] NEW_LINE return foo ( a ) + foo ( b ) NEW_LINE DEDENT"], ["bar", "def bar ( done , todo ) : NEW_LINE INDENT if len ( todo ) == 1 : NEW_LINE INDENT return [ map ( int , done + [ todo [ 0 ] ] ) ] NEW_LINE DEDENT a = bar ( done + todo [ : 1 ] , todo [ 1 : ] ) NEW_LINE b = bar ( list ( done ) , [ todo [ 0 ] + todo [ 1 ] ] + todo [ 2 : ] ) NEW_LINE return a + b NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_08_33", "java": [{"id": "19", "code": "import java . io . * ; import java . util . * ; import java . math . * ; public class Problem3 { public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" Problem3 . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" Problem3 . out \" ) ) ) ; int c = in . nextInt ( ) ; for ( int cn = 0 ; cn < c ; cn ++ ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; long x = in . nextInt ( ) ; long y = in . nextInt ( ) ; long z = in . nextInt ( ) ; long sub [ ] = new long [ n ] ; BigInteger ans [ ] = new BigInteger [ n ] ; long array [ ] = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) array [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sub [ i ] = array [ i % m ] ; array [ i % m ] = ( x * array [ i % m ] + y * ( i + 1 ) ) % z ; } Arrays . fill ( ans , BigInteger . ONE ) ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) { if ( sub [ j ] < sub [ i ] ) ans [ i ] = ans [ i ] . add ( ans [ j ] ) ; } BigInteger sum = BigInteger . ZERO ; for ( int i = 0 ; i < n ; i ++ ) sum = sum . add ( ans [ i ] ) ; sum = sum . remainder ( new BigInteger ( \"1000000007\" ) ) ; out . write ( \" Case \u2581 # \" + ( cn + 1 ) + \" : \u2581 \" + sum . toString ( ) + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" Problem3 . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" Problem3 . out \" ) ) ) ; int c = in . nextInt ( ) ; for ( int cn = 0 ; cn < c ; cn ++ ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; long x = in . nextInt ( ) ; long y = in . nextInt ( ) ; long z = in . nextInt ( ) ; long sub [ ] = new long [ n ] ; BigInteger ans [ ] = new BigInteger [ n ] ; long array [ ] = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) array [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sub [ i ] = array [ i % m ] ; array [ i % m ] = ( x * array [ i % m ] + y * ( i + 1 ) ) % z ; } Arrays . fill ( ans , BigInteger . ONE ) ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) { if ( sub [ j ] < sub [ i ] ) ans [ i ] = ans [ i ] . add ( ans [ j ] ) ; } BigInteger sum = BigInteger . ZERO ; for ( int i = 0 ; i < n ; i ++ ) sum = sum . add ( ans [ i ] ) ; sum = sum . remainder ( new BigInteger ( \"1000000007\" ) ) ; out . write ( \" Case \u2581 # \" + ( cn + 1 ) + \" : \u2581 \" + sum . toString ( ) + \" \\n \" ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": []}, {"id": "4", "code": "package Andra ; import java . util . * ; public class CumulativeTable { public static final long MOD = 1000000007 ; private long [ ] sum ; private int [ ] degreeTwo ; private int n ; public CumulativeTable ( int n ) { this . n = n ; this . sum = new long [ n + 1 ] ; this . degreeTwo = new int [ n + 1 ] ; calculateDegrees ( ) ; } private void calculateDegrees ( ) { degreeTwo [ 0 ] = 1 ; degreeTwo [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) == 0 ) degreeTwo [ i ] = degreeTwo [ i >> 1 ] * 2 ; else degreeTwo [ i ] = 1 ; } } public void reset ( ) { for ( int i = 0 ; i < n ; i ++ ) sum [ i ] = 0 ; } public void add ( int index , long value ) { int i = index ; while ( i <= n ) { sum [ i ] = ( sum [ i ] + value ) % MOD ; i = i + degreeTwo [ i ] ; } } public long count ( int index ) { int i = index ; long toReturn = 0 ; while ( i >= 0 ) { toReturn = ( toReturn + sum [ i ] ) % MOD ; i = i - degreeTwo [ i ] ; } return toReturn ; } public static void main ( String [ ] args ) { Random rnd = new Random ( ) ; int n = 100 ; int [ ] a = new int [ n ] ; CumulativeTable ct = new CumulativeTable ( n ) ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int index = rnd . nextInt ( n ) ; int value = rnd . nextInt ( 1000 ) ; a [ index ] = a [ index ] + value ; ct . add ( index , value ) ; int sum = 0 ; for ( int j = 0 ; j <= index ; j ++ ) sum += a [ j ] ; System . out . println ( sum ) ; System . out . println ( ct . count ( index ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Random rnd = new Random ( ) ; int n = 100 ; int [ ] a = new int [ n ] ; CumulativeTable ct = new CumulativeTable ( n ) ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { int index = rnd . nextInt ( n ) ; int value = rnd . nextInt ( 1000 ) ; a [ index ] = a [ index ] + value ; ct . add ( index , value ) ; int sum = 0 ; for ( int j = 0 ; j <= index ; j ++ ) sum += a [ j ] ; System . out . println ( sum ) ; System . out . println ( ct . count ( index ) ) ; } }"]], "functions_class": [["CumulativeTable", "public CumulativeTable ( int n ) { this . n = n ; this . sum = new long [ n + 1 ] ; this . degreeTwo = new int [ n + 1 ] ; calculateDegrees ( ) ; }"], ["calculateDegrees", "private void calculateDegrees ( ) { degreeTwo [ 0 ] = 1 ; degreeTwo [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) == 0 ) degreeTwo [ i ] = degreeTwo [ i >> 1 ] * 2 ; else degreeTwo [ i ] = 1 ; } }"], ["reset", "public void reset ( ) { for ( int i = 0 ; i < n ; i ++ ) sum [ i ] = 0 ; }"], ["add", "public void add ( int index , long value ) { int i = index ; while ( i <= n ) { sum [ i ] = ( sum [ i ] + value ) % MOD ; i = i + degreeTwo [ i ] ; } }"], ["count", "public long count ( int index ) { int i = index ; long toReturn = 0 ; while ( i >= 0 ) { toReturn = ( toReturn + sum [ i ] ) % MOD ; i = i - degreeTwo [ i ] ; } return toReturn ; }"]]}, {"id": "20", "code": "package codejam2c ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" c - small . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" c - small - out . out \" ) ) ; final long M = 1000000007 ; int T = in . nextInt ( ) ; for ( int x = 1 ; x <= T ; x ++ ) { int n = in . nextInt ( ) , m = in . nextInt ( ) , X = in . nextInt ( ) , Y = in . nextInt ( ) , Z = in . nextInt ( ) ; int i , j ; int [ ] a = new int [ n ] , A = new int [ m ] ; long [ ] nr = new long [ n ] ; long S = 0 ; for ( i = 0 ; i < m ; i ++ ) { A [ i ] = in . nextInt ( ) ; } for ( i = 0 ; i < n ; i ++ ) { a [ i ] = A [ i % m ] ; A [ i % m ] = ( int ) ( ( ( long ) ( ( long ) X * A [ i % m ] + ( long ) Y * ( i + 1 ) ) ) % ( long ) Z ) ; } nr [ 0 ] = 1 ; S = 1 ; for ( i = 1 ; i < n ; i ++ ) { nr [ i ] = 1 ; for ( j = 0 ; j < i ; j ++ ) if ( a [ j ] < a [ i ] ) { nr [ i ] += nr [ j ] ; nr [ i ] %= M ; } S += nr [ i ] ; S %= M ; } out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , x , S ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new FileReader ( \" c - small . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" c - small - out . out \" ) ) ; final long M = 1000000007 ; int T = in . nextInt ( ) ; for ( int x = 1 ; x <= T ; x ++ ) { int n = in . nextInt ( ) , m = in . nextInt ( ) , X = in . nextInt ( ) , Y = in . nextInt ( ) , Z = in . nextInt ( ) ; int i , j ; int [ ] a = new int [ n ] , A = new int [ m ] ; long [ ] nr = new long [ n ] ; long S = 0 ; for ( i = 0 ; i < m ; i ++ ) { A [ i ] = in . nextInt ( ) ; } for ( i = 0 ; i < n ; i ++ ) { a [ i ] = A [ i % m ] ; A [ i % m ] = ( int ) ( ( ( long ) ( ( long ) X * A [ i % m ] + ( long ) Y * ( i + 1 ) ) ) % ( long ) Z ) ; } nr [ 0 ] = 1 ; S = 1 ; for ( i = 1 ; i < n ; i ++ ) { nr [ i ] = 1 ; for ( j = 0 ; j < i ; j ++ ) if ( a [ j ] < a [ i ] ) { nr [ i ] += nr [ j ] ; nr [ i ] %= M ; } S += nr [ i ] ; S %= M ; } out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , x , S ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": []}, {"id": "8", "code": "import java . util . Scanner ; public class ProblemC { public static void main ( final String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; final int cases = sc . nextInt ( ) ; for ( int cc = 1 ; cc <= cases ; cc ++ ) { final int n = sc . nextInt ( ) ; final int m = sc . nextInt ( ) ; final long x = sc . nextLong ( ) , y = sc . nextLong ( ) , z = sc . nextLong ( ) ; final int [ ] h = new int [ n ] ; final int [ ] a = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) h [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = h [ i % m ] ; h [ i % m ] = ( int ) ( ( x * h [ i % m ] + y * ( i + 1 ) ) % z ) ; } final int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( a [ j ] < a [ i ] ) s [ i ] = ( s [ i ] + s [ j ] ) % 1000000007 ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count = ( count + s [ i ] ) % 1000000007 ; System . out . printf ( \" Case \u2581 # % s : \u2581 % s \\n \" , cc , count ) ; } System . out . flush ( ) ; } }", "functions_standalone": [["main", "public static void main ( final String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; final int cases = sc . nextInt ( ) ; for ( int cc = 1 ; cc <= cases ; cc ++ ) { final int n = sc . nextInt ( ) ; final int m = sc . nextInt ( ) ; final long x = sc . nextLong ( ) , y = sc . nextLong ( ) , z = sc . nextLong ( ) ; final int [ ] h = new int [ n ] ; final int [ ] a = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) h [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = h [ i % m ] ; h [ i % m ] = ( int ) ( ( x * h [ i % m ] + y * ( i + 1 ) ) % z ) ; } final int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( a [ j ] < a [ i ] ) s [ i ] = ( s [ i ] + s [ j ] ) % 1000000007 ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count = ( count + s [ i ] ) % 1000000007 ; System . out . printf ( \" Case \u2581 # % s : \u2581 % s \\n \" , cc , count ) ; } System . out . flush ( ) ; }"]], "functions_class": []}, {"id": "16", "code": "import java . io . * ; import java . util . * ; public class Main { Scanner in ; PrintWriter out ; String IFILE = \" c - small - attempt0 . in \" ; String OFILE = \" c - small - attempt0 . out \" ; final long MOD = 1000000007 ; public void run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( OFILE ) ; int nt = in . nextInt ( ) ; for ( int it = 0 ; it < nt ; it ++ ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; long x = in . nextInt ( ) ; long y = in . nextInt ( ) ; long z = in . nextInt ( ) ; long [ ] a = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = in . nextLong ( ) ; long [ ] mas = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { mas [ i ] = a [ i % m ] ; a [ i % m ] = ( x * a [ i % m ] + y * ( i + 1 ) ) % z ; } long [ ] f = new long [ n ] ; Arrays . fill ( f , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mas [ j ] < mas [ i ] ) f [ i ] = ( f [ i ] + f [ j ] ) % MOD ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = ( ans + f [ i ] ) % MOD ; out . println ( \" Case \u2581 # \" + ( it + 1 ) + \" : \u2581 \" + ans ) ; } out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; }"]], "functions_class": [["run", "public void run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( OFILE ) ; int nt = in . nextInt ( ) ; for ( int it = 0 ; it < nt ; it ++ ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; long x = in . nextInt ( ) ; long y = in . nextInt ( ) ; long z = in . nextInt ( ) ; long [ ] a = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = in . nextLong ( ) ; long [ ] mas = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { mas [ i ] = a [ i % m ] ; a [ i % m ] = ( x * a [ i % m ] + y * ( i + 1 ) ) % z ; } long [ ] f = new long [ n ] ; Arrays . fill ( f , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mas [ j ] < mas [ i ] ) f [ i ] = ( f [ i ] + f [ j ] ) % MOD ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = ( ans + f [ i ] ) % MOD ; out . println ( \" Case \u2581 # \" + ( it + 1 ) + \" : \u2581 \" + ans ) ; } out . close ( ) ; }"]]}], "python": [{"id": "13", "code": "import sys NEW_LINE def getnext ( gen , type ) : NEW_LINE INDENT try : NEW_LINE INDENT l = gen . next ( ) . strip ( \" \\n \" ) NEW_LINE return type ( l ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT def getSpeeds ( n , A , X , Y , Z ) : NEW_LINE INDENT signs = [ ] NEW_LINE m = len ( A ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT signs . append ( A [ i % m ] ) NEW_LINE A [ i % m ] = ( X * A [ i % m ] + Y * ( i + 1 ) ) % Z NEW_LINE DEDENT return signs NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT infile = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE reader = infile . xreadlines ( ) NEW_LINE outfile = open ( sys . argv [ 1 ] + ' - output ' , ' w ' ) NEW_LINE nCases = getnext ( reader , int ) NEW_LINE for case in range ( nCases ) : NEW_LINE INDENT line = [ int ( i ) for i in getnext ( reader , str ) . split ( \" \u2581 \" ) ] NEW_LINE numSigns = line [ 0 ] NEW_LINE arraySize = line [ 1 ] NEW_LINE X = line [ 2 ] NEW_LINE Y = line [ 3 ] NEW_LINE Z = line [ 4 ] NEW_LINE A = [ ] NEW_LINE for l in range ( arraySize ) : NEW_LINE INDENT A . append ( getnext ( reader , int ) ) NEW_LINE DEDENT speeds = getSpeeds ( numSigns , A , X , Y , Z ) NEW_LINE speeds . reverse ( ) NEW_LINE sinc = [ 0 ] * len ( speeds ) NEW_LINE sinc [ 0 ] = 1 NEW_LINE for s in range ( 1 , len ( speeds ) ) : NEW_LINE INDENT sinc [ s ] = 1 + sum ( sinc [ j ] for j in range ( s ) if speeds [ j ] > speeds [ s ] ) NEW_LINE DEDENT outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( case + 1 , sum ( sinc ) % 1000000007 ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["getnext", "def getnext ( gen , type ) : NEW_LINE INDENT try : NEW_LINE INDENT l = gen . next ( ) . strip ( \" \\n \" ) NEW_LINE return type ( l ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT"], ["getSpeeds", "def getSpeeds ( n , A , X , Y , Z ) : NEW_LINE INDENT signs = [ ] NEW_LINE m = len ( A ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT signs . append ( A [ i % m ] ) NEW_LINE A [ i % m ] = ( X * A [ i % m ] + Y * ( i + 1 ) ) % Z NEW_LINE DEDENT return signs NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_08_11", "java": [{"id": "9", "code": "import java . io . * ; import java . util . StringTokenizer ; import java . util . Arrays ; public class A { private String solve ( ) throws IOException { int n = nextInt ( ) ; long [ ] x = new long [ n ] ; long [ ] y = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { y [ i ] = nextInt ( ) ; } Arrays . sort ( x ) ; Arrays . sort ( y ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += x [ i ] * y [ n - 1 - i ] ; } return \" \" + ans ; } private BufferedReader reader ; private StringTokenizer tt = new StringTokenizer ( \" \" ) ; private String nextToken ( ) throws IOException { while ( ! tt . hasMoreTokens ( ) ) { tt = new StringTokenizer ( reader . readLine ( ) ) ; } return tt . nextToken ( ) ; } private int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } private void run ( ) throws IOException { reader = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; PrintWriter writer = new PrintWriter ( new File ( \" A - large . out \" ) ) ; try { int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { writer . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; writer . print ( solve ( ) ) ; writer . println ( ) ; } } finally { reader . close ( ) ; writer . close ( ) ; } } public static void main ( String [ ] args ) { try { new A ( ) . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { new A ( ) . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": [["solve", "private String solve ( ) throws IOException { int n = nextInt ( ) ; long [ ] x = new long [ n ] ; long [ ] y = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { y [ i ] = nextInt ( ) ; } Arrays . sort ( x ) ; Arrays . sort ( y ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += x [ i ] * y [ n - 1 - i ] ; } return \" \" + ans ; }"], ["nextToken", "private String nextToken ( ) throws IOException { while ( ! tt . hasMoreTokens ( ) ) { tt = new StringTokenizer ( reader . readLine ( ) ) ; } return tt . nextToken ( ) ; }"], ["nextInt", "private int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }"], ["run", "private void run ( ) throws IOException { reader = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; PrintWriter writer = new PrintWriter ( new File ( \" A - large . out \" ) ) ; try { int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { writer . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; writer . print ( solve ( ) ) ; writer . println ( ) ; } } finally { reader . close ( ) ; writer . close ( ) ; } }"]]}, {"id": "8", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class P1 { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" p1 . in \" ) ) ; String line = \" \" ; int t = Integer . parseInt ( br . readLine ( ) ) ; FileWriter out = new FileWriter ( \" p1 . out \" ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( br . readLine ( ) ) ; String v1 = br . readLine ( ) ; String v2 = br . readLine ( ) ; String [ ] vv1 = v1 . split ( \" \\\\ s + \" ) ; String [ ] vv2 = v2 . split ( \" \\\\ s + \" ) ; List < Long > iv1 = s2l ( vv1 ) ; List < Long > iv2 = s2l ( vv2 ) ; Collections . sort ( iv1 ) ; Collections . sort ( iv2 ) ; if ( iv1 . size ( ) != iv2 . size ( ) ) System . out . println ( \" Oops ! \" ) ; long res = 0 ; for ( int j = 0 ; j < iv1 . size ( ) ; j ++ ) { System . out . println ( iv1 . get ( j ) + \" \u2581 * \u2581 \" + iv2 . get ( iv1 . size ( ) - 1 - j ) ) ; res += iv1 . get ( j ) * iv2 . get ( iv1 . size ( ) - 1 - j ) ; } out . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + res + \" \\n \" ) ; System . out . println ( res ) ; } br . close ( ) ; out . close ( ) ; } private static List < Long > s2l ( String [ ] vv1 ) { List < Long > ret = new ArrayList < Long > ( vv1 . length ) ; for ( int i = 0 ; i < vv1 . length ; i ++ ) ret . add ( Long . parseLong ( vv1 [ i ] ) ) ; return ret ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" p1 . in \" ) ) ; String line = \" \" ; int t = Integer . parseInt ( br . readLine ( ) ) ; FileWriter out = new FileWriter ( \" p1 . out \" ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( br . readLine ( ) ) ; String v1 = br . readLine ( ) ; String v2 = br . readLine ( ) ; String [ ] vv1 = v1 . split ( \" \\\\ s + \" ) ; String [ ] vv2 = v2 . split ( \" \\\\ s + \" ) ; List < Long > iv1 = s2l ( vv1 ) ; List < Long > iv2 = s2l ( vv2 ) ; Collections . sort ( iv1 ) ; Collections . sort ( iv2 ) ; if ( iv1 . size ( ) != iv2 . size ( ) ) System . out . println ( \" Oops ! \" ) ; long res = 0 ; for ( int j = 0 ; j < iv1 . size ( ) ; j ++ ) { System . out . println ( iv1 . get ( j ) + \" \u2581 * \u2581 \" + iv2 . get ( iv1 . size ( ) - 1 - j ) ) ; res += iv1 . get ( j ) * iv2 . get ( iv1 . size ( ) - 1 - j ) ; } out . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + res + \" \\n \" ) ; System . out . println ( res ) ; } br . close ( ) ; out . close ( ) ; }"], ["s2l", "private static List < Long > s2l ( String [ ] vv1 ) { List < Long > ret = new ArrayList < Long > ( vv1 . length ) ; for ( int i = 0 ; i < vv1 . length ; i ++ ) ret . add ( Long . parseLong ( vv1 [ i ] ) ) ; return ret ; }"]], "functions_class": []}, {"id": "12", "code": "import java . io . * ; import java . util . * ; public class SolutionA implements Runnable { public static void main ( String [ ] args ) { new Thread ( new SolutionA ( ) ) . run ( ) ; } public void run ( ) { try { Locale . setDefault ( Locale . US ) ; br = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ; out = new PrintWriter ( FILENAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } BufferedReader br ; PrintWriter out ; StringTokenizer st ; boolean eof ; String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } private static final String FILENAME = \" A - large \" ; public void solve ( ) throws IOException { int testsn = nextInt ( ) ; for ( int test = 0 ; test < testsn ; test ++ ) { out . print ( \" Case \u2581 # \" + ( test + 1 ) + \" : \u2581 \" ) ; int n = nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextLong ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = nextLong ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += a [ i ] * b [ n - 1 - i ] ; } out . println ( ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Thread ( new SolutionA ( ) ) . run ( ) ; }"]], "functions_class": [["run", "public void run ( ) { try { Locale . setDefault ( Locale . US ) ; br = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ; out = new PrintWriter ( FILENAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"], ["nextToken", "String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; }"], ["solve", "public void solve ( ) throws IOException { int testsn = nextInt ( ) ; for ( int test = 0 ; test < testsn ; test ++ ) { out . print ( \" Case \u2581 # \" + ( test + 1 ) + \" : \u2581 \" ) ; int n = nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextLong ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = nextLong ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += a [ i ] * b [ n - 1 - i ] ; } out . println ( ans ) ; } }"]]}, {"id": "5", "code": "import java . util . * ; public class MinimumProduct { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) doCase ( i + 1 , in ) ; } private static void doCase ( int caseNum , Scanner in ) { int dims = in . nextInt ( ) ; List < Integer > v1 = new ArrayList < Integer > ( dims ) ; for ( int i = 0 ; i < dims ; i ++ ) v1 . add ( in . nextInt ( ) ) ; Collections . sort ( v1 ) ; List < Integer > v2 = new ArrayList < Integer > ( dims ) ; for ( int i = 0 ; i < dims ; i ++ ) v2 . add ( in . nextInt ( ) ) ; Collections . sort ( v2 , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return - o1 . compareTo ( o2 ) ; } } ) ; long prod = 0 ; for ( int i = 0 ; i < dims ; i ++ ) prod += v1 . get ( i ) * ( long ) v2 . get ( i ) ; System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + prod ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) doCase ( i + 1 , in ) ; }"], ["doCase", "private static void doCase ( int caseNum , Scanner in ) { int dims = in . nextInt ( ) ; List < Integer > v1 = new ArrayList < Integer > ( dims ) ; for ( int i = 0 ; i < dims ; i ++ ) v1 . add ( in . nextInt ( ) ) ; Collections . sort ( v1 ) ; List < Integer > v2 = new ArrayList < Integer > ( dims ) ; for ( int i = 0 ; i < dims ; i ++ ) v2 . add ( in . nextInt ( ) ) ; Collections . sort ( v2 , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return - o1 . compareTo ( o2 ) ; } } ) ; long prod = 0 ; for ( int i = 0 ; i < dims ; i ++ ) prod += v1 . get ( i ) * ( long ) v2 . get ( i ) ; System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + prod ) ; }"]], "functions_class": []}, {"id": "16", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Solution implements Runnable { private static final String INPUT_FILE_NAME = \" a . big . in . txt \" ; private static final String OUTPUT_FILE_NAME = \" a . big . out . txt \" ; private BufferedReader rd ; private PrintWriter wr ; public static void main ( String [ ] args ) { new Thread ( new Solution ( ) ) . start ( ) ; } public void run ( ) { try { solve ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } void solve ( ) throws IOException { rd = new BufferedReader ( new FileReader ( Solution . INPUT_FILE_NAME ) ) ; wr = new PrintWriter ( Solution . OUTPUT_FILE_NAME ) ; String line = rd . readLine ( ) ; StringTokenizer st = new StringTokenizer ( line ) ; int nn = Integer . parseInt ( st . nextToken ( ) ) ; for ( int ii = 0 ; ii < nn ; ++ ii ) { subSolve ( ii ) ; } rd . close ( ) ; wr . close ( ) ; } private void subSolve ( int ii ) throws IOException { String line = rd . readLine ( ) ; StringTokenizer st = new StringTokenizer ( line ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; line = rd . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } line = rd . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < n ; ++ i ) { b [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; long result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result += ( a [ i ] * b [ n - i - 1 ] ) ; } wr . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , ii + 1 , result ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Thread ( new Solution ( ) ) . start ( ) ; }"]], "functions_class": [["run", "public void run ( ) { try { solve ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }"], ["solve", "void solve ( ) throws IOException { rd = new BufferedReader ( new FileReader ( Solution . INPUT_FILE_NAME ) ) ; wr = new PrintWriter ( Solution . OUTPUT_FILE_NAME ) ; String line = rd . readLine ( ) ; StringTokenizer st = new StringTokenizer ( line ) ; int nn = Integer . parseInt ( st . nextToken ( ) ) ; for ( int ii = 0 ; ii < nn ; ++ ii ) { subSolve ( ii ) ; } rd . close ( ) ; wr . close ( ) ; }"], ["subSolve", "private void subSolve ( int ii ) throws IOException { String line = rd . readLine ( ) ; StringTokenizer st = new StringTokenizer ( line ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; line = rd . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } line = rd . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < n ; ++ i ) { b [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; long result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result += ( a [ i ] * b [ n - i - 1 ] ) ; } wr . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , ii + 1 , result ) ) ; }"]]}], "python": [{"id": "9", "code": "import sys NEW_LINE if ( __name__ == ' _ _ main _ _ ' ) : NEW_LINE INDENT tc_count = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( tc_count ) : NEW_LINE INDENT sys . stdin . readline ( ) NEW_LINE v1 = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v2 = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE v2 . reverse ( ) NEW_LINE msp = 0 NEW_LINE assert ( len ( v1 ) == len ( v2 ) ) NEW_LINE for j in range ( len ( v1 ) ) : NEW_LINE INDENT msp += v1 [ j ] * v2 [ j ] NEW_LINE DEDENT sys . stdout . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( i + 1 , msp ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "14", "code": "import sys NEW_LINE argv = sys . argv [ 1 : ] NEW_LINE testFile = open ( argv [ 0 ] + ' . in ' , ' rb ' ) NEW_LINE outFile = open ( argv [ 0 ] + ' . out ' , ' wb ' ) NEW_LINE nCases = int ( testFile . readline ( ) ) NEW_LINE for i in xrange ( 1 , nCases + 1 ) : NEW_LINE INDENT n = int ( testFile . readline ( ) ) NEW_LINE v1 = sorted ( int ( val ) for val in testFile . readline ( ) . split ( ) ) NEW_LINE v2 = sorted ( int ( val ) for val in testFile . readline ( ) . split ( ) ) NEW_LINE v2 = v2 [ : : - 1 ] NEW_LINE outFile . write ( ' Case \u2581 # % i : \u2581 % i \\n ' % ( i , sum ( a * b for a , b in zip ( v1 , v2 ) ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "import sys NEW_LINE _TYPE = { ' d ' : int , ' l ' : long , ' f ' : float , ' s ' : str } NEW_LINE _buffer = [ ] NEW_LINE def next_token ( ) : NEW_LINE INDENT if not _buffer : NEW_LINE INDENT line = sys . stdin . readline ( ) NEW_LINE _buffer . extend ( line . split ( ) ) NEW_LINE DEDENT return _buffer . pop ( 0 ) NEW_LINE DEDENT def scanf ( format ) : NEW_LINE INDENT if len ( format ) % 2 != 0 : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT for i in xrange ( 0 , len ( format ) , 2 ) : NEW_LINE INDENT if format [ i ] != ' % ' : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT if format [ i + 1 ] not in ' dfs ' : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT DEDENT result = [ ] NEW_LINE for i in xrange ( 1 , len ( format ) , 2 ) : NEW_LINE INDENT token = next_token ( ) NEW_LINE value = _TYPE [ format [ i ] ] ( token ) NEW_LINE result . append ( value ) NEW_LINE DEDENT return tuple ( result ) NEW_LINE DEDENT def printf ( format , * args ) : NEW_LINE INDENT message = format % args NEW_LINE sys . stdout . write ( message ) NEW_LINE return len ( message ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n , = scanf ( ' % d ' ) NEW_LINE v1 = list ( scanf ( ' % d ' * n ) ) NEW_LINE v2 = list ( scanf ( ' % d ' * n ) ) NEW_LINE v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE msp = sum ( x * y for x , y in zip ( v1 , v2 [ : : - 1 ] ) ) NEW_LINE return msp NEW_LINE DEDENT num_cases , = scanf ( ' % d ' ) NEW_LINE for case_num in xrange ( num_cases ) : NEW_LINE INDENT result = solve ( ) NEW_LINE printf ( ' Case \u2581 # % d : \u2581 % s \\n ' , case_num + 1 , result ) NEW_LINE DEDENT", "functions_standalone": [["next_token", "def next_token ( ) : NEW_LINE INDENT if not _buffer : NEW_LINE INDENT line = sys . stdin . readline ( ) NEW_LINE _buffer . extend ( line . split ( ) ) NEW_LINE DEDENT return _buffer . pop ( 0 ) NEW_LINE DEDENT"], ["printf", "def printf ( format , * args ) : NEW_LINE INDENT message = format % args NEW_LINE sys . stdout . write ( message ) NEW_LINE return len ( message ) NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT n , = scanf ( ' % d ' ) NEW_LINE v1 = list ( scanf ( ' % d ' * n ) ) NEW_LINE v2 = list ( scanf ( ' % d ' * n ) ) NEW_LINE v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE msp = sum ( x * y for x , y in zip ( v1 , v2 [ : : - 1 ] ) ) NEW_LINE return msp NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "import sys , math NEW_LINE def dist ( p1 , p2 ) : NEW_LINE INDENT x1 , y1 = p1 NEW_LINE x2 , y2 = p2 NEW_LINE return pyth ( x2 - x1 , y2 - y1 ) NEW_LINE DEDENT def pyth ( s1 , s2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( s1 , 2 ) + math . pow ( s2 , 2 ) ) NEW_LINE DEDENT def cArea ( r ) : NEW_LINE INDENT return math . pi * math . pow ( r , 2 ) NEW_LINE DEDENT def rectArea ( l , w ) : NEW_LINE INDENT return l * w NEW_LINE DEDENT def triArea ( s1 , s2 , s3 ) : NEW_LINE INDENT s = ( s1 + s2 + s3 ) / 2 NEW_LINE return s * ( s - s1 ) * ( s - s2 ) * ( s - s3 ) NEW_LINE DEDENT def main ( v1 , v2 ) : NEW_LINE INDENT v1 . sort ( ) NEW_LINE v2 . sort ( lambda a , b : cmp ( b , a ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT sum += ( v1 [ i ] * v2 [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def getline ( fpin , types ) : NEW_LINE INDENT args = fpin . readline ( ) . strip ( ) . split ( ) NEW_LINE for i in range ( len ( types ) ) : NEW_LINE INDENT args [ i ] = types [ i ] ( args [ i ] ) NEW_LINE DEDENT return args NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fpin = open ( sys . argv [ 1 ] ) NEW_LINE if len ( sys . argv ) > 2 : NEW_LINE INDENT fpout = open ( sys . argv [ 2 ] , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT fpout = sys . stdout NEW_LINE DEDENT cases = int ( fpin . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT s = int ( fpin . readline ( ) . strip ( ) ) NEW_LINE v1 = [ int ( x ) for x in fpin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v2 = [ int ( x ) for x in fpin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE fpout . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( case , main ( v1 , v2 ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["dist", "def dist ( p1 , p2 ) : NEW_LINE INDENT x1 , y1 = p1 NEW_LINE x2 , y2 = p2 NEW_LINE return pyth ( x2 - x1 , y2 - y1 ) NEW_LINE DEDENT"], ["pyth", "def pyth ( s1 , s2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( s1 , 2 ) + math . pow ( s2 , 2 ) ) NEW_LINE DEDENT"], ["cArea", "def cArea ( r ) : NEW_LINE INDENT return math . pi * math . pow ( r , 2 ) NEW_LINE DEDENT"], ["rectArea", "def rectArea ( l , w ) : NEW_LINE INDENT return l * w NEW_LINE DEDENT"], ["triArea", "def triArea ( s1 , s2 , s3 ) : NEW_LINE INDENT s = ( s1 + s2 + s3 ) / 2 NEW_LINE return s * ( s - s1 ) * ( s - s2 ) * ( s - s3 ) NEW_LINE DEDENT"], ["main", "def main ( v1 , v2 ) : NEW_LINE INDENT v1 . sort ( ) NEW_LINE v2 . sort ( lambda a , b : cmp ( b , a ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT sum += ( v1 [ i ] * v2 [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT"], ["getline", "def getline ( fpin , types ) : NEW_LINE INDENT args = fpin . readline ( ) . strip ( ) . split ( ) NEW_LINE for i in range ( len ( types ) ) : NEW_LINE INDENT args [ i ] = types [ i ] ( args [ i ] ) NEW_LINE DEDENT return args NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "filename = \" A - large . in \" NEW_LINE f = open ( filename , ' r ' ) NEW_LINE of = open ( \" A - large . out \" , ' w ' ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for x in xrange ( N ) : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE a = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE b = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE a = [ int ( y ) for y in a ] NEW_LINE b = [ int ( y ) for y in b ] NEW_LINE a . sort ( ) NEW_LINE b . sort ( reverse = True ) NEW_LINE s = 0 NEW_LINE for y in xrange ( len ( a ) ) : NEW_LINE INDENT s += a [ y ] * b [ y ] NEW_LINE DEDENT print >> of , \" Case \u2581 # % d : \u2581 % d \" % ( x + 1 , s ) NEW_LINE DEDENT f . close ( ) NEW_LINE of . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_08_42", "java": [{"id": "9", "code": "import java . io . * ; import java . util . StringTokenizer ; public class B { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" b . out \" ) ; int C = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 1 ; i <= C ; i ++ ) { StringTokenizer tz = new StringTokenizer ( in . readLine ( ) ) ; int N = Integer . parseInt ( tz . nextToken ( ) ) ; int M = Integer . parseInt ( tz . nextToken ( ) ) ; int A = Integer . parseInt ( tz . nextToken ( ) ) ; String ans ; if ( A > N * M ) { ans = \" IMPOSSIBLE \" ; } else { int a = A / M ; int b , c = 1 , d = M ; if ( a * M == A ) { b = 0 ; } else { a ++ ; b = a * d - A ; } ans = \"0 \u2581 0 \u2581 \" + a + \" \u2581 \" + b + \" \u2581 \" + c + \" \u2581 \" + d ; } out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + ans ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( \" b . out \" ) ; int C = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 1 ; i <= C ; i ++ ) { StringTokenizer tz = new StringTokenizer ( in . readLine ( ) ) ; int N = Integer . parseInt ( tz . nextToken ( ) ) ; int M = Integer . parseInt ( tz . nextToken ( ) ) ; int A = Integer . parseInt ( tz . nextToken ( ) ) ; String ans ; if ( A > N * M ) { ans = \" IMPOSSIBLE \" ; } else { int a = A / M ; int b , c = 1 , d = M ; if ( a * M == A ) { b = 0 ; } else { a ++ ; b = a * d - A ; } ans = \"0 \u2581 0 \u2581 \" + a + \" \u2581 \" + b + \" \u2581 \" + c + \" \u2581 \" + d ; } out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + ans ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . Locale ; public class B implements Runnable { static final String NAME = \" b - large \" ; public void solve ( ) throws Exception { int ntest = Integer . parseInt ( readWord ( ) ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { long n = Long . parseLong ( readWord ( ) ) ; long m = Long . parseLong ( readWord ( ) ) ; long a = Long . parseLong ( readWord ( ) ) ; if ( a > n * m ) { stdout . write ( \" Case \u2581 # \" + test + \" : \u2581 \" + \" IMPOSSIBLE \\n \" ) ; continue ; } long s = a % n ; if ( s == 0 ) { stdout . write ( \" Case \u2581 # \" + test + \" : \u2581 \" + \"0 \u2581 0 \u2581 \" + n + \" \u2581 \" + 0 + \" \u2581 \" + n + \" \u2581 \" + ( a / n ) + \" \\n \" ) ; } else { stdout . write ( \" Case \u2581 # \" + test + \" : \u2581 \" + \"0 \u2581 0 \u2581 \" + n + \" \u2581 \" + 1 + \" \u2581 \" + ( n - s ) + \" \u2581 \" + ( a / n + 1 ) + \" \\n \" ) ; } } } static BufferedReader stdin ; static BufferedWriter stdout ; String readWord ( ) throws Exception { StringBuilder b = new StringBuilder ( ) ; int c ; while ( true ) { c = stdin . read ( ) ; if ( c < 0 ) { return \" \" ; } if ( c > 32 ) { break ; } } while ( true ) { b . append ( ( char ) c ) ; c = stdin . read ( ) ; if ( c <= 32 ) { break ; } } return b . toString ( ) ; } public void run ( ) { try { stdin = new BufferedReader ( new FileReader ( NAME + \" . in \" ) ) ; stdout = new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ; solve ( ) ; stdout . close ( ) ; stdin . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) { try { Locale . setDefault ( Locale . US ) ; } catch ( Throwable e ) { } new Thread ( new B ( ) ) . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { Locale . setDefault ( Locale . US ) ; } catch ( Throwable e ) { } new Thread ( new B ( ) ) . start ( ) ; }"]], "functions_class": [["solve", "public void solve ( ) throws Exception { int ntest = Integer . parseInt ( readWord ( ) ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { long n = Long . parseLong ( readWord ( ) ) ; long m = Long . parseLong ( readWord ( ) ) ; long a = Long . parseLong ( readWord ( ) ) ; if ( a > n * m ) { stdout . write ( \" Case \u2581 # \" + test + \" : \u2581 \" + \" IMPOSSIBLE \\n \" ) ; continue ; } long s = a % n ; if ( s == 0 ) { stdout . write ( \" Case \u2581 # \" + test + \" : \u2581 \" + \"0 \u2581 0 \u2581 \" + n + \" \u2581 \" + 0 + \" \u2581 \" + n + \" \u2581 \" + ( a / n ) + \" \\n \" ) ; } else { stdout . write ( \" Case \u2581 # \" + test + \" : \u2581 \" + \"0 \u2581 0 \u2581 \" + n + \" \u2581 \" + 1 + \" \u2581 \" + ( n - s ) + \" \u2581 \" + ( a / n + 1 ) + \" \\n \" ) ; } } }"], ["readWord", "String readWord ( ) throws Exception { StringBuilder b = new StringBuilder ( ) ; int c ; while ( true ) { c = stdin . read ( ) ; if ( c < 0 ) { return \" \" ; } if ( c > 32 ) { break ; } } while ( true ) { b . append ( ( char ) c ) ; c = stdin . read ( ) ; if ( c <= 32 ) { break ; } } return b . toString ( ) ; }"], ["run", "public void run ( ) { try { stdin = new BufferedReader ( new FileReader ( NAME + \" . in \" ) ) ; stdout = new BufferedWriter ( new FileWriter ( NAME + \" . out \" ) ) ; solve ( ) ; stdout . close ( ) ; stdin . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"]]}, {"id": "13", "code": "import java . io . PrintWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . util . Scanner ; public class B { static Scanner in ; static PrintWriter out ; public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new File ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( ) ) ; } out . close ( ) ; } private Object solve ( ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int a = in . nextInt ( ) ; boolean [ ] q = new boolean [ n * m + 1 ] ; int [ ] xx = new int [ n * m + 1 ] ; int [ ] yy = new int [ n * m + 1 ] ; for ( int x = 0 ; x <= n ; x ++ ) { for ( int y = 0 ; y <= m ; y ++ ) { int z = ( x * y ) ; q [ z ] = true ; xx [ z ] = x ; yy [ z ] = y ; } } for ( int i = 0 ; i <= ( n * m - a ) ; i ++ ) { if ( q [ i ] && q [ i + a ] ) { return \"0 \u2581 0 \u2581 \" + xx [ i ] + \" \u2581 \" + yy [ i + a ] + \" \u2581 \" + xx [ i + a ] + \" \u2581 \" + yy [ i ] ; } } return \" IMPOSSIBLE \" ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new File ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( ) ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private Object solve ( ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int a = in . nextInt ( ) ; boolean [ ] q = new boolean [ n * m + 1 ] ; int [ ] xx = new int [ n * m + 1 ] ; int [ ] yy = new int [ n * m + 1 ] ; for ( int x = 0 ; x <= n ; x ++ ) { for ( int y = 0 ; y <= m ; y ++ ) { int z = ( x * y ) ; q [ z ] = true ; xx [ z ] = x ; yy [ z ] = y ; } } for ( int i = 0 ; i <= ( n * m - a ) ; i ++ ) { if ( q [ i ] && q [ i + a ] ) { return \"0 \u2581 0 \u2581 \" + xx [ i ] + \" \u2581 \" + yy [ i + a ] + \" \u2581 \" + xx [ i + a ] + \" \u2581 \" + yy [ i ] ; } } return \" IMPOSSIBLE \" ; }"]]}, {"id": "0", "code": "import java . io . * ; import java . util . * ; public class B implements Runnable { private Scanner in ; private PrintWriter out ; private void solve ( int testCase ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int a = in . nextInt ( ) ; if ( a > n * m ) { out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 IMPOSSIBLE \" ) ; return ; } int p = a - a % n ; if ( p < a ) p += n ; int y3 = p / n ; int x3 = p - a ; out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 0 \u2581 0 \u2581 \" + n + \" \u2581 1 \u2581 \" + x3 + \" \u2581 \" + y3 ) ; } public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; new Thread ( new B ( ) ) . start ( ) ; } public void run ( ) { try { in = new Scanner ( new FileReader ( \" b . in \" ) ) ; out = new PrintWriter ( \" b . out \" ) ; int n = in . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) solve ( i ) ; in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; new Thread ( new B ( ) ) . start ( ) ; }"]], "functions_class": [["solve", "private void solve ( int testCase ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int a = in . nextInt ( ) ; if ( a > n * m ) { out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 IMPOSSIBLE \" ) ; return ; } int p = a - a % n ; if ( p < a ) p += n ; int y3 = p / n ; int x3 = p - a ; out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 0 \u2581 0 \u2581 \" + n + \" \u2581 1 \u2581 \" + x3 + \" \u2581 \" + y3 ) ; }"], ["run", "public void run ( ) { try { in = new Scanner ( new FileReader ( \" b . in \" ) ) ; out = new PrintWriter ( \" b . out \" ) ; int n = in . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) solve ( i ) ; in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }"]]}, {"id": "16", "code": "import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . InputStream ; import java . util . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; import static java . lang . Integer . * ; import static java . lang . Character . * ; public class B { Scanner scan ; InputStream in ; int intLine ( ) { return parseInt ( scan . nextLine ( ) ) ; } String find ( long A , long B , long area ) { for ( long a = 1 ; a <= A ; a ++ ) for ( long b = 1 ; b <= B ; b ++ ) { for ( long x = 0 ; x <= b ; x ++ ) for ( long y = 0 ; y <= a ; y ++ ) { long r = x * a + y * b - x * y ; if ( r == area ) { return String . format ( \" % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \" , 0 , x , y , 0 , a , b ) ; } } } return null ; } String solve ( ) { long res = 0 ; int A = scan . nextInt ( ) ; int B = scan . nextInt ( ) ; long area = scan . nextLong ( ) ; if ( find ( A , B , area ) != null ) return find ( A , B , area ) ; return \" IMPOSSIBLE \" ; } void solveAll ( ) { int N = parseInt ( scan . nextLine ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { String r = solve ( ) ; System . out . format ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , r ) ; } } B ( ) throws Exception { in = new BufferedInputStream ( new FileInputStream ( \" B - small - attempt0 . in \" ) ) ; scan = new Scanner ( in ) ; } public static void main ( String [ ] args ) throws Exception { Locale . setDefault ( Locale . US ) ; new B ( ) . solveAll ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Locale . setDefault ( Locale . US ) ; new B ( ) . solveAll ( ) ; }"]], "functions_class": [["intLine", "int intLine ( ) { return parseInt ( scan . nextLine ( ) ) ; }"], ["find", "String find ( long A , long B , long area ) { for ( long a = 1 ; a <= A ; a ++ ) for ( long b = 1 ; b <= B ; b ++ ) { for ( long x = 0 ; x <= b ; x ++ ) for ( long y = 0 ; y <= a ; y ++ ) { long r = x * a + y * b - x * y ; if ( r == area ) { return String . format ( \" % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \" , 0 , x , y , 0 , a , b ) ; } } } return null ; }"], ["solve", "String solve ( ) { long res = 0 ; int A = scan . nextInt ( ) ; int B = scan . nextInt ( ) ; long area = scan . nextLong ( ) ; if ( find ( A , B , area ) != null ) return find ( A , B , area ) ; return \" IMPOSSIBLE \" ; }"], ["solveAll", "void solveAll ( ) { int N = parseInt ( scan . nextLine ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { String r = solve ( ) ; System . out . format ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , r ) ; } }"], ["B", "B ( ) throws Exception { in = new BufferedInputStream ( new FileInputStream ( \" B - small - attempt0 . in \" ) ) ; scan = new Scanner ( in ) ; }"]]}], "python": [{"id": "8", "code": "def area2 ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT vx1 = x2 - x1 NEW_LINE vx2 = x3 - x1 NEW_LINE vy1 = y2 - y1 NEW_LINE vy2 = y3 - y1 NEW_LINE return abs ( vx1 * vy2 - vx2 * vy1 ) NEW_LINE DEDENT def find_v ( N , M , A ) : NEW_LINE INDENT for x1 in xrange ( N + 1 ) : NEW_LINE INDENT for y1 in xrange ( M + 1 ) : NEW_LINE INDENT for x2 in xrange ( N + 1 ) : NEW_LINE INDENT for y2 in xrange ( M + 1 ) : NEW_LINE INDENT if ( area2 ( 0 , 0 , x1 , y1 , x2 , y2 ) == A ) : NEW_LINE INDENT return ( 0 , x1 , x2 , 0 , y1 , y2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return None NEW_LINE DEDENT filename = \" B - small - attempt0 . in \" NEW_LINE f = open ( filename , ' r ' ) NEW_LINE of = open ( \" B - large . out \" , ' w ' ) NEW_LINE C = int ( f . readline ( ) ) NEW_LINE for x in xrange ( C ) : NEW_LINE INDENT l = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE N = int ( l [ 0 ] ) NEW_LINE M = int ( l [ 1 ] ) NEW_LINE A = int ( l [ 2 ] ) NEW_LINE points = find_v ( N , M , A ) NEW_LINE if ( points != None ) : NEW_LINE INDENT print >> of , \" Case \u2581 # % d : \u2581 % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \" % ( x + 1 , points [ 0 ] , points [ 3 ] , points [ 1 ] , points [ 4 ] , points [ 2 ] , points [ 5 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print >> of , \" Case \u2581 # % d : \u2581 IMPOSSIBLE \" % ( x + 1 ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["area2", "def area2 ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT vx1 = x2 - x1 NEW_LINE vx2 = x3 - x1 NEW_LINE vy1 = y2 - y1 NEW_LINE vy2 = y3 - y1 NEW_LINE return abs ( vx1 * vy2 - vx2 * vy1 ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "def solve ( n , m , a ) : NEW_LINE INDENT for x2 in xrange ( 0 , n + 1 ) : NEW_LINE INDENT for y1 in xrange ( 0 , m + 1 ) : NEW_LINE INDENT b = a + x2 * y1 NEW_LINE for x1 in xrange ( 1 , n + 1 ) : NEW_LINE INDENT if b % x1 == 0 and b // x1 <= m : NEW_LINE INDENT return \" % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \u2581 % d \" % ( 0 , 0 , x1 , y1 , x2 , b // x1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT for c in range ( input ( ) ) : NEW_LINE INDENT n , m , a = map ( int , raw_input ( ) . split ( ) ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( c + 1 , solve ( n , m , a ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_08_44", "java": [{"id": "14", "code": "import static java . lang . Math . * ; import static java . math . BigInteger . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import java . math . * ; import java . util . * ; public class D { char [ ] cs ; int n ; public static void main ( String [ ] args ) { new D ( ) . run ( ) ; } void run ( ) { Scanner sc = new Scanner ( System . in ) ; int on = sc . nextInt ( ) ; for ( int o = 1 ; o <= on ; o ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , o ) ; n = sc . nextInt ( ) ; cs = sc . next ( ) . toCharArray ( ) ; System . out . println ( permRec ( new int [ n ] , new boolean [ n ] , 0 ) ) ; } } int permRec ( int [ ] a , boolean [ ] used , int p ) { if ( p == a . length ) { char last = 0 ; int res = 0 ; for ( int i = 0 ; i < cs . length ; i += n ) { for ( int j = 0 ; j < n ; j ++ ) { char c = cs [ i + a [ j ] ] ; if ( c != last ) { res ++ ; last = c ; } } } return res ; } else { int res = Integer . MAX_VALUE ; for ( a [ p ] = 0 ; a [ p ] < used . length ; a [ p ] ++ ) if ( ! used [ a [ p ] ] ) { used [ a [ p ] ] = true ; res = min ( res , permRec ( a , used , p + 1 ) ) ; used [ a [ p ] ] = false ; } return res ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new D ( ) . run ( ) ; }"]], "functions_class": [["run", "void run ( ) { Scanner sc = new Scanner ( System . in ) ; int on = sc . nextInt ( ) ; for ( int o = 1 ; o <= on ; o ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , o ) ; n = sc . nextInt ( ) ; cs = sc . next ( ) . toCharArray ( ) ; System . out . println ( permRec ( new int [ n ] , new boolean [ n ] , 0 ) ) ; } }"], ["permRec", "int permRec ( int [ ] a , boolean [ ] used , int p ) { if ( p == a . length ) { char last = 0 ; int res = 0 ; for ( int i = 0 ; i < cs . length ; i += n ) { for ( int j = 0 ; j < n ; j ++ ) { char c = cs [ i + a [ j ] ] ; if ( c != last ) { res ++ ; last = c ; } } } return res ; } else { int res = Integer . MAX_VALUE ; for ( a [ p ] = 0 ; a [ p ] < used . length ; a [ p ] ++ ) if ( ! used [ a [ p ] ] ) { used [ a [ p ] ] = true ; res = min ( res , permRec ( a , used , p + 1 ) ) ; used [ a [ p ] ] = false ; } return res ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "12", "code": "import java . io . PrintWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . util . Scanner ; public class D { static Scanner in ; static PrintWriter out ; public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new File ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new D ( ) . solve ( ) ) ; } out . close ( ) ; } int k ; String s ; int [ ] p ; boolean [ ] z ; int res ; private Object solve ( ) { k = in . nextInt ( ) ; s = in . next ( ) ; p = new int [ k ] ; z = new boolean [ k ] ; res = s . length ( ) + 1 ; bt ( 0 ) ; return \" \" + res ; } private void bt ( int i ) { if ( i == k ) { char pc = ' . ' ; int r = 0 ; for ( int j = 0 ; j < s . length ( ) / k ; j ++ ) { for ( int t = 0 ; t < k ; t ++ ) { char c = s . charAt ( j * k + p [ t ] ) ; if ( c != pc ) { pc = c ; r ++ ; } } } res = Math . min ( res , r ) ; } else { for ( p [ i ] = 0 ; p [ i ] < k ; p [ i ] ++ ) if ( ! z [ p [ i ] ] ) { z [ p [ i ] ] = true ; bt ( i + 1 ) ; z [ p [ i ] ] = false ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new File ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new D ( ) . solve ( ) ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private Object solve ( ) { k = in . nextInt ( ) ; s = in . next ( ) ; p = new int [ k ] ; z = new boolean [ k ] ; res = s . length ( ) + 1 ; bt ( 0 ) ; return \" \" + res ; }"], ["bt", "private void bt ( int i ) { if ( i == k ) { char pc = ' . ' ; int r = 0 ; for ( int j = 0 ; j < s . length ( ) / k ; j ++ ) { for ( int t = 0 ; t < k ; t ++ ) { char c = s . charAt ( j * k + p [ t ] ) ; if ( c != pc ) { pc = c ; r ++ ; } } } res = Math . min ( res , r ) ; } else { for ( p [ i ] = 0 ; p [ i ] < k ; p [ i ] ++ ) if ( ! z [ p [ i ] ] ) { z [ p [ i ] ] = true ; bt ( i + 1 ) ; z [ p [ i ] ] = false ; } } }"]]}, {"id": "7", "code": "import java . util . * ; import java . io . * ; public class x { static int mn , a [ ] , l , k ; static char [ ] c1 , c2 ; static boolean [ ] b ; static void rec ( int x ) { if ( x >= k ) { for ( int j = 0 ; j < l / k ; j ++ ) for ( int d = 0 ; d < k ; d ++ ) { c2 [ k * j + a [ d ] ] = c1 [ k * j + d ] ; } ; char cc = ' @ ' ; int cnt = 0 ; for ( int j = 0 ; j < l ; j ++ ) if ( c2 [ j ] != cc ) { cc = c2 [ j ] ; ++ cnt ; } ; mn = Math . min ( cnt , mn ) ; } else { for ( int i = 0 ; i < k ; i ++ ) if ( ! b [ i ] ) { b [ i ] = true ; a [ x ] = i ; rec ( x + 1 ) ; b [ i ] = false ; } ; } ; } ; public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { k = in . nextInt ( ) ; String s = in . next ( ) ; l = s . length ( ) ; c1 = s . toCharArray ( ) ; c2 = new char [ l ] ; mn = ( int ) 1e9 ; a = new int [ k ] ; b = new boolean [ k ] ; rec ( 0 ) ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + mn ) ; } ; } ; } ;", "functions_standalone": [["rec", "static void rec ( int x ) { if ( x >= k ) { for ( int j = 0 ; j < l / k ; j ++ ) for ( int d = 0 ; d < k ; d ++ ) { c2 [ k * j + a [ d ] ] = c1 [ k * j + d ] ; } ; char cc = ' @ ' ; int cnt = 0 ; for ( int j = 0 ; j < l ; j ++ ) if ( c2 [ j ] != cc ) { cc = c2 [ j ] ; ++ cnt ; } ; mn = Math . min ( cnt , mn ) ; } else { for ( int i = 0 ; i < k ; i ++ ) if ( ! b [ i ] ) { b [ i ] = true ; a [ x ] = i ; rec ( x + 1 ) ; b [ i ] = false ; } ; } ; }"], ["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { k = in . nextInt ( ) ; String s = in . next ( ) ; l = s . length ( ) ; c1 = s . toCharArray ( ) ; c2 = new char [ l ] ; mn = ( int ) 1e9 ; a = new int [ k ] ; b = new boolean [ k ] ; rec ( 0 ) ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + mn ) ; } ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "def next_permut ( entry ) : NEW_LINE INDENT m = len ( entry ) NEW_LINE i = m - 1 NEW_LINE while ( i > 0 and entry [ i ] < entry [ i - 1 ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT entry . reverse ( ) NEW_LINE return False NEW_LINE DEDENT k = m - 1 NEW_LINE while ( entry [ k ] < entry [ i - 1 ] ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT entry [ i - 1 ] , entry [ k ] = entry [ k ] , entry [ i - 1 ] NEW_LINE x = 0 NEW_LINE while ( i + x < m - 1 - x ) : NEW_LINE INDENT entry [ i + x ] , entry [ m - 1 - x ] = entry [ m - 1 - x ] , entry [ i + x ] NEW_LINE x += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def comp_size ( s ) : NEW_LINE INDENT tot = 0 NEW_LINE last_seen = ' % ' NEW_LINE for x in xrange ( len ( s ) ) : NEW_LINE INDENT if ( s [ x ] != last_seen ) : NEW_LINE INDENT last_seen = s [ x ] NEW_LINE tot += 1 NEW_LINE DEDENT DEDENT return tot NEW_LINE DEDENT def apply_permut ( p , s ) : NEW_LINE INDENT k = len ( p ) NEW_LINE ns = [ 0 ] * len ( s ) NEW_LINE for x in xrange ( len ( s ) ) : NEW_LINE INDENT ns [ x ] = s [ p [ x % k ] + ( x // k ) * k ] NEW_LINE DEDENT return ' ' . join ( ns ) NEW_LINE DEDENT filename = \" D - small - attempt0 . in \" NEW_LINE f = open ( filename , ' r ' ) NEW_LINE of = open ( \" D - small . out \" , ' w ' ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for x in xrange ( N ) : NEW_LINE INDENT k = int ( f . readline ( ) ) NEW_LINE S = f . readline ( ) . strip ( ) NEW_LINE t = 1000000000 NEW_LINE p = [ i for i in xrange ( k ) ] NEW_LINE t = min ( t , comp_size ( apply_permut ( p , S ) ) ) NEW_LINE while ( next_permut ( p ) ) : NEW_LINE INDENT t = min ( t , comp_size ( apply_permut ( p , S ) ) ) NEW_LINE DEDENT print >> of , \" Case \u2581 # % d : \u2581 % d \" % ( x + 1 , t ) NEW_LINE DEDENT", "functions_standalone": [["next_permut", "def next_permut ( entry ) : NEW_LINE INDENT m = len ( entry ) NEW_LINE i = m - 1 NEW_LINE while ( i > 0 and entry [ i ] < entry [ i - 1 ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT entry . reverse ( ) NEW_LINE return False NEW_LINE DEDENT k = m - 1 NEW_LINE while ( entry [ k ] < entry [ i - 1 ] ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT entry [ i - 1 ] , entry [ k ] = entry [ k ] , entry [ i - 1 ] NEW_LINE x = 0 NEW_LINE while ( i + x < m - 1 - x ) : NEW_LINE INDENT entry [ i + x ] , entry [ m - 1 - x ] = entry [ m - 1 - x ] , entry [ i + x ] NEW_LINE x += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_08_31", "java": [{"id": "9", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class TaskA { private static final String TEST_NAME = \" A - large \" ; private static final String INPUT_FILE = TEST_NAME + \" . in \" ; private static final String OUTPUT_FILE = TEST_NAME + \" . out \" ; private static Scanner in ; private static PrintWriter out ; public static void main ( String [ ] args ) throws Exception { in = new Scanner ( new File ( INPUT_FILE ) ) ; out = new PrintWriter ( OUTPUT_FILE ) ; int testCasesNum = in . nextInt ( ) ; for ( int i = 0 ; i < testCasesNum ; ++ i ) { solveTestCase ( i + 1 ) ; } in . close ( ) ; out . close ( ) ; } private static void reverse ( int [ ] a ) { int med = a . length / 2 ; int len = a . length ; for ( int i = 0 ; i < med ; ++ i ) { int t = a [ i ] ; a [ i ] = a [ len - 1 - i ] ; a [ len - 1 - i ] = t ; } } private static void solveTestCase ( int testCaseID ) { int P = in . nextInt ( ) ; int K = in . nextInt ( ) ; int L = in . nextInt ( ) ; int [ ] freq = new int [ L ] ; for ( int i = 0 ; i < L ; ++ i ) { freq [ i ] = in . nextInt ( ) ; } Arrays . sort ( freq ) ; reverse ( freq ) ; int [ ] keys = new int [ K ] ; int curKey = - 1 ; long result = 0 ; for ( int i = 0 ; i < L ; ++ i ) { curKey = ( curKey + 1 ) % K ; keys [ curKey ] += 1 ; result += keys [ curKey ] * freq [ i ] ; } out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , testCaseID , result ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { in = new Scanner ( new File ( INPUT_FILE ) ) ; out = new PrintWriter ( OUTPUT_FILE ) ; int testCasesNum = in . nextInt ( ) ; for ( int i = 0 ; i < testCasesNum ; ++ i ) { solveTestCase ( i + 1 ) ; } in . close ( ) ; out . close ( ) ; }"], ["reverse", "private static void reverse ( int [ ] a ) { int med = a . length / 2 ; int len = a . length ; for ( int i = 0 ; i < med ; ++ i ) { int t = a [ i ] ; a [ i ] = a [ len - 1 - i ] ; a [ len - 1 - i ] = t ; } }"], ["solveTestCase", "private static void solveTestCase ( int testCaseID ) { int P = in . nextInt ( ) ; int K = in . nextInt ( ) ; int L = in . nextInt ( ) ; int [ ] freq = new int [ L ] ; for ( int i = 0 ; i < L ; ++ i ) { freq [ i ] = in . nextInt ( ) ; } Arrays . sort ( freq ) ; reverse ( freq ) ; int [ ] keys = new int [ K ] ; int curKey = - 1 ; long result = 0 ; for ( int i = 0 ; i < L ; ++ i ) { curKey = ( curKey + 1 ) % K ; keys [ curKey ] += 1 ; result += keys [ curKey ] * freq [ i ] ; } out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , testCaseID , result ) ) ; }"]], "functions_class": []}, {"id": "5", "code": "import java . io . * ; import java . util . * ; public class a { a ( ) { try { File f = new File ( \" A - large . in \" ) ; BufferedReader input = new BufferedReader ( new FileReader ( f ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" large . out \" ) ) ; int nrtests = Integer . parseInt ( input . readLine ( ) ) ; for ( int nrt = 0 ; nrt < nrtests ; nrt ++ ) { String [ ] spl = input . readLine ( ) . split ( \" \u2581 \" ) ; long p = Integer . parseInt ( spl [ 0 ] ) ; long k = Integer . parseInt ( spl [ 1 ] ) ; long l = Integer . parseInt ( spl [ 2 ] ) ; spl = input . readLine ( ) . split ( \" \u2581 \" ) ; int n = spl . length ; long [ ] v = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = Long . parseLong ( spl [ i ] ) ; Arrays . sort ( v ) ; String ans = \" Impossible \" ; if ( p * k >= l ) { long rez = 0 ; for ( long pas = 0 , poz = n - 1 ; pas < p ; pas ++ ) for ( long j = 0 ; j < k ; j ++ , poz -- ) if ( poz >= 0 ) rez += ( long ) ( pas + 1 ) * ( long ) v [ ( int ) poz ] ; ans = \" \" + rez ; } out . write ( \" Case \u2581 # \" + ( nrt + 1 ) + \" : \u2581 \" + ans + \" \\n \" ) ; } out . close ( ) ; } catch ( IOException e ) { } } public static void main ( String [ ] args ) { new a ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new a ( ) ; }"]], "functions_class": [["a", "a ( ) { try { File f = new File ( \" A - large . in \" ) ; BufferedReader input = new BufferedReader ( new FileReader ( f ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" large . out \" ) ) ; int nrtests = Integer . parseInt ( input . readLine ( ) ) ; for ( int nrt = 0 ; nrt < nrtests ; nrt ++ ) { String [ ] spl = input . readLine ( ) . split ( \" \u2581 \" ) ; long p = Integer . parseInt ( spl [ 0 ] ) ; long k = Integer . parseInt ( spl [ 1 ] ) ; long l = Integer . parseInt ( spl [ 2 ] ) ; spl = input . readLine ( ) . split ( \" \u2581 \" ) ; int n = spl . length ; long [ ] v = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = Long . parseLong ( spl [ i ] ) ; Arrays . sort ( v ) ; String ans = \" Impossible \" ; if ( p * k >= l ) { long rez = 0 ; for ( long pas = 0 , poz = n - 1 ; pas < p ; pas ++ ) for ( long j = 0 ; j < k ; j ++ , poz -- ) if ( poz >= 0 ) rez += ( long ) ( pas + 1 ) * ( long ) v [ ( int ) poz ] ; ans = \" \" + rez ; } out . write ( \" Case \u2581 # \" + ( nrt + 1 ) + \" : \u2581 \" + ans + \" \\n \" ) ; } out . close ( ) ; } catch ( IOException e ) { } }"]]}, {"id": "6", "code": "import java . io . FileOutputStream ; import java . io . PrintWriter ; import java . io . IOException ; import java . util . Set ; import java . util . HashSet ; import java . util . Collections ; import java . util . Arrays ; public class A { public static void main ( String [ ] args ) { try { Scanner scanner = new Scanner ( \" c : / input . txt \" ) ; FileOutputStream out = new FileOutputStream ( \" c : / output . txt \" ) ; int numberOfCases ; numberOfCases = scanner . nextInt ( ) ; PrintWriter wr = new PrintWriter ( out ) ; for ( int i = 0 ; i < numberOfCases ; i ++ ) { doCase ( i + 1 , scanner , wr ) ; } wr . close ( ) ; out . close ( ) ; } catch ( IOException e ) { System . out . println ( \" Error : \u2581 \" + e ) ; } } private static void doCase ( int caseNumber , Scanner sc , PrintWriter wr ) throws IOException { int P , K , L ; P = sc . nextInt ( ) ; K = sc . nextInt ( ) ; L = sc . nextInt ( ) ; int [ ] freq = new int [ L ] ; for ( int i = 0 ; i < L ; i ++ ) { freq [ i ] = sc . nextInt ( ) ; } Arrays . sort ( freq ) ; long result = 0 ; int keyPress = 1 ; int keyCounter = 0 ; for ( int i = L - 1 ; i >= 0 ; i -- ) { if ( ++ keyCounter > K ) { keyCounter = 1 ; keyPress ++ ; } result += freq [ i ] * keyPress ; } wr . println ( \" Case \u2581 # \" + caseNumber + \" : \u2581 \" + result ) ; System . out . println ( \" Case \u2581 # \" + caseNumber + \" : \u2581 \" + result ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { Scanner scanner = new Scanner ( \" c : / input . txt \" ) ; FileOutputStream out = new FileOutputStream ( \" c : / output . txt \" ) ; int numberOfCases ; numberOfCases = scanner . nextInt ( ) ; PrintWriter wr = new PrintWriter ( out ) ; for ( int i = 0 ; i < numberOfCases ; i ++ ) { doCase ( i + 1 , scanner , wr ) ; } wr . close ( ) ; out . close ( ) ; } catch ( IOException e ) { System . out . println ( \" Error : \u2581 \" + e ) ; } }"], ["doCase", "private static void doCase ( int caseNumber , Scanner sc , PrintWriter wr ) throws IOException { int P , K , L ; P = sc . nextInt ( ) ; K = sc . nextInt ( ) ; L = sc . nextInt ( ) ; int [ ] freq = new int [ L ] ; for ( int i = 0 ; i < L ; i ++ ) { freq [ i ] = sc . nextInt ( ) ; } Arrays . sort ( freq ) ; long result = 0 ; int keyPress = 1 ; int keyCounter = 0 ; for ( int i = L - 1 ; i >= 0 ; i -- ) { if ( ++ keyCounter > K ) { keyCounter = 1 ; keyPress ++ ; } result += freq [ i ] * keyPress ; } wr . println ( \" Case \u2581 # \" + caseNumber + \" : \u2581 \" + result ) ; System . out . println ( \" Case \u2581 # \" + caseNumber + \" : \u2581 \" + result ) ; }"]], "functions_class": []}, {"id": "8", "code": "package indy . codejam ; import java . io . * ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . util . * ; import java . math . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; import static java . lang . Double . parseDouble ; import static java . lang . Float . parseFloat ; import static java . lang . Long . parseLong ; import static java . lang . Integer . parseInt ; public class TextMessagingOutrage { public static void main ( String [ ] args ) throws Exception { String name = \" A - large \" ; String path = \" C : / codejam / \" ; Scanner sc = new Scanner ( new File ( path + name + \" . in \" ) ) ; PrintWriter pw = new PrintWriter ( path + name + \" . out \" ) ; int N = sc . nextInt ( ) ; for ( int z = 1 ; z <= N ; z ++ ) { int P = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; long [ ] f = new long [ L ] ; for ( int i = 0 ; i < L ; i ++ ) { f [ i ] = sc . nextLong ( ) ; } sort ( f ) ; long res = 0 ; for ( int i = 0 ; i < L ; i ++ ) { long r = i / K + 1 ; res += f [ L - 1 - i ] * r ; } pw . print ( \" Case \u2581 # \" + z + \" : \u2581 \" + res ) ; pw . println ( ) ; pw . flush ( ) ; } pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String name = \" A - large \" ; String path = \" C : / codejam / \" ; Scanner sc = new Scanner ( new File ( path + name + \" . in \" ) ) ; PrintWriter pw = new PrintWriter ( path + name + \" . out \" ) ; int N = sc . nextInt ( ) ; for ( int z = 1 ; z <= N ; z ++ ) { int P = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; long [ ] f = new long [ L ] ; for ( int i = 0 ; i < L ; i ++ ) { f [ i ] = sc . nextLong ( ) ; } sort ( f ) ; long res = 0 ; for ( int i = 0 ; i < L ; i ++ ) { long r = i / K + 1 ; res += f [ L - 1 - i ] * r ; } pw . print ( \" Case \u2581 # \" + z + \" : \u2581 \" + res ) ; pw . println ( ) ; pw . flush ( ) ; } pw . close ( ) ; }"]], "functions_class": []}, {"id": "12", "code": "package gcj ; import java . io . BufferedReader ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . StringTokenizer ; public class MainA { public static void reverse ( int [ ] p ) { int i = 0 , j = p . length - 1 ; while ( i < j ) { int a = p [ i ] ; p [ i ] = p [ j ] ; p [ j ] = a ; i ++ ; j -- ; } } public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader cin = new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" D : \\\\ topcoder \\\\ eclipse - workspace \\\\ ACM \\\\ gcj \\\\ A - small . in \" ) ) ) ; PrintWriter out = new PrintWriter ( \" D : \\\\ topcoder \\\\ eclipse - workspace \\\\ ACM \\\\ gcj \\\\ Aout . txt \" ) ; int testcase = Integer . parseInt ( cin . readLine ( ) ) ; for ( int tst = 1 ; tst <= testcase ; tst ++ ) { int P , K , L ; StringTokenizer st = new StringTokenizer ( cin . readLine ( ) ) ; P = Integer . parseInt ( st . nextToken ( ) ) ; K = Integer . parseInt ( st . nextToken ( ) ) ; L = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] hits = new int [ L ] ; st = new StringTokenizer ( cin . readLine ( ) ) ; for ( int i = 0 ; i < L ; i ++ ) hits [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; Arrays . sort ( hits ) ; reverse ( hits ) ; long res = 0 ; for ( int i = 0 ; i < hits . length ; i ++ ) { res += ( i / K + 1 ) * hits [ i ] ; } out . println ( \" Case \u2581 # \" + tst + \" : \u2581 \" + res ) ; } out . close ( ) ; } }", "functions_standalone": [["reverse", "public static void reverse ( int [ ] p ) { int i = 0 , j = p . length - 1 ; while ( i < j ) { int a = p [ i ] ; p [ i ] = p [ j ] ; p [ j ] = a ; i ++ ; j -- ; } }"]], "functions_class": [["StringTokenizer", "tst ++ ) { int P , K , L ; StringTokenizer st = new StringTokenizer ( cin . readLine ( ) ) ; P = Integer . parseInt ( st . nextToken ( ) ) ; K = Integer . parseInt ( st . nextToken ( ) ) ; L = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] hits = new int [ L ] ; st = new StringTokenizer ( cin . readLine ( ) ) ; for ( int i = 0 ; i < L ; i ++ ) hits [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; Arrays . sort ( hits ) ; reverse ( hits ) ; long res = 0 ; for ( int i = 0 ; i < hits . length ; i ++ ) { res += ( i / K + 1 ) * hits [ i ] ; } out . println ( \" Case \u2581 # \" + tst + \" : \u2581 \" + res ) ; }"]]}], "python": [{"id": "7", "code": "fin = open ( \" b . in \" , \" r \" ) NEW_LINE n = int ( fin . readline ( ) ) NEW_LINE fout = open ( \" b . out \" , \" w \" ) NEW_LINE for i in xrange ( 1 , n + 1 ) : NEW_LINE INDENT p , k , l = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE freqs = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE if p * k < l : NEW_LINE INDENT print >> fout , \" Case \u2581 # % d : \u2581 Impossible \" % i NEW_LINE DEDENT else : NEW_LINE INDENT freqs . sort ( lambda a , b : b - a ) NEW_LINE total = 0 NEW_LINE for j in xrange ( 1 , p + 1 ) : NEW_LINE INDENT total += sum ( freqs [ : k ] ) * j NEW_LINE freqs = freqs [ k : ] NEW_LINE if len ( freqs ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print >> fout , \" Case \u2581 # % d : \u2581 % d \" % ( i , total ) NEW_LINE DEDENT DEDENT fout . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_08_54", "java": [{"id": "19", "code": "import java . util . Scanner ; public class EndlessKnight { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) doCase ( i + 1 , in ) ; } private static void doCase ( int caseNum , Scanner in ) { int H = in . nextInt ( ) ; int W = in . nextInt ( ) ; int R = in . nextInt ( ) ; int [ ] [ ] memoized = new int [ W ] [ H ] ; for ( int [ ] arr : memoized ) for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = - 1 ; for ( int i = 0 ; i < R ; i ++ ) { int rockY = in . nextInt ( ) ; int rockX = in . nextInt ( ) ; memoized [ W - rockX ] [ H - rockY ] = 0 ; } int total = findMoves ( W - 1 , H - 1 , memoized ) ; System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + total ) ; } private static int findMoves ( int i , int j , int [ ] [ ] memoized ) { if ( i == 0 && j == 0 ) return 1 ; if ( i < 1 || j < 1 ) return 0 ; if ( memoized [ i ] [ j ] != - 1 ) return memoized [ i ] [ j ] ; memoized [ i ] [ j ] = ( findMoves ( i - 1 , j - 2 , memoized ) + findMoves ( i - 2 , j - 1 , memoized ) ) % 10007 ; return memoized [ i ] [ j ] ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) doCase ( i + 1 , in ) ; }"], ["doCase", "private static void doCase ( int caseNum , Scanner in ) { int H = in . nextInt ( ) ; int W = in . nextInt ( ) ; int R = in . nextInt ( ) ; int [ ] [ ] memoized = new int [ W ] [ H ] ; for ( int [ ] arr : memoized ) for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = - 1 ; for ( int i = 0 ; i < R ; i ++ ) { int rockY = in . nextInt ( ) ; int rockX = in . nextInt ( ) ; memoized [ W - rockX ] [ H - rockY ] = 0 ; } int total = findMoves ( W - 1 , H - 1 , memoized ) ; System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + total ) ; }"], ["findMoves", "private static int findMoves ( int i , int j , int [ ] [ ] memoized ) { if ( i == 0 && j == 0 ) return 1 ; if ( i < 1 || j < 1 ) return 0 ; if ( memoized [ i ] [ j ] != - 1 ) return memoized [ i ] [ j ] ; memoized [ i ] [ j ] = ( findMoves ( i - 1 , j - 2 , memoized ) + findMoves ( i - 2 , j - 1 , memoized ) ) % 10007 ; return memoized [ i ] [ j ] ; }"]], "functions_class": []}, {"id": "7", "code": "import java . util . * ; public class DSmall { static final int P = 10007 ; public static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= N ; caseID ++ ) { int H = sc . nextInt ( ) ; int W = sc . nextInt ( ) ; int R = sc . nextInt ( ) ; boolean [ ] [ ] rock = new boolean [ H ] [ W ] ; for ( int i = 0 ; i < R ; i ++ ) { int r = sc . nextInt ( ) - 1 ; int c = sc . nextInt ( ) - 1 ; rock [ r ] [ c ] = true ; } int [ ] [ ] count = new int [ H + 2 ] [ W + 2 ] ; count [ 0 ] [ 0 ] = 1 ; for ( int y = 0 ; y < H ; y ++ ) { for ( int x = 0 ; x < W ; x ++ ) { if ( rock [ y ] [ x ] ) continue ; count [ y + 2 ] [ x + 1 ] += count [ y ] [ x ] ; count [ y + 2 ] [ x + 1 ] %= P ; count [ y + 1 ] [ x + 2 ] += count [ y ] [ x ] ; count [ y + 1 ] [ x + 2 ] %= P ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , caseID , count [ H - 1 ] [ W - 1 ] ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int N = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= N ; caseID ++ ) { int H = sc . nextInt ( ) ; int W = sc . nextInt ( ) ; int R = sc . nextInt ( ) ; boolean [ ] [ ] rock = new boolean [ H ] [ W ] ; for ( int i = 0 ; i < R ; i ++ ) { int r = sc . nextInt ( ) - 1 ; int c = sc . nextInt ( ) - 1 ; rock [ r ] [ c ] = true ; } int [ ] [ ] count = new int [ H + 2 ] [ W + 2 ] ; count [ 0 ] [ 0 ] = 1 ; for ( int y = 0 ; y < H ; y ++ ) { for ( int x = 0 ; x < W ; x ++ ) { if ( rock [ y ] [ x ] ) continue ; count [ y + 2 ] [ x + 1 ] += count [ y ] [ x ] ; count [ y + 2 ] [ x + 1 ] %= P ; count [ y + 1 ] [ x + 2 ] += count [ y ] [ x ] ; count [ y + 1 ] [ x + 2 ] %= P ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , caseID , count [ H - 1 ] [ W - 1 ] ) ; } }"]], "functions_class": []}, {"id": "1", "code": "import static java . lang . Math . * ; import static java . math . BigInteger . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import java . math . * ; import java . util . * ; public class D { public static void main ( String [ ] args ) { new D ( ) . run ( ) ; } long M = 10007 ; static final int [ ] di = { 1 , 2 } , dj = { 2 , 1 } ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; int on = sc . nextInt ( ) ; for ( int o = 1 ; o <= on ; o ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , o ) ; int h = sc . nextInt ( ) , w = sc . nextInt ( ) , r = sc . nextInt ( ) ; boolean [ ] [ ] bs = new boolean [ h ] [ w ] ; for ( int i = 0 ; i < r ; i ++ ) bs [ sc . nextInt ( ) - 1 ] [ sc . nextInt ( ) - 1 ] = true ; long [ ] [ ] dp = new long [ h ] [ w ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) if ( ! bs [ i ] [ j ] ) { for ( int k = 0 ; k < 2 ; k ++ ) { int ii = i + di [ k ] , jj = j + dj [ k ] ; if ( ii < h && jj < w ) dp [ ii ] [ jj ] = ( dp [ ii ] [ jj ] + dp [ i ] [ j ] ) % M ; } } } System . out . println ( dp [ h - 1 ] [ w - 1 ] ) ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new D ( ) . run ( ) ; }"]], "functions_class": [["run", "void run ( ) { Scanner sc = new Scanner ( System . in ) ; int on = sc . nextInt ( ) ; for ( int o = 1 ; o <= on ; o ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , o ) ; int h = sc . nextInt ( ) , w = sc . nextInt ( ) , r = sc . nextInt ( ) ; boolean [ ] [ ] bs = new boolean [ h ] [ w ] ; for ( int i = 0 ; i < r ; i ++ ) bs [ sc . nextInt ( ) - 1 ] [ sc . nextInt ( ) - 1 ] = true ; long [ ] [ ] dp = new long [ h ] [ w ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) if ( ! bs [ i ] [ j ] ) { for ( int k = 0 ; k < 2 ; k ++ ) { int ii = i + di [ k ] , jj = j + dj [ k ] ; if ( ii < h && jj < w ) dp [ ii ] [ jj ] = ( dp [ ii ] [ jj ] + dp [ i ] [ j ] ) % M ; } } } System . out . println ( dp [ h - 1 ] [ w - 1 ] ) ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "8", "code": "import java . io . PrintWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . util . Scanner ; public class D { static Scanner in ; static PrintWriter out ; public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new File ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new D ( ) . solve ( ) ) ; } out . close ( ) ; } private Object solve ( ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int r = in . nextInt ( ) ; boolean [ ] [ ] a = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < r ; i ++ ) { a [ in . nextInt ( ) - 1 ] [ in . nextInt ( ) - 1 ] = true ; } int [ ] [ ] d = new int [ n ] [ m ] ; d [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < m ; j ++ ) if ( ! a [ i ] [ j ] ) { if ( i > 1 ) { d [ i ] [ j ] += d [ i - 2 ] [ j - 1 ] ; } if ( j > 1 ) { d [ i ] [ j ] += d [ i - 1 ] [ j - 2 ] ; } d [ i ] [ j ] %= 10007 ; } } return d [ n - 1 ] [ m - 1 ] ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new File ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new D ( ) . solve ( ) ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private Object solve ( ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int r = in . nextInt ( ) ; boolean [ ] [ ] a = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < r ; i ++ ) { a [ in . nextInt ( ) - 1 ] [ in . nextInt ( ) - 1 ] = true ; } int [ ] [ ] d = new int [ n ] [ m ] ; d [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < m ; j ++ ) if ( ! a [ i ] [ j ] ) { if ( i > 1 ) { d [ i ] [ j ] += d [ i - 2 ] [ j - 1 ] ; } if ( j > 1 ) { d [ i ] [ j ] += d [ i - 1 ] [ j - 2 ] ; } d [ i ] [ j ] %= 10007 ; } } return d [ n - 1 ] [ m - 1 ] ; }"]]}, {"id": "11", "code": "import java . util . * ; import java . io . * ; public class x { static int fla ( int p , int q ) { int ti = 2 * q - p ; int tj = 2 * p - q ; if ( ti % 3 != 0 || tj % 3 != 0 ) return 0 ; ti /= 3 ; tj /= 3 ; return 0 ; } ; public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { int h = in . nextInt ( ) ; int w = in . nextInt ( ) ; int r = in . nextInt ( ) ; int [ ] a = new int [ r ] , b = new int [ r ] ; boolean [ ] [ ] f = new boolean [ h + 1 ] [ w + 1 ] ; for ( int i = 0 ; i < r ; i ++ ) { a [ i ] = in . nextInt ( ) ; b [ i ] = in . nextInt ( ) ; f [ a [ i ] ] [ b [ i ] ] = true ; } ; int [ ] [ ] D = new int [ h + 1 ] [ w + 1 ] ; D [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) for ( int j = 2 ; j <= w ; j ++ ) if ( ! f [ i ] [ j ] ) D [ i ] [ j ] += ( D [ i - 2 ] [ j - 1 ] + D [ i - 1 ] [ j - 2 ] ) % 10007 ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + D [ h ] [ w ] ) ; } ; } ; } ;", "functions_standalone": [["fla", "static int fla ( int p , int q ) { int ti = 2 * q - p ; int tj = 2 * p - q ; if ( ti % 3 != 0 || tj % 3 != 0 ) return 0 ; ti /= 3 ; tj /= 3 ; return 0 ; }"], ["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int tt = 1 ; tt <= t ; tt ++ ) { int h = in . nextInt ( ) ; int w = in . nextInt ( ) ; int r = in . nextInt ( ) ; int [ ] a = new int [ r ] , b = new int [ r ] ; boolean [ ] [ ] f = new boolean [ h + 1 ] [ w + 1 ] ; for ( int i = 0 ; i < r ; i ++ ) { a [ i ] = in . nextInt ( ) ; b [ i ] = in . nextInt ( ) ; f [ a [ i ] ] [ b [ i ] ] = true ; } ; int [ ] [ ] D = new int [ h + 1 ] [ w + 1 ] ; D [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) for ( int j = 2 ; j <= w ; j ++ ) if ( ! f [ i ] [ j ] ) D [ i ] [ j ] += ( D [ i - 2 ] [ j - 1 ] + D [ i - 1 ] [ j - 2 ] ) % 10007 ; System . out . println ( \" Case \u2581 # \" + tt + \" : \u2581 \" + D [ h ] [ w ] ) ; } ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "rocks = { } NEW_LINE num_ways = { } NEW_LINE mod = 10007 NEW_LINE def num_u_ways ( r , c , H , W ) : NEW_LINE INDENT if ( r >= H or c >= W ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( r , c ) in rocks ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( r == H - 1 and c == W - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( ( r , c ) in num_ways ) : NEW_LINE INDENT return num_ways [ ( r , c ) ] NEW_LINE DEDENT a = num_u_ways ( r + 2 , c + 1 , H , W ) NEW_LINE b = num_u_ways ( r + 1 , c + 2 , H , W ) NEW_LINE num_ways [ ( r , c ) ] = ( a + b ) % mod NEW_LINE return num_ways [ ( r , c ) ] NEW_LINE DEDENT filename = \" D - small - attempt0 . in \" NEW_LINE f = open ( filename , ' r ' ) NEW_LINE of = open ( \" D - small . out \" , ' w ' ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for x in xrange ( N ) : NEW_LINE INDENT l = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE H = int ( l [ 0 ] ) NEW_LINE W = int ( l [ 1 ] ) NEW_LINE R = int ( l [ 2 ] ) NEW_LINE rocks = { } NEW_LINE for y in xrange ( R ) : NEW_LINE INDENT l = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE rocks [ ( int ( l [ 0 ] ) - 1 , int ( l [ 1 ] ) - 1 ) ] = True NEW_LINE DEDENT num_ways = { } NEW_LINE ans = num_u_ways ( 0 , 0 , H , W ) NEW_LINE print >> of , \" Case \u2581 # % d : \u2581 % d \" % ( x + 1 , ans ) NEW_LINE DEDENT", "functions_standalone": [["num_u_ways", "def num_u_ways ( r , c , H , W ) : NEW_LINE INDENT if ( r >= H or c >= W ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( r , c ) in rocks ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( r == H - 1 and c == W - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( ( r , c ) in num_ways ) : NEW_LINE INDENT return num_ways [ ( r , c ) ] NEW_LINE DEDENT a = num_u_ways ( r + 2 , c + 1 , H , W ) NEW_LINE b = num_u_ways ( r + 1 , c + 2 , H , W ) NEW_LINE num_ways [ ( r , c ) ] = ( a + b ) % mod NEW_LINE return num_ways [ ( r , c ) ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_08_01", "java": [{"id": "9", "code": "import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . PrintStream ; import java . util . Hashtable ; import java . util . Scanner ; public class Saving { public void solve ( Scanner in , PrintStream out ) throws Exception { int numTests = in . nextInt ( ) ; for ( int t = 1 ; t <= numTests ; t ++ ) { int numEngines = in . nextInt ( ) ; Hashtable < String , Integer > table = new Hashtable < String , Integer > ( ) ; in . nextLine ( ) ; for ( int e = 0 ; e < numEngines ; e ++ ) { table . put ( in . nextLine ( ) , e ) ; } int numQueries = in . nextInt ( ) ; int [ ] query = new int [ numQueries ] ; in . nextLine ( ) ; for ( int q = 0 ; q < numQueries ; q ++ ) { String a = in . nextLine ( ) ; query [ q ] = table . get ( a ) ; } int numSwitches = 0 ; int curEngine = - 1 ; for ( int curQ = 0 ; curQ < numQueries ; curQ ++ ) { if ( curEngine != query [ curQ ] && curEngine != - 1 ) { continue ; } int bestScore = 0 ; int bestEngine = 0 ; for ( int e = 0 ; e < numEngines ; e ++ ) { int curBest = 0 ; for ( int q = curQ ; q < numQueries ; q ++ ) { if ( query [ q ] == e ) { break ; } curBest ++ ; } if ( curBest > bestScore ) { bestScore = curBest ; bestEngine = e ; } } curEngine = bestEngine ; numSwitches ++ ; } numSwitches -- ; if ( numSwitches < 0 ) { numSwitches = 0 ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + numSwitches ) ; } } public static void main ( String [ ] args ) throws Exception { Scanner in = null ; PrintStream out = null ; in = new Scanner ( System . in ) ; out = System . out ; in = new Scanner ( new FileReader ( \" A - large . in \" ) ) ; out = new PrintStream ( new FileOutputStream ( \" A - large . out \" ) ) ; new Saving ( ) . solve ( in , out ) ; out . close ( ) ; System . exit ( 0 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = null ; PrintStream out = null ; in = new Scanner ( System . in ) ; out = System . out ; in = new Scanner ( new FileReader ( \" A - large . in \" ) ) ; out = new PrintStream ( new FileOutputStream ( \" A - large . out \" ) ) ; new Saving ( ) . solve ( in , out ) ; out . close ( ) ; System . exit ( 0 ) ; }"]], "functions_class": [["solve", "public void solve ( Scanner in , PrintStream out ) throws Exception { int numTests = in . nextInt ( ) ; for ( int t = 1 ; t <= numTests ; t ++ ) { int numEngines = in . nextInt ( ) ; Hashtable < String , Integer > table = new Hashtable < String , Integer > ( ) ; in . nextLine ( ) ; for ( int e = 0 ; e < numEngines ; e ++ ) { table . put ( in . nextLine ( ) , e ) ; } int numQueries = in . nextInt ( ) ; int [ ] query = new int [ numQueries ] ; in . nextLine ( ) ; for ( int q = 0 ; q < numQueries ; q ++ ) { String a = in . nextLine ( ) ; query [ q ] = table . get ( a ) ; } int numSwitches = 0 ; int curEngine = - 1 ; for ( int curQ = 0 ; curQ < numQueries ; curQ ++ ) { if ( curEngine != query [ curQ ] && curEngine != - 1 ) { continue ; } int bestScore = 0 ; int bestEngine = 0 ; for ( int e = 0 ; e < numEngines ; e ++ ) { int curBest = 0 ; for ( int q = curQ ; q < numQueries ; q ++ ) { if ( query [ q ] == e ) { break ; } curBest ++ ; } if ( curBest > bestScore ) { bestScore = curBest ; bestEngine = e ; } } curEngine = bestEngine ; numSwitches ++ ; } numSwitches -- ; if ( numSwitches < 0 ) { numSwitches = 0 ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + numSwitches ) ; } }"]]}, {"id": "4", "code": "package library ; import java . util . * ; public class Translation < T > { Hashtable < T , Integer > a ; Hashtable < Integer , T > b ; int next ; public Translation ( ) { a = new Hashtable < T , Integer > ( ) ; b = new Hashtable < Integer , T > ( ) ; next = 0 ; } public int add ( T item ) { if ( a . containsKey ( item ) ) { return a . get ( item ) ; } a . put ( item , next ) ; b . put ( next , item ) ; next ++ ; return next - 1 ; } public int get ( T item ) { if ( a . containsKey ( item ) ) { return a . get ( item ) ; } return - 1 ; } public T get ( int index ) { if ( b . containsKey ( index ) ) { return b . get ( index ) ; } return null ; } }", "functions_standalone": [], "functions_class": [["Translation", "public Translation ( ) { a = new Hashtable < T , Integer > ( ) ; b = new Hashtable < Integer , T > ( ) ; next = 0 ; }"], ["add", "public int add ( T item ) { if ( a . containsKey ( item ) ) { return a . get ( item ) ; } a . put ( item , next ) ; b . put ( next , item ) ; next ++ ; return next - 1 ; }"], ["get", "public int get ( T item ) { if ( a . containsKey ( item ) ) { return a . get ( item ) ; } return - 1 ; }"], ["get", "public T get ( int index ) { if ( b . containsKey ( index ) ) { return b . get ( index ) ; } return null ; }"]]}, {"id": "3", "code": "import static java . lang . Math . * ; import static java . util . Arrays . * ; import java . util . * ; public class A { public static void main ( String [ ] args ) { new A ( ) . run ( ) ; } int INF = 1 << 29 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int t = 1 ; t <= n ; t ++ ) { int m = sc . nextInt ( ) ; sc . nextLine ( ) ; String [ ] ss = new String [ m ] ; for ( int i = 0 ; i < m ; i ++ ) ss [ i ] = sc . nextLine ( ) ; int q = sc . nextInt ( ) ; sc . nextLine ( ) ; String [ ] ts = new String [ q ] ; for ( int i = 0 ; i < q ; i ++ ) ts [ i ] = sc . nextLine ( ) ; int [ ] dp = new int [ m ] ; for ( String s : ts ) { int min = minAll ( dp ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( ss [ i ] . equals ( s ) ) dp [ i ] = INF ; else dp [ i ] = min ( dp [ i ] , min + 1 ) ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , t , minAll ( dp ) ) ; } } int minAll ( int ... is ) { int res = is [ 0 ] ; for ( int i = 1 ; i < is . length ; i ++ ) { if ( res > is [ i ] ) res = is [ i ] ; } return res ; } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new A ( ) . run ( ) ; }"]], "functions_class": [["run", "void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int t = 1 ; t <= n ; t ++ ) { int m = sc . nextInt ( ) ; sc . nextLine ( ) ; String [ ] ss = new String [ m ] ; for ( int i = 0 ; i < m ; i ++ ) ss [ i ] = sc . nextLine ( ) ; int q = sc . nextInt ( ) ; sc . nextLine ( ) ; String [ ] ts = new String [ q ] ; for ( int i = 0 ; i < q ; i ++ ) ts [ i ] = sc . nextLine ( ) ; int [ ] dp = new int [ m ] ; for ( String s : ts ) { int min = minAll ( dp ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( ss [ i ] . equals ( s ) ) dp [ i ] = INF ; else dp [ i ] = min ( dp [ i ] , min + 1 ) ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , t , minAll ( dp ) ) ; } }"], ["minAll", "int minAll ( int ... is ) { int res = is [ 0 ] ; for ( int i = 1 ; i < is . length ; i ++ ) { if ( res > is [ i ] ) res = is [ i ] ; } return res ; }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "10", "code": "package emm . cj08 ; import java . io . * ; import java . util . * ; public class Search { private static final File IN = new File ( \" / home / eric / cj / search - in . txt \" ) , OUT = new File ( \" / home / eric / cj / search - out . txt \" ) ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( IN ) ) ; PrintStream ps = new PrintStream ( OUT ) ; int trials = Integer . parseInt ( br . readLine ( ) ) ; for ( int trial = 0 ; trial < trials ; trial ++ ) { HashMap < String , Integer > map = new HashMap < String , Integer > ( ) ; int engines = Integer . parseInt ( br . readLine ( ) ) ; for ( int engine = 0 ; engine < engines ; engine ++ ) map . put ( br . readLine ( ) , engine ) ; int availCnt = engines ; boolean [ ] avail = getAvail ( engines , - 1 ) ; int changes = 0 ; int queries = Integer . parseInt ( br . readLine ( ) ) ; for ( int query = 0 ; query < queries ; query ++ ) { int pos = map . get ( br . readLine ( ) ) ; if ( avail [ pos ] ) { avail [ pos ] = false ; availCnt -- ; if ( availCnt <= 0 ) { availCnt = engines - 1 ; avail = getAvail ( engines , pos ) ; changes ++ ; } } } ps . println ( \" Case \u2581 # \" + ( trial + 1 ) + \" : \u2581 \" + changes ) ; } br . close ( ) ; ps . close ( ) ; } private static boolean [ ] getAvail ( int engines , int cur ) { boolean [ ] result = new boolean [ engines ] ; for ( int i = 0 ; i < engines ; i ++ ) result [ i ] = i != cur ; return result ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( IN ) ) ; PrintStream ps = new PrintStream ( OUT ) ; int trials = Integer . parseInt ( br . readLine ( ) ) ; for ( int trial = 0 ; trial < trials ; trial ++ ) { HashMap < String , Integer > map = new HashMap < String , Integer > ( ) ; int engines = Integer . parseInt ( br . readLine ( ) ) ; for ( int engine = 0 ; engine < engines ; engine ++ ) map . put ( br . readLine ( ) , engine ) ; int availCnt = engines ; boolean [ ] avail = getAvail ( engines , - 1 ) ; int changes = 0 ; int queries = Integer . parseInt ( br . readLine ( ) ) ; for ( int query = 0 ; query < queries ; query ++ ) { int pos = map . get ( br . readLine ( ) ) ; if ( avail [ pos ] ) { avail [ pos ] = false ; availCnt -- ; if ( availCnt <= 0 ) { availCnt = engines - 1 ; avail = getAvail ( engines , pos ) ; changes ++ ; } } } ps . println ( \" Case \u2581 # \" + ( trial + 1 ) + \" : \u2581 \" + changes ) ; } br . close ( ) ; ps . close ( ) ; }"], ["getAvail", "private static boolean [ ] getAvail ( int engines , int cur ) { boolean [ ] result = new boolean [ engines ] ; for ( int i = 0 ; i < engines ; i ++ ) result [ i ] = i != cur ; return result ; }"]], "functions_class": []}, {"id": "19", "code": "import java . util . Comparator ; public class CompareUnit implements Comparator { public int compare ( Object o1 , Object o2 ) { Unit u1 , u2 ; u1 = ( Unit ) o1 ; u2 = ( Unit ) o2 ; if ( u1 . turnTime < u2 . turnTime ) return - 1 ; else if ( u1 . turnTime == u2 . turnTime ) return 0 ; else return 1 ; } }", "functions_standalone": [], "functions_class": [["compare", "public int compare ( Object o1 , Object o2 ) { Unit u1 , u2 ; u1 = ( Unit ) o1 ; u2 = ( Unit ) o2 ; if ( u1 . turnTime < u2 . turnTime ) return - 1 ; else if ( u1 . turnTime == u2 . turnTime ) return 0 ; else return 1 ; }"]]}], "python": [{"id": "20", "code": "from sys import stdin as input_file NEW_LINE from sys import stdout as output_file NEW_LINE def readline ( file ) : NEW_LINE INDENT return file . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT num_cases = int ( readline ( input_file ) ) NEW_LINE for case_num in xrange ( num_cases ) : NEW_LINE INDENT num_engines = int ( readline ( input_file ) ) NEW_LINE engines = [ ] NEW_LINE for i in xrange ( num_engines ) : NEW_LINE INDENT engine = readline ( input_file ) NEW_LINE engines . append ( engine ) NEW_LINE DEDENT num_queries = int ( readline ( input_file ) ) NEW_LINE queries = [ ] NEW_LINE for i in xrange ( num_queries ) : NEW_LINE INDENT query = readline ( input_file ) NEW_LINE queries . append ( query ) NEW_LINE DEDENT num_switches = 0 NEW_LINE occurrence = set ( ) NEW_LINE for query in queries : NEW_LINE INDENT occurrence . add ( query ) NEW_LINE if len ( occurrence ) == num_engines : NEW_LINE INDENT occurrence = set ( ) NEW_LINE occurrence . add ( query ) NEW_LINE num_switches += 1 NEW_LINE DEDENT DEDENT output_file . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( case_num + 1 , num_switches ) ) NEW_LINE DEDENT", "functions_standalone": [["readline", "def readline ( file ) : NEW_LINE INDENT return file . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "13", "code": "import string NEW_LINE S = 0 NEW_LINE N = 0 NEW_LINE Q = 0 NEW_LINE engine = { } NEW_LINE input_f = None NEW_LINE output_f = None NEW_LINE def case_init ( ) : NEW_LINE INDENT global S , N , Q , engine , input_f , output_f NEW_LINE S = string . atoi ( input_f . readline ( ) ) NEW_LINE engine = { } NEW_LINE for i in xrange ( S ) : NEW_LINE INDENT engine [ input_f . readline ( ) ] = i NEW_LINE DEDENT Q = string . atoi ( input_f . readline ( ) ) NEW_LINE DEDENT def query ( ) : NEW_LINE INDENT global S , N , Q , engine , input_f , output_f NEW_LINE for i in xrange ( Q ) : NEW_LINE INDENT yield engine [ input_f . readline ( ) ] NEW_LINE DEDENT DEDENT def cal ( ) : NEW_LINE INDENT global S , N , Q , engine , input_f , output_f NEW_LINE result = [ 0 ] * S NEW_LINE for i in query ( ) : NEW_LINE INDENT for j in xrange ( S ) : NEW_LINE INDENT result [ j ] = min ( result [ j ] , result [ i ] + 1 ) NEW_LINE DEDENT result [ i ] = 10000000 NEW_LINE DEDENT return min ( result ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT global S , N , Q , engine , input_f , output_f NEW_LINE input_f = open ( ' A - large . in ' , ' rb ' ) NEW_LINE output_f = open ( ' output . txt ' , ' w ' ) NEW_LINE output_f . seek ( 0 ) NEW_LINE N = string . atoi ( input_f . readline ( ) ) NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT case_init ( ) NEW_LINE output_f . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( i + 1 , cal ( ) ) ) NEW_LINE DEDENT output_f . flush ( ) NEW_LINE DEDENT main ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_08_23", "java": [{"id": "19", "code": "import java . util . * ; public class C { public static void main ( String args [ ] ) { ( new C ( ) ) . exec ( ) ; } void exec ( ) { Scanner cin = new Scanner ( System . in ) ; int t = cin . nextInt ( ) ; for ( int z = 0 ; z < t ; ++ z ) { int k = cin . nextInt ( ) ; int value [ ] = new int [ k ] ; boolean used [ ] = new boolean [ k ] ; int count = 0 ; int cur = 0 ; while ( count < k ) { for ( int i = 0 ; i < k ; ++ i ) { if ( used [ i ] ) { continue ; } if ( cur == count ) { value [ i ] = ++ count ; cur = 0 ; used [ i ] = true ; } else { ++ cur ; } } } System . out . print ( \" Case \u2581 # \" + ( z + 1 ) + \" : \" ) ; int n = cin . nextInt ( ) ; for ( int i = 0 ; i < n ; ++ i ) { System . out . print ( \" \u2581 \" + value [ cin . nextInt ( ) - 1 ] ) ; } System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { ( new C ( ) ) . exec ( ) ; }"]], "functions_class": [["exec", "void exec ( ) { Scanner cin = new Scanner ( System . in ) ; int t = cin . nextInt ( ) ; for ( int z = 0 ; z < t ; ++ z ) { int k = cin . nextInt ( ) ; int value [ ] = new int [ k ] ; boolean used [ ] = new boolean [ k ] ; int count = 0 ; int cur = 0 ; while ( count < k ) { for ( int i = 0 ; i < k ; ++ i ) { if ( used [ i ] ) { continue ; } if ( cur == count ) { value [ i ] = ++ count ; cur = 0 ; used [ i ] = true ; } else { ++ cur ; } } } System . out . print ( \" Case \u2581 # \" + ( z + 1 ) + \" : \" ) ; int n = cin . nextInt ( ) ; for ( int i = 0 ; i < n ; ++ i ) { System . out . print ( \" \u2581 \" + value [ cin . nextInt ( ) - 1 ] ) ; } System . out . println ( ) ; } }"]]}, {"id": "8", "code": "import java . io . * ; import java . util . * ; public class TaskC implements Runnable { private String IFILE = \" C - large . in \" ; private Scanner in ; private PrintWriter out ; public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \" ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int [ ] mas = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int v = in . nextInt ( ) - 1 ; int count = n ; for ( int j = 0 ; j < n ; j ++ ) { int pos = j % count ; if ( pos == v ) { out . print ( \" \u2581 \" + ( j + 1 ) ) ; break ; } if ( pos > v ) { v += count - pos - 1 ; } else { v = v - pos - 1 ; } count -- ; } } out . println ( ) ; } in . close ( ) ; out . close ( ) ; } public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } } public static void main ( String [ ] args ) throws IOException { new TaskC ( ) . Run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new TaskC ( ) . Run ( ) ; }"]], "functions_class": [["Run", "public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \" ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int [ ] mas = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int v = in . nextInt ( ) - 1 ; int count = n ; for ( int j = 0 ; j < n ; j ++ ) { int pos = j % count ; if ( pos == v ) { out . print ( \" \u2581 \" + ( j + 1 ) ) ; break ; } if ( pos > v ) { v += count - pos - 1 ; } else { v = v - pos - 1 ; } count -- ; } } out . println ( ) ; } in . close ( ) ; out . close ( ) ; }"], ["run", "public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } }"]]}, {"id": "12", "code": "package common ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Helper { public static String [ ] getAllFileContentAsArray ( String filename ) throws Exception { BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ; List < String > all = new ArrayList < String > ( ) ; String s = in . readLine ( ) ; while ( s != null ) { all . add ( s ) ; s = in . readLine ( ) ; } in . close ( ) ; return all . toArray ( new String [ 0 ] ) ; } public static void writeToFile ( String [ ] cont , String filename ) throws Exception { File file = new File ( filename ) ; file . delete ( ) ; FileWriter w = null ; try { w = new FileWriter ( file , true ) ; for ( String s : cont ) { w . write ( s + \" \\n \" ) ; } } finally { if ( w != null ) { w . close ( ) ; } } } public static int [ ] getIntegersFromString ( String s ) throws Exception { List < Integer > a = new ArrayList < Integer > ( ) ; for ( String se : s . split ( \" \u2581 \" ) ) { try { Integer x = Integer . parseInt ( se ) ; a . add ( x ) ; } catch ( Exception e ) { } } int [ ] ret = new int [ a . size ( ) ] ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) { ret [ i ] = a . get ( i ) . intValue ( ) ; } return ret ; } private Helper ( ) { } }", "functions_standalone": [["getAllFileContentAsArray", "public static String [ ] getAllFileContentAsArray ( String filename ) throws Exception { BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ; List < String > all = new ArrayList < String > ( ) ; String s = in . readLine ( ) ; while ( s != null ) { all . add ( s ) ; s = in . readLine ( ) ; } in . close ( ) ; return all . toArray ( new String [ 0 ] ) ; }"], ["writeToFile", "public static void writeToFile ( String [ ] cont , String filename ) throws Exception { File file = new File ( filename ) ; file . delete ( ) ; FileWriter w = null ; try { w = new FileWriter ( file , true ) ; for ( String s : cont ) { w . write ( s + \" \\n \" ) ; } } finally { if ( w != null ) { w . close ( ) ; } } }"], ["getIntegersFromString", "public static int [ ] getIntegersFromString ( String s ) throws Exception { List < Integer > a = new ArrayList < Integer > ( ) ; for ( String se : s . split ( \" \u2581 \" ) ) { try { Integer x = Integer . parseInt ( se ) ; a . add ( x ) ; } catch ( Exception e ) { } } int [ ] ret = new int [ a . size ( ) ] ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) { ret [ i ] = a . get ( i ) . intValue ( ) ; } return ret ; }"]], "functions_class": [["Helper", "private Helper ( ) { }"]]}, {"id": "18", "code": "import java . io . * ; import java . util . * ; public class C { public static void main ( String args [ ] ) throws IOException { new C ( ) . solve ( ) ; } void solve ( ) throws IOException { br = new BufferedReader ( new FileReader ( \" C - small - attempt0 . in \" ) ) ; pw = new PrintWriter ( \" C - small . out \" ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int c = 1 ; c <= T ; ++ c ) { System . out . println ( c ) ; int K = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { d [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } int [ ] v = new int [ K ] ; int s = 0 ; for ( int k = 1 ; k <= K ; ++ k ) { for ( int p = 1 ; p < k ; ++ p ) { s ++ ; if ( s == K ) s = 0 ; while ( v [ s ] != 0 ) { s ++ ; if ( s == K ) s = 0 ; } } v [ s ] = k ; if ( k < K ) { s ++ ; if ( s == K ) s = 0 ; while ( v [ s ] != 0 ) { s ++ ; if ( s == K ) s = 0 ; } } } pw . print ( \" Case \u2581 # \" + c + \" : \" ) ; for ( int i = 0 ; i < n ; ++ i ) { pw . print ( \" \u2581 \" + v [ d [ i ] - 1 ] ) ; } pw . println ( ) ; } pw . close ( ) ; } BufferedReader br ; PrintWriter pw ; }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws IOException { new C ( ) . solve ( ) ; }"]], "functions_class": [["solve", "void solve ( ) throws IOException { br = new BufferedReader ( new FileReader ( \" C - small - attempt0 . in \" ) ) ; pw = new PrintWriter ( \" C - small . out \" ) ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int c = 1 ; c <= T ; ++ c ) { System . out . println ( c ) ; int K = Integer . parseInt ( br . readLine ( ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { d [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } int [ ] v = new int [ K ] ; int s = 0 ; for ( int k = 1 ; k <= K ; ++ k ) { for ( int p = 1 ; p < k ; ++ p ) { s ++ ; if ( s == K ) s = 0 ; while ( v [ s ] != 0 ) { s ++ ; if ( s == K ) s = 0 ; } } v [ s ] = k ; if ( k < K ) { s ++ ; if ( s == K ) s = 0 ; while ( v [ s ] != 0 ) { s ++ ; if ( s == K ) s = 0 ; } } } pw . print ( \" Case \u2581 # \" + c + \" : \" ) ; for ( int i = 0 ; i < n ; ++ i ) { pw . print ( \" \u2581 \" + v [ d [ i ] - 1 ] ) ; } pw . println ( ) ; } pw . close ( ) ; }"]]}, {"id": "13", "code": "import java . util . * ; public class CSmall { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= T ; caseID ++ ) { int K = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] ds = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ds [ i ] = sc . nextInt ( ) ; } boolean [ ] visited = new boolean [ K ] ; int [ ] cards = new int [ K ] ; int iter = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int cnt = 0 ; int next = ( i - 1 ) % ( K - i + 1 ) ; while ( true ) { if ( iter == K ) iter = 0 ; if ( ! visited [ iter ] ) { if ( cnt == next ) { visited [ iter ] = true ; cards [ iter ] = i ; cnt ++ ; iter ++ ; break ; } else { cnt ++ ; iter ++ ; } } else { iter ++ ; } } } System . out . printf ( \" Case \u2581 # % d : \" , caseID ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . printf ( \" \u2581 % d \" , cards [ ds [ i ] - 1 ] ) ; } System . out . printf ( \" % n \" ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= T ; caseID ++ ) { int K = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] ds = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ds [ i ] = sc . nextInt ( ) ; } boolean [ ] visited = new boolean [ K ] ; int [ ] cards = new int [ K ] ; int iter = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int cnt = 0 ; int next = ( i - 1 ) % ( K - i + 1 ) ; while ( true ) { if ( iter == K ) iter = 0 ; if ( ! visited [ iter ] ) { if ( cnt == next ) { visited [ iter ] = true ; cards [ iter ] = i ; cnt ++ ; iter ++ ; break ; } else { cnt ++ ; iter ++ ; } } else { iter ++ ; } } } System . out . printf ( \" Case \u2581 # % d : \" , caseID ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . printf ( \" \u2581 % d \" , cards [ ds [ i ] - 1 ] ) ; } System . out . printf ( \" % n \" ) ; } }"]], "functions_class": []}], "python": [{"id": "8", "code": "import sys NEW_LINE line = sys . stdin . readline ( ) NEW_LINE line = line . rstrip ( ) NEW_LINE cases = int ( line ) NEW_LINE for case in xrange ( 0 , cases ) : NEW_LINE INDENT K = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE ds = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE ds [ 0 : 1 ] = [ ] NEW_LINE indexes = range ( 0 , K ) NEW_LINE cards = [ - 1 ] * K NEW_LINE I = 0 NEW_LINE for X in xrange ( 0 , K ) : NEW_LINE INDENT I += X NEW_LINE I = I % ( len ( indexes ) ) NEW_LINE ii = I % ( K - X ) NEW_LINE i = indexes [ ii ] NEW_LINE indexes [ ii : ii + 1 ] = [ ] NEW_LINE cards [ i ] = X NEW_LINE DEDENT sys . stdout . write ( \" Case \u2581 # % d : \" % ( case + 1 ) ) NEW_LINE for d in ds : NEW_LINE INDENT sys . stdout . write ( \" \u2581 % d \" % ( cards [ d - 1 ] + 1 ) ) NEW_LINE DEDENT sys . stdout . write ( \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "11", "code": "from time import time NEW_LINE import psyco NEW_LINE import re NEW_LINE import math NEW_LINE psyco . full ( ) NEW_LINE fin = open ( \"1 _ input . txt \" , \" r \" ) NEW_LINE fout = open ( \"1 _ output . txt \" , \" w \" ) NEW_LINE cases = int ( fin . readline ( ) ) NEW_LINE t0 = time ( ) NEW_LINE for casenr in range ( cases ) : NEW_LINE INDENT K = int ( fin . readline ( ) ) NEW_LINE indices = map ( int , [ e for e in fin . readline ( ) . split ( ) ] ) NEW_LINE indices = indices [ 1 : ] NEW_LINE open_indices = [ ] NEW_LINE closed_indices = [ ] NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT open_indices . append ( i ) NEW_LINE closed_indices . append ( i ) NEW_LINE DEDENT current_number = 1 NEW_LINE current_position = - 1 NEW_LINE while open_indices : NEW_LINE INDENT next_index = ( current_position + current_number ) % len ( open_indices ) NEW_LINE closed_indices [ open_indices [ next_index ] - 1 ] = current_number NEW_LINE open_indices . pop ( next_index ) NEW_LINE current_position = next_index - 1 NEW_LINE current_number += 1 NEW_LINE DEDENT fout . write ( \" Case \u2581 # % d : \" % ( casenr + 1 ) ) NEW_LINE for ind in indices : NEW_LINE INDENT fout . write ( \" \u2581 % d \" % ( closed_indices [ ind - 1 ] ) ) NEW_LINE DEDENT fout . write ( \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "3", "code": "case = \" small - attempt0\" NEW_LINE input_file = \" C - % s . in \" % case NEW_LINE output_file = \" C - % s . out \" % case NEW_LINE fin = open ( input_file ) NEW_LINE fout = open ( output_file , \" w \" ) NEW_LINE ncase = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for z in xrange ( 1 , ncase + 1 ) : NEW_LINE INDENT print >> fout , \" Case \u2581 # % d : \" % z , NEW_LINE k = int ( fin . readline ( ) . strip ( ) ) NEW_LINE d = [ int ( x ) - 1 for x in fin . readline ( ) . strip ( ) . split ( ) [ 1 : ] ] NEW_LINE for dd in d : NEW_LINE INDENT n , p , r , i = k , dd , 0 , 1 NEW_LINE while p != r : NEW_LINE INDENT n -= 1 NEW_LINE if p > r : NEW_LINE INDENT p -= 1 NEW_LINE DEDENT r = ( r + i ) % n NEW_LINE i += 1 NEW_LINE DEDENT print >> fout , i , NEW_LINE DEDENT print >> fout NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "13", "code": "inp_file = file ( \" C - small . in \" ) NEW_LINE out_file = file ( \" C - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT line = [ int ( c1 ) for c1 in line . split ( \" \u2581 \" ) ] NEW_LINE card_num , indices = line [ : 2 ] NEW_LINE line = line [ 2 : ] NEW_LINE positions = range ( card_num ) NEW_LINE result = [ 0 for c1 in range ( card_num ) ] NEW_LINE c1 = 1 NEW_LINE c2 = 0 NEW_LINE while c1 < card_num : NEW_LINE INDENT result [ positions [ c2 ] ] = c1 NEW_LINE positions . pop ( c2 ) NEW_LINE c2 = ( c2 + c1 ) % len ( positions ) NEW_LINE c1 += 1 NEW_LINE DEDENT result [ result . index ( 0 ) ] = card_num NEW_LINE return \" \u2581 \" . join ( [ str ( result [ c1 - 1 ] ) for c1 in line ] ) NEW_LINE DEDENT num = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT line = inp_file . readline ( ) [ : - 1 ] + \" \u2581 \" + inp_file . readline ( ) [ : - 1 ] NEW_LINE out_file . write ( \" Case \u2581 # % s : \u2581 \" % ( case + 1 ) + solve ( line ) + \" \\n \" ) NEW_LINE DEDENT inp_file . close ( ) NEW_LINE out_file . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( line ) : NEW_LINE INDENT line = [ int ( c1 ) for c1 in line . split ( \" \u2581 \" ) ] NEW_LINE card_num , indices = line [ : 2 ] NEW_LINE line = line [ 2 : ] NEW_LINE positions = range ( card_num ) NEW_LINE result = [ 0 for c1 in range ( card_num ) ] NEW_LINE c1 = 1 NEW_LINE c2 = 0 NEW_LINE while c1 < card_num : NEW_LINE INDENT result [ positions [ c2 ] ] = c1 NEW_LINE positions . pop ( c2 ) NEW_LINE c2 = ( c2 + c1 ) % len ( positions ) NEW_LINE c1 += 1 NEW_LINE DEDENT result [ result . index ( 0 ) ] = card_num NEW_LINE return \" \u2581 \" . join ( [ str ( result [ c1 - 1 ] ) for c1 in line ] ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "12", "code": "import sys NEW_LINE cached_in = \" \" NEW_LINE def next_line ( ) : NEW_LINE INDENT global cached_in NEW_LINE if cached_in : NEW_LINE INDENT res = \" \" . join ( cached_in ) NEW_LINE cached_in = \" \" NEW_LINE return res NEW_LINE DEDENT return sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT def next_val ( ) : NEW_LINE INDENT global cached_in NEW_LINE while not cached_in : NEW_LINE INDENT cached_in = sys . stdin . readline ( ) . strip ( ) NEW_LINE cached_in = cached_in . split ( ) NEW_LINE cached_in . reverse ( ) NEW_LINE DEDENT return cached_in . pop ( ) NEW_LINE DEDENT def next_int ( ) : NEW_LINE INDENT return int ( next_val ( ) ) NEW_LINE DEDENT", "functions_standalone": [["next_line", "def next_line ( ) : NEW_LINE INDENT global cached_in NEW_LINE if cached_in : NEW_LINE INDENT res = \" \" . join ( cached_in ) NEW_LINE cached_in = \" \" NEW_LINE return res NEW_LINE DEDENT return sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT"], ["next_val", "def next_val ( ) : NEW_LINE INDENT global cached_in NEW_LINE while not cached_in : NEW_LINE INDENT cached_in = sys . stdin . readline ( ) . strip ( ) NEW_LINE cached_in = cached_in . split ( ) NEW_LINE cached_in . reverse ( ) NEW_LINE DEDENT return cached_in . pop ( ) NEW_LINE DEDENT"], ["next_int", "def next_int ( ) : NEW_LINE INDENT return int ( next_val ( ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_08_13", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; import java . math . * ; public class Main implements Runnable { StreamTokenizer ST ; PrintWriter out ; BufferedReader br ; Scanner in ; String FileName = \" test \" ; int inf = 1000000000 ; int nextInt ( ) throws IOException { ST . nextToken ( ) ; return ( int ) ST . nval ; } String next ( ) throws IOException { ST . nextToken ( ) ; return ST . sval ; } double nextD ( ) throws IOException { ST . nextToken ( ) ; return ST . nval ; } public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; } public void run ( ) { try { out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" output . txt \" ) ) ) ) ; br = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; in = new Scanner ( br ) ; ST = new StreamTokenizer ( br ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } public void solve ( ) throws IOException { BigDecimal d = BigDecimal . valueOf ( 5 ) ; BigDecimal l = BigDecimal . valueOf ( 2 ) ; BigDecimal r = BigDecimal . valueOf ( 3 ) ; BigDecimal e = BigDecimal . valueOf ( 1 ) ; e = e . divide ( BigDecimal . TEN . pow ( 100 ) ) ; while ( r . subtract ( l ) . compareTo ( e ) > 0 ) { BigDecimal m = l . add ( r ) . divide ( BigDecimal . valueOf ( 2 ) ) ; if ( m . multiply ( m ) . compareTo ( d ) > 0 ) r = m ; else l = m ; } r = r . add ( BigDecimal . valueOf ( 3 ) ) ; int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; BigDecimal x = r . pow ( nextInt ( ) ) ; String s = x . toString ( ) ; s = \"0\" + s . substring ( 0 , s . indexOf ( ' . ' ) ) ; out . println ( s . substring ( s . length ( ) - 3 , s . length ( ) ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; }"]], "functions_class": [["nextInt", "int nextInt ( ) throws IOException { ST . nextToken ( ) ; return ( int ) ST . nval ; }"], ["next", "String next ( ) throws IOException { ST . nextToken ( ) ; return ST . sval ; }"], ["nextD", "double nextD ( ) throws IOException { ST . nextToken ( ) ; return ST . nval ; }"], ["run", "public void run ( ) { try { out = new PrintWriter ( new BufferedWriter ( new FileWriter ( new File ( \" output . txt \" ) ) ) ) ; br = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; in = new Scanner ( br ) ; ST = new StreamTokenizer ( br ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }"], ["solve", "public void solve ( ) throws IOException { BigDecimal d = BigDecimal . valueOf ( 5 ) ; BigDecimal l = BigDecimal . valueOf ( 2 ) ; BigDecimal r = BigDecimal . valueOf ( 3 ) ; BigDecimal e = BigDecimal . valueOf ( 1 ) ; e = e . divide ( BigDecimal . TEN . pow ( 100 ) ) ; while ( r . subtract ( l ) . compareTo ( e ) > 0 ) { BigDecimal m = l . add ( r ) . divide ( BigDecimal . valueOf ( 2 ) ) ; if ( m . multiply ( m ) . compareTo ( d ) > 0 ) r = m ; else l = m ; } r = r . add ( BigDecimal . valueOf ( 3 ) ) ; int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; BigDecimal x = r . pow ( nextInt ( ) ) ; String s = x . toString ( ) ; s = \"0\" + s . substring ( 0 , s . indexOf ( ' . ' ) ) ; out . println ( s . substring ( s . length ( ) - 3 , s . length ( ) ) ) ; } }"]]}, {"id": "3", "code": "import org . apfloat . * ; import java . util . * ; import java . math . * ; public class Numbers { static int [ ] jojojo = { 143 , 751 , 935 , 607 , 903 , 991 , 335 , 47 , 943 , 471 , 55 , 447 , 463 , 991 , 95 , 607 , 263 , 151 , 855 , 527 , 743 , 351 , 135 , 407 , 903 , 791 , 135 , 647 , 343 , 471 , 455 , 847 , 263 , 191 , 95 , 807 , 463 , 551 , 455 , 527 , 343 , 951 , 335 , 207 , 903 , 591 , 935 , 247 , 743 , 471 , 855 , 247 , 63 , 391 , 95 , 7 , 663 , 951 , 55 , 527 , 943 , 551 , 535 , 7 , 903 , 391 , 735 , 847 , 143 , 471 , 255 , 647 , 863 , 591 , 95 , 207 , 863 , 351 , 655 , 527 , 543 , 151 , 735 , 807 , 903 , 191 , 535 , 447 , 543 , 471 , 655 , 47 , 663 , 791 , 95 , 407 , 63 , 751 , 255 , 527 } ; static String jojojofunction ( long l ) { if ( l == 0 ) return \"001\" ; if ( l == 1 ) return \"005\" ; if ( l == 2 ) return \"027\" ; String s = \" \" + jojojo [ ( int ) ( ( l - 3 ) % jojojo . length ) ] ; while ( s . length ( ) < 3 ) s = \"0\" + s ; return s ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; for ( int c = 0 , T = sc . nextInt ( ) ; c < T ; c ++ ) { System . out . println ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" + jojojofunction ( sc . nextLong ( ) ) ) ; } } }", "functions_standalone": [["jojojofunction", "static String jojojofunction ( long l ) { if ( l == 0 ) return \"001\" ; if ( l == 1 ) return \"005\" ; if ( l == 2 ) return \"027\" ; String s = \" \" + jojojo [ ( int ) ( ( l - 3 ) % jojojo . length ) ] ; while ( s . length ( ) < 3 ) s = \"0\" + s ; return s ; }"], ["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; for ( int c = 0 , T = sc . nextInt ( ) ; c < T ; c ++ ) { System . out . println ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" + jojojofunction ( sc . nextLong ( ) ) ) ; } }"]], "functions_class": []}, {"id": "16", "code": "import java . io . * ; import java . util . * ; import java . math . * ; public class C { public static void main ( String [ ] args ) throws Throwable { StreamTokenizer in = new StreamTokenizer ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" A - small . out \" ) ) ) ; BigDecimal X = new BigDecimal ( \"3\" ) . add ( new BigDecimal ( \"2.2360679774997896964091736687312762354406183596115257242708972454105209256378048994144144083787822749695081761507737835042532677244470738635863601215334527088667781731918791658112766453226398565805357613504175337850034233924140644420864325390972525926272288762995174024406816117759089094984923713907297288984820886415426898940991316935770197486788844250897541329561831769214999774248015304341150359576683325124988151781394080005624208552435422355561063063428202340933319829339597463522712013417496142026359047378855043896870611356600457571399565955669569175645782219525000605392312340050092867648755297220567662536660744858535052623306784946334222423176372770266324076801044433158257335058930981362263431986864719469899701808189524264459620345221411922329125981963258111041704958070481204034559949435068555518555725123886416550102624363125710244496187894246829034044747161154557232017376765904609185295756035779843980541553807790643936397230287560629994822138521773485924535151210463455550407072278724215347787529112121211843317893351910380080111181790045906188462496471042442483088801294068113146959532794478989989316915774607924618075006798771242048473805027736082915599139624489149435606834625290644083279446426808889897460463083535378750420613747576068834018790881925591179735744641902485378711461940901919136880351103976384360412810581103786989518520146970456420217638928908844463778263858937924400460288754053984601560617052236150903857754100421936849872542718503752155576933167230047782698666624462106784642724863852745782134100679856453052711241805959728494551954513101723097508714965294362829025400120477803241554644899887061779981900336065622438864096392877535172662959714382279563079561495230154442350165389172786409130419793971113562821393674576811749220675621088878188736716716276226233798771115395096829828906830182590814010038955097232615084528345878936073463961172366783665719826079214402891190089955842415224957129183232167411899757201394037881977280152887234186683454183828673002743153202296076286125247610286423469630201118026912202360158101276284305418617176185751406901015616290917639812672259655962823490678546241618579455844426596128589375648549748034901108135575141664746219518302355259568865694958163530361955745368322352650077224225828736687534047007422326614517397665174206726444762196180242203979835368298350246626803054676876744690018695720995\" ) ) ; String [ ] ans = new String [ 31 ] ; for ( int i = 2 ; i < 31 ; i ++ ) { ans [ i ] = m3 ( X . pow ( i ) . toBigInteger ( ) . toString ( ) ) ; System . out . println ( i ) ; } System . out . println ( \" Ready . \" ) ; in . nextToken ( ) ; int t = ( int ) in . nval , iter = 0 ; while ( t -- > 0 ) { iter ++ ; in . nextToken ( ) ; out . println ( \" Case \u2581 # \" + iter + \" : \u2581 \" + ans [ ( int ) in . nval ] ) ; } out . close ( ) ; System . exit ( 0 ) ; } static String m3 ( String s ) { if ( s . length ( ) > 3 ) s = s . substring ( s . length ( ) - 3 ) ; while ( s . length ( ) < 3 ) s = \"0\" + s ; return s ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { StreamTokenizer in = new StreamTokenizer ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" A - small . out \" ) ) ) ; BigDecimal X = new BigDecimal ( \"3\" ) . add ( new BigDecimal ( \"2.2360679774997896964091736687312762354406183596115257242708972454105209256378048994144144083787822749695081761507737835042532677244470738635863601215334527088667781731918791658112766453226398565805357613504175337850034233924140644420864325390972525926272288762995174024406816117759089094984923713907297288984820886415426898940991316935770197486788844250897541329561831769214999774248015304341150359576683325124988151781394080005624208552435422355561063063428202340933319829339597463522712013417496142026359047378855043896870611356600457571399565955669569175645782219525000605392312340050092867648755297220567662536660744858535052623306784946334222423176372770266324076801044433158257335058930981362263431986864719469899701808189524264459620345221411922329125981963258111041704958070481204034559949435068555518555725123886416550102624363125710244496187894246829034044747161154557232017376765904609185295756035779843980541553807790643936397230287560629994822138521773485924535151210463455550407072278724215347787529112121211843317893351910380080111181790045906188462496471042442483088801294068113146959532794478989989316915774607924618075006798771242048473805027736082915599139624489149435606834625290644083279446426808889897460463083535378750420613747576068834018790881925591179735744641902485378711461940901919136880351103976384360412810581103786989518520146970456420217638928908844463778263858937924400460288754053984601560617052236150903857754100421936849872542718503752155576933167230047782698666624462106784642724863852745782134100679856453052711241805959728494551954513101723097508714965294362829025400120477803241554644899887061779981900336065622438864096392877535172662959714382279563079561495230154442350165389172786409130419793971113562821393674576811749220675621088878188736716716276226233798771115395096829828906830182590814010038955097232615084528345878936073463961172366783665719826079214402891190089955842415224957129183232167411899757201394037881977280152887234186683454183828673002743153202296076286125247610286423469630201118026912202360158101276284305418617176185751406901015616290917639812672259655962823490678546241618579455844426596128589375648549748034901108135575141664746219518302355259568865694958163530361955745368322352650077224225828736687534047007422326614517397665174206726444762196180242203979835368298350246626803054676876744690018695720995\" ) ) ; String [ ] ans = new String [ 31 ] ; for ( int i = 2 ; i < 31 ; i ++ ) { ans [ i ] = m3 ( X . pow ( i ) . toBigInteger ( ) . toString ( ) ) ; System . out . println ( i ) ; } System . out . println ( \" Ready . \" ) ; in . nextToken ( ) ; int t = ( int ) in . nval , iter = 0 ; while ( t -- > 0 ) { iter ++ ; in . nextToken ( ) ; out . println ( \" Case \u2581 # \" + iter + \" : \u2581 \" + ans [ ( int ) in . nval ] ) ; } out . close ( ) ; System . exit ( 0 ) ; }"], ["m3", "static String m3 ( String s ) { if ( s . length ( ) > 3 ) s = s . substring ( s . length ( ) - 3 ) ; while ( s . length ( ) < 3 ) s = \"0\" + s ; return s ; }"]], "functions_class": []}, {"id": "5", "code": "import java . util . * ; import java . io . * ; import java . math . BigInteger ; public class Main { final static String FNAME = \" c1\" ; public Scanner in ; public PrintWriter out ; void open ( ) throws IOException { in = new Scanner ( new File ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( new File ( FNAME + \" . out \" ) ) ; } void close ( ) throws IOException { out . close ( ) ; } void run ( ) { BigInteger two = new BigInteger ( \"2\" ) ; BigInteger l = new BigInteger ( \"2\" ) . multiply ( BigInteger . TEN . pow ( 35 ) ) ; BigInteger r = new BigInteger ( \"3\" ) . multiply ( BigInteger . TEN . pow ( 35 ) ) ; BigInteger p = new BigInteger ( \"5\" ) . multiply ( BigInteger . TEN . pow ( 70 ) ) ; while ( ! r . equals ( l ) ) { BigInteger m = l . add ( r ) . divide ( two ) ; if ( m . multiply ( m ) . compareTo ( p ) > 0 ) { r = m ; } else { l = m . add ( BigInteger . ONE ) ; } } l = l . add ( new BigInteger ( \"3\" ) . multiply ( BigInteger . TEN . pow ( 35 ) ) ) ; int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int d = in . nextInt ( ) ; String s = \" \" + l . pow ( d ) . divide ( BigInteger . TEN . pow ( d * 35 ) ) . remainder ( new BigInteger ( \"1000\" ) ) ; while ( s . length ( ) < 3 ) { s = '0' + s ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + s ) ; } } public static void main ( String [ ] args ) throws IOException { new Thread ( ) { public void run ( ) { try { Main solution = new Main ( ) ; solution . open ( ) ; solution . run ( ) ; solution . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } . start ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Thread ( ) { public void run ( ) { try { Main solution = new Main ( ) ; solution . open ( ) ; solution . run ( ) ; solution . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } . start ( ) ; }"]], "functions_class": [["open", "void open ( ) throws IOException { in = new Scanner ( new File ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( new File ( FNAME + \" . out \" ) ) ; }"], ["close", "void close ( ) throws IOException { out . close ( ) ; }"], ["run", "void run ( ) { BigInteger two = new BigInteger ( \"2\" ) ; BigInteger l = new BigInteger ( \"2\" ) . multiply ( BigInteger . TEN . pow ( 35 ) ) ; BigInteger r = new BigInteger ( \"3\" ) . multiply ( BigInteger . TEN . pow ( 35 ) ) ; BigInteger p = new BigInteger ( \"5\" ) . multiply ( BigInteger . TEN . pow ( 70 ) ) ; while ( ! r . equals ( l ) ) { BigInteger m = l . add ( r ) . divide ( two ) ; if ( m . multiply ( m ) . compareTo ( p ) > 0 ) { r = m ; } else { l = m . add ( BigInteger . ONE ) ; } } l = l . add ( new BigInteger ( \"3\" ) . multiply ( BigInteger . TEN . pow ( 35 ) ) ) ; int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int d = in . nextInt ( ) ; String s = \" \" + l . pow ( d ) . divide ( BigInteger . TEN . pow ( d * 35 ) ) . remainder ( new BigInteger ( \"1000\" ) ) ; while ( s . length ( ) < 3 ) { s = '0' + s ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + s ) ; } }"]]}, {"id": "6", "code": "import java . math . * ; import java . util . * ; public class z { static BigDecimal sqrt ( BigDecimal z ) { BigDecimal l = BigDecimal . valueOf ( 2 ) ; BigDecimal r = BigDecimal . valueOf ( 3 ) ; for ( int i = 0 ; i < 100 ; i ++ ) { BigDecimal x = l . add ( r ) . divide ( BigDecimal . valueOf ( 2 ) ) ; if ( x . multiply ( x ) . compareTo ( z ) >= 0 ) r = x ; else l = x ; } ; return l . add ( r ) . divide ( BigDecimal . valueOf ( 2 ) ) ; } ; public static void main ( String args [ ] ) { BigDecimal t1 = BigDecimal . valueOf ( 3 ) ; BigDecimal t2 = t1 . add ( sqrt ( BigDecimal . valueOf ( 5 ) ) ) ; String s [ ] = new String [ 31 ] ; BigDecimal p = t2 ; for ( int i = 1 ; i <= 30 ; i ++ ) { String q = \" \" + p ; int h = q . indexOf ( ' . ' ) ; int b = Math . max ( h - 3 , 0 ) ; q = q . substring ( b , h ) ; while ( q . length ( ) < 3 ) q = \"0\" + q ; s [ i ] = q ; p = p . multiply ( t2 ) ; } ; Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int h = in . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + s [ h ] ) ; } ; } ; } ;", "functions_standalone": [["sqrt", "static BigDecimal sqrt ( BigDecimal z ) { BigDecimal l = BigDecimal . valueOf ( 2 ) ; BigDecimal r = BigDecimal . valueOf ( 3 ) ; for ( int i = 0 ; i < 100 ; i ++ ) { BigDecimal x = l . add ( r ) . divide ( BigDecimal . valueOf ( 2 ) ) ; if ( x . multiply ( x ) . compareTo ( z ) >= 0 ) r = x ; else l = x ; } ; return l . add ( r ) . divide ( BigDecimal . valueOf ( 2 ) ) ; }"], ["main", "public static void main ( String args [ ] ) { BigDecimal t1 = BigDecimal . valueOf ( 3 ) ; BigDecimal t2 = t1 . add ( sqrt ( BigDecimal . valueOf ( 5 ) ) ) ; String s [ ] = new String [ 31 ] ; BigDecimal p = t2 ; for ( int i = 1 ; i <= 30 ; i ++ ) { String q = \" \" + p ; int h = q . indexOf ( ' . ' ) ; int b = Math . max ( h - 3 , 0 ) ; q = q . substring ( b , h ) ; while ( q . length ( ) < 3 ) q = \"0\" + q ; s [ i ] = q ; p = p . multiply ( t2 ) ; } ; Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int h = in . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + s [ h ] ) ; } ; }"]], "functions_class": []}], "python": [{"id": "4", "code": "import sys NEW_LINE _TYPE = { ' d ' : int , ' l ' : long , ' f ' : float , ' s ' : str } NEW_LINE _buffer = [ ] NEW_LINE def next_token ( ) : NEW_LINE INDENT if not _buffer : NEW_LINE INDENT line = sys . stdin . readline ( ) NEW_LINE _buffer . extend ( line . split ( ) ) NEW_LINE DEDENT return _buffer . pop ( 0 ) NEW_LINE DEDENT def scanf ( format ) : NEW_LINE INDENT if len ( format ) % 2 != 0 : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT for i in xrange ( 0 , len ( format ) , 2 ) : NEW_LINE INDENT if format [ i ] != ' % ' : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT if format [ i + 1 ] not in ' dfs ' : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT DEDENT result = [ ] NEW_LINE for i in xrange ( 1 , len ( format ) , 2 ) : NEW_LINE INDENT token = next_token ( ) NEW_LINE value = _TYPE [ format [ i ] ] ( token ) NEW_LINE result . append ( value ) NEW_LINE DEDENT return tuple ( result ) NEW_LINE DEDENT def printf ( format , * args ) : NEW_LINE INDENT message = format % args NEW_LINE sys . stdout . write ( message ) NEW_LINE return len ( message ) NEW_LINE DEDENT from decimal import * NEW_LINE getcontext ( ) . prec = 40 NEW_LINE base = Decimal ( '5.2360679774997896964091736687312762354406' ) NEW_LINE def solve ( ) : NEW_LINE INDENT n , = scanf ( ' % d ' ) NEW_LINE y = str ( base ** n ) NEW_LINE point_pos = y . index ( ' . ' ) NEW_LINE return y [ : point_pos ] [ - 3 : ] . zfill ( 3 ) NEW_LINE DEDENT num_cases , = scanf ( ' % d ' ) NEW_LINE for case_num in xrange ( num_cases ) : NEW_LINE INDENT result = solve ( ) NEW_LINE printf ( ' Case \u2581 # % d : \u2581 % s \\n ' , case_num + 1 , result ) NEW_LINE DEDENT", "functions_standalone": [["next_token", "def next_token ( ) : NEW_LINE INDENT if not _buffer : NEW_LINE INDENT line = sys . stdin . readline ( ) NEW_LINE _buffer . extend ( line . split ( ) ) NEW_LINE DEDENT return _buffer . pop ( 0 ) NEW_LINE DEDENT"], ["printf", "def printf ( format , * args ) : NEW_LINE INDENT message = format % args NEW_LINE sys . stdout . write ( message ) NEW_LINE return len ( message ) NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT n , = scanf ( ' % d ' ) NEW_LINE y = str ( base ** n ) NEW_LINE point_pos = y . index ( ' . ' ) NEW_LINE return y [ : point_pos ] [ - 3 : ] . zfill ( 3 ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "import sys , math NEW_LINE from decimal import Decimal , getcontext NEW_LINE def main ( ) : NEW_LINE INDENT fin = file ( sys . argv [ 1 ] ) NEW_LINE fout = file ( sys . argv [ 2 ] , \" wt \" ) NEW_LINE getcontext ( ) . prec = 50 NEW_LINE K = Decimal ( 3 ) + Decimal ( 5 ) . sqrt ( ) NEW_LINE numCases = int ( fin . readline ( ) ) NEW_LINE for case in xrange ( numCases ) : NEW_LINE INDENT exp = int ( fin . readline ( ) ) NEW_LINE answer = Decimal ( 1 ) NEW_LINE for n in xrange ( exp ) : NEW_LINE INDENT answer *= K NEW_LINE DEDENT fout . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( case + 1 , ( \"000\" + str ( int ( answer ) ) ) [ - 3 : ] ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT import doctest NEW_LINE doctest . testmod ( ) NEW_LINE main ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_08_22", "java": [{"id": "12", "code": "package common ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Helper { public static String [ ] getAllFileContentAsArray ( String filename ) throws Exception { BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ; List < String > all = new ArrayList < String > ( ) ; String s = in . readLine ( ) ; while ( s != null ) { all . add ( s ) ; s = in . readLine ( ) ; } in . close ( ) ; return all . toArray ( new String [ 0 ] ) ; } public static void writeToFile ( String [ ] cont , String filename ) throws Exception { File file = new File ( filename ) ; file . delete ( ) ; FileWriter w = null ; try { w = new FileWriter ( file , true ) ; for ( String s : cont ) { w . write ( s + \" \\n \" ) ; } } finally { if ( w != null ) { w . close ( ) ; } } } public static int [ ] getIntegersFromString ( String s ) throws Exception { List < Integer > a = new ArrayList < Integer > ( ) ; for ( String se : s . split ( \" \u2581 \" ) ) { try { Integer x = Integer . parseInt ( se ) ; a . add ( x ) ; } catch ( Exception e ) { } } int [ ] ret = new int [ a . size ( ) ] ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) { ret [ i ] = a . get ( i ) . intValue ( ) ; } return ret ; } private Helper ( ) { } }", "functions_standalone": [["getAllFileContentAsArray", "public static String [ ] getAllFileContentAsArray ( String filename ) throws Exception { BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ; List < String > all = new ArrayList < String > ( ) ; String s = in . readLine ( ) ; while ( s != null ) { all . add ( s ) ; s = in . readLine ( ) ; } in . close ( ) ; return all . toArray ( new String [ 0 ] ) ; }"], ["writeToFile", "public static void writeToFile ( String [ ] cont , String filename ) throws Exception { File file = new File ( filename ) ; file . delete ( ) ; FileWriter w = null ; try { w = new FileWriter ( file , true ) ; for ( String s : cont ) { w . write ( s + \" \\n \" ) ; } } finally { if ( w != null ) { w . close ( ) ; } } }"], ["getIntegersFromString", "public static int [ ] getIntegersFromString ( String s ) throws Exception { List < Integer > a = new ArrayList < Integer > ( ) ; for ( String se : s . split ( \" \u2581 \" ) ) { try { Integer x = Integer . parseInt ( se ) ; a . add ( x ) ; } catch ( Exception e ) { } } int [ ] ret = new int [ a . size ( ) ] ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) { ret [ i ] = a . get ( i ) . intValue ( ) ; } return ret ; }"]], "functions_class": [["Helper", "private Helper ( ) { }"]]}, {"id": "17", "code": "import java . util . Scanner ; import java . io . File ; import java . io . FileWriter ; import java . io . PrintWriter ; public class B { static int parents [ ] ; public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( new File ( \" B . in \" ) ) ; FileWriter fw = new FileWriter ( \" B . out \" ) ; PrintWriter out = new PrintWriter ( fw ) ; int test = in . nextInt ( ) ; for ( int t = 1 ; t <= test ; t ++ ) { long A = in . nextLong ( ) ; long B = in . nextLong ( ) ; long P = in . nextLong ( ) ; parents = new int [ ( int ) ( B - A + 1 ) ] ; for ( int i = 0 ; i < parents . length ; i ++ ) { parents [ i ] = i ; } int group = parents . length ; for ( long i = P ; i <= B - A ; i ++ ) { if ( isPrime ( i ) == true ) { long number = A / i * i ; if ( number < A ) { number += i ; } int root1 = getRoot ( ( int ) ( number - A ) ) ; for ( long j = number + i ; j <= B ; j += i ) { int root2 = getRoot ( ( int ) ( j - A ) ) ; if ( root1 != root2 ) { parents [ root2 ] = root1 ; group -- ; } } } } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + group ) ; } out . close ( ) ; fw . close ( ) ; } static boolean isPrime ( long number ) { for ( long i = 2 ; i * i <= number ; i ++ ) { if ( number % i == 0 ) { return false ; } } return true ; } static int getRoot ( int node ) { int root = node ; while ( parents [ root ] != root ) { root = parents [ root ] ; } while ( node != root ) { int temp = parents [ node ] ; parents [ node ] = root ; node = temp ; } return root ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( new File ( \" B . in \" ) ) ; FileWriter fw = new FileWriter ( \" B . out \" ) ; PrintWriter out = new PrintWriter ( fw ) ; int test = in . nextInt ( ) ; for ( int t = 1 ; t <= test ; t ++ ) { long A = in . nextLong ( ) ; long B = in . nextLong ( ) ; long P = in . nextLong ( ) ; parents = new int [ ( int ) ( B - A + 1 ) ] ; for ( int i = 0 ; i < parents . length ; i ++ ) { parents [ i ] = i ; } int group = parents . length ; for ( long i = P ; i <= B - A ; i ++ ) { if ( isPrime ( i ) == true ) { long number = A / i * i ; if ( number < A ) { number += i ; } int root1 = getRoot ( ( int ) ( number - A ) ) ; for ( long j = number + i ; j <= B ; j += i ) { int root2 = getRoot ( ( int ) ( j - A ) ) ; if ( root1 != root2 ) { parents [ root2 ] = root1 ; group -- ; } } } } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + group ) ; } out . close ( ) ; fw . close ( ) ; }"], ["isPrime", "static boolean isPrime ( long number ) { for ( long i = 2 ; i * i <= number ; i ++ ) { if ( number % i == 0 ) { return false ; } } return true ; }"], ["getRoot", "static int getRoot ( int node ) { int root = node ; while ( parents [ root ] != root ) { root = parents [ root ] ; } while ( node != root ) { int temp = parents [ node ] ; parents [ node ] = root ; node = temp ; } return root ; }"]], "functions_class": []}, {"id": "20", "code": "import java . math . BigInteger ; import java . util . HashSet ; import java . util . Scanner ; public class R1B_B { public static void main ( String [ ] args ) { Scanner scin = new Scanner ( System . in ) ; int N = scin . nextInt ( ) ; for ( int z = 1 ; z <= N ; ++ z ) { long A = scin . nextLong ( ) ; long B = scin . nextLong ( ) ; long P = scin . nextLong ( ) ; int [ ] equiv = new int [ ( int ) ( B + 1 ) ] ; for ( int i = ( int ) A ; i <= B ; ++ i ) equiv [ i ] = i ; for ( int i = ( int ) A ; i <= B ; ++ i ) { for ( int j = i + 1 ; j <= B ; ++ j ) { if ( equiv [ i ] == equiv [ j ] ) continue ; int gcd = ( int ) gcd ( i , j ) ; boolean ok = false ; for ( int k = ( int ) P ; k <= gcd ; ++ k ) { if ( new BigInteger ( \" \" + k ) . isProbablePrime ( 1024 ) && gcd % k == 0 ) { ok = true ; break ; } } if ( ok ) { for ( int k = ( int ) A ; k <= B ; ++ k ) { if ( equiv [ k ] == equiv [ j ] ) equiv [ k ] = equiv [ i ] ; } } } } HashSet < Integer > set = new HashSet < Integer > ( ) ; for ( int i : equiv ) set . add ( i ) ; System . out . println ( \" Case \u2581 # \" + z + \" : \u2581 \" + ( set . size ( ) - 1 ) ) ; } } static long gcd ( long a , long b ) { return new BigInteger ( \" \" + a ) . gcd ( new BigInteger ( \" \" + b ) ) . longValue ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner scin = new Scanner ( System . in ) ; int N = scin . nextInt ( ) ; for ( int z = 1 ; z <= N ; ++ z ) { long A = scin . nextLong ( ) ; long B = scin . nextLong ( ) ; long P = scin . nextLong ( ) ; int [ ] equiv = new int [ ( int ) ( B + 1 ) ] ; for ( int i = ( int ) A ; i <= B ; ++ i ) equiv [ i ] = i ; for ( int i = ( int ) A ; i <= B ; ++ i ) { for ( int j = i + 1 ; j <= B ; ++ j ) { if ( equiv [ i ] == equiv [ j ] ) continue ; int gcd = ( int ) gcd ( i , j ) ; boolean ok = false ; for ( int k = ( int ) P ; k <= gcd ; ++ k ) { if ( new BigInteger ( \" \" + k ) . isProbablePrime ( 1024 ) && gcd % k == 0 ) { ok = true ; break ; } } if ( ok ) { for ( int k = ( int ) A ; k <= B ; ++ k ) { if ( equiv [ k ] == equiv [ j ] ) equiv [ k ] = equiv [ i ] ; } } } } HashSet < Integer > set = new HashSet < Integer > ( ) ; for ( int i : equiv ) set . add ( i ) ; System . out . println ( \" Case \u2581 # \" + z + \" : \u2581 \" + ( set . size ( ) - 1 ) ) ; } }"], ["gcd", "static long gcd ( long a , long b ) { return new BigInteger ( \" \" + a ) . gcd ( new BigInteger ( \" \" + b ) ) . longValue ( ) ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "inp_file = file ( \" B - small . in \" ) NEW_LINE out_file = file ( \" B - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT A , B , P = [ int ( c1 ) for c1 in line . split ( \" \u2581 \" ) ] NEW_LINE numbers = range ( A , B + 1 ) NEW_LINE sets = range ( B - A + 1 ) NEW_LINE for c1 in primes : NEW_LINE INDENT if c1 < P : continue NEW_LINE if c1 > B / 2 + 1 : break NEW_LINE same = [ ] NEW_LINE for c2 in numbers : NEW_LINE INDENT if not c2 % c1 : same . append ( c2 - A ) NEW_LINE DEDENT sets = merge_sets ( sets , same ) NEW_LINE DEDENT counted = [ ] NEW_LINE c2 = 0 NEW_LINE for c1 in sets : NEW_LINE INDENT if not c1 in counted : NEW_LINE INDENT counted . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT DEDENT return str ( c2 ) NEW_LINE DEDENT def merge_sets ( sets , same ) : NEW_LINE INDENT to_change = [ sets [ c1 ] for c1 in same ] NEW_LINE for c1 in range ( len ( sets ) ) : NEW_LINE INDENT if sets [ c1 ] in to_change : NEW_LINE INDENT sets [ c1 ] = to_change [ 0 ] NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT p_file = file ( \" primes1000 . txt \" ) NEW_LINE primes = [ int ( c1 ) for c1 in p_file . read ( ) . split ( \" \\n \" ) ] NEW_LINE p_file . close ( ) NEW_LINE num = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT line = inp_file . readline ( ) [ : - 1 ] NEW_LINE out_file . write ( \" Case \u2581 # % s : \u2581 \" % ( case + 1 ) + solve ( line ) + \" \\n \" ) NEW_LINE DEDENT inp_file . close ( ) NEW_LINE out_file . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( line ) : NEW_LINE INDENT A , B , P = [ int ( c1 ) for c1 in line . split ( \" \u2581 \" ) ] NEW_LINE numbers = range ( A , B + 1 ) NEW_LINE sets = range ( B - A + 1 ) NEW_LINE for c1 in primes : NEW_LINE INDENT if c1 < P : continue NEW_LINE if c1 > B / 2 + 1 : break NEW_LINE same = [ ] NEW_LINE for c2 in numbers : NEW_LINE INDENT if not c2 % c1 : same . append ( c2 - A ) NEW_LINE DEDENT sets = merge_sets ( sets , same ) NEW_LINE DEDENT counted = [ ] NEW_LINE c2 = 0 NEW_LINE for c1 in sets : NEW_LINE INDENT if not c1 in counted : NEW_LINE INDENT counted . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT DEDENT return str ( c2 ) NEW_LINE DEDENT"], ["merge_sets", "def merge_sets ( sets , same ) : NEW_LINE INDENT to_change = [ sets [ c1 ] for c1 in same ] NEW_LINE for c1 in range ( len ( sets ) ) : NEW_LINE INDENT if sets [ c1 ] in to_change : NEW_LINE INDENT sets [ c1 ] = to_change [ 0 ] NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_04", "java": [{"id": "15", "code": "package cj2015 . qr ; import java . io . * ; import java . util . * ; public class D { Scanner sc ; PrintWriter pw ; int X , R , C ; public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" D - large \" ; try { new D ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } } public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; } void read ( Scanner sc ) { X = sc . nextInt ( ) ; R = sc . nextInt ( ) ; C = sc . nextInt ( ) ; } void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; } void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; } public void solve ( ) { if ( canFill ( X , R , C ) ) println ( \" GABRIEL \" ) ; else println ( \" RICHARD \" ) ; } public boolean canFill ( int x , int r , int c ) { if ( r > c ) { int temp = r ; r = c ; c = temp ; } if ( x >= 7 ) return false ; if ( ( r * c ) % x != 0 ) return false ; if ( x > c || ( x + 1 ) / 2 > r ) return false ; if ( x <= 3 ) return true ; if ( ( x + 1 ) / 2 == r ) if ( x == 4 || x == 6 || ( x == 5 && c == 5 ) ) return false ; return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" D - large \" ; try { new D ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } }"]], "functions_class": [["run", "public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; }"], ["read", "void read ( Scanner sc ) { X = sc . nextInt ( ) ; R = sc . nextInt ( ) ; C = sc . nextInt ( ) ; }"], ["print", "void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; }"], ["println", "void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; }"], ["solve", "public void solve ( ) { if ( canFill ( X , R , C ) ) println ( \" GABRIEL \" ) ; else println ( \" RICHARD \" ) ; }"], ["canFill", "public boolean canFill ( int x , int r , int c ) { if ( r > c ) { int temp = r ; r = c ; c = temp ; } if ( x >= 7 ) return false ; if ( ( r * c ) % x != 0 ) return false ; if ( x > c || ( x + 1 ) / 2 > r ) return false ; if ( x <= 3 ) return true ; if ( ( x + 1 ) / 2 == r ) if ( x == 4 || x == 6 || ( x == 5 && c == 5 ) ) return false ; return true ; }"]]}, {"id": "2", "code": "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Scanner ; public class D { static final String FILENAME = \" D - large \" ; static final String IN = FILENAME + \" . in \" ; static final String OUT = FILENAME + \" . out \" ; Scanner sc ; BufferedWriter out ; private void solve ( ) throws IOException { int x = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( x >= 7 || x > Math . max ( r , c ) || ( x + 1 ) / 2 > Math . min ( r , c ) || ( r * c ) % x != 0 || ( ( x + 1 ) / 2 == Math . min ( r , c ) && ( x == 4 || ( x == 5 && Math . max ( r , c ) < 6 ) || x == 6 ) ) ) { out . write ( \" RICHARD \" ) ; } else { out . write ( \" GABRIEL \" ) ; } out . newLine ( ) ; out . flush ( ) ; } private void run ( ) throws IOException { sc = new Scanner ( new File ( IN ) ) ; out = new BufferedWriter ( new FileWriter ( OUT ) ) ; int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { out . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } sc . close ( ) ; out . close ( ) ; } public static void main ( String args [ ] ) throws Exception { new D ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { new D ( ) . run ( ) ; }"]], "functions_class": [["solve", "private void solve ( ) throws IOException { int x = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( x >= 7 || x > Math . max ( r , c ) || ( x + 1 ) / 2 > Math . min ( r , c ) || ( r * c ) % x != 0 || ( ( x + 1 ) / 2 == Math . min ( r , c ) && ( x == 4 || ( x == 5 && Math . max ( r , c ) < 6 ) || x == 6 ) ) ) { out . write ( \" RICHARD \" ) ; } else { out . write ( \" GABRIEL \" ) ; } out . newLine ( ) ; out . flush ( ) ; }"], ["run", "private void run ( ) throws IOException { sc = new Scanner ( new File ( IN ) ) ; out = new BufferedWriter ( new FileWriter ( OUT ) ) ; int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { out . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } sc . close ( ) ; out . close ( ) ; }"]]}, {"id": "14", "code": "import java . io . File ; import java . io . PrintStream ; import java . util . Scanner ; public class D_Large { static final Boolean SAMPLE = false ; static final String PROBLEM = \" D \" ; static final String INPUT = \" large \" ; static final String ID = \"0\" ; static final String PATH = \" / Users / wangkai / Documents / codejam - commandline - 1.2 - beta1 / source / \" ; public static void main ( String [ ] args ) throws Throwable { Scanner in = SAMPLE ? new Scanner ( System . in ) : new Scanner ( new File ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . in \" ) ) ; PrintStream out = SAMPLE ? System . out : new PrintStream ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . out \" ) ; int test = in . nextInt ( ) ; for ( int t = 1 ; t <= test ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; int omino = in . nextInt ( ) ; int row = in . nextInt ( ) ; int col = in . nextInt ( ) ; boolean firstPlayerWin ; if ( row * col % omino != 0 ) { firstPlayerWin = true ; } else { int minSide = Math . min ( row , col ) ; int maxSide = Math . max ( row , col ) ; if ( omino == 1 ) { firstPlayerWin = false ; } else if ( omino == 2 ) { firstPlayerWin = false ; } else if ( omino == 3 ) { if ( minSide == 1 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else if ( omino == 4 ) { if ( minSide <= 2 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else if ( omino == 5 ) { if ( minSide <= 2 ) { firstPlayerWin = true ; } else if ( minSide == 3 ) { if ( maxSide == 5 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else { firstPlayerWin = false ; } } else if ( omino == 6 ) { if ( minSide <= 2 ) { firstPlayerWin = true ; } else if ( minSide == 3 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else { firstPlayerWin = true ; } } out . println ( firstPlayerWin ? \" RICHARD \" : \" GABRIEL \" ) ; } out . close ( ) ; in . close ( ) ; System . out . println ( \" finish ! \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { Scanner in = SAMPLE ? new Scanner ( System . in ) : new Scanner ( new File ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . in \" ) ) ; PrintStream out = SAMPLE ? System . out : new PrintStream ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . out \" ) ; int test = in . nextInt ( ) ; for ( int t = 1 ; t <= test ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; int omino = in . nextInt ( ) ; int row = in . nextInt ( ) ; int col = in . nextInt ( ) ; boolean firstPlayerWin ; if ( row * col % omino != 0 ) { firstPlayerWin = true ; } else { int minSide = Math . min ( row , col ) ; int maxSide = Math . max ( row , col ) ; if ( omino == 1 ) { firstPlayerWin = false ; } else if ( omino == 2 ) { firstPlayerWin = false ; } else if ( omino == 3 ) { if ( minSide == 1 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else if ( omino == 4 ) { if ( minSide <= 2 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else if ( omino == 5 ) { if ( minSide <= 2 ) { firstPlayerWin = true ; } else if ( minSide == 3 ) { if ( maxSide == 5 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else { firstPlayerWin = false ; } } else if ( omino == 6 ) { if ( minSide <= 2 ) { firstPlayerWin = true ; } else if ( minSide == 3 ) { firstPlayerWin = true ; } else { firstPlayerWin = false ; } } else { firstPlayerWin = true ; } } out . println ( firstPlayerWin ? \" RICHARD \" : \" GABRIEL \" ) ; } out . close ( ) ; in . close ( ) ; System . out . println ( \" finish ! \" ) ; }"]], "functions_class": []}, {"id": "6", "code": "package gcj2015 . qualif ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ExoD { public static void main ( final String [ ] args ) { final String base = \" / home / jean / gcj2015 / q / ExoD / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoD . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } private static void test ( final Scanner sc , final PrintWriter pw ) { final int X = sc . nextInt ( ) ; final int R = sc . nextInt ( ) ; final int C = sc . nextInt ( ) ; if ( X >= 7 || ( R * C ) % X != 0 ) { pw . print ( \" RICHARD \" ) ; } else { if ( X == 1 || X == 2 || ( X == 3 && ( R != 1 && C != 1 ) ) || ( X == 4 && ( R >= 4 && C > 2 || C >= 4 && R > 2 ) ) || ( X == 5 && ( ( R >= 4 && C >= 4 ) || ( R == 3 && C >= 10 || R >= 10 && C == 3 ) ) ) || ( X == 6 && ( R >= 4 && C >= 4 && ( R >= 6 || C >= 6 ) ) ) ) { pw . print ( \" GABRIEL \" ) ; } else { pw . print ( \" RICHARD \" ) ; } } } }", "functions_standalone": [["main", "public static void main ( final String [ ] args ) { final String base = \" / home / jean / gcj2015 / q / ExoD / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoD . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"], ["test", "private static void test ( final Scanner sc , final PrintWriter pw ) { final int X = sc . nextInt ( ) ; final int R = sc . nextInt ( ) ; final int C = sc . nextInt ( ) ; if ( X >= 7 || ( R * C ) % X != 0 ) { pw . print ( \" RICHARD \" ) ; } else { if ( X == 1 || X == 2 || ( X == 3 && ( R != 1 && C != 1 ) ) || ( X == 4 && ( R >= 4 && C > 2 || C >= 4 && R > 2 ) ) || ( X == 5 && ( ( R >= 4 && C >= 4 ) || ( R == 3 && C >= 10 || R >= 10 && C == 3 ) ) ) || ( X == 6 && ( R >= 4 && C >= 4 && ( R >= 6 || C >= 6 ) ) ) ) { pw . print ( \" GABRIEL \" ) ; } else { pw . print ( \" RICHARD \" ) ; } } }"]], "functions_class": []}, {"id": "18", "code": "import java . awt . geom . * ; import java . io . * ; import java . math . * ; import java . util . * ; import java . util . regex . * ; import static java . lang . Math . * ; import static java . lang . System . * ; public class D { boolean solve ( int caseNum ) { int x = in . nextInt ( ) ; int r = in . nextInt ( ) ; int c = in . nextInt ( ) ; int max = max ( r , c ) ; int min = min ( r , c ) ; if ( x >= 7 ) return false ; if ( r * c % x != 0 ) return false ; if ( x > max ) return false ; if ( x > min * 2 ) return false ; if ( x < min * 2 - 1 ) return true ; if ( x <= 2 ) return true ; if ( x == 3 ) { if ( min != 2 ) { debug ( \" x \u2581 = = \u2581 3 \u2581 & & \u2581 min \u2581 ! = \u2581 2\" ) ; } return true ; } if ( x == 4 ) { if ( min != 2 ) { debug ( \" x \u2581 = = \u2581 4 \u2581 & & \u2581 min \u2581 ! = \u2581 2\" ) ; } return false ; } if ( x == 5 ) { if ( min != 3 ) { debug ( \" x \u2581 = = \u2581 5 \u2581 & & \u2581 min \u2581 ! = \u2581 3\" ) ; } return max > 5 ; } if ( x == 6 ) { if ( min != 3 ) { debug ( \" x \u2581 = = \u2581 6 \u2581 & & \u2581 min \u2581 ! = \u2581 3\" ) ; } return false ; } debug ( \" never \u2581 reach \" ) ; return true ; } Scanner in = new Scanner ( System . in ) ; public D ( ) throws Exception { int caseCount = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= caseCount ; caseNum ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 \" , caseNum ) ; if ( solve ( caseNum ) ) { out . println ( \" GABRIEL \" ) ; } else { out . println ( \" RICHARD \" ) ; } } } public static void main ( String [ ] args ) throws Exception { new D ( ) ; } public static void debug ( Object ... arr ) { System . err . println ( Arrays . deepToString ( arr ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new D ( ) ; }"], ["debug", "public static void debug ( Object ... arr ) { System . err . println ( Arrays . deepToString ( arr ) ) ; }"]], "functions_class": [["solve", "boolean solve ( int caseNum ) { int x = in . nextInt ( ) ; int r = in . nextInt ( ) ; int c = in . nextInt ( ) ; int max = max ( r , c ) ; int min = min ( r , c ) ; if ( x >= 7 ) return false ; if ( r * c % x != 0 ) return false ; if ( x > max ) return false ; if ( x > min * 2 ) return false ; if ( x < min * 2 - 1 ) return true ; if ( x <= 2 ) return true ; if ( x == 3 ) { if ( min != 2 ) { debug ( \" x \u2581 = = \u2581 3 \u2581 & & \u2581 min \u2581 ! = \u2581 2\" ) ; } return true ; } if ( x == 4 ) { if ( min != 2 ) { debug ( \" x \u2581 = = \u2581 4 \u2581 & & \u2581 min \u2581 ! = \u2581 2\" ) ; } return false ; } if ( x == 5 ) { if ( min != 3 ) { debug ( \" x \u2581 = = \u2581 5 \u2581 & & \u2581 min \u2581 ! = \u2581 3\" ) ; } return max > 5 ; } if ( x == 6 ) { if ( min != 3 ) { debug ( \" x \u2581 = = \u2581 6 \u2581 & & \u2581 min \u2581 ! = \u2581 3\" ) ; } return false ; } debug ( \" never \u2581 reach \" ) ; return true ; }"], ["D", "public D ( ) throws Exception { int caseCount = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= caseCount ; caseNum ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 \" , caseNum ) ; if ( solve ( caseNum ) ) { out . println ( \" GABRIEL \" ) ; } else { out . println ( \" RICHARD \" ) ; } } }"]]}], "python": [{"id": "15", "code": "def winner ( X , S , L ) : NEW_LINE INDENT if S * L % X : return ' RICHARD ' NEW_LINE if X <= 2 : return ' GABRIEL ' NEW_LINE if X >= 7 : return ' RICHARD ' NEW_LINE if L < X : return ' RICHARD ' NEW_LINE if 2 * S <= X : return ' RICHARD ' NEW_LINE if ( X , S , L ) == ( 5 , 3 , 5 ) : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT return ' GABRIEL ' NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT X , R , C = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , winner ( X , min ( R , C ) , max ( R , C ) ) ) ) NEW_LINE DEDENT", "functions_standalone": [["winner", "def winner ( X , S , L ) : NEW_LINE INDENT if S * L % X : return ' RICHARD ' NEW_LINE if X <= 2 : return ' GABRIEL ' NEW_LINE if X >= 7 : return ' RICHARD ' NEW_LINE if L < X : return ' RICHARD ' NEW_LINE if 2 * S <= X : return ' RICHARD ' NEW_LINE if ( X , S , L ) == ( 5 , 3 , 5 ) : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT return ' GABRIEL ' NEW_LINE DEDENT"]], "functions_class": []}, {"id": "11", "code": "import math NEW_LINE import re NEW_LINE def solve ( x , r , c ) : NEW_LINE INDENT if x >= 7 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if ( r * c ) % x != 0 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if max ( r , c ) < x : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if min ( r , c ) < ( x + 1 ) / 2 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if max ( r , c ) == 5 and min ( r , c ) == 3 and x == 5 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if min ( r , c ) == x / 2 and x != 2 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT return \" GABRIEL \" NEW_LINE DEDENT inp = open ( \" D - large . in \" , \" r \" ) NEW_LINE out = open ( \" D - large \" , \" w \" ) NEW_LINE lines = inp . readlines ( ) NEW_LINE for i in range ( 1 , len ( lines ) ) : NEW_LINE INDENT l = [ int ( x ) for x in re . split ( \" \u2581 \" , lines [ i ] ) ] NEW_LINE out . write ( \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + solve ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) + \" \\n \" ) NEW_LINE DEDENT out . close ( ) NEW_LINE inp . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( x , r , c ) : NEW_LINE INDENT if x >= 7 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if ( r * c ) % x != 0 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if max ( r , c ) < x : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if min ( r , c ) < ( x + 1 ) / 2 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if max ( r , c ) == 5 and min ( r , c ) == 3 and x == 5 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if min ( r , c ) == x / 2 and x != 2 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT return \" GABRIEL \" NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "import sys NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( \" Case \u2581 # { } : \u2581 \" . format ( i + 1 ) ) NEW_LINE x , r , c = map ( int , sys . stdin . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE r , c = min ( r , c ) , max ( r , c ) NEW_LINE ans = ' GABRIEL ' NEW_LINE if x == 1 : NEW_LINE INDENT pass NEW_LINE DEDENT elif x > 6 : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT elif ( r * c ) % x != 0 : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT elif c < x : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT elif x > 2 and r == 1 : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT elif x > 4 and r < 3 : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT elif ( x , r ) == ( 4 , 2 ) : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT elif ( x , r , c ) == ( 5 , 3 , 5 ) : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT elif ( x , r ) == ( 6 , 3 ) : NEW_LINE INDENT ans = ' RICHARD ' NEW_LINE DEDENT sys . stdout . write ( \" { } \\n \" . format ( ans ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "3", "code": "def solver ( x , r , c ) : NEW_LINE INDENT if x > 6 : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT if ( r * c ) % x != 0 : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT if x <= 2 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT if x == 3 : NEW_LINE INDENT if min ( r , c ) > 1 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT if x == 4 : NEW_LINE INDENT if min ( r , c ) > 2 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT if x == 5 : NEW_LINE INDENT if min ( r , c ) > 2 and r + c > 8 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT if x == 6 : NEW_LINE INDENT if min ( r , c ) > 3 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT DEDENT import sys NEW_LINE with open ( sys . argv [ 1 ] , \" r \" ) as fileIN : NEW_LINE INDENT inputLines = fileIN . readlines ( ) NEW_LINE DEDENT inputLines = [ line . strip ( ) for line in inputLines ] NEW_LINE with open ( sys . argv [ 2 ] , \" w \" ) as fileOUT : NEW_LINE INDENT numberOfCases = int ( inputLines . pop ( 0 ) ) NEW_LINE for num in range ( numberOfCases ) : NEW_LINE INDENT inputlist = inputLines . pop ( 0 ) . rstrip ( ) . split ( ' \u2581 ' ) NEW_LINE x = int ( inputlist [ 0 ] ) NEW_LINE r = int ( inputlist [ 1 ] ) NEW_LINE c = int ( inputlist [ 2 ] ) NEW_LINE fileOUT . write ( ' Case \u2581 # ' + str ( num + 1 ) + ' : \u2581 ' + solver ( x , r , c ) + ' \\n ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solver", "def solver ( x , r , c ) : NEW_LINE INDENT if x > 6 : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT if ( r * c ) % x != 0 : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT if x <= 2 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT if x == 3 : NEW_LINE INDENT if min ( r , c ) > 1 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT if x == 4 : NEW_LINE INDENT if min ( r , c ) > 2 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT if x == 5 : NEW_LINE INDENT if min ( r , c ) > 2 and r + c > 8 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT if x == 6 : NEW_LINE INDENT if min ( r , c ) > 3 : NEW_LINE INDENT return ' GABRIEL ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "18", "code": "__author__ = ' Reuben ' NEW_LINE def solution ( dom_size , width , height ) : NEW_LINE INDENT if dom_size >= 7 or width * height % dom_size != 0 or dom_size > max ( width , height ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if dom_size == 1 or dom_size == 2 : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT if dom_size == 3 : NEW_LINE INDENT if height == 1 or width == 1 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT if dom_size == 4 : NEW_LINE INDENT if ( height <= 2 or width <= 2 ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT if dom_size == 5 : NEW_LINE INDENT if ( height <= 2 or width <= 2 ) or ( width == 3 and ( height < 10 or height % 5 != 0 ) ) or ( height == 3 and ( width < 10 or width % 5 != 0 ) ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT if dom_size == 6 : NEW_LINE INDENT if ( height <= 3 or width <= 3 ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT DEDENT f_in = open ( ' file . in ' ) NEW_LINE f_out = open ( ' file . out ' , ' w ' ) NEW_LINE cases = int ( f_in . readline ( ) ) NEW_LINE for i in range ( 1 , cases + 1 ) : NEW_LINE INDENT line = f_in . readline ( ) . split ( ) NEW_LINE dom_size = int ( line [ 0 ] ) NEW_LINE width = int ( line [ 1 ] ) NEW_LINE height = int ( line [ 2 ] ) NEW_LINE s = solution ( dom_size , width , height ) NEW_LINE f_out . write ( \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + s + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [["solution", "def solution ( dom_size , width , height ) : NEW_LINE INDENT if dom_size >= 7 or width * height % dom_size != 0 or dom_size > max ( width , height ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT if dom_size == 1 or dom_size == 2 : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT if dom_size == 3 : NEW_LINE INDENT if height == 1 or width == 1 : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT if dom_size == 4 : NEW_LINE INDENT if ( height <= 2 or width <= 2 ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT if dom_size == 5 : NEW_LINE INDENT if ( height <= 2 or width <= 2 ) or ( width == 3 and ( height < 10 or height % 5 != 0 ) ) or ( height == 3 and ( width < 10 or width % 5 != 0 ) ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT if dom_size == 6 : NEW_LINE INDENT if ( height <= 3 or width <= 3 ) : NEW_LINE INDENT return \" RICHARD \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" GABRIEL \" NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_32", "java": [{"id": "5", "code": "package c_2015 ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int kases = in . nextInt ( ) ; for ( int kas = 1 ; kas <= kases ; kas ++ ) { int K = in . nextInt ( ) ; int L = in . nextInt ( ) ; int S = in . nextInt ( ) ; String keyboard = in . next ( ) ; String target = in . next ( ) ; int [ ] keys = new int [ 26 ] ; for ( int i = 0 ; i < K ; i ++ ) keys [ keyboard . charAt ( i ) - ' A ' ] ++ ; boolean possible = true ; for ( int i = 0 ; i < L ; i ++ ) if ( keys [ target . charAt ( i ) - ' A ' ] == 0 ) possible = false ; if ( ! possible ) { System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 0.0\" ) ; continue ; } int [ ] EV = new int [ S ] ; int p ; outer : for ( p = L - 1 ; p > 0 ; p -- ) { for ( int i = 0 ; i < p ; i ++ ) { if ( target . charAt ( i ) != target . charAt ( L - p + i ) ) continue outer ; } break ; } int max = ( S - p ) / ( L - p ) ; double prob_word = 1 ; for ( int i = 0 ; i < L ; i ++ ) { prob_word *= keys [ target . charAt ( i ) - ' A ' ] / ( 0.0 + K ) ; } System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 \" + ( max - prob_word * ( S - L + 1 ) ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int kases = in . nextInt ( ) ; for ( int kas = 1 ; kas <= kases ; kas ++ ) { int K = in . nextInt ( ) ; int L = in . nextInt ( ) ; int S = in . nextInt ( ) ; String keyboard = in . next ( ) ; String target = in . next ( ) ; int [ ] keys = new int [ 26 ] ; for ( int i = 0 ; i < K ; i ++ ) keys [ keyboard . charAt ( i ) - ' A ' ] ++ ; boolean possible = true ; for ( int i = 0 ; i < L ; i ++ ) if ( keys [ target . charAt ( i ) - ' A ' ] == 0 ) possible = false ; if ( ! possible ) { System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 0.0\" ) ; continue ; } int [ ] EV = new int [ S ] ; int p ; outer : for ( p = L - 1 ; p > 0 ; p -- ) { for ( int i = 0 ; i < p ; i ++ ) { if ( target . charAt ( i ) != target . charAt ( L - p + i ) ) continue outer ; } break ; } int max = ( S - p ) / ( L - p ) ; double prob_word = 1 ; for ( int i = 0 ; i < L ; i ++ ) { prob_word *= keys [ target . charAt ( i ) - ' A ' ] / ( 0.0 + K ) ; } System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 \" + ( max - prob_word * ( S - L + 1 ) ) ) ; } }"]], "functions_class": []}, {"id": "14", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . LinkedList ; public class TypewriterMonkey { public static void main ( String [ ] args ) throws NumberFormatException , IOException { FileReader input = new FileReader ( args [ 0 ] ) ; BufferedReader buffer = new BufferedReader ( input ) ; int max = Integer . parseInt ( buffer . readLine ( ) . trim ( ) ) ; for ( int i = 1 ; i <= max ; i ++ ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solve ( buffer ) ) ; } } public static double solve ( BufferedReader buffer ) throws NumberFormatException , IOException { String [ ] split = buffer . readLine ( ) . trim ( ) . split ( \" \\\\ s + \" ) ; int K = Integer . parseInt ( split [ 0 ] ) ; int L = Integer . parseInt ( split [ 1 ] ) ; int S = Integer . parseInt ( split [ 2 ] ) ; String keys = buffer . readLine ( ) . trim ( ) ; String target = buffer . readLine ( ) . trim ( ) ; int differentStrings = ( int ) Math . pow ( K , S ) ; int max = 0 ; int sum = 0 ; for ( int i = 0 ; i < differentStrings ; i ++ ) { int number = i ; String result = new String ( ) ; for ( int j = 0 ; j < S ; j ++ ) { result = result . concat ( \" \" + keys . charAt ( number % K ) ) ; number /= K ; } int count = 0 ; int from = 0 ; while ( ( from = result . indexOf ( target , from ) + 1 ) > 0 ) { count ++ ; } sum += count ; if ( count > max ) max = count ; } return 1.0 * max - 1.0 * sum / differentStrings ; } }", "functions_standalone": [], "functions_class": [["println", "i ++ ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solve ( buffer ) ) ; }"], ["String", "i ++ ) { int number = i ; String result = new String ( ) ; for ( int j = 0 ; j < S ; j ++ ) { result = result . concat ( \" \" + keys . charAt ( number % K ) ) ; number /= K ; } int count = 0 ; int from = 0 ; while ( ( from = result . indexOf ( target , from ) + 1 ) > 0 ) { count ++ ; } sum += count ; if ( count > max ) max = count ; }"]]}, {"id": "17", "code": "import java . util . Arrays ; import java . util . Scanner ; public final class B { public static void main ( final String ... args ) { final Scanner sc = new Scanner ( System . in ) ; final int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; ++ i ) { System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % .7f \" , i + 1 , testcase ( sc ) ) ) ; } } private static double testcase ( final Scanner sc ) { final int k = sc . nextInt ( ) ; final int l = sc . nextInt ( ) ; final int s = sc . nextInt ( ) ; final String keyboard = sc . next ( ) ; final String text = sc . next ( ) ; final int [ ] perm = new int [ s ] ; Arrays . fill ( perm , 0 ) ; int maxOccurences = 0 ; double sum = 0.0 ; double denominator = 0 ; do { final StringBuilder builder = new StringBuilder ( s ) ; for ( int i = 0 ; i < s ; ++ i ) { builder . append ( keyboard . charAt ( perm [ i ] ) ) ; } final String result = builder . toString ( ) ; int howMany = 0 ; for ( int i = 0 ; i < s - l + 1 ; ++ i ) { if ( result . substring ( i , i + l ) . equals ( text ) ) { ++ howMany ; } } maxOccurences = Math . max ( maxOccurences , howMany ) ; sum += howMany ; ++ denominator ; } while ( nextPermutation ( perm , k ) ) ; return maxOccurences - ( sum / denominator ) ; } private static boolean nextPermutation ( final int [ ] perm , final int k ) { int i = 0 ; while ( i < perm . length && perm [ i ] == k - 1 ) { perm [ i ] = 0 ; ++ i ; } if ( i == perm . length ) { return false ; } ++ perm [ i ] ; return true ; } }", "functions_standalone": [["main", "public static void main ( final String ... args ) { final Scanner sc = new Scanner ( System . in ) ; final int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; ++ i ) { System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % .7f \" , i + 1 , testcase ( sc ) ) ) ; } }"], ["testcase", "private static double testcase ( final Scanner sc ) { final int k = sc . nextInt ( ) ; final int l = sc . nextInt ( ) ; final int s = sc . nextInt ( ) ; final String keyboard = sc . next ( ) ; final String text = sc . next ( ) ; final int [ ] perm = new int [ s ] ; Arrays . fill ( perm , 0 ) ; int maxOccurences = 0 ; double sum = 0.0 ; double denominator = 0 ; do { final StringBuilder builder = new StringBuilder ( s ) ; for ( int i = 0 ; i < s ; ++ i ) { builder . append ( keyboard . charAt ( perm [ i ] ) ) ; } final String result = builder . toString ( ) ; int howMany = 0 ; for ( int i = 0 ; i < s - l + 1 ; ++ i ) { if ( result . substring ( i , i + l ) . equals ( text ) ) { ++ howMany ; } } maxOccurences = Math . max ( maxOccurences , howMany ) ; sum += howMany ; ++ denominator ; } while ( nextPermutation ( perm , k ) ) ; return maxOccurences - ( sum / denominator ) ; }"], ["nextPermutation", "private static boolean nextPermutation ( final int [ ] perm , final int k ) { int i = 0 ; while ( i < perm . length && perm [ i ] == k - 1 ) { perm [ i ] = 0 ; ++ i ; } if ( i == perm . length ) { return false ; } ++ perm [ i ] ; return true ; }"]], "functions_class": []}, {"id": "16", "code": "import java . io . * ; import java . util . * ; public class SolutionB { static Scanner scan = new Scanner ( System . in ) ; static PrintStream out = System . out ; private static void solve ( ) { int K = scan . nextInt ( ) , L = scan . nextInt ( ) , S = scan . nextInt ( ) ; String keys = scan . next ( ) ; String word = scan . next ( ) ; int [ ] keyCounts = new int [ 26 ] ; for ( char c : keys . toCharArray ( ) ) { int k = ( int ) ( c - ' A ' ) ; keyCounts [ k ] ++ ; } int idx = 1 ; while ( idx < L ) { if ( word . substring ( 0 , L - idx ) . equals ( word . substring ( idx ) ) ) break ; ++ idx ; } int totalB = ( idx == L ) ? S / L : ( S - L ) / idx + 1 ; double percentage = 1 ; for ( char c : word . toCharArray ( ) ) { int k = ( int ) ( c - ' A ' ) ; int cnt = keyCounts [ k ] ; if ( cnt == 0 ) { out . println ( \"0.0\" ) ; return ; } percentage *= ( double ) cnt / K ; } out . println ( totalB - percentage * ( S - L + 1 ) ) ; } public static void main ( String [ ] args ) { int T = scan . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } } }", "functions_standalone": [["solve", "private static void solve ( ) { int K = scan . nextInt ( ) , L = scan . nextInt ( ) , S = scan . nextInt ( ) ; String keys = scan . next ( ) ; String word = scan . next ( ) ; int [ ] keyCounts = new int [ 26 ] ; for ( char c : keys . toCharArray ( ) ) { int k = ( int ) ( c - ' A ' ) ; keyCounts [ k ] ++ ; } int idx = 1 ; while ( idx < L ) { if ( word . substring ( 0 , L - idx ) . equals ( word . substring ( idx ) ) ) break ; ++ idx ; } int totalB = ( idx == L ) ? S / L : ( S - L ) / idx + 1 ; double percentage = 1 ; for ( char c : word . toCharArray ( ) ) { int k = ( int ) ( c - ' A ' ) ; int cnt = keyCounts [ k ] ; if ( cnt == 0 ) { out . println ( \"0.0\" ) ; return ; } percentage *= ( double ) cnt / K ; } out . println ( totalB - percentage * ( S - L + 1 ) ) ; }"], ["main", "public static void main ( String [ ] args ) { int T = scan . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } }"]], "functions_class": []}], "python": [{"id": "6", "code": "import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE T = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE K = int ( line [ 0 ] ) NEW_LINE L = int ( line [ 1 ] ) NEW_LINE S = int ( line [ 2 ] ) NEW_LINE keyboard = iFile . readline ( ) . strip ( ) NEW_LINE target = iFile . readline ( ) . strip ( ) NEW_LINE effectiveLength = len ( target ) NEW_LINE for strPos in range ( 1 , len ( target ) ) : NEW_LINE INDENT if target [ strPos : ] == target [ : - strPos ] : NEW_LINE INDENT effectiveLength = strPos NEW_LINE break NEW_LINE DEDENT DEDENT max_bananas = 1 + int ( ( S - len ( target ) ) / effectiveLength ) NEW_LINE single_prob = 1.0 NEW_LINE for letter in target : NEW_LINE INDENT if letter in keyboard : NEW_LINE INDENT single_prob *= keyboard . count ( letter ) / len ( keyboard ) NEW_LINE DEDENT else : NEW_LINE INDENT single_prob = 0.0 NEW_LINE max_bananas = 0 NEW_LINE break NEW_LINE DEDENT DEDENT total_prob = single_prob * ( S - len ( target ) + 1 ) NEW_LINE answer = max_bananas - total_prob NEW_LINE output = str ( answer ) NEW_LINE print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "def maximunBananas ( key , target , length ) : NEW_LINE INDENT if length < len ( target ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] not in d : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT advanced = len ( target ) NEW_LINE for i in range ( len ( target ) - 1 ) : NEW_LINE INDENT if target [ : i + 1 ] == target [ len ( target ) - i - 1 : ] : NEW_LINE INDENT advanced = len ( target ) - i - 1 NEW_LINE DEDENT DEDENT return 1 + int ( ( length - len ( target ) ) / advanced ) NEW_LINE DEDENT def expectedBananas ( key , target , length ) : NEW_LINE INDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT prob = 1 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] in d : NEW_LINE INDENT prob *= d [ target [ i ] ] / len ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return prob * ( length - len ( target ) + 1 ) NEW_LINE DEDENT def calculate ( ) : NEW_LINE INDENT k , l , s = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE key = input ( ) NEW_LINE target = input ( ) NEW_LINE return maximunBananas ( key , target , s ) - expectedBananas ( key , target , s ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["maximunBananas", "def maximunBananas ( key , target , length ) : NEW_LINE INDENT if length < len ( target ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] not in d : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT advanced = len ( target ) NEW_LINE for i in range ( len ( target ) - 1 ) : NEW_LINE INDENT if target [ : i + 1 ] == target [ len ( target ) - i - 1 : ] : NEW_LINE INDENT advanced = len ( target ) - i - 1 NEW_LINE DEDENT DEDENT return 1 + int ( ( length - len ( target ) ) / advanced ) NEW_LINE DEDENT"], ["expectedBananas", "def expectedBananas ( key , target , length ) : NEW_LINE INDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT prob = 1 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] in d : NEW_LINE INDENT prob *= d [ target [ i ] ] / len ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return prob * ( length - len ( target ) + 1 ) NEW_LINE DEDENT"], ["calculate", "def calculate ( ) : NEW_LINE INDENT k , l , s = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE key = input ( ) NEW_LINE target = input ( ) NEW_LINE return maximunBananas ( key , target , s ) - expectedBananas ( key , target , s ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "12", "code": "from __future__ import print_function , division NEW_LINE from collections import Counter NEW_LINE def overlap_shift ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s . startswith ( s [ i + 1 : ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT def tc ( tci ) : NEW_LINE INDENT [ klen , tlen , s ] = map ( int , raw_input ( ) . split ( ) ) NEW_LINE keyboard = raw_input ( ) NEW_LINE target = raw_input ( ) NEW_LINE assert klen == len ( keyboard ) NEW_LINE assert tlen == len ( target ) NEW_LINE assert s >= tlen NEW_LINE sol = 0.0 NEW_LINE counter = Counter ( keyboard ) NEW_LINE if all ( t in counter for t in target ) : NEW_LINE INDENT sh = overlap_shift ( target ) NEW_LINE occs = 1 + ( s - tlen ) // sh NEW_LINE p = 1.0 NEW_LINE for t in target : NEW_LINE INDENT p *= counter [ t ] / klen NEW_LINE DEDENT sol = occs - p * ( s - tlen + 1 ) NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { : . 15f } \" . format ( tci , sol ) ) NEW_LINE DEDENT tcn = int ( raw_input ( ) ) NEW_LINE for tci in range ( 1 , tcn + 1 ) : tc ( tci ) NEW_LINE", "functions_standalone": [["overlap_shift", "def overlap_shift ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s . startswith ( s [ i + 1 : ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT"], ["tc", "def tc ( tci ) : NEW_LINE INDENT [ klen , tlen , s ] = map ( int , raw_input ( ) . split ( ) ) NEW_LINE keyboard = raw_input ( ) NEW_LINE target = raw_input ( ) NEW_LINE assert klen == len ( keyboard ) NEW_LINE assert tlen == len ( target ) NEW_LINE assert s >= tlen NEW_LINE sol = 0.0 NEW_LINE counter = Counter ( keyboard ) NEW_LINE if all ( t in counter for t in target ) : NEW_LINE INDENT sh = overlap_shift ( target ) NEW_LINE occs = 1 + ( s - tlen ) // sh NEW_LINE p = 1.0 NEW_LINE for t in target : NEW_LINE INDENT p *= counter [ t ] / klen NEW_LINE DEDENT sol = occs - p * ( s - tlen + 1 ) NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { : . 15f } \" . format ( tci , sol ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_33", "java": [{"id": "5", "code": "package c_2015 ; import java . util . Scanner ; public class C { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int kases = in . nextInt ( ) ; for ( int kas = 1 ; kas <= kases ; kas ++ ) { int C = in . nextInt ( ) ; int D = in . nextInt ( ) ; int V = in . nextInt ( ) ; if ( kas == 31 ) { C = C ; } long max = 0 ; int added = 0 ; for ( int i = 0 ; i < D ; i ++ ) { long coin = in . nextLong ( ) ; while ( max + 1 < coin ) { max += C * ( max + 1 ) ; added ++ ; } max += C * coin ; } while ( max < V ) { max += C * ( max + 1 ) ; added ++ ; } System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 \" + added ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int kases = in . nextInt ( ) ; for ( int kas = 1 ; kas <= kases ; kas ++ ) { int C = in . nextInt ( ) ; int D = in . nextInt ( ) ; int V = in . nextInt ( ) ; if ( kas == 31 ) { C = C ; } long max = 0 ; int added = 0 ; for ( int i = 0 ; i < D ; i ++ ) { long coin = in . nextLong ( ) ; while ( max + 1 < coin ) { max += C * ( max + 1 ) ; added ++ ; } max += C * coin ; } while ( max < V ) { max += C * ( max + 1 ) ; added ++ ; } System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 \" + added ) ; } }"]], "functions_class": []}, {"id": "4", "code": "package round1c ; import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Kattio extends PrintWriter { public Kattio ( InputStream i ) { super ( new BufferedOutputStream ( System . out ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public Kattio ( InputStream i , OutputStream o ) { super ( new BufferedOutputStream ( o ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public boolean hasMoreTokens ( ) { return peekToken ( ) != null ; } public int getInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } public double getDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } public long getLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } public String getWord ( ) { return nextToken ( ) ; } private BufferedReader r ; private String line ; private StringTokenizer st ; private String token ; private String peekToken ( ) { if ( token == null ) try { while ( st == null || ! st . hasMoreTokens ( ) ) { line = r . readLine ( ) ; if ( line == null ) return null ; st = new StringTokenizer ( line ) ; } token = st . nextToken ( ) ; } catch ( IOException e ) { } return token ; } private String nextToken ( ) { String ans = peekToken ( ) ; token = null ; return ans ; } }", "functions_standalone": [], "functions_class": [["Kattio", "public Kattio ( InputStream i ) { super ( new BufferedOutputStream ( System . out ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; }"], ["Kattio", "public Kattio ( InputStream i , OutputStream o ) { super ( new BufferedOutputStream ( o ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; }"], ["hasMoreTokens", "public boolean hasMoreTokens ( ) { return peekToken ( ) != null ; }"], ["getInt", "public int getInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["getDouble", "public double getDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; }"], ["getLong", "public long getLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["getWord", "public String getWord ( ) { return nextToken ( ) ; }"], ["peekToken", "private String peekToken ( ) { if ( token == null ) try { while ( st == null || ! st . hasMoreTokens ( ) ) { line = r . readLine ( ) ; if ( line == null ) return null ; st = new StringTokenizer ( line ) ; } token = st . nextToken ( ) ; } catch ( IOException e ) { } return token ; }"], ["nextToken", "private String nextToken ( ) { String ans = peekToken ( ) ; token = null ; return ans ; }"]]}, {"id": "17", "code": "import java . io . * ; import java . util . * ; public class SolutionD { static Scanner scan = new Scanner ( System . in ) ; static PrintStream out = System . out ; private static boolean doable ( TreeSet < Long > demo , long C , long value ) { Iterator iter = demo . descendingIterator ( ) ; while ( iter . hasNext ( ) ) { long d = ( Long ) ( iter . next ( ) ) ; if ( value % d == 0 && value / d <= C ) return true ; value -= Math . min ( value / d , C ) * d ; } return false ; } private static void solve ( ) { long C = scan . nextLong ( ) , D = scan . nextLong ( ) , V = scan . nextLong ( ) ; TreeSet < Long > demo = new TreeSet < Long > ( ) ; for ( int i = 0 ; i < D ; ++ i ) demo . add ( scan . nextLong ( ) ) ; long value = 1 ; while ( value <= V ) { if ( demo . contains ( value ) ) { value = value * ( C + 1 ) ; } else if ( ! doable ( demo , C , value ) ) { demo . add ( value ) ; value = value * ( C + 1 ) ; } else { long sum = 0 ; for ( long t : demo ) { if ( t <= value ) sum += C * t ; } value = Math . max ( value + 1 , sum ) ; } } out . println ( demo . size ( ) - D ) ; } public static void main ( String [ ] args ) { int T = scan . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } } }", "functions_standalone": [["doable", "private static boolean doable ( TreeSet < Long > demo , long C , long value ) { Iterator iter = demo . descendingIterator ( ) ; while ( iter . hasNext ( ) ) { long d = ( Long ) ( iter . next ( ) ) ; if ( value % d == 0 && value / d <= C ) return true ; value -= Math . min ( value / d , C ) * d ; } return false ; }"], ["solve", "private static void solve ( ) { long C = scan . nextLong ( ) , D = scan . nextLong ( ) , V = scan . nextLong ( ) ; TreeSet < Long > demo = new TreeSet < Long > ( ) ; for ( int i = 0 ; i < D ; ++ i ) demo . add ( scan . nextLong ( ) ) ; long value = 1 ; while ( value <= V ) { if ( demo . contains ( value ) ) { value = value * ( C + 1 ) ; } else if ( ! doable ( demo , C , value ) ) { demo . add ( value ) ; value = value * ( C + 1 ) ; } else { long sum = 0 ; for ( long t : demo ) { if ( t <= value ) sum += C * t ; } value = Math . max ( value + 1 , sum ) ; } } out . println ( demo . size ( ) - D ) ; }"], ["main", "public static void main ( String [ ] args ) { int T = scan . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } }"]], "functions_class": []}, {"id": "15", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . LinkedList ; public class LessMoneyMoreProblems { public static void main ( String [ ] args ) throws NumberFormatException , IOException { FileReader input = new FileReader ( args [ 0 ] ) ; BufferedReader buffer = new BufferedReader ( input ) ; int max = Integer . parseInt ( buffer . readLine ( ) . trim ( ) ) ; for ( int i = 1 ; i <= max ; i ++ ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solve ( buffer ) ) ; } } public static long solve ( BufferedReader buffer ) throws NumberFormatException , IOException { String [ ] split = buffer . readLine ( ) . trim ( ) . split ( \" \\\\ s + \" ) ; long C = Long . parseLong ( split [ 0 ] ) ; int D = Integer . parseInt ( split [ 1 ] ) ; long V = Long . parseLong ( split [ 2 ] ) ; String [ ] sCoins = buffer . readLine ( ) . trim ( ) . split ( \" \\\\ s + \" ) ; long [ ] coins = new long [ D ] ; for ( int i = 0 ; i < D ; i ++ ) { coins [ i ] = Long . parseLong ( sCoins [ i ] ) ; } int index = 0 ; long current = 0 ; long count = 0 ; while ( current < V ) { if ( index < D && coins [ index ] <= current + 1 ) { current += C * coins [ index ] ; index ++ ; } else { current += C * ( current + 1 ) ; count ++ ; } } return count ; } }", "functions_standalone": [], "functions_class": [["println", "i ++ ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solve ( buffer ) ) ; }"], ["parseLong", "i ++ ) { coins [ i ] = Long . parseLong ( sCoins [ i ] ) ; }"], ["while", "while ( current < V ) { if ( index < D && coins [ index ] <= current + 1 ) { current += C * coins [ index ] ; index ++ ; } else { current += C * ( current + 1 ) ; count ++ ; } }"]]}, {"id": "1", "code": "import java . io . BufferedWriter ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Arrays ; import java . util . Locale ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try { Scanner scanner = new Scanner ( new FileInputStream ( \" input . txt \" ) ) ; scanner . useLocale ( Locale . ENGLISH ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" output1 . txt \" ) ) ; int tests = scanner . nextInt ( ) ; for ( int i = 0 ; i < tests ; i ++ ) { long c = scanner . nextLong ( ) ; int d = scanner . nextInt ( ) ; long v = scanner . nextLong ( ) ; long [ ] values = new long [ d ] ; for ( int j = 0 ; j < d ; j ++ ) { values [ j ] = scanner . nextLong ( ) ; } long result = 0 ; long netWorth = 0 ; int j = 0 ; while ( netWorth < v ) { if ( j < values . length && values [ j ] <= netWorth + 1 ) { netWorth += c * values [ j ] ; j ++ ; } else { netWorth += c * ( netWorth + 1 ) ; result ++ ; } } out . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + result + \" \\n \" ) ; out . flush ( ) ; } out . close ( ) ; } catch ( FileNotFoundException e ) { } catch ( IOException e ) { } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { Scanner scanner = new Scanner ( new FileInputStream ( \" input . txt \" ) ) ; scanner . useLocale ( Locale . ENGLISH ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( \" output1 . txt \" ) ) ; int tests = scanner . nextInt ( ) ; for ( int i = 0 ; i < tests ; i ++ ) { long c = scanner . nextLong ( ) ; int d = scanner . nextInt ( ) ; long v = scanner . nextLong ( ) ; long [ ] values = new long [ d ] ; for ( int j = 0 ; j < d ; j ++ ) { values [ j ] = scanner . nextLong ( ) ; } long result = 0 ; long netWorth = 0 ; int j = 0 ; while ( netWorth < v ) { if ( j < values . length && values [ j ] <= netWorth + 1 ) { netWorth += c * values [ j ] ; j ++ ; } else { netWorth += c * ( netWorth + 1 ) ; result ++ ; } } out . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + result + \" \\n \" ) ; out . flush ( ) ; } out . close ( ) ; } catch ( FileNotFoundException e ) { } catch ( IOException e ) { } }"]], "functions_class": []}], "python": [{"id": "6", "code": "import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE T = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE C = int ( line [ 0 ] ) NEW_LINE D = int ( line [ 1 ] ) NEW_LINE V = int ( line [ 2 ] ) NEW_LINE denominations = [ int ( x ) for x in iFile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE denominations . append ( V + 1 ) NEW_LINE covered = 0 NEW_LINE additions = 0 NEW_LINE for denom in denominations : NEW_LINE INDENT while denom > covered + 1 : NEW_LINE INDENT additions += 1 NEW_LINE covered += C * ( covered + 1 ) NEW_LINE DEDENT covered += C * denom NEW_LINE DEDENT answer = additions NEW_LINE output = str ( answer ) NEW_LINE print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "def calculate ( ) : NEW_LINE INDENT c , d , v = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE coins = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE currentMax = 0 ; NEW_LINE extraCoin = 0 ; NEW_LINE for i in range ( len ( coins ) ) : NEW_LINE INDENT if currentMax > v : NEW_LINE INDENT return extraCoin NEW_LINE DEDENT while currentMax < coins [ i ] - 1 : NEW_LINE INDENT extraCoin += 1 NEW_LINE currentMax += ( currentMax + 1 ) * c NEW_LINE DEDENT currentMax += coins [ i ] * c NEW_LINE DEDENT while currentMax < v : NEW_LINE INDENT extraCoin += 1 NEW_LINE currentMax += ( currentMax + 1 ) * c NEW_LINE DEDENT return extraCoin NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["calculate", "def calculate ( ) : NEW_LINE INDENT c , d , v = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE coins = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE currentMax = 0 ; NEW_LINE extraCoin = 0 ; NEW_LINE for i in range ( len ( coins ) ) : NEW_LINE INDENT if currentMax > v : NEW_LINE INDENT return extraCoin NEW_LINE DEDENT while currentMax < coins [ i ] - 1 : NEW_LINE INDENT extraCoin += 1 NEW_LINE currentMax += ( currentMax + 1 ) * c NEW_LINE DEDENT currentMax += coins [ i ] * c NEW_LINE DEDENT while currentMax < v : NEW_LINE INDENT extraCoin += 1 NEW_LINE currentMax += ( currentMax + 1 ) * c NEW_LINE DEDENT return extraCoin NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "17", "code": "def solve ( test ) : NEW_LINE INDENT c , n , v = map ( int , input ( ) . split ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( a ) NEW_LINE ans = 0 NEW_LINE cur = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while cur < a [ i ] - 1 : NEW_LINE INDENT ans += 1 NEW_LINE cur += ( cur + 1 ) * c NEW_LINE DEDENT cur += a [ i ] * c NEW_LINE DEDENT while cur < v : NEW_LINE INDENT ans += 1 NEW_LINE cur += ( cur + 1 ) * c NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( test , ans ) ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT solve ( i + 1 ) ; NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( test ) : NEW_LINE INDENT c , n , v = map ( int , input ( ) . split ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( a ) NEW_LINE ans = 0 NEW_LINE cur = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while cur < a [ i ] - 1 : NEW_LINE INDENT ans += 1 NEW_LINE cur += ( cur + 1 ) * c NEW_LINE DEDENT cur += a [ i ] * c NEW_LINE DEDENT while cur < v : NEW_LINE INDENT ans += 1 NEW_LINE cur += ( cur + 1 ) * c NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( test , ans ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "12", "code": "C = 0 NEW_LINE D = 0 NEW_LINE V = 0 NEW_LINE h = [ ] NEW_LINE def solve ( ) : NEW_LINE INDENT r = raw_input ( ) . split ( ) NEW_LINE C = int ( r [ 0 ] ) NEW_LINE D = int ( r [ 1 ] ) NEW_LINE V = int ( r [ 2 ] ) NEW_LINE h = raw_input ( ) . split ( ) NEW_LINE for i in range ( len ( h ) ) : NEW_LINE INDENT h [ i ] = int ( h [ i ] ) NEW_LINE DEDENT h = sorted ( h ) NEW_LINE q = 1 NEW_LINE summ = 0 NEW_LINE i = 0 NEW_LINE ret = 0 NEW_LINE while ( q <= V ) : NEW_LINE INDENT if ( i < D and h [ i ] <= q ) : NEW_LINE INDENT summ = summ + C * h [ i ] NEW_LINE i = i + 1 NEW_LINE q = summ + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret + 1 NEW_LINE summ = summ + C * q NEW_LINE q = summ + 1 NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT TTT = int ( input ( ) ) NEW_LINE for ttt in range ( 1 , TTT + 1 ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( ttt , solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT r = raw_input ( ) . split ( ) NEW_LINE C = int ( r [ 0 ] ) NEW_LINE D = int ( r [ 1 ] ) NEW_LINE V = int ( r [ 2 ] ) NEW_LINE h = raw_input ( ) . split ( ) NEW_LINE for i in range ( len ( h ) ) : NEW_LINE INDENT h [ i ] = int ( h [ i ] ) NEW_LINE DEDENT h = sorted ( h ) NEW_LINE q = 1 NEW_LINE summ = 0 NEW_LINE i = 0 NEW_LINE ret = 0 NEW_LINE while ( q <= V ) : NEW_LINE INDENT if ( i < D and h [ i ] <= q ) : NEW_LINE INDENT summ = summ + C * h [ i ] NEW_LINE i = i + 1 NEW_LINE q = summ + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret + 1 NEW_LINE summ = summ + C * q NEW_LINE q = summ + 1 NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_02", "java": [{"id": "15", "code": "package cj2015 . qr ; import java . io . * ; import java . util . * ; public class B { Scanner sc ; PrintWriter pw ; int D ; int [ ] P ; public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" B - large \" ; try { new B ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } } public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; } void read ( Scanner sc ) { D = sc . nextInt ( ) ; P = new int [ D ] ; for ( int i = 0 ; i < D ; i ++ ) P [ i ] = sc . nextInt ( ) ; } void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; } void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; } public void solve ( ) { final int INF = 1000000 ; int min = INF ; for ( int x = 1 ; x <= 1000 ; x ++ ) { int time = 0 ; for ( int i = 0 ; i < D ; i ++ ) time += ( P [ i ] + x - 1 ) / x - 1 ; min = Math . min ( min , time + x ) ; } println ( min ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" B - large \" ; try { new B ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } }"]], "functions_class": [["run", "public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; }"], ["read", "void read ( Scanner sc ) { D = sc . nextInt ( ) ; P = new int [ D ] ; for ( int i = 0 ; i < D ; i ++ ) P [ i ] = sc . nextInt ( ) ; }"], ["print", "void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; }"], ["println", "void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; }"], ["solve", "public void solve ( ) { final int INF = 1000000 ; int min = INF ; for ( int x = 1 ; x <= 1000 ; x ++ ) { int time = 0 ; for ( int i = 0 ; i < D ; i ++ ) time += ( P [ i ] + x - 1 ) / x - 1 ; min = Math . min ( min , time + x ) ; } println ( min ) ; }"]]}, {"id": "2", "code": "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Scanner ; public class B { static final String FILENAME = \" B - large \" ; static final String IN = FILENAME + \" . in \" ; static final String OUT = FILENAME + \" . out \" ; Scanner sc ; BufferedWriter out ; static final int MAXP = 1000 ; private int divideTime ( int [ ] num , int limit ) { int time = 0 ; for ( int i = limit + 1 ; i <= MAXP ; i ++ ) { time += num [ i ] * ( ( i - 1 ) / limit ) ; } return time ; } private void solve ( ) throws IOException { int ans = Integer . MAX_VALUE ; int d = sc . nextInt ( ) ; int [ ] num = new int [ MAXP + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) { num [ sc . nextInt ( ) ] ++ ; } for ( int limit = 1 ; limit <= MAXP ; limit ++ ) { int cur = divideTime ( num , limit ) + limit ; if ( ans > cur ) { ans = cur ; } } out . write ( Integer . toString ( ans ) ) ; out . newLine ( ) ; out . flush ( ) ; } private void run ( ) throws IOException { sc = new Scanner ( new File ( IN ) ) ; out = new BufferedWriter ( new FileWriter ( OUT ) ) ; int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { out . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } sc . close ( ) ; out . close ( ) ; } public static void main ( String args [ ] ) throws Exception { new B ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Exception { new B ( ) . run ( ) ; }"]], "functions_class": [["divideTime", "private int divideTime ( int [ ] num , int limit ) { int time = 0 ; for ( int i = limit + 1 ; i <= MAXP ; i ++ ) { time += num [ i ] * ( ( i - 1 ) / limit ) ; } return time ; }"], ["solve", "private void solve ( ) throws IOException { int ans = Integer . MAX_VALUE ; int d = sc . nextInt ( ) ; int [ ] num = new int [ MAXP + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) { num [ sc . nextInt ( ) ] ++ ; } for ( int limit = 1 ; limit <= MAXP ; limit ++ ) { int cur = divideTime ( num , limit ) + limit ; if ( ans > cur ) { ans = cur ; } } out . write ( Integer . toString ( ans ) ) ; out . newLine ( ) ; out . flush ( ) ; }"], ["run", "private void run ( ) throws IOException { sc = new Scanner ( new File ( IN ) ) ; out = new BufferedWriter ( new FileWriter ( OUT ) ) ; int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { out . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } sc . close ( ) ; out . close ( ) ; }"]]}, {"id": "1", "code": "import java . io . * ; import java . util . * ; import java . util . concurrent . * ; public class B { int n ; int [ ] a ; String solve ( ) { Arrays . sort ( a ) ; int m = a [ n - 1 ] ; int ans = m ; for ( int k = 1 ; k <= m ; k ++ ) { int divs = 0 ; for ( int x : a ) { divs += ( x - 1 ) / k ; } ans = Math . min ( ans , k + divs ) ; } return \" \" + ans ; } public B ( Scanner in ) { n = in . nextInt ( ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } } private static String fileName = B . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) . toLowerCase ( ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; public static void main ( String [ ] args ) throws IOException , InterruptedException , ExecutionException { ExecutorService executor = Executors . newFixedThreadPool ( 4 ) ; Locale . setDefault ( Locale . US ) ; Scanner in = new Scanner ( new File ( inputFileName ) ) ; PrintWriter out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; @ SuppressWarnings ( \" unchecked \" ) Future < String > [ ] outputs = new Future [ tests ] ; for ( int t = 0 ; t < tests ; t ++ ) { final B testCase = new B ( in ) ; final int testCaseNumber = t ; outputs [ t ] = executor . submit ( new Callable < String > ( ) { @ Override public String call ( ) { String answer = testCase . solve ( ) ; String printed = \" Case \u2581 # \" + ( testCaseNumber + 1 ) + \" : \u2581 \" + answer ; System . out . println ( printed ) ; return printed ; } } ) ; } for ( int t = 0 ; t < tests ; t ++ ) { out . println ( outputs [ t ] . get ( ) ) ; } in . close ( ) ; out . close ( ) ; executor . shutdown ( ) ; } }", "functions_standalone": [], "functions_class": [["solve", "String solve ( ) { Arrays . sort ( a ) ; int m = a [ n - 1 ] ; int ans = m ; for ( int k = 1 ; k <= m ; k ++ ) { int divs = 0 ; for ( int x : a ) { divs += ( x - 1 ) / k ; } ans = Math . min ( ans , k + divs ) ; } return \" \" + ans ; }"], ["B", "public B ( Scanner in ) { n = in . nextInt ( ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } }"], ["B", "t ++ ) { final B testCase = new B ( in ) ; final int testCaseNumber = t ; outputs [ t ] = executor . submit ( new Callable < String > ( ) { @ Override public String call ( ) { String answer = testCase . solve ( ) ; String printed = \" Case \u2581 # \" + ( testCaseNumber + 1 ) + \" : \u2581 \" + answer ; System . out . println ( printed ) ; return printed ; } } ) ; }"], ["println", "t ++ ) { out . println ( outputs [ t ] . get ( ) ) ; }"]]}, {"id": "7", "code": "import java . util . * ; import java . io . * ; public class InfinitePancakes { static final String filename = \" C : / Users / Kevin / algs4 / CodeJam / InfinitePancakes / B - large . in \" ; static final String output = \" largeoutput . txt \" ; public static int howLong ( int [ ] cakecounts ) { if ( cakecounts . length < 4 ) return cakecounts . length - 1 ; int ret = Integer . MAX_VALUE ; for ( int maxsize = 2 ; maxsize < cakecounts . length ; ++ maxsize ) { int [ ] cakes = Arrays . copyOf ( cakecounts , cakecounts . length ) ; int numspec = 0 ; int maxstack = cakecounts . length - 1 ; while ( maxstack > maxsize ) { while ( cakes [ maxstack ] > 0 ) { cakes [ maxstack ] -- ; cakes [ maxstack - maxsize ] ++ ; cakes [ maxsize ] ++ ; numspec ++ ; } maxstack -- ; } ret = Math . min ( ret , maxsize + numspec ) ; } return ret ; } public static void main ( String [ ] args ) { try { Scanner sc = new Scanner ( new FileInputStream ( new File ( filename ) ) ) ; int no_of_times = sc . nextInt ( ) ; for ( int i = 0 ; i < no_of_times ; ++ i ) { int D = sc . nextInt ( ) ; int [ ] platenumbers = new int [ D ] ; int maxnumber = 0 ; for ( int j = 0 ; j < D ; ++ j ) { platenumbers [ j ] = sc . nextInt ( ) ; maxnumber = Math . max ( maxnumber , platenumbers [ j ] ) ; } int [ ] cakecounts = new int [ maxnumber + 1 ] ; for ( int j = 0 ; j < D ; ++ j ) { cakecounts [ platenumbers [ j ] ] ++ ; } FileOutputStream fos = new FileOutputStream ( output , true ) ; fos . write ( ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + howLong ( cakecounts ) + \" \\n \" ) . getBytes ( ) ) ; fos . close ( ) ; } sc . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["howLong", "public static int howLong ( int [ ] cakecounts ) { if ( cakecounts . length < 4 ) return cakecounts . length - 1 ; int ret = Integer . MAX_VALUE ; for ( int maxsize = 2 ; maxsize < cakecounts . length ; ++ maxsize ) { int [ ] cakes = Arrays . copyOf ( cakecounts , cakecounts . length ) ; int numspec = 0 ; int maxstack = cakecounts . length - 1 ; while ( maxstack > maxsize ) { while ( cakes [ maxstack ] > 0 ) { cakes [ maxstack ] -- ; cakes [ maxstack - maxsize ] ++ ; cakes [ maxsize ] ++ ; numspec ++ ; } maxstack -- ; } ret = Math . min ( ret , maxsize + numspec ) ; } return ret ; }"], ["main", "public static void main ( String [ ] args ) { try { Scanner sc = new Scanner ( new FileInputStream ( new File ( filename ) ) ) ; int no_of_times = sc . nextInt ( ) ; for ( int i = 0 ; i < no_of_times ; ++ i ) { int D = sc . nextInt ( ) ; int [ ] platenumbers = new int [ D ] ; int maxnumber = 0 ; for ( int j = 0 ; j < D ; ++ j ) { platenumbers [ j ] = sc . nextInt ( ) ; maxnumber = Math . max ( maxnumber , platenumbers [ j ] ) ; } int [ ] cakecounts = new int [ maxnumber + 1 ] ; for ( int j = 0 ; j < D ; ++ j ) { cakecounts [ platenumbers [ j ] ] ++ ; } FileOutputStream fos = new FileOutputStream ( output , true ) ; fos . write ( ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + howLong ( cakecounts ) + \" \\n \" ) . getBytes ( ) ) ; fos . close ( ) ; } sc . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "6", "code": "package gcj2015 . qualif ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ExoB { public static void main ( final String [ ] args ) { final String base = \" / home / jean / gcj2015 / q / ExoB / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b2 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test3 ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } private static void test3 ( final Scanner sc , final PrintWriter pw ) { final int D = sc . nextInt ( ) ; List < Integer > nums = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < D ; i ++ ) { nums . add ( sc . nextInt ( ) ) ; } int max = Collections . max ( nums ) ; int bt = max ; for ( int m = 1 ; m <= max ; m ++ ) { System . out . println ( \" for \u2581 m \u2581 = \u2581 \" + m ) ; int t = m ; for ( int k : nums ) { if ( k != 0 ) t += ( k % m == 0 ) ? ( k / m ) - 1 : k / m ; } System . out . println ( \" t \u2581 = \u2581 \" + t ) ; if ( t < bt ) { bt = t ; } } pw . print ( bt ) ; } }", "functions_standalone": [["main", "public static void main ( final String [ ] args ) { final String base = \" / home / jean / gcj2015 / q / ExoB / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b2 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test3 ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"], ["test3", "private static void test3 ( final Scanner sc , final PrintWriter pw ) { final int D = sc . nextInt ( ) ; List < Integer > nums = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < D ; i ++ ) { nums . add ( sc . nextInt ( ) ) ; } int max = Collections . max ( nums ) ; int bt = max ; for ( int m = 1 ; m <= max ; m ++ ) { System . out . println ( \" for \u2581 m \u2581 = \u2581 \" + m ) ; int t = m ; for ( int k : nums ) { if ( k != 0 ) t += ( k % m == 0 ) ? ( k / m ) - 1 : k / m ; } System . out . println ( \" t \u2581 = \u2581 \" + t ) ; if ( t < bt ) { bt = t ; } } pw . print ( bt ) ; }"]], "functions_class": []}], "python": [{"id": "9", "code": "import math NEW_LINE import re NEW_LINE def solve ( l ) : NEW_LINE INDENT s = max ( l ) NEW_LINE for a in range ( 1 , s ) : NEW_LINE INDENT s = min ( s , reduce ( lambda x , y : x - ( - y ) / a - 1 , l , a ) ) NEW_LINE DEDENT return ( s ) NEW_LINE DEDENT inp = open ( \" B - large . in \" , \" r \" ) NEW_LINE out = open ( \" B - large \" , \" w \" ) NEW_LINE lines = inp . readlines ( ) NEW_LINE for i in range ( 1 , len ( lines ) / 2 + 1 ) : NEW_LINE INDENT l = [ int ( x ) for x in re . split ( \" \u2581 \" , lines [ 2 * i ] ) ] NEW_LINE out . write ( \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + str ( solve ( l ) ) + \" \\n \" ) NEW_LINE DEDENT out . close ( ) NEW_LINE inp . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( l ) : NEW_LINE INDENT s = max ( l ) NEW_LINE for a in range ( 1 , s ) : NEW_LINE INDENT s = min ( s , reduce ( lambda x , y : x - ( - y ) / a - 1 , l , a ) ) NEW_LINE DEDENT return ( s ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "DESCRIPTION = \"\"\" STRNEWLINE \"\"\" NEW_LINE import os NEW_LINE import sys NEW_LINE import argparse NEW_LINE def perr ( msg ) : NEW_LINE INDENT sys . stderr . write ( \" % s \" % msg ) NEW_LINE sys . stderr . flush ( ) NEW_LINE DEDENT def pinfo ( msg ) : NEW_LINE INDENT sys . stdout . write ( \" % s \" % msg ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT def runcmd ( cmd ) : NEW_LINE INDENT perr ( \" % s \\n \" % cmd ) NEW_LINE os . system ( cmd ) NEW_LINE DEDENT def getargs ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = DESCRIPTION , formatter_class = argparse . RawTextHelpFormatter ) NEW_LINE parser . add_argument ( ' infile ' , type = str , help = ' input \u2581 file ' ) NEW_LINE parser . add_argument ( ' outfile ' , type = str , nargs = ' ? ' , default = None , help = ' output \u2581 file ' ) NEW_LINE return parser . parse_args ( ) NEW_LINE DEDENT def steps_to_get_Pmax_eq_p ( P , Pmax ) : NEW_LINE INDENT nstep = 0 NEW_LINE for p in P : NEW_LINE INDENT nstep += ( ( p - 1 ) / Pmax ) NEW_LINE DEDENT return nstep NEW_LINE DEDENT def solve ( D , P ) : NEW_LINE INDENT min_costs = max ( P ) NEW_LINE for Pmax in range ( 1 , max ( P ) + 1 ) : NEW_LINE INDENT N = steps_to_get_Pmax_eq_p ( P , Pmax ) NEW_LINE costs = N + Pmax NEW_LINE if costs < min_costs : NEW_LINE INDENT min_costs = costs NEW_LINE DEDENT DEDENT return min_costs NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT if None == args . outfile : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args . outfile , \" w \" ) NEW_LINE DEDENT with open ( args . infile ) as infile : NEW_LINE INDENT T = int ( infile . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT D = int ( infile . readline ( ) ) NEW_LINE P = [ int ( p ) for p in infile . readline ( ) . split ( ) ] NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i , solve ( D , P ) ) ) NEW_LINE DEDENT DEDENT if None != args . outfile : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( getargs ( ) ) NEW_LINE DEDENT", "functions_standalone": [["perr", "def perr ( msg ) : NEW_LINE INDENT sys . stderr . write ( \" % s \" % msg ) NEW_LINE sys . stderr . flush ( ) NEW_LINE DEDENT"], ["pinfo", "def pinfo ( msg ) : NEW_LINE INDENT sys . stdout . write ( \" % s \" % msg ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT"], ["runcmd", "def runcmd ( cmd ) : NEW_LINE INDENT perr ( \" % s \\n \" % cmd ) NEW_LINE os . system ( cmd ) NEW_LINE DEDENT"], ["getargs", "def getargs ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = DESCRIPTION , formatter_class = argparse . RawTextHelpFormatter ) NEW_LINE parser . add_argument ( ' infile ' , type = str , help = ' input \u2581 file ' ) NEW_LINE parser . add_argument ( ' outfile ' , type = str , nargs = ' ? ' , default = None , help = ' output \u2581 file ' ) NEW_LINE return parser . parse_args ( ) NEW_LINE DEDENT"], ["steps_to_get_Pmax_eq_p", "def steps_to_get_Pmax_eq_p ( P , Pmax ) : NEW_LINE INDENT nstep = 0 NEW_LINE for p in P : NEW_LINE INDENT nstep += ( ( p - 1 ) / Pmax ) NEW_LINE DEDENT return nstep NEW_LINE DEDENT"], ["solve", "def solve ( D , P ) : NEW_LINE INDENT min_costs = max ( P ) NEW_LINE for Pmax in range ( 1 , max ( P ) + 1 ) : NEW_LINE INDENT N = steps_to_get_Pmax_eq_p ( P , Pmax ) NEW_LINE costs = N + Pmax NEW_LINE if costs < min_costs : NEW_LINE INDENT min_costs = costs NEW_LINE DEDENT DEDENT return min_costs NEW_LINE DEDENT"], ["main", "def main ( args ) : NEW_LINE INDENT if None == args . outfile : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args . outfile , \" w \" ) NEW_LINE DEDENT with open ( args . infile ) as infile : NEW_LINE INDENT T = int ( infile . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT D = int ( infile . readline ( ) ) NEW_LINE P = [ int ( p ) for p in infile . readline ( ) . split ( ) ] NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i , solve ( D , P ) ) ) NEW_LINE DEDENT DEDENT if None != args . outfile : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "2", "code": "import math NEW_LINE import sys NEW_LINE def findsol ( P , D ) : NEW_LINE INDENT P . sort ( ) NEW_LINE T = P [ len ( P ) - 1 ] NEW_LINE for jj in range ( 1 , T ) : NEW_LINE INDENT N = 0 NEW_LINE for kk in P : NEW_LINE INDENT N += math . ceil ( kk / jj ) - 1 NEW_LINE DEDENT T2 = N + jj NEW_LINE if ( T2 < T ) : NEW_LINE INDENT T = T2 NEW_LINE DEDENT DEDENT return T NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT fidi = open ( ' B - large . in ' , ' r ' ) NEW_LINE fido = open ( ' a . out ' , ' w ' ) NEW_LINE T = fidi . readline ( ) NEW_LINE T = int ( T ) NEW_LINE for ii in range ( 1 , T + 1 ) : NEW_LINE INDENT D = int ( fidi . readline ( ) ) NEW_LINE P = fidi . readline ( ) NEW_LINE P = convertnums ( P ) NEW_LINE a = findsol ( P , D ) NEW_LINE fido . write ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' + str ( a ) + ' \\n ' ) NEW_LINE print ( ' Case \u2581 # ' , str ( ii ) , ' : \u2581 ' , str ( a ) ) NEW_LINE DEDENT fidi . close ( ) NEW_LINE fido . close ( ) NEW_LINE", "functions_standalone": [["findsol", "def findsol ( P , D ) : NEW_LINE INDENT P . sort ( ) NEW_LINE T = P [ len ( P ) - 1 ] NEW_LINE for jj in range ( 1 , T ) : NEW_LINE INDENT N = 0 NEW_LINE for kk in P : NEW_LINE INDENT N += math . ceil ( kk / jj ) - 1 NEW_LINE DEDENT T2 = N + jj NEW_LINE if ( T2 < T ) : NEW_LINE INDENT T = T2 NEW_LINE DEDENT DEDENT return T NEW_LINE DEDENT"], ["convertnums", "def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT"]], "functions_class": []}, {"id": "13", "code": "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT input ( ) NEW_LINE p = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = min ( e + sum ( - ( - i // e ) - 1 for i in p ) for e in range ( 1 , max ( p ) + 1 ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "19", "code": "import sys , math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( \" Case \u2581 # { } : \u2581 \" . format ( i + 1 ) ) NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE l = map ( int , sys . stdin . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE m = max ( l ) NEW_LINE ans = m NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT d = 0 NEW_LINE for p in l : NEW_LINE INDENT if p > i : NEW_LINE INDENT d = d + int ( math . ceil ( p / float ( i ) ) ) - 1 NEW_LINE DEDENT DEDENT ans = min ( ans , d + i ) NEW_LINE DEDENT sys . stdout . write ( \" { } \\n \" . format ( ans ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_15_11", "java": [{"id": "5", "code": "import java . util . * ; import static java . lang . Math . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; long [ ] M = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) M [ i ] = in . nextInt ( ) ; long ans1 = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { ans1 += max ( 0 , M [ i ] - M [ i + 1 ] ) ; } long max = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { max = max ( max , M [ i ] - M [ i + 1 ] ) ; } long ans2 = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) ans2 += min ( max , M [ i ] ) ; System . out . format ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , zz , ans1 , ans2 ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; long [ ] M = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) M [ i ] = in . nextInt ( ) ; long ans1 = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { ans1 += max ( 0 , M [ i ] - M [ i + 1 ] ) ; } long max = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { max = max ( max , M [ i ] - M [ i + 1 ] ) ; } long ans2 = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) ans2 += min ( max , M [ i ] ) ; System . out . format ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , zz , ans1 , ans2 ) ; } }"]], "functions_class": []}, {"id": "10", "code": "import java . io . * ; import java . util . * ; public class taskA { PrintWriter out ; BufferedReader br ; StringTokenizer st ; String nextToken ( ) throws IOException { while ( ( st == null ) || ( ! st . hasMoreTokens ( ) ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; } public void solve ( ) throws IOException { int n = nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextInt ( ) ; } int y = 0 ; int z = 0 ; int minS = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { y += a [ i - 1 ] - a [ i ] ; minS = Math . max ( minS , a [ i - 1 ] - a [ i ] ) ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { z += Math . min ( a [ i ] , minS ) ; } out . println ( y + \" \u2581 \" + z ) ; } public void run ( ) { try { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( System . out ) ; br = new BufferedReader ( new FileReader ( \" taskA . in \" ) ) ; out = new PrintWriter ( \" taskA . out \" ) ; int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solve ( ) ; } out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) { new taskA ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new taskA ( ) . run ( ) ; }"]], "functions_class": [["nextToken", "String nextToken ( ) throws IOException { while ( ( st == null ) || ( ! st . hasMoreTokens ( ) ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "public long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "public double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; }"], ["solve", "public void solve ( ) throws IOException { int n = nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextInt ( ) ; } int y = 0 ; int z = 0 ; int minS = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { y += a [ i - 1 ] - a [ i ] ; minS = Math . max ( minS , a [ i - 1 ] - a [ i ] ) ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { z += Math . min ( a [ i ] , minS ) ; } out . println ( y + \" \u2581 \" + z ) ; }"], ["run", "public void run ( ) { try { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( System . out ) ; br = new BufferedReader ( new FileReader ( \" taskA . in \" ) ) ; out = new PrintWriter ( \" taskA . out \" ) ; int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solve ( ) ; } out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]]}, {"id": "18", "code": "package gcj2015 . r1 ; import java . io . * ; import java . util . Scanner ; public class Mushroom { static PrintWriter out ; public static void main ( String [ ] args ) throws IOException { String name = \" gcj2015 / r1 / A - large \" ; Scanner s = new Scanner ( new File ( name + \" . in \" ) ) ; int count = s . nextInt ( ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( name + \" . out \" ) ) ) ; for ( int cc = 1 ; cc <= count ; cc ++ ) { out . print ( \" Case \u2581 # \" + cc + \" : \u2581 \" ) ; int n = s . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . nextInt ( ) ; } int res1 = solve1 ( n , a ) ; int res2 = solve2 ( n , a ) ; out . print ( res1 ) ; out . print ( ' \u2581 ' ) ; out . print ( res2 ) ; out . println ( ) ; } out . close ( ) ; } static int solve1 ( int n , int [ ] a ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res += Math . max ( a [ i ] - a [ i + 1 ] , 0 ) ; } return res ; } static int solve2 ( int n , int [ ] a ) { int res = 0 ; int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { max = Math . max ( a [ i ] - a [ i + 1 ] , max ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { res += Math . min ( a [ i ] , max ) ; } return res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { String name = \" gcj2015 / r1 / A - large \" ; Scanner s = new Scanner ( new File ( name + \" . in \" ) ) ; int count = s . nextInt ( ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( name + \" . out \" ) ) ) ; for ( int cc = 1 ; cc <= count ; cc ++ ) { out . print ( \" Case \u2581 # \" + cc + \" : \u2581 \" ) ; int n = s . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . nextInt ( ) ; } int res1 = solve1 ( n , a ) ; int res2 = solve2 ( n , a ) ; out . print ( res1 ) ; out . print ( ' \u2581 ' ) ; out . print ( res2 ) ; out . println ( ) ; } out . close ( ) ; }"], ["solve1", "static int solve1 ( int n , int [ ] a ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res += Math . max ( a [ i ] - a [ i + 1 ] , 0 ) ; } return res ; }"], ["solve2", "static int solve2 ( int n , int [ ] a ) { int res = 0 ; int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { max = Math . max ( a [ i ] - a [ i + 1 ] , max ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { res += Math . min ( a [ i ] , max ) ; } return res ; }"]], "functions_class": []}, {"id": "20", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; public class mushroom { public static void main ( String [ ] args ) throws IOException { BufferedReader buf = new BufferedReader ( new FileReader ( \" mushroom . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" mushroom . out \" ) ) ) ; Long n = Long . parseLong ( buf . readLine ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { Long m = Long . parseLong ( buf . readLine ( ) ) ; String [ ] s = buf . readLine ( ) . split ( \" \u2581 \" ) ; long fsum = 0 ; long largest = 0 ; for ( int j = 1 ; j < m ; j ++ ) { if ( Long . parseLong ( s [ j ] ) - Long . parseLong ( s [ j - 1 ] ) < 0 ) { fsum = fsum + Long . parseLong ( s [ j - 1 ] ) - Long . parseLong ( s [ j ] ) ; if ( Long . parseLong ( s [ j - 1 ] ) - Long . parseLong ( s [ j ] ) > largest ) largest = Long . parseLong ( s [ j - 1 ] ) - Long . parseLong ( s [ j ] ) ; } } long nsum = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { nsum = nsum + Math . min ( Long . parseLong ( s [ j ] ) , largest ) ; } out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + fsum + \" \u2581 \" + nsum ) ; } buf . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader buf = new BufferedReader ( new FileReader ( \" mushroom . in \" ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" mushroom . out \" ) ) ) ; Long n = Long . parseLong ( buf . readLine ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { Long m = Long . parseLong ( buf . readLine ( ) ) ; String [ ] s = buf . readLine ( ) . split ( \" \u2581 \" ) ; long fsum = 0 ; long largest = 0 ; for ( int j = 1 ; j < m ; j ++ ) { if ( Long . parseLong ( s [ j ] ) - Long . parseLong ( s [ j - 1 ] ) < 0 ) { fsum = fsum + Long . parseLong ( s [ j - 1 ] ) - Long . parseLong ( s [ j ] ) ; if ( Long . parseLong ( s [ j - 1 ] ) - Long . parseLong ( s [ j ] ) > largest ) largest = Long . parseLong ( s [ j - 1 ] ) - Long . parseLong ( s [ j ] ) ; } } long nsum = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { nsum = nsum + Math . min ( Long . parseLong ( s [ j ] ) , largest ) ; } out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + fsum + \" \u2581 \" + nsum ) ; } buf . close ( ) ; out . close ( ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class Mushroom { final static String PROBLEM_NAME = \" mushroom \" ; final static String WORK_DIR = \" D : \\\\ GCJ \\ \\\" + PROBLEM_NAME + \" \\ \\\" ; void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } int ans1 = 0 ; int speed = 0 ; for ( int i = 0 ; i + 1 < N ; i ++ ) { if ( A [ i + 1 ] < A [ i ] ) { ans1 += A [ i ] - A [ i + 1 ] ; speed = Math . max ( speed , A [ i ] - A [ i + 1 ] ) ; } } int ans2 = 0 ; for ( int i = 0 ; i + 1 < N ; i ++ ) { ans2 += Math . min ( A [ i ] , speed ) ; } pw . println ( ans1 + \" \u2581 \" + ans2 ) ; } public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new Mushroom ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new Mushroom ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["solve", "void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } int ans1 = 0 ; int speed = 0 ; for ( int i = 0 ; i + 1 < N ; i ++ ) { if ( A [ i + 1 ] < A [ i ] ) { ans1 += A [ i ] - A [ i + 1 ] ; speed = Math . max ( speed , A [ i ] - A [ i + 1 ] ) ; } } int ans2 = 0 ; for ( int i = 0 ; i + 1 < N ; i ++ ) { ans2 += Math . min ( A [ i ] , speed ) ; } pw . println ( ans1 + \" \u2581 \" + ans2 ) ; }"]]}], "python": [{"id": "8", "code": "tc = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( tc ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE v = list ( int ( x ) for x in input ( ) . strip ( ) . split ( ) ) NEW_LINE a = sum ( max ( 0 , v [ i ] - v [ i + 1 ] ) for i in range ( n - 1 ) ) NEW_LINE b = max ( max ( 0 , v [ i ] - v [ i + 1 ] ) for i in range ( n - 1 ) ) NEW_LINE c = sum ( min ( b , v [ i ] ) for i in range ( n - 1 ) ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \" % ( t + 1 , a , c ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "20", "code": "import sys NEW_LINE sys . stdin = open ( ' a . in ' , ' r ' ) NEW_LINE sys . stdout = open ( ' a . out ' , ' w ' ) NEW_LINE def getline ( ) : NEW_LINE INDENT return [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT [ n ] = getline ( ) NEW_LINE a = getline ( ) NEW_LINE ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE k = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans1 += a [ i ] - a [ i + 1 ] NEW_LINE k = max ( k , a [ i ] - a [ i + 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT ans2 += min ( a [ i ] , k ) NEW_LINE DEDENT return \" % d \u2581 % d \" % ( ans1 , ans2 ) NEW_LINE DEDENT for T in range ( int ( input ( ) ) ) : NEW_LINE INDENT sys . stderr . write ( str ( T ) ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % s ' % ( T + 1 , solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["getline", "def getline ( ) : NEW_LINE INDENT return [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT [ n ] = getline ( ) NEW_LINE a = getline ( ) NEW_LINE ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE k = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans1 += a [ i ] - a [ i + 1 ] NEW_LINE k = max ( k , a [ i ] - a [ i + 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT ans2 += min ( a [ i ] , k ) NEW_LINE DEDENT return \" % d \u2581 % d \" % ( ans1 , ans2 ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y , t , r = 0 , 0 , 0 , 0 NEW_LINE for d in m : NEW_LINE INDENT if d < t : NEW_LINE INDENT x += t - d NEW_LINE r = max ( r , t - d ) NEW_LINE DEDENT t = d NEW_LINE DEDENT for d in m [ : - 1 ] : NEW_LINE INDENT y += min ( r , d ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \" % ( tc + 1 , x , y ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "def gao1 ( l ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] < l [ i - 1 ] : NEW_LINE INDENT ans += l [ i - 1 ] - l [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def gao2 ( l ) : NEW_LINE INDENT rate = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT rate = max ( rate , l [ i - 1 ] - l [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT ans += min ( l [ i - 1 ] , rate ) NEW_LINE DEDENT return ans NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for cas in range ( t ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : ' % ( cas + 1 ) , end = ' \u2581 ' ) NEW_LINE n = input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( gao1 ( l ) , gao2 ( l ) ) NEW_LINE DEDENT", "functions_standalone": [["gao1", "def gao1 ( l ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] < l [ i - 1 ] : NEW_LINE INDENT ans += l [ i - 1 ] - l [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"], ["gao2", "def gao2 ( l ) : NEW_LINE INDENT rate = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT rate = max ( rate , l [ i - 1 ] - l [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT ans += min ( l [ i - 1 ] , rate ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "tests = int ( input ( ) ) NEW_LINE for t in range ( tests ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE first = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i + 1 ] < a [ i ] : NEW_LINE INDENT first += a [ i ] - a [ i + 1 ] NEW_LINE DEDENT DEDENT maxdiff = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT maxdiff = max ( maxdiff , a [ i ] - a [ i + 1 ] ) NEW_LINE DEDENT current , second = a [ 0 ] , 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT now = min ( current , maxdiff ) NEW_LINE second += now NEW_LINE current = a [ i ] NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } \u2581 { } ' . format ( t + 1 , first , second ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_15_21", "java": [{"id": "5", "code": "import java . util . Scanner ; public class A { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { long N = sc . nextLong ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , i , solve ( N ) ) ; } } static long solve ( long v ) { if ( v <= 10 ) return v ; int len = ( \" \" + v ) . length ( ) ; long mod = 1 ; for ( int i = 0 ; i < len / 2 ; ++ i ) { mod *= 10 ; } if ( v % mod == 0 ) return solve ( v - 1 ) + 1 ; long add = v % mod - 1 ; v -= add ; long rev = 0 ; long tmp = v ; while ( tmp > 0 ) { rev *= 10 ; rev += tmp % 10 ; tmp /= 10 ; } if ( rev != v ) return solve ( rev ) + add + 1 ; return solve ( v - 1 ) + add + 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { long N = sc . nextLong ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , i , solve ( N ) ) ; } }"], ["solve", "static long solve ( long v ) { if ( v <= 10 ) return v ; int len = ( \" \" + v ) . length ( ) ; long mod = 1 ; for ( int i = 0 ; i < len / 2 ; ++ i ) { mod *= 10 ; } if ( v % mod == 0 ) return solve ( v - 1 ) + 1 ; long add = v % mod - 1 ; v -= add ; long rev = 0 ; long tmp = v ; while ( tmp > 0 ) { rev *= 10 ; rev += tmp % 10 ; tmp /= 10 ; } if ( rev != v ) return solve ( rev ) + add + 1 ; return solve ( v - 1 ) + add + 1 ; }"]], "functions_class": []}, {"id": "2", "code": "import java . util . * ; import java . io . * ; public class A { static long [ ] POW10 = new long [ 20 ] ; static { POW10 [ 0 ] = 1 ; for ( int i = 1 ; i < POW10 . length ; i ++ ) POW10 [ i ] = POW10 [ i - 1 ] * 10 ; } public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { String s = input . next ( ) ; long l = Long . parseLong ( s ) ; boolean zero = l % POW10 [ s . length ( ) / 2 ] == 0 ; if ( zero ) { l -- ; s = l + \" \" ; } long ans = 0 ; for ( int d = 1 ; d < s . length ( ) ; d ++ ) ans += POW10 [ d / 2 ] + POW10 [ ( d + 1 ) / 2 ] - 1 ; String sb = \"0\" + s . substring ( 0 , s . length ( ) / 2 ) ; if ( s . length ( ) > 1 && Long . parseLong ( sb ) != POW10 [ s . length ( ) / 2 - 1 ] ) { ans += Long . parseLong ( \"0\" + new StringBuilder ( s . substring ( 0 , s . length ( ) / 2 ) ) . reverse ( ) . toString ( ) ) ; } ans += Long . parseLong ( \"0\" + s . substring ( s . length ( ) / 2 ) ) ; if ( zero ) ans ++ ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { String s = input . next ( ) ; long l = Long . parseLong ( s ) ; boolean zero = l % POW10 [ s . length ( ) / 2 ] == 0 ; if ( zero ) { l -- ; s = l + \" \" ; } long ans = 0 ; for ( int d = 1 ; d < s . length ( ) ; d ++ ) ans += POW10 [ d / 2 ] + POW10 [ ( d + 1 ) / 2 ] - 1 ; String sb = \"0\" + s . substring ( 0 , s . length ( ) / 2 ) ; if ( s . length ( ) > 1 && Long . parseLong ( sb ) != POW10 [ s . length ( ) / 2 - 1 ] ) { ans += Long . parseLong ( \"0\" + new StringBuilder ( s . substring ( 0 , s . length ( ) / 2 ) ) . reverse ( ) . toString ( ) ) ; } ans += Long . parseLong ( \"0\" + s . substring ( s . length ( ) / 2 ) ) ; if ( zero ) ans ++ ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( ans ) ; } }"]], "functions_class": []}, {"id": "6", "code": "import java . util . * ; public class Slam { static int [ ] basic = new int [ 15 ] ; { basic [ 1 ] = 10 ; for ( int i = 2 ; i < 15 ; i ++ ) { if ( i % 2 == 0 ) { basic [ i ] = basic [ i - 1 ] + 2 * ( int ) ( Math . pow ( 10 , i / 2 ) ) - 1 ; } else { basic [ i ] = basic [ i - 1 ] + ( int ) ( ( Math . pow ( 10 , i / 2 ) ) + ( Math . pow ( 10 , ( i + 1 ) / 2 ) ) - 1 ) ; } } } static boolean allzero ( String t ) { for ( char ch : t . toCharArray ( ) ) if ( ch != '0' ) return false ; return true ; } static long f ( long v ) { if ( v < 10 ) return v ; int L = ( \" \" + v ) . length ( ) ; String right = ( \" \" + v ) . substring ( L / 2 , L ) ; String left = ( \" \" + v ) . substring ( 0 , L / 2 ) ; if ( allzero ( right ) ) return 1 + f ( v - 1 ) ; long result = basic [ L - 1 ] + Integer . parseInt ( right ) + Integer . parseInt ( new StringBuilder ( left ) . reverse ( ) . toString ( ) ) ; result = Math . min ( result , basic [ L - 1 ] + ( v - ( long ) Math . pow ( 10 , L - 1 ) ) ) ; return result ; } public static void main ( String [ ] args ) { new Slam ( ) ; Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; for ( int kk = 1 ; kk <= k ; kk ++ ) System . out . println ( \" Case \u2581 # \" + kk + \" : \u2581 \" + f ( sc . nextLong ( ) ) ) ; } }", "functions_standalone": [["allzero", "static boolean allzero ( String t ) { for ( char ch : t . toCharArray ( ) ) if ( ch != '0' ) return false ; return true ; }"], ["f", "static long f ( long v ) { if ( v < 10 ) return v ; int L = ( \" \" + v ) . length ( ) ; String right = ( \" \" + v ) . substring ( L / 2 , L ) ; String left = ( \" \" + v ) . substring ( 0 , L / 2 ) ; if ( allzero ( right ) ) return 1 + f ( v - 1 ) ; long result = basic [ L - 1 ] + Integer . parseInt ( right ) + Integer . parseInt ( new StringBuilder ( left ) . reverse ( ) . toString ( ) ) ; result = Math . min ( result , basic [ L - 1 ] + ( v - ( long ) Math . pow ( 10 , L - 1 ) ) ) ; return result ; }"], ["main", "public static void main ( String [ ] args ) { new Slam ( ) ; Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; for ( int kk = 1 ; kk <= k ; kk ++ ) System . out . println ( \" Case \u2581 # \" + kk + \" : \u2581 \" + f ( sc . nextLong ( ) ) ) ; }"]], "functions_class": [["if", "i ++ ) { if ( i % 2 == 0 ) { basic [ i ] = basic [ i - 1 ] + 2 * ( int ) ( Math . pow ( 10 , i / 2 ) ) - 1 ; } else { basic [ i ] = basic [ i - 1 ] + ( int ) ( ( Math . pow ( 10 , i / 2 ) ) + ( Math . pow ( 10 , ( i + 1 ) / 2 ) ) - 1 ) ; } }"]]}, {"id": "18", "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; } void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { String s = cin . next ( ) ; System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( s ) ) ; } } long solve ( String s ) { if ( Long . parseLong ( s ) == 0 ) { return 0 ; } int N = s . length ( ) ; String head = s . substring ( 0 , N / 2 ) ; String tail = s . substring ( N / 2 ) ; long tmp = Long . parseLong ( tail ) ; if ( tmp == 0 ) { return 1 + solve ( \" \" + ( Long . parseLong ( s ) - 1 ) ) ; } String next = \" \" + ( Long . parseLong ( s ) - ( tmp - 1 ) ) ; String rev = rev ( next ) ; if ( Long . parseLong ( next ) == Long . parseLong ( rev ) ) { return tmp + solve ( \" \" + ( Long . parseLong ( s ) - tmp ) ) ; } return tmp + solve ( rev ) ; } String rev ( String s ) { return ( new StringBuilder ( s ) ) . reverse ( ) . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { String s = cin . next ( ) ; System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( s ) ) ; } }"], ["solve", "long solve ( String s ) { if ( Long . parseLong ( s ) == 0 ) { return 0 ; } int N = s . length ( ) ; String head = s . substring ( 0 , N / 2 ) ; String tail = s . substring ( N / 2 ) ; long tmp = Long . parseLong ( tail ) ; if ( tmp == 0 ) { return 1 + solve ( \" \" + ( Long . parseLong ( s ) - 1 ) ) ; } String next = \" \" + ( Long . parseLong ( s ) - ( tmp - 1 ) ) ; String rev = rev ( next ) ; if ( Long . parseLong ( next ) == Long . parseLong ( rev ) ) { return tmp + solve ( \" \" + ( Long . parseLong ( s ) - tmp ) ) ; } return tmp + solve ( rev ) ; }"], ["rev", "String rev ( String s ) { return ( new StringBuilder ( s ) ) . reverse ( ) . toString ( ) ; }"]]}, {"id": "7", "code": "import java . util . * ; public class A { String solve ( Scanner sc ) { int N = sc . nextInt ( ) ; int [ ] dp = new int [ N + 1 ] ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = Integer . MAX_VALUE ; } for ( int i = 1 ; i < N ; i ++ ) { dp [ i + 1 ] = Math . min ( dp [ i + 1 ] , dp [ i ] + 1 ) ; int r = reverse ( i ) ; if ( r <= N ) { dp [ r ] = Math . min ( dp [ r ] , dp [ i ] + 1 ) ; } } return \" \" + dp [ N ] ; } int reverse ( int N ) { int r = 0 ; while ( N > 0 ) { r *= 10 ; r += N % 10 ; N /= 10 ; } return r ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= T ; cs ++ ) { String res = new A ( ) . solve ( sc ) ; System . out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + res ) ; } sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= T ; cs ++ ) { String res = new A ( ) . solve ( sc ) ; System . out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + res ) ; } sc . close ( ) ; }"]], "functions_class": [["solve", "String solve ( Scanner sc ) { int N = sc . nextInt ( ) ; int [ ] dp = new int [ N + 1 ] ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = Integer . MAX_VALUE ; } for ( int i = 1 ; i < N ; i ++ ) { dp [ i + 1 ] = Math . min ( dp [ i + 1 ] , dp [ i ] + 1 ) ; int r = reverse ( i ) ; if ( r <= N ) { dp [ r ] = Math . min ( dp [ r ] , dp [ i ] + 1 ) ; } } return \" \" + dp [ N ] ; }"], ["reverse", "int reverse ( int N ) { int r = 0 ; while ( N > 0 ) { r *= 10 ; r += N % 10 ; N /= 10 ; } return r ; }"]]}], "python": [{"id": "8", "code": "def f ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if str ( n ) [ - 1 ] == \"0\" : NEW_LINE INDENT return 1 + f ( n - 1 ) NEW_LINE DEDENT s = str ( n ) NEW_LINE k = int ( \"1\" + ( len ( s ) - 1 ) * \"0\" ) NEW_LINE a = - k NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a += int ( s [ ~ i ] ) * 10 ** i NEW_LINE b += int ( s [ ~ i ] ) * 10 ** min ( i , len ( s ) - i - 1 ) NEW_LINE DEDENT return min ( a , b ) + f ( k ) NEW_LINE DEDENT with open ( \" A - large . in \" ) as infile : NEW_LINE INDENT with open ( \" A . out \" , \" w \" ) as outfile : NEW_LINE INDENT ncases = int ( next ( infile ) ) NEW_LINE for case in range ( 1 , ncases + 1 ) : NEW_LINE INDENT n = int ( next ( infile ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , f ( n ) ) , file = outfile ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["f", "def f ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if str ( n ) [ - 1 ] == \"0\" : NEW_LINE INDENT return 1 + f ( n - 1 ) NEW_LINE DEDENT s = str ( n ) NEW_LINE k = int ( \"1\" + ( len ( s ) - 1 ) * \"0\" ) NEW_LINE a = - k NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a += int ( s [ ~ i ] ) * 10 ** i NEW_LINE b += int ( s [ ~ i ] ) * 10 ** min ( i , len ( s ) - i - 1 ) NEW_LINE DEDENT return min ( a , b ) + f ( k ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "7", "code": "from queue import Queue NEW_LINE def minsteps ( start , goal ) : NEW_LINE INDENT if start == goal : return 0 NEW_LINE best = int ( goal ) - int ( start ) NEW_LINE bmedzi = ' ' NEW_LINE C = len ( start ) NEW_LINE for cif in range ( C ) : NEW_LINE INDENT rgoal = goal [ : : - 1 ] NEW_LINE medzi = start [ : C - cif ] + rgoal [ C - cif : ] NEW_LINE if medzi [ : : - 1 ] > goal : continue NEW_LINE toto = int ( medzi ) - int ( start ) + 1 NEW_LINE toto += int ( goal ) - int ( medzi [ : : - 1 ] ) NEW_LINE if toto < best : NEW_LINE INDENT best = toto NEW_LINE bmedzi = medzi NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT def solve ( goal ) : NEW_LINE INDENT start = '1' NEW_LINE answer = 1 NEW_LINE while len ( start ) < len ( goal ) : NEW_LINE INDENT answer += minsteps ( start , '9' * len ( start ) ) + 1 NEW_LINE start += '0' NEW_LINE DEDENT answer += minsteps ( start , goal ) NEW_LINE return answer NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT goal = input ( ) . strip ( ) NEW_LINE answer = solve ( goal ) NEW_LINE if goal != '1' : NEW_LINE INDENT goal = str ( int ( goal ) - 1 ) NEW_LINE answer = min ( answer , 1 + solve ( goal ) ) NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( t , answer ) ) NEW_LINE DEDENT", "functions_standalone": [["minsteps", "def minsteps ( start , goal ) : NEW_LINE INDENT if start == goal : return 0 NEW_LINE best = int ( goal ) - int ( start ) NEW_LINE bmedzi = ' ' NEW_LINE C = len ( start ) NEW_LINE for cif in range ( C ) : NEW_LINE INDENT rgoal = goal [ : : - 1 ] NEW_LINE medzi = start [ : C - cif ] + rgoal [ C - cif : ] NEW_LINE if medzi [ : : - 1 ] > goal : continue NEW_LINE toto = int ( medzi ) - int ( start ) + 1 NEW_LINE toto += int ( goal ) - int ( medzi [ : : - 1 ] ) NEW_LINE if toto < best : NEW_LINE INDENT best = toto NEW_LINE bmedzi = medzi NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT"], ["solve", "def solve ( goal ) : NEW_LINE INDENT start = '1' NEW_LINE answer = 1 NEW_LINE while len ( start ) < len ( goal ) : NEW_LINE INDENT answer += minsteps ( start , '9' * len ( start ) ) + 1 NEW_LINE start += '0' NEW_LINE DEDENT answer += minsteps ( start , goal ) NEW_LINE return answer NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case \u2581 # { : d } : \u2581 { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 arguments , \u2581 not \u2581 { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["readline", "def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT"], ["readint", "def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readfloat", "def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT"], ["readints", "def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["readfloats", "def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["writeline", "def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT"], ["writecase", "def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case \u2581 # { : d } : \u2581 { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT"], ["run", "def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 arguments , \u2581 not \u2581 { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "5", "code": "from sys import stdin , stdout , stderr NEW_LINE import collections NEW_LINE best = { } NEW_LINE def precompute ( ) : NEW_LINE INDENT best [ 1 ] = 1 NEW_LINE queue = collections . deque ( [ 1 ] ) NEW_LINE limit = 1000000 NEW_LINE while queue : NEW_LINE INDENT i = queue . popleft ( ) NEW_LINE d = best [ i ] NEW_LINE if d > limit : NEW_LINE INDENT break NEW_LINE DEDENT if i + 1 not in best and i + 1 <= limit * 10 : NEW_LINE INDENT best [ i + 1 ] = d + 1 NEW_LINE queue . append ( i + 1 ) NEW_LINE DEDENT rev = int ( \" \" . join ( reversed ( str ( i ) ) ) ) NEW_LINE if rev not in best and rev <= limit * 10 : NEW_LINE INDENT best [ rev ] = d + 1 NEW_LINE queue . append ( rev ) NEW_LINE DEDENT DEDENT DEDENT def solve ( N ) : NEW_LINE INDENT return best [ N ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE answer = solve ( N ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , answer ) ) NEW_LINE DEDENT DEDENT precompute ( ) NEW_LINE main ( ) NEW_LINE", "functions_standalone": [["precompute", "def precompute ( ) : NEW_LINE INDENT best [ 1 ] = 1 NEW_LINE queue = collections . deque ( [ 1 ] ) NEW_LINE limit = 1000000 NEW_LINE while queue : NEW_LINE INDENT i = queue . popleft ( ) NEW_LINE d = best [ i ] NEW_LINE if d > limit : NEW_LINE INDENT break NEW_LINE DEDENT if i + 1 not in best and i + 1 <= limit * 10 : NEW_LINE INDENT best [ i + 1 ] = d + 1 NEW_LINE queue . append ( i + 1 ) NEW_LINE DEDENT rev = int ( \" \" . join ( reversed ( str ( i ) ) ) ) NEW_LINE if rev not in best and rev <= limit * 10 : NEW_LINE INDENT best [ rev ] = d + 1 NEW_LINE queue . append ( rev ) NEW_LINE DEDENT DEDENT DEDENT"], ["solve", "def solve ( N ) : NEW_LINE INDENT return best [ N ] NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE answer = solve ( N ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , answer ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "2", "code": "import sys NEW_LINE from fractions import gcd NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT def reverse ( nr ) : NEW_LINE INDENT return int ( str ( nr ) [ : : - 1 ] ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT n = int ( fin . readline ( ) ) NEW_LINE count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT digits = str ( n ) NEW_LINE halfcount = ( len ( digits ) + 1 ) // 2 NEW_LINE rev = reverse ( n ) NEW_LINE mod = n % ( 10 ** halfcount ) NEW_LINE if mod == 1 and n != rev : NEW_LINE INDENT n = rev NEW_LINE count += 1 NEW_LINE DEDENT elif mod <= 1 : NEW_LINE INDENT n -= 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n -= ( mod - 1 ) NEW_LINE count += ( mod - 1 ) NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , count ) ) NEW_LINE DEDENT", "functions_standalone": [["debug", "def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT"], ["reverse", "def reverse ( nr ) : NEW_LINE INDENT return int ( str ( nr ) [ : : - 1 ] ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_31", "java": [{"id": "19", "code": "import java . io . * ; import java . util . * ; public class A { MyScanner in ; PrintWriter out ; final static String FILENAME = \" a \" ; public static void main ( String [ ] args ) throws Exception { new A ( ) . run ( ) ; } public void run ( ) throws Exception { in = new MyScanner ( FILENAME + \" . in \" ) ; out = new PrintWriter ( FILENAME + \" . out \" ) ; int tests = in . nextInt ( ) ; for ( int test = 0 ; test < tests ; test ++ ) { out . println ( \" Case \u2581 # \" + ( test + 1 ) + \" : \u2581 \" + solve ( ) ) ; } out . close ( ) ; } public long solve ( ) throws Exception { int r = in . nextInt ( ) ; int c = in . nextInt ( ) ; int w = in . nextInt ( ) ; return r * ( c / w + w + ( c % w == 0 ? - 1 : 0 ) ) ; } class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( String file ) throws Exception { br = new BufferedReader ( new FileReader ( file ) ) ; } String next ( ) throws Exception { while ( ( st == null ) || ( ! st . hasMoreTokens ( ) ) ) { String t = br . readLine ( ) ; if ( t == null ) { return null ; } st = new StringTokenizer ( t ) ; } return st . nextToken ( ) ; } int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; } double nextDouble ( ) throws Exception { return Double . parseDouble ( next ( ) ) ; } boolean nextBoolean ( ) throws Exception { return Boolean . parseBoolean ( next ( ) ) ; } long nextLong ( ) throws Exception { return Long . parseLong ( next ( ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { new A ( ) . run ( ) ; }"]], "functions_class": [["run", "public void run ( ) throws Exception { in = new MyScanner ( FILENAME + \" . in \" ) ; out = new PrintWriter ( FILENAME + \" . out \" ) ; int tests = in . nextInt ( ) ; for ( int test = 0 ; test < tests ; test ++ ) { out . println ( \" Case \u2581 # \" + ( test + 1 ) + \" : \u2581 \" + solve ( ) ) ; } out . close ( ) ; }"], ["solve", "public long solve ( ) throws Exception { int r = in . nextInt ( ) ; int c = in . nextInt ( ) ; int w = in . nextInt ( ) ; return r * ( c / w + w + ( c % w == 0 ? - 1 : 0 ) ) ; }"], ["MyScanner", "public MyScanner ( String file ) throws Exception { br = new BufferedReader ( new FileReader ( file ) ) ; }"], ["next", "String next ( ) throws Exception { while ( ( st == null ) || ( ! st . hasMoreTokens ( ) ) ) { String t = br . readLine ( ) ; if ( t == null ) { return null ; } st = new StringTokenizer ( t ) ; } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws Exception { return Double . parseDouble ( next ( ) ) ; }"], ["nextBoolean", "boolean nextBoolean ( ) throws Exception { return Boolean . parseBoolean ( next ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws Exception { return Long . parseLong ( next ( ) ) ; }"]]}, {"id": "15", "code": "package com . archieve ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; import static java . util . Arrays . deepToString ; public class codejam2015_1C_A { static PrintWriter out = null ; static FileInputStream in = null ; Scanner sc ; int N ; Integer R , C , W ; void read ( ) { R = sc . nextInt ( ) ; C = sc . nextInt ( ) ; W = sc . nextInt ( ) ; } void solve ( ) { long solution = 0 ; solution += ( R - 1 ) * ( C / W ) ; solution += ( C - 1 ) / W ; solution += W ; out . println ( solution ) ; System . out . println ( solution ) ; } void output ( long a ) { out . println ( a ) ; System . out . println ( a ) ; } void run ( ) { try { in = new FileInputStream ( \" src / com / resources / smallInput . txt \" ) ; out = new PrintWriter ( \" src / com / resources / output . txt \" ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } sc = new Scanner ( in ) ; int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } out . close ( ) ; } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( codejam2015_1C_A . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new codejam2015_1C_A ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( codejam2015_1C_A . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new codejam2015_1C_A ( ) . run ( ) ; }"]], "functions_class": [["read", "void read ( ) { R = sc . nextInt ( ) ; C = sc . nextInt ( ) ; W = sc . nextInt ( ) ; }"], ["solve", "void solve ( ) { long solution = 0 ; solution += ( R - 1 ) * ( C / W ) ; solution += ( C - 1 ) / W ; solution += W ; out . println ( solution ) ; System . out . println ( solution ) ; }"], ["output", "void output ( long a ) { out . println ( a ) ; System . out . println ( a ) ; }"], ["run", "void run ( ) { try { in = new FileInputStream ( \" src / com / resources / smallInput . txt \" ) ; out = new PrintWriter ( \" src / com / resources / output . txt \" ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } sc = new Scanner ( in ) ; int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } out . close ( ) ; }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "18", "code": "import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class ProblemA { public static void main ( String [ ] args ) throws IOException { ProblemA solver = new ProblemA ( ) ; solver . init ( ) ; solver . solve ( ) ; } void init ( ) { } private void solve ( ) throws IOException { Reader in = new Reader ( System . in ) ; PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int R = in . nextInt ( ) ; int C = in . nextInt ( ) ; int W = in . nextInt ( ) ; int r = ( C / W ) * R ; r += ( W - 1 ) ; if ( ( C % W ) > 0 ) r ++ ; out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + r ) ; } out . flush ( ) ; out . close ( ) ; } private static class Reader { BufferedReader reader ; StringTokenizer tokenizer ; Reader ( InputStream input ) { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; tokenizer = new StringTokenizer ( \" \" ) ; } public void skipLine ( ) throws IOException { reader . readLine ( ) ; } public String next ( ) throws IOException { while ( ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { ProblemA solver = new ProblemA ( ) ; solver . init ( ) ; solver . solve ( ) ; }"]], "functions_class": [["init", "void init ( ) { }"], ["solve", "private void solve ( ) throws IOException { Reader in = new Reader ( System . in ) ; PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int R = in . nextInt ( ) ; int C = in . nextInt ( ) ; int W = in . nextInt ( ) ; int r = ( C / W ) * R ; r += ( W - 1 ) ; if ( ( C % W ) > 0 ) r ++ ; out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + r ) ; } out . flush ( ) ; out . close ( ) ; }"], ["Reader", "Reader ( InputStream input ) { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; tokenizer = new StringTokenizer ( \" \" ) ; }"], ["skipLine", "public void skipLine ( ) throws IOException { reader . readLine ( ) ; }"], ["next", "public String next ( ) throws IOException { while ( ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }"], ["nextDouble", "public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; }"], ["nextLong", "public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; }"]]}, {"id": "17", "code": "import java . util . Scanner ; public final class A { public static void main ( final String ... args ) { final Scanner sc = new Scanner ( System . in ) ; final int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; ++ i ) { System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , i + 1 , testcase ( sc ) ) ) ; } } private static int testcase ( final Scanner sc ) { final int r = sc . nextInt ( ) ; final int c = sc . nextInt ( ) ; final int w = sc . nextInt ( ) ; return ( c / w ) * r + ( w - 1 ) + ( c % w == 0 ? 0 : 1 ) ; } }", "functions_standalone": [["main", "public static void main ( final String ... args ) { final Scanner sc = new Scanner ( System . in ) ; final int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; ++ i ) { System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , i + 1 , testcase ( sc ) ) ) ; } }"], ["testcase", "private static int testcase ( final Scanner sc ) { final int r = sc . nextInt ( ) ; final int c = sc . nextInt ( ) ; final int w = sc . nextInt ( ) ; return ( c / w ) * r + ( w - 1 ) + ( c % w == 0 ? 0 : 1 ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . io . * ; import java . util . StringTokenizer ; public class Main { public void solve ( int testNumber , FastScanner in , PrintWriter out ) { out . printf ( \" Case \u2581 # % d : \u2581 \" , testNumber ) ; int r = in . nextInt ( ) ; int c = in . nextInt ( ) ; int w = in . nextInt ( ) ; int addRow = c / w * ( r - 1 ) ; int inRow = c / w + w ; if ( c % w == 0 ) inRow -- ; out . println ( addRow + inRow ) ; } public static void main ( String [ ] args ) throws IOException { FastScanner in = new FastScanner ( new FileInputStream ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int t = in . nextInt ( ) ; for ( int test = 1 ; test <= t ; test ++ ) new Main ( ) . solve ( test , in , out ) ; in . close ( ) ; out . close ( ) ; } } class FastScanner { private StringTokenizer tokenizer ; private BufferedReader reader ; public FastScanner ( InputStream inputStream ) { reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { String line ; try { line = reader . readLine ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } if ( line == null ) return null ; tokenizer = new StringTokenizer ( line ) ; } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public String nextLine ( ) { String line ; try { line = reader . readLine ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } tokenizer = null ; return line ; } public void close ( ) { try { reader . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { FastScanner in = new FastScanner ( new FileInputStream ( \" input . txt \" ) ) ; PrintWriter out = new PrintWriter ( \" output . txt \" ) ; int t = in . nextInt ( ) ; for ( int test = 1 ; test <= t ; test ++ ) new Main ( ) . solve ( test , in , out ) ; in . close ( ) ; out . close ( ) ; }"]], "functions_class": [["solve", "public void solve ( int testNumber , FastScanner in , PrintWriter out ) { out . printf ( \" Case \u2581 # % d : \u2581 \" , testNumber ) ; int r = in . nextInt ( ) ; int c = in . nextInt ( ) ; int w = in . nextInt ( ) ; int addRow = c / w * ( r - 1 ) ; int inRow = c / w + w ; if ( c % w == 0 ) inRow -- ; out . println ( addRow + inRow ) ; }"], ["FastScanner", "public FastScanner ( InputStream inputStream ) { reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; }"], ["next", "public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { String line ; try { line = reader . readLine ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } if ( line == null ) return null ; tokenizer = new StringTokenizer ( line ) ; } return tokenizer . nextToken ( ) ; }"], ["nextInt", "public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }"], ["nextLong", "public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; }"], ["nextDouble", "public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; }"], ["nextLine", "public String nextLine ( ) { String line ; try { line = reader . readLine ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } tokenizer = null ; return line ; }"], ["close", "public void close ( ) { try { reader . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }"]]}], "python": [{"id": "14", "code": "FILE_NAME_BASE = ' A - large ' NEW_LINE NUM_PROCESSES = 0 NEW_LINE MEM_LIMIT_GB = 1.5 NEW_LINE RECURSION_LIMIT = 1000 NEW_LINE def parse ( inp ) : NEW_LINE INDENT rows , cols , size = ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE return rows , cols , size NEW_LINE DEDENT def solve ( rows , cols , size ) : NEW_LINE INDENT toHit = cols / size NEW_LINE hitFlex = cols % size NEW_LINE toSink = size - 1 if hitFlex == 0 else size NEW_LINE return rows * toHit + toSink NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT import sys NEW_LINE sys . setrecursionlimit ( RECURSION_LIMIT ) NEW_LINE import resource NEW_LINE soft , hard = resource . getrlimit ( resource . RLIMIT_AS ) NEW_LINE resource . setrlimit ( resource . RLIMIT_AS , ( MEM_LIMIT_GB * 1024 ** 3 , hard ) ) NEW_LINE with open ( FILE_NAME_BASE + ' . in ' , ' r ' ) as inp : NEW_LINE INDENT numCases = int ( inp . readline ( ) ) NEW_LINE inputs = [ parse ( inp ) for _ in xrange ( numCases ) ] NEW_LINE DEDENT if NUM_PROCESSES == 0 : NEW_LINE INDENT runners = [ lambda inp = inp : apply ( solve , inp ) for inp in inputs ] NEW_LINE DEDENT else : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE from signal import SIGINT , SIG_IGN , signal NEW_LINE pool = Pool ( NUM_PROCESSES , signal , ( SIGINT , SIG_IGN ) ) NEW_LINE runners = [ pool . apply_async ( solve , inp ) . get for inp in inputs ] NEW_LINE pool . close ( ) NEW_LINE DEDENT caseFmt = ' % ' + str ( len ( str ( numCases ) ) ) + ' d ' NEW_LINE progressFmt = ' [ % s / % s ] \u2581 % % s \\n ' % ( caseFmt , caseFmt ) NEW_LINE with open ( FILE_NAME_BASE + ' . out ' , ' w ' ) as out : NEW_LINE INDENT for case , runner in enumerate ( runners , 1 ) : NEW_LINE INDENT result = runner ( ) NEW_LINE out . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( case , result ) ) NEW_LINE out . flush ( ) NEW_LINE sys . stderr . write ( progressFmt % ( case , numCases , result ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["parse", "def parse ( inp ) : NEW_LINE INDENT rows , cols , size = ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE return rows , cols , size NEW_LINE DEDENT"], ["solve", "def solve ( rows , cols , size ) : NEW_LINE INDENT toHit = cols / size NEW_LINE hitFlex = cols % size NEW_LINE toSink = size - 1 if hitFlex == 0 else size NEW_LINE return rows * toHit + toSink NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "def calculate ( ) : NEW_LINE INDENT r , c , w = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if c % w == 0 : NEW_LINE INDENT return r * int ( c / w ) + w - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return r * int ( c / w ) + w NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["calculate", "def calculate ( ) : NEW_LINE INDENT r , c , w = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if c % w == 0 : NEW_LINE INDENT return r * int ( c / w ) + w - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return r * int ( c / w ) + w NEW_LINE DEDENT DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "7", "code": "import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE T = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE R = int ( line [ 0 ] ) NEW_LINE C = int ( line [ 1 ] ) NEW_LINE W = int ( line [ 2 ] ) NEW_LINE shotsFailRows = 0 NEW_LINE shotsWinRow = 0 NEW_LINE remainingFields = C NEW_LINE while remainingFields >= 2 * W : NEW_LINE INDENT remainingFields -= W NEW_LINE shotsFailRows += 1 NEW_LINE shotsWinRow += 1 NEW_LINE DEDENT shotsWinRow += min ( remainingFields , W + 1 ) NEW_LINE shotsFailRows += 1 NEW_LINE answer = ( R - 1 ) * shotsFailRows + shotsWinRow NEW_LINE output = str ( answer ) NEW_LINE print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "import math NEW_LINE import itertools NEW_LINE import numpy as NP NEW_LINE def read_case ( f ) : NEW_LINE INDENT return read_ints ( f ) NEW_LINE DEDENT def solve_small ( case ) : NEW_LINE INDENT R , C , W = case NEW_LINE return ( C // W ) * R + W - ( 1 if C % W == 0 else 0 ) NEW_LINE DEDENT def solve_large ( case ) : NEW_LINE INDENT return solve_small ( case ) NEW_LINE DEDENT def write_case ( f , i , res ) : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 ' % i ) NEW_LINE f . write ( ' % s ' % res ) NEW_LINE f . write ( ' \\n ' ) NEW_LINE DEDENT def read_word ( f ) : NEW_LINE INDENT return next ( f ) . strip ( ) NEW_LINE DEDENT def read_int ( f , b = 10 ) : NEW_LINE INDENT return int ( read_word ( f ) , b ) NEW_LINE DEDENT def read_letters ( f ) : NEW_LINE INDENT return list ( read_word ( f ) ) NEW_LINE DEDENT def read_digits ( f , b = 10 ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_letters ( f ) ] NEW_LINE DEDENT def read_words ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return read_word ( f ) . split ( d ) NEW_LINE DEDENT def read_ints ( f , b = 10 , d = ' \u2581 ' ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_words ( f , d ) ] NEW_LINE DEDENT def read_floats ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return [ float ( x ) for x in read_words ( f , d ) ] NEW_LINE DEDENT def read_arr ( f , R , reader = read_ints , * args , ** kwargs ) : NEW_LINE INDENT return [ reader ( f , * args , ** kwargs ) for i in range ( R ) ] NEW_LINE DEDENT def solve ( solver , fn , out_fn = None ) : NEW_LINE INDENT in_fn = fn + ' . in ' NEW_LINE if out_fn is None : NEW_LINE INDENT out_fn = fn + ' . out ' NEW_LINE DEDENT with open ( in_fn , ' r ' ) as fi : NEW_LINE INDENT with open ( out_fn , ' w ' ) as fo : NEW_LINE INDENT T = read_int ( fi ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT case = read_case ( fi ) NEW_LINE res = solver ( case ) NEW_LINE write_case ( fo , i , res ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEBUG = ' i ' NEW_LINE from run import * NEW_LINE", "functions_standalone": [["read_case", "def read_case ( f ) : NEW_LINE INDENT return read_ints ( f ) NEW_LINE DEDENT"], ["solve_small", "def solve_small ( case ) : NEW_LINE INDENT R , C , W = case NEW_LINE return ( C // W ) * R + W - ( 1 if C % W == 0 else 0 ) NEW_LINE DEDENT"], ["solve_large", "def solve_large ( case ) : NEW_LINE INDENT return solve_small ( case ) NEW_LINE DEDENT"], ["write_case", "def write_case ( f , i , res ) : NEW_LINE INDENT f . write ( ' Case \u2581 # % d : \u2581 ' % i ) NEW_LINE f . write ( ' % s ' % res ) NEW_LINE f . write ( ' \\n ' ) NEW_LINE DEDENT"], ["read_word", "def read_word ( f ) : NEW_LINE INDENT return next ( f ) . strip ( ) NEW_LINE DEDENT"], ["read_int", "def read_int ( f , b = 10 ) : NEW_LINE INDENT return int ( read_word ( f ) , b ) NEW_LINE DEDENT"], ["read_letters", "def read_letters ( f ) : NEW_LINE INDENT return list ( read_word ( f ) ) NEW_LINE DEDENT"], ["read_digits", "def read_digits ( f , b = 10 ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_letters ( f ) ] NEW_LINE DEDENT"], ["read_words", "def read_words ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return read_word ( f ) . split ( d ) NEW_LINE DEDENT"], ["read_ints", "def read_ints ( f , b = 10 , d = ' \u2581 ' ) : NEW_LINE INDENT return [ int ( x , b ) for x in read_words ( f , d ) ] NEW_LINE DEDENT"], ["read_floats", "def read_floats ( f , d = ' \u2581 ' ) : NEW_LINE INDENT return [ float ( x ) for x in read_words ( f , d ) ] NEW_LINE DEDENT"], ["read_arr", "def read_arr ( f , R , reader = read_ints , * args , ** kwargs ) : NEW_LINE INDENT return [ reader ( f , * args , ** kwargs ) for i in range ( R ) ] NEW_LINE DEDENT"], ["solve", "def solve ( solver , fn , out_fn = None ) : NEW_LINE INDENT in_fn = fn + ' . in ' NEW_LINE if out_fn is None : NEW_LINE INDENT out_fn = fn + ' . out ' NEW_LINE DEDENT with open ( in_fn , ' r ' ) as fi : NEW_LINE INDENT with open ( out_fn , ' w ' ) as fo : NEW_LINE INDENT T = read_int ( fi ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT case = read_case ( fi ) NEW_LINE res = solver ( case ) NEW_LINE write_case ( fo , i , res ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "17", "code": "def solve ( test ) : NEW_LINE INDENT r , c , w = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ( c / w + w - 1 ) if c % w == 0 else ( c / w + w ) NEW_LINE ans += ( r - 1 ) * c / w NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \" % ( test , ans ) ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT solve ( i + 1 ) ; NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( test ) : NEW_LINE INDENT r , c , w = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ( c / w + w - 1 ) if c % w == 0 else ( c / w + w ) NEW_LINE ans += ( r - 1 ) * c / w NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \" % ( test , ans ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_54", "java": [{"id": "14", "code": "package round3 ; import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class D { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int P = sc . nextInt ( ) ; long [ ] vals = new long [ P ] , freqs = new long [ P ] ; Map < Long , Integer > pos = new HashMap < Long , Integer > ( ) ; for ( int i = 0 ; i < vals . length ; i ++ ) { vals [ i ] = sc . nextLong ( ) ; pos . put ( vals [ i ] , i ) ; } long total = 0 ; for ( int i = 0 ; i < vals . length ; i ++ ) { freqs [ i ] = sc . nextLong ( ) ; total += freqs [ i ] ; } int cant = 0 ; long tmp = total ; while ( tmp > 1 ) { tmp /= 2 ; cant ++ ; } long [ ] ans = new long [ cant ] ; int sumIdx = 0 , setIdx = 0 ; for ( setIdx = 0 ; setIdx < cant ; setIdx ++ ) { for ( int m = 0 ; m < ( 1 << setIdx ) ; m ++ ) { if ( setIdx != 0 && ( m & ( 1 << ( setIdx - 1 ) ) ) == 0 ) continue ; long val = 0 ; for ( int i = 0 ; i < setIdx ; i ++ ) if ( ( m & ( 1 << i ) ) != 0 ) val += ans [ i ] ; freqs [ pos . get ( val ) ] -- ; } while ( freqs [ sumIdx ] == 0 ) { sumIdx ++ ; } ans [ setIdx ] = vals [ sumIdx ] ; } System . out . print ( \" Case \u2581 # \" + caze + \" : \" ) ; for ( int i = 0 ; i < ans . length ; i ++ ) { System . out . print ( \" \u2581 \" + ans [ i ] ) ; } System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int P = sc . nextInt ( ) ; long [ ] vals = new long [ P ] , freqs = new long [ P ] ; Map < Long , Integer > pos = new HashMap < Long , Integer > ( ) ; for ( int i = 0 ; i < vals . length ; i ++ ) { vals [ i ] = sc . nextLong ( ) ; pos . put ( vals [ i ] , i ) ; } long total = 0 ; for ( int i = 0 ; i < vals . length ; i ++ ) { freqs [ i ] = sc . nextLong ( ) ; total += freqs [ i ] ; } int cant = 0 ; long tmp = total ; while ( tmp > 1 ) { tmp /= 2 ; cant ++ ; } long [ ] ans = new long [ cant ] ; int sumIdx = 0 , setIdx = 0 ; for ( setIdx = 0 ; setIdx < cant ; setIdx ++ ) { for ( int m = 0 ; m < ( 1 << setIdx ) ; m ++ ) { if ( setIdx != 0 && ( m & ( 1 << ( setIdx - 1 ) ) ) == 0 ) continue ; long val = 0 ; for ( int i = 0 ; i < setIdx ; i ++ ) if ( ( m & ( 1 << i ) ) != 0 ) val += ans [ i ] ; freqs [ pos . get ( val ) ] -- ; } while ( freqs [ sumIdx ] == 0 ) { sumIdx ++ ; } ans [ setIdx ] = vals [ sumIdx ] ; } System . out . print ( \" Case \u2581 # \" + caze + \" : \" ) ; for ( int i = 0 ; i < ans . length ; i ++ ) { System . out . print ( \" \u2581 \" + ans [ i ] ) ; } System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "12", "code": "import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Scanner ; public class D { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { int P = sc . nextInt ( ) ; int [ ] E = new int [ P ] ; int [ ] F = new int [ P ] ; for ( int i = 0 ; i < P ; i ++ ) { E [ i ] = sc . nextInt ( ) ; } int total = 0 ; for ( int i = 0 ; i < P ; i ++ ) { F [ i ] = sc . nextInt ( ) ; total += F [ i ] ; } int numElems = ( int ) ( Math . log ( total ) / Math . log ( 2 ) + 0.5 ) ; List < Integer > S = new ArrayList < > ( ) ; Map < Integer , Integer > frequencies = new HashMap < > ( ) ; frequencies . put ( 0 , 1 ) ; for ( int i = 0 ; i < P ; i ++ ) { if ( ! frequencies . containsKey ( E [ i ] ) ) { frequencies . put ( E [ i ] , 0 ) ; } while ( frequencies . get ( E [ i ] ) < F [ i ] ) { S . add ( E [ i ] ) ; Map < Integer , Integer > temp = new HashMap < > ( frequencies ) ; for ( Map . Entry < Integer , Integer > entry : frequencies . entrySet ( ) ) { int sum = entry . getKey ( ) + E [ i ] ; if ( temp . containsKey ( sum ) ) { temp . put ( sum , entry . getValue ( ) + frequencies . get ( sum ) ) ; } else { temp . put ( sum , entry . getValue ( ) ) ; } } frequencies = temp ; } } System . out . print ( \" Case \u2581 # \" + caseNum + \" : \" ) ; for ( int i : S ) { System . out . print ( \" \u2581 \" + i ) ; } System . out . println ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { int P = sc . nextInt ( ) ; int [ ] E = new int [ P ] ; int [ ] F = new int [ P ] ; for ( int i = 0 ; i < P ; i ++ ) { E [ i ] = sc . nextInt ( ) ; } int total = 0 ; for ( int i = 0 ; i < P ; i ++ ) { F [ i ] = sc . nextInt ( ) ; total += F [ i ] ; } int numElems = ( int ) ( Math . log ( total ) / Math . log ( 2 ) + 0.5 ) ; List < Integer > S = new ArrayList < > ( ) ; Map < Integer , Integer > frequencies = new HashMap < > ( ) ; frequencies . put ( 0 , 1 ) ; for ( int i = 0 ; i < P ; i ++ ) { if ( ! frequencies . containsKey ( E [ i ] ) ) { frequencies . put ( E [ i ] , 0 ) ; } while ( frequencies . get ( E [ i ] ) < F [ i ] ) { S . add ( E [ i ] ) ; Map < Integer , Integer > temp = new HashMap < > ( frequencies ) ; for ( Map . Entry < Integer , Integer > entry : frequencies . entrySet ( ) ) { int sum = entry . getKey ( ) + E [ i ] ; if ( temp . containsKey ( sum ) ) { temp . put ( sum , entry . getValue ( ) + frequencies . get ( sum ) ) ; } else { temp . put ( sum , entry . getValue ( ) ) ; } } frequencies = temp ; } } System . out . print ( \" Case \u2581 # \" + caseNum + \" : \" ) ; for ( int i : S ) { System . out . print ( \" \u2581 \" + i ) ; } System . out . println ( ) ; } }"]], "functions_class": []}], "python": [{"id": "3", "code": "tc = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( tc ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE v = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE cnt = sum ( c ) NEW_LINE c [ 0 ] -= 1 NEW_LINE midx = 0 NEW_LINE res = [ ] NEW_LINE while cnt > 2 : NEW_LINE INDENT while c [ midx ] == 0 : NEW_LINE INDENT midx += 1 NEW_LINE DEDENT d = v [ midx ] - v [ 0 ] NEW_LINE res . append ( d ) NEW_LINE if d == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT c [ i ] = c [ i ] // 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tosub = { d : c [ 0 ] + 1 } NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT c [ i ] -= tosub . get ( v [ i ] , 0 ) NEW_LINE tosub [ v [ i ] + d ] = c [ i ] NEW_LINE DEDENT DEDENT cnt /= 2 NEW_LINE DEDENT while c [ midx ] == 0 : NEW_LINE INDENT midx += 1 NEW_LINE DEDENT if v [ 0 ] == 0 : NEW_LINE INDENT res . append ( v [ midx ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( v [ 0 ] ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( t + 1 , \" \u2581 \" . join ( str ( x ) for x in sorted ( res ) ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "from collections import Counter NEW_LINE T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT P , = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE E = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE F = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE neg = min ( E ) NEW_LINE E = [ i - neg for i in E ] NEW_LINE c = Counter ( dict ( zip ( E , F ) ) ) NEW_LINE ans = [ ] NEW_LINE while c [ 0 ] > 1 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE d = Counter ( ) NEW_LINE for k in c : NEW_LINE INDENT d [ k ] = c [ k ] // 2 NEW_LINE DEDENT c = d NEW_LINE DEDENT del c [ 0 ] NEW_LINE while c : NEW_LINE INDENT e = min ( c ) NEW_LINE ans . append ( e ) NEW_LINE c [ e ] -= 1 NEW_LINE d = Counter ( ) NEW_LINE for k in sorted ( c . keys ( ) ) : NEW_LINE INDENT if c [ k ] > 0 : NEW_LINE INDENT d [ k ] = c [ k ] NEW_LINE assert k + e in c NEW_LINE c [ k + e ] -= c [ k ] NEW_LINE DEDENT DEDENT c = d NEW_LINE DEDENT while neg : NEW_LINE INDENT t = max ( i for i in ans if i <= - neg ) NEW_LINE del ans [ ans . index ( t ) ] NEW_LINE ans . append ( - t ) NEW_LINE neg += t NEW_LINE DEDENT ans . sort ( ) NEW_LINE ans = ' \u2581 ' . join ( map ( str , ans ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_15_01", "java": [{"id": "19", "code": "package codejam15 ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . Scanner ; public class A { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( new File ( \" a . in \" ) ) ) ; PrintWriter pw = new PrintWriter ( \" a . out \" ) ; int tc = sc . nextInt ( ) ; for ( int t = 1 ; t <= tc ; t ++ ) { int l = sc . nextInt ( ) ; String s = sc . nextLine ( ) ; int cnt = 0 ; int added = 0 ; for ( int i = 0 ; i <= l ; i ++ ) { if ( i > cnt ) { int need = i - cnt ; added += need ; cnt += need ; } cnt += s . charAt ( i + 1 ) - '0' ; } pw . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , t , added ) ; } sc . close ( ) ; pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( new File ( \" a . in \" ) ) ) ; PrintWriter pw = new PrintWriter ( \" a . out \" ) ; int tc = sc . nextInt ( ) ; for ( int t = 1 ; t <= tc ; t ++ ) { int l = sc . nextInt ( ) ; String s = sc . nextLine ( ) ; int cnt = 0 ; int added = 0 ; for ( int i = 0 ; i <= l ; i ++ ) { if ( i > cnt ) { int need = i - cnt ; added += need ; cnt += need ; } cnt += s . charAt ( i + 1 ) - '0' ; } pw . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , t , added ) ; } sc . close ( ) ; pw . close ( ) ; }"]], "functions_class": []}, {"id": "1", "code": "import java . io . * ; import java . util . * ; import java . util . concurrent . * ; public class A { int n ; String s ; String solve ( ) { int up = 0 ; int ans = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int count = s . charAt ( i ) - '0' ; if ( count == 0 ) { continue ; } if ( up < i ) { ans += i - up ; up = i ; } up += count ; } return \" \" + ans ; } public A ( Scanner in ) { n = in . nextInt ( ) ; s = in . next ( ) ; } private static String fileName = A . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) . toLowerCase ( ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; public static void main ( String [ ] args ) throws IOException , InterruptedException , ExecutionException { ExecutorService executor = Executors . newFixedThreadPool ( 4 ) ; Locale . setDefault ( Locale . US ) ; Scanner in = new Scanner ( new File ( inputFileName ) ) ; PrintWriter out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; @ SuppressWarnings ( \" unchecked \" ) Future < String > [ ] outputs = new Future [ tests ] ; for ( int t = 0 ; t < tests ; t ++ ) { final A testCase = new A ( in ) ; final int testCaseNumber = t ; outputs [ t ] = executor . submit ( new Callable < String > ( ) { @ Override public String call ( ) { String answer = testCase . solve ( ) ; String printed = \" Case \u2581 # \" + ( testCaseNumber + 1 ) + \" : \u2581 \" + answer ; System . out . println ( printed ) ; return printed ; } } ) ; } for ( int t = 0 ; t < tests ; t ++ ) { out . println ( outputs [ t ] . get ( ) ) ; } in . close ( ) ; out . close ( ) ; executor . shutdown ( ) ; } }", "functions_standalone": [], "functions_class": [["solve", "String solve ( ) { int up = 0 ; int ans = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int count = s . charAt ( i ) - '0' ; if ( count == 0 ) { continue ; } if ( up < i ) { ans += i - up ; up = i ; } up += count ; } return \" \" + ans ; }"], ["A", "public A ( Scanner in ) { n = in . nextInt ( ) ; s = in . next ( ) ; }"], ["A", "t ++ ) { final A testCase = new A ( in ) ; final int testCaseNumber = t ; outputs [ t ] = executor . submit ( new Callable < String > ( ) { @ Override public String call ( ) { String answer = testCase . solve ( ) ; String printed = \" Case \u2581 # \" + ( testCaseNumber + 1 ) + \" : \u2581 \" + answer ; System . out . println ( printed ) ; return printed ; } } ) ; }"], ["println", "t ++ ) { out . println ( outputs [ t ] . get ( ) ) ; }"]]}, {"id": "7", "code": "import java . util . * ; import java . io . * ; public class StandingOvation { static final String filename = \" C : / Users / Kevin / algs4 / CodeJam / StandingOvation / A - large . in \" ; static final String output = \" largefinaloutput . txt \" ; public static int numOfFriends ( int [ ] shylevels ) { int total = 0 ; int ret = 0 ; for ( int i = 0 ; i < shylevels . length ; ++ i ) { ret = Math . max ( ret , i - total ) ; total += shylevels [ i ] ; } return ret ; } public static void main ( String [ ] args ) { try { Scanner sc = new Scanner ( new FileInputStream ( new File ( filename ) ) ) ; int no_of_times = sc . nextInt ( ) ; for ( int i = 0 ; i < no_of_times ; ++ i ) { sc . nextInt ( ) ; char [ ] shylevelchars = sc . nextLine ( ) . toCharArray ( ) ; int [ ] shylevels = new int [ shylevelchars . length - 1 ] ; for ( int j = 1 ; j < shylevelchars . length ; ++ j ) { shylevels [ j - 1 ] = Integer . parseInt ( ( ( Character ) shylevelchars [ j ] ) . toString ( ) ) ; } FileOutputStream fos = new FileOutputStream ( output , true ) ; fos . write ( ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + numOfFriends ( shylevels ) + \" \\n \" ) . getBytes ( ) ) ; fos . close ( ) ; } sc . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["numOfFriends", "public static int numOfFriends ( int [ ] shylevels ) { int total = 0 ; int ret = 0 ; for ( int i = 0 ; i < shylevels . length ; ++ i ) { ret = Math . max ( ret , i - total ) ; total += shylevels [ i ] ; } return ret ; }"], ["main", "public static void main ( String [ ] args ) { try { Scanner sc = new Scanner ( new FileInputStream ( new File ( filename ) ) ) ; int no_of_times = sc . nextInt ( ) ; for ( int i = 0 ; i < no_of_times ; ++ i ) { sc . nextInt ( ) ; char [ ] shylevelchars = sc . nextLine ( ) . toCharArray ( ) ; int [ ] shylevels = new int [ shylevelchars . length - 1 ] ; for ( int j = 1 ; j < shylevelchars . length ; ++ j ) { shylevels [ j - 1 ] = Integer . parseInt ( ( ( Character ) shylevelchars [ j ] ) . toString ( ) ) ; } FileOutputStream fos = new FileOutputStream ( output , true ) ; fos . write ( ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + numOfFriends ( shylevels ) + \" \\n \" ) . getBytes ( ) ) ; fos . close ( ) ; } sc . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "20", "code": "package round0 ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; public class StandingOvation { private static FileWriter writer ; public static void main ( String [ ] args ) throws IOException { File file = new File ( \" round0 / A - large . in \" ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; File outputFile = new File ( \" round0 / output - ovation . txt \" ) ; writer = new FileWriter ( outputFile ) ; int numberOfPerformances = Integer . parseInt ( reader . readLine ( ) ) ; for ( int show = 1 ; show <= numberOfPerformances ; show ++ ) { String [ ] split = reader . readLine ( ) . split ( \" \u2581 \" ) ; int length = Integer . parseInt ( split [ 0 ] ) ; char [ ] audience = split [ 1 ] . toCharArray ( ) ; generateOutput ( \" Case \u2581 # \" + show + \" : \u2581 \" + invitedFriends ( length , audience ) ) ; } reader . close ( ) ; writer . close ( ) ; } private static int invitedFriends ( int length , char [ ] audience ) { int friends = 0 ; int totalStanding = 0 ; for ( int i = 0 ; i < length + 1 ; i ++ ) { totalStanding += Integer . parseInt ( \" \" + audience [ i ] ) ; if ( totalStanding < i + 1 ) { friends ++ ; totalStanding ++ ; } } return friends ; } private static void generateOutput ( String line ) throws IOException { System . out . println ( line ) ; writer . write ( line + \" \\n \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { File file = new File ( \" round0 / A - large . in \" ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; File outputFile = new File ( \" round0 / output - ovation . txt \" ) ; writer = new FileWriter ( outputFile ) ; int numberOfPerformances = Integer . parseInt ( reader . readLine ( ) ) ; for ( int show = 1 ; show <= numberOfPerformances ; show ++ ) { String [ ] split = reader . readLine ( ) . split ( \" \u2581 \" ) ; int length = Integer . parseInt ( split [ 0 ] ) ; char [ ] audience = split [ 1 ] . toCharArray ( ) ; generateOutput ( \" Case \u2581 # \" + show + \" : \u2581 \" + invitedFriends ( length , audience ) ) ; } reader . close ( ) ; writer . close ( ) ; }"], ["invitedFriends", "private static int invitedFriends ( int length , char [ ] audience ) { int friends = 0 ; int totalStanding = 0 ; for ( int i = 0 ; i < length + 1 ; i ++ ) { totalStanding += Integer . parseInt ( \" \" + audience [ i ] ) ; if ( totalStanding < i + 1 ) { friends ++ ; totalStanding ++ ; } } return friends ; }"], ["generateOutput", "private static void generateOutput ( String line ) throws IOException { System . out . println ( line ) ; writer . write ( line + \" \\n \" ) ; }"]], "functions_class": []}, {"id": "6", "code": "package gcj2015 . qualif ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ExoA { public static void main ( final String [ ] args ) { final String base = \" / home / jean / gcj2015 / q / ExoA / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoA . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } private static void test ( final Scanner sc , final PrintWriter pw ) { final int Smax = sc . nextInt ( ) ; final String levels = sc . next ( ) ; final int [ ] ls = new int [ levels . length ( ) ] ; int ts = 0 ; int toAdd = 0 ; for ( int i = 0 ; i < levels . length ( ) ; i ++ ) { if ( ts < i ) { toAdd += ( i - ts ) ; ts = i ; } ls [ i ] = levels . charAt ( i ) - '0' ; ts += ls [ i ] ; } pw . print ( toAdd ) ; } }", "functions_standalone": [["main", "public static void main ( final String [ ] args ) { final String base = \" / home / jean / gcj2015 / q / ExoA / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b1 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoA . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"], ["test", "private static void test ( final Scanner sc , final PrintWriter pw ) { final int Smax = sc . nextInt ( ) ; final String levels = sc . next ( ) ; final int [ ] ls = new int [ levels . length ( ) ] ; int ts = 0 ; int toAdd = 0 ; for ( int i = 0 ; i < levels . length ( ) ; i ++ ) { if ( ts < i ) { toAdd += ( i - ts ) ; ts = i ; } ls [ i ] = levels . charAt ( i ) - '0' ; ts += ls [ i ] ; } pw . print ( toAdd ) ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "DESCRIPTION = \"\"\" STRNEWLINE \"\"\" NEW_LINE import os NEW_LINE import sys NEW_LINE import argparse NEW_LINE def perr ( msg ) : NEW_LINE INDENT sys . stderr . write ( \" % s \" % msg ) NEW_LINE sys . stderr . flush ( ) NEW_LINE DEDENT def pinfo ( msg ) : NEW_LINE INDENT sys . stdout . write ( \" % s \" % msg ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT def runcmd ( cmd ) : NEW_LINE INDENT perr ( \" % s \\n \" % cmd ) NEW_LINE os . system ( cmd ) NEW_LINE DEDENT def getargs ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = DESCRIPTION , formatter_class = argparse . RawTextHelpFormatter ) NEW_LINE parser . add_argument ( ' infile ' , type = str , help = ' input \u2581 file ' ) NEW_LINE parser . add_argument ( ' outfile ' , type = str , nargs = ' ? ' , default = None , help = ' output \u2581 file ' ) NEW_LINE return parser . parse_args ( ) NEW_LINE DEDENT def solve ( Smax , Scnt ) : NEW_LINE INDENT ret = 0 NEW_LINE acc = Scnt [ 0 ] NEW_LINE for i in range ( 1 , len ( Scnt ) ) : NEW_LINE INDENT rest = i - acc NEW_LINE if rest > 0 : NEW_LINE INDENT ret += rest NEW_LINE acc += rest NEW_LINE DEDENT acc += Scnt [ i ] NEW_LINE DEDENT return ret NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT if None == args . outfile : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args . outfile , \" w \" ) NEW_LINE DEDENT with open ( args . infile ) as infile : NEW_LINE INDENT T = int ( infile . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT [ Smax , Scnt ] = infile . readline ( ) . split ( ) NEW_LINE Smax = int ( Smax ) NEW_LINE Scnt = [ int ( cnt ) for cnt in list ( Scnt ) ] NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i , solve ( Smax , Scnt ) ) ) NEW_LINE DEDENT DEDENT if None != args . outfile : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( getargs ( ) ) NEW_LINE DEDENT", "functions_standalone": [["perr", "def perr ( msg ) : NEW_LINE INDENT sys . stderr . write ( \" % s \" % msg ) NEW_LINE sys . stderr . flush ( ) NEW_LINE DEDENT"], ["pinfo", "def pinfo ( msg ) : NEW_LINE INDENT sys . stdout . write ( \" % s \" % msg ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT"], ["runcmd", "def runcmd ( cmd ) : NEW_LINE INDENT perr ( \" % s \\n \" % cmd ) NEW_LINE os . system ( cmd ) NEW_LINE DEDENT"], ["getargs", "def getargs ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = DESCRIPTION , formatter_class = argparse . RawTextHelpFormatter ) NEW_LINE parser . add_argument ( ' infile ' , type = str , help = ' input \u2581 file ' ) NEW_LINE parser . add_argument ( ' outfile ' , type = str , nargs = ' ? ' , default = None , help = ' output \u2581 file ' ) NEW_LINE return parser . parse_args ( ) NEW_LINE DEDENT"], ["solve", "def solve ( Smax , Scnt ) : NEW_LINE INDENT ret = 0 NEW_LINE acc = Scnt [ 0 ] NEW_LINE for i in range ( 1 , len ( Scnt ) ) : NEW_LINE INDENT rest = i - acc NEW_LINE if rest > 0 : NEW_LINE INDENT ret += rest NEW_LINE acc += rest NEW_LINE DEDENT acc += Scnt [ i ] NEW_LINE DEDENT return ret NEW_LINE DEDENT"], ["main", "def main ( args ) : NEW_LINE INDENT if None == args . outfile : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args . outfile , \" w \" ) NEW_LINE DEDENT with open ( args . infile ) as infile : NEW_LINE INDENT T = int ( infile . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT [ Smax , Scnt ] = infile . readline ( ) . split ( ) NEW_LINE Smax = int ( Smax ) NEW_LINE Scnt = [ int ( cnt ) for cnt in list ( Scnt ) ] NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i , solve ( Smax , Scnt ) ) ) NEW_LINE DEDENT DEDENT if None != args . outfile : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "18", "code": "f_in = open ( ' file . in ' ) NEW_LINE f_out = open ( ' file . out ' , ' w ' ) NEW_LINE cases = int ( f_in . readline ( ) ) NEW_LINE for i in range ( 1 , cases + 1 ) : NEW_LINE INDENT shynesses = f_in . readline ( ) . split ( ) [ 1 ] NEW_LINE shynesses = [ int ( i ) for i in list ( shynesses ) ] NEW_LINE friends = 0 NEW_LINE current = 0 NEW_LINE for j in range ( 0 , len ( shynesses ) ) : NEW_LINE INDENT if current < j and shynesses [ j ] != 0 : NEW_LINE INDENT friends += j - current NEW_LINE current += j - current NEW_LINE DEDENT current += shynesses [ j ] NEW_LINE DEDENT f_out . write ( \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + str ( friends ) + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT N , S = input ( ) . split ( ) NEW_LINE answer , alive , N = 0 , int ( S [ 0 ] ) , int ( N ) NEW_LINE for n in range ( 1 , N + 1 ) : NEW_LINE INDENT if S [ n ] == '0' : continue NEW_LINE if alive < n : NEW_LINE INDENT answer += n - alive NEW_LINE alive = n NEW_LINE DEDENT alive += int ( S [ n ] ) NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( t , answer ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "3", "code": "def numberneeded ( lst ) : NEW_LINE INDENT invites = 0 NEW_LINE standing = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if lst [ i ] != 0 and standing < i : NEW_LINE INDENT invites += ( i - standing ) NEW_LINE standing += ( i - standing ) NEW_LINE DEDENT standing += lst [ i ] NEW_LINE DEDENT return ( invites ) NEW_LINE DEDENT import sys NEW_LINE with open ( sys . argv [ 1 ] , \" r \" ) as fileIN : NEW_LINE INDENT inputLines = fileIN . readlines ( ) NEW_LINE DEDENT inputLines = [ line . strip ( ) for line in inputLines ] NEW_LINE with open ( sys . argv [ 2 ] , \" w \" ) as fileOUT : NEW_LINE INDENT numberOfCases = int ( inputLines . pop ( 0 ) ) NEW_LINE for num in range ( numberOfCases ) : NEW_LINE INDENT inputstring = inputLines . pop ( 0 ) . rstrip ( ) . split ( ' \u2581 ' ) [ 1 ] NEW_LINE inputlist = [ int ( x ) for x in list ( inputstring ) ] NEW_LINE fileOUT . write ( ' Case \u2581 # ' + str ( num + 1 ) + ' : \u2581 ' + str ( numberneeded ( inputlist ) ) + ' \\n ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["numberneeded", "def numberneeded ( lst ) : NEW_LINE INDENT invites = 0 NEW_LINE standing = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if lst [ i ] != 0 and standing < i : NEW_LINE INDENT invites += ( i - standing ) NEW_LINE standing += ( i - standing ) NEW_LINE DEDENT standing += lst [ i ] NEW_LINE DEDENT return ( invites ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "import math NEW_LINE import sys NEW_LINE def findsol ( S , Smax ) : NEW_LINE INDENT b = 0 NEW_LINE c = 0 NEW_LINE for ii in range ( len ( S ) ) : NEW_LINE INDENT c += S [ ii ] NEW_LINE if ( ii - c + 1 > b ) : NEW_LINE INDENT b = ii - c + 1 NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT fidi = open ( ' A - large . in ' , ' r ' ) NEW_LINE fido = open ( ' a . out ' , ' w ' ) NEW_LINE T = fidi . readline ( ) NEW_LINE T = int ( T ) NEW_LINE for ii in range ( 1 , T + 1 ) : NEW_LINE INDENT tmp = fidi . readline ( ) NEW_LINE jj = tmp . find ( ' \u2581 ' ) NEW_LINE Smax = int ( tmp [ 0 : jj ] ) NEW_LINE S = [ ] NEW_LINE for kk in range ( jj + 1 , len ( tmp ) ) : NEW_LINE INDENT try : NEW_LINE INDENT S . append ( int ( tmp [ kk ] ) ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( ' ' ) NEW_LINE DEDENT DEDENT a = findsol ( S , Smax ) NEW_LINE fido . write ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' + str ( a ) + ' \\n ' ) NEW_LINE print ( ' Case \u2581 # ' , str ( ii ) , ' : \u2581 ' , str ( a ) ) NEW_LINE DEDENT fidi . close ( ) NEW_LINE fido . close ( ) NEW_LINE", "functions_standalone": [["findsol", "def findsol ( S , Smax ) : NEW_LINE INDENT b = 0 NEW_LINE c = 0 NEW_LINE for ii in range ( len ( S ) ) : NEW_LINE INDENT c += S [ ii ] NEW_LINE if ( ii - c + 1 > b ) : NEW_LINE INDENT b = ii - c + 1 NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT"], ["convertnums", "def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_52", "java": [{"id": "14", "code": "import java . util . * ; import static java . lang . Math . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; long [ ] sum = new long [ N - K + 1 ] ; for ( int i = 0 ; i < sum . length ; i ++ ) sum [ i ] = in . nextInt ( ) ; long [ ] diff = new long [ N ] ; long [ ] A = new long [ K ] ; long [ ] B = new long [ K ] ; for ( int i = 0 ; i + 1 < sum . length ; i ++ ) { long d = sum [ i + 1 ] - sum [ i ] ; diff [ i + K ] = diff [ i ] + d ; A [ i % K ] = min ( A [ i % K ] , diff [ i + K ] ) ; B [ i % K ] = max ( B [ i % K ] , diff [ i + K ] ) ; } long total = 0 ; for ( int i = 0 ; i < K ; i ++ ) { total -= A [ i ] ; B [ i ] -= A [ i ] ; A [ i ] = 0 ; } Arrays . sort ( B ) ; long d = sum [ 0 ] - total ; d = ( ( d % K ) + K ) % K ; if ( d < 0 || d >= K ) throw new RuntimeException ( ) ; for ( long ans = B [ K - 1 ] ; ; ans ++ ) { long less = 0 ; for ( long b : B ) less += ans - b ; if ( less >= d ) { System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans ) ; break ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; long [ ] sum = new long [ N - K + 1 ] ; for ( int i = 0 ; i < sum . length ; i ++ ) sum [ i ] = in . nextInt ( ) ; long [ ] diff = new long [ N ] ; long [ ] A = new long [ K ] ; long [ ] B = new long [ K ] ; for ( int i = 0 ; i + 1 < sum . length ; i ++ ) { long d = sum [ i + 1 ] - sum [ i ] ; diff [ i + K ] = diff [ i ] + d ; A [ i % K ] = min ( A [ i % K ] , diff [ i + K ] ) ; B [ i % K ] = max ( B [ i % K ] , diff [ i + K ] ) ; } long total = 0 ; for ( int i = 0 ; i < K ; i ++ ) { total -= A [ i ] ; B [ i ] -= A [ i ] ; A [ i ] = 0 ; } Arrays . sort ( B ) ; long d = sum [ 0 ] - total ; d = ( ( d % K ) + K ) % K ; if ( d < 0 || d >= K ) throw new RuntimeException ( ) ; for ( long ans = B [ K - 1 ] ; ; ans ++ ) { long less = 0 ; for ( long b : B ) less += ans - b ; if ( less >= d ) { System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans ) ; break ; } } } }"]], "functions_class": []}, {"id": "18", "code": "package round3 ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; int [ ] sums = new int [ N - K + 1 ] ; for ( int i = 0 ; i < sums . length ; i ++ ) { sums [ i ] = sc . nextInt ( ) ; } int [ ] min = new int [ K ] , max = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { int val = 0 ; for ( int j = i ; j + 1 < sums . length ; j += K ) { val += sums [ j + 1 ] - sums [ j ] ; min [ i ] = Math . min ( min [ i ] , val ) ; max [ i ] = Math . max ( max [ i ] , val ) ; } } int sumModulo = 0 , maxInterval = 0 , canUse = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sumModulo -= min [ i ] ; maxInterval = Math . max ( maxInterval , max [ i ] - min [ i ] ) ; } for ( int i = 0 ; i < K ; i ++ ) { canUse += maxInterval - ( max [ i ] - min [ i ] ) ; } boolean can = false ; for ( int i = 0 ; i <= canUse ; i ++ ) { if ( ( sumModulo + i - sums [ 0 ] ) % K == 0 ) { can = true ; break ; } } if ( ! can ) maxInterval ++ ; System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + maxInterval ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; int [ ] sums = new int [ N - K + 1 ] ; for ( int i = 0 ; i < sums . length ; i ++ ) { sums [ i ] = sc . nextInt ( ) ; } int [ ] min = new int [ K ] , max = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { int val = 0 ; for ( int j = i ; j + 1 < sums . length ; j += K ) { val += sums [ j + 1 ] - sums [ j ] ; min [ i ] = Math . min ( min [ i ] , val ) ; max [ i ] = Math . max ( max [ i ] , val ) ; } } int sumModulo = 0 , maxInterval = 0 , canUse = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sumModulo -= min [ i ] ; maxInterval = Math . max ( maxInterval , max [ i ] - min [ i ] ) ; } for ( int i = 0 ; i < K ; i ++ ) { canUse += maxInterval - ( max [ i ] - min [ i ] ) ; } boolean can = false ; for ( int i = 0 ; i <= canUse ; i ++ ) { if ( ( sumModulo + i - sums [ 0 ] ) % K == 0 ) { can = true ; break ; } } if ( ! can ) maxInterval ++ ; System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + maxInterval ) ; } }"]], "functions_class": []}, {"id": "12", "code": "import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; int [ ] sums = new int [ N - K + 1 ] ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) { sums [ i ] = sc . nextInt ( ) ; } int [ ] maxDiff = new int [ K ] ; int [ ] minDiff = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { int totalDiff = 0 ; for ( int j = i ; j < N - K ; j += K ) { totalDiff += sums [ j + 1 ] - sums [ j ] ; maxDiff [ i ] = Math . max ( maxDiff [ i ] , totalDiff ) ; minDiff [ i ] = Math . min ( minDiff [ i ] , totalDiff ) ; } } long min = 0 ; long max = Integer . MAX_VALUE ; while ( min < max ) { long mid = ( min + max ) / 2 ; boolean possible = true ; long minSum = 0 , maxSum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( maxDiff [ i ] - minDiff [ i ] > mid ) { possible = false ; break ; } long minValue = - minDiff [ i ] , maxValue = mid - maxDiff [ i ] ; minSum += minValue ; maxSum += maxValue ; } long target = ( ( sums [ 0 ] - minSum ) % K + K ) % K + minSum ; if ( possible && target <= maxSum ) { max = mid ; } else { min = mid + 1 ; } } System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + min ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; int [ ] sums = new int [ N - K + 1 ] ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) { sums [ i ] = sc . nextInt ( ) ; } int [ ] maxDiff = new int [ K ] ; int [ ] minDiff = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { int totalDiff = 0 ; for ( int j = i ; j < N - K ; j += K ) { totalDiff += sums [ j + 1 ] - sums [ j ] ; maxDiff [ i ] = Math . max ( maxDiff [ i ] , totalDiff ) ; minDiff [ i ] = Math . min ( minDiff [ i ] , totalDiff ) ; } } long min = 0 ; long max = Integer . MAX_VALUE ; while ( min < max ) { long mid = ( min + max ) / 2 ; boolean possible = true ; long minSum = 0 , maxSum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( maxDiff [ i ] - minDiff [ i ] > mid ) { possible = false ; break ; } long minValue = - minDiff [ i ] , maxValue = mid - maxDiff [ i ] ; minSum += minValue ; maxSum += maxValue ; } long target = ( ( sums [ 0 ] - minSum ) % K + K ) % K + minSum ; if ( possible && target <= maxSum ) { max = mid ; } else { min = mid + 1 ; } } System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + min ) ; } }"]], "functions_class": []}, {"id": "7", "code": "import java . util . * ; import java . io . * ; public class B { public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; int K = input . nextInt ( ) ; int [ ] sums = new int [ N - K + 1 ] ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) sums [ i ] = input . nextInt ( ) ; int [ ] maxdiffs = new int [ K ] ; int [ ] mindiffs = new int [ K ] ; int [ ] currdiff = new int [ K ] ; for ( int i = K ; i < N ; i ++ ) { currdiff [ i % K ] += sums [ i - K + 1 ] - sums [ i - K ] ; if ( currdiff [ i % K ] > maxdiffs [ i % K ] ) maxdiffs [ i % K ] = currdiff [ i % K ] ; if ( currdiff [ i % K ] < mindiffs [ i % K ] ) mindiffs [ i % K ] = currdiff [ i % K ] ; } int [ ] diffdiffs = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) diffdiffs [ i ] = maxdiffs [ i ] - mindiffs [ i ] ; int maxdiffdiff = 0 ; for ( int i = 0 ; i < K ; i ++ ) if ( diffdiffs [ i ] > maxdiffdiff ) maxdiffdiff = diffdiffs [ i ] ; int highBound = 0 ; for ( int i = 0 ; i < K ; i ++ ) highBound += maxdiffdiff - diffdiffs [ i ] ; int target = sums [ 0 ] ; for ( int i = 0 ; i < K ; i ++ ) target += mindiffs [ i ] ; target = ( target % K + K ) % K ; int ans = maxdiffdiff + ( target <= highBound ? 0 : 1 ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; int K = input . nextInt ( ) ; int [ ] sums = new int [ N - K + 1 ] ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) sums [ i ] = input . nextInt ( ) ; int [ ] maxdiffs = new int [ K ] ; int [ ] mindiffs = new int [ K ] ; int [ ] currdiff = new int [ K ] ; for ( int i = K ; i < N ; i ++ ) { currdiff [ i % K ] += sums [ i - K + 1 ] - sums [ i - K ] ; if ( currdiff [ i % K ] > maxdiffs [ i % K ] ) maxdiffs [ i % K ] = currdiff [ i % K ] ; if ( currdiff [ i % K ] < mindiffs [ i % K ] ) mindiffs [ i % K ] = currdiff [ i % K ] ; } int [ ] diffdiffs = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) diffdiffs [ i ] = maxdiffs [ i ] - mindiffs [ i ] ; int maxdiffdiff = 0 ; for ( int i = 0 ; i < K ; i ++ ) if ( diffdiffs [ i ] > maxdiffdiff ) maxdiffdiff = diffdiffs [ i ] ; int highBound = 0 ; for ( int i = 0 ; i < K ; i ++ ) highBound += maxdiffdiff - diffdiffs [ i ] ; int target = sums [ 0 ] ; for ( int i = 0 ; i < K ; i ++ ) target += mindiffs [ i ] ; target = ( target % K + K ) % K ; int ans = maxdiffdiff + ( target <= highBound ? 0 : 1 ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( ans ) ; } }"]], "functions_class": []}], "python": [{"id": "11", "code": "for x in range ( 1 , int ( input ( ) ) + 1 ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE sums = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ 0 ] * K NEW_LINE t = sums [ 0 ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT b = 0 NEW_LINE c = 0 NEW_LINE for j in range ( i , N - K , K ) : NEW_LINE INDENT c += sums [ j + 1 ] - sums [ j ] NEW_LINE if c > a [ i ] : NEW_LINE INDENT a [ i ] = c NEW_LINE DEDENT elif c < b : NEW_LINE INDENT b = c NEW_LINE DEDENT DEDENT a [ i ] -= b NEW_LINE t += b NEW_LINE DEDENT t %= K NEW_LINE for i in range ( t ) : NEW_LINE INDENT bestj = 0 NEW_LINE for j in range ( 1 , K ) : NEW_LINE INDENT if a [ j ] < a [ bestj ] : NEW_LINE INDENT bestj = j NEW_LINE DEDENT DEDENT a [ bestj ] += 1 NEW_LINE DEDENT y = max ( a ) NEW_LINE print ( ' Case \u2581 # ' + str ( x ) + ' : ' , y ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "9", "code": "import sys NEW_LINE def run ( N , K , sums ) : NEW_LINE INDENT diffs = [ ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT cmin = 0 NEW_LINE cmax = 0 NEW_LINE ctemp = 0 NEW_LINE for j in range ( i , N - K , K ) : NEW_LINE INDENT ctemp += sums [ j + 1 ] - sums [ j ] NEW_LINE cmin = min ( cmin , ctemp ) NEW_LINE cmax = max ( cmax , ctemp ) NEW_LINE DEDENT diffs . append ( [ cmax - cmin , cmin , cmax ] ) NEW_LINE DEDENT diffs . sort ( ) NEW_LINE diff2 = [ ] NEW_LINE offset = 0 NEW_LINE for d in diffs : NEW_LINE INDENT if d [ 1 ] < diffs [ - 1 ] [ 1 ] : NEW_LINE INDENT offset += diffs [ - 1 ] [ 1 ] - d [ 1 ] NEW_LINE diff2 . append ( [ d [ 0 ] , diffs [ - 1 ] [ 1 ] , d [ 2 ] + diffs [ - 1 ] [ 1 ] - d [ 1 ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT diff2 . append ( d ) NEW_LINE DEDENT DEDENT totminus = sum ( r [ 1 ] - diff2 [ - 1 ] [ 1 ] for r in diff2 ) NEW_LINE totplus = sum ( diff2 [ - 1 ] [ 2 ] - r [ 2 ] for r in diff2 ) NEW_LINE needplus = ( sums [ 0 ] - offset ) % K NEW_LINE needminus = ( offset - sums [ 0 ] ) % K NEW_LINE if totminus >= needminus or totplus >= needplus : NEW_LINE INDENT return diff2 [ - 1 ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return diff2 [ - 1 ] [ 0 ] + 1 NEW_LINE DEDENT DEDENT fin = open ( sys . argv [ 1 ] ) NEW_LINE T = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT N , K = [ int ( x ) for x in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE sums = [ int ( x ) for x in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE ans = run ( N , K , sums ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % s ' % ( i , ans ) ) NEW_LINE DEDENT", "functions_standalone": [["run", "def run ( N , K , sums ) : NEW_LINE INDENT diffs = [ ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT cmin = 0 NEW_LINE cmax = 0 NEW_LINE ctemp = 0 NEW_LINE for j in range ( i , N - K , K ) : NEW_LINE INDENT ctemp += sums [ j + 1 ] - sums [ j ] NEW_LINE cmin = min ( cmin , ctemp ) NEW_LINE cmax = max ( cmax , ctemp ) NEW_LINE DEDENT diffs . append ( [ cmax - cmin , cmin , cmax ] ) NEW_LINE DEDENT diffs . sort ( ) NEW_LINE diff2 = [ ] NEW_LINE offset = 0 NEW_LINE for d in diffs : NEW_LINE INDENT if d [ 1 ] < diffs [ - 1 ] [ 1 ] : NEW_LINE INDENT offset += diffs [ - 1 ] [ 1 ] - d [ 1 ] NEW_LINE diff2 . append ( [ d [ 0 ] , diffs [ - 1 ] [ 1 ] , d [ 2 ] + diffs [ - 1 ] [ 1 ] - d [ 1 ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT diff2 . append ( d ) NEW_LINE DEDENT DEDENT totminus = sum ( r [ 1 ] - diff2 [ - 1 ] [ 1 ] for r in diff2 ) NEW_LINE totplus = sum ( diff2 [ - 1 ] [ 2 ] - r [ 2 ] for r in diff2 ) NEW_LINE needplus = ( sums [ 0 ] - offset ) % K NEW_LINE needminus = ( offset - sums [ 0 ] ) % K NEW_LINE if totminus >= needminus or totplus >= needplus : NEW_LINE INDENT return diff2 [ - 1 ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return diff2 [ - 1 ] [ 0 ] + 1 NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "2", "code": "from pulp import * NEW_LINE tc = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( tc ) : NEW_LINE INDENT f = input ( ) . split ( ) NEW_LINE n , k = int ( f [ 0 ] ) , int ( f [ 1 ] ) NEW_LINE s = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] NEW_LINE var = [ LpVariable ( \" x _ % d \" % i , cat = ' Integer ' ) for i in range ( k - 1 ) ] NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT var . append ( s [ i ] - sum ( var [ - ( j + 1 ) ] for j in range ( k - 1 ) ) ) NEW_LINE DEDENT prob = LpProblem ( \" myProblem \" , LpMinimize ) NEW_LINE x_max = LpVariable ( \" x _ max \" ) NEW_LINE x_min = LpVariable ( \" x _ min \" ) NEW_LINE res = x_max - x_min NEW_LINE for i in range ( n ) : NEW_LINE INDENT prob += x_max >= var [ i ] NEW_LINE prob += x_min <= var [ i ] NEW_LINE DEDENT prob += res NEW_LINE status = prob . solve ( ) NEW_LINE if status != 1 : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE \" % ( t + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( t + 1 , value ( res ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "import math NEW_LINE import re NEW_LINE def solve ( n , k , sums ) : NEW_LINE INDENT a = [ 0 ] * ( n - k ) NEW_LINE r = [ 0 ] * k NEW_LINE q = [ 0 ] * k NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT a [ i - 1 ] = sums [ i - 1 ] - sums [ i ] NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT b = [ a [ i + k * x ] for x in range ( ( n - 1 - i ) / k ) ] NEW_LINE for c in range ( 1 , len ( b ) ) : NEW_LINE INDENT b [ c ] = b [ c - 1 ] + b [ c ] NEW_LINE DEDENT b . append ( 0 ) NEW_LINE d = abs ( max ( b ) - min ( b ) ) NEW_LINE r [ i ] = d NEW_LINE q [ i ] = max ( b ) NEW_LINE DEDENT m = max ( r ) NEW_LINE rem = ( sums [ 0 ] - sum ( q ) ) % k NEW_LINE n = m * k - sum ( r ) NEW_LINE if n >= rem : NEW_LINE INDENT return m NEW_LINE DEDENT else : NEW_LINE INDENT return m + 1 NEW_LINE DEDENT DEDENT inp = open ( \" B - large . in \" , \" r \" ) NEW_LINE out = open ( \" B - large \" , \" w \" ) NEW_LINE lines = inp . readlines ( ) NEW_LINE i = 1 NEW_LINE count = 1 NEW_LINE while i < len ( lines ) : NEW_LINE INDENT [ n , k ] = [ int ( x ) for x in re . split ( \" \u2581 \" , lines [ i ] ) ] NEW_LINE B = [ int ( x ) for x in re . split ( \" \u2581 \" , lines [ i + 1 ] ) ] NEW_LINE out . write ( \" Case \u2581 # \" + str ( count ) + \" : \u2581 \" + \" { : } \" . format ( solve ( n , k , B ) ) + \" \\n \" ) NEW_LINE i += 2 NEW_LINE count += 1 NEW_LINE DEDENT out . close ( ) NEW_LINE inp . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( n , k , sums ) : NEW_LINE INDENT a = [ 0 ] * ( n - k ) NEW_LINE r = [ 0 ] * k NEW_LINE q = [ 0 ] * k NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT a [ i - 1 ] = sums [ i - 1 ] - sums [ i ] NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT b = [ a [ i + k * x ] for x in range ( ( n - 1 - i ) / k ) ] NEW_LINE for c in range ( 1 , len ( b ) ) : NEW_LINE INDENT b [ c ] = b [ c - 1 ] + b [ c ] NEW_LINE DEDENT b . append ( 0 ) NEW_LINE d = abs ( max ( b ) - min ( b ) ) NEW_LINE r [ i ] = d NEW_LINE q [ i ] = max ( b ) NEW_LINE DEDENT m = max ( r ) NEW_LINE rem = ( sums [ 0 ] - sum ( q ) ) % k NEW_LINE n = m * k - sum ( r ) NEW_LINE if n >= rem : NEW_LINE INDENT return m NEW_LINE DEDENT else : NEW_LINE INDENT return m + 1 NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_23", "java": [{"id": "3", "code": "import java . util . * ; public class c { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int T = input . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { System . out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; int n = input . nextInt ( ) ; PriorityQueue < Double > finish = new PriorityQueue < Double > ( ) ; PriorityQueue < Hiker > lap = new PriorityQueue < Hiker > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = input . nextInt ( ) ; int h = input . nextInt ( ) ; int m = input . nextInt ( ) ; for ( int j = 0 ; j < h ; j ++ ) { int time = m + j ; double ft = time * ( 360.0 - d ) / 360 ; finish . add ( ft ) ; lap . add ( new Hiker ( ft + time , time ) ) ; } } int size = lap . size ( ) ; int res = size , count = size ; while ( ! finish . isEmpty ( ) ) { while ( count < 2 * size && lap . peek ( ) . time <= finish . peek ( ) ) { Hiker h = lap . poll ( ) ; count ++ ; h . time += h . add ; lap . add ( h ) ; } if ( count == 2 * size ) break ; count -- ; res = Math . min ( res , count ) ; double x = finish . poll ( ) ; } System . out . println ( res ) ; } } static class Hiker implements Comparable < Hiker > { double time ; double add ; public Hiker ( double tt , double aa ) { time = tt ; add = aa ; } @ Override public int compareTo ( Hiker o ) { return Double . compare ( time , o . time ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int T = input . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { System . out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; int n = input . nextInt ( ) ; PriorityQueue < Double > finish = new PriorityQueue < Double > ( ) ; PriorityQueue < Hiker > lap = new PriorityQueue < Hiker > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = input . nextInt ( ) ; int h = input . nextInt ( ) ; int m = input . nextInt ( ) ; for ( int j = 0 ; j < h ; j ++ ) { int time = m + j ; double ft = time * ( 360.0 - d ) / 360 ; finish . add ( ft ) ; lap . add ( new Hiker ( ft + time , time ) ) ; } } int size = lap . size ( ) ; int res = size , count = size ; while ( ! finish . isEmpty ( ) ) { while ( count < 2 * size && lap . peek ( ) . time <= finish . peek ( ) ) { Hiker h = lap . poll ( ) ; count ++ ; h . time += h . add ; lap . add ( h ) ; } if ( count == 2 * size ) break ; count -- ; res = Math . min ( res , count ) ; double x = finish . poll ( ) ; } System . out . println ( res ) ; } }"]], "functions_class": [["Hiker", "public Hiker ( double tt , double aa ) { time = tt ; add = aa ; }"], ["compareTo", "public int compareTo ( Hiker o ) { return Double . compare ( time , o . time ) ; }"]]}, {"id": "2", "code": "import java . util . * ; import java . io . * ; public class C { public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; PriorityQueue < Hiker > hikers = new PriorityQueue < Hiker > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int D = input . nextInt ( ) ; int H = input . nextInt ( ) ; int M = input . nextInt ( ) ; for ( int j = 0 ; j < H ; j ++ ) hikers . add ( new Hiker ( D , M + j ) ) ; } long minEncounters = Long . MAX_VALUE ; int numHikers = hikers . size ( ) ; int numEncounters = 0 ; int numPassed = 0 ; for ( int i = 0 ; i < 3 * numHikers ; i ++ ) { Hiker next = hikers . poll ( ) ; if ( next . passed ) numEncounters ++ ; else numPassed ++ ; next . passed = true ; next . cross += 360L * next . M ; hikers . add ( next ) ; if ( numEncounters + numHikers - numPassed < minEncounters ) minEncounters = numEncounters + numHikers - numPassed ; } System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( minEncounters ) ; } } static class Hiker implements Comparable < Hiker > { int D ; int M ; long cross ; boolean passed ; Hiker ( int D , int M ) { this . D = D ; this . M = M ; this . cross = ( 360L - D ) * M ; this . passed = false ; } public int compareTo ( Hiker other ) { if ( cross > other . cross ) return 1 ; else if ( cross < other . cross ) return - 1 ; else if ( passed && ! other . passed ) return - 1 ; else if ( ! passed && other . passed ) return 1 ; return 0 ; } } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; PriorityQueue < Hiker > hikers = new PriorityQueue < Hiker > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int D = input . nextInt ( ) ; int H = input . nextInt ( ) ; int M = input . nextInt ( ) ; for ( int j = 0 ; j < H ; j ++ ) hikers . add ( new Hiker ( D , M + j ) ) ; } long minEncounters = Long . MAX_VALUE ; int numHikers = hikers . size ( ) ; int numEncounters = 0 ; int numPassed = 0 ; for ( int i = 0 ; i < 3 * numHikers ; i ++ ) { Hiker next = hikers . poll ( ) ; if ( next . passed ) numEncounters ++ ; else numPassed ++ ; next . passed = true ; next . cross += 360L * next . M ; hikers . add ( next ) ; if ( numEncounters + numHikers - numPassed < minEncounters ) minEncounters = numEncounters + numHikers - numPassed ; } System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; System . out . println ( minEncounters ) ; } }"]], "functions_class": [["Hiker", "Hiker ( int D , int M ) { this . D = D ; this . M = M ; this . cross = ( 360L - D ) * M ; this . passed = false ; }"], ["compareTo", "public int compareTo ( Hiker other ) { if ( cross > other . cross ) return 1 ; else if ( cross < other . cross ) return - 1 ; else if ( passed && ! other . passed ) return - 1 ; else if ( ! passed && other . passed ) return 1 ; return 0 ; }"]]}, {"id": "7", "code": "import java . util . * ; public class C { private class Hiker implements Comparable < Hiker > { long nextCompletion ; long timeForLap ; int lap ; Hiker ( long nextCompletion , long timeForLap , int lap ) { this . nextCompletion = nextCompletion ; this . timeForLap = timeForLap ; this . lap = lap ; } @ Override public int compareTo ( Hiker that ) { if ( this . nextCompletion < that . nextCompletion ) { return - 1 ; } else if ( this . nextCompletion > that . nextCompletion ) { return 1 ; } else { return that . lap - this . lap ; } } } String solve ( Scanner sc ) { PriorityQueue < Hiker > pq = new PriorityQueue < Hiker > ( ) ; int N = sc . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int D = sc . nextInt ( ) ; int H = sc . nextInt ( ) ; long M = sc . nextLong ( ) ; for ( int j = 0 ; j < H ; j ++ ) { long timeForLap = M + j ; pq . add ( new Hiker ( ( 360 - D ) * timeForLap , timeForLap , 0 ) ) ; } } int s = pq . size ( ) ; int limit = s * 2 ; int min = s ; for ( int i = 0 ; i < 10 * limit ; i ++ ) { Hiker h = pq . poll ( ) ; if ( h . lap == 0 ) { s -- ; } else { s ++ ; } min = Math . min ( min , s ) ; pq . add ( new Hiker ( h . nextCompletion + 360 * h . timeForLap , h . timeForLap , h . lap + 1 ) ) ; } return \" \" + min ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= T ; cs ++ ) { String res = new C ( ) . solve ( sc ) ; System . out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + res ) ; } sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= T ; cs ++ ) { String res = new C ( ) . solve ( sc ) ; System . out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + res ) ; } sc . close ( ) ; }"]], "functions_class": [["Hiker", "Hiker ( long nextCompletion , long timeForLap , int lap ) { this . nextCompletion = nextCompletion ; this . timeForLap = timeForLap ; this . lap = lap ; }"], ["compareTo", "public int compareTo ( Hiker that ) { if ( this . nextCompletion < that . nextCompletion ) { return - 1 ; } else if ( this . nextCompletion > that . nextCompletion ) { return 1 ; } else { return that . lap - this . lap ; } }"], ["solve", "String solve ( Scanner sc ) { PriorityQueue < Hiker > pq = new PriorityQueue < Hiker > ( ) ; int N = sc . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int D = sc . nextInt ( ) ; int H = sc . nextInt ( ) ; long M = sc . nextLong ( ) ; for ( int j = 0 ; j < H ; j ++ ) { long timeForLap = M + j ; pq . add ( new Hiker ( ( 360 - D ) * timeForLap , timeForLap , 0 ) ) ; } } int s = pq . size ( ) ; int limit = s * 2 ; int min = s ; for ( int i = 0 ; i < 10 * limit ; i ++ ) { Hiker h = pq . poll ( ) ; if ( h . lap == 0 ) { s -- ; } else { s ++ ; } min = Math . min ( min , s ) ; pq . add ( new Hiker ( h . nextCompletion + 360 * h . timeForLap , h . timeForLap , h . lap + 1 ) ) ; } return \" \" + min ; }"]]}, {"id": "6", "code": "import java . util . * ; public class Herb { static int val ( ) { int groups = sc . nextInt ( ) ; long [ ] start = new long [ groups ] ; long [ ] size = new long [ groups ] ; long [ ] period = new long [ groups ] ; int total = 0 ; for ( int i = 0 ; i < groups ; i ++ ) { start [ i ] = sc . nextInt ( ) ; size [ i ] = sc . nextInt ( ) ; total += size [ i ] ; period [ i ] = sc . nextInt ( ) ; } long [ ] first = new long [ total ] ; long [ ] diff = new long [ total ] ; { int j = 0 ; for ( int i = 0 ; i < groups ; i ++ ) { for ( int k = 0 ; k < size [ i ] ; k ++ ) { first [ j ] = ( period [ i ] + k ) * 2 * ( 360 - start [ i ] ) ; diff [ j ] = 2 * 360 * period [ i ] ; j ++ ; } } } long opt = total + 1 ; for ( int i = 0 ; i < total ; i ++ ) { long crossings = 0 ; for ( int j = 0 ; j < total ; j ++ ) { if ( first [ i ] + 1 <= first [ j ] ) crossings += 1 ; else if ( first [ i ] + 1 <= first [ j ] + diff [ j ] ) crossings += 0 ; else crossings += ( first [ i ] + 1 - first [ j ] ) / diff [ j ] ; } opt = Math . min ( opt , crossings ) ; } return ( int ) opt ; } static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int k = sc . nextInt ( ) ; for ( int kk = 1 ; kk <= k ; kk ++ ) System . out . println ( \" Case \u2581 # \" + kk + \" : \u2581 \" + val ( ) ) ; } }", "functions_standalone": [["val", "static int val ( ) { int groups = sc . nextInt ( ) ; long [ ] start = new long [ groups ] ; long [ ] size = new long [ groups ] ; long [ ] period = new long [ groups ] ; int total = 0 ; for ( int i = 0 ; i < groups ; i ++ ) { start [ i ] = sc . nextInt ( ) ; size [ i ] = sc . nextInt ( ) ; total += size [ i ] ; period [ i ] = sc . nextInt ( ) ; } long [ ] first = new long [ total ] ; long [ ] diff = new long [ total ] ; { int j = 0 ; for ( int i = 0 ; i < groups ; i ++ ) { for ( int k = 0 ; k < size [ i ] ; k ++ ) { first [ j ] = ( period [ i ] + k ) * 2 * ( 360 - start [ i ] ) ; diff [ j ] = 2 * 360 * period [ i ] ; j ++ ; } } } long opt = total + 1 ; for ( int i = 0 ; i < total ; i ++ ) { long crossings = 0 ; for ( int j = 0 ; j < total ; j ++ ) { if ( first [ i ] + 1 <= first [ j ] ) crossings += 1 ; else if ( first [ i ] + 1 <= first [ j ] + diff [ j ] ) crossings += 0 ; else crossings += ( first [ i ] + 1 - first [ j ] ) / diff [ j ] ; } opt = Math . min ( opt , crossings ) ; } return ( int ) opt ; }"], ["main", "public static void main ( String [ ] args ) { int k = sc . nextInt ( ) ; for ( int kk = 1 ; kk <= k ; kk ++ ) System . out . println ( \" Case \u2581 # \" + kk + \" : \u2581 \" + val ( ) ) ; }"]], "functions_class": []}, {"id": "16", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Locale ; import java . util . Scanner ; public class C { private static final int MAXH = 10 ; static void solve ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int hn = 0 ; long [ ] start = new long [ MAXH ] ; long [ ] min = new long [ MAXH ] ; long [ ] t = new long [ MAXH ] ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = in . nextInt ( ) ; int h = in . nextInt ( ) ; int m = in . nextInt ( ) ; for ( int j = 0 ; j < h ; j ++ ) { start [ hn ] = d ; min [ hn ] = m + j ; t [ hn ] = min [ hn ] * ( 360 - start [ hn ] ) ; hn ++ ; } } long r = hn ; for ( int i = 0 ; i < hn ; i ++ ) { long rr = hn ; for ( int j = 0 ; j < hn ; j ++ ) { if ( t [ j ] <= t [ i ] ) { rr -- ; rr += ( t [ i ] - t [ j ] ) / ( 360 * min [ j ] ) ; } } r = Math . min ( r , rr ) ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r ) ; } } static Scanner in ; static PrintWriter out ; public static void main ( String [ ] args ) throws FileNotFoundException { Locale . setDefault ( Locale . US ) ; in = new Scanner ( new File ( \" C : \\\\ programming \\\\ contests \\\\ GCJ \\\\ GCJ _ 2015 \\\\ 2015.05.02 _ Round _ 1B \\\\ in \" ) ) ; out = new PrintWriter ( new File ( \" C : \\\\ programming \\\\ contests \\\\ GCJ \\\\ GCJ _ 2015 \\\\ 2015.05.02 _ Round _ 1B \\\\ out \" ) ) ; solve ( ) ; out . close ( ) ; } }", "functions_standalone": [["solve", "static void solve ( ) { int tn = in . nextInt ( ) ; for ( int test = 1 ; test <= tn ; test ++ ) { int hn = 0 ; long [ ] start = new long [ MAXH ] ; long [ ] min = new long [ MAXH ] ; long [ ] t = new long [ MAXH ] ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = in . nextInt ( ) ; int h = in . nextInt ( ) ; int m = in . nextInt ( ) ; for ( int j = 0 ; j < h ; j ++ ) { start [ hn ] = d ; min [ hn ] = m + j ; t [ hn ] = min [ hn ] * ( 360 - start [ hn ] ) ; hn ++ ; } } long r = hn ; for ( int i = 0 ; i < hn ; i ++ ) { long rr = hn ; for ( int j = 0 ; j < hn ; j ++ ) { if ( t [ j ] <= t [ i ] ) { rr -- ; rr += ( t [ i ] - t [ j ] ) / ( 360 * min [ j ] ) ; } } r = Math . min ( r , rr ) ; } out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + r ) ; } }"], ["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Locale . setDefault ( Locale . US ) ; in = new Scanner ( new File ( \" C : \\\\ programming \\\\ contests \\\\ GCJ \\\\ GCJ _ 2015 \\\\ 2015.05.02 _ Round _ 1B \\\\ in \" ) ) ; out = new PrintWriter ( new File ( \" C : \\\\ programming \\\\ contests \\\\ GCJ \\\\ GCJ _ 2015 \\\\ 2015.05.02 _ Round _ 1B \\\\ out \" ) ) ; solve ( ) ; out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "6", "code": "from fractions import Fraction NEW_LINE T = int ( input ( ) ) NEW_LINE for test in range ( 1 , T + 1 ) : NEW_LINE INDENT people = [ ] NEW_LINE G = int ( input ( ) ) NEW_LINE for g in range ( G ) : NEW_LINE INDENT di , hi , mi = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for h in range ( hi ) : NEW_LINE INDENT people . append ( ( di , mi + h ) ) NEW_LINE DEDENT DEDENT assert len ( people ) <= 2 NEW_LINE d0 , m0 = people [ 0 ] NEW_LINE d1 , m1 = people [ 1 ] NEW_LINE t0 = Fraction ( ( 360 - d0 ) * m0 , 360 ) NEW_LINE t1 = Fraction ( ( 360 - d1 ) * m1 , 360 ) NEW_LINE t = max ( t0 , t1 ) NEW_LINE prejde0 = t * 360 / m0 NEW_LINE prejde1 = t * 360 / m1 NEW_LINE if ( prejde0 >= 720 - d0 ) or ( prejde1 >= 720 - d1 ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( test , 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( test , 0 ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE import heapq NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( fin . readline ( ) ) NEW_LINE heap = [ ] NEW_LINE hikers = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT d , h , m = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE for p in range ( m , m + h ) : NEW_LINE INDENT t = p * ( 360 - d ) / 360.0 NEW_LINE heapq . heappush ( heap , ( t , 1 , p ) ) NEW_LINE hikers += 1 NEW_LINE DEDENT DEDENT current = hikers NEW_LINE least = current NEW_LINE while current <= hikers * 2 : NEW_LINE INDENT token = heapq . heappop ( heap ) NEW_LINE t , d , p = token NEW_LINE current -= d NEW_LINE least = min ( current , least ) NEW_LINE heapq . heappush ( heap , ( t + p , - 1 , p ) ) NEW_LINE DEDENT result = least NEW_LINE debug ( \" Case \u2581 % d \" % case ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , result ) ) NEW_LINE DEDENT", "functions_standalone": [["debug", "def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "0", "code": "import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case \u2581 # { : d } : \u2581 { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 arguments , \u2581 not \u2581 { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["readline", "def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT"], ["readint", "def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readfloat", "def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT"], ["readints", "def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["readfloats", "def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["writeline", "def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT"], ["writecase", "def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case \u2581 # { : d } : \u2581 { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT"], ["run", "def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 arguments , \u2581 not \u2581 { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "4", "code": "from sys import stdin , stdout , stderr NEW_LINE import heapq NEW_LINE def solve ( N , hikers ) : NEW_LINE INDENT N = len ( hikers ) NEW_LINE D = [ h [ 0 ] for h in hikers ] NEW_LINE M = [ h [ 1 ] for h in hikers ] NEW_LINE intersects = [ ( ( 360 - D [ i ] ) * M [ i ] , M [ i ] , i ) for i in range ( N ) ] NEW_LINE heapq . heapify ( intersects ) NEW_LINE best = N NEW_LINE current = best NEW_LINE seen = set ( ) NEW_LINE while current <= 2 * N : NEW_LINE INDENT ( m , M , i ) = heapq . heappop ( intersects ) NEW_LINE if i not in seen : NEW_LINE INDENT current -= 1 NEW_LINE best = min ( best , current ) NEW_LINE seen . add ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT current += 1 NEW_LINE DEDENT heapq . heappush ( intersects , ( m + M * 360 , M , i ) ) NEW_LINE DEDENT return best NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE hikers = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT D , H , M = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( H ) : NEW_LINE INDENT hikers . append ( ( D , M + j ) ) NEW_LINE DEDENT DEDENT answer = solve ( N , hikers ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , answer ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( N , hikers ) : NEW_LINE INDENT N = len ( hikers ) NEW_LINE D = [ h [ 0 ] for h in hikers ] NEW_LINE M = [ h [ 1 ] for h in hikers ] NEW_LINE intersects = [ ( ( 360 - D [ i ] ) * M [ i ] , M [ i ] , i ) for i in range ( N ) ] NEW_LINE heapq . heapify ( intersects ) NEW_LINE best = N NEW_LINE current = best NEW_LINE seen = set ( ) NEW_LINE while current <= 2 * N : NEW_LINE INDENT ( m , M , i ) = heapq . heappop ( intersects ) NEW_LINE if i not in seen : NEW_LINE INDENT current -= 1 NEW_LINE best = min ( best , current ) NEW_LINE seen . add ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT current += 1 NEW_LINE DEDENT heapq . heappush ( intersects , ( m + M * 360 , M , i ) ) NEW_LINE DEDENT return best NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE hikers = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT D , H , M = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( H ) : NEW_LINE INDENT hikers . append ( ( D , M + j ) ) NEW_LINE DEDENT DEDENT answer = solve ( N , hikers ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , answer ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "7", "code": "from fractions import Fraction NEW_LINE import math NEW_LINE with open ( \" C - small - 1 - attempt0 . in \" ) as infile : NEW_LINE INDENT with open ( \" C . out \" , \" w \" ) as outfile : NEW_LINE INDENT ncases = int ( next ( infile ) ) NEW_LINE for case in range ( 1 , ncases + 1 ) : NEW_LINE INDENT nlines = int ( next ( infile ) ) NEW_LINE hikers = [ ] NEW_LINE for L in range ( nlines ) : NEW_LINE INDENT D , H , M = map ( int , next ( infile ) . split ( ) ) NEW_LINE for i in range ( H ) : NEW_LINE INDENT hikers . append ( ( D , M + i ) ) NEW_LINE DEDENT DEDENT hikers . sort ( ) NEW_LINE time1 = ( Fraction ( hikers [ 0 ] [ 1 ] ) * ( 360 - hikers [ 0 ] [ 0 ] ) ) / 360 NEW_LINE laps2 = time1 * 1 / Fraction ( hikers [ 1 ] [ 1 ] ) + Fraction ( hikers [ 1 ] [ 0 ] ) / 360 NEW_LINE time2 = ( Fraction ( hikers [ 1 ] [ 1 ] ) * ( 360 - hikers [ 1 ] [ 0 ] ) ) / 360 NEW_LINE laps1 = time2 * 1 / Fraction ( hikers [ 0 ] [ 1 ] ) + Fraction ( hikers [ 0 ] [ 0 ] ) / 360 NEW_LINE if laps2 <= 1 : NEW_LINE INDENT sol1 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sol1 = int ( laps2 - 1 ) NEW_LINE DEDENT if laps1 <= 1 : NEW_LINE INDENT sol2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sol2 = int ( laps1 - 1 ) NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , min ( sol1 , sol2 ) ) , file = outfile ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_15_12", "java": [{"id": "5", "code": "import java . util . * ; import static java . lang . Math . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int B = in . nextInt ( ) ; long N = in . nextInt ( ) ; long [ ] M = new long [ B ] ; for ( int i = 0 ; i < B ; i ++ ) M [ i ] = in . nextInt ( ) ; long start = 0 ; long end = ( long ) 1e16 ; while ( start < end ) { long mid = ( start + end ) / 2 ; long count = 0 ; for ( long t : M ) { count += ( mid / t ) + 1 ; } if ( count >= N ) { end = mid ; } else { start = mid + 1 ; } } long count = 0 ; long exact = 0 ; for ( long t : M ) { count += ( start / t ) + 1 ; if ( start % t == 0 ) exact ++ ; } long before = count - exact ; int ans = - 1 ; for ( int i = 0 ; i < B ; i ++ ) { if ( start % M [ i ] != 0 ) continue ; if ( before + 1 == N ) { ans = i ; break ; } before ++ ; } System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans + 1 ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int B = in . nextInt ( ) ; long N = in . nextInt ( ) ; long [ ] M = new long [ B ] ; for ( int i = 0 ; i < B ; i ++ ) M [ i ] = in . nextInt ( ) ; long start = 0 ; long end = ( long ) 1e16 ; while ( start < end ) { long mid = ( start + end ) / 2 ; long count = 0 ; for ( long t : M ) { count += ( mid / t ) + 1 ; } if ( count >= N ) { end = mid ; } else { start = mid + 1 ; } } long count = 0 ; long exact = 0 ; for ( long t : M ) { count += ( start / t ) + 1 ; if ( start % t == 0 ) exact ++ ; } long before = count - exact ; int ans = - 1 ; for ( int i = 0 ; i < B ; i ++ ) { if ( start % M [ i ] != 0 ) continue ; if ( before + 1 == N ) { ans = i ; break ; } before ++ ; } System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans + 1 ) ; } }"]], "functions_class": []}, {"id": "18", "code": "package gcj2015 . r1 ; import java . io . * ; import java . util . Scanner ; public class Haircut { static PrintWriter out ; public static void main ( String [ ] args ) throws IOException { String name = \" gcj2015 / r1 / B - large \" ; Scanner s = new Scanner ( new File ( name + \" . in \" ) ) ; int count = s . nextInt ( ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( name + \" . out \" ) ) ) ; for ( int cc = 1 ; cc <= count ; cc ++ ) { out . print ( \" Case \u2581 # \" + cc + \" : \u2581 \" ) ; int b = s . nextInt ( ) ; int n = s . nextInt ( ) ; int [ ] m = new int [ b ] ; for ( int i = 0 ; i < b ; i ++ ) { m [ i ] = s . nextInt ( ) ; } int res = solve ( b , n , m ) ; out . print ( res ) ; out . println ( ) ; } out . close ( ) ; } static int solve ( int b , int n , int [ ] m ) { long l = 0 ; long r = 100000l * n + 1 ; long mid ; while ( true ) { mid = ( l + r ) / 2 ; long num = num ( b , m , mid ) ; if ( num < n ) { l = mid ; } else { r = mid ; } if ( r - mid == 1 ) break ; } int rem = n - ( int ) num ( b , m , mid ) ; for ( int i = 0 ; i < b ; i ++ ) { if ( mid % m [ i ] == 0 ) { rem -- ; } if ( rem == 0 ) return i + 1 ; } return - 1 ; } static long num ( int b , int [ ] m , long t ) { long res = 0 ; for ( int mm : m ) { res += ( t + mm - 1 ) / mm ; } return res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { String name = \" gcj2015 / r1 / B - large \" ; Scanner s = new Scanner ( new File ( name + \" . in \" ) ) ; int count = s . nextInt ( ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( name + \" . out \" ) ) ) ; for ( int cc = 1 ; cc <= count ; cc ++ ) { out . print ( \" Case \u2581 # \" + cc + \" : \u2581 \" ) ; int b = s . nextInt ( ) ; int n = s . nextInt ( ) ; int [ ] m = new int [ b ] ; for ( int i = 0 ; i < b ; i ++ ) { m [ i ] = s . nextInt ( ) ; } int res = solve ( b , n , m ) ; out . print ( res ) ; out . println ( ) ; } out . close ( ) ; }"], ["solve", "static int solve ( int b , int n , int [ ] m ) { long l = 0 ; long r = 100000l * n + 1 ; long mid ; while ( true ) { mid = ( l + r ) / 2 ; long num = num ( b , m , mid ) ; if ( num < n ) { l = mid ; } else { r = mid ; } if ( r - mid == 1 ) break ; } int rem = n - ( int ) num ( b , m , mid ) ; for ( int i = 0 ; i < b ; i ++ ) { if ( mid % m [ i ] == 0 ) { rem -- ; } if ( rem == 0 ) return i + 1 ; } return - 1 ; }"], ["num", "static long num ( int b , int [ ] m , long t ) { long res = 0 ; for ( int mm : m ) { res += ( t + mm - 1 ) / mm ; } return res ; }"]], "functions_class": []}, {"id": "2", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class Haircut { final static String PROBLEM_NAME = \" haircut \" ; final static String WORK_DIR = \" D : \\\\ GCJ \\ \\\" + PROBLEM_NAME + \" \\ \\\" ; void solve ( Scanner sc , PrintWriter pw ) { int B = sc . nextInt ( ) ; long N = sc . nextLong ( ) ; int [ ] T = new int [ B ] ; for ( int i = 0 ; i < B ; i ++ ) { T [ i ] = sc . nextInt ( ) ; } long L = 0 , R = 1000000000000000L ; while ( R - L > 1 ) { long mid = ( L + R ) / 2 ; long servedBefore = 0 ; for ( int i = 0 ; i < B ; i ++ ) { servedBefore += ( mid - 1 ) / T [ i ] + 1 ; } if ( servedBefore < N ) { L = mid ; } else { R = mid ; } } long when = L ; for ( int i = 0 ; i < B ; i ++ ) { N -= ( when - 1 ) / T [ i ] + 1 ; } for ( int i = 0 ; i < B ; i ++ ) { if ( when % T [ i ] == 0 ) { N -- ; if ( N == 0 ) { pw . println ( i + 1 ) ; return ; } } } } public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new Haircut ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new Haircut ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["solve", "void solve ( Scanner sc , PrintWriter pw ) { int B = sc . nextInt ( ) ; long N = sc . nextLong ( ) ; int [ ] T = new int [ B ] ; for ( int i = 0 ; i < B ; i ++ ) { T [ i ] = sc . nextInt ( ) ; } long L = 0 , R = 1000000000000000L ; while ( R - L > 1 ) { long mid = ( L + R ) / 2 ; long servedBefore = 0 ; for ( int i = 0 ; i < B ; i ++ ) { servedBefore += ( mid - 1 ) / T [ i ] + 1 ; } if ( servedBefore < N ) { L = mid ; } else { R = mid ; } } long when = L ; for ( int i = 0 ; i < B ; i ++ ) { N -= ( when - 1 ) / T [ i ] + 1 ; } for ( int i = 0 ; i < B ; i ++ ) { if ( when % T [ i ] == 0 ) { N -- ; if ( N == 0 ) { pw . println ( i + 1 ) ; return ; } } } }"]]}, {"id": "14", "code": "import java . util . Scanner ; public class B { static int B ; static long N ; static long [ ] M ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { B = sc . nextInt ( ) ; N = sc . nextLong ( ) ; M = new long [ B + 1 ] ; for ( int i = 1 ; i <= B ; i ++ ) { M [ i ] = sc . nextLong ( ) ; } System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + solve ( ) ) ; } } static long solve ( ) { if ( N <= B ) { return N ; } long time = getHaircutTime ( ) ; long customers = numCustomers ( time ) ; for ( int i = B ; i > 0 ; i -- ) { if ( time % M [ i ] == 0 ) { if ( customers == N ) { return i ; } customers -- ; } } throw new IllegalStateException ( ) ; } static long getHaircutTime ( ) { long min = 0 ; long max = 100_000_000_000_000L ; while ( min < max ) { long mid = ( min + max ) / 2 ; long customers = numCustomers ( mid ) ; if ( customers < N ) { min = mid + 1 ; } else { max = mid ; } } return min ; } private static long numCustomers ( long time ) { long customers = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { customers += 1 + ( time / M [ i ] ) ; } return customers ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numCases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; caseNum ++ ) { B = sc . nextInt ( ) ; N = sc . nextLong ( ) ; M = new long [ B + 1 ] ; for ( int i = 1 ; i <= B ; i ++ ) { M [ i ] = sc . nextLong ( ) ; } System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + solve ( ) ) ; } }"], ["solve", "static long solve ( ) { if ( N <= B ) { return N ; } long time = getHaircutTime ( ) ; long customers = numCustomers ( time ) ; for ( int i = B ; i > 0 ; i -- ) { if ( time % M [ i ] == 0 ) { if ( customers == N ) { return i ; } customers -- ; } } throw new IllegalStateException ( ) ; }"], ["getHaircutTime", "static long getHaircutTime ( ) { long min = 0 ; long max = 100_000_000_000_000L ; while ( min < max ) { long mid = ( min + max ) / 2 ; long customers = numCustomers ( mid ) ; if ( customers < N ) { min = mid + 1 ; } else { max = mid ; } } return min ; }"], ["numCustomers", "private static long numCustomers ( long time ) { long customers = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { customers += 1 + ( time / M [ i ] ) ; } return customers ; }"]], "functions_class": []}, {"id": "13", "code": "package round1a ; import java . util . Scanner ; public class B { private static long [ ] times ; private static long B , N ; private static long started ( long t ) { long ret = 0 ; for ( int i = 0 ; i < times . length ; i ++ ) { ret += 1 + t / times [ i ] ; } return ret ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { B = sc . nextInt ( ) ; N = sc . nextInt ( ) ; times = new long [ ( int ) B ] ; for ( int i = 0 ; i < times . length ; i ++ ) { times [ i ] = sc . nextInt ( ) ; } long ret = - 1 ; if ( B >= N ) { ret = N ; } if ( ret == - 1 ) { long left = 0 , right = N * 1000000 ; while ( left + 1 < right ) { long med = ( left + right ) / 2 ; if ( started ( med ) < N ) { left = med ; } else { right = med ; } } long dif = N - started ( left ) ; for ( int i = 0 ; i < times . length ; i ++ ) { if ( right % times [ i ] == 0 ) dif -- ; if ( dif == 0 ) { ret = i + 1 ; break ; } } } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ret ) ; } } }", "functions_standalone": [["started", "private static long started ( long t ) { long ret = 0 ; for ( int i = 0 ; i < times . length ; i ++ ) { ret += 1 + t / times [ i ] ; } return ret ; }"], ["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { B = sc . nextInt ( ) ; N = sc . nextInt ( ) ; times = new long [ ( int ) B ] ; for ( int i = 0 ; i < times . length ; i ++ ) { times [ i ] = sc . nextInt ( ) ; } long ret = - 1 ; if ( B >= N ) { ret = N ; } if ( ret == - 1 ) { long left = 0 , right = N * 1000000 ; while ( left + 1 < right ) { long med = ( left + right ) / 2 ; if ( started ( med ) < N ) { left = med ; } else { right = med ; } } long dif = N - started ( left ) ; for ( int i = 0 ; i < times . length ; i ++ ) { if ( right % times [ i ] == 0 ) dif -- ; if ( dif == 0 ) { ret = i + 1 ; break ; } } } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ret ) ; } }"]], "functions_class": []}], "python": [{"id": "9", "code": "tc = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( tc ) : NEW_LINE INDENT b , n = tuple ( int ( x ) for x in input ( ) . strip ( ) . split ( ) ) NEW_LINE m = list ( int ( x ) for x in input ( ) . strip ( ) . split ( ) ) NEW_LINE l , r = - 1 , n * min ( m ) NEW_LINE lv = 0 NEW_LINE while l + 1 < r : NEW_LINE INDENT c = ( l + r ) // 2 NEW_LINE v = sum ( c // a + 1 for a in m ) NEW_LINE if v < n : NEW_LINE INDENT l = c NEW_LINE lv = v NEW_LINE DEDENT else : NEW_LINE INDENT r = c NEW_LINE DEDENT DEDENT idx = n - lv - 1 NEW_LINE ans = list ( i + 1 for i in range ( b ) if r % m [ i ] == 0 ) [ idx ] NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \" % ( t + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "def cal ( m , t ) : NEW_LINE INDENT return sum ( [ ( t + x - 1 ) // x for x in m ] ) NEW_LINE DEDENT def gao ( ) : NEW_LINE INDENT ( b , n ) = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = 0 NEW_LINE r = min ( m ) * n NEW_LINE ans = r NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE s = cal ( m , mid ) NEW_LINE if s >= n : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT ans = ans - 1 NEW_LINE cnt = n - cal ( m , ans ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT if ans % m [ i ] == 0 : NEW_LINE INDENT cnt -= 1 NEW_LINE if cnt == 0 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for cas in range ( t ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : ' % ( cas + 1 ) , end = ' \u2581 ' ) NEW_LINE print ( gao ( ) ) NEW_LINE DEDENT", "functions_standalone": [["cal", "def cal ( m , t ) : NEW_LINE INDENT return sum ( [ ( t + x - 1 ) // x for x in m ] ) NEW_LINE DEDENT"], ["gao", "def gao ( ) : NEW_LINE INDENT ( b , n ) = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = 0 NEW_LINE r = min ( m ) * n NEW_LINE ans = r NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE s = cal ( m , mid ) NEW_LINE if s >= n : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT ans = ans - 1 NEW_LINE cnt = n - cal ( m , ans ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT if ans % m [ i ] == 0 : NEW_LINE INDENT cnt -= 1 NEW_LINE if cnt == 0 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "import sys NEW_LINE sys . stdin = open ( ' a . in ' , ' r ' ) NEW_LINE sys . stdout = open ( ' a . out ' , ' w ' ) NEW_LINE def getline ( ) : NEW_LINE INDENT return [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE DEDENT def can ( t , b , B , N ) : NEW_LINE INDENT ans = 0 NEW_LINE flag = True NEW_LINE count = sum ( [ ( t + ( c - 1 ) ) // c for c in b ] ) NEW_LINE free = sum ( [ 1 for c in b if t % c == 0 ] ) NEW_LINE if count + free >= N : NEW_LINE INDENT flag = True NEW_LINE tmp = 0 NEW_LINE for j in range ( B ) : NEW_LINE INDENT if t % b [ j ] == 0 : NEW_LINE INDENT tmp += 1 NEW_LINE DEDENT if tmp == N - count : NEW_LINE INDENT return [ j + 1 , True ] NEW_LINE DEDENT DEDENT return [ 0 , True ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ 0 , False ] NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT [ B , N ] = getline ( ) NEW_LINE b = getline ( ) NEW_LINE l = 0 NEW_LINE r = 10000000000000000 NEW_LINE [ ans , flag ] = can ( l , b , B , N ) NEW_LINE if flag : return ans NEW_LINE while l + 1 < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE [ ans , flag ] = can ( m , b , B , N ) NEW_LINE if flag : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT [ ans , flag ] = can ( r , b , B , N ) NEW_LINE return ans NEW_LINE DEDENT for T in range ( int ( input ( ) ) ) : NEW_LINE INDENT sys . stderr . write ( str ( T ) ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % s ' % ( T + 1 , solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["getline", "def getline ( ) : NEW_LINE INDENT return [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE DEDENT"], ["can", "def can ( t , b , B , N ) : NEW_LINE INDENT ans = 0 NEW_LINE flag = True NEW_LINE count = sum ( [ ( t + ( c - 1 ) ) // c for c in b ] ) NEW_LINE free = sum ( [ 1 for c in b if t % c == 0 ] ) NEW_LINE if count + free >= N : NEW_LINE INDENT flag = True NEW_LINE tmp = 0 NEW_LINE for j in range ( B ) : NEW_LINE INDENT if t % b [ j ] == 0 : NEW_LINE INDENT tmp += 1 NEW_LINE DEDENT if tmp == N - count : NEW_LINE INDENT return [ j + 1 , True ] NEW_LINE DEDENT DEDENT return [ 0 , True ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ 0 , False ] NEW_LINE DEDENT DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT [ B , N ] = getline ( ) NEW_LINE b = getline ( ) NEW_LINE l = 0 NEW_LINE r = 10000000000000000 NEW_LINE [ ans , flag ] = can ( l , b , B , N ) NEW_LINE if flag : return ans NEW_LINE while l + 1 < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE [ ans , flag ] = can ( m , b , B , N ) NEW_LINE if flag : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT [ ans , flag ] = can ( r , b , B , N ) NEW_LINE return ans NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "from math import ceil NEW_LINE from fractions import Fraction NEW_LINE from heapq import heapify , heappop , heappushpop NEW_LINE T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT B , N = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE tmin = max ( N - B , 0 ) / sum ( Fraction ( 1 , i ) for i in m ) NEW_LINE N -= sum ( ceil ( tmin / m [ b ] ) for b in range ( B ) ) NEW_LINE h = [ ( ceil ( tmin / m [ b ] ) * m [ b ] , b ) for b in range ( B ) ] NEW_LINE heapify ( h ) NEW_LINE t , b = heappop ( h ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT t , b = heappushpop ( h , ( t + m [ b ] , b ) ) NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , b + 1 ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "import heapq NEW_LINE def ReadIn ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for c in range ( 1 , t + 1 ) : NEW_LINE INDENT m , n = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE yield c , n , a NEW_LINE DEDENT DEDENT def OK ( n , a , guess ) : NEW_LINE INDENT return sum ( [ guess // x + 1 for x in a ] ) >= n NEW_LINE DEDENT def Solve ( n , a ) : NEW_LINE INDENT if n <= len ( a ) : return n NEW_LINE lower = 0 NEW_LINE upper = max ( a ) * n NEW_LINE while lower < upper : NEW_LINE INDENT guess = ( lower + upper + 1 ) // 2 NEW_LINE if OK ( n , a , guess ) : upper = guess - 1 NEW_LINE else : lower = guess NEW_LINE DEDENT guess = lower NEW_LINE heap = [ ] NEW_LINE remain = n NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT num = guess // x + 1 NEW_LINE remain -= num NEW_LINE heapq . heappush ( heap , ( num * x - guess , i ) ) NEW_LINE DEDENT ret = heap [ 0 ] [ 1 ] NEW_LINE for r in range ( remain ) : NEW_LINE INDENT t , i = heapq . heappop ( heap ) NEW_LINE heapq . heappush ( heap , ( t + a [ i ] , i ) ) NEW_LINE ret = i NEW_LINE DEDENT return ret + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for c , n , a in ReadIn ( ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : \u2581 % d ' % ( c , Solve ( n , a ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["ReadIn", "def ReadIn ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for c in range ( 1 , t + 1 ) : NEW_LINE INDENT m , n = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE yield c , n , a NEW_LINE DEDENT DEDENT"], ["OK", "def OK ( n , a , guess ) : NEW_LINE INDENT return sum ( [ guess // x + 1 for x in a ] ) >= n NEW_LINE DEDENT"], ["Solve", "def Solve ( n , a ) : NEW_LINE INDENT if n <= len ( a ) : return n NEW_LINE lower = 0 NEW_LINE upper = max ( a ) * n NEW_LINE while lower < upper : NEW_LINE INDENT guess = ( lower + upper + 1 ) // 2 NEW_LINE if OK ( n , a , guess ) : upper = guess - 1 NEW_LINE else : lower = guess NEW_LINE DEDENT guess = lower NEW_LINE heap = [ ] NEW_LINE remain = n NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT num = guess // x + 1 NEW_LINE remain -= num NEW_LINE heapq . heappush ( heap , ( num * x - guess , i ) ) NEW_LINE DEDENT ret = heap [ 0 ] [ 1 ] NEW_LINE for r in range ( remain ) : NEW_LINE INDENT t , i = heapq . heappop ( heap ) NEW_LINE heapq . heappush ( heap , ( t + a [ i ] , i ) ) NEW_LINE ret = i NEW_LINE DEDENT return ret + 1 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_13", "java": [{"id": "12", "code": "import java . util . * ; import java . io . * ; public class C { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" C - large . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int x = 0 ; x < t ; x ++ ) { int n = in . nextInt ( ) ; int [ ] xs = new int [ n ] ; int [ ] ys = new int [ n ] ; for ( int y = 0 ; y < n ; y ++ ) { xs [ y ] = in . nextInt ( ) ; ys [ y ] = in . nextInt ( ) ; } out . println ( \" Case \u2581 # \" + ( x + 1 ) + \" : \" ) ; for ( int z = 0 ; z < xs . length ; z ++ ) { ArrayList < Double > angles = new ArrayList < Double > ( ) ; for ( int a = 0 ; a < xs . length ; a ++ ) { if ( a != z ) { double current = Math . atan2 ( ys [ a ] - ys [ z ] , xs [ a ] - xs [ z ] ) ; angles . add ( current ) ; angles . add ( current + 2.0 * Math . PI ) ; } } Collections . sort ( angles ) ; int index = 0 ; int result = n ; for ( int b = 0 ; b < n ; b ++ ) { while ( index < angles . size ( ) && angles . get ( index ) < angles . get ( b ) + Math . PI + 1E-12 ) { index ++ ; } result = Math . min ( result , n - ( index - b ) - 1 ) ; } if ( n == 1 ) { out . println ( 0 ) ; } else { out . println ( result ) ; } } } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" C - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" C - large . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int x = 0 ; x < t ; x ++ ) { int n = in . nextInt ( ) ; int [ ] xs = new int [ n ] ; int [ ] ys = new int [ n ] ; for ( int y = 0 ; y < n ; y ++ ) { xs [ y ] = in . nextInt ( ) ; ys [ y ] = in . nextInt ( ) ; } out . println ( \" Case \u2581 # \" + ( x + 1 ) + \" : \" ) ; for ( int z = 0 ; z < xs . length ; z ++ ) { ArrayList < Double > angles = new ArrayList < Double > ( ) ; for ( int a = 0 ; a < xs . length ; a ++ ) { if ( a != z ) { double current = Math . atan2 ( ys [ a ] - ys [ z ] , xs [ a ] - xs [ z ] ) ; angles . add ( current ) ; angles . add ( current + 2.0 * Math . PI ) ; } } Collections . sort ( angles ) ; int index = 0 ; int result = n ; for ( int b = 0 ; b < n ; b ++ ) { while ( index < angles . size ( ) && angles . get ( index ) < angles . get ( b ) + Math . PI + 1E-12 ) { index ++ ; } result = Math . min ( result , n - ( index - b ) - 1 ) ; } if ( n == 1 ) { out . println ( 0 ) ; } else { out . println ( result ) ; } } } out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "import heapq NEW_LINE def ReadIn ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for c in range ( 1 , t + 1 ) : NEW_LINE INDENT m , n = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE yield c , n , a NEW_LINE DEDENT DEDENT def OK ( n , a , guess ) : NEW_LINE INDENT return sum ( [ guess // x + 1 for x in a ] ) >= n NEW_LINE DEDENT def Solve ( n , a ) : NEW_LINE INDENT if n <= len ( a ) : return n NEW_LINE lower = 0 NEW_LINE upper = max ( a ) * n NEW_LINE while lower < upper : NEW_LINE INDENT guess = ( lower + upper + 1 ) // 2 NEW_LINE if OK ( n , a , guess ) : upper = guess - 1 NEW_LINE else : lower = guess NEW_LINE DEDENT guess = lower NEW_LINE heap = [ ] NEW_LINE remain = n NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT num = guess // x + 1 NEW_LINE remain -= num NEW_LINE heapq . heappush ( heap , ( num * x - guess , i ) ) NEW_LINE DEDENT ret = heap [ 0 ] [ 1 ] NEW_LINE for r in range ( remain ) : NEW_LINE INDENT t , i = heapq . heappop ( heap ) NEW_LINE heapq . heappush ( heap , ( t + a [ i ] , i ) ) NEW_LINE ret = i NEW_LINE DEDENT return ret + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for c , n , a in ReadIn ( ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : \u2581 % d ' % ( c , Solve ( n , a ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["ReadIn", "def ReadIn ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for c in range ( 1 , t + 1 ) : NEW_LINE INDENT m , n = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE yield c , n , a NEW_LINE DEDENT DEDENT"], ["OK", "def OK ( n , a , guess ) : NEW_LINE INDENT return sum ( [ guess // x + 1 for x in a ] ) >= n NEW_LINE DEDENT"], ["Solve", "def Solve ( n , a ) : NEW_LINE INDENT if n <= len ( a ) : return n NEW_LINE lower = 0 NEW_LINE upper = max ( a ) * n NEW_LINE while lower < upper : NEW_LINE INDENT guess = ( lower + upper + 1 ) // 2 NEW_LINE if OK ( n , a , guess ) : upper = guess - 1 NEW_LINE else : lower = guess NEW_LINE DEDENT guess = lower NEW_LINE heap = [ ] NEW_LINE remain = n NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT num = guess // x + 1 NEW_LINE remain -= num NEW_LINE heapq . heappush ( heap , ( num * x - guess , i ) ) NEW_LINE DEDENT ret = heap [ 0 ] [ 1 ] NEW_LINE for r in range ( remain ) : NEW_LINE INDENT t , i = heapq . heappop ( heap ) NEW_LINE heapq . heappush ( heap , ( t + a [ i ] , i ) ) NEW_LINE ret = i NEW_LINE DEDENT return ret + 1 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "from math import atan2 NEW_LINE def right ( p , q ) : NEW_LINE INDENT return p [ 0 ] * q [ 1 ] - p [ 1 ] * q [ 0 ] <= 0 NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE P = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE n = N - 1 NEW_LINE print ( \" Case \u2581 # { } : \" . format ( case ) ) NEW_LINE for cx , cy in P : NEW_LINE INDENT D = [ ( x - cx , y - cy ) for x , y in P if x != cx or y != cy ] NEW_LINE D . sort ( key = lambda p : atan2 ( * p ) ) NEW_LINE j = 0 NEW_LINE m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while right ( D [ i ] , D [ j % n ] ) and j < i + n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT m = max ( m , j - i ) NEW_LINE DEDENT print ( n - m ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["right", "def right ( p , q ) : NEW_LINE INDENT return p [ 0 ] * q [ 1 ] - p [ 1 ] * q [ 0 ] <= 0 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "def cal ( m , t ) : NEW_LINE INDENT return sum ( [ ( t + x - 1 ) // x for x in m ] ) NEW_LINE DEDENT def gao ( ) : NEW_LINE INDENT ( b , n ) = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = 0 NEW_LINE r = min ( m ) * n NEW_LINE ans = r NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE s = cal ( m , mid ) NEW_LINE if s >= n : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT ans = ans - 1 NEW_LINE cnt = n - cal ( m , ans ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT if ans % m [ i ] == 0 : NEW_LINE INDENT cnt -= 1 NEW_LINE if cnt == 0 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for cas in range ( t ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : ' % ( cas + 1 ) , end = ' \u2581 ' ) NEW_LINE print ( gao ( ) ) NEW_LINE DEDENT", "functions_standalone": [["cal", "def cal ( m , t ) : NEW_LINE INDENT return sum ( [ ( t + x - 1 ) // x for x in m ] ) NEW_LINE DEDENT"], ["gao", "def gao ( ) : NEW_LINE INDENT ( b , n ) = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = 0 NEW_LINE r = min ( m ) * n NEW_LINE ans = r NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE s = cal ( m , mid ) NEW_LINE if s >= n : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT ans = ans - 1 NEW_LINE cnt = n - cal ( m , ans ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT if ans % m [ i ] == 0 : NEW_LINE INDENT cnt -= 1 NEW_LINE if cnt == 0 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_15_22", "java": [{"id": "19", "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; } void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { int Row = cin . nextInt ( ) ; int Col = cin . nextInt ( ) ; int Num = cin . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( Row , Col , Num ) ) ; } } int solve ( int R , int C , int N ) { List < Integer > all = new ArrayList < Integer > ( ) ; List < Integer > all2 = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < R ; ++ i ) { for ( int j = 0 ; j < C ; ++ j ) { int wall = 0 ; if ( i > 0 ) { ++ wall ; } if ( j > 0 ) { ++ wall ; } if ( i + 1 < R ) { ++ wall ; } if ( j + 1 < C ) { ++ wall ; } if ( ( i + j ) % 2 == 0 ) { all . add ( wall ) ; } else { all2 . add ( wall ) ; } } } int ret = 0 ; Collections . sort ( all ) ; for ( int i = 0 ; i < all . size ( ) - ( R * C - N ) ; ++ i ) { ret += all . get ( i ) ; } int ret2 = 0 ; Collections . sort ( all2 ) ; for ( int i = 0 ; i < all2 . size ( ) - ( R * C - N ) ; ++ i ) { ret2 += all2 . get ( i ) ; } return Math . min ( ret , ret2 ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { int Row = cin . nextInt ( ) ; int Col = cin . nextInt ( ) ; int Num = cin . nextInt ( ) ; System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( Row , Col , Num ) ) ; } }"], ["solve", "int solve ( int R , int C , int N ) { List < Integer > all = new ArrayList < Integer > ( ) ; List < Integer > all2 = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < R ; ++ i ) { for ( int j = 0 ; j < C ; ++ j ) { int wall = 0 ; if ( i > 0 ) { ++ wall ; } if ( j > 0 ) { ++ wall ; } if ( i + 1 < R ) { ++ wall ; } if ( j + 1 < C ) { ++ wall ; } if ( ( i + j ) % 2 == 0 ) { all . add ( wall ) ; } else { all2 . add ( wall ) ; } } } int ret = 0 ; Collections . sort ( all ) ; for ( int i = 0 ; i < all . size ( ) - ( R * C - N ) ; ++ i ) { ret += all . get ( i ) ; } int ret2 = 0 ; Collections . sort ( all2 ) ; for ( int i = 0 ; i < all2 . size ( ) - ( R * C - N ) ; ++ i ) { ret2 += all2 . get ( i ) ; } return Math . min ( ret , ret2 ) ; }"]]}, {"id": "7", "code": "import java . util . * ; public class B { String solve ( Scanner sc ) { int R = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < 1 << ( R * C ) ; i ++ ) { if ( Integer . bitCount ( i ) == N ) { int s = 0 ; boolean [ ] [ ] b = new boolean [ R ] [ C ] ; for ( int r = 0 ; r < R ; r ++ ) { for ( int c = 0 ; c < C ; c ++ ) { b [ r ] [ c ] = ( i & ( 1 << ( r * C + c ) ) ) != 0 ; if ( b [ r ] [ c ] ) { if ( r > 0 && b [ r - 1 ] [ c ] ) { s ++ ; } if ( c > 0 && b [ r ] [ c - 1 ] ) { s ++ ; } } } } min = Math . min ( min , s ) ; } } return \" \" + min ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= T ; cs ++ ) { String res = new B ( ) . solve ( sc ) ; System . out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + res ) ; } sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= T ; cs ++ ) { String res = new B ( ) . solve ( sc ) ; System . out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + res ) ; } sc . close ( ) ; }"]], "functions_class": [["solve", "String solve ( Scanner sc ) { int R = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < 1 << ( R * C ) ; i ++ ) { if ( Integer . bitCount ( i ) == N ) { int s = 0 ; boolean [ ] [ ] b = new boolean [ R ] [ C ] ; for ( int r = 0 ; r < R ; r ++ ) { for ( int c = 0 ; c < C ; c ++ ) { b [ r ] [ c ] = ( i & ( 1 << ( r * C + c ) ) ) != 0 ; if ( b [ r ] [ c ] ) { if ( r > 0 && b [ r - 1 ] [ c ] ) { s ++ ; } if ( c > 0 && b [ r ] [ c - 1 ] ) { s ++ ; } } } } min = Math . min ( min , s ) ; } } return \" \" + min ; }"]]}, {"id": "6", "code": "import java . util . * ; public class NN { static Scanner sc = new Scanner ( System . in ) ; static int k ; { k = sc . nextInt ( ) ; for ( int kk = 1 ; kk <= k ; kk ++ ) { System . out . print ( \" Case \u2581 # \" + kk + \" : \u2581 \" ) ; int r = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int a = val ( r , c , n ) ; System . out . println ( val ( r , c , n ) ) ; } } static int thing ( int r , int c , int n , int basegood , int corn , int edg ) { if ( n <= basegood ) return 0 ; n -= basegood ; if ( n <= corn ) return 2 * n ; int result = 2 * corn ; n -= corn ; if ( n <= edg ) return result + 3 * n ; result += 3 * edg ; n -= edg ; return result + 4 * n ; } static int special ( int size , int n ) { if ( size % 2 == 0 ) { if ( n <= size / 2 ) return 0 ; return 2 * ( n - size / 2 ) - 1 ; } else { if ( n <= size / 2 + 1 ) return 0 ; return 2 * ( n - size / 2 - 1 ) ; } } static int val ( int r , int c , int n ) { if ( r == 1 ) return special ( c , n ) ; if ( c == 1 ) return special ( r , n ) ; if ( ( r * c ) % 2 == 0 ) return thing ( r , c , n , r * c / 2 , 2 , r + c - 4 ) ; else return Math . min ( thing ( r , c , n , r * c / 2 + 1 , 0 , r + c - 2 ) , thing ( r , c , n , r * c / 2 , 4 , r + c - 6 ) ) ; } public static void main ( String [ ] args ) { new NN ( ) ; } }", "functions_standalone": [["thing", "static int thing ( int r , int c , int n , int basegood , int corn , int edg ) { if ( n <= basegood ) return 0 ; n -= basegood ; if ( n <= corn ) return 2 * n ; int result = 2 * corn ; n -= corn ; if ( n <= edg ) return result + 3 * n ; result += 3 * edg ; n -= edg ; return result + 4 * n ; }"], ["special", "static int special ( int size , int n ) { if ( size % 2 == 0 ) { if ( n <= size / 2 ) return 0 ; return 2 * ( n - size / 2 ) - 1 ; } else { if ( n <= size / 2 + 1 ) return 0 ; return 2 * ( n - size / 2 - 1 ) ; } }"], ["val", "static int val ( int r , int c , int n ) { if ( r == 1 ) return special ( c , n ) ; if ( c == 1 ) return special ( r , n ) ; if ( ( r * c ) % 2 == 0 ) return thing ( r , c , n , r * c / 2 , 2 , r + c - 4 ) ; else return Math . min ( thing ( r , c , n , r * c / 2 + 1 , 0 , r + c - 2 ) , thing ( r , c , n , r * c / 2 , 4 , r + c - 6 ) ) ; }"], ["main", "public static void main ( String [ ] args ) { new NN ( ) ; }"]], "functions_class": [["print", "kk ++ ) { System . out . print ( \" Case \u2581 # \" + kk + \" : \u2581 \" ) ; int r = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int a = val ( r , c , n ) ; System . out . println ( val ( r , c , n ) ) ; }"]]}], "python": [{"id": "20", "code": "import sys NEW_LINE inp = sys . argv [ 1 ] NEW_LINE outp = \" % s . out \" % inp . split ( \" . \" ) [ 0 ] NEW_LINE from itertools import product , combinations NEW_LINE def unhappiness ( tenants ) : NEW_LINE INDENT res = 0 NEW_LINE for c in combinations ( tenants , 2 ) : NEW_LINE INDENT t1 = c [ 0 ] NEW_LINE t2 = c [ 1 ] NEW_LINE dx = abs ( t1 [ 0 ] - t2 [ 0 ] ) NEW_LINE dy = abs ( t1 [ 1 ] - t2 [ 1 ] ) NEW_LINE if dx == 0 and dy == 1 : res += 1 NEW_LINE if dx == 1 and dy == 0 : res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def solve ( r , c , n ) : NEW_LINE INDENT return min ( [ unhappiness ( t ) for t in combinations ( product ( range ( r ) , range ( c ) ) , n ) ] ) NEW_LINE DEDENT with open ( inp , ' r ' ) as f , open ( outp , ' w ' ) as out : NEW_LINE INDENT cases = int ( f . readline ( ) ) NEW_LINE for c in range ( cases ) : NEW_LINE INDENT r , cc , n = tuple ( [ int ( x ) for x in f . readline ( ) [ : - 1 ] . split ( \" \u2581 \" ) ] ) NEW_LINE out . write ( \" Case \u2581 # % s : \u2581 % s \\n \" % ( c + 1 , solve ( r , cc , n ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["unhappiness", "def unhappiness ( tenants ) : NEW_LINE INDENT res = 0 NEW_LINE for c in combinations ( tenants , 2 ) : NEW_LINE INDENT t1 = c [ 0 ] NEW_LINE t2 = c [ 1 ] NEW_LINE dx = abs ( t1 [ 0 ] - t2 [ 0 ] ) NEW_LINE dy = abs ( t1 [ 1 ] - t2 [ 1 ] ) NEW_LINE if dx == 0 and dy == 1 : res += 1 NEW_LINE if dx == 1 and dy == 0 : res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT"], ["solve", "def solve ( r , c , n ) : NEW_LINE INDENT return min ( [ unhappiness ( t ) for t in combinations ( product ( range ( r ) , range ( c ) ) , n ) ] ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "0", "code": "import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case \u2581 # { : d } : \u2581 { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 arguments , \u2581 not \u2581 { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["readline", "def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT"], ["readint", "def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readfloat", "def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT"], ["readints", "def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["readfloats", "def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["writeline", "def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT"], ["writecase", "def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case \u2581 # { : d } : \u2581 { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT"], ["run", "def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 arguments , \u2581 not \u2581 { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "2", "code": "def solve ( R , C , N ) : NEW_LINE INDENT z = N - ( R * C + 1 ) // 2 NEW_LINE if z <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT y = 0 NEW_LINE if R == 1 or C == 1 : NEW_LINE INDENT if R * C % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE z -= 1 NEW_LINE DEDENT y += 2 * z NEW_LINE return y NEW_LINE DEDENT if R * C % 2 == 0 : NEW_LINE INDENT dz = min ( z , 2 ) NEW_LINE y += 2 * dz NEW_LINE z -= dz NEW_LINE dz = min ( z , R + C - 4 ) NEW_LINE y += 3 * dz NEW_LINE z -= dz NEW_LINE y += 4 * z NEW_LINE return y NEW_LINE DEDENT if z == 1 : NEW_LINE INDENT return 3 NEW_LINE DEDENT z += 1 NEW_LINE dz = min ( z , 4 ) NEW_LINE y += 2 * dz NEW_LINE z -= dz NEW_LINE dz = min ( z , R + C - 6 ) NEW_LINE y += 3 * dz NEW_LINE z -= dz NEW_LINE y += 4 * z NEW_LINE return y NEW_LINE DEDENT for x in range ( 1 , int ( input ( ) ) + 1 ) : NEW_LINE INDENT y = solve ( * map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' Case \u2581 # ' + str ( x ) + ' : ' , y ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( R , C , N ) : NEW_LINE INDENT z = N - ( R * C + 1 ) // 2 NEW_LINE if z <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT y = 0 NEW_LINE if R == 1 or C == 1 : NEW_LINE INDENT if R * C % 2 == 0 : NEW_LINE INDENT y += 1 NEW_LINE z -= 1 NEW_LINE DEDENT y += 2 * z NEW_LINE return y NEW_LINE DEDENT if R * C % 2 == 0 : NEW_LINE INDENT dz = min ( z , 2 ) NEW_LINE y += 2 * dz NEW_LINE z -= dz NEW_LINE dz = min ( z , R + C - 4 ) NEW_LINE y += 3 * dz NEW_LINE z -= dz NEW_LINE y += 4 * z NEW_LINE return y NEW_LINE DEDENT if z == 1 : NEW_LINE INDENT return 3 NEW_LINE DEDENT z += 1 NEW_LINE dz = min ( z , 4 ) NEW_LINE y += 2 * dz NEW_LINE z -= dz NEW_LINE dz = min ( z , R + C - 6 ) NEW_LINE y += 3 * dz NEW_LINE z -= dz NEW_LINE y += 4 * z NEW_LINE return y NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "from functools import * NEW_LINE inf = open ( ' B - large . in ' ) NEW_LINE ouf = open ( ' B - large . out ' , ' w ' ) NEW_LINE input = lambda : inf . readline ( ) . strip ( ) NEW_LINE print = partial ( print , file = ouf ) NEW_LINE def solve ( ) : NEW_LINE INDENT r , c , n = map ( int , input ( ) . split ( ) ) NEW_LINE if r > c : NEW_LINE INDENT r , c = c , r NEW_LINE DEDENT if n <= ( r * c ) // 2 + ( r * c ) % 2 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT free = r * c - n NEW_LINE cur = ( r - 1 ) * c + ( c - 1 ) * r NEW_LINE if r == 1 : NEW_LINE INDENT if c % 2 == 0 : NEW_LINE INDENT ways = [ [ 2 ] * ( c // 2 - 1 ) + [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT ways = [ [ 2 ] * ( c // 2 ) , [ 2 ] * ( c // 2 - 1 ) + [ 1 , 1 ] ] NEW_LINE DEDENT DEDENT elif r * c % 2 == 0 : NEW_LINE INDENT ways = [ [ 4 ] * ( ( r - 2 ) * ( c - 2 ) // 2 ) + [ 3 ] * ( r - 2 + c - 2 ) + [ 2 , 2 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT ways = [ [ 4 ] * ( ( r - 2 ) * ( c - 2 ) // 2 + 1 ) + [ 3 ] * ( r - 3 + c - 3 ) + [ 2 ] * 4 , [ 4 ] * ( ( r - 2 ) * ( c - 2 ) // 2 ) + [ 3 ] * ( r - 1 + c - 1 ) , ] NEW_LINE DEDENT print ( cur - max ( sum ( way [ : free ] ) for way in ways ) ) NEW_LINE DEDENT tests = int ( input ( ) ) NEW_LINE for z in range ( tests ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 \" . format ( z + 1 ) , end = ' ' ) NEW_LINE solve ( ) NEW_LINE DEDENT ouf . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT r , c , n = map ( int , input ( ) . split ( ) ) NEW_LINE if r > c : NEW_LINE INDENT r , c = c , r NEW_LINE DEDENT if n <= ( r * c ) // 2 + ( r * c ) % 2 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT free = r * c - n NEW_LINE cur = ( r - 1 ) * c + ( c - 1 ) * r NEW_LINE if r == 1 : NEW_LINE INDENT if c % 2 == 0 : NEW_LINE INDENT ways = [ [ 2 ] * ( c // 2 - 1 ) + [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT ways = [ [ 2 ] * ( c // 2 ) , [ 2 ] * ( c // 2 - 1 ) + [ 1 , 1 ] ] NEW_LINE DEDENT DEDENT elif r * c % 2 == 0 : NEW_LINE INDENT ways = [ [ 4 ] * ( ( r - 2 ) * ( c - 2 ) // 2 ) + [ 3 ] * ( r - 2 + c - 2 ) + [ 2 , 2 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT ways = [ [ 4 ] * ( ( r - 2 ) * ( c - 2 ) // 2 + 1 ) + [ 3 ] * ( r - 3 + c - 3 ) + [ 2 ] * 4 , [ 4 ] * ( ( r - 2 ) * ( c - 2 ) // 2 ) + [ 3 ] * ( r - 1 + c - 1 ) , ] NEW_LINE DEDENT print ( cur - max ( sum ( way [ : free ] ) for way in ways ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT def permutations ( n , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT yield [ False ] * n NEW_LINE return NEW_LINE DEDENT for p in permutations ( n - 1 , k - 1 ) : NEW_LINE INDENT yield p + [ True ] NEW_LINE DEDENT if n > k : NEW_LINE INDENT for p in permutations ( n - 1 , k ) : NEW_LINE INDENT yield p + [ False ] NEW_LINE DEDENT DEDENT DEDENT def cost ( p , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c - 1 ) : NEW_LINE INDENT if p [ i * c + j ] and p [ i * c + j + 1 ] : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( r - 1 ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if p [ i * c + j ] and p [ i * c + j + c ] : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT R , C , N = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE best = R * C * 10 NEW_LINE for p in permutations ( R * C , N ) : NEW_LINE INDENT best = min ( best , cost ( p , R , C ) ) NEW_LINE DEDENT result = best NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , result ) ) NEW_LINE DEDENT", "functions_standalone": [["debug", "def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT"], ["permutations", "def permutations ( n , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT yield [ False ] * n NEW_LINE return NEW_LINE DEDENT for p in permutations ( n - 1 , k - 1 ) : NEW_LINE INDENT yield p + [ True ] NEW_LINE DEDENT if n > k : NEW_LINE INDENT for p in permutations ( n - 1 , k ) : NEW_LINE INDENT yield p + [ False ] NEW_LINE DEDENT DEDENT DEDENT"], ["cost", "def cost ( p , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c - 1 ) : NEW_LINE INDENT if p [ i * c + j ] and p [ i * c + j + 1 ] : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( r - 1 ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if p [ i * c + j ] and p [ i * c + j + c ] : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_03", "java": [{"id": "19", "code": "package google . codejam2012 . qualification ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class RecycledNumbers { static private int getDigitsCount ( int number ) { int sh = 10 ; int digits = 1 ; while ( sh <= number ) { sh *= 10 ; digits ++ ; } return digits ; } static private int getRecyclingPairsCount ( int number , int limit ) { int digits = getDigitsCount ( number ) ; int sh = 1 ; for ( int i = 1 ; i < digits ; i ++ ) { sh *= 10 ; } int permutation = number ; int result = 0 ; int [ ] usedNumbers = new int [ digits ] ; int usedNumbersCount = 0 ; for ( int i = 1 ; i < digits ; i ++ ) { permutation = ( permutation % 10 ) * sh + ( permutation / 10 ) ; if ( number < permutation & permutation <= limit ) { boolean isNumberAlreadyUsed = false ; for ( int j = 0 ; j < usedNumbersCount ; j ++ ) { if ( usedNumbers [ j ] == permutation ) { isNumberAlreadyUsed = true ; break ; } } if ( ! isNumberAlreadyUsed ) { usedNumbers [ usedNumbersCount ++ ] = permutation ; result ++ ; } } } return result ; } static public void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 64 << 10 ) ; int testsNumber = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; for ( int test = 1 ; test <= testsNumber ; test ++ ) { StringTokenizer tokenizer = new StringTokenizer ( br . readLine ( ) ) ; int startingNumber = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int endingNumber = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int result = 0 ; for ( int number = startingNumber ; number <= endingNumber ; number ++ ) { result += getRecyclingPairsCount ( number , endingNumber ) ; } System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + result ) ; } } catch ( Exception e ) { System . err . println ( \" Error : \" + e . getMessage ( ) ) ; } } }", "functions_standalone": [["getDigitsCount", "static private int getDigitsCount ( int number ) { int sh = 10 ; int digits = 1 ; while ( sh <= number ) { sh *= 10 ; digits ++ ; } return digits ; }"], ["getRecyclingPairsCount", "static private int getRecyclingPairsCount ( int number , int limit ) { int digits = getDigitsCount ( number ) ; int sh = 1 ; for ( int i = 1 ; i < digits ; i ++ ) { sh *= 10 ; } int permutation = number ; int result = 0 ; int [ ] usedNumbers = new int [ digits ] ; int usedNumbersCount = 0 ; for ( int i = 1 ; i < digits ; i ++ ) { permutation = ( permutation % 10 ) * sh + ( permutation / 10 ) ; if ( number < permutation & permutation <= limit ) { boolean isNumberAlreadyUsed = false ; for ( int j = 0 ; j < usedNumbersCount ; j ++ ) { if ( usedNumbers [ j ] == permutation ) { isNumberAlreadyUsed = true ; break ; } } if ( ! isNumberAlreadyUsed ) { usedNumbers [ usedNumbersCount ++ ] = permutation ; result ++ ; } } } return result ; }"], ["main", "static public void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 64 << 10 ) ; int testsNumber = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; for ( int test = 1 ; test <= testsNumber ; test ++ ) { StringTokenizer tokenizer = new StringTokenizer ( br . readLine ( ) ) ; int startingNumber = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int endingNumber = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int result = 0 ; for ( int number = startingNumber ; number <= endingNumber ; number ++ ) { result += getRecyclingPairsCount ( number , endingNumber ) ; } System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + result ) ; } } catch ( Exception e ) { System . err . println ( \" Error : \" + e . getMessage ( ) ) ; } }"]], "functions_class": []}, {"id": "15", "code": "import java . util . * ; import java . io . * ; import java . math . * ; import java . awt . * ; import static java . lang . Math . * ; import static java . lang . Integer . parseInt ; import static java . lang . Double . parseDouble ; import static java . lang . Long . parseLong ; import static java . lang . System . * ; import static java . util . Arrays . * ; import static java . util . Collection . * ; public class C { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int T = parseInt ( br . readLine ( ) ) ; for ( int t = 0 ; t ++ < T ; ) { String [ ] line = br . readLine ( ) . split ( \" \u2581 \" ) ; int A = parseInt ( line [ 0 ] ) , B = parseInt ( line [ 1 ] ) ; long [ ] V = new long [ B - A + 1 ] , S = new long [ B - A + 1 ] ; int order = 1 ; S [ 0 ] = V [ 0 ] = 0 ; while ( order < B ) order *= 10 ; for ( int i = A + 1 ; i <= B ; i ++ ) { int index = - 1 ; for ( int j = 10 ; j <= i ; j *= 10 ) { int count = i / j + ( i % j ) * ( order / j ) ; if ( index < count && count < i ) index = count ; } V [ i - A ] = index >= A ? V [ index - A ] + 1 : 0 ; S [ i - A ] = V [ i - A ] + S [ i - A - 1 ] ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + S [ B - A ] ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int T = parseInt ( br . readLine ( ) ) ; for ( int t = 0 ; t ++ < T ; ) { String [ ] line = br . readLine ( ) . split ( \" \u2581 \" ) ; int A = parseInt ( line [ 0 ] ) , B = parseInt ( line [ 1 ] ) ; long [ ] V = new long [ B - A + 1 ] , S = new long [ B - A + 1 ] ; int order = 1 ; S [ 0 ] = V [ 0 ] = 0 ; while ( order < B ) order *= 10 ; for ( int i = A + 1 ; i <= B ; i ++ ) { int index = - 1 ; for ( int j = 10 ; j <= i ; j *= 10 ) { int count = i / j + ( i % j ) * ( order / j ) ; if ( index < count && count < i ) index = count ; } V [ i - A ] = index >= A ? V [ index - A ] + 1 : 0 ; S [ i - A ] = V [ i - A ] + S [ i - A - 1 ] ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + S [ B - A ] ) ; } }"]], "functions_class": []}, {"id": "16", "code": "package qualification ; import java . io . * ; import java . util . * ; public class C_RecycledNumbers { private static String ID = \" C \" ; private static String NAME = \" large \" ; private static boolean STANDARD_OUTPUT = false ; public static void main ( String [ ] args ) throws Throwable { int [ ] [ ] results = new int [ 2000001 ] [ ] ; for ( int i = 0 ; i < results . length ; i ++ ) { int array [ ] = new int [ 8 ] , n = 0 ; String s = \" \" + i ; loop : for ( int p = 1 ; p < s . length ( ) ; p ++ ) if ( s . charAt ( p ) != '0' ) { int j = Integer . parseInt ( s . substring ( p ) + s . substring ( 0 , p ) ) ; if ( j <= i ) continue loop ; for ( int q = 0 ; q < n ; q ++ ) if ( array [ q ] == j ) continue loop ; if ( array . length == n ) array = Arrays . copyOf ( array , n * 2 ) ; array [ n ++ ] = j ; } results [ i ] = Arrays . copyOf ( array , n ) ; Arrays . sort ( results [ i ] ) ; } BufferedReader reader = new BufferedReader ( new FileReader ( new File ( \" data / \" + ID + \" - \" + NAME + \" . in \" ) ) ) ; if ( ! STANDARD_OUTPUT ) System . setOut ( new PrintStream ( new File ( \" data / \" + ID + \" - \" + NAME + \" . out \" ) ) ) ; for ( int c = 1 , T = Integer . parseInt ( reader . readLine ( ) ) ; c <= T ; c ++ ) { String w [ ] = reader . readLine ( ) . trim ( ) . split ( \" \u2581 + \" ) ; int A = Integer . parseInt ( w [ 0 ] ) , B = Integer . parseInt ( w [ 1 ] ) ; int count = 0 ; for ( int i = A ; i <= B ; i ++ ) { for ( int x : results [ i ] ) if ( x <= B ) count ++ ; } System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + count ) ; } if ( ! STANDARD_OUTPUT ) System . out . close ( ) ; reader . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { int [ ] [ ] results = new int [ 2000001 ] [ ] ; for ( int i = 0 ; i < results . length ; i ++ ) { int array [ ] = new int [ 8 ] , n = 0 ; String s = \" \" + i ; loop : for ( int p = 1 ; p < s . length ( ) ; p ++ ) if ( s . charAt ( p ) != '0' ) { int j = Integer . parseInt ( s . substring ( p ) + s . substring ( 0 , p ) ) ; if ( j <= i ) continue loop ; for ( int q = 0 ; q < n ; q ++ ) if ( array [ q ] == j ) continue loop ; if ( array . length == n ) array = Arrays . copyOf ( array , n * 2 ) ; array [ n ++ ] = j ; } results [ i ] = Arrays . copyOf ( array , n ) ; Arrays . sort ( results [ i ] ) ; } BufferedReader reader = new BufferedReader ( new FileReader ( new File ( \" data / \" + ID + \" - \" + NAME + \" . in \" ) ) ) ; if ( ! STANDARD_OUTPUT ) System . setOut ( new PrintStream ( new File ( \" data / \" + ID + \" - \" + NAME + \" . out \" ) ) ) ; for ( int c = 1 , T = Integer . parseInt ( reader . readLine ( ) ) ; c <= T ; c ++ ) { String w [ ] = reader . readLine ( ) . trim ( ) . split ( \" \u2581 + \" ) ; int A = Integer . parseInt ( w [ 0 ] ) , B = Integer . parseInt ( w [ 1 ] ) ; int count = 0 ; for ( int i = A ; i <= B ; i ++ ) { for ( int x : results [ i ] ) if ( x <= B ) count ++ ; } System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + count ) ; } if ( ! STANDARD_OUTPUT ) System . out . close ( ) ; reader . close ( ) ; }"]], "functions_class": []}, {"id": "11", "code": "import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { FileInputStream fis = new FileInputStream ( new File ( \" in . txt \" ) ) ; FileOutputStream fos = new FileOutputStream ( new File ( \" out . txt \" ) ) ; Scanner sc = new Scanner ( fis ) ; PrintWriter out = new PrintWriter ( fos ) ; int cases = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= cases ; cs ++ ) { int begin = sc . nextInt ( ) ; int end = sc . nextInt ( ) ; int cnt = 0 ; for ( int n = begin ; n <= end ; n ++ ) { int weishu = getWeishu ( n ) ; int cur = getNext ( n , weishu ) ; while ( cur != n ) { if ( cur > n && cur <= end && getWeishu ( cur ) == weishu ) cnt ++ ; cur = getNext ( cur , weishu ) ; } } out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + cnt ) ; } sc . close ( ) ; out . close ( ) ; } public static int getNext ( int n , int weishu ) { return n % 10 * getTens ( weishu - 1 ) + n / 10 ; } private static int getTens ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) res *= 10 ; return res ; } private static int getWeishu ( int n ) { int weishu = 1 ; int nweishu = 10 ; while ( n >= nweishu ) { nweishu *= 10 ; weishu ++ ; } return weishu ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { FileInputStream fis = new FileInputStream ( new File ( \" in . txt \" ) ) ; FileOutputStream fos = new FileOutputStream ( new File ( \" out . txt \" ) ) ; Scanner sc = new Scanner ( fis ) ; PrintWriter out = new PrintWriter ( fos ) ; int cases = sc . nextInt ( ) ; for ( int cs = 1 ; cs <= cases ; cs ++ ) { int begin = sc . nextInt ( ) ; int end = sc . nextInt ( ) ; int cnt = 0 ; for ( int n = begin ; n <= end ; n ++ ) { int weishu = getWeishu ( n ) ; int cur = getNext ( n , weishu ) ; while ( cur != n ) { if ( cur > n && cur <= end && getWeishu ( cur ) == weishu ) cnt ++ ; cur = getNext ( cur , weishu ) ; } } out . println ( \" Case \u2581 # \" + cs + \" : \u2581 \" + cnt ) ; } sc . close ( ) ; out . close ( ) ; }"], ["getNext", "public static int getNext ( int n , int weishu ) { return n % 10 * getTens ( weishu - 1 ) + n / 10 ; }"], ["getTens", "private static int getTens ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) res *= 10 ; return res ; }"], ["getWeishu", "private static int getWeishu ( int n ) { int weishu = 1 ; int nweishu = 10 ; while ( n >= nweishu ) { nweishu *= 10 ; weishu ++ ; } return weishu ; }"]], "functions_class": []}, {"id": "0", "code": "package gcj ; import java . util . * ; import java . io . * ; public class RecycledNumbers { final static String PROBLEM_NAME = \" rnum \" ; final static String WORK_DIR = \" D : \\\\ Gcj \\ \\\" + PROBLEM_NAME + \" \\ \\\" ; void solve ( Scanner sc , PrintWriter pw ) { int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int res = 0 ; for ( int n = A ; n <= B ; n ++ ) { String s = \" \" + n ; Set < Integer > cand = new HashSet < Integer > ( ) ; for ( int st = 1 ; st < s . length ( ) ; st ++ ) { String ss = s . substring ( st ) + s . substring ( 0 , st ) ; int m = Integer . parseInt ( ss ) ; if ( n < m && m >= A && m <= B ) cand . add ( m ) ; } res += cand . size ( ) ; } pw . println ( res ) ; } public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new RecycledNumbers ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new RecycledNumbers ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["solve", "void solve ( Scanner sc , PrintWriter pw ) { int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int res = 0 ; for ( int n = A ; n <= B ; n ++ ) { String s = \" \" + n ; Set < Integer > cand = new HashSet < Integer > ( ) ; for ( int st = 1 ; st < s . length ( ) ; st ++ ) { String ss = s . substring ( st ) + s . substring ( 0 , st ) ; int m = Integer . parseInt ( ss ) ; if ( n < m && m >= A && m <= B ) cand . add ( m ) ; } res += cand . size ( ) ; } pw . println ( res ) ; }"]]}], "python": [{"id": "10", "code": "import sys NEW_LINE def recycle ( N , A , B ) : NEW_LINE INDENT n = str ( N ) NEW_LINE r = 0 NEW_LINE S = [ ] NEW_LINE for k in range ( 1 , len ( n ) ) : NEW_LINE INDENT if n [ k ] >= n [ 0 ] : NEW_LINE INDENT p = int ( n [ k : ] + n [ : k ] ) NEW_LINE if ( p > N ) and ( p <= B ) and p not in S : NEW_LINE INDENT S . append ( p ) NEW_LINE r += 1 NEW_LINE DEDENT DEDENT DEDENT return r NEW_LINE DEDENT def work ( s ) : NEW_LINE INDENT A , B = tuple ( map ( int , s . split ( ) ) ) NEW_LINE n = sum ( recycle ( k , A , B ) for k in range ( A , B ) ) NEW_LINE return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT s = work ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , s ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["recycle", "def recycle ( N , A , B ) : NEW_LINE INDENT n = str ( N ) NEW_LINE r = 0 NEW_LINE S = [ ] NEW_LINE for k in range ( 1 , len ( n ) ) : NEW_LINE INDENT if n [ k ] >= n [ 0 ] : NEW_LINE INDENT p = int ( n [ k : ] + n [ : k ] ) NEW_LINE if ( p > N ) and ( p <= B ) and p not in S : NEW_LINE INDENT S . append ( p ) NEW_LINE r += 1 NEW_LINE DEDENT DEDENT DEDENT return r NEW_LINE DEDENT"], ["work", "def work ( s ) : NEW_LINE INDENT A , B = tuple ( map ( int , s . split ( ) ) ) NEW_LINE n = sum ( recycle ( k , A , B ) for k in range ( A , B ) ) NEW_LINE return n NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "f = open ( ' C - small - attempt0 . in ' , ' r ' ) NEW_LINE g = open ( ' Csm . txt ' , ' w ' ) NEW_LINE T = int ( f . next ( ) . strip ( ) ) NEW_LINE def solve ( A , B , N ) : NEW_LINE INDENT sh = range ( 1 , N ) NEW_LINE n1 = range ( N - 1 ) NEW_LINE j10 = [ 10 ** j for j in sh ] NEW_LINE r10 = [ 10 ** ( N - j ) for j in sh ] NEW_LINE res = 0 NEW_LINE for i in xrange ( A , B ) : NEW_LINE INDENT S = set ( ) NEW_LINE for j in n1 : NEW_LINE INDENT r = i % j10 [ j ] NEW_LINE d = i / j10 [ j ] NEW_LINE N = r * r10 [ j ] + d NEW_LINE if N > i and N <= B : NEW_LINE INDENT S . add ( N ) NEW_LINE DEDENT DEDENT res += len ( S ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in xrange ( 1 , 1 + T ) : NEW_LINE INDENT s = f . next ( ) . strip ( ) . split ( ) NEW_LINE A = int ( s [ 0 ] ) NEW_LINE B = int ( s [ 1 ] ) NEW_LINE N = len ( s [ 0 ] ) NEW_LINE res = solve ( A , B , N ) NEW_LINE g . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 ' + str ( res ) + ' \\n ' ) NEW_LINE DEDENT g . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "canons = [ ] NEW_LINE def canonicalize ( s ) : NEW_LINE INDENT min_string = s NEW_LINE for i in xrange ( len ( s ) ) : NEW_LINE INDENT s = s [ 1 : ] + s [ 0 ] NEW_LINE if s < min_string : NEW_LINE INDENT min_string = s NEW_LINE DEDENT DEDENT return min_string NEW_LINE DEDENT for i in xrange ( 2000005 ) : NEW_LINE INDENT canons . append ( canonicalize ( str ( i ) ) ) NEW_LINE DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT counts = { } NEW_LINE A , B = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE for j in xrange ( A , B + 1 ) : NEW_LINE INDENT s = canons [ j ] NEW_LINE if not counts . has_key ( s ) : NEW_LINE INDENT counts [ s ] = 0 NEW_LINE DEDENT counts [ s ] += 1 NEW_LINE DEDENT num = sum ( counts [ s ] * ( counts [ s ] - 1 ) / 2 for s in counts ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) + str ( num ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_12_32", "java": [{"id": "19", "code": "import java . util . Scanner ; public class iCode2012OutofGas { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int index = 1 ; index <= T ; index ++ ) { System . out . println ( \" Case \u2581 # \" + index + \" : \" ) ; double D = in . nextDouble ( ) ; int N = in . nextInt ( ) ; int A = in . nextInt ( ) ; double [ ] time = new double [ N + 1 ] ; double [ ] pos = new double [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { time [ i ] = in . nextDouble ( ) ; pos [ i ] = in . nextDouble ( ) ; } for ( int acc = 0 ; acc < A ; acc ++ ) { double a = in . nextDouble ( ) ; double startmovingat = 0 ; for ( int i = 1 ; i < N ; i ++ ) { startmovingat = Math . max ( startmovingat , time [ i ] - Math . sqrt ( 2 * pos [ i ] / a ) ) ; } double effectivetime = time [ N - 1 ] + ( time [ N ] - time [ N - 1 ] ) / ( pos [ N ] - pos [ N - 1 ] ) * ( D - pos [ N - 1 ] ) ; startmovingat = Math . max ( startmovingat , effectivetime - Math . sqrt ( 2 * D / a ) ) ; System . out . println ( Math . max ( effectivetime , startmovingat + Math . sqrt ( 2 * D / a ) ) ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int index = 1 ; index <= T ; index ++ ) { System . out . println ( \" Case \u2581 # \" + index + \" : \" ) ; double D = in . nextDouble ( ) ; int N = in . nextInt ( ) ; int A = in . nextInt ( ) ; double [ ] time = new double [ N + 1 ] ; double [ ] pos = new double [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { time [ i ] = in . nextDouble ( ) ; pos [ i ] = in . nextDouble ( ) ; } for ( int acc = 0 ; acc < A ; acc ++ ) { double a = in . nextDouble ( ) ; double startmovingat = 0 ; for ( int i = 1 ; i < N ; i ++ ) { startmovingat = Math . max ( startmovingat , time [ i ] - Math . sqrt ( 2 * pos [ i ] / a ) ) ; } double effectivetime = time [ N - 1 ] + ( time [ N ] - time [ N - 1 ] ) / ( pos [ N ] - pos [ N - 1 ] ) * ( D - pos [ N - 1 ] ) ; startmovingat = Math . max ( startmovingat , effectivetime - Math . sqrt ( 2 * D / a ) ) ; System . out . println ( Math . max ( effectivetime , startmovingat + Math . sqrt ( 2 * D / a ) ) ) ; } } }"]], "functions_class": []}, {"id": "14", "code": "import java . util . Scanner ; public class Gas { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . printf ( \" Case \u2581 # % d : \\n \" , C ) ; double D = sc . nextDouble ( ) ; int N = sc . nextInt ( ) ; int A = sc . nextInt ( ) ; if ( N == 1 ) { sc . nextDouble ( ) ; sc . nextDouble ( ) ; for ( int i = 0 ; i < A ; i ++ ) { double a = sc . nextDouble ( ) ; System . out . println ( Math . sqrt ( 2 * D / a ) ) ; } continue ; } double t1 = sc . nextDouble ( ) ; double d1 = sc . nextDouble ( ) ; double t2 = sc . nextDouble ( ) ; double d2 = sc . nextDouble ( ) ; double v = ( d2 - d1 ) / t2 ; for ( int i = 0 ; i < A ; i ++ ) { double a = sc . nextDouble ( ) ; double t_meet = ( v + Math . sqrt ( v * v + 2 * a * d1 ) ) / a ; double d_meet = d1 + v * t_meet ; if ( d_meet >= D ) { System . out . println ( Math . sqrt ( 2 * D / a ) ) ; } else { System . out . println ( t_meet + ( D - d_meet ) / v ) ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . printf ( \" Case \u2581 # % d : \\n \" , C ) ; double D = sc . nextDouble ( ) ; int N = sc . nextInt ( ) ; int A = sc . nextInt ( ) ; if ( N == 1 ) { sc . nextDouble ( ) ; sc . nextDouble ( ) ; for ( int i = 0 ; i < A ; i ++ ) { double a = sc . nextDouble ( ) ; System . out . println ( Math . sqrt ( 2 * D / a ) ) ; } continue ; } double t1 = sc . nextDouble ( ) ; double d1 = sc . nextDouble ( ) ; double t2 = sc . nextDouble ( ) ; double d2 = sc . nextDouble ( ) ; double v = ( d2 - d1 ) / t2 ; for ( int i = 0 ; i < A ; i ++ ) { double a = sc . nextDouble ( ) ; double t_meet = ( v + Math . sqrt ( v * v + 2 * a * d1 ) ) / a ; double d_meet = d1 + v * t_meet ; if ( d_meet >= D ) { System . out . println ( Math . sqrt ( 2 * D / a ) ) ; } else { System . out . println ( t_meet + ( D - d_meet ) / v ) ; } } } }"]], "functions_class": []}, {"id": "4", "code": "package round1c ; import java . util . Locale ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Locale . setDefault ( Locale . ENGLISH ) ; Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { double d = sc . nextDouble ( ) ; int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; double times [ ] = new double [ n ] ; double positions [ ] = new double [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { times [ j ] = sc . nextDouble ( ) ; positions [ j ] = sc . nextDouble ( ) ; } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \" ) ; for ( int j = 0 ; j < a ; j ++ ) { double acc = sc . nextDouble ( ) ; double otherTime = n == 1 ? 0 : ( d - positions [ 0 ] ) / ( positions [ 1 ] - positions [ 0 ] ) * ( times [ 1 ] - times [ 0 ] ) + times [ 0 ] ; double myTime = Math . sqrt ( d * 2 / acc ) ; System . out . println ( \" \" + Math . max ( otherTime , myTime ) ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Locale . setDefault ( Locale . ENGLISH ) ; Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { double d = sc . nextDouble ( ) ; int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; double times [ ] = new double [ n ] ; double positions [ ] = new double [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { times [ j ] = sc . nextDouble ( ) ; positions [ j ] = sc . nextDouble ( ) ; } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \" ) ; for ( int j = 0 ; j < a ; j ++ ) { double acc = sc . nextDouble ( ) ; double otherTime = n == 1 ? 0 : ( d - positions [ 0 ] ) / ( positions [ 1 ] - positions [ 0 ] ) * ( times [ 1 ] - times [ 0 ] ) + times [ 0 ] ; double myTime = Math . sqrt ( d * 2 / acc ) ; System . out . println ( \" \" + Math . max ( otherTime , myTime ) ) ; } } }"]], "functions_class": []}, {"id": "16", "code": "import java . util . * ; import java . io . * ; public class B { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; double D ; int N , A ; for ( int caseNo = 1 ; caseNo <= T ; caseNo ++ ) { D = in . nextDouble ( ) ; N = in . nextInt ( ) ; A = in . nextInt ( ) ; double anotherVelocity ; double [ ] t = new double [ N ] ; double [ ] x = new double [ N ] ; double minTime = 0 ; for ( int i = 0 ; i < N ; i ++ ) { t [ i ] = in . nextDouble ( ) ; x [ i ] = in . nextDouble ( ) ; } if ( N == 2 ) { anotherVelocity = ( x [ 1 ] - x [ 0 ] ) / ( t [ 1 ] - t [ 0 ] ) ; minTime = ( D - x [ 0 ] ) / anotherVelocity + t [ 0 ] ; } System . out . println ( \" Case \u2581 # \" + caseNo + \" : \" ) ; for ( int i = 0 ; i < A ; i ++ ) { double a = in . nextDouble ( ) ; if ( N == 1 ) { System . out . printf ( \" % .7f \\n \" , Math . sqrt ( 2 * D / a ) ) ; } else { System . out . printf ( \" % .7f \\n \" , Math . max ( Math . sqrt ( 2 * D / a ) , minTime ) ) ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; double D ; int N , A ; for ( int caseNo = 1 ; caseNo <= T ; caseNo ++ ) { D = in . nextDouble ( ) ; N = in . nextInt ( ) ; A = in . nextInt ( ) ; double anotherVelocity ; double [ ] t = new double [ N ] ; double [ ] x = new double [ N ] ; double minTime = 0 ; for ( int i = 0 ; i < N ; i ++ ) { t [ i ] = in . nextDouble ( ) ; x [ i ] = in . nextDouble ( ) ; } if ( N == 2 ) { anotherVelocity = ( x [ 1 ] - x [ 0 ] ) / ( t [ 1 ] - t [ 0 ] ) ; minTime = ( D - x [ 0 ] ) / anotherVelocity + t [ 0 ] ; } System . out . println ( \" Case \u2581 # \" + caseNo + \" : \" ) ; for ( int i = 0 ; i < A ; i ++ ) { double a = in . nextDouble ( ) ; if ( N == 1 ) { System . out . printf ( \" % .7f \\n \" , Math . sqrt ( 2 * D / a ) ) ; } else { System . out . printf ( \" % .7f \\n \" , Math . max ( Math . sqrt ( 2 * D / a ) , minTime ) ) ; } } } }"]], "functions_class": []}], "python": [{"id": "6", "code": "inp = open ( ' . / B - large . in ' , ' r ' ) NEW_LINE outp = open ( ' . / B . out ' , ' w ' ) NEW_LINE T = int ( inp . readline ( ) ) NEW_LINE def solve ( i ) : NEW_LINE INDENT I = inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) NEW_LINE D = float ( I [ 0 ] ) NEW_LINE N = int ( I [ 1 ] ) NEW_LINE A = int ( I [ 2 ] ) NEW_LINE Ns = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT Ns . append ( [ float ( x ) for x in inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) ] ) NEW_LINE if Ns [ n ] [ 1 ] > D : NEW_LINE INDENT if n != 0 : Ns [ n ] [ 0 ] = Ns [ n - 1 ] [ 0 ] + ( D - Ns [ n - 1 ] [ 1 ] ) / ( Ns [ n ] [ 1 ] - Ns [ n - 1 ] [ 1 ] ) * ( Ns [ n ] [ 0 ] - Ns [ n - 1 ] [ 0 ] ) NEW_LINE Ns [ n ] [ 1 ] = D NEW_LINE DEDENT DEDENT As = [ float ( x ) for x in inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) ] NEW_LINE Mx = [ 0 ] * A NEW_LINE for n in range ( N ) : NEW_LINE INDENT for a in range ( A ) : NEW_LINE INDENT Mx [ a ] = max ( Mx [ a ] , Ns [ n ] [ 0 ] - ( 2 * Ns [ n ] [ 1 ] / As [ a ] ) ** 0.5 ) NEW_LINE DEDENT DEDENT outp . write ( ' Case \u2581 # ' + str ( i ) + ' : \\n ' ) NEW_LINE for a in range ( A ) : NEW_LINE INDENT x = ( 2 * D / As [ a ] ) ** 0.5 + Mx [ a ] NEW_LINE outp . write ( str ( x ) + ' \\n ' ) NEW_LINE DEDENT DEDENT for k in range ( T ) : NEW_LINE INDENT solve ( k + 1 ) NEW_LINE DEDENT inp . close ( ) NEW_LINE outp . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( i ) : NEW_LINE INDENT I = inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) NEW_LINE D = float ( I [ 0 ] ) NEW_LINE N = int ( I [ 1 ] ) NEW_LINE A = int ( I [ 2 ] ) NEW_LINE Ns = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT Ns . append ( [ float ( x ) for x in inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) ] ) NEW_LINE if Ns [ n ] [ 1 ] > D : NEW_LINE INDENT if n != 0 : Ns [ n ] [ 0 ] = Ns [ n - 1 ] [ 0 ] + ( D - Ns [ n - 1 ] [ 1 ] ) / ( Ns [ n ] [ 1 ] - Ns [ n - 1 ] [ 1 ] ) * ( Ns [ n ] [ 0 ] - Ns [ n - 1 ] [ 0 ] ) NEW_LINE Ns [ n ] [ 1 ] = D NEW_LINE DEDENT DEDENT As = [ float ( x ) for x in inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) ] NEW_LINE Mx = [ 0 ] * A NEW_LINE for n in range ( N ) : NEW_LINE INDENT for a in range ( A ) : NEW_LINE INDENT Mx [ a ] = max ( Mx [ a ] , Ns [ n ] [ 0 ] - ( 2 * Ns [ n ] [ 1 ] / As [ a ] ) ** 0.5 ) NEW_LINE DEDENT DEDENT outp . write ( ' Case \u2581 # ' + str ( i ) + ' : \\n ' ) NEW_LINE for a in range ( A ) : NEW_LINE INDENT x = ( 2 * D / As [ a ] ) ** 0.5 + Mx [ a ] NEW_LINE outp . write ( str ( x ) + ' \\n ' ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "0", "code": "import sys NEW_LINE from fractions import Fraction NEW_LINE from math import sqrt NEW_LINE line = sys . stdin . readline ( ) NEW_LINE fields = line . split ( ) NEW_LINE assert len ( fields ) == 1 NEW_LINE ntc = int ( fields [ 0 ] ) NEW_LINE def solve ( d , a , other_car ) : NEW_LINE INDENT wait_time = Fraction ( 0 ) NEW_LINE first = True NEW_LINE for time , distance in other_car : NEW_LINE INDENT if distance > d : NEW_LINE INDENT if first : NEW_LINE INDENT break NEW_LINE DEDENT time = last_time + ( time - last_time ) * ( d - last_distance ) / ( distance - last_distance ) NEW_LINE distance = d NEW_LINE DEDENT first = False NEW_LINE arrival_time = sqrt ( 2 * distance / a ) NEW_LINE if arrival_time < time : NEW_LINE INDENT cur_wait_time = time - arrival_time NEW_LINE DEDENT else : NEW_LINE INDENT cur_wait_time = Fraction ( 0 ) NEW_LINE DEDENT if cur_wait_time > wait_time : NEW_LINE INDENT wait_time = cur_wait_time NEW_LINE DEDENT last_time , last_distance = time , distance NEW_LINE DEDENT arrival_time = sqrt ( 2 * d / a ) NEW_LINE return wait_time + arrival_time NEW_LINE DEDENT for tc in range ( 1 , ntc + 1 ) : NEW_LINE INDENT line = sys . stdin . readline ( ) NEW_LINE fields = line . split ( ) NEW_LINE assert len ( fields ) == 3 NEW_LINE d = Fraction ( fields [ 0 ] ) NEW_LINE n = int ( fields [ 1 ] ) NEW_LINE a = int ( fields [ 2 ] ) NEW_LINE other_car = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT line = sys . stdin . readline ( ) NEW_LINE fields = line . split ( ) NEW_LINE assert len ( fields ) == 2 NEW_LINE time = Fraction ( fields [ 0 ] ) NEW_LINE distance = Fraction ( fields [ 1 ] ) NEW_LINE other_car . append ( ( time , distance ) ) NEW_LINE DEDENT line = sys . stdin . readline ( ) NEW_LINE fields = line . split ( ) NEW_LINE assert len ( fields ) == a NEW_LINE print ( ' Case \u2581 # { 0 } : ' . format ( tc ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT accel = Fraction ( fields [ i ] ) NEW_LINE ans = solve ( d , accel , other_car ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["solve", "def solve ( d , a , other_car ) : NEW_LINE INDENT wait_time = Fraction ( 0 ) NEW_LINE first = True NEW_LINE for time , distance in other_car : NEW_LINE INDENT if distance > d : NEW_LINE INDENT if first : NEW_LINE INDENT break NEW_LINE DEDENT time = last_time + ( time - last_time ) * ( d - last_distance ) / ( distance - last_distance ) NEW_LINE distance = d NEW_LINE DEDENT first = False NEW_LINE arrival_time = sqrt ( 2 * distance / a ) NEW_LINE if arrival_time < time : NEW_LINE INDENT cur_wait_time = time - arrival_time NEW_LINE DEDENT else : NEW_LINE INDENT cur_wait_time = Fraction ( 0 ) NEW_LINE DEDENT if cur_wait_time > wait_time : NEW_LINE INDENT wait_time = cur_wait_time NEW_LINE DEDENT last_time , last_distance = time , distance NEW_LINE DEDENT arrival_time = sqrt ( 2 * d / a ) NEW_LINE return wait_time + arrival_time NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_51", "java": [{"id": "9", "code": "import java . io . * ; import java . util . Arrays ; import java . util . Scanner ; public class A { public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" A - small - attempt0 \u2581 ( 1 ) . in \" ) ) ; PrintWriter out = new PrintWriter ( \" a . out \" ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = in . nextInt ( ) ; Lev [ ] ls = new Lev [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ls [ i ] = new Lev ( ) ; ls [ i ] . i = i ; ls [ i ] . l = in . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { ls [ i ] . p = in . nextInt ( ) ; } Arrays . sort ( ls ) ; StringBuilder buf = new StringBuilder ( ) ; for ( Lev l : ls ) { buf . append ( \" \u2581 \" ) . append ( l . i ) ; } out . println ( \" Case \u2581 # \" + t + \" : \" + buf ) ; } out . close ( ) ; in . close ( ) ; } private static class Lev implements Comparable < Lev > { public int l , p , i ; public int compareTo ( Lev o ) { double q1 = Math . log ( ( 100. - p ) * 0.01 ) / l ; double q2 = Math . log ( ( 100. - o . p ) * 0.01 ) / o . l ; return Double . compare ( q1 , q2 ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( \" A - small - attempt0 \u2581 ( 1 ) . in \" ) ) ; PrintWriter out = new PrintWriter ( \" a . out \" ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = in . nextInt ( ) ; Lev [ ] ls = new Lev [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ls [ i ] = new Lev ( ) ; ls [ i ] . i = i ; ls [ i ] . l = in . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { ls [ i ] . p = in . nextInt ( ) ; } Arrays . sort ( ls ) ; StringBuilder buf = new StringBuilder ( ) ; for ( Lev l : ls ) { buf . append ( \" \u2581 \" ) . append ( l . i ) ; } out . println ( \" Case \u2581 # \" + t + \" : \" + buf ) ; } out . close ( ) ; in . close ( ) ; }"]], "functions_class": [["compareTo", "public int compareTo ( Lev o ) { double q1 = Math . log ( ( 100. - p ) * 0.01 ) / l ; double q2 = Math . log ( ( 100. - o . p ) * 0.01 ) / o . l ; return Double . compare ( q1 , q2 ) ; }"]]}, {"id": "10", "code": "import java . io . * ; import java . util . Arrays ; import java . util . Locale ; import java . util . StringTokenizer ; public class A { BufferedReader in ; StringTokenizer str ; PrintWriter out ; String SK ; String next ( ) throws IOException { while ( ( str == null ) || ( ! str . hasMoreTokens ( ) ) ) { SK = in . readLine ( ) ; if ( SK == null ) return null ; str = new StringTokenizer ( SK ) ; } return str . nextToken ( ) ; } int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } class Sob implements Comparable < Sob > { int t ; int p ; int num ; public int compareTo ( Sob o ) { return o . p * t - p * o . t ; } } void solve ( ) throws IOException { int n = nextInt ( ) ; Sob [ ] a = new Sob [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = new Sob ( ) ; a [ i ] . num = i ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] . t = nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] . p = nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) { out . print ( \" \u2581 \" + a [ i ] . num ) ; } out . println ( ) ; } void run ( ) throws IOException { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int t = nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \" ) ; solve ( ) ; } out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new A ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new A ( ) . run ( ) ; }"]], "functions_class": [["next", "String next ( ) throws IOException { while ( ( str == null ) || ( ! str . hasMoreTokens ( ) ) ) { SK = in . readLine ( ) ; if ( SK == null ) return null ; str = new StringTokenizer ( SK ) ; } return str . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; }"], ["compareTo", "public int compareTo ( Sob o ) { return o . p * t - p * o . t ; }"], ["solve", "void solve ( ) throws IOException { int n = nextInt ( ) ; Sob [ ] a = new Sob [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = new Sob ( ) ; a [ i ] . num = i ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] . t = nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] . p = nextInt ( ) ; } Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) { out . print ( \" \u2581 \" + a [ i ] . num ) ; } out . println ( ) ; }"], ["run", "void run ( ) throws IOException { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int t = nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \" ) ; solve ( ) ; } out . close ( ) ; }"]]}, {"id": "17", "code": "import java . util . * ; import java . io . * ; import java . math . * ; import java . awt . * ; public class A { public static Comparator < Point > cmp = new Comparator < Point > ( ) { public int compare ( Point a , Point b ) { if ( a . y > b . y ) return - 1 ; if ( a . y < b . y ) return 1 ; return a . x - b . x ; } } ; public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int T = scan . nextInt ( ) ; for ( int ca = 1 ; ca <= T ; ca ++ ) { int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) scan . nextInt ( ) ; Point [ ] a = new Point [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = new Point ( i , scan . nextInt ( ) ) ; Arrays . sort ( a , cmp ) ; System . out . print ( \" Case \u2581 # \" + ca + \" : \" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( \" \u2581 \" + a [ i ] . x ) ; System . out . println ( ) ; } } }", "functions_standalone": [[">", "public static Comparator < Point > cmp = new Comparator < Point > ( ) { public int compare ( Point a , Point b ) { if ( a . y > b . y ) return - 1 ; if ( a . y < b . y ) return 1 ; return a . x - b . x ; } }"], ["main", "public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int T = scan . nextInt ( ) ; for ( int ca = 1 ; ca <= T ; ca ++ ) { int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) scan . nextInt ( ) ; Point [ ] a = new Point [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = new Point ( i , scan . nextInt ( ) ) ; Arrays . sort ( a , cmp ) ; System . out . print ( \" Case \u2581 # \" + ca + \" : \" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( \" \u2581 \" + a [ i ] . x ) ; System . out . println ( ) ; } }"]], "functions_class": []}, {"id": "15", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main implements Runnable { public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; } public void run ( ) { try { run1 ( ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } } public void run1 ( ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int tN = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int tn = 0 ; tn < tN ; tn ++ ) { int n = sc . nextInt ( ) ; int [ ] p = new int [ n ] ; int [ ] len = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { len [ i ] = sc . nextInt ( ) ; } boolean [ ] oppa = new boolean [ n ] ; pw . print ( \" Case \u2581 # \" + ( tn + 1 ) + \" : \" ) ; c : for ( int i = 0 ; i < n ; i ++ ) { int be = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! oppa [ j ] ) { if ( be == - 1 || len [ j ] * p [ be ] > len [ be ] * p [ j ] ) { be = j ; } } } oppa [ be ] = true ; pw . print ( \" \u2581 \" + be ) ; } pw . println ( ) ; } pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new Thread ( new Main ( ) ) . start ( ) ; }"]], "functions_class": [["run", "public void run ( ) { try { run1 ( ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } }"], ["run1", "public void run1 ( ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; int tN = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int tn = 0 ; tn < tN ; tn ++ ) { int n = sc . nextInt ( ) ; int [ ] p = new int [ n ] ; int [ ] len = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { len [ i ] = sc . nextInt ( ) ; } boolean [ ] oppa = new boolean [ n ] ; pw . print ( \" Case \u2581 # \" + ( tn + 1 ) + \" : \" ) ; c : for ( int i = 0 ; i < n ; i ++ ) { int be = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! oppa [ j ] ) { if ( be == - 1 || len [ j ] * p [ be ] > len [ be ] * p [ j ] ) { be = j ; } } } oppa [ be ] = true ; pw . print ( \" \u2581 \" + be ) ; } pw . println ( ) ; } pw . close ( ) ; }"]]}, {"id": "5", "code": "import java . util . Arrays ; import java . util . Scanner ; public class A { static Scanner sc = new Scanner ( System . in ) ; static class Solver { int N ; int [ ] L , P ; void solve ( ) { N = sc . nextInt ( ) ; L = new int [ N ] ; P = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { L [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < N ; ++ i ) { P [ i ] = sc . nextInt ( ) ; } Stage [ ] stages = new Stage [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { stages [ i ] = new Stage ( L [ i ] , P [ i ] , i ) ; } Arrays . sort ( stages ) ; for ( int i = 0 ; i < N ; ++ i ) { System . out . print ( stages [ i ] . idx ) ; if ( i != N - 1 ) { System . out . print ( \" \u2581 \" ) ; } } System . out . println ( ) ; } } static class Stage implements Comparable < Stage > { int l , p , idx ; Stage ( int l , int p , int idx ) { this . l = l ; this . p = p ; this . idx = idx ; } public int compareTo ( Stage o ) { return o . l * o . p - this . l * this . p ; } } public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; Solver solver = new Solver ( ) ; solver . solve ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; Solver solver = new Solver ( ) ; solver . solve ( ) ; } }"]], "functions_class": [["solve", "void solve ( ) { N = sc . nextInt ( ) ; L = new int [ N ] ; P = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { L [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < N ; ++ i ) { P [ i ] = sc . nextInt ( ) ; } Stage [ ] stages = new Stage [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { stages [ i ] = new Stage ( L [ i ] , P [ i ] , i ) ; } Arrays . sort ( stages ) ; for ( int i = 0 ; i < N ; ++ i ) { System . out . print ( stages [ i ] . idx ) ; if ( i != N - 1 ) { System . out . print ( \" \u2581 \" ) ; } } System . out . println ( ) ; }"], ["Stage", "Stage ( int l , int p , int idx ) { this . l = l ; this . p = p ; this . idx = idx ; }"], ["compareTo", "public int compareTo ( Stage o ) { return o . l * o . p - this . l * this . p ; }"]]}], "python": [{"id": "9", "code": "from __future__ import division NEW_LINE import os NEW_LINE import sys NEW_LINE import operator NEW_LINE import string NEW_LINE import re NEW_LINE import time NEW_LINE from os . path import splitext NEW_LINE from copy import copy NEW_LINE from math import * NEW_LINE from operator import * NEW_LINE from collections import * NEW_LINE from itertools import * NEW_LINE from functools import * NEW_LINE try : NEW_LINE INDENT from do import report_working_on NEW_LINE DEDENT except ImportError : NEW_LINE INDENT report_working_on = lambda a , b : None NEW_LINE DEDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT fin = file ( sys . argv [ 1 ] , ' r ' ) NEW_LINE fout = file ( splitext ( sys . argv [ 1 ] ) [ 0 ] + ' . out ' , ' w + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT fin = sys . stdin NEW_LINE fout = sys . stdout NEW_LINE DEDENT def dorun ( ) : NEW_LINE INDENT cases = int ( fin . next ( ) ) NEW_LINE for case in xrange ( cases ) : NEW_LINE INDENT report_working_on ( case , cases ) NEW_LINE print >> fout , ' Case \u2581 # % d : \u2581 % s ' % ( 1 + case , solve ( fin ) ) NEW_LINE DEDENT else : NEW_LINE INDENT report_working_on ( 0 , 0 ) NEW_LINE DEDENT DEDENT def solve ( fin ) : NEW_LINE INDENT N = int ( fin . next ( ) . strip ( ) ) NEW_LINE Lx = map ( int , fin . next ( ) . split ( ) ) NEW_LINE Px = map ( int , fin . next ( ) . split ( ) ) NEW_LINE LL = list ( enumerate ( Px ) ) NEW_LINE LL . sort ( key = lambda a : - a [ 1 ] ) NEW_LINE return ' \u2581 ' . join ( str ( a [ 0 ] ) for a in LL ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : dorun ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( fin ) : NEW_LINE INDENT N = int ( fin . next ( ) . strip ( ) ) NEW_LINE Lx = map ( int , fin . next ( ) . split ( ) ) NEW_LINE Px = map ( int , fin . next ( ) . split ( ) ) NEW_LINE LL = list ( enumerate ( Px ) ) NEW_LINE LL . sort ( key = lambda a : - a [ 1 ] ) NEW_LINE return ' \u2581 ' . join ( str ( a [ 0 ] ) for a in LL ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "fin = open ( \" A - small - attempt0 . in \" , \" r \" ) NEW_LINE fout = open ( \" A . out \" , \" w \" ) NEW_LINE numcases = int ( fin . readline ( ) ) NEW_LINE numcases += 1 NEW_LINE for cas in xrange ( 1 , numcases ) : NEW_LINE INDENT fout . write ( \" Case \u2581 # \" + str ( cas ) + \" : \" ) NEW_LINE n = int ( fin . readline ( ) ) NEW_LINE l = map ( float , fin . readline ( ) . split ( ) ) NEW_LINE p = map ( float , fin . readline ( ) . split ( ) ) NEW_LINE q = [ p [ i ] / l [ i ] for i in xrange ( n ) ] NEW_LINE r = [ ( q [ i ] , - i ) for i in xrange ( n ) ] NEW_LINE r . sort ( ) NEW_LINE r . reverse ( ) NEW_LINE for i in r : NEW_LINE INDENT fout . write ( \" \u2581 \" + str ( - i [ 1 ] ) ) NEW_LINE DEDENT fout . write ( \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "testCount = int ( raw_input ( ) ) NEW_LINE for testIndex in range ( testCount ) : NEW_LINE INDENT ans = \" Case \u2581 # \" + str ( testIndex + 1 ) + \" : \u2581 \" NEW_LINE n = int ( raw_input ( ) ) NEW_LINE l = [ int ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE p = [ int ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a += [ [ i , 1.0 * p [ i ] / l [ i ] , l [ i ] ] ] NEW_LINE DEDENT a . sort ( key = lambda x : - x [ 1 ] ) NEW_LINE for i in a : NEW_LINE INDENT ans += str ( i [ 0 ] ) + \" \u2581 \" NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "f = open ( \" data . txt \" , ' r ' ) NEW_LINE g = open ( \" data1 . txt \" , ' w ' ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE l = [ int ( x ) for x in ( f . readline ( ) ) . split ( ) ] NEW_LINE p = [ int ( x ) for x in ( f . readline ( ) ) . split ( ) ] NEW_LINE result = 0 NEW_LINE m = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT m . append ( [ 100 - p [ j ] , j ] ) NEW_LINE DEDENT m . sort ( ) NEW_LINE result = str ( m [ 0 ] [ 1 ] ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT result = result + \" \u2581 \" + str ( m [ j ] [ 1 ] ) NEW_LINE DEDENT string = \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + str ( result ) + \" \\n \" NEW_LINE g . write ( string ) NEW_LINE DEDENT f . close ( ) NEW_LINE g . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "13", "code": "import collections NEW_LINE import sys NEW_LINE bak = sys . stdin NEW_LINE sys . stdin = open ( ' input . txt ' ) NEW_LINE for kase in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \" . format ( kase + 1 ) , end = \" \" ) NEW_LINE n = int ( input ( ) ) NEW_LINE l = input ( ) NEW_LINE p = input ( ) . split ( ) NEW_LINE p = [ int ( i ) for i in p ] NEW_LINE s = [ ( 100 - p [ i ] , i ) for i in range ( len ( p ) ) ] NEW_LINE s . sort ( ) NEW_LINE ans = \" \" NEW_LINE for i in s : NEW_LINE INDENT ans += ' \u2581 ' + str ( i [ 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT sys . stdin = bak NEW_LINE input ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_12_02", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class Dancing { public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { StringTokenizer st = new StringTokenizer ( in . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int S = Integer . parseInt ( st . nextToken ( ) ) ; int p = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] scores = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { scores [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } int ans = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( p == 0 ) { ans ++ ; continue ; } if ( scores [ j ] == 0 ) continue ; if ( scores [ j ] / 3 >= p ) { ans ++ ; } else if ( scores [ j ] / 3 == p - 1 && scores [ j ] % 3 > 0 ) { ans ++ ; } else if ( scores [ j ] / 3 == p - 1 && scores [ j ] % 3 == 0 && S > 0 ) { ans ++ ; S -- ; } else if ( scores [ j ] / 3 == p - 2 && scores [ j ] % 3 == 2 && S > 0 ) { ans ++ ; S -- ; } } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { StringTokenizer st = new StringTokenizer ( in . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int S = Integer . parseInt ( st . nextToken ( ) ) ; int p = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] scores = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { scores [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } int ans = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( p == 0 ) { ans ++ ; continue ; } if ( scores [ j ] == 0 ) continue ; if ( scores [ j ] / 3 >= p ) { ans ++ ; } else if ( scores [ j ] / 3 == p - 1 && scores [ j ] % 3 > 0 ) { ans ++ ; } else if ( scores [ j ] / 3 == p - 1 && scores [ j ] % 3 == 0 && S > 0 ) { ans ++ ; S -- ; } else if ( scores [ j ] / 3 == p - 2 && scores [ j ] % 3 == 2 && S > 0 ) { ans ++ ; S -- ; } } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans ) ; } }"]], "functions_class": []}, {"id": "13", "code": "package j2012qualifier ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class B { public static String inputDirectory = \" src / j2012qualifier / \" ; public static String inputFile = \" B . in \" ; public static String outputFile = \" B . out \" ; public static PrintWriter output ; public static void main ( String [ ] args ) throws FileNotFoundException { Scanner s = new Scanner ( new File ( inputDirectory + inputFile ) ) ; output = new PrintWriter ( new File ( inputDirectory + outputFile ) ) ; int cases = s . nextInt ( ) ; for ( int Case = 1 ; Case <= cases ; Case ++ ) { s . nextLine ( ) ; int googlers = s . nextInt ( ) ; int maxSupriseScores = s . nextInt ( ) ; int targetScore = s . nextInt ( ) ; int normalScores = 0 ; int surpriseScores = 0 ; for ( int i = 0 ; i < googlers ; i ++ ) { int score = s . nextInt ( ) ; if ( targetScore > score ) { continue ; } int otherScore = ( score - targetScore ) / 2 ; if ( otherScore >= targetScore - 1 ) { normalScores ++ ; } else if ( otherScore >= targetScore - 2 ) { surpriseScores ++ ; } } int answer = normalScores + Math . min ( surpriseScores , maxSupriseScores ) ; out ( \" Case \u2581 # \" + Case + \" : \u2581 \" + answer ) ; } output . flush ( ) ; } public static void out ( String s ) { output . println ( s ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner s = new Scanner ( new File ( inputDirectory + inputFile ) ) ; output = new PrintWriter ( new File ( inputDirectory + outputFile ) ) ; int cases = s . nextInt ( ) ; for ( int Case = 1 ; Case <= cases ; Case ++ ) { s . nextLine ( ) ; int googlers = s . nextInt ( ) ; int maxSupriseScores = s . nextInt ( ) ; int targetScore = s . nextInt ( ) ; int normalScores = 0 ; int surpriseScores = 0 ; for ( int i = 0 ; i < googlers ; i ++ ) { int score = s . nextInt ( ) ; if ( targetScore > score ) { continue ; } int otherScore = ( score - targetScore ) / 2 ; if ( otherScore >= targetScore - 1 ) { normalScores ++ ; } else if ( otherScore >= targetScore - 2 ) { surpriseScores ++ ; } } int answer = normalScores + Math . min ( surpriseScores , maxSupriseScores ) ; out ( \" Case \u2581 # \" + Case + \" : \u2581 \" + answer ) ; } output . flush ( ) ; }"], ["out", "public static void out ( String s ) { output . println ( s ) ; }"]], "functions_class": []}, {"id": "3", "code": "import java . io . * ; import java . util . * ; public class CodeJam2012_Q_B { public int calc ( int N , int S , int p , int [ ] score ) { int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( score [ i ] >= p + Math . max ( p - 1 , 0 ) * 2 ) { cnt ++ ; } else if ( score [ i ] >= p + Math . max ( p - 2 , 0 ) * 2 && S > 0 ) { cnt ++ ; S -- ; } } return cnt ; } public static void main ( String [ ] args ) { try { ( new CodeJam2012_Q_B ( ) ) . exec ( \" B - large . in \" , \"2012 _ Q _ B - large . out \" ) ; } catch ( Exception ex ) { } } public final void exec ( String inFileName , String outFileName ) throws Exception { BufferedReader inReader = new BufferedReader ( new FileReader ( inFileName ) ) ; PrintWriter outWriter = new PrintWriter ( new BufferedWriter ( new FileWriter ( outFileName ) ) ) ; int caseNums = 0 ; caseNums = Integer . parseInt ( inReader . readLine ( ) ) ; for ( int i = 0 ; i < caseNums ; i ++ ) { String [ ] input = inReader . readLine ( ) . split ( \" \u2581 \" ) ; int N = Integer . valueOf ( input [ 0 ] ) ; int S = Integer . valueOf ( input [ 1 ] ) ; int p = Integer . valueOf ( input [ 2 ] ) ; int [ ] score = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) score [ j ] = Integer . valueOf ( input [ j + 3 ] ) ; int outStr = calc ( N , S , p , score ) ; String fmtOutStr = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + outStr ; outWriter . println ( fmtOutStr ) ; System . out . println ( fmtOutStr ) ; } System . out . println ( caseNums + \" \u2581 cases \u2581 complete \" ) ; outWriter . close ( ) ; inReader . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { ( new CodeJam2012_Q_B ( ) ) . exec ( \" B - large . in \" , \"2012 _ Q _ B - large . out \" ) ; } catch ( Exception ex ) { } }"]], "functions_class": [["calc", "public int calc ( int N , int S , int p , int [ ] score ) { int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( score [ i ] >= p + Math . max ( p - 1 , 0 ) * 2 ) { cnt ++ ; } else if ( score [ i ] >= p + Math . max ( p - 2 , 0 ) * 2 && S > 0 ) { cnt ++ ; S -- ; } } return cnt ; }"], ["exec", "public final void exec ( String inFileName , String outFileName ) throws Exception { BufferedReader inReader = new BufferedReader ( new FileReader ( inFileName ) ) ; PrintWriter outWriter = new PrintWriter ( new BufferedWriter ( new FileWriter ( outFileName ) ) ) ; int caseNums = 0 ; caseNums = Integer . parseInt ( inReader . readLine ( ) ) ; for ( int i = 0 ; i < caseNums ; i ++ ) { String [ ] input = inReader . readLine ( ) . split ( \" \u2581 \" ) ; int N = Integer . valueOf ( input [ 0 ] ) ; int S = Integer . valueOf ( input [ 1 ] ) ; int p = Integer . valueOf ( input [ 2 ] ) ; int [ ] score = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) score [ j ] = Integer . valueOf ( input [ j + 3 ] ) ; int outStr = calc ( N , S , p , score ) ; String fmtOutStr = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + outStr ; outWriter . println ( fmtOutStr ) ; System . out . println ( fmtOutStr ) ; } System . out . println ( caseNums + \" \u2581 cases \u2581 complete \" ) ; outWriter . close ( ) ; inReader . close ( ) ; }"]]}, {"id": "5", "code": "import static java . lang . Double . parseDouble ; import static java . lang . Integer . parseInt ; import static java . lang . Long . parseLong ; import static java . lang . System . exit ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class B { static BufferedReader in ; static PrintWriter out ; static StringTokenizer tok ; static int test ; static void solve ( ) throws Exception { int n = nextInt ( ) ; int s = nextInt ( ) ; int p = nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int t = nextInt ( ) ; if ( ( t + 2 ) / 3 >= p ) { ++ ans ; } else if ( s > 0 && t > 0 && ( t + 4 ) / 3 >= p ) { -- s ; ++ ans ; } } printCase ( ) ; out . println ( ans ) ; } static void printCase ( ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; } static void printlnCase ( ) { out . println ( \" Case \u2581 # \" + test + \" : \" ) ; } static int nextInt ( ) throws IOException { return parseInt ( next ( ) ) ; } static long nextLong ( ) throws IOException { return parseLong ( next ( ) ) ; } static double nextDouble ( ) throws IOException { return parseDouble ( next ( ) ) ; } static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) ) ; } return tok . nextToken ( ) ; } public static void main ( String [ ] args ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int tests = nextInt ( ) ; for ( test = 1 ; test <= tests ; test ++ ) { solve ( ) ; } in . close ( ) ; out . close ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; exit ( 1 ) ; } } }", "functions_standalone": [["solve", "static void solve ( ) throws Exception { int n = nextInt ( ) ; int s = nextInt ( ) ; int p = nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int t = nextInt ( ) ; if ( ( t + 2 ) / 3 >= p ) { ++ ans ; } else if ( s > 0 && t > 0 && ( t + 4 ) / 3 >= p ) { -- s ; ++ ans ; } } printCase ( ) ; out . println ( ans ) ; }"], ["printCase", "static void printCase ( ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; }"], ["printlnCase", "static void printlnCase ( ) { out . println ( \" Case \u2581 # \" + test + \" : \" ) ; }"], ["nextInt", "static int nextInt ( ) throws IOException { return parseInt ( next ( ) ) ; }"], ["nextLong", "static long nextLong ( ) throws IOException { return parseLong ( next ( ) ) ; }"], ["nextDouble", "static double nextDouble ( ) throws IOException { return parseDouble ( next ( ) ) ; }"], ["next", "static String next ( ) throws IOException { while ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) ) ; } return tok . nextToken ( ) ; }"], ["main", "public static void main ( String [ ] args ) { try { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int tests = nextInt ( ) ; for ( test = 1 ; test <= tests ; test ++ ) { solve ( ) ; } in . close ( ) ; out . close ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; exit ( 1 ) ; } }"]], "functions_class": []}, {"id": "12", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; public class codejamp2 { public static char [ ] map ; public static void main ( String [ ] args ) throws IOException { readFile ( ) ; } public static String getResult ( String input ) { int resultInt = 0 ; String [ ] splitResult = input . split ( \" \u2581 \" ) ; int dancerCount = Integer . parseInt ( splitResult [ 0 ] ) ; int suprising = Integer . parseInt ( splitResult [ 1 ] ) ; int max = Integer . parseInt ( splitResult [ 2 ] ) ; for ( int i = 3 ; i < dancerCount + 3 ; i ++ ) { int current = Integer . parseInt ( splitResult [ i ] ) ; int ave = current / 3 ; int remain = current - 3 * ave ; int currentmax = ave + remain ; if ( remain == 0 && ( max - currentmax == 1 ) && current != 0 ) { if ( suprising > 0 ) { suprising -- ; resultInt ++ ; } } if ( currentmax >= max ) { if ( remain <= 1 ) { resultInt ++ ; } else if ( remain == 2 ) { if ( max - ave <= 1 ) { resultInt ++ ; } else if ( suprising > 0 ) { suprising -- ; resultInt ++ ; } } } } return \" \" + resultInt ; } public static void readFile ( ) throws IOException { FileWriter fstream = new FileWriter ( \" out . txt \" ) ; BufferedWriter out = new BufferedWriter ( fstream ) ; FileReader input = new FileReader ( \" in . txt \" ) ; BufferedReader bufRead = new BufferedReader ( input ) ; String line = bufRead . readLine ( ) ; String current = getResult ( line ) ; int i = 1 ; out . write ( \" Case \u2581 # \" + i + \" : \u2581 \" + current ) ; line = bufRead . readLine ( ) ; while ( line != null ) { i ++ ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + getResult ( line ) ) ; out . write ( ' \\n ' + \" Case \u2581 # \" + i + \" : \u2581 \" + getResult ( line ) ) ; line = bufRead . readLine ( ) ; } bufRead . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { readFile ( ) ; }"], ["getResult", "public static String getResult ( String input ) { int resultInt = 0 ; String [ ] splitResult = input . split ( \" \u2581 \" ) ; int dancerCount = Integer . parseInt ( splitResult [ 0 ] ) ; int suprising = Integer . parseInt ( splitResult [ 1 ] ) ; int max = Integer . parseInt ( splitResult [ 2 ] ) ; for ( int i = 3 ; i < dancerCount + 3 ; i ++ ) { int current = Integer . parseInt ( splitResult [ i ] ) ; int ave = current / 3 ; int remain = current - 3 * ave ; int currentmax = ave + remain ; if ( remain == 0 && ( max - currentmax == 1 ) && current != 0 ) { if ( suprising > 0 ) { suprising -- ; resultInt ++ ; } } if ( currentmax >= max ) { if ( remain <= 1 ) { resultInt ++ ; } else if ( remain == 2 ) { if ( max - ave <= 1 ) { resultInt ++ ; } else if ( suprising > 0 ) { suprising -- ; resultInt ++ ; } } } } return \" \" + resultInt ; }"], ["readFile", "public static void readFile ( ) throws IOException { FileWriter fstream = new FileWriter ( \" out . txt \" ) ; BufferedWriter out = new BufferedWriter ( fstream ) ; FileReader input = new FileReader ( \" in . txt \" ) ; BufferedReader bufRead = new BufferedReader ( input ) ; String line = bufRead . readLine ( ) ; String current = getResult ( line ) ; int i = 1 ; out . write ( \" Case \u2581 # \" + i + \" : \u2581 \" + current ) ; line = bufRead . readLine ( ) ; while ( line != null ) { i ++ ; System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + getResult ( line ) ) ; out . write ( ' \\n ' + \" Case \u2581 # \" + i + \" : \u2581 \" + getResult ( line ) ) ; line = bufRead . readLine ( ) ; } bufRead . close ( ) ; out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "7", "code": "import sys NEW_LINE def gethighest ( t ) : NEW_LINE INDENT n , k = t // 3 , t % 3 NEW_LINE if n == 0 : NEW_LINE INDENT return min ( 1 , k ) , k NEW_LINE DEDENT elif n == 10 : NEW_LINE INDENT return 10 , 10 NEW_LINE DEDENT elif n == 9 : NEW_LINE INDENT return n + ( k != 0 ) , 10 NEW_LINE DEDENT else : NEW_LINE INDENT return n + ( k != 0 ) , n + 1 + ( k == 2 ) NEW_LINE DEDENT DEDENT def work ( s ) : NEW_LINE INDENT s = list ( map ( int , s . split ( ) ) ) NEW_LINE N = s [ 0 ] NEW_LINE S = s [ 1 ] NEW_LINE p = s [ 2 ] NEW_LINE T = s [ 3 : ] NEW_LINE assert ( len ( T ) == N ) NEW_LINE BH = 0 NEW_LINE OH = 0 NEW_LINE BL = 0 NEW_LINE for t in T : NEW_LINE INDENT nh , sh = gethighest ( t ) NEW_LINE if nh >= p : NEW_LINE INDENT BH += 1 NEW_LINE DEDENT elif sh >= p : NEW_LINE INDENT OH += 1 NEW_LINE DEDENT else : NEW_LINE INDENT BL += 1 NEW_LINE DEDENT DEDENT return ( BH + min ( OH , S ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT s = work ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , s ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["gethighest", "def gethighest ( t ) : NEW_LINE INDENT n , k = t // 3 , t % 3 NEW_LINE if n == 0 : NEW_LINE INDENT return min ( 1 , k ) , k NEW_LINE DEDENT elif n == 10 : NEW_LINE INDENT return 10 , 10 NEW_LINE DEDENT elif n == 9 : NEW_LINE INDENT return n + ( k != 0 ) , 10 NEW_LINE DEDENT else : NEW_LINE INDENT return n + ( k != 0 ) , n + 1 + ( k == 2 ) NEW_LINE DEDENT DEDENT"], ["work", "def work ( s ) : NEW_LINE INDENT s = list ( map ( int , s . split ( ) ) ) NEW_LINE N = s [ 0 ] NEW_LINE S = s [ 1 ] NEW_LINE p = s [ 2 ] NEW_LINE T = s [ 3 : ] NEW_LINE assert ( len ( T ) == N ) NEW_LINE BH = 0 NEW_LINE OH = 0 NEW_LINE BL = 0 NEW_LINE for t in T : NEW_LINE INDENT nh , sh = gethighest ( t ) NEW_LINE if nh >= p : NEW_LINE INDENT BH += 1 NEW_LINE DEDENT elif sh >= p : NEW_LINE INDENT OH += 1 NEW_LINE DEDENT else : NEW_LINE INDENT BL += 1 NEW_LINE DEDENT DEDENT return ( BH + min ( OH , S ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "f = open ( ' B - large . in ' , ' r ' ) NEW_LINE g = open ( ' resultBlarge . txt ' , ' w ' ) NEW_LINE T = int ( f . next ( ) . strip ( ) ) NEW_LINE for i in xrange ( 1 , 1 + T ) : NEW_LINE INDENT s = map ( int , f . next ( ) . strip ( ) . split ( ) ) NEW_LINE N = s [ 0 ] NEW_LINE S = s [ 1 ] NEW_LINE p = s [ 2 ] NEW_LINE scores = s [ 3 : ] NEW_LINE if p >= 2 : NEW_LINE INDENT solid_score = 3 * p - 2 NEW_LINE surprise_score = 3 * p - 4 NEW_LINE DEDENT elif p == 1 : NEW_LINE INDENT solid_score = 1 NEW_LINE surprise_score = 1 NEW_LINE DEDENT elif p == 0 : NEW_LINE INDENT solid_score = 0 NEW_LINE surprise_score = 0 NEW_LINE DEDENT solid = sum ( sc >= solid_score for sc in scores ) NEW_LINE surprise = sum ( sc >= surprise_score for sc in scores ) - solid NEW_LINE res = solid + min ( surprise , S ) NEW_LINE g . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 ' + str ( res ) + ' \\n ' ) NEW_LINE DEDENT g . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "with open ( ' B - large . in ' , ' r ' ) as fin : NEW_LINE INDENT with open ( ' output . txt ' , ' w ' ) as fout : NEW_LINE INDENT numcases = int ( fin . readline ( ) ) NEW_LINE for i in range ( 1 , numcases + 1 ) : NEW_LINE INDENT line = [ int ( j ) for j in fin . readline ( ) . split ( ) ] NEW_LINE surprising = line [ 1 ] NEW_LINE minscore = line [ 2 ] NEW_LINE oknum = 0 NEW_LINE needsSurprising = 0 NEW_LINE for j in line [ 3 : ] : NEW_LINE INDENT d = j / 3 NEW_LINE m = j % 3 NEW_LINE if m == 0 : NEW_LINE INDENT if d >= minscore : NEW_LINE INDENT oknum += 1 NEW_LINE DEDENT elif d >= minscore - 1 and d > 0 : NEW_LINE INDENT needsSurprising += 1 NEW_LINE DEDENT DEDENT elif m == 1 : NEW_LINE INDENT if d >= minscore - 1 : NEW_LINE INDENT oknum += 1 NEW_LINE DEDENT DEDENT elif m == 2 : NEW_LINE INDENT if d >= minscore - 1 : NEW_LINE INDENT oknum += 1 NEW_LINE DEDENT elif d >= minscore - 2 : NEW_LINE INDENT needsSurprising += 1 NEW_LINE DEDENT DEDENT DEDENT fout . write ( \" Case \u2581 # \" ) NEW_LINE fout . write ( str ( i ) ) NEW_LINE fout . write ( \" : \u2581 \" ) NEW_LINE fout . write ( str ( oknum + min ( surprising , needsSurprising ) ) ) NEW_LINE fout . write ( ' \\n ' ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "12", "code": "import sys NEW_LINE def ints ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield int ( word ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT get_int = ints ( ) NEW_LINE T = next ( get_int ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N = next ( get_int ) NEW_LINE S = next ( get_int ) NEW_LINE p = next ( get_int ) NEW_LINE total = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = next ( get_int ) NEW_LINE if val > 3 * p - 3 : total = total + 1 NEW_LINE elif val > 3 * p - 5 and S > 0 and val > 0 : NEW_LINE INDENT total = total + 1 NEW_LINE S = S - 1 NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # \" , t + 1 , \" : \u2581 \" , total , sep = ' ' ) NEW_LINE DEDENT", "functions_standalone": [["ints", "def ints ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield int ( word ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_11", "java": [{"id": "9", "code": "import java . util . * ; import java . io . * ; import java . math . * ; import java . awt . * ; import static java . lang . Math . * ; import static java . lang . Integer . parseInt ; import static java . lang . Double . parseDouble ; import static java . lang . Long . parseLong ; import static java . lang . System . * ; import static java . util . Arrays . * ; import static java . util . Collection . * ; public class A { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int T = parseInt ( br . readLine ( ) ) ; for ( int t = 0 ; t ++ < T ; ) { String [ ] line = br . readLine ( ) . split ( \" \u2581 \" ) ; int A = parseInt ( line [ 0 ] ) , B = parseInt ( line [ 1 ] ) ; line = br . readLine ( ) . split ( \" \u2581 \" ) ; double [ ] P = new double [ A + 1 ] ; P [ 0 ] = 1 ; for ( int a = 0 ; a < A ; a ++ ) P [ a + 1 ] = parseDouble ( line [ a ] ) * P [ a ] ; double best = 2 + B ; for ( int a = 0 ; a <= A ; a ++ ) best = min ( best , 2 * a + ( B - A ) + 1 + ( 1 - P [ A - a ] ) * ( B + 1 ) ) ; out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + best ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int T = parseInt ( br . readLine ( ) ) ; for ( int t = 0 ; t ++ < T ; ) { String [ ] line = br . readLine ( ) . split ( \" \u2581 \" ) ; int A = parseInt ( line [ 0 ] ) , B = parseInt ( line [ 1 ] ) ; line = br . readLine ( ) . split ( \" \u2581 \" ) ; double [ ] P = new double [ A + 1 ] ; P [ 0 ] = 1 ; for ( int a = 0 ; a < A ; a ++ ) P [ a + 1 ] = parseDouble ( line [ a ] ) * P [ a ] ; double best = 2 + B ; for ( int a = 0 ; a <= A ; a ++ ) best = min ( best , 2 * a + ( B - A ) + 1 + ( 1 - P [ A - a ] ) * ( B + 1 ) ) ; out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + best ) ; } }"]], "functions_class": []}, {"id": "8", "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int inputs = in . nextInt ( ) ; Q : for ( int _ = 1 ; _ <= inputs ; _ ++ ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; double exp = 2 + b ; double [ ] prob = new double [ a + 1 ] ; prob [ 0 ] = 1 ; for ( int i = 0 ; i < a ; i ++ ) { prob [ i + 1 ] = prob [ i ] * ( in . nextDouble ( ) ) ; } double exp2 = prob [ a ] * ( b - a + 1 ) + ( 1 - prob [ a ] ) * ( 2 * b - a + 2 ) ; if ( exp2 < exp ) exp = exp2 ; exp2 = 0 ; for ( int i = 0 ; i < a ; i ++ ) { exp2 = prob [ i ] * ( 2 * ( a - i ) + ( b - a ) + 1 ) + ( 1 - prob [ i ] ) * ( ( 2 * ( a - i ) + ( b - a ) + 1 ) + b + 1 ) ; if ( exp2 < exp ) exp = exp2 ; } System . out . printf ( \" Case \u2581 # \" + _ + \" : \u2581 % .6f \\n \" , exp ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int inputs = in . nextInt ( ) ; Q : for ( int _ = 1 ; _ <= inputs ; _ ++ ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; double exp = 2 + b ; double [ ] prob = new double [ a + 1 ] ; prob [ 0 ] = 1 ; for ( int i = 0 ; i < a ; i ++ ) { prob [ i + 1 ] = prob [ i ] * ( in . nextDouble ( ) ) ; } double exp2 = prob [ a ] * ( b - a + 1 ) + ( 1 - prob [ a ] ) * ( 2 * b - a + 2 ) ; if ( exp2 < exp ) exp = exp2 ; exp2 = 0 ; for ( int i = 0 ; i < a ; i ++ ) { exp2 = prob [ i ] * ( 2 * ( a - i ) + ( b - a ) + 1 ) + ( 1 - prob [ i ] ) * ( ( 2 * ( a - i ) + ( b - a ) + 1 ) + b + 1 ) ; if ( exp2 < exp ) exp = exp2 ; } System . out . printf ( \" Case \u2581 # \" + _ + \" : \u2581 % .6f \\n \" , exp ) ; } }"]], "functions_class": []}, {"id": "2", "code": "import java . io . * ; import java . util . * ; public class PasswordProblem { void solve ( ) throws Exception { int a = nextInt ( ) ; int b = nextInt ( ) ; double [ ] p = new double [ a ] ; for ( int i = 0 ; i < a ; i ++ ) { p [ i ] = nextDouble ( ) ; } double [ ] prob = p . clone ( ) ; for ( int i = 1 ; i < a ; i ++ ) { prob [ i ] = prob [ i - 1 ] * prob [ i ] ; } double ans = b + 2 ; for ( int i = a - 1 ; i >= 0 ; i -- ) { double curAns = ( a - i - 1 ) + ( b - i - 1 ) + 1 + ( 1 - prob [ i ] ) * ( b + 1 ) ; ans = Math . min ( ans , curAns ) ; } out . println ( ans ) ; } void run ( ) { try { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int tests = nextInt ( ) ; for ( int i = 0 ; i < tests ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solve ( ) ; } out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } BufferedReader in ; StringTokenizer st ; PrintWriter out ; final String filename = new String ( \" PasswordProblem \" ) . toLowerCase ( ) ; String nextToken ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( in . readLine ( ) ) ; return st . nextToken ( ) ; } int nextInt ( ) throws Exception { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) throws Exception { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) throws Exception { return Double . parseDouble ( nextToken ( ) ) ; } public static void main ( String [ ] args ) { new PasswordProblem ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new PasswordProblem ( ) . run ( ) ; }"]], "functions_class": [["solve", "void solve ( ) throws Exception { int a = nextInt ( ) ; int b = nextInt ( ) ; double [ ] p = new double [ a ] ; for ( int i = 0 ; i < a ; i ++ ) { p [ i ] = nextDouble ( ) ; } double [ ] prob = p . clone ( ) ; for ( int i = 1 ; i < a ; i ++ ) { prob [ i ] = prob [ i - 1 ] * prob [ i ] ; } double ans = b + 2 ; for ( int i = a - 1 ; i >= 0 ; i -- ) { double curAns = ( a - i - 1 ) + ( b - i - 1 ) + 1 + ( 1 - prob [ i ] ) * ( b + 1 ) ; ans = Math . min ( ans , curAns ) ; } out . println ( ans ) ; }"], ["run", "void run ( ) { try { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int tests = nextInt ( ) ; for ( int i = 0 ; i < tests ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solve ( ) ; } out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }"], ["nextToken", "String nextToken ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( in . readLine ( ) ) ; return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws Exception { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws Exception { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws Exception { return Double . parseDouble ( nextToken ( ) ) ; }"]]}, {"id": "18", "code": "import java . math . BigDecimal ; import java . math . MathContext ; import java . math . RoundingMode ; import java . util . Arrays ; import java . util . Scanner ; public class A { private static Scanner sc ; private static long start ; public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 0 ; i < t ; i ++ ) { start = System . currentTimeMillis ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , exec ( ) ) ; long end = System . currentTimeMillis ( ) ; } } private static final MathContext ROUND_CONTEXT = new MathContext ( 8 , RoundingMode . HALF_EVEN ) ; public static String exec ( ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; BigDecimal [ ] bd = new BigDecimal [ a ] ; for ( int i = 0 ; i < a ; i ++ ) bd [ i ] = new BigDecimal ( sc . next ( ) ) ; BigDecimal [ ] rs = new BigDecimal [ a + 2 ] ; rs [ 0 ] = new BigDecimal ( b + 2 ) ; int backspacesNeeded = a ; double runningChance = 1.0 ; for ( int i = 0 ; i < a ; i ++ ) { int charsNeededOnSuccess = backspacesNeeded + b - i + 1 ; int charsNeededOnFail = charsNeededOnSuccess + b + 1 ; double onSuccess = runningChance * charsNeededOnSuccess ; double onFail = ( 1.0 - runningChance ) * charsNeededOnFail ; rs [ i + 1 ] = new BigDecimal ( onSuccess + onFail ) ; runningChance *= bd [ i ] . doubleValue ( ) ; backspacesNeeded -- ; } rs [ a + 1 ] = new BigDecimal ( ( runningChance * ( b - a + 1 ) ) + ( ( 1.0 - runningChance ) * ( b - a + 1 + b + 1 ) ) ) ; Arrays . sort ( rs ) ; BigDecimal result = rs [ 0 ] ; return String . format ( \" % .06f \" , result ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 0 ; i < t ; i ++ ) { start = System . currentTimeMillis ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , exec ( ) ) ; long end = System . currentTimeMillis ( ) ; } }"], ["exec", "public static String exec ( ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; BigDecimal [ ] bd = new BigDecimal [ a ] ; for ( int i = 0 ; i < a ; i ++ ) bd [ i ] = new BigDecimal ( sc . next ( ) ) ; BigDecimal [ ] rs = new BigDecimal [ a + 2 ] ; rs [ 0 ] = new BigDecimal ( b + 2 ) ; int backspacesNeeded = a ; double runningChance = 1.0 ; for ( int i = 0 ; i < a ; i ++ ) { int charsNeededOnSuccess = backspacesNeeded + b - i + 1 ; int charsNeededOnFail = charsNeededOnSuccess + b + 1 ; double onSuccess = runningChance * charsNeededOnSuccess ; double onFail = ( 1.0 - runningChance ) * charsNeededOnFail ; rs [ i + 1 ] = new BigDecimal ( onSuccess + onFail ) ; runningChance *= bd [ i ] . doubleValue ( ) ; backspacesNeeded -- ; } rs [ a + 1 ] = new BigDecimal ( ( runningChance * ( b - a + 1 ) ) + ( ( 1.0 - runningChance ) * ( b - a + 1 + b + 1 ) ) ) ; Arrays . sort ( rs ) ; BigDecimal result = rs [ 0 ] ; return String . format ( \" % .06f \" , result ) ; }"]], "functions_class": []}, {"id": "14", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Scanner ; public class A { static double [ ] logP = new double [ 1 << 17 ] ; public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; int T = s . nextInt ( ) ; for ( int tc = 1 ; tc <= T ; tc ++ ) { out . print ( \" Case \u2581 # \" + tc + \" : \u2581 \" ) ; int A = s . nextInt ( ) , B = s . nextInt ( ) ; double best = A + B + 1 ; logP [ 0 ] = Math . log ( s . nextDouble ( ) ) ; best = Math . min ( best , ( 2 * ( A - 1 ) + ( B - A ) + 1 ) + ( B + 1 ) - ( B + 1 ) * Math . exp ( logP [ 0 ] ) ) ; for ( int i = 1 ; i < A ; i ++ ) { logP [ i ] = logP [ i - 1 ] + Math . log ( s . nextDouble ( ) ) ; best = Math . min ( best , ( 2 * ( A - 1 - i ) + ( B - A ) + 1 ) + ( B + 1 ) - ( B + 1 ) * Math . exp ( logP [ i ] ) ) ; } best = Math . min ( best , B + 2 ) ; out . println ( best ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; int T = s . nextInt ( ) ; for ( int tc = 1 ; tc <= T ; tc ++ ) { out . print ( \" Case \u2581 # \" + tc + \" : \u2581 \" ) ; int A = s . nextInt ( ) , B = s . nextInt ( ) ; double best = A + B + 1 ; logP [ 0 ] = Math . log ( s . nextDouble ( ) ) ; best = Math . min ( best , ( 2 * ( A - 1 ) + ( B - A ) + 1 ) + ( B + 1 ) - ( B + 1 ) * Math . exp ( logP [ 0 ] ) ) ; for ( int i = 1 ; i < A ; i ++ ) { logP [ i ] = logP [ i - 1 ] + Math . log ( s . nextDouble ( ) ) ; best = Math . min ( best , ( 2 * ( A - 1 - i ) + ( B - A ) + 1 ) + ( B + 1 ) - ( B + 1 ) * Math . exp ( logP [ i ] ) ) ; } best = Math . min ( best , B + 2 ) ; out . println ( best ) ; } out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "testCount = int ( raw_input ( ) ) NEW_LINE for testIndex in range ( testCount ) : NEW_LINE INDENT ans = \" Case \u2581 # \" + str ( testIndex + 1 ) + \" : \u2581 \" NEW_LINE n , m = [ int ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE p = [ float ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE minType = m + 1.0 NEW_LINE p1 = reduce ( lambda x , y : x * y , p , 1.0 ) NEW_LINE type = ( m - n ) * p1 + ( m - n + 1 + m ) * ( 1 - p1 ) NEW_LINE minType = min ( type , minType ) NEW_LINE p1 = 1.0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p1 *= p [ i - 1 ] NEW_LINE type = ( n - i + m - i ) * p1 + ( n - i + m - i + 1 + m ) * ( 1 - p1 ) NEW_LINE minType = min ( type , minType ) NEW_LINE DEDENT print ( ans + str ( minType + 1.0 ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "with open ( ' A - large . in ' , ' r ' ) as fin : NEW_LINE INDENT with open ( ' output . txt ' , ' w ' ) as fout : NEW_LINE INDENT numcases = int ( fin . readline ( ) ) NEW_LINE for i in range ( 1 , numcases + 1 ) : NEW_LINE INDENT line = [ int ( j ) for j in fin . readline ( ) . split ( ) ] NEW_LINE charstyped = line [ 0 ] NEW_LINE numchars = line [ 1 ] NEW_LINE line = [ float ( j ) for j in fin . readline ( ) . split ( ) ] NEW_LINE bestcost = numchars + 2 NEW_LINE correctprob = 1 NEW_LINE for idx in range ( charstyped ) : NEW_LINE INDENT correctprob = correctprob * line [ idx ] NEW_LINE currcost = ( numchars + 1 ) * ( 1 - correctprob ) + ( charstyped - idx - 1 ) + ( numchars - idx - 1 ) + 1 NEW_LINE if currcost < bestcost : NEW_LINE INDENT bestcost = currcost NEW_LINE DEDENT DEDENT fout . write ( \" Case \u2581 # \" ) NEW_LINE fout . write ( str ( i ) ) NEW_LINE fout . write ( \" : \u2581 \" ) NEW_LINE fout . write ( str ( bestcost ) ) NEW_LINE fout . write ( ' \\n ' ) NEW_LINE print ( i ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE t_n = int ( sys . stdin . readline ( ) ) NEW_LINE for t_t in range ( 1 , t_n + 1 ) : NEW_LINE INDENT a , b = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE p = list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE ans = 1.0 * b + 1 NEW_LINE r = 1.0 NEW_LINE for x in range ( 0 , a + 1 ) : NEW_LINE INDENT ans = min ( ans , ( a + b - 2 * x ) + ( 1.0 - r ) * ( b + 1 ) ) NEW_LINE if x < a : NEW_LINE INDENT r *= p [ x ] NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % .10f \" % ( t_t , ans + 1.0 ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "16", "code": "def work ( K , N , P ) : NEW_LINE INDENT return min ( work_backspace ( K , N , P ) , work_giveup ( K , N , P ) ) NEW_LINE DEDENT def work_backspace ( K , N , P ) : NEW_LINE INDENT Pc = 1 NEW_LINE res = N * N NEW_LINE for k in range ( K + 1 ) : NEW_LINE INDENT r = ( K - k ) NEW_LINE r += ( N + 1 - k ) NEW_LINE r += ( 1 - Pc ) * ( N + 1 ) NEW_LINE if k < K : NEW_LINE INDENT Pc *= P [ k ] NEW_LINE DEDENT res = min ( res , r ) NEW_LINE DEDENT return res NEW_LINE DEDENT def work_giveup ( K , N , P ) : NEW_LINE INDENT return 1 + N + 1 NEW_LINE DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT K , N = map ( int , raw_input ( ) . split ( ) ) NEW_LINE P = map ( float , raw_input ( ) . split ( ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { : f } ' . format ( i , work ( K , N , P ) ) ) NEW_LINE DEDENT", "functions_standalone": [["work", "def work ( K , N , P ) : NEW_LINE INDENT return min ( work_backspace ( K , N , P ) , work_giveup ( K , N , P ) ) NEW_LINE DEDENT"], ["work_backspace", "def work_backspace ( K , N , P ) : NEW_LINE INDENT Pc = 1 NEW_LINE res = N * N NEW_LINE for k in range ( K + 1 ) : NEW_LINE INDENT r = ( K - k ) NEW_LINE r += ( N + 1 - k ) NEW_LINE r += ( 1 - Pc ) * ( N + 1 ) NEW_LINE if k < K : NEW_LINE INDENT Pc *= P [ k ] NEW_LINE DEDENT res = min ( res , r ) NEW_LINE DEDENT return res NEW_LINE DEDENT"], ["work_giveup", "def work_giveup ( K , N , P ) : NEW_LINE INDENT return 1 + N + 1 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_21", "java": [{"id": "9", "code": "import java . util . Scanner ; public class A { static Scanner in = new Scanner ( System . in ) ; void solve ( ) { int N = in . nextInt ( ) ; int [ ] s = new int [ N ] ; int X = 0 ; for ( int i = 0 ; i < N ; ++ i ) { s [ i ] = in . nextInt ( ) ; X += s [ i ] ; } for ( int i = 0 ; i < N ; ++ i ) { double a = 0.0 ; double b = 1.0 ; for ( int q = 0 ; q < 100 ; ++ q ) { double c = ( a + b ) / 2 ; double val = s [ i ] + c * X ; double used = c * X ; for ( int j = 0 ; j < N ; ++ j ) { if ( i == j ) continue ; if ( s [ j ] >= val ) continue ; used += val - s [ j ] ; } if ( used >= X ) { b = c ; } else { a = c ; } } System . out . print ( String . format ( \" \u2581 % .6f \" , 100 * a ) . replace ( \" , \" , \" . \" ) ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int T = in . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \" ) ; new A ( ) . solve ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = in . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \" ) ; new A ( ) . solve ( ) ; } }"]], "functions_class": [["solve", "void solve ( ) { int N = in . nextInt ( ) ; int [ ] s = new int [ N ] ; int X = 0 ; for ( int i = 0 ; i < N ; ++ i ) { s [ i ] = in . nextInt ( ) ; X += s [ i ] ; } for ( int i = 0 ; i < N ; ++ i ) { double a = 0.0 ; double b = 1.0 ; for ( int q = 0 ; q < 100 ; ++ q ) { double c = ( a + b ) / 2 ; double val = s [ i ] + c * X ; double used = c * X ; for ( int j = 0 ; j < N ; ++ j ) { if ( i == j ) continue ; if ( s [ j ] >= val ) continue ; used += val - s [ j ] ; } if ( used >= X ) { b = c ; } else { a = c ; } } System . out . print ( String . format ( \" \u2581 % .6f \" , 100 * a ) . replace ( \" , \" , \" . \" ) ) ; } System . out . println ( ) ; }"]]}, {"id": "19", "code": "import java . io . * ; import java . util . * ; public class A implements Runnable { private String IFILE = \" A - large . in \" ; private Scanner in ; private PrintWriter out ; public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int [ ] mas = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mas [ i ] = in . nextInt ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mas [ i ] ; double [ ] f = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) f [ i ] = ( mas [ i ] + 0.0 ) / sum ; for ( int i = 0 ; i < n ; i ++ ) { double min = 0.0 ; double max = 1.0 ; while ( max - min > 1e-14 ) { double v = ( min + max ) / 2.0 ; double cv = f [ i ] + v ; double q = 0.0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i != j ) q += Math . max ( cv - f [ j ] , 0 ) ; if ( q < 1.0 - v ) min = v ; else max = v ; } out . print ( \" \u2581 \" + 100.0 * max ) ; } out . println ( ) ; } in . close ( ) ; out . close ( ) ; } public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } } public static void main ( String [ ] args ) throws IOException { new A ( ) . Run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new A ( ) . Run ( ) ; }"]], "functions_class": [["Run", "public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; int [ ] mas = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mas [ i ] = in . nextInt ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mas [ i ] ; double [ ] f = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) f [ i ] = ( mas [ i ] + 0.0 ) / sum ; for ( int i = 0 ; i < n ; i ++ ) { double min = 0.0 ; double max = 1.0 ; while ( max - min > 1e-14 ) { double v = ( min + max ) / 2.0 ; double cv = f [ i ] + v ; double q = 0.0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i != j ) q += Math . max ( cv - f [ j ] , 0 ) ; if ( q < 1.0 - v ) min = v ; else max = v ; } out . print ( \" \u2581 \" + 100.0 * max ) ; } out . println ( ) ; } in . close ( ) ; out . close ( ) ; }"], ["run", "public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } }"]]}, {"id": "8", "code": "package round1 ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; public class A { public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" src / round1 / A - large - 0 . in \" ) , new FileOutputStream ( \" src / round1 / A - large - 0 . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; new A ( ) . solve ( io ) ; } io . close ( ) ; } private void solve ( Kattio io ) { int n = io . getInt ( ) , sum = 0 ; int s [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = io . getInt ( ) ; sum += s [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { double lo = 0.0 , hi = 1.0 ; for ( int j = 0 ; j < 200 ; j ++ ) { double x = ( lo + hi ) / 2 ; double isc = s [ i ] + sum * x ; double left = 1 - x ; for ( int k = 0 ; k < n ; k ++ ) { if ( k == i || s [ k ] > isc ) continue ; double y = ( isc - s [ k ] ) / sum ; left -= y ; } if ( left < 0 ) { hi = x ; } else { lo = x ; } } if ( i > 0 ) { io . print ( ' \u2581 ' ) ; } io . print ( lo * 100.0 ) ; } io . println ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" src / round1 / A - large - 0 . in \" ) , new FileOutputStream ( \" src / round1 / A - large - 0 . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; new A ( ) . solve ( io ) ; } io . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( Kattio io ) { int n = io . getInt ( ) , sum = 0 ; int s [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = io . getInt ( ) ; sum += s [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { double lo = 0.0 , hi = 1.0 ; for ( int j = 0 ; j < 200 ; j ++ ) { double x = ( lo + hi ) / 2 ; double isc = s [ i ] + sum * x ; double left = 1 - x ; for ( int k = 0 ; k < n ; k ++ ) { if ( k == i || s [ k ] > isc ) continue ; double y = ( isc - s [ k ] ) / sum ; left -= y ; } if ( left < 0 ) { hi = x ; } else { lo = x ; } } if ( i > 0 ) { io . print ( ' \u2581 ' ) ; } io . print ( lo * 100.0 ) ; } io . println ( ) ; }"]]}, {"id": "4", "code": "import static java . lang . Math . max ; import java . io . * ; import java . util . * ; public class SafetyInNumbers { public static void main ( String [ ] args ) throws Throwable { Scanner in = new Scanner ( new File ( \" safety . in \" ) ) ; PrintWriter out = new PrintWriter ( \" safety . out \" ) ; int testCount = Integer . parseInt ( in . nextLine ( ) . trim ( ) ) ; for ( int i = 0 ; i < testCount ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \" ) ; solve ( in , out ) ; } out . close ( ) ; } static void solve ( Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; double [ ] answer = new double [ n ] ; int sum = 0 ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; sum += a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { double l = 0 ; double r = 1 ; for ( int j = 0 ; j < 100 ; j ++ ) { double m = ( l + r ) * .5 ; double currentMan = a [ i ] + m * sum ; double all = m ; for ( int k = 0 ; k < n ; k ++ ) { if ( k == i ) { continue ; } all += max ( 0 , ( currentMan - a [ k ] ) / sum ) ; } if ( all > 1 ) { r = m ; } else { l = m ; } } answer [ i ] = ( l + r ) * 50 ; } for ( double e : answer ) { out . print ( \" \u2581 \" + e ) ; } out . println ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Throwable { Scanner in = new Scanner ( new File ( \" safety . in \" ) ) ; PrintWriter out = new PrintWriter ( \" safety . out \" ) ; int testCount = Integer . parseInt ( in . nextLine ( ) . trim ( ) ) ; for ( int i = 0 ; i < testCount ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \" ) ; solve ( in , out ) ; } out . close ( ) ; }"], ["solve", "static void solve ( Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; double [ ] answer = new double [ n ] ; int sum = 0 ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; sum += a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { double l = 0 ; double r = 1 ; for ( int j = 0 ; j < 100 ; j ++ ) { double m = ( l + r ) * .5 ; double currentMan = a [ i ] + m * sum ; double all = m ; for ( int k = 0 ; k < n ; k ++ ) { if ( k == i ) { continue ; } all += max ( 0 , ( currentMan - a [ k ] ) / sum ) ; } if ( all > 1 ) { r = m ; } else { l = m ; } } answer [ i ] = ( l + r ) * 50 ; } for ( double e : answer ) { out . print ( \" \u2581 \" + e ) ; } out . println ( ) ; }"]], "functions_class": []}, {"id": "16", "code": "import java . io . * ; import java . text . DecimalFormat ; import java . util . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class A { public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new InputStreamReader ( new FileInputStream ( \" a _ in . txt \" ) ) ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( \" a _ out . txt \" ) ) ) ; int n = in . nextInt ( ) ; in . nextLine ( ) ; int t = 1 ; while ( n -- > 0 ) new A ( ) . solveProblem ( t ++ ) ; out . close ( ) ; } static Scanner in = new Scanner ( new InputStreamReader ( System . in ) ) ; static PrintStream out = new PrintStream ( new BufferedOutputStream ( System . out ) ) ; public void solveProblem ( int nr ) { out . print ( \" Case \u2581 # \" + nr + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) p [ i ] = in . nextInt ( ) ; double som = 0 ; for ( double pp : p ) som += ( double ) pp ; for ( int i = 0 ; i < n ; i ++ ) { double lo = 0.0 ; double hi = 1. ; for ( int l = 0 ; l < 500 ; l ++ ) { double mid = ( lo + hi ) / 2.0 ; double eind = p [ i ] + mid * som ; double tot = mid ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( p [ j ] >= eind - eps ) continue ; tot += ( eind - p [ j ] ) / som ; } if ( tot > 1.0 ) hi = mid ; else lo = mid ; } double ou = ( 100.0 * lo ) ; if ( ou < eps ) ou = 0.0 ; out . print ( ou ) ; if ( i == n - 1 ) out . println ( ) ; else out . print ( \" \u2581 \" ) ; } System . err . println ( \" Case \u2581 # \" + nr + \" \u2581 solved \" ) ; } double eps = 1e-9 ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { in = new Scanner ( new InputStreamReader ( new FileInputStream ( \" a _ in . txt \" ) ) ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( \" a _ out . txt \" ) ) ) ; int n = in . nextInt ( ) ; in . nextLine ( ) ; int t = 1 ; while ( n -- > 0 ) new A ( ) . solveProblem ( t ++ ) ; out . close ( ) ; }"]], "functions_class": [["solveProblem", "public void solveProblem ( int nr ) { out . print ( \" Case \u2581 # \" + nr + \" : \u2581 \" ) ; int n = in . nextInt ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) p [ i ] = in . nextInt ( ) ; double som = 0 ; for ( double pp : p ) som += ( double ) pp ; for ( int i = 0 ; i < n ; i ++ ) { double lo = 0.0 ; double hi = 1. ; for ( int l = 0 ; l < 500 ; l ++ ) { double mid = ( lo + hi ) / 2.0 ; double eind = p [ i ] + mid * som ; double tot = mid ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( p [ j ] >= eind - eps ) continue ; tot += ( eind - p [ j ] ) / som ; } if ( tot > 1.0 ) hi = mid ; else lo = mid ; } double ou = ( 100.0 * lo ) ; if ( ou < eps ) ou = 0.0 ; out . print ( ou ) ; if ( i == n - 1 ) out . println ( ) ; else out . print ( \" \u2581 \" ) ; } System . err . println ( \" Case \u2581 # \" + nr + \" \u2581 solved \" ) ; }"]]}], "python": [{"id": "8", "code": "class Solver ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def setup ( cls , infile ) : NEW_LINE INDENT cls . data = { } NEW_LINE DEDENT def __init__ ( self , infile , tc ) : NEW_LINE INDENT self . tc = tc NEW_LINE self . I = I = map ( int , infile . next ( ) . split ( ) ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT JJ = J = self . I [ 1 : ] NEW_LINE X = float ( sum ( J ) ) NEW_LINE win = [ ] NEW_LINE lw = - 1 NEW_LINE while len ( win ) > lw : NEW_LINE INDENT lw = len ( win ) NEW_LINE win . extend ( [ j for j in J if j > ( ( X + sum ( J ) ) / len ( J ) ) ] ) NEW_LINE J = [ j for j in J if j <= ( ( X + sum ( J ) ) / len ( J ) ) ] NEW_LINE DEDENT res = dict ( ( w , 0. ) for w in win ) NEW_LINE for j in J : NEW_LINE INDENT res [ j ] = ( ( X + sum ( J ) ) / len ( J ) - j ) / X * 100. NEW_LINE DEDENT return ' Case \u2581 # % s : \u2581 % s \\n ' % ( self . tc , ' \u2581 ' . join ( ' % f ' % res [ j ] for j in JJ ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE T = int ( sys . stdin . next ( ) ) NEW_LINE Solver . setup ( sys . stdin ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT sys . stdout . write ( Solver ( sys . stdin , t ) . solve ( ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["setup", "def setup ( cls , infile ) : NEW_LINE INDENT cls . data = { } NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self , infile , tc ) : NEW_LINE INDENT self . tc = tc NEW_LINE self . I = I = map ( int , infile . next ( ) . split ( ) ) NEW_LINE DEDENT"], ["solve", "def solve ( self ) : NEW_LINE INDENT JJ = J = self . I [ 1 : ] NEW_LINE X = float ( sum ( J ) ) NEW_LINE win = [ ] NEW_LINE lw = - 1 NEW_LINE while len ( win ) > lw : NEW_LINE INDENT lw = len ( win ) NEW_LINE win . extend ( [ j for j in J if j > ( ( X + sum ( J ) ) / len ( J ) ) ] ) NEW_LINE J = [ j for j in J if j <= ( ( X + sum ( J ) ) / len ( J ) ) ] NEW_LINE DEDENT res = dict ( ( w , 0. ) for w in win ) NEW_LINE for j in J : NEW_LINE INDENT res [ j ] = ( ( X + sum ( J ) ) / len ( J ) - j ) / X * 100. NEW_LINE DEDENT return ' Case \u2581 # % s : \u2581 % s \\n ' % ( self . tc , ' \u2581 ' . join ( ' % f ' % res [ j ] for j in JJ ) ) NEW_LINE DEDENT"]]}, {"id": "3", "code": "def readline_ints ( ) : NEW_LINE INDENT return [ int ( num ) for num in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT from collections import Counter NEW_LINE def tideline ( scores , X ) : NEW_LINE INDENT cc = Counter ( scores ) NEW_LINE floating = 0 NEW_LINE for score in range ( max ( scores ) + 1 ) : NEW_LINE INDENT floating += cc [ score ] NEW_LINE if floating > X : NEW_LINE INDENT break NEW_LINE DEDENT X -= floating NEW_LINE DEDENT else : NEW_LINE INDENT score += 1 NEW_LINE DEDENT return score + X / floating NEW_LINE DEDENT def find_min_vote_proportions ( scores ) : NEW_LINE INDENT X = sum ( scores ) NEW_LINE points_limit = tideline ( scores , X ) NEW_LINE print ( points_limit ) NEW_LINE proportions_needed = [ ] NEW_LINE for s in scores : NEW_LINE INDENT if s >= points_limit : NEW_LINE INDENT proportions_needed . append ( 0.0 ) NEW_LINE DEDENT else : NEW_LINE INDENT points_needed = points_limit - s NEW_LINE proportions_needed . append ( 100 * points_needed / X ) NEW_LINE DEDENT DEDENT return proportions_needed NEW_LINE DEDENT fname = \" A - large \" NEW_LINE with open ( fname + \" . in \" , \" r \" ) as fin , open ( fname + \" . out \" , \" w \" ) as fout : NEW_LINE INDENT numcases = readline_ints ( ) [ 0 ] NEW_LINE print ( numcases , \" cases \" ) NEW_LINE for caseno in range ( 1 , numcases + 1 ) : NEW_LINE INDENT N , * scores = readline_ints ( ) NEW_LINE result = find_min_vote_proportions ( scores ) NEW_LINE result_str = \" \u2581 \" . join ( \" % f \" % p for p in result ) NEW_LINE outstr = \" Case \u2581 # % d : \u2581 % s \" % ( caseno , result_str ) NEW_LINE fout . write ( outstr + \" \\n \" ) NEW_LINE print ( outstr ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["readline_ints", "def readline_ints ( ) : NEW_LINE INDENT return [ int ( num ) for num in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT"], ["tideline", "def tideline ( scores , X ) : NEW_LINE INDENT cc = Counter ( scores ) NEW_LINE floating = 0 NEW_LINE for score in range ( max ( scores ) + 1 ) : NEW_LINE INDENT floating += cc [ score ] NEW_LINE if floating > X : NEW_LINE INDENT break NEW_LINE DEDENT X -= floating NEW_LINE DEDENT else : NEW_LINE INDENT score += 1 NEW_LINE DEDENT return score + X / floating NEW_LINE DEDENT"], ["find_min_vote_proportions", "def find_min_vote_proportions ( scores ) : NEW_LINE INDENT X = sum ( scores ) NEW_LINE points_limit = tideline ( scores , X ) NEW_LINE print ( points_limit ) NEW_LINE proportions_needed = [ ] NEW_LINE for s in scores : NEW_LINE INDENT if s >= points_limit : NEW_LINE INDENT proportions_needed . append ( 0.0 ) NEW_LINE DEDENT else : NEW_LINE INDENT points_needed = points_limit - s NEW_LINE proportions_needed . append ( 100 * points_needed / X ) NEW_LINE DEDENT DEDENT return proportions_needed NEW_LINE DEDENT"]], "functions_class": []}, {"id": "13", "code": "from sys import stdout NEW_LINE def fill ( si , tot ) : NEW_LINE INDENT for j in xrange ( len ( si ) - 1 ) : NEW_LINE INDENT if si [ j ] < si [ j + 1 ] : NEW_LINE INDENT diff = min ( tot , ( si [ j + 1 ] - si [ j ] ) * ( j + 1 ) ) NEW_LINE si [ j ] += float ( diff ) / ( j + 1 ) NEW_LINE tot -= diff NEW_LINE for k in xrange ( 0 , j ) : NEW_LINE INDENT s [ k ] = s [ j ] NEW_LINE DEDENT if tot <= 0.0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT diff = float ( tot ) / len ( si ) NEW_LINE for k in xrange ( 0 , len ( si ) ) : NEW_LINE INDENT si [ k ] += diff NEW_LINE DEDENT DEDENT def solve ( si ) : NEW_LINE INDENT ans = [ ] NEW_LINE tot = sum ( si ) NEW_LINE xi = [ ( s , j ) for j , s in enumerate ( si ) ] NEW_LINE xi . sort ( ) NEW_LINE si . sort ( ) NEW_LINE fill ( si , tot ) NEW_LINE si = [ ( xi [ j ] [ 1 ] , float ( si [ j ] - xi [ j ] [ 0 ] ) / tot ) for j in xrange ( len ( si ) ) ] NEW_LINE si . sort ( ) NEW_LINE si = [ s [ 1 ] for s in si ] NEW_LINE return si NEW_LINE DEDENT t = int ( raw_input ( ) ) NEW_LINE for case in xrange ( 1 , t + 1 ) : NEW_LINE INDENT s = [ int ( x ) for x in raw_input ( ) . split ( ) ] [ 1 : ] NEW_LINE s = solve ( s ) NEW_LINE stdout . write ( \" Case \u2581 # % d : \" % case ) NEW_LINE for a in s : NEW_LINE INDENT stdout . write ( \" \u2581 % .10f \" % ( a * 100.0 ) ) NEW_LINE DEDENT stdout . write ( \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_12_43", "java": [{"id": "14", "code": "import java . util . Random ; import java . util . Scanner ; public class C { static Scanner sc = new Scanner ( System . in ) ; static class Solver { int N ; int [ ] x ; void solve ( ) { N = sc . nextInt ( ) ; x = new int [ N - 1 ] ; for ( int i = 0 ; i < N - 1 ; ++ i ) { x [ i ] = sc . nextInt ( ) - 1 ; } for ( int i = 0 ; i < N - 1 ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) { if ( x [ j ] > i && x [ j ] < x [ i ] ) { System . out . println ( \" Impossible \" ) ; return ; } } } int [ ] h = new int [ N ] ; Random rand = new Random ( ) ; while ( true ) { for ( int i = 0 ; i < N ; ++ i ) { h [ i ] = rand . nextInt ( 100000000 + 1 ) ; } boolean success = true ; for ( int i = 0 ; i < N - 1 ; ++ i ) { double slopeMax = Integer . MIN_VALUE ; double mi = 0 ; for ( int j = i + 1 ; j < N ; ++ j ) { double slope = 1.0 * ( h [ j ] - h [ i ] ) / ( j - i ) ; if ( slope > slopeMax ) { slopeMax = slope ; mi = j ; } } if ( mi != x [ i ] ) { success = false ; break ; } } if ( success ) { for ( int i = 0 ; i < N ; ++ i ) { System . out . print ( h [ i ] ) ; if ( i != N - 1 ) { System . out . print ( \" \u2581 \" ) ; } } System . out . println ( ) ; return ; } } } } public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; Solver solver = new Solver ( ) ; solver . solve ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; Solver solver = new Solver ( ) ; solver . solve ( ) ; } }"]], "functions_class": [["solve", "void solve ( ) { N = sc . nextInt ( ) ; x = new int [ N - 1 ] ; for ( int i = 0 ; i < N - 1 ; ++ i ) { x [ i ] = sc . nextInt ( ) - 1 ; } for ( int i = 0 ; i < N - 1 ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) { if ( x [ j ] > i && x [ j ] < x [ i ] ) { System . out . println ( \" Impossible \" ) ; return ; } } } int [ ] h = new int [ N ] ; Random rand = new Random ( ) ; while ( true ) { for ( int i = 0 ; i < N ; ++ i ) { h [ i ] = rand . nextInt ( 100000000 + 1 ) ; } boolean success = true ; for ( int i = 0 ; i < N - 1 ; ++ i ) { double slopeMax = Integer . MIN_VALUE ; double mi = 0 ; for ( int j = i + 1 ; j < N ; ++ j ) { double slope = 1.0 * ( h [ j ] - h [ i ] ) / ( j - i ) ; if ( slope > slopeMax ) { slopeMax = slope ; mi = j ; } } if ( mi != x [ i ] ) { success = false ; break ; } } if ( success ) { for ( int i = 0 ; i < N ; ++ i ) { System . out . print ( h [ i ] ) ; if ( i != N - 1 ) { System . out . print ( \" \u2581 \" ) ; } } System . out . println ( ) ; return ; } } }"]]}, {"id": "13", "code": "import java . util . * ; import java . awt . * ; import java . math . * ; public class C { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int T = scan . nextInt ( ) ; for ( int ca = 1 ; ca <= T ; ca ++ ) { boolean rtn = false ; int n = scan . nextInt ( ) ; int [ ] a = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) a [ i ] = scan . nextInt ( ) - 1 ; int TRIALS = 10000000 ; int [ ] h = new int [ n ] ; while ( TRIALS -- > 0 ) { boolean good = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { double m = - 999999999 ; int max = - 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { double tm = ( double ) ( h [ j ] - h [ i ] ) / ( j - i ) ; if ( tm > m ) { m = tm ; max = j ; } } if ( max != a [ i ] ) { good = false ; h [ a [ i ] ] ++ ; break ; } } if ( good ) break ; } System . out . print ( \" Case \u2581 # \" + ca + \" : \" ) ; if ( TRIALS <= 0 ) System . out . println ( \" \u2581 Impossible \" ) ; else { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( \" \u2581 \" + h [ i ] ) ; System . out . println ( ) ; } } } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int T = scan . nextInt ( ) ; for ( int ca = 1 ; ca <= T ; ca ++ ) { boolean rtn = false ; int n = scan . nextInt ( ) ; int [ ] a = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) a [ i ] = scan . nextInt ( ) - 1 ; int TRIALS = 10000000 ; int [ ] h = new int [ n ] ; while ( TRIALS -- > 0 ) { boolean good = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { double m = - 999999999 ; int max = - 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { double tm = ( double ) ( h [ j ] - h [ i ] ) / ( j - i ) ; if ( tm > m ) { m = tm ; max = j ; } } if ( max != a [ i ] ) { good = false ; h [ a [ i ] ] ++ ; break ; } } if ( good ) break ; } System . out . print ( \" Case \u2581 # \" + ca + \" : \" ) ; if ( TRIALS <= 0 ) System . out . println ( \" \u2581 Impossible \" ) ; else { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( \" \u2581 \" + h [ i ] ) ; System . out . println ( ) ; } } }"]], "functions_class": []}], "python": [{"id": "19", "code": "outfile = \" output . txt \" NEW_LINE def popinput ( input ) : NEW_LINE INDENT return int ( input . readline ( ) . split ( ) [ 0 ] ) NEW_LINE DEDENT def solve ( file ) : NEW_LINE INDENT input = open ( file , ' r ' ) NEW_LINE output = open ( outfile , ' w ' ) NEW_LINE cases = popinput ( input ) NEW_LINE for i in range ( cases ) : NEW_LINE INDENT output . write ( \" Case \u2581 # % ( number ) d : \u2581 % ( answer ) s \\n \" % { \" number \" : i + 1 , \" answer \" : solvecase ( input ) } ) NEW_LINE print ( ' Case \u2581 solved : ' , i ) NEW_LINE DEDENT DEDENT def solvecase ( input ) : NEW_LINE INDENT n = popinput ( input ) NEW_LINE highest = list ( map ( int , input . readline ( ) . split ( ) ) ) NEW_LINE height = { } NEW_LINE height [ n ] = 1000000000 NEW_LINE height [ n - 1 ] = 999900000 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , highest [ i - 1 ] ) : NEW_LINE INDENT if highest [ j - 1 ] > highest [ i - 1 ] : NEW_LINE INDENT return ' Impossible ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = n - i NEW_LINE a = highest [ j - 1 ] NEW_LINE if a == n : NEW_LINE INDENT height [ j ] = height [ a ] - 100000 * i + 2 * ( i - 1 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE b = highest [ a - 1 ] NEW_LINE c = height [ a ] - ( height [ b ] - height [ a ] ) * ( a - j ) / ( b - a ) NEW_LINE height [ j ] = c - 4 NEW_LINE DEDENT DEDENT height = list ( map ( int , height . values ( ) ) ) NEW_LINE return str . replace ( str ( height ) . strip ( ' [ ] ' ) , ' , ' , ' ' ) NEW_LINE DEDENT", "functions_standalone": [["popinput", "def popinput ( input ) : NEW_LINE INDENT return int ( input . readline ( ) . split ( ) [ 0 ] ) NEW_LINE DEDENT"], ["solve", "def solve ( file ) : NEW_LINE INDENT input = open ( file , ' r ' ) NEW_LINE output = open ( outfile , ' w ' ) NEW_LINE cases = popinput ( input ) NEW_LINE for i in range ( cases ) : NEW_LINE INDENT output . write ( \" Case \u2581 # % ( number ) d : \u2581 % ( answer ) s \\n \" % { \" number \" : i + 1 , \" answer \" : solvecase ( input ) } ) NEW_LINE print ( ' Case \u2581 solved : ' , i ) NEW_LINE DEDENT DEDENT"], ["solvecase", "def solvecase ( input ) : NEW_LINE INDENT n = popinput ( input ) NEW_LINE highest = list ( map ( int , input . readline ( ) . split ( ) ) ) NEW_LINE height = { } NEW_LINE height [ n ] = 1000000000 NEW_LINE height [ n - 1 ] = 999900000 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , highest [ i - 1 ] ) : NEW_LINE INDENT if highest [ j - 1 ] > highest [ i - 1 ] : NEW_LINE INDENT return ' Impossible ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = n - i NEW_LINE a = highest [ j - 1 ] NEW_LINE if a == n : NEW_LINE INDENT height [ j ] = height [ a ] - 100000 * i + 2 * ( i - 1 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE b = highest [ a - 1 ] NEW_LINE c = height [ a ] - ( height [ b ] - height [ a ] ) * ( a - j ) / ( b - a ) NEW_LINE height [ j ] = c - 4 NEW_LINE DEDENT DEDENT height = list ( map ( int , height . values ( ) ) ) NEW_LINE return str . replace ( str ( height ) . strip ( ' [ ] ' ) , ' , ' , ' ' ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "testCount = int ( raw_input ( ) ) NEW_LINE for testIndex in range ( testCount ) : NEW_LINE INDENT ans = \" Case \u2581 # \" + str ( testIndex + 1 ) + \" : \u2581 \" NEW_LINE n = int ( raw_input ( ) ) NEW_LINE see = [ int ( x ) - 1 for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE m = [ n - 1 ] * n NEW_LINE cm = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if i >= m [ cm ] : NEW_LINE INDENT cm -= 1 NEW_LINE DEDENT if see [ i ] > m [ cm ] : NEW_LINE INDENT ans += \" Impossible \" NEW_LINE break NEW_LINE DEDENT if see [ i ] < m [ cm ] : NEW_LINE INDENT cm += 1 NEW_LINE m [ cm ] = see [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT height = [ 0 ] * n NEW_LINE count = [ - 1 ] * n NEW_LINE for i in see : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT angle = [ 0 ] * n NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT angle [ i ] = count [ see [ i ] ] + angle [ see [ i ] ] NEW_LINE count [ see [ i ] ] -= 1 NEW_LINE height [ i ] = ( see [ i ] - i ) * angle [ i ] + height [ see [ i ] ] NEW_LINE DEDENT m = max ( height ) NEW_LINE for i in height : NEW_LINE INDENT ans += str ( m - i ) + \" \u2581 \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "import fractions NEW_LINE f = fractions . Fraction NEW_LINE def rat ( a , b ) : NEW_LINE INDENT if v [ a ] == v [ b ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT return f ( v [ b ] - v [ a ] , b - a ) NEW_LINE DEDENT cases = int ( input ( ) ) NEW_LINE for case in range ( cases ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE x = list ( int ( s ) - 1 for s in input ( ) . split ( ) ) NEW_LINE possible = True NEW_LINE for i , xi in enumerate ( x ) : NEW_LINE INDENT if xi > i + 1 : NEW_LINE INDENT if max ( x [ i + 1 : xi ] ) > xi : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not possible : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case + 1 , \" Impossible \" ) ) NEW_LINE continue NEW_LINE DEDENT v = [ 1 ] * N NEW_LINE cg = True NEW_LINE while cg : NEW_LINE INDENT cg = False NEW_LINE for i , xi in enumerate ( x ) : NEW_LINE INDENT cl = True NEW_LINE while cl : NEW_LINE INDENT cl = False NEW_LINE if xi - i > 1 : NEW_LINE INDENT while rat ( i , xi ) <= max ( rat ( i , j ) for j in range ( i + 1 , xi ) ) : NEW_LINE INDENT v [ xi ] += 1 NEW_LINE cg = cl = True NEW_LINE DEDENT DEDENT if N - xi > 1 : NEW_LINE INDENT while rat ( i , xi ) < max ( rat ( i , j ) for j in range ( xi + 1 , N ) ) : NEW_LINE INDENT v [ xi ] += 1 NEW_LINE cg = cl = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case + 1 , \" \u2581 \" . join ( str ( vi ) for vi in v ) ) ) NEW_LINE DEDENT", "functions_standalone": [["rat", "def rat ( a , b ) : NEW_LINE INDENT if v [ a ] == v [ b ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT return f ( v [ b ] - v [ a ] , b - a ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_31", "java": [{"id": "19", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . * ; public class Diamond implements Runnable { final Scanner in ; final PrintWriter out ; public Diamond ( ) throws FileNotFoundException { out = new PrintWriter ( getClass ( ) . getName ( ) . toLowerCase ( ) + \" . out \" ) ; in = new Scanner ( new File ( getClass ( ) . getName ( ) . toLowerCase ( ) + \" . in \" ) ) ; } public static void main ( String [ ] args ) { try { new Diamond ( ) . run ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } public void run ( ) { int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int testcase = 1 ; testcase <= tests ; testcase ++ ) { int n = in . nextInt ( ) ; List < List < Integer > > edges = new ArrayList < List < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { List < Integer > cur = new ArrayList < Integer > ( ) ; int mi = in . nextInt ( ) ; for ( int x = 0 ; x < mi ; x ++ ) { cur . add ( in . nextInt ( ) - 1 ) ; } edges . add ( cur ) ; } boolean path = false ; for ( int st = 0 ; st < n ; st ++ ) { Queue < Integer > q = new ArrayDeque < Integer > ( ) ; Set < Integer > v = new HashSet < Integer > ( ) ; v . add ( st ) ; for ( q . offer ( st ) ; ! q . isEmpty ( ) ; q . poll ( ) ) { int c = q . peek ( ) ; for ( int d : edges . get ( c ) ) { if ( v . contains ( d ) ) { path = true ; continue ; } v . add ( d ) ; q . offer ( d ) ; } } } out . println ( \" Case \u2581 # \" + testcase + \" : \u2581 \" + ( path ? \" Yes \" : \" No \" ) ) ; } out . close ( ) ; in . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { new Diamond ( ) . run ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": [["Diamond", "public Diamond ( ) throws FileNotFoundException { out = new PrintWriter ( getClass ( ) . getName ( ) . toLowerCase ( ) + \" . out \" ) ; in = new Scanner ( new File ( getClass ( ) . getName ( ) . toLowerCase ( ) + \" . in \" ) ) ; }"], ["run", "public void run ( ) { int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int testcase = 1 ; testcase <= tests ; testcase ++ ) { int n = in . nextInt ( ) ; List < List < Integer > > edges = new ArrayList < List < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { List < Integer > cur = new ArrayList < Integer > ( ) ; int mi = in . nextInt ( ) ; for ( int x = 0 ; x < mi ; x ++ ) { cur . add ( in . nextInt ( ) - 1 ) ; } edges . add ( cur ) ; } boolean path = false ; for ( int st = 0 ; st < n ; st ++ ) { Queue < Integer > q = new ArrayDeque < Integer > ( ) ; Set < Integer > v = new HashSet < Integer > ( ) ; v . add ( st ) ; for ( q . offer ( st ) ; ! q . isEmpty ( ) ; q . poll ( ) ) { int c = q . peek ( ) ; for ( int d : edges . get ( c ) ) { if ( v . contains ( d ) ) { path = true ; continue ; } v . add ( d ) ; q . offer ( d ) ; } } } out . println ( \" Case \u2581 # \" + testcase + \" : \u2581 \" + ( path ? \" Yes \" : \" No \" ) ) ; } out . close ( ) ; in . close ( ) ; }"]]}, {"id": "11", "code": "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class R1CC { static boolean [ ] g ; static int [ ] [ ] p ; static int [ ] d ; public static void main ( String [ ] args ) { try { Scanner sc = new Scanner ( new File ( \" A - large . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( \" output . out \" ) ) ) ; int t = sc . nextInt ( ) ; X : for ( int i = 0 ; i < t ; i ++ ) { bw . write ( \" Case \u2581 # \" + String . valueOf ( i + 1 ) + \" : \u2581 \" ) ; int r = 0 ; int n = sc . nextInt ( ) ; d = new int [ n ] ; p = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { d [ j ] = sc . nextInt ( ) ; for ( int k = 0 ; k < d [ j ] ; k ++ ) p [ j ] [ k ] = sc . nextInt ( ) - 1 ; } for ( int j = 0 ; j < n ; j ++ ) { g = new boolean [ n ] ; if ( traverse ( j ) ) { bw . write ( \" Yes \" ) ; bw . newLine ( ) ; bw . flush ( ) ; continue X ; } } bw . write ( \" No \" ) ; bw . newLine ( ) ; bw . flush ( ) ; } bw . close ( ) ; } catch ( Exception ex ) { Logger . getLogger ( QA . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } static boolean traverse ( int h ) { for ( int i = 0 ; i < d [ h ] ; i ++ ) { if ( g [ p [ h ] [ i ] ] ) return true ; else g [ p [ h ] [ i ] ] = true ; if ( traverse ( p [ h ] [ i ] ) ) return true ; } return false ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { Scanner sc = new Scanner ( new File ( \" A - large . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( \" output . out \" ) ) ) ; int t = sc . nextInt ( ) ; X : for ( int i = 0 ; i < t ; i ++ ) { bw . write ( \" Case \u2581 # \" + String . valueOf ( i + 1 ) + \" : \u2581 \" ) ; int r = 0 ; int n = sc . nextInt ( ) ; d = new int [ n ] ; p = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { d [ j ] = sc . nextInt ( ) ; for ( int k = 0 ; k < d [ j ] ; k ++ ) p [ j ] [ k ] = sc . nextInt ( ) - 1 ; } for ( int j = 0 ; j < n ; j ++ ) { g = new boolean [ n ] ; if ( traverse ( j ) ) { bw . write ( \" Yes \" ) ; bw . newLine ( ) ; bw . flush ( ) ; continue X ; } } bw . write ( \" No \" ) ; bw . newLine ( ) ; bw . flush ( ) ; } bw . close ( ) ; } catch ( Exception ex ) { Logger . getLogger ( QA . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"], ["traverse", "static boolean traverse ( int h ) { for ( int i = 0 ; i < d [ h ] ; i ++ ) { if ( g [ p [ h ] [ i ] ] ) return true ; else g [ p [ h ] [ i ] ] = true ; if ( traverse ( p [ h ] [ i ] ) ) return true ; } return false ; }"]], "functions_class": []}, {"id": "18", "code": "package codejam . round1c_2012 ; import java . io . File ; import java . io . PrintStream ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Deque ; import java . util . HashSet ; import java . util . List ; import java . util . Scanner ; import java . util . Set ; public class MainA { static char [ ] mapping = new char [ 256 ] ; static List < Set < Integer > > defs ; public static void main ( String [ ] args ) throws Exception { String f = \" / home / floris / dev / java / Test / src / codejam / round1c _ 2012 / A - large . in \" ; Scanner sc = new Scanner ( new File ( f ) ) ; System . setOut ( new PrintStream ( new File ( f + \" . out \" ) ) ) ; int T = sc . nextInt ( ) ; for ( int i = 1 ; T -- > 0 ; i ++ ) { defs = new ArrayList < Set < Integer > > ( ) ; int classCount = sc . nextInt ( ) ; for ( int j = 0 ; j < classCount ; j ++ ) { Set < Integer > cur = new HashSet < Integer > ( ) ; int ic = sc . nextInt ( ) ; for ( int k = 0 ; k < ic ; k ++ ) cur . add ( sc . nextInt ( ) - 1 ) ; defs . add ( cur ) ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , i , solve ( ) ) ; } } private static String solve ( ) { for ( int i = 0 ; i < defs . size ( ) ; i ++ ) { List < Integer > contained = new ArrayList < Integer > ( ) ; Deque < Integer > d = new ArrayDeque ( ) ; d . addAll ( defs . get ( i ) ) ; contained . addAll ( defs . get ( i ) ) ; contained . add ( i ) ; while ( ! d . isEmpty ( ) ) { int v = d . remove ( ) ; for ( int k : defs . get ( v ) ) { if ( contained . contains ( k ) ) return \" Yes \" ; d . add ( k ) ; contained . add ( k ) ; } } } return \" No \" ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String f = \" / home / floris / dev / java / Test / src / codejam / round1c _ 2012 / A - large . in \" ; Scanner sc = new Scanner ( new File ( f ) ) ; System . setOut ( new PrintStream ( new File ( f + \" . out \" ) ) ) ; int T = sc . nextInt ( ) ; for ( int i = 1 ; T -- > 0 ; i ++ ) { defs = new ArrayList < Set < Integer > > ( ) ; int classCount = sc . nextInt ( ) ; for ( int j = 0 ; j < classCount ; j ++ ) { Set < Integer > cur = new HashSet < Integer > ( ) ; int ic = sc . nextInt ( ) ; for ( int k = 0 ; k < ic ; k ++ ) cur . add ( sc . nextInt ( ) - 1 ) ; defs . add ( cur ) ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , i , solve ( ) ) ; } }"], ["solve", "private static String solve ( ) { for ( int i = 0 ; i < defs . size ( ) ; i ++ ) { List < Integer > contained = new ArrayList < Integer > ( ) ; Deque < Integer > d = new ArrayDeque ( ) ; d . addAll ( defs . get ( i ) ) ; contained . addAll ( defs . get ( i ) ) ; contained . add ( i ) ; while ( ! d . isEmpty ( ) ) { int v = d . remove ( ) ; for ( int k : defs . get ( v ) ) { if ( contained . contains ( k ) ) return \" Yes \" ; d . add ( k ) ; contained . add ( k ) ; } } } return \" No \" ; }"]], "functions_class": []}, {"id": "12", "code": "import java . io . * ; import java . util . * ; public class A { public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" A - small - attempt0 . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" A - small . out \" ) ) ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { boolean adj [ ] [ ] = new boolean [ 1005 ] [ 1005 ] ; int N ; String s = in . readLine ( ) ; StringTokenizer st = new StringTokenizer ( s ) ; N = Integer . parseInt ( st . nextToken ( ) ) ; for ( int r = 0 ; r < N ; r ++ ) { s = in . readLine ( ) ; st = new StringTokenizer ( s ) ; int M = Integer . parseInt ( st . nextToken ( ) ) ; for ( int c = 0 ; c < M ; c ++ ) { int d = Integer . parseInt ( st . nextToken ( ) ) - 1 ; adj [ r ] [ d ] = true ; } } boolean ans = false ; for ( int n = 0 ; n < N ; n ++ ) { LinkedList < Integer > q = new LinkedList < Integer > ( ) ; q . add ( n ) ; boolean v [ ] = new boolean [ N ] ; while ( ! q . isEmpty ( ) ) { int x = q . pollFirst ( ) ; if ( v [ x ] ) { ans = true ; break ; } v [ x ] = true ; for ( int m = 0 ; m < N ; m ++ ) { if ( adj [ x ] [ m ] ) { q . addFirst ( m ) ; } } } } out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ( ans ? \" Yes \" : \" No \" ) ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" A - small - attempt0 . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( \" A - small . out \" ) ) ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { boolean adj [ ] [ ] = new boolean [ 1005 ] [ 1005 ] ; int N ; String s = in . readLine ( ) ; StringTokenizer st = new StringTokenizer ( s ) ; N = Integer . parseInt ( st . nextToken ( ) ) ; for ( int r = 0 ; r < N ; r ++ ) { s = in . readLine ( ) ; st = new StringTokenizer ( s ) ; int M = Integer . parseInt ( st . nextToken ( ) ) ; for ( int c = 0 ; c < M ; c ++ ) { int d = Integer . parseInt ( st . nextToken ( ) ) - 1 ; adj [ r ] [ d ] = true ; } } boolean ans = false ; for ( int n = 0 ; n < N ; n ++ ) { LinkedList < Integer > q = new LinkedList < Integer > ( ) ; q . add ( n ) ; boolean v [ ] = new boolean [ N ] ; while ( ! q . isEmpty ( ) ) { int x = q . pollFirst ( ) ; if ( v [ x ] ) { ans = true ; break ; } v [ x ] = true ; for ( int m = 0 ; m < N ; m ++ ) { if ( adj [ x ] [ m ] ) { q . addFirst ( m ) ; } } } } out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ( ans ? \" Yes \" : \" No \" ) ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "15", "code": "import java . util . ArrayList ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; import java . util . Set ; public class Q1 { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int numTests = s . nextInt ( ) ; for ( int test = 0 ; test < numTests ; test ++ ) { System . out . println ( \" Case \u2581 # \" + ( test + 1 ) + \" : \u2581 \" + getResult ( s ) ) ; } } private static String getResult ( Scanner s ) { int numNodes = s . nextInt ( ) ; List < GraphNode > nodes = new ArrayList < GraphNode > ( numNodes ) ; for ( int i = 0 ; i < numNodes ; i ++ ) { nodes . add ( new GraphNode ( ) ) ; } for ( int i = 0 ; i < numNodes ; i ++ ) { int numChildren = s . nextInt ( ) ; for ( int j = 0 ; j < numChildren ; j ++ ) { int child = s . nextInt ( ) ; nodes . get ( child - 1 ) . childNodes . add ( nodes . get ( i ) ) ; } } for ( GraphNode node : nodes ) { if ( node . childNodes . size ( ) > 1 && node . hasDiamond ( ) ) { return \" Yes \" ; } } return \" No \" ; } public static class GraphNode { public List < GraphNode > childNodes = new LinkedList < GraphNode > ( ) ; public boolean hasDiamond ( ) { List < GraphNode > foundSoFar = new LinkedList < GraphNode > ( ) ; Set < GraphNode > fastLookup = new HashSet < GraphNode > ( ) ; foundSoFar . add ( this ) ; fastLookup . add ( this ) ; while ( foundSoFar . size ( ) > 0 ) { GraphNode node = foundSoFar . remove ( 0 ) ; for ( GraphNode child : node . childNodes ) { if ( fastLookup . contains ( child ) ) return true ; foundSoFar . add ( child ) ; fastLookup . add ( child ) ; } } return false ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int numTests = s . nextInt ( ) ; for ( int test = 0 ; test < numTests ; test ++ ) { System . out . println ( \" Case \u2581 # \" + ( test + 1 ) + \" : \u2581 \" + getResult ( s ) ) ; } }"], ["getResult", "private static String getResult ( Scanner s ) { int numNodes = s . nextInt ( ) ; List < GraphNode > nodes = new ArrayList < GraphNode > ( numNodes ) ; for ( int i = 0 ; i < numNodes ; i ++ ) { nodes . add ( new GraphNode ( ) ) ; } for ( int i = 0 ; i < numNodes ; i ++ ) { int numChildren = s . nextInt ( ) ; for ( int j = 0 ; j < numChildren ; j ++ ) { int child = s . nextInt ( ) ; nodes . get ( child - 1 ) . childNodes . add ( nodes . get ( i ) ) ; } } for ( GraphNode node : nodes ) { if ( node . childNodes . size ( ) > 1 && node . hasDiamond ( ) ) { return \" Yes \" ; } } return \" No \" ; }"]], "functions_class": [["hasDiamond", "public boolean hasDiamond ( ) { List < GraphNode > foundSoFar = new LinkedList < GraphNode > ( ) ; Set < GraphNode > fastLookup = new HashSet < GraphNode > ( ) ; foundSoFar . add ( this ) ; fastLookup . add ( this ) ; while ( foundSoFar . size ( ) > 0 ) { GraphNode node = foundSoFar . remove ( 0 ) ; for ( GraphNode child : node . childNodes ) { if ( fastLookup . contains ( child ) ) return true ; foundSoFar . add ( child ) ; fastLookup . add ( child ) ; } } return false ; }"]]}], "python": [{"id": "15", "code": "import operator NEW_LINE import itertools NEW_LINE import functools NEW_LINE import math NEW_LINE from collections import deque NEW_LINE def bfs ( i ) : NEW_LINE INDENT res = False NEW_LINE visited = [ 0 ] * ( N + 1 ) NEW_LINE q = deque ( [ node [ i ] ] ) NEW_LINE while len ( q ) : NEW_LINE INDENT n = q . popleft ( ) NEW_LINE if visited [ n [ 0 ] ] : NEW_LINE INDENT res = True NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT visited [ n [ 0 ] ] = 1 NEW_LINE DEDENT for x in n [ 1 : ] : NEW_LINE INDENT q . append ( node [ x ] ) NEW_LINE DEDENT DEDENT DEDENT fn = open ( '1 . in ' ) NEW_LINE ofn = open ( '1 . out ' , ' w ' ) NEW_LINE TC = int ( fn . readline ( ) ) NEW_LINE for tc in range ( TC ) : NEW_LINE INDENT N = int ( fn . readline ( ) . strip ( ) ) NEW_LINE node = [ None ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT r = map ( int , fn . readline ( ) . strip ( ) . split ( ) ) NEW_LINE node [ i ] = [ i ] + r [ 1 : ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if bfs ( i ) : NEW_LINE INDENT print >> ofn , ' Case \u2581 # { } : \u2581 { } ' . format ( tc + 1 , ' Yes ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print >> ofn , ' Case \u2581 # { } : \u2581 { } ' . format ( tc + 1 , ' No ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["bfs", "def bfs ( i ) : NEW_LINE INDENT res = False NEW_LINE visited = [ 0 ] * ( N + 1 ) NEW_LINE q = deque ( [ node [ i ] ] ) NEW_LINE while len ( q ) : NEW_LINE INDENT n = q . popleft ( ) NEW_LINE if visited [ n [ 0 ] ] : NEW_LINE INDENT res = True NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT visited [ n [ 0 ] ] = 1 NEW_LINE DEDENT for x in n [ 1 : ] : NEW_LINE INDENT q . append ( node [ x ] ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "10", "code": "import itertools NEW_LINE class DiamondFound ( Exception ) : NEW_LINE INDENT pass NEW_LINE DEDENT def find_ancestors ( class_num , inheritance , ancestors ) : NEW_LINE INDENT if ancestors [ class_num ] : NEW_LINE INDENT return NEW_LINE DEDENT direct_fathers = inheritance [ class_num ] NEW_LINE ancestors [ class_num ] . update ( direct_fathers ) NEW_LINE for direct_father in direct_fathers : NEW_LINE INDENT find_ancestors ( direct_father , inheritance , ancestors ) NEW_LINE ancestors_of_direct_father = ancestors [ direct_father ] NEW_LINE before = len ( ancestors [ class_num ] ) NEW_LINE ancestors [ class_num ] . update ( ancestors_of_direct_father ) NEW_LINE after = len ( ancestors [ class_num ] ) NEW_LINE if after - before != len ( ancestors_of_direct_father ) : NEW_LINE INDENT raise DiamondFound ( ) NEW_LINE DEDENT DEDENT DEDENT def solve ( num_of_classes , inheritance ) : NEW_LINE INDENT ancestors = dict ( ( i , set ( ) ) for i in xrange ( 1 , num_of_classes + 1 ) ) NEW_LINE for class_num in inheritance : NEW_LINE INDENT try : NEW_LINE INDENT find_ancestors ( class_num , inheritance , ancestors ) NEW_LINE DEDENT except DiamondFound : NEW_LINE INDENT return ' Yes ' NEW_LINE DEDENT DEDENT return ' No ' NEW_LINE DEDENT def process_files ( in_file , out_file ) : NEW_LINE INDENT num_of_test_cases = int ( in_file . next ( ) . strip ( ) ) NEW_LINE for test_number in xrange ( num_of_test_cases ) : NEW_LINE INDENT num_of_classes = int ( in_file . next ( ) . strip ( ) ) NEW_LINE inheritance = { } NEW_LINE for class_num in xrange ( 1 , num_of_classes + 1 ) : NEW_LINE INDENT params = in_file . next ( ) . strip ( ) . split ( ) NEW_LINE assert len ( params ) - 1 == int ( params [ 0 ] ) NEW_LINE inheritance [ class_num ] = [ int ( i ) for i in params [ 1 : ] ] NEW_LINE DEDENT result = solve ( num_of_classes , inheritance ) NEW_LINE out_file . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( test_number + 1 , result ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT with open ( ' A - large . in ' , ' rb ' ) as in_file : NEW_LINE INDENT with open ( ' A - large . out ' , ' wb ' ) as out_file : NEW_LINE INDENT process_files ( in_file , out_file ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["find_ancestors", "def find_ancestors ( class_num , inheritance , ancestors ) : NEW_LINE INDENT if ancestors [ class_num ] : NEW_LINE INDENT return NEW_LINE DEDENT direct_fathers = inheritance [ class_num ] NEW_LINE ancestors [ class_num ] . update ( direct_fathers ) NEW_LINE for direct_father in direct_fathers : NEW_LINE INDENT find_ancestors ( direct_father , inheritance , ancestors ) NEW_LINE ancestors_of_direct_father = ancestors [ direct_father ] NEW_LINE before = len ( ancestors [ class_num ] ) NEW_LINE ancestors [ class_num ] . update ( ancestors_of_direct_father ) NEW_LINE after = len ( ancestors [ class_num ] ) NEW_LINE if after - before != len ( ancestors_of_direct_father ) : NEW_LINE INDENT raise DiamondFound ( ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "13", "code": "import sys NEW_LINE sys . setrecursionlimit ( 5000 ) NEW_LINE def check ( i , graph , seen , mini ) : NEW_LINE INDENT if seen [ i ] == True : NEW_LINE INDENT return True , seen NEW_LINE DEDENT else : NEW_LINE INDENT seen [ i ] = True NEW_LINE DEDENT for j in range ( 0 , len ( graph ) ) : NEW_LINE INDENT if graph [ i ] [ j ] : NEW_LINE INDENT res , seen = check ( j , graph , seen , mini ) NEW_LINE if res : NEW_LINE INDENT return True , seen NEW_LINE DEDENT DEDENT DEDENT return False , seen NEW_LINE DEDENT inFile = open ( ' A - large . in ' , ' r ' ) NEW_LINE outFile = open ( ' diamond . out ' , ' w ' ) NEW_LINE T = int ( inFile . readline ( ) ) NEW_LINE for n in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( inFile . readline ( ) ) NEW_LINE graph = [ [ False for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = [ int ( x ) for x in inFile . readline ( ) . split ( ) ] NEW_LINE for j in range ( 1 , len ( l ) ) : NEW_LINE INDENT graph [ i ] [ l [ j ] - 1 ] = True NEW_LINE DEDENT DEDENT res = False NEW_LINE for i in range ( N ) : NEW_LINE INDENT res , seen = check ( i , graph , [ False for i in range ( N ) ] , i + 1 ) NEW_LINE if res : break NEW_LINE DEDENT if res : NEW_LINE INDENT print ( ' Case \u2581 # ' + str ( n ) + ' : \u2581 Yes ' ) NEW_LINE outFile . write ( ' Case \u2581 # ' + str ( n ) + ' : \u2581 Yes \\n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Case \u2581 # ' + str ( n ) + ' : \u2581 No ' ) NEW_LINE outFile . write ( ' Case \u2581 # ' + str ( n ) + ' : \u2581 No \\n ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["check", "def check ( i , graph , seen , mini ) : NEW_LINE INDENT if seen [ i ] == True : NEW_LINE INDENT return True , seen NEW_LINE DEDENT else : NEW_LINE INDENT seen [ i ] = True NEW_LINE DEDENT for j in range ( 0 , len ( graph ) ) : NEW_LINE INDENT if graph [ i ] [ j ] : NEW_LINE INDENT res , seen = check ( j , graph , seen , mini ) NEW_LINE if res : NEW_LINE INDENT return True , seen NEW_LINE DEDENT DEDENT DEDENT return False , seen NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "inp = open ( ' . / A - large . in ' , ' r ' ) NEW_LINE outp = open ( ' . / A . out ' , ' w ' ) NEW_LINE T = int ( inp . readline ( ) ) NEW_LINE def solve ( i ) : NEW_LINE INDENT N = int ( inp . readline ( ) ) NEW_LINE classes = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT classes . append ( set ( [ int ( x ) for x in inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) ] [ 1 : ] ) ) NEW_LINE DEDENT for n in range ( N ) : NEW_LINE INDENT for m in range ( N ) : NEW_LINE INDENT if n + 1 in classes [ m ] : NEW_LINE INDENT k = len ( classes [ n ] ) + len ( classes [ m ] ) NEW_LINE classes [ m ] = classes [ n ] | classes [ m ] NEW_LINE if len ( classes [ m ] ) != k : NEW_LINE INDENT outp . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 Yes \\n ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT outp . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 No \\n ' ) NEW_LINE DEDENT for k in range ( T ) : NEW_LINE INDENT solve ( k + 1 ) NEW_LINE DEDENT inp . close ( ) NEW_LINE outp . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( i ) : NEW_LINE INDENT N = int ( inp . readline ( ) ) NEW_LINE classes = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT classes . append ( set ( [ int ( x ) for x in inp . readline ( ) . replace ( ' \\n ' , ' ' ) . split ( ' \u2581 ' ) ] [ 1 : ] ) ) NEW_LINE DEDENT for n in range ( N ) : NEW_LINE INDENT for m in range ( N ) : NEW_LINE INDENT if n + 1 in classes [ m ] : NEW_LINE INDENT k = len ( classes [ n ] ) + len ( classes [ m ] ) NEW_LINE classes [ m ] = classes [ n ] | classes [ m ] NEW_LINE if len ( classes [ m ] ) != k : NEW_LINE INDENT outp . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 Yes \\n ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT outp . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 No \\n ' ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE sys . setrecursionlimit ( 3000 ) NEW_LINE def diamond_inheritance ( M ) : NEW_LINE INDENT visited = set ( ) NEW_LINE for node in M : NEW_LINE INDENT if not node in visited : NEW_LINE INDENT curr_visited = set ( ) NEW_LINE if visit ( M , node , curr_visited ) : NEW_LINE INDENT return True NEW_LINE DEDENT visited . update ( curr_visited ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def visit ( M , k , visited ) : NEW_LINE INDENT for node in M [ k ] : NEW_LINE INDENT if not node in visited : NEW_LINE INDENT if visit ( M , node , visited ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT visited . add ( k ) NEW_LINE return False NEW_LINE DEDENT fi = open ( \" A . in \" , \" r \" ) NEW_LINE fo = open ( \" A . out \" , \" w \" ) NEW_LINE T = int ( fi . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N = int ( fi . readline ( ) ) NEW_LINE M = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT line = map ( int , fi . readline ( ) . split ( ) ) NEW_LINE M [ i + 1 ] = line [ 1 : ] NEW_LINE DEDENT result = diamond_inheritance ( M ) NEW_LINE if result : NEW_LINE INDENT fo . write ( ' Case \u2581 # { 0 } : \u2581 Yes \\n ' . format ( t + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT fo . write ( ' Case \u2581 # { 0 } : \u2581 No \\n ' . format ( t + 1 ) ) NEW_LINE DEDENT DEDENT fi . close ( ) NEW_LINE fo . close ( ) NEW_LINE", "functions_standalone": [["diamond_inheritance", "def diamond_inheritance ( M ) : NEW_LINE INDENT visited = set ( ) NEW_LINE for node in M : NEW_LINE INDENT if not node in visited : NEW_LINE INDENT curr_visited = set ( ) NEW_LINE if visit ( M , node , curr_visited ) : NEW_LINE INDENT return True NEW_LINE DEDENT visited . update ( curr_visited ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"], ["visit", "def visit ( M , k , visited ) : NEW_LINE INDENT for node in M [ k ] : NEW_LINE INDENT if not node in visited : NEW_LINE INDENT if visit ( M , node , visited ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT visited . add ( k ) NEW_LINE return False NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_01", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class Googlerese { public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String dict = \" yhesocvxduiglbkrztnwjpfmaq \" ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = in . readLine ( ) ; String ans = \" \" ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) < 97 || s . charAt ( j ) > 122 ) { ans += s . charAt ( j ) ; } else { ans += dict . charAt ( s . charAt ( j ) - 97 ) ; } } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String dict = \" yhesocvxduiglbkrztnwjpfmaq \" ; int T = Integer . parseInt ( in . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = in . readLine ( ) ; String ans = \" \" ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) < 97 || s . charAt ( j ) > 122 ) { ans += s . charAt ( j ) ; } else { ans += dict . charAt ( s . charAt ( j ) - 97 ) ; } } System . out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans ) ; } }"]], "functions_class": []}, {"id": "13", "code": "package j2012qualifier ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class A { public static String inputDirectory = \" src / j2012qualifier / \" ; public static String inputFile = \" A . in \" ; public static String outputFile = \" A . out \" ; public static PrintWriter output ; public static void main ( String [ ] args ) throws FileNotFoundException { Scanner s = new Scanner ( new File ( inputDirectory + inputFile ) ) ; output = new PrintWriter ( new File ( inputDirectory + outputFile ) ) ; Map < Character , Character > codeMap = new HashMap < Character , Character > ( ) ; String source = \" qzejp \u2581 mysljylc \u2581 kd \u2581 kxveddknmc \u2581 re \u2581 jsicpdrysi \u2581 rbcpc \u2581 ypc \u2581 rtcsra \u2581 dkh \u2581 wyfrepkym \u2581 veddknkmkrkcd \u2581 de \u2581 kr \u2581 kd \u2581 eoya \u2581 kw \u2581 aej \u2581 tysr \u2581 re \u2581 ujdr \u2581 lkgc \u2581 jv \" ; String result = \" zqour \u2581 language \u2581 is \u2581 impossible \u2581 to \u2581 understand \u2581 there \u2581 are \u2581 twenty \u2581 six \u2581 factorial \u2581 possibilities \u2581 so \u2581 it \u2581 is \u2581 okay \u2581 if \u2581 you \u2581 want \u2581 to \u2581 just \u2581 give \u2581 up \" ; for ( int i = 0 ; i < source . length ( ) ; i ++ ) { codeMap . put ( source . charAt ( i ) , result . charAt ( i ) ) ; } int cases = s . nextInt ( ) ; s . nextLine ( ) ; for ( int Case = 1 ; Case <= cases ; Case ++ ) { String code = s . nextLine ( ) ; char [ ] uncoded = new char [ code . length ( ) ] ; for ( int i = 0 ; i < uncoded . length ; i ++ ) { uncoded [ i ] = codeMap . get ( code . charAt ( i ) ) ; } String answer = String . valueOf ( uncoded ) ; out ( \" Case \u2581 # \" + Case + \" : \u2581 \" + answer ) ; } output . flush ( ) ; } public static void out ( String s ) { output . println ( s ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner s = new Scanner ( new File ( inputDirectory + inputFile ) ) ; output = new PrintWriter ( new File ( inputDirectory + outputFile ) ) ; Map < Character , Character > codeMap = new HashMap < Character , Character > ( ) ; String source = \" qzejp \u2581 mysljylc \u2581 kd \u2581 kxveddknmc \u2581 re \u2581 jsicpdrysi \u2581 rbcpc \u2581 ypc \u2581 rtcsra \u2581 dkh \u2581 wyfrepkym \u2581 veddknkmkrkcd \u2581 de \u2581 kr \u2581 kd \u2581 eoya \u2581 kw \u2581 aej \u2581 tysr \u2581 re \u2581 ujdr \u2581 lkgc \u2581 jv \" ; String result = \" zqour \u2581 language \u2581 is \u2581 impossible \u2581 to \u2581 understand \u2581 there \u2581 are \u2581 twenty \u2581 six \u2581 factorial \u2581 possibilities \u2581 so \u2581 it \u2581 is \u2581 okay \u2581 if \u2581 you \u2581 want \u2581 to \u2581 just \u2581 give \u2581 up \" ; for ( int i = 0 ; i < source . length ( ) ; i ++ ) { codeMap . put ( source . charAt ( i ) , result . charAt ( i ) ) ; } int cases = s . nextInt ( ) ; s . nextLine ( ) ; for ( int Case = 1 ; Case <= cases ; Case ++ ) { String code = s . nextLine ( ) ; char [ ] uncoded = new char [ code . length ( ) ] ; for ( int i = 0 ; i < uncoded . length ; i ++ ) { uncoded [ i ] = codeMap . get ( code . charAt ( i ) ) ; } String answer = String . valueOf ( uncoded ) ; out ( \" Case \u2581 # \" + Case + \" : \u2581 \" + answer ) ; } output . flush ( ) ; }"], ["out", "public static void out ( String s ) { output . println ( s ) ; }"]], "functions_class": []}, {"id": "18", "code": "package google . codejam2012 . qualification ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class SpeakingInTongues { private static String TRANSLATER = \" yhesocvxduiglbkrztnwjpfmaq \" ; private static char translate ( char ch ) { if ( ' a ' <= ch & ch <= ' z ' ) return TRANSLATER . charAt ( ch - ' a ' ) ; else return ch ; } private static String translate ( String s ) { int l = s . length ( ) ; StringBuilder translated = new StringBuilder ( l ) ; for ( int i = 0 ; i < l ; i ++ ) { translated . append ( translate ( s . charAt ( i ) ) ) ; } return translated . toString ( ) ; } public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 64 << 10 ) ; int testsNumber = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; for ( int test = 1 ; test <= testsNumber ; test ++ ) { System . out . println ( \" Case \u2581 # \" + test + \" : \" + translate ( br . readLine ( ) ) ) ; } } catch ( Exception e ) { System . err . println ( \" Error : \" + e . getMessage ( ) ) ; } } }", "functions_standalone": [["translate", "private static char translate ( char ch ) { if ( ' a ' <= ch & ch <= ' z ' ) return TRANSLATER . charAt ( ch - ' a ' ) ; else return ch ; }"], ["translate", "private static String translate ( String s ) { int l = s . length ( ) ; StringBuilder translated = new StringBuilder ( l ) ; for ( int i = 0 ; i < l ; i ++ ) { translated . append ( translate ( s . charAt ( i ) ) ) ; } return translated . toString ( ) ; }"], ["main", "public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 64 << 10 ) ; int testsNumber = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; for ( int test = 1 ; test <= testsNumber ; test ++ ) { System . out . println ( \" Case \u2581 # \" + test + \" : \" + translate ( br . readLine ( ) ) ) ; } } catch ( Exception e ) { System . err . println ( \" Error : \" + e . getMessage ( ) ) ; } }"]], "functions_class": []}, {"id": "6", "code": "import java . util . Scanner ; import java . io . PrintStream ; import java . io . OutputStream ; import java . io . IOException ; import java . io . FileOutputStream ; import java . util . Arrays ; import java . io . PrintWriter ; import java . io . FileInputStream ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream ; try { inputStream = new FileInputStream ( \" gcj1 . in \" ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } OutputStream outputStream ; try { outputStream = new FileOutputStream ( \" gcj1 . out \" ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; GCJ1 solver = new GCJ1 ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } } class GCJ1 { public void solve ( int testNumber , Scanner in , PrintWriter out ) { char [ ] map = { ' y ' , ' h ' , ' e ' , ' s ' , ' o ' , ' c ' , ' v ' , ' x ' , ' d ' , ' u ' , ' i ' , ' g ' , ' l ' , ' b ' , ' k ' , ' r ' , ' z ' , ' t ' , ' n ' , ' w ' , ' j ' , ' p ' , ' f ' , ' m ' , ' a ' , ' q ' } ; int cases = in . nextInt ( ) ; in . nextLine ( ) ; for ( int i = 0 ; i < cases ; i ++ ) { String input = in . nextLine ( ) ; char [ ] output = new char [ input . length ( ) ] ; for ( int j = 0 ; j < output . length ; j ++ ) { if ( input . charAt ( j ) == ' \u2581 ' ) output [ j ] = ' \u2581 ' ; else output [ j ] = map [ input . charAt ( j ) - ' a ' ] ; } out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new String ( output ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { InputStream inputStream ; try { inputStream = new FileInputStream ( \" gcj1 . in \" ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } OutputStream outputStream ; try { outputStream = new FileOutputStream ( \" gcj1 . out \" ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; GCJ1 solver = new GCJ1 ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; }"]], "functions_class": [["solve", "public void solve ( int testNumber , Scanner in , PrintWriter out ) { char [ ] map = { ' y ' , ' h ' , ' e ' , ' s ' , ' o ' , ' c ' , ' v ' , ' x ' , ' d ' , ' u ' , ' i ' , ' g ' , ' l ' , ' b ' , ' k ' , ' r ' , ' z ' , ' t ' , ' n ' , ' w ' , ' j ' , ' p ' , ' f ' , ' m ' , ' a ' , ' q ' } ; int cases = in . nextInt ( ) ; in . nextLine ( ) ; for ( int i = 0 ; i < cases ; i ++ ) { String input = in . nextLine ( ) ; char [ ] output = new char [ input . length ( ) ] ; for ( int j = 0 ; j < output . length ; j ++ ) { if ( input . charAt ( j ) == ' \u2581 ' ) output [ j ] = ' \u2581 ' ; else output [ j ] = map [ input . charAt ( j ) - ' a ' ] ; } out . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new String ( output ) ) ; } }"]]}, {"id": "14", "code": "import java . util . * ; import java . io . * ; import java . math . * ; import java . awt . * ; import static java . lang . Math . * ; import static java . lang . Integer . parseInt ; import static java . lang . Double . parseDouble ; import static java . lang . Long . parseLong ; import static java . lang . System . * ; import static java . util . Arrays . * ; import static java . util . Collection . * ; public class A { static char [ ] Cipher = new char [ 256 ] ; public static void train ( ) { String in = \" ejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjvyeq \" , out = \" ourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveupaoz \" ; fill ( Cipher , ( char ) 0 ) ; for ( int i = 0 ; i < in . length ( ) ; ++ i ) Cipher [ in . charAt ( i ) ] = out . charAt ( i ) ; for ( char i = ' a ' ; i <= ' z ' ; ++ i ) { if ( Cipher [ i ] == 0 ) { char j , k ; for ( j = ' a ' ; j <= ' z ' ; ++ j ) { for ( k = ' a ' ; k <= ' z ' ; ++ k ) if ( Cipher [ k ] == j ) break ; if ( k > ' z ' ) break ; } Cipher [ i ] = j ; } } for ( int i = ' a ' ; i <= ' z ' ; ++ i ) if ( Cipher [ i ] != 0 ) Cipher [ i - ' a ' + ' A ' ] = ( char ) ( i + ( ' A ' - ' a ' ) ) ; } public static void main ( String [ ] args ) throws IOException { train ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int T = parseInt ( br . readLine ( ) ) ; for ( int t = 0 ; t ++ < T ; ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; for ( char c : br . readLine ( ) . toCharArray ( ) ) out . print ( Cipher [ c ] == 0 ? c : Cipher [ c ] ) ; out . println ( ) ; } } }", "functions_standalone": [["train", "public static void train ( ) { String in = \" ejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjvyeq \" , out = \" ourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveupaoz \" ; fill ( Cipher , ( char ) 0 ) ; for ( int i = 0 ; i < in . length ( ) ; ++ i ) Cipher [ in . charAt ( i ) ] = out . charAt ( i ) ; for ( char i = ' a ' ; i <= ' z ' ; ++ i ) { if ( Cipher [ i ] == 0 ) { char j , k ; for ( j = ' a ' ; j <= ' z ' ; ++ j ) { for ( k = ' a ' ; k <= ' z ' ; ++ k ) if ( Cipher [ k ] == j ) break ; if ( k > ' z ' ) break ; } Cipher [ i ] = j ; } } for ( int i = ' a ' ; i <= ' z ' ; ++ i ) if ( Cipher [ i ] != 0 ) Cipher [ i - ' a ' + ' A ' ] = ( char ) ( i + ( ' A ' - ' a ' ) ) ; }"], ["main", "public static void main ( String [ ] args ) throws IOException { train ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int T = parseInt ( br . readLine ( ) ) ; for ( int t = 0 ; t ++ < T ; ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; for ( char c : br . readLine ( ) . toCharArray ( ) ) out . print ( Cipher [ c ] == 0 ? c : Cipher [ c ] ) ; out . println ( ) ; } }"]], "functions_class": []}], "python": [{"id": "15", "code": "import sys NEW_LINE m = { ' \\n ' : ' ' , ' \u2581 ' : ' \u2581 ' , ' a ' : ' y ' , ' b ' : ' h ' , ' c ' : ' e ' , ' d ' : ' s ' , ' e ' : ' o ' , ' f ' : ' c ' , ' g ' : ' v ' , ' h ' : ' x ' , ' i ' : ' d ' , ' j ' : ' u ' , ' k ' : ' i ' , ' l ' : ' g ' , ' n ' : ' b ' , ' m ' : ' l ' , ' o ' : ' k ' , ' p ' : ' r ' , ' q ' : ' z ' , ' r ' : ' t ' , ' s ' : ' n ' , ' t ' : ' w ' , ' u ' : ' j ' , ' v ' : ' p ' , ' w ' : ' f ' , ' x ' : ' m ' , ' y ' : ' a ' , ' z ' : ' q ' } NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) , end = ' ' ) NEW_LINE print ( ' ' . join ( [ m . get ( x , ' [ FAIL : % s ] ' % x ) for x in s ] ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "8", "code": "import sys NEW_LINE def makemap ( ) : NEW_LINE INDENT ALPHA = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE M = { ' y ' : ' a ' , ' e ' : ' o ' , ' q ' : ' z ' , } NEW_LINE G = ''' ejp \u2581 mysljylc \u2581 kd \u2581 kxveddknmc \u2581 re \u2581 jsicpdrysi STRNEWLINE rbcpc \u2581 ypc \u2581 rtcsra \u2581 dkh \u2581 wyfrepkym \u2581 veddknkmkrkcd STRNEWLINE de \u2581 kr \u2581 kd \u2581 eoya \u2581 kw \u2581 aej \u2581 tysr \u2581 re \u2581 ujdr \u2581 lkgc \u2581 jv ''' NEW_LINE E = ''' our \u2581 language \u2581 is \u2581 impossible \u2581 to \u2581 understand STRNEWLINE there \u2581 are \u2581 twenty \u2581 six \u2581 factorial \u2581 possibilities STRNEWLINE so \u2581 it \u2581 is \u2581 okay \u2581 if \u2581 you \u2581 want \u2581 to \u2581 just \u2581 give \u2581 up ''' NEW_LINE assert ( len ( G ) == len ( E ) ) NEW_LINE for i in range ( len ( G ) ) : NEW_LINE INDENT g = G [ i ] NEW_LINE e = E [ i ] NEW_LINE if g in ALPHA : NEW_LINE INDENT assert ( e in ALPHA ) NEW_LINE if g not in M : NEW_LINE INDENT M [ g ] = e NEW_LINE DEDENT else : NEW_LINE INDENT assert ( M [ g ] == e ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert ( e not in ALPHA ) NEW_LINE DEDENT DEDENT assert ( len ( M ) == 25 or len ( M ) == 26 ) NEW_LINE assert ( len ( M ) == len ( set ( M . values ( ) ) ) ) NEW_LINE if len ( M ) == 25 : NEW_LINE INDENT g = ' ' . join ( c for c in ALPHA if c not in M ) NEW_LINE e = ' ' . join ( c for c in ALPHA if c not in M . values ( ) ) NEW_LINE M [ g ] = e NEW_LINE DEDENT assert ( len ( M ) == len ( set ( M . values ( ) ) ) ) NEW_LINE assert ( set ( M ) == set ( ALPHA ) ) NEW_LINE return M NEW_LINE DEDENT def trans ( s , M ) : NEW_LINE INDENT return ' ' . join ( M . get ( c , c ) for c in s ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT M = makemap ( ) NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE s = trans ( s , M ) NEW_LINE sys . stdout . write ( ' Case \u2581 # { } : \u2581 ' . format ( i + 1 ) ) NEW_LINE sys . stdout . write ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["makemap", "def makemap ( ) : NEW_LINE INDENT ALPHA = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE M = { ' y ' : ' a ' , ' e ' : ' o ' , ' q ' : ' z ' , } NEW_LINE G = ''' ejp \u2581 mysljylc \u2581 kd \u2581 kxveddknmc \u2581 re \u2581 jsicpdrysi STRNEWLINE rbcpc \u2581 ypc \u2581 rtcsra \u2581 dkh \u2581 wyfrepkym \u2581 veddknkmkrkcd STRNEWLINE de \u2581 kr \u2581 kd \u2581 eoya \u2581 kw \u2581 aej \u2581 tysr \u2581 re \u2581 ujdr \u2581 lkgc \u2581 jv ''' NEW_LINE E = ''' our \u2581 language \u2581 is \u2581 impossible \u2581 to \u2581 understand STRNEWLINE there \u2581 are \u2581 twenty \u2581 six \u2581 factorial \u2581 possibilities STRNEWLINE so \u2581 it \u2581 is \u2581 okay \u2581 if \u2581 you \u2581 want \u2581 to \u2581 just \u2581 give \u2581 up ''' NEW_LINE assert ( len ( G ) == len ( E ) ) NEW_LINE for i in range ( len ( G ) ) : NEW_LINE INDENT g = G [ i ] NEW_LINE e = E [ i ] NEW_LINE if g in ALPHA : NEW_LINE INDENT assert ( e in ALPHA ) NEW_LINE if g not in M : NEW_LINE INDENT M [ g ] = e NEW_LINE DEDENT else : NEW_LINE INDENT assert ( M [ g ] == e ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert ( e not in ALPHA ) NEW_LINE DEDENT DEDENT assert ( len ( M ) == 25 or len ( M ) == 26 ) NEW_LINE assert ( len ( M ) == len ( set ( M . values ( ) ) ) ) NEW_LINE if len ( M ) == 25 : NEW_LINE INDENT g = ' ' . join ( c for c in ALPHA if c not in M ) NEW_LINE e = ' ' . join ( c for c in ALPHA if c not in M . values ( ) ) NEW_LINE M [ g ] = e NEW_LINE DEDENT assert ( len ( M ) == len ( set ( M . values ( ) ) ) ) NEW_LINE assert ( set ( M ) == set ( ALPHA ) ) NEW_LINE return M NEW_LINE DEDENT"], ["trans", "def trans ( s , M ) : NEW_LINE INDENT return ' ' . join ( M . get ( c , c ) for c in s ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT M = makemap ( ) NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE s = trans ( s , M ) NEW_LINE sys . stdout . write ( ' Case \u2581 # { } : \u2581 ' . format ( i + 1 ) ) NEW_LINE sys . stdout . write ( s ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "6", "code": "import sys NEW_LINE d = { ' a ' : ' y ' , ' o ' : ' e ' , ' z ' : ' q ' , ' \u2581 ' : ' \u2581 ' , ' r ' : ' p ' , ' l ' : ' m ' , ' n ' : ' s ' , ' g ' : ' l ' , ' u ' : ' j ' , ' e ' : ' c ' , ' i ' : ' k ' , ' s ' : ' d ' , ' m ' : ' x ' , ' p ' : ' v ' , ' t ' : ' r ' , ' d ' : ' i ' , ' b ' : ' n ' , ' h ' : ' b ' , ' w ' : ' t ' , ' y ' : ' a ' , ' x ' : ' h ' , ' f ' : ' w ' , ' c ' : ' f ' , ' k ' : ' o ' , ' j ' : ' u ' , ' v ' : ' g ' , ' q ' : ' z ' , ' \\n ' : ' \\n ' , } NEW_LINE r = dict ( ( v , k ) for ( k , v ) in d . items ( ) ) NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = sys . stdin NEW_LINE if len ( sys . argv ) >= 2 : NEW_LINE INDENT fn = sys . argv [ 1 ] NEW_LINE if fn != ' - ' : NEW_LINE INDENT f = open ( fn ) NEW_LINE DEDENT DEDENT f . readline ( ) NEW_LINE i = 1 NEW_LINE for l in f : NEW_LINE INDENT sys . stdout . write ( \" Case \u2581 # % d : \u2581 \" % i ) NEW_LINE for c in l : NEW_LINE INDENT sys . stdout . write ( r [ c ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "14", "code": "from __future__ import division NEW_LINE from __future__ import with_statement NEW_LINE from __future__ import print_function NEW_LINE def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT from os . path import basename , splitext NEW_LINE TASK = splitext ( basename ( __file__ ) ) [ 0 ] NEW_LINE print ( \" Task \u2581 { } \" . format ( TASK ) ) NEW_LINE print ( \" Precalculation . . . \" ) NEW_LINE from string import maketrans NEW_LINE src = \"\"\" aozq STRNEWLINE ejp \u2581 mysljylc \u2581 kd \u2581 kxveddknmc \u2581 re \u2581 jsicpdrysi STRNEWLINE rbcpc \u2581 ypc \u2581 rtcsra \u2581 dkh \u2581 wyfrepkym \u2581 veddknkmkrkcd STRNEWLINE de \u2581 kr \u2581 kd \u2581 eoya \u2581 kw \u2581 aej \u2581 tysr \u2581 re \u2581 ujdr \u2581 lkgc \u2581 jv \"\"\" NEW_LINE dst = \"\"\" yeqz STRNEWLINE our \u2581 language \u2581 is \u2581 impossible \u2581 to \u2581 understand STRNEWLINE there \u2581 are \u2581 twenty \u2581 six \u2581 factorial \u2581 possibilities STRNEWLINE so \u2581 it \u2581 is \u2581 okay \u2581 if \u2581 you \u2581 want \u2581 to \u2581 just \u2581 give \u2581 up \"\"\" NEW_LINE table = maketrans ( src , dst ) NEW_LINE print ( \" Precalculation \u2581 done . \" ) NEW_LINE print ( \" Calculation . . . \" ) NEW_LINE with open ( TASK + \" . in \" ) as infile : NEW_LINE INDENT with open ( TASK + \" . out \" , mode = \" wt \" ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for ncase in range ( cases ) : NEW_LINE INDENT print ( \" Case \u2581 # { nc } \" . format ( nc = ncase + 1 ) ) NEW_LINE text = infile . readline ( ) . strip ( ) NEW_LINE data = text . translate ( table ) NEW_LINE outfile . write ( \" Case \u2581 # { nc } : \u2581 { data } \\n \" . format ( nc = ncase + 1 , data = data ) ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Calculation \u2581 done . \" ) NEW_LINE", "functions_standalone": [["memoized", "def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT"]], "functions_class": []}, {"id": "2", "code": "import string NEW_LINE encrypted = [ ' ejp \u2581 mysljylc \u2581 kd \u2581 kxveddknmc \u2581 re \u2581 jsicpdrysi ' , ' rbcpc \u2581 ypc \u2581 rtcsra \u2581 dkh \u2581 wyfrepkym \u2581 veddknkmkrkcd ' , ' de \u2581 kr \u2581 kd \u2581 eoya \u2581 kw \u2581 aej \u2581 tysr \u2581 re \u2581 ujdr \u2581 lkgc \u2581 jv ' , ' y \u2581 qeez ' ] NEW_LINE decrypted = [ ' our \u2581 language \u2581 is \u2581 impossible \u2581 to \u2581 understand ' , ' there \u2581 are \u2581 twenty \u2581 six \u2581 factorial \u2581 possibilities ' , ' so \u2581 it \u2581 is \u2581 okay \u2581 if \u2581 you \u2581 want \u2581 to \u2581 just \u2581 give \u2581 up ' , ' a \u2581 zooq ' ] NEW_LINE mapping = { } NEW_LINE for enc , dec in zip ( encrypted , decrypted ) : NEW_LINE INDENT for i in xrange ( len ( enc ) ) : NEW_LINE INDENT mapping [ enc [ i ] ] = dec [ i ] NEW_LINE DEDENT DEDENT def decrypt_string ( s ) : NEW_LINE INDENT dec = ' ' NEW_LINE for c in s : NEW_LINE INDENT dec += mapping [ c ] NEW_LINE DEDENT return dec NEW_LINE DEDENT N = int ( raw_input ( ) ) NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT line = raw_input ( ) . split ( ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) + ' \u2581 ' . join ( decrypt_string ( s ) for s in line ) NEW_LINE DEDENT", "functions_standalone": [["decrypt_string", "def decrypt_string ( s ) : NEW_LINE INDENT dec = ' ' NEW_LINE for c in s : NEW_LINE INDENT dec += mapping [ c ] NEW_LINE DEDENT return dec NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_41", "java": [{"id": "9", "code": "package gcj ; import java . util . * ; import java . io . * ; public class Swinging { final static String PROBLEM_NAME = \" swing \" ; final static String WORK_DIR = \" D : \\\\ Gcj \\ \\\" + PROBLEM_NAME + \" \\ \\\" ; static void preprocess ( ) { } void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; int [ ] dist = new int [ N ] ; int [ ] len = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dist [ i ] = sc . nextInt ( ) ; len [ i ] = sc . nextInt ( ) ; } int D = sc . nextInt ( ) ; int [ ] maxH = new int [ N ] ; Arrays . fill ( maxH , - 1 ) ; maxH [ 0 ] = dist [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( maxH [ i ] == - 1 ) continue ; if ( D - dist [ i ] <= maxH [ i ] ) { pw . println ( \" YES \" ) ; return ; } for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] - dist [ i ] <= maxH [ i ] ) maxH [ j ] = Math . max ( maxH [ j ] , Math . min ( len [ j ] , dist [ j ] - dist [ i ] ) ) ; } pw . println ( \" NO \" ) ; } public static void main ( String [ ] args ) throws Exception { preprocess ( ) ; Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new Swinging ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["preprocess", "static void preprocess ( ) { }"], ["main", "public static void main ( String [ ] args ) throws Exception { preprocess ( ) ; Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new Swinging ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["solve", "void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; int [ ] dist = new int [ N ] ; int [ ] len = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dist [ i ] = sc . nextInt ( ) ; len [ i ] = sc . nextInt ( ) ; } int D = sc . nextInt ( ) ; int [ ] maxH = new int [ N ] ; Arrays . fill ( maxH , - 1 ) ; maxH [ 0 ] = dist [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( maxH [ i ] == - 1 ) continue ; if ( D - dist [ i ] <= maxH [ i ] ) { pw . println ( \" YES \" ) ; return ; } for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] - dist [ i ] <= maxH [ i ] ) maxH [ j ] = Math . max ( maxH [ j ] , Math . min ( len [ j ] , dist [ j ] - dist [ i ] ) ) ; } pw . println ( \" NO \" ) ; }"]]}, {"id": "4", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class A { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( A . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( A . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new A ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; } private String solve ( Scanner in ) { int n = in . nextInt ( ) ; int [ ] d = new int [ n + 1 ] ; int [ ] l = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { d [ i ] = in . nextInt ( ) ; l [ i ] = in . nextInt ( ) ; } d [ n ] = in . nextInt ( ) ; int [ ] z = new int [ n + 1 ] ; z [ 0 ] = d [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { z [ i ] = Math . min ( z [ i ] , l [ i ] ) ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( d [ j ] <= d [ i ] + z [ i ] ) { z [ j ] = Math . max ( z [ j ] , d [ j ] - d [ i ] ) ; } } } return z [ n ] > 0 ? \" YES \" : \" NO \" ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( A . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( A . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new A ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private String solve ( Scanner in ) { int n = in . nextInt ( ) ; int [ ] d = new int [ n + 1 ] ; int [ ] l = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { d [ i ] = in . nextInt ( ) ; l [ i ] = in . nextInt ( ) ; } d [ n ] = in . nextInt ( ) ; int [ ] z = new int [ n + 1 ] ; z [ 0 ] = d [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { z [ i ] = Math . min ( z [ i ] , l [ i ] ) ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( d [ j ] <= d [ i ] + z [ i ] ) { z [ j ] = Math . max ( z [ j ] , d [ j ] - d [ i ] ) ; } } } return z [ n ] > 0 ? \" YES \" : \" NO \" ; }"]]}, {"id": "12", "code": "import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Scanner ; public class A { Scanner in ; PrintWriter out ; void doit ( int tnum ) { int n = in . nextInt ( ) ; long [ ] d = new long [ n ] ; long [ ] l = new long [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { d [ i ] = in . nextLong ( ) ; l [ i ] = in . nextLong ( ) ; } long D = in . nextLong ( ) ; long [ ] ans = new long [ n ] ; ans [ 0 ] = d [ 0 ] ; boolean ok = false ; for ( int i = 1 ; i < n ; ++ i ) ans [ i ] = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( D - d [ i ] <= ans [ i ] ) ok = true ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( ( d [ j ] - d [ i ] ) <= ans [ i ] ) { long attempt = Math . min ( l [ j ] , d [ j ] - d [ i ] ) ; if ( ans [ j ] == - 1 ) ans [ j ] = attempt ; if ( ans [ j ] < attempt ) ans [ j ] = attempt ; } } } out . println ( \" Case \u2581 # \" + tnum + \" : \u2581 \" + ( ok ? \" YES \" : \" NO \" ) ) ; System . err . println ( \" Case \u2581 # \" + tnum + \" : \u2581 \" + ( ok ? \" YES \" : \" NO \" ) ) ; } public void doit ( ) throws IOException { out = new PrintWriter ( new FileOutputStream ( \" output . txt \" ) ) ; in = new Scanner ( new FileInputStream ( \" A - large . in \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; ++ i ) { doit ( i + 1 ) ; } out . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new A ( ) . doit ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new A ( ) . doit ( ) ; }"]], "functions_class": [["doit", "void doit ( int tnum ) { int n = in . nextInt ( ) ; long [ ] d = new long [ n ] ; long [ ] l = new long [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { d [ i ] = in . nextLong ( ) ; l [ i ] = in . nextLong ( ) ; } long D = in . nextLong ( ) ; long [ ] ans = new long [ n ] ; ans [ 0 ] = d [ 0 ] ; boolean ok = false ; for ( int i = 1 ; i < n ; ++ i ) ans [ i ] = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( D - d [ i ] <= ans [ i ] ) ok = true ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( ( d [ j ] - d [ i ] ) <= ans [ i ] ) { long attempt = Math . min ( l [ j ] , d [ j ] - d [ i ] ) ; if ( ans [ j ] == - 1 ) ans [ j ] = attempt ; if ( ans [ j ] < attempt ) ans [ j ] = attempt ; } } } out . println ( \" Case \u2581 # \" + tnum + \" : \u2581 \" + ( ok ? \" YES \" : \" NO \" ) ) ; System . err . println ( \" Case \u2581 # \" + tnum + \" : \u2581 \" + ( ok ? \" YES \" : \" NO \" ) ) ; }"], ["doit", "public void doit ( ) throws IOException { out = new PrintWriter ( new FileOutputStream ( \" output . txt \" ) ) ; in = new Scanner ( new FileInputStream ( \" A - large . in \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; ++ i ) { doit ( i + 1 ) ; } out . close ( ) ; }"]]}, {"id": "19", "code": "import java . util . Arrays ; import java . util . Scanner ; public class A { static int n ; static long [ ] D ; static long [ ] L ; static int [ ] P ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { n = in . nextInt ( ) ; D = new long [ n + 2 ] ; L = new long [ n + 2 ] ; P = new int [ n + 2 ] ; D [ 0 ] = 0 ; L [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { D [ i + 1 ] = in . nextLong ( ) ; L [ i + 1 ] = in . nextLong ( ) ; } D [ n + 1 ] = in . nextLong ( ) ; L [ n + 1 ] = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) P [ i ] = n + 10 ; P [ 1 ] = 0 ; for ( int c = 1 ; c < n + 2 ; c ++ ) { if ( P [ c ] == n + 10 ) continue ; long my_len = Math . min ( L [ c ] , D [ c ] - D [ P [ c ] ] ) ; for ( int nxt = c + 1 ; nxt < n + 2 && D [ nxt ] - D [ c ] <= my_len ; nxt ++ ) { P [ nxt ] = Math . min ( P [ nxt ] , c ) ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , cas , P [ n + 1 ] == n + 10 ? \" NO \" : \" YES \" ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { n = in . nextInt ( ) ; D = new long [ n + 2 ] ; L = new long [ n + 2 ] ; P = new int [ n + 2 ] ; D [ 0 ] = 0 ; L [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { D [ i + 1 ] = in . nextLong ( ) ; L [ i + 1 ] = in . nextLong ( ) ; } D [ n + 1 ] = in . nextLong ( ) ; L [ n + 1 ] = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) P [ i ] = n + 10 ; P [ 1 ] = 0 ; for ( int c = 1 ; c < n + 2 ; c ++ ) { if ( P [ c ] == n + 10 ) continue ; long my_len = Math . min ( L [ c ] , D [ c ] - D [ P [ c ] ] ) ; for ( int nxt = c + 1 ; nxt < n + 2 && D [ nxt ] - D [ c ] <= my_len ; nxt ++ ) { P [ nxt ] = Math . min ( P [ nxt ] , c ) ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , cas , P [ n + 1 ] == n + 10 ? \" NO \" : \" YES \" ) ; } }"]], "functions_class": []}, {"id": "14", "code": "import java . util . Arrays ; import java . util . Scanner ; public class A { static Scanner sc = new Scanner ( System . in ) ; static class Solver { int N ; int [ ] ds ; int [ ] ls ; int D ; boolean solve ( ) { N = sc . nextInt ( ) ; ds = new int [ N ] ; ls = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { ds [ i ] = sc . nextInt ( ) ; ls [ i ] = sc . nextInt ( ) ; } D = sc . nextInt ( ) ; int [ ] reach = new int [ N ] ; Arrays . fill ( reach , - 1 ) ; if ( ds [ 0 ] > ls [ 0 ] ) return false ; reach [ 0 ] = ds [ 0 ] ; for ( int i = 0 ; i < N ; ++ i ) { if ( reach [ i ] < 0 ) continue ; if ( reach [ i ] >= D - ds [ i ] ) return true ; for ( int j = i + 1 ; j < N ; ++ j ) { if ( reach [ j ] >= 0 ) continue ; if ( ds [ j ] > ds [ i ] + reach [ i ] ) break ; reach [ j ] = Math . min ( ds [ j ] - ds [ i ] , ls [ j ] ) ; } } return false ; } } public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; Solver solver = new Solver ( ) ; System . out . println ( solver . solve ( ) ? \" YES \" : \" NO \" ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; Solver solver = new Solver ( ) ; System . out . println ( solver . solve ( ) ? \" YES \" : \" NO \" ) ; } }"]], "functions_class": [["solve", "boolean solve ( ) { N = sc . nextInt ( ) ; ds = new int [ N ] ; ls = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { ds [ i ] = sc . nextInt ( ) ; ls [ i ] = sc . nextInt ( ) ; } D = sc . nextInt ( ) ; int [ ] reach = new int [ N ] ; Arrays . fill ( reach , - 1 ) ; if ( ds [ 0 ] > ls [ 0 ] ) return false ; reach [ 0 ] = ds [ 0 ] ; for ( int i = 0 ; i < N ; ++ i ) { if ( reach [ i ] < 0 ) continue ; if ( reach [ i ] >= D - ds [ i ] ) return true ; for ( int j = i + 1 ; j < N ; ++ j ) { if ( reach [ j ] >= 0 ) continue ; if ( ds [ j ] > ds [ i ] + reach [ i ] ) break ; reach [ j ] = Math . min ( ds [ j ] - ds [ i ] , ls [ j ] ) ; } } return false ; }"]]}], "python": [{"id": "11", "code": "from collections import deque NEW_LINE import sys NEW_LINE fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( fin . readline ( ) ) NEW_LINE vines = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT di , li = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE vines . append ( ( di , li ) ) NEW_LINE DEDENT D = int ( fin . readline ( ) ) NEW_LINE vines . append ( ( D , 0 ) ) NEW_LINE queue = deque ( [ ( vines [ 0 ] [ 0 ] , vines [ 0 ] [ 0 ] * 2 ) ] ) NEW_LINE for d , l in vines [ 1 : ] : NEW_LINE INDENT while queue and queue [ 0 ] [ 1 ] < d : NEW_LINE INDENT queue . popleft ( ) NEW_LINE DEDENT if not queue : NEW_LINE INDENT break NEW_LINE DEDENT distance = min ( l , d - queue [ 0 ] [ 0 ] ) NEW_LINE p = d + distance NEW_LINE if p > queue [ - 1 ] [ 1 ] : NEW_LINE INDENT queue . append ( ( d , p ) ) NEW_LINE DEDENT DEDENT success = bool ( queue ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , success and \" YES \" or \" NO \" ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "14", "code": "f = open ( \" data . txt \" , ' r ' ) NEW_LINE g = open ( \" data1 . txt \" , ' w ' ) NEW_LINE line = f . readline ( ) NEW_LINE t = int ( line ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT line = f . readline ( ) NEW_LINE n = int ( line ) NEW_LINE vines = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT line = f . readline ( ) NEW_LINE integers = [ int ( x ) for x in line . split ( ) ] NEW_LINE vines . append ( integers ) NEW_LINE DEDENT line = f . readline ( ) NEW_LINE d = int ( line ) NEW_LINE vines . append ( [ d , 0 ] ) NEW_LINE reachable = dict ( ) NEW_LINE reachable [ 0 ] = vines [ 0 ] [ 0 ] NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT reachable [ j ] = - 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT hook = vines [ j ] [ 0 ] NEW_LINE hang = reachable [ j ] NEW_LINE for k in range ( j + 1 , n + 1 ) : NEW_LINE INDENT if ( vines [ k ] [ 0 ] - hook ) > hang : NEW_LINE INDENT break NEW_LINE DEDENT reachable [ k ] = max ( reachable [ k ] , min ( vines [ k ] [ 1 ] , ( vines [ k ] [ 0 ] - hook ) ) ) NEW_LINE DEDENT DEDENT if reachable [ n ] > - 1 : NEW_LINE INDENT result = \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT result = \" NO \" NEW_LINE DEDENT string = \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + result + ' \\n ' NEW_LINE g . write ( string ) NEW_LINE DEDENT f . close ( ) NEW_LINE g . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "testCount = int ( raw_input ( ) ) NEW_LINE for testIndex in range ( testCount ) : NEW_LINE INDENT ans = \" Case \u2581 # \" + str ( testIndex + 1 ) + \" : \u2581 \" NEW_LINE n = int ( raw_input ( ) ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v += [ [ int ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] ] NEW_LINE DEDENT g = int ( raw_input ( ) ) NEW_LINE p = [ 0 ] * n NEW_LINE p [ 0 ] = v [ 0 ] [ 0 ] NEW_LINE res = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] + v [ i ] [ 0 ] >= g : NEW_LINE INDENT res = True NEW_LINE break NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if p [ i ] + v [ i ] [ 0 ] < v [ j ] [ 0 ] : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT pp = min ( v [ j ] [ 1 ] , v [ j ] [ 0 ] - v [ i ] [ 0 ] ) NEW_LINE p [ j ] = max ( p [ j ] , pp ) NEW_LINE DEDENT DEDENT DEDENT if res : NEW_LINE INDENT ans += \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT ans += \" NO \" NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "18", "code": "import sys NEW_LINE def get_ints ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield int ( word ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT ints = get_ints ( ) NEW_LINE def get_floats ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield float ( word ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT floats = get_floats ( ) NEW_LINE def up ( a ) : NEW_LINE INDENT i = 1 NEW_LINE while i < a : NEW_LINE INDENT i *= 2 NEW_LINE DEDENT return 2 * i NEW_LINE DEDENT T = next ( ints ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT def solve ( ) : NEW_LINE INDENT N = next ( ints ) NEW_LINE D = ( N + 1 ) * [ 0 ] NEW_LINE L = ( N + 1 ) * [ 0 ] NEW_LINE K = ( N + 1 ) * [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT D [ i ] = next ( ints ) NEW_LINE L [ i ] = next ( ints ) NEW_LINE DEDENT D [ N ] = next ( ints ) NEW_LINE K [ 0 ] = D [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j <= N and D [ j ] - D [ i ] <= K [ i ] : NEW_LINE INDENT if j == N : return True NEW_LINE K [ j ] = max ( K [ j ] , min ( D [ j ] - D [ i ] , L [ j ] ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if solve ( ) : NEW_LINE INDENT print ( \" Case \u2581 # \" , t + 1 , \" : \u2581 YES \" , sep = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case \u2581 # \" , t + 1 , \" : \u2581 NO \" , sep = ' ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["get_ints", "def get_ints ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield int ( word ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT"], ["get_floats", "def get_floats ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield float ( word ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT"], ["up", "def up ( a ) : NEW_LINE INDENT i = 1 NEW_LINE while i < a : NEW_LINE INDENT i *= 2 NEW_LINE DEDENT return 2 * i NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT N = next ( ints ) NEW_LINE D = ( N + 1 ) * [ 0 ] NEW_LINE L = ( N + 1 ) * [ 0 ] NEW_LINE K = ( N + 1 ) * [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT D [ i ] = next ( ints ) NEW_LINE L [ i ] = next ( ints ) NEW_LINE DEDENT D [ N ] = next ( ints ) NEW_LINE K [ 0 ] = D [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j <= N and D [ j ] - D [ i ] <= K [ i ] : NEW_LINE INDENT if j == N : return True NEW_LINE K [ j ] = max ( K [ j ] , min ( D [ j ] - D [ i ] , L [ j ] ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"]], "functions_class": []}, {"id": "13", "code": "import sys NEW_LINE import heapq NEW_LINE def case ( ) : NEW_LINE INDENT N = int ( sys . stdin . readline ( ) ) NEW_LINE vines = [ ] NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT vines . append ( [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] ) NEW_LINE DEDENT D = int ( sys . stdin . readline ( ) ) NEW_LINE vines . append ( [ D , 0 ] ) NEW_LINE reach = [ - 1 for i in range ( 0 , N + 1 ) ] NEW_LINE reach [ 0 ] = vines [ 0 ] [ 0 ] NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 ) : NEW_LINE INDENT if vines [ j ] [ 0 ] > vines [ i ] [ 0 ] + reach [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT r = min ( vines [ j ] [ 1 ] , vines [ j ] [ 0 ] - vines [ i ] [ 0 ] ) NEW_LINE if r > reach [ j ] : NEW_LINE INDENT reach [ j ] = r NEW_LINE DEDENT DEDENT DEDENT if reach [ N ] != - 1 : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT r = case ( ) NEW_LINE print ( \" Case \u2581 # % s : \u2581 % s \" % ( i , r ) ) NEW_LINE DEDENT", "functions_standalone": [["case", "def case ( ) : NEW_LINE INDENT N = int ( sys . stdin . readline ( ) ) NEW_LINE vines = [ ] NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT vines . append ( [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] ) NEW_LINE DEDENT D = int ( sys . stdin . readline ( ) ) NEW_LINE vines . append ( [ D , 0 ] ) NEW_LINE reach = [ - 1 for i in range ( 0 , N + 1 ) ] NEW_LINE reach [ 0 ] = vines [ 0 ] [ 0 ] NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 ) : NEW_LINE INDENT if vines [ j ] [ 0 ] > vines [ i ] [ 0 ] + reach [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT r = min ( vines [ j ] [ 1 ] , vines [ j ] [ 0 ] - vines [ i ] [ 0 ] ) NEW_LINE if r > reach [ j ] : NEW_LINE INDENT reach [ j ] = r NEW_LINE DEDENT DEDENT DEDENT if reach [ N ] != - 1 : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_12_23", "java": [{"id": "8", "code": "package round1 ; import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Kattio extends PrintWriter { public Kattio ( InputStream i ) { super ( new BufferedOutputStream ( System . out ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public Kattio ( InputStream i , OutputStream o ) { super ( new BufferedOutputStream ( o ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public boolean hasMoreTokens ( ) { return peekToken ( ) != null ; } public int getInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } public double getDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } public long getLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } public String getWord ( ) { return nextToken ( ) ; } private BufferedReader r ; private String line ; private StringTokenizer st ; private String token ; private String peekToken ( ) { if ( token == null ) try { while ( st == null || ! st . hasMoreTokens ( ) ) { line = r . readLine ( ) ; if ( line == null ) return null ; st = new StringTokenizer ( line ) ; } token = st . nextToken ( ) ; } catch ( IOException e ) { } return token ; } private String nextToken ( ) { String ans = peekToken ( ) ; token = null ; return ans ; } }", "functions_standalone": [], "functions_class": [["Kattio", "public Kattio ( InputStream i ) { super ( new BufferedOutputStream ( System . out ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; }"], ["Kattio", "public Kattio ( InputStream i , OutputStream o ) { super ( new BufferedOutputStream ( o ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; }"], ["hasMoreTokens", "public boolean hasMoreTokens ( ) { return peekToken ( ) != null ; }"], ["getInt", "public int getInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["getDouble", "public double getDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; }"], ["getLong", "public long getLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["getWord", "public String getWord ( ) { return nextToken ( ) ; }"], ["peekToken", "private String peekToken ( ) { if ( token == null ) try { while ( st == null || ! st . hasMoreTokens ( ) ) { line = r . readLine ( ) ; if ( line == null ) return null ; st = new StringTokenizer ( line ) ; } token = st . nextToken ( ) ; } catch ( IOException e ) { } return token ; }"], ["nextToken", "private String nextToken ( ) { String ans = peekToken ( ) ; token = null ; return ans ; }"]]}, {"id": "13", "code": "import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . HashMap ; import java . util . Map ; import java . util . Random ; import java . util . Scanner ; public class EqualSums2 { public static void main ( final String ... args ) throws IOException { final String fname = \" C - large \" ; final Scanner sc = new Scanner ( new File ( fname + \" . in \" ) ) ; final PrintWriter pw = new PrintWriter ( fname + \" . out \" ) ; final int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; ++ i ) { System . out . println ( i ) ; final int n = sc . nextInt ( ) ; final long [ ] a = new long [ n ] ; for ( int j = 0 ; j < n ; ++ j ) { a [ j ] = sc . nextLong ( ) ; } final Random rnd = new Random ( ) ; final Map < Long , Long > m = new HashMap < Long , Long > ( ) ; long s1 = - 1 ; long s2 = - 1 ; while ( true ) { long j = rnd . nextLong ( ) ; if ( j < 0 ) { continue ; } long x = j ; int k = 0 ; long s = 0 ; while ( x > 0 ) { if ( ( x & 1 ) != 0 ) { s += a [ k ] ; } x >>= 1 ; ++ k ; } final Long b = m . get ( s ) ; if ( b == null ) { m . put ( s , j ) ; } else if ( b != j ) { s1 = b ; s2 = j ; break ; } } pw . println ( \" Case \u2581 # \" + i + \" : \" ) ; int k = 0 ; while ( s1 > 0 ) { if ( ( s1 & 1 ) != 0 ) { pw . print ( a [ k ] + \" \u2581 \" ) ; } s1 >>= 1 ; ++ k ; } pw . println ( ) ; k = 0 ; while ( s2 > 0 ) { if ( ( s2 & 1 ) != 0 ) { pw . print ( a [ k ] + \" \u2581 \" ) ; } s2 >>= 1 ; ++ k ; } pw . println ( ) ; } pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( final String ... args ) throws IOException { final String fname = \" C - large \" ; final Scanner sc = new Scanner ( new File ( fname + \" . in \" ) ) ; final PrintWriter pw = new PrintWriter ( fname + \" . out \" ) ; final int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; ++ i ) { System . out . println ( i ) ; final int n = sc . nextInt ( ) ; final long [ ] a = new long [ n ] ; for ( int j = 0 ; j < n ; ++ j ) { a [ j ] = sc . nextLong ( ) ; } final Random rnd = new Random ( ) ; final Map < Long , Long > m = new HashMap < Long , Long > ( ) ; long s1 = - 1 ; long s2 = - 1 ; while ( true ) { long j = rnd . nextLong ( ) ; if ( j < 0 ) { continue ; } long x = j ; int k = 0 ; long s = 0 ; while ( x > 0 ) { if ( ( x & 1 ) != 0 ) { s += a [ k ] ; } x >>= 1 ; ++ k ; } final Long b = m . get ( s ) ; if ( b == null ) { m . put ( s , j ) ; } else if ( b != j ) { s1 = b ; s2 = j ; break ; } } pw . println ( \" Case \u2581 # \" + i + \" : \" ) ; int k = 0 ; while ( s1 > 0 ) { if ( ( s1 & 1 ) != 0 ) { pw . print ( a [ k ] + \" \u2581 \" ) ; } s1 >>= 1 ; ++ k ; } pw . println ( ) ; k = 0 ; while ( s2 > 0 ) { if ( ( s2 & 1 ) != 0 ) { pw . print ( a [ k ] + \" \u2581 \" ) ; } s2 >>= 1 ; ++ k ; } pw . println ( ) ; } pw . close ( ) ; }"]], "functions_class": []}, {"id": "20", "code": "import java . io . * ; import java . util . * ; public class C implements Runnable { private final int MAX_VALUE = 100000 * 20 + 10 ; private String IFILE = \" C - small - attempt0 . in \" ; private Scanner in ; private PrintWriter out ; public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . println ( \" Case \u2581 # \" + test + \" : \" ) ; int n = in . nextInt ( ) ; int [ ] mas = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mas [ i ] = in . nextInt ( ) ; Arrays . sort ( mas ) ; int [ ] f = new int [ MAX_VALUE ] ; Arrays . fill ( f , - 1 ) ; f [ 0 ] = 0 ; boolean ok = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int d = MAX_VALUE - 1 ; d >= 0 ; d -- ) { if ( f [ d ] == - 1 ) continue ; int dd = d + mas [ i ] ; if ( f [ dd ] != - 1 ) { ok = true ; int z = dd ; while ( z != 0 ) { if ( z != dd ) out . print ( \" \u2581 \" ) ; out . print ( mas [ f [ z ] ] ) ; z -= mas [ f [ z ] ] ; } out . println ( ) ; out . print ( mas [ i ] ) ; z = d ; while ( z != 0 ) { out . print ( \" \u2581 \" + mas [ f [ z ] ] ) ; z -= mas [ f [ z ] ] ; } out . println ( ) ; break ; } else f [ dd ] = i ; } if ( ok ) break ; } if ( ! ok ) out . println ( \" Impossible \" ) ; } in . close ( ) ; out . close ( ) ; } public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } } public static void main ( String [ ] args ) throws IOException { new C ( ) . Run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new C ( ) . Run ( ) ; }"]], "functions_class": [["Run", "public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . println ( \" Case \u2581 # \" + test + \" : \" ) ; int n = in . nextInt ( ) ; int [ ] mas = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mas [ i ] = in . nextInt ( ) ; Arrays . sort ( mas ) ; int [ ] f = new int [ MAX_VALUE ] ; Arrays . fill ( f , - 1 ) ; f [ 0 ] = 0 ; boolean ok = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int d = MAX_VALUE - 1 ; d >= 0 ; d -- ) { if ( f [ d ] == - 1 ) continue ; int dd = d + mas [ i ] ; if ( f [ dd ] != - 1 ) { ok = true ; int z = dd ; while ( z != 0 ) { if ( z != dd ) out . print ( \" \u2581 \" ) ; out . print ( mas [ f [ z ] ] ) ; z -= mas [ f [ z ] ] ; } out . println ( ) ; out . print ( mas [ i ] ) ; z = d ; while ( z != 0 ) { out . print ( \" \u2581 \" + mas [ f [ z ] ] ) ; z -= mas [ f [ z ] ] ; } out . println ( ) ; break ; } else f [ dd ] = i ; } if ( ok ) break ; } if ( ! ok ) out . println ( \" Impossible \" ) ; } in . close ( ) ; out . close ( ) ; }"], ["run", "public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } }"]]}], "python": [{"id": "9", "code": "class Solver ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def setup ( cls , infile ) : NEW_LINE INDENT cls . data = { } NEW_LINE DEDENT def __init__ ( self , infile , tc ) : NEW_LINE INDENT self . tc = tc NEW_LINE self . I = I = map ( int , infile . next ( ) . split ( ) ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT import itertools as it NEW_LINE S = self . I [ 1 : ] NEW_LINE seen = { } NEW_LINE for n in xrange ( 1 , 4 ) : NEW_LINE INDENT for s in it . combinations ( S , n ) : NEW_LINE INDENT ss = sum ( s ) NEW_LINE if ss in seen : NEW_LINE INDENT return ' Case \u2581 # % s : \\n % s \\n % s \\n ' % ( self . tc , ' \u2581 ' . join ( ' % d ' % i for i in s ) , ' \u2581 ' . join ( ' % d ' % i for i in seen [ ss ] ) , ) NEW_LINE DEDENT seen [ ss ] = s NEW_LINE DEDENT DEDENT return ' Case \u2581 # % s : \u2581 Impossible \\n ' % ( self . tc , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE T = int ( sys . stdin . next ( ) ) NEW_LINE Solver . setup ( sys . stdin ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT sys . stdout . write ( Solver ( sys . stdin , t ) . solve ( ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["setup", "def setup ( cls , infile ) : NEW_LINE INDENT cls . data = { } NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self , infile , tc ) : NEW_LINE INDENT self . tc = tc NEW_LINE self . I = I = map ( int , infile . next ( ) . split ( ) ) NEW_LINE DEDENT"]]}, {"id": "3", "code": "def readline_ints ( ) : NEW_LINE INDENT return [ int ( num ) for num in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT import itertools NEW_LINE def ordered_subsets_sums ( S ) : NEW_LINE INDENT lim = sum ( S ) // 2 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT for subset in itertools . combinations ( S , i ) : NEW_LINE INDENT sub_sum = sum ( subset ) NEW_LINE if sub_sum > lim : NEW_LINE INDENT break NEW_LINE DEDENT yield subset , sub_sum NEW_LINE DEDENT DEDENT DEDENT def find_collision ( S ) : NEW_LINE INDENT sums = { } NEW_LINE for sub , sub_sum in ordered_subsets_sums ( S ) : NEW_LINE INDENT if sub_sum in sums : NEW_LINE INDENT return sums [ sub_sum ] , sub NEW_LINE DEDENT sums [ sub_sum ] = sub NEW_LINE DEDENT DEDENT fname = \" C - large \" NEW_LINE with open ( fname + \" . in \" , \" r \" ) as fin , open ( fname + \" . out \" , \" w \" ) as fout : NEW_LINE INDENT numcases = readline_ints ( ) [ 0 ] NEW_LINE print ( numcases , \" cases \" ) NEW_LINE for caseno in range ( 1 , numcases + 1 ) : NEW_LINE INDENT N , * S = readline_ints ( ) NEW_LINE S . sort ( ) NEW_LINE coll = find_collision ( S ) NEW_LINE if coll is None : NEW_LINE INDENT result = \" Impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT s1 , s2 = coll NEW_LINE result = \" \u2581 \" . join ( str ( n ) for n in sorted ( s1 ) ) + \" \\n \" + \" \u2581 \" . join ( str ( n ) for n in sorted ( s2 ) ) NEW_LINE DEDENT outstr = \" Case \u2581 # % d : \\n % s \" % ( caseno , result ) NEW_LINE fout . write ( outstr + \" \\n \" ) NEW_LINE print ( outstr ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["readline_ints", "def readline_ints ( ) : NEW_LINE INDENT return [ int ( num ) for num in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT"], ["ordered_subsets_sums", "def ordered_subsets_sums ( S ) : NEW_LINE INDENT lim = sum ( S ) // 2 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT for subset in itertools . combinations ( S , i ) : NEW_LINE INDENT sub_sum = sum ( subset ) NEW_LINE if sub_sum > lim : NEW_LINE INDENT break NEW_LINE DEDENT yield subset , sub_sum NEW_LINE DEDENT DEDENT DEDENT"], ["find_collision", "def find_collision ( S ) : NEW_LINE INDENT sums = { } NEW_LINE for sub , sub_sum in ordered_subsets_sums ( S ) : NEW_LINE INDENT if sub_sum in sums : NEW_LINE INDENT return sums [ sub_sum ] , sub NEW_LINE DEDENT sums [ sub_sum ] = sub NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "12", "code": "import os , itertools NEW_LINE curr_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) NEW_LINE srcfilename = os . path . join ( curr_dir , ' C - large . in ' ) NEW_LINE dstfilename = os . path . join ( curr_dir , ' output . txt ' ) NEW_LINE def solve ( numbers_ ) : NEW_LINE INDENT numbers = sorted ( numbers_ ) NEW_LINE memory = dict ( ( k , [ k ] ) for k in numbers ) NEW_LINE for r in xrange ( 2 , len ( numbers ) ) : NEW_LINE INDENT combinations = itertools . combinations ( numbers , r ) NEW_LINE for combination in combinations : NEW_LINE INDENT s = sum ( combination ) NEW_LINE if s in memory : NEW_LINE INDENT r1 = memory [ s ] NEW_LINE r2 = combination NEW_LINE return r1 , r2 NEW_LINE DEDENT memory [ s ] = combination NEW_LINE DEDENT DEDENT return ' Impossible ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT with open ( srcfilename , ' rb ' ) as inp : NEW_LINE INDENT with open ( dstfilename , ' wb ' ) as outp : NEW_LINE INDENT lines = inp . readlines ( ) NEW_LINE count = int ( lines . pop ( 0 ) ) NEW_LINE outlines = [ ] NEW_LINE for i in xrange ( count ) : NEW_LINE INDENT line = lines [ i ] NEW_LINE numbers = [ int ( number ) for number in line . split ( ' \u2581 ' ) ] NEW_LINE numbers . pop ( 0 ) NEW_LINE result = solve ( numbers ) NEW_LINE if result == ' Impossible ' : NEW_LINE INDENT outlines . append ( ' Case \u2581 # % d : \u2581 Impossible \\n ' % ( i + 1 , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r1 , r2 = result NEW_LINE outlines . append ( ' Case \u2581 # % d : \\n ' % ( i + 1 , ) ) NEW_LINE outlines . append ( ' % s \\n ' % ' \u2581 ' . join ( [ ' % d ' % r1i for r1i in r1 ] ) ) NEW_LINE outlines . append ( ' % s \\n ' % ' \u2581 ' . join ( [ ' % d ' % r2i for r2i in r2 ] ) ) NEW_LINE DEDENT DEDENT outp . writelines ( outlines ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_12_12", "java": [{"id": "5", "code": "import java . util . * ; import static java . lang . Math . * ; public class B { static void p ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; int [ ] A = new int [ N ] ; int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = in . nextInt ( ) ; B [ i ] = in . nextInt ( ) ; } int [ ] have = new int [ N ] ; int stars = 0 ; int ans = 0 ; next : while ( stars < 2 * N ) { int best = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( have [ i ] == 2 ) continue ; if ( stars >= B [ i ] ) { stars += 2 - have [ i ] ; have [ i ] = 2 ; ans ++ ; continue next ; } if ( have [ i ] == 1 ) continue ; if ( stars < A [ i ] ) continue ; if ( best == - 1 || B [ i ] > B [ best ] ) { best = i ; } } if ( best == - 1 ) break ; have [ best ] = 1 ; ans ++ ; stars ++ ; } if ( stars == 2 * N ) System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans ) ; else System . out . format ( \" Case \u2581 # % d : \u2581 Too \u2581 Bad \\n \" , zz , ans ) ; } } }", "functions_standalone": [["p", "static void p ( Object ... o ) { System . out . println ( Arrays . deepToString ( o ) ) ; }"], ["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int N = in . nextInt ( ) ; int [ ] A = new int [ N ] ; int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = in . nextInt ( ) ; B [ i ] = in . nextInt ( ) ; } int [ ] have = new int [ N ] ; int stars = 0 ; int ans = 0 ; next : while ( stars < 2 * N ) { int best = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( have [ i ] == 2 ) continue ; if ( stars >= B [ i ] ) { stars += 2 - have [ i ] ; have [ i ] = 2 ; ans ++ ; continue next ; } if ( have [ i ] == 1 ) continue ; if ( stars < A [ i ] ) continue ; if ( best == - 1 || B [ i ] > B [ best ] ) { best = i ; } } if ( best == - 1 ) break ; have [ best ] = 1 ; ans ++ ; stars ++ ; } if ( stars == 2 * N ) System . out . format ( \" Case \u2581 # % d : \u2581 % d \\n \" , zz , ans ) ; else System . out . format ( \" Case \u2581 # % d : \u2581 Too \u2581 Bad \\n \" , zz , ans ) ; } }"]], "functions_class": []}, {"id": "14", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class B { static int [ ] visit = new int [ 1024 ] ; static int [ ] a = new int [ 1024 ] ; static int [ ] b = new int [ 1024 ] ; public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( new File ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" B . out \" ) ) ; int T = s . nextInt ( ) ; for ( int tc = 1 ; tc <= T ; tc ++ ) { out . print ( \" Case \u2581 # \" + tc + \" : \u2581 \" ) ; int N = s . nextInt ( ) ; Arrays . fill ( visit , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = s . nextInt ( ) ; b [ i ] = s . nextInt ( ) ; } int ans = 0 ; int stars = 0 ; boolean progress = true ; outer : while ( progress ) { if ( stars == 2 * N ) break ; ans ++ ; progress = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( visit [ i ] == 0 && b [ i ] <= stars ) { progress = true ; stars += 2 ; visit [ i ] = 2 ; continue outer ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( visit [ i ] == 1 && b [ i ] <= stars ) { progress = true ; stars += 1 ; visit [ i ] = 2 ; continue outer ; } } int bestb = 0 ; int besti = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( visit [ i ] == 0 && a [ i ] <= stars ) { progress = true ; if ( bestb < b [ i ] ) { bestb = b [ i ] ; besti = i ; } } } if ( progress ) { visit [ besti ] = 1 ; stars += 1 ; } } if ( stars == 2 * N ) out . println ( ans ) ; else out . println ( \" Too \u2581 Bad \" ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( new File ( \" B . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" B . out \" ) ) ; int T = s . nextInt ( ) ; for ( int tc = 1 ; tc <= T ; tc ++ ) { out . print ( \" Case \u2581 # \" + tc + \" : \u2581 \" ) ; int N = s . nextInt ( ) ; Arrays . fill ( visit , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = s . nextInt ( ) ; b [ i ] = s . nextInt ( ) ; } int ans = 0 ; int stars = 0 ; boolean progress = true ; outer : while ( progress ) { if ( stars == 2 * N ) break ; ans ++ ; progress = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( visit [ i ] == 0 && b [ i ] <= stars ) { progress = true ; stars += 2 ; visit [ i ] = 2 ; continue outer ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( visit [ i ] == 1 && b [ i ] <= stars ) { progress = true ; stars += 1 ; visit [ i ] = 2 ; continue outer ; } } int bestb = 0 ; int besti = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( visit [ i ] == 0 && a [ i ] <= stars ) { progress = true ; if ( bestb < b [ i ] ) { bestb = b [ i ] ; besti = i ; } } } if ( progress ) { visit [ besti ] = 1 ; stars += 1 ; } } if ( stars == 2 * N ) out . println ( ans ) ; else out . println ( \" Too \u2581 Bad \" ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "17", "code": "import java . util . Comparator ; import java . util . HashSet ; import java . util . Scanner ; import java . util . TreeSet ; public class b { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new b ( ) . go ( ) ; } private void go ( ) { int numc = in . nextInt ( ) ; IN : for ( int cnum = 0 ; cnum < numc ; cnum ++ ) { int n = in . nextInt ( ) ; int [ ] [ ] q = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { q [ i ] [ 0 ] = in . nextInt ( ) ; q [ i ] [ 1 ] = in . nextInt ( ) ; } int min = 0 , stars = 0 ; HashSet < Integer > chose1 = new HashSet < Integer > ( ) , chose2 = new HashSet < Integer > ( ) ; OUT : for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( stars == 2 * n ) break ; int max = 0 , maxIndex = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! chose2 . contains ( j ) ) { if ( ! chose1 . contains ( j ) ) { if ( q [ j ] [ 1 ] <= stars ) { stars += 2 ; min ++ ; chose2 . add ( j ) ; continue OUT ; } if ( q [ j ] [ 0 ] <= stars && q [ j ] [ 1 ] > max ) { max = q [ j ] [ 1 ] ; maxIndex = j ; } } if ( q [ j ] [ 1 ] <= stars ) { stars += 1 ; min ++ ; chose2 . add ( j ) ; chose1 . remove ( j ) ; continue OUT ; } } } if ( maxIndex == - 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 Too \u2581 Bad \\n \" , cnum + 1 ) ; continue IN ; } chose1 . add ( maxIndex ) ; min ++ ; stars += 1 ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , cnum + 1 , min ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new b ( ) . go ( ) ; }"]], "functions_class": [["go", "private void go ( ) { int numc = in . nextInt ( ) ; IN : for ( int cnum = 0 ; cnum < numc ; cnum ++ ) { int n = in . nextInt ( ) ; int [ ] [ ] q = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { q [ i ] [ 0 ] = in . nextInt ( ) ; q [ i ] [ 1 ] = in . nextInt ( ) ; } int min = 0 , stars = 0 ; HashSet < Integer > chose1 = new HashSet < Integer > ( ) , chose2 = new HashSet < Integer > ( ) ; OUT : for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( stars == 2 * n ) break ; int max = 0 , maxIndex = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! chose2 . contains ( j ) ) { if ( ! chose1 . contains ( j ) ) { if ( q [ j ] [ 1 ] <= stars ) { stars += 2 ; min ++ ; chose2 . add ( j ) ; continue OUT ; } if ( q [ j ] [ 0 ] <= stars && q [ j ] [ 1 ] > max ) { max = q [ j ] [ 1 ] ; maxIndex = j ; } } if ( q [ j ] [ 1 ] <= stars ) { stars += 1 ; min ++ ; chose2 . add ( j ) ; chose1 . remove ( j ) ; continue OUT ; } } } if ( maxIndex == - 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 Too \u2581 Bad \\n \" , cnum + 1 ) ; continue IN ; } chose1 . add ( maxIndex ) ; min ++ ; stars += 1 ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , cnum + 1 , min ) ; } }"]]}, {"id": "7", "code": "import java . util . * ; import java . math . * ; public class Main { static class Level implements Comparable < Level > { public int low ; public int high ; public Level ( int low , int high ) { this . low = low ; this . high = high ; } @ Override public int compareTo ( Level o ) { return high - o . high ; } } public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int task = scan . nextInt ( ) ; int current = 1 ; while ( task -- > 0 ) { int N = scan . nextInt ( ) ; Level [ ] arr = new Level [ N ] ; int [ ] status = new int [ N ] ; int finished = 0 ; int star = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = new Level ( scan . nextInt ( ) , scan . nextInt ( ) ) ; } Arrays . sort ( arr ) ; int result = 0 ; while ( finished < N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] == 2 ) { continue ; } if ( star >= arr [ i ] . high ) { star += 2 - status [ i ] ; status [ i ] = 2 ; finished ++ ; result ++ ; } } if ( finished == N ) { break ; } int select = - 1 ; int max = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] >= 1 ) { continue ; } if ( star >= arr [ i ] . low ) { if ( arr [ i ] . high > max ) { select = i ; max = arr [ i ] . high ; } } } if ( select == - 1 ) { result = - 1 ; break ; } else { result ++ ; status [ select ] = 1 ; star ++ ; } } System . out . println ( \" Case \u2581 # \" + current + \" : \u2581 \" + ( result == - 1 ? \" Too \u2581 Bad \" : result ) ) ; current ++ ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int task = scan . nextInt ( ) ; int current = 1 ; while ( task -- > 0 ) { int N = scan . nextInt ( ) ; Level [ ] arr = new Level [ N ] ; int [ ] status = new int [ N ] ; int finished = 0 ; int star = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = new Level ( scan . nextInt ( ) , scan . nextInt ( ) ) ; } Arrays . sort ( arr ) ; int result = 0 ; while ( finished < N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] == 2 ) { continue ; } if ( star >= arr [ i ] . high ) { star += 2 - status [ i ] ; status [ i ] = 2 ; finished ++ ; result ++ ; } } if ( finished == N ) { break ; } int select = - 1 ; int max = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( status [ i ] >= 1 ) { continue ; } if ( star >= arr [ i ] . low ) { if ( arr [ i ] . high > max ) { select = i ; max = arr [ i ] . high ; } } } if ( select == - 1 ) { result = - 1 ; break ; } else { result ++ ; status [ select ] = 1 ; star ++ ; } } System . out . println ( \" Case \u2581 # \" + current + \" : \u2581 \" + ( result == - 1 ? \" Too \u2581 Bad \" : result ) ) ; current ++ ; } }"]], "functions_class": [["Level", "public Level ( int low , int high ) { this . low = low ; this . high = high ; }"], ["compareTo", "public int compareTo ( Level o ) { return high - o . high ; }"]]}, {"id": "18", "code": "import java . util . Scanner ; public class B { private static Scanner sc ; public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 0 ; i < t ; i ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , exec ( ) ) ; } } public static String exec ( ) { int n = sc . nextInt ( ) ; int [ ] s1 = new int [ n ] ; int [ ] s2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s1 [ i ] = sc . nextInt ( ) ; s2 [ i ] = sc . nextInt ( ) ; } int stars = 0 ; int goal = n * 2 ; int [ ] obtained = new int [ n ] ; int plays = 0 ; loop : while ( stars < goal ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] > stars ) continue ; if ( obtained [ i ] == 2 ) continue ; stars += 2 - obtained [ i ] ; obtained [ i ] = 2 ; plays ++ ; continue loop ; } int s2OfWinner = - 1 ; int idxOfWinner = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( obtained [ i ] != 0 ) continue ; if ( s1 [ i ] > stars ) continue ; if ( s2 [ i ] < s2OfWinner ) continue ; s2OfWinner = s2 [ i ] ; idxOfWinner = i ; } if ( s2OfWinner == - 1 ) return \" Too \u2581 Bad \" ; stars ++ ; obtained [ idxOfWinner ] = 1 ; plays ++ ; } return String . valueOf ( plays ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 0 ; i < t ; i ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , exec ( ) ) ; } }"], ["exec", "public static String exec ( ) { int n = sc . nextInt ( ) ; int [ ] s1 = new int [ n ] ; int [ ] s2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s1 [ i ] = sc . nextInt ( ) ; s2 [ i ] = sc . nextInt ( ) ; } int stars = 0 ; int goal = n * 2 ; int [ ] obtained = new int [ n ] ; int plays = 0 ; loop : while ( stars < goal ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] > stars ) continue ; if ( obtained [ i ] == 2 ) continue ; stars += 2 - obtained [ i ] ; obtained [ i ] = 2 ; plays ++ ; continue loop ; } int s2OfWinner = - 1 ; int idxOfWinner = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( obtained [ i ] != 0 ) continue ; if ( s1 [ i ] > stars ) continue ; if ( s2 [ i ] < s2OfWinner ) continue ; s2OfWinner = s2 [ i ] ; idxOfWinner = i ; } if ( s2OfWinner == - 1 ) return \" Too \u2581 Bad \" ; stars ++ ; obtained [ idxOfWinner ] = 1 ; plays ++ ; } return String . valueOf ( plays ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "testCount = int ( raw_input ( ) ) NEW_LINE for testIndex in range ( testCount ) : NEW_LINE INDENT ans = \" Case \u2581 # \" + str ( testIndex + 1 ) + \" : \u2581 \" NEW_LINE n = int ( raw_input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a1 , a2 = [ int ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE a += [ ( a1 , a2 , 2 ) ] NEW_LINE DEDENT a . sort ( key = lambda x : x [ 1 ] * 10000 + x [ 0 ] ) NEW_LINE star = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT need = a [ i ] [ 1 ] - star NEW_LINE while need > 0 : NEW_LINE INDENT flag = True NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if a [ j ] [ 2 ] == 2 and star >= a [ j ] [ 0 ] : NEW_LINE INDENT a [ j ] = ( a [ j ] [ 0 ] , a [ j ] [ 1 ] , 1 ) NEW_LINE need -= 1 NEW_LINE star += 1 NEW_LINE count += 1 NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if need > 0 : NEW_LINE INDENT ans += \" Too \u2581 Bad \" NEW_LINE break NEW_LINE DEDENT star += a [ i ] [ 2 ] NEW_LINE count += 1 NEW_LINE DEDENT if star == n * 2 : NEW_LINE INDENT ans += str ( count ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "13", "code": "def work ( A , B , NL ) : NEW_LINE INDENT res = 0 NEW_LINE pts = 0 NEW_LINE S = [ 0 ] * NL NEW_LINE R2 = 0 NEW_LINE while True : NEW_LINE INDENT cont = True NEW_LINE while cont : NEW_LINE INDENT cont = False NEW_LINE for k in range ( NL ) : NEW_LINE INDENT if S [ k ] < 2 and B [ k ] <= pts : NEW_LINE INDENT cont = True NEW_LINE pts += ( 2 - S [ k ] ) NEW_LINE S [ k ] = 2 NEW_LINE res += 1 NEW_LINE R2 += 1 NEW_LINE if R2 == NL : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT DEDENT DEDENT cont = False NEW_LINE Sel = [ k for k in range ( NL ) if S [ k ] == 0 and A [ k ] <= pts ] NEW_LINE if len ( Sel ) == 0 : NEW_LINE INDENT return ' Too \u2581 Bad ' NEW_LINE DEDENT k = max ( Sel , key = lambda i : B [ i ] ) NEW_LINE pts += 1 NEW_LINE res += 1 NEW_LINE S [ k ] = 1 NEW_LINE DEDENT DEDENT T = int ( raw_input ( ) ) NEW_LINE for k in range ( 1 , T + 1 ) : NEW_LINE INDENT NL = int ( raw_input ( ) ) NEW_LINE A = [ 0 ] * NL NEW_LINE B = [ 0 ] * NL NEW_LINE for i in range ( NL ) : NEW_LINE INDENT A [ i ] , B [ i ] = map ( int , raw_input ( ) . split ( ) ) NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( k , work ( A , B , NL ) ) ) NEW_LINE DEDENT", "functions_standalone": [["work", "def work ( A , B , NL ) : NEW_LINE INDENT res = 0 NEW_LINE pts = 0 NEW_LINE S = [ 0 ] * NL NEW_LINE R2 = 0 NEW_LINE while True : NEW_LINE INDENT cont = True NEW_LINE while cont : NEW_LINE INDENT cont = False NEW_LINE for k in range ( NL ) : NEW_LINE INDENT if S [ k ] < 2 and B [ k ] <= pts : NEW_LINE INDENT cont = True NEW_LINE pts += ( 2 - S [ k ] ) NEW_LINE S [ k ] = 2 NEW_LINE res += 1 NEW_LINE R2 += 1 NEW_LINE if R2 == NL : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT DEDENT DEDENT cont = False NEW_LINE Sel = [ k for k in range ( NL ) if S [ k ] == 0 and A [ k ] <= pts ] NEW_LINE if len ( Sel ) == 0 : NEW_LINE INDENT return ' Too \u2581 Bad ' NEW_LINE DEDENT k = max ( Sel , key = lambda i : B [ i ] ) NEW_LINE pts += 1 NEW_LINE res += 1 NEW_LINE S [ k ] = 1 NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "19", "code": "from sys import argv NEW_LINE infile = open ( argv [ 1 ] ) NEW_LINE cases = int ( infile . readline ( ) ) NEW_LINE for i in range ( cases ) : NEW_LINE INDENT n = int ( infile . readline ( ) ) NEW_LINE needed = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT needed . append ( list ( map ( int , infile . readline ( ) . split ( ) ) ) ) NEW_LINE DEDENT games = 0 NEW_LINE stars = 0 NEW_LINE earned = [ 0 for j in range ( n ) ] NEW_LINE toobad = False NEW_LINE games = 0 NEW_LINE while stars < 2 * n : NEW_LINE INDENT level = None NEW_LINE earn = 0 NEW_LINE mostneeded = - 1 NEW_LINE spam = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if stars >= needed [ j ] [ 1 ] and earned [ j ] == 0 : NEW_LINE INDENT level = j NEW_LINE earn = 2 NEW_LINE break NEW_LINE DEDENT elif stars >= needed [ j ] [ 1 ] and earned [ j ] == 1 : NEW_LINE INDENT level = j NEW_LINE earn = 1 NEW_LINE spam = False NEW_LINE DEDENT elif spam and stars >= needed [ j ] [ 0 ] and earned [ j ] == 0 and needed [ j ] [ 1 ] > mostneeded : NEW_LINE INDENT level = j NEW_LINE earn = 1 NEW_LINE mostneeded = needed [ j ] [ 1 ] NEW_LINE DEDENT DEDENT if earn == 2 : NEW_LINE INDENT earned [ level ] = 2 NEW_LINE stars += 2 NEW_LINE DEDENT elif earn == 1 : NEW_LINE INDENT earned [ level ] += 1 NEW_LINE stars += 1 NEW_LINE DEDENT else : NEW_LINE INDENT toobad = True NEW_LINE break NEW_LINE DEDENT games += 1 NEW_LINE DEDENT if toobad : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 Too \u2581 Bad ' . format ( i + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , games ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "from Queue import PriorityQueue NEW_LINE with open ( ' B - large . in ' , ' r ' ) as fin : NEW_LINE INDENT with open ( ' output . txt ' , ' w ' ) as fout : NEW_LINE INDENT numcases = int ( fin . readline ( ) ) NEW_LINE for i in range ( 1 , numcases + 1 ) : NEW_LINE INDENT line = [ int ( j ) for j in fin . readline ( ) . split ( ) ] NEW_LINE numlevels = line [ 0 ] NEW_LINE doables = [ ] NEW_LINE levels = PriorityQueue ( ) NEW_LINE for j in range ( numlevels ) : NEW_LINE INDENT line = [ int ( k ) for k in fin . readline ( ) . split ( ) ] NEW_LINE levels . put ( ( line [ 0 ] , line [ 1 ] ) ) NEW_LINE DEDENT stars = 0 NEW_LINE played = 0 NEW_LINE while True : NEW_LINE INDENT while not levels . empty ( ) : NEW_LINE INDENT nextlevel = levels . get ( ) NEW_LINE if nextlevel [ 0 ] <= stars : NEW_LINE INDENT if nextlevel [ 1 ] == None : NEW_LINE INDENT played += 1 NEW_LINE stars += 1 NEW_LINE DEDENT else : NEW_LINE INDENT doables . append ( nextlevel [ 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT levels . put ( nextlevel ) NEW_LINE break NEW_LINE DEDENT DEDENT doables . sort ( ) NEW_LINE if len ( doables ) == 0 : NEW_LINE INDENT if not levels . empty ( ) : NEW_LINE INDENT played = - 1 NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT lowlevel = doables [ 0 ] NEW_LINE played += 1 NEW_LINE if lowlevel <= stars : NEW_LINE INDENT stars += 2 NEW_LINE doables = doables [ 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT stars += 1 NEW_LINE levels . put ( ( doables [ - 1 ] , None ) ) NEW_LINE del doables [ - 1 ] NEW_LINE DEDENT DEDENT DEDENT fout . write ( \" Case \u2581 # \" ) NEW_LINE fout . write ( str ( i ) ) NEW_LINE fout . write ( \" : \u2581 \" ) NEW_LINE if ( played >= 0 ) : NEW_LINE INDENT fout . write ( str ( played ) ) NEW_LINE DEDENT else : NEW_LINE INDENT fout . write ( \" Too \u2581 Bad \" ) NEW_LINE DEDENT fout . write ( ' \\n ' ) NEW_LINE print ( i ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "20", "code": "def input ( ) : NEW_LINE INDENT with open ( ' b . in ' ) as file : NEW_LINE INDENT tests_count = int ( file . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( tests_count ) : NEW_LINE INDENT levels_count = int ( file . readline ( ) . strip ( ) ) NEW_LINE levels_requirements = [ ] NEW_LINE for j in xrange ( levels_count ) : NEW_LINE INDENT levels_requirements . append ( tuple ( int ( n ) for n in file . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT yield levels_requirements NEW_LINE DEDENT DEDENT DEDENT def output ( answers ) : NEW_LINE INDENT with open ( ' b . out ' , ' w ' ) as file : NEW_LINE INDENT for i , answer in enumerate ( answers ) : NEW_LINE INDENT file . write ( ' Case \u2581 # % s : \u2581 % s \\n ' % ( i + 1 , answer ) ) NEW_LINE DEDENT DEDENT DEDENT def choose_level ( levels_requirements , levels_solved , stars_earned ) : NEW_LINE INDENT for i in xrange ( len ( levels_requirements ) ) : NEW_LINE INDENT result = levels_solved [ i ] NEW_LINE if result < 2 : NEW_LINE INDENT if levels_requirements [ i ] [ 1 ] <= stars_earned : NEW_LINE INDENT levels_solved [ i ] = 2 NEW_LINE return 2 - result NEW_LINE DEDENT DEDENT DEDENT candidate_i = - 1 NEW_LINE maximum_2_stars = - 1 NEW_LINE for i in xrange ( len ( levels_requirements ) ) : NEW_LINE INDENT result = levels_solved [ i ] NEW_LINE if result == 0 : NEW_LINE INDENT if levels_requirements [ i ] [ 0 ] <= stars_earned : NEW_LINE INDENT if levels_requirements [ i ] [ 1 ] > maximum_2_stars : NEW_LINE INDENT maximum_2_stars = levels_requirements [ i ] [ 1 ] NEW_LINE candidate_i = i NEW_LINE DEDENT DEDENT DEDENT DEDENT if candidate_i == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT levels_solved [ candidate_i ] = 1 NEW_LINE return 1 NEW_LINE DEDENT def solve ( levels_requirements ) : NEW_LINE INDENT levels_solved = [ 0 ] * len ( levels_requirements ) NEW_LINE stars_earned = 0 NEW_LINE games_played = 0 NEW_LINE while True : NEW_LINE INDENT if all ( l == 2 for l in levels_solved ) : NEW_LINE INDENT return games_played NEW_LINE DEDENT new_stars = choose_level ( levels_requirements , levels_solved , stars_earned ) NEW_LINE if not new_stars : NEW_LINE INDENT return ' Too \u2581 Bad ' NEW_LINE DEDENT else : NEW_LINE INDENT stars_earned += new_stars NEW_LINE games_played += 1 NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT answers = ( solve ( levels_requirements ) for levels_requirements in input ( ) ) NEW_LINE output ( answers ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["output", "def output ( answers ) : NEW_LINE INDENT with open ( ' b . out ' , ' w ' ) as file : NEW_LINE INDENT for i , answer in enumerate ( answers ) : NEW_LINE INDENT file . write ( ' Case \u2581 # % s : \u2581 % s \\n ' % ( i + 1 , answer ) ) NEW_LINE DEDENT DEDENT DEDENT"], ["solve", "def solve ( levels_requirements ) : NEW_LINE INDENT levels_solved = [ 0 ] * len ( levels_requirements ) NEW_LINE stars_earned = 0 NEW_LINE games_played = 0 NEW_LINE while True : NEW_LINE INDENT if all ( l == 2 for l in levels_solved ) : NEW_LINE INDENT return games_played NEW_LINE DEDENT new_stars = choose_level ( levels_requirements , levels_solved , stars_earned ) NEW_LINE if not new_stars : NEW_LINE INDENT return ' Too \u2581 Bad ' NEW_LINE DEDENT else : NEW_LINE INDENT stars_earned += new_stars NEW_LINE games_played += 1 NEW_LINE DEDENT DEDENT DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT answers = ( solve ( levels_requirements ) for levels_requirements in input ( ) ) NEW_LINE output ( answers ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_32", "java": [{"id": "19", "code": "import java . util . * ; import java . io . * ; public class SolB implements Runnable { public static void main ( String [ ] args ) { new Thread ( new SolB ( ) ) . start ( ) ; } @ Override public void run ( ) { try { br = new BufferedReader ( new FileReader ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( FNAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } BufferedReader br ; StringTokenizer st ; PrintWriter out ; boolean eof = false ; String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } private final String FNAME = \" B - small - attempt0\" ; int [ ] dx = new int [ ] { - 1 , 0 , 0 , 1 } ; int [ ] dy = new int [ ] { 0 , - 1 , 1 , 0 } ; char [ ] dirch = new char [ ] { ' W ' , ' S ' , ' N ' , ' E ' } ; void solve ( ) { int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int xf = nextInt ( ) ; int yf = nextInt ( ) ; String ans = \" \" ; for ( int i = 0 ; i < Math . abs ( xf ) ; i ++ ) { if ( xf < 0 ) { ans += \" EW \" ; } else { ans += \" WE \" ; } } for ( int i = 0 ; i < Math . abs ( yf ) ; i ++ ) { if ( yf < 0 ) { ans += \" NS \" ; } else { ans += \" SN \" ; } } out . println ( ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new Thread ( new SolB ( ) ) . start ( ) ; }"]], "functions_class": [["run", "public void run ( ) { try { br = new BufferedReader ( new FileReader ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( FNAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"], ["nextToken", "String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["solve", "void solve ( ) { int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int xf = nextInt ( ) ; int yf = nextInt ( ) ; String ans = \" \" ; for ( int i = 0 ; i < Math . abs ( xf ) ; i ++ ) { if ( xf < 0 ) { ans += \" EW \" ; } else { ans += \" WE \" ; } } for ( int i = 0 ; i < Math . abs ( yf ) ; i ++ ) { if ( yf < 0 ) { ans += \" NS \" ; } else { ans += \" SN \" ; } } out . println ( ans ) ; } }"]]}, {"id": "4", "code": "import java . io . File ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . util . Scanner ; public class GCJ_2013_C2 { public static String solve ( int x , int y ) { StringBuffer s = new StringBuffer ( \" \" ) ; for ( int i = 0 ; i < Math . abs ( x ) ; i ++ ) { if ( x < 0 ) s . append ( \" EW \" ) ; else s . append ( \" WE \" ) ; } for ( int i = 0 ; i < Math . abs ( y ) ; i ++ ) { if ( y < 0 ) s . append ( \" NS \" ) ; else s . append ( \" SN \" ) ; } return s . toString ( ) ; } public static void main ( String [ ] args ) throws Exception { String fname = \" B _ small \" ; File file = new File ( fname + \" _ in . txt \" ) ; Scanner scanner = new Scanner ( file ) ; FileWriter outFile = new FileWriter ( fname + \" _ out . txt \" ) ; PrintWriter outp = new PrintWriter ( outFile ) ; int T = scanner . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int x = scanner . nextInt ( ) ; int y = scanner . nextInt ( ) ; outp . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i , solve ( x , y ) ) ; } outp . close ( ) ; } }", "functions_standalone": [["solve", "public static String solve ( int x , int y ) { StringBuffer s = new StringBuffer ( \" \" ) ; for ( int i = 0 ; i < Math . abs ( x ) ; i ++ ) { if ( x < 0 ) s . append ( \" EW \" ) ; else s . append ( \" WE \" ) ; } for ( int i = 0 ; i < Math . abs ( y ) ; i ++ ) { if ( y < 0 ) s . append ( \" NS \" ) ; else s . append ( \" SN \" ) ; } return s . toString ( ) ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { String fname = \" B _ small \" ; File file = new File ( fname + \" _ in . txt \" ) ; Scanner scanner = new Scanner ( file ) ; FileWriter outFile = new FileWriter ( fname + \" _ out . txt \" ) ; PrintWriter outp = new PrintWriter ( outFile ) ; int T = scanner . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int x = scanner . nextInt ( ) ; int y = scanner . nextInt ( ) ; outp . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i , solve ( x , y ) ) ; } outp . close ( ) ; }"]], "functions_class": []}, {"id": "3", "code": "import java . io . * ; import java . util . StringTokenizer ; public class B { FastScanner in ; PrintWriter out ; public void solve ( ) throws IOException { int tests = in . nextInt ( ) ; for ( int testcase = 1 ; testcase <= tests ; testcase ++ ) { int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; StringBuilder answer = new StringBuilder ( ) ; while ( x > 0 ) { answer . append ( \" WE \" ) ; x -- ; } while ( x < 0 ) { answer . append ( \" EW \" ) ; x ++ ; } while ( y > 0 ) { answer . append ( \" SN \" ) ; y -- ; } while ( y < 0 ) { answer . append ( \" NS \" ) ; y ++ ; } out . println ( \" Case \u2581 # \" + testcase + \" : \u2581 \" + answer . toString ( ) ) ; } } public void run ( ) { try { in = new FastScanner ( new File ( \" B - small - attempt0 . in \" ) ) ; out = new PrintWriter ( new File ( \" B - small . out \" ) ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } class FastScanner { BufferedReader br ; StringTokenizer st ; FastScanner ( File f ) { try { br = new BufferedReader ( new FileReader ( f ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } String next ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } public static void main ( String [ ] arg ) { new B ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] arg ) { new B ( ) . run ( ) ; }"]], "functions_class": [["solve", "public void solve ( ) throws IOException { int tests = in . nextInt ( ) ; for ( int testcase = 1 ; testcase <= tests ; testcase ++ ) { int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; StringBuilder answer = new StringBuilder ( ) ; while ( x > 0 ) { answer . append ( \" WE \" ) ; x -- ; } while ( x < 0 ) { answer . append ( \" EW \" ) ; x ++ ; } while ( y > 0 ) { answer . append ( \" SN \" ) ; y -- ; } while ( y < 0 ) { answer . append ( \" NS \" ) ; y ++ ; } out . println ( \" Case \u2581 # \" + testcase + \" : \u2581 \" + answer . toString ( ) ) ; } }"], ["run", "public void run ( ) { try { in = new FastScanner ( new File ( \" B - small - attempt0 . in \" ) ) ; out = new PrintWriter ( new File ( \" B - small . out \" ) ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"], ["FastScanner", "FastScanner ( File f ) { try { br = new BufferedReader ( new FileReader ( f ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }"], ["next", "String next ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }"]]}, {"id": "2", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; public class B { static String result ( int x , int y ) { StringBuilder sb = new StringBuilder ( ) ; while ( x < 0 ) { x ++ ; sb . append ( \" EW \" ) ; } while ( x > 0 ) { x -- ; sb . append ( \" WE \" ) ; } while ( y < 0 ) { y ++ ; sb . append ( \" NS \" ) ; } while ( y > 0 ) { y -- ; sb . append ( \" SN \" ) ; } return sb . toString ( ) ; } static void go ( String inputFile ) throws Exception { LineNumberReader in = new LineNumberReader ( new FileReader ( inputFile ) ) ; FileWriter out = new FileWriter ( inputFile + \" . out \" ) ; int nCases = Integer . parseInt ( in . readLine ( ) ) ; for ( int c = 1 ; c <= nCases ; c ++ ) { int [ ] dims = toInts ( in . readLine ( ) ) ; String res = result ( dims [ 0 ] , dims [ 1 ] ) ; String line = \" Case \u2581 # \" + c + \" : \u2581 \" + res ; System . out . println ( line ) ; out . write ( line + \" \\n \" ) ; } out . close ( ) ; } static int [ ] toInts ( String s ) { String [ ] tmp = s . trim ( ) . split ( \" \u2581 \" ) ; int n = tmp . length ; int [ ] res = new int [ n ] ; for ( int a = 0 ; a < n ; a ++ ) res [ a ] = Integer . parseInt ( tmp [ a ] ) ; return res ; } public static void main ( String [ ] args ) throws Exception { LineNumberReader sysIn = new LineNumberReader ( new InputStreamReader ( System . in ) ) ; String line ; while ( ( line = sysIn . readLine ( ) ) != null ) { go ( line . trim ( ) ) ; } } }", "functions_standalone": [["result", "static String result ( int x , int y ) { StringBuilder sb = new StringBuilder ( ) ; while ( x < 0 ) { x ++ ; sb . append ( \" EW \" ) ; } while ( x > 0 ) { x -- ; sb . append ( \" WE \" ) ; } while ( y < 0 ) { y ++ ; sb . append ( \" NS \" ) ; } while ( y > 0 ) { y -- ; sb . append ( \" SN \" ) ; } return sb . toString ( ) ; }"], ["go", "static void go ( String inputFile ) throws Exception { LineNumberReader in = new LineNumberReader ( new FileReader ( inputFile ) ) ; FileWriter out = new FileWriter ( inputFile + \" . out \" ) ; int nCases = Integer . parseInt ( in . readLine ( ) ) ; for ( int c = 1 ; c <= nCases ; c ++ ) { int [ ] dims = toInts ( in . readLine ( ) ) ; String res = result ( dims [ 0 ] , dims [ 1 ] ) ; String line = \" Case \u2581 # \" + c + \" : \u2581 \" + res ; System . out . println ( line ) ; out . write ( line + \" \\n \" ) ; } out . close ( ) ; }"], ["toInts", "static int [ ] toInts ( String s ) { String [ ] tmp = s . trim ( ) . split ( \" \u2581 \" ) ; int n = tmp . length ; int [ ] res = new int [ n ] ; for ( int a = 0 ; a < n ; a ++ ) res [ a ] = Integer . parseInt ( tmp [ a ] ) ; return res ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { LineNumberReader sysIn = new LineNumberReader ( new InputStreamReader ( System . in ) ) ; String line ; while ( ( line = sysIn . readLine ( ) ) != null ) { go ( line . trim ( ) ) ; } }"]], "functions_class": []}], "python": [{"id": "20", "code": "import math , os , sys , random NEW_LINE def single_test ( IN , OUT ) : NEW_LINE INDENT X , Y = map ( int , IN . readline ( ) . split ( ) ) NEW_LINE x , y = 0 , 0 NEW_LINE result = ' ' NEW_LINE step = 1 NEW_LINE while True : NEW_LINE INDENT E = X - x + random . random ( ) NEW_LINE N = Y - y + random . random ( ) NEW_LINE W = - E + random . random ( ) NEW_LINE S = - N + random . random ( ) NEW_LINE d = max ( E , N , W , S ) NEW_LINE nx , ny = x , y NEW_LINE r = ' O ' NEW_LINE if E == d : NEW_LINE INDENT nx += step NEW_LINE r = ' E ' NEW_LINE DEDENT elif N == d : NEW_LINE INDENT ny += step NEW_LINE r = ' N ' NEW_LINE DEDENT elif W == d : NEW_LINE INDENT nx -= step NEW_LINE r = ' W ' NEW_LINE DEDENT elif S == d : NEW_LINE INDENT ny -= step NEW_LINE r = ' S ' NEW_LINE DEDENT if abs ( X - nx ) + abs ( Y - ny ) < abs ( X - x ) + abs ( Y - y ) : NEW_LINE INDENT step += 1 NEW_LINE result += r NEW_LINE x , y = nx , ny NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT while ( x , y ) != ( X , Y ) : NEW_LINE INDENT if Y > y : NEW_LINE INDENT result += ' SN ' NEW_LINE y += 1 NEW_LINE DEDENT elif Y < y : NEW_LINE INDENT result += ' NS ' NEW_LINE y -= 1 NEW_LINE DEDENT elif X > x : NEW_LINE INDENT result += ' WE ' NEW_LINE x += 1 NEW_LINE DEDENT elif X < x : NEW_LINE INDENT result += ' EW ' NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def main ( IN , OUT ) : NEW_LINE INDENT T = int ( IN . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT OUT . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( i , single_test ( IN , OUT ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT assert len ( sys . argv ) == 2 NEW_LINE IN = open ( sys . argv [ 1 ] , ' rt ' ) NEW_LINE OUT = open ( ' % s . out ' % sys . argv [ 1 ] [ : - 3 ] , ' wt ' ) NEW_LINE main ( IN , OUT ) NEW_LINE OUT . close ( ) NEW_LINE IN . close ( ) NEW_LINE DEDENT", "functions_standalone": [["single_test", "def single_test ( IN , OUT ) : NEW_LINE INDENT X , Y = map ( int , IN . readline ( ) . split ( ) ) NEW_LINE x , y = 0 , 0 NEW_LINE result = ' ' NEW_LINE step = 1 NEW_LINE while True : NEW_LINE INDENT E = X - x + random . random ( ) NEW_LINE N = Y - y + random . random ( ) NEW_LINE W = - E + random . random ( ) NEW_LINE S = - N + random . random ( ) NEW_LINE d = max ( E , N , W , S ) NEW_LINE nx , ny = x , y NEW_LINE r = ' O ' NEW_LINE if E == d : NEW_LINE INDENT nx += step NEW_LINE r = ' E ' NEW_LINE DEDENT elif N == d : NEW_LINE INDENT ny += step NEW_LINE r = ' N ' NEW_LINE DEDENT elif W == d : NEW_LINE INDENT nx -= step NEW_LINE r = ' W ' NEW_LINE DEDENT elif S == d : NEW_LINE INDENT ny -= step NEW_LINE r = ' S ' NEW_LINE DEDENT if abs ( X - nx ) + abs ( Y - ny ) < abs ( X - x ) + abs ( Y - y ) : NEW_LINE INDENT step += 1 NEW_LINE result += r NEW_LINE x , y = nx , ny NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT while ( x , y ) != ( X , Y ) : NEW_LINE INDENT if Y > y : NEW_LINE INDENT result += ' SN ' NEW_LINE y += 1 NEW_LINE DEDENT elif Y < y : NEW_LINE INDENT result += ' NS ' NEW_LINE y -= 1 NEW_LINE DEDENT elif X > x : NEW_LINE INDENT result += ' WE ' NEW_LINE x += 1 NEW_LINE DEDENT elif X < x : NEW_LINE INDENT result += ' EW ' NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT"], ["main", "def main ( IN , OUT ) : NEW_LINE INDENT T = int ( IN . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT OUT . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( i , single_test ( IN , OUT ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "2", "code": "def check ( xx , yy ) : NEW_LINE INDENT points = set ( [ ( 0 , 0 ) ] ) NEW_LINE for step in range ( 30 ) : NEW_LINE INDENT t1 = ( 0 , 0 ) in points NEW_LINE t2 = step % 4 in ( 0 , 3 ) NEW_LINE d = step + 1 NEW_LINE if ( xx , yy ) in points : NEW_LINE INDENT return step NEW_LINE DEDENT points = set ( [ a for b in [ [ ( x + d , y ) , ( x - d , y ) , ( x , y + d ) , ( x , y - d ) ] for x , y in points ] for a in b ] ) NEW_LINE DEDENT DEDENT def calc ( x , y ) : NEW_LINE INDENT d = s = 0 NEW_LINE while s < abs ( x ) + abs ( y ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT add_zero = d % 4 in ( 0 , 3 ) NEW_LINE while ( ( abs ( x ) + abs ( y ) ) % 2 == 0 ) != ( d % 4 in ( 0 , 3 ) ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT res = ' ' NEW_LINE for i in range ( d , 0 , - 1 ) : NEW_LINE INDENT if abs ( x ) > abs ( y ) and x > 0 : NEW_LINE INDENT x -= i NEW_LINE res = ' E ' + res NEW_LINE DEDENT elif abs ( x ) > abs ( y ) : NEW_LINE INDENT x += i NEW_LINE res = ' W ' + res NEW_LINE DEDENT elif y > 0 : NEW_LINE INDENT y -= i NEW_LINE res = ' N ' + res NEW_LINE DEDENT else : NEW_LINE INDENT y += i NEW_LINE res = ' S ' + res NEW_LINE DEDENT DEDENT assert ( x , y ) == ( 0 , 0 ) , ( x , y , d ) NEW_LINE return res NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE res = calc ( x , y ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \" % t , end = ' \u2581 ' ) NEW_LINE solve ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["check", "def check ( xx , yy ) : NEW_LINE INDENT points = set ( [ ( 0 , 0 ) ] ) NEW_LINE for step in range ( 30 ) : NEW_LINE INDENT t1 = ( 0 , 0 ) in points NEW_LINE t2 = step % 4 in ( 0 , 3 ) NEW_LINE d = step + 1 NEW_LINE if ( xx , yy ) in points : NEW_LINE INDENT return step NEW_LINE DEDENT points = set ( [ a for b in [ [ ( x + d , y ) , ( x - d , y ) , ( x , y + d ) , ( x , y - d ) ] for x , y in points ] for a in b ] ) NEW_LINE DEDENT DEDENT"], ["calc", "def calc ( x , y ) : NEW_LINE INDENT d = s = 0 NEW_LINE while s < abs ( x ) + abs ( y ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT add_zero = d % 4 in ( 0 , 3 ) NEW_LINE while ( ( abs ( x ) + abs ( y ) ) % 2 == 0 ) != ( d % 4 in ( 0 , 3 ) ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT res = ' ' NEW_LINE for i in range ( d , 0 , - 1 ) : NEW_LINE INDENT if abs ( x ) > abs ( y ) and x > 0 : NEW_LINE INDENT x -= i NEW_LINE res = ' E ' + res NEW_LINE DEDENT elif abs ( x ) > abs ( y ) : NEW_LINE INDENT x += i NEW_LINE res = ' W ' + res NEW_LINE DEDENT elif y > 0 : NEW_LINE INDENT y -= i NEW_LINE res = ' N ' + res NEW_LINE DEDENT else : NEW_LINE INDENT y += i NEW_LINE res = ' S ' + res NEW_LINE DEDENT DEDENT assert ( x , y ) == ( 0 , 0 ) , ( x , y , d ) NEW_LINE return res NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE res = calc ( x , y ) NEW_LINE print ( res ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "t = int ( raw_input ( ) ) NEW_LINE for kei in xrange ( t ) : NEW_LINE INDENT x , y = ( int ( j ) for j in raw_input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE while x > 0 : NEW_LINE INDENT ans . append ( ' WE ' ) NEW_LINE x -= 1 NEW_LINE DEDENT while x < 0 : NEW_LINE INDENT ans . append ( ' EW ' ) NEW_LINE x += 1 NEW_LINE DEDENT while y > 0 : NEW_LINE INDENT ans . append ( ' SN ' ) NEW_LINE y -= 1 NEW_LINE DEDENT while y < 0 : NEW_LINE INDENT ans . append ( ' NS ' ) NEW_LINE y += 1 NEW_LINE DEDENT print ( ' Case \u2581 # % d : \u2581 % s ' % ( kei + 1 , ' ' . join ( ans ) ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "4", "code": "import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE def puts ( s ) : NEW_LINE INDENT print ( s , end = ' ' ) NEW_LINE DEDENT def direction ( x , y ) : NEW_LINE INDENT if x > 0 : NEW_LINE INDENT return \" E \" NEW_LINE DEDENT if x < 0 : NEW_LINE INDENT return \" W \" NEW_LINE DEDENT if y > 0 : NEW_LINE INDENT return \" N \" NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT return \" S \" NEW_LINE DEDENT DEDENT def movesReq ( x , y ) : NEW_LINE INDENT mandis = abs ( x ) + abs ( y ) NEW_LINE dis = 0 NEW_LINE moves = 0 NEW_LINE while mandis > dis or dis % 2 != mandis % 2 : NEW_LINE INDENT moves += 1 NEW_LINE dis += moves NEW_LINE DEDENT return moves NEW_LINE DEDENT def solutions ( x , y , num ) : NEW_LINE INDENT if num == 0 and x == 0 and y == 0 : NEW_LINE INDENT yield \" \" NEW_LINE DEDENT elif movesReq ( x , y ) <= num : NEW_LINE INDENT for d , xp , yp in [ ( \" E \" , x - num , y ) , ( \" W \" , x + num , y ) , ( \" S \" , x , y + num ) , ( \" N \" , x , y - num ) ] : NEW_LINE INDENT for s in solutions ( xp , yp , num - 1 ) : NEW_LINE INDENT yield s + d NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( case ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE num = movesReq ( x , y ) NEW_LINE for s in solutions ( x , y , num ) : NEW_LINE INDENT print ( s ) NEW_LINE break NEW_LINE DEDENT DEDENT for case in range ( 1 , 1 + int ( input ( ) ) ) : NEW_LINE INDENT puts ( \" Case \u2581 # \" + str ( case ) + \" : \u2581 \" ) NEW_LINE solve ( case ) NEW_LINE DEDENT", "functions_standalone": [["puts", "def puts ( s ) : NEW_LINE INDENT print ( s , end = ' ' ) NEW_LINE DEDENT"], ["direction", "def direction ( x , y ) : NEW_LINE INDENT if x > 0 : NEW_LINE INDENT return \" E \" NEW_LINE DEDENT if x < 0 : NEW_LINE INDENT return \" W \" NEW_LINE DEDENT if y > 0 : NEW_LINE INDENT return \" N \" NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT return \" S \" NEW_LINE DEDENT DEDENT"], ["movesReq", "def movesReq ( x , y ) : NEW_LINE INDENT mandis = abs ( x ) + abs ( y ) NEW_LINE dis = 0 NEW_LINE moves = 0 NEW_LINE while mandis > dis or dis % 2 != mandis % 2 : NEW_LINE INDENT moves += 1 NEW_LINE dis += moves NEW_LINE DEDENT return moves NEW_LINE DEDENT"], ["solutions", "def solutions ( x , y , num ) : NEW_LINE INDENT if num == 0 and x == 0 and y == 0 : NEW_LINE INDENT yield \" \" NEW_LINE DEDENT elif movesReq ( x , y ) <= num : NEW_LINE INDENT for d , xp , yp in [ ( \" E \" , x - num , y ) , ( \" W \" , x + num , y ) , ( \" S \" , x , y + num ) , ( \" N \" , x , y - num ) ] : NEW_LINE INDENT for s in solutions ( xp , yp , num - 1 ) : NEW_LINE INDENT yield s + d NEW_LINE DEDENT DEDENT DEDENT DEDENT"], ["solve", "def solve ( case ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE num = movesReq ( x , y ) NEW_LINE for s in solutions ( x , y , num ) : NEW_LINE INDENT print ( s ) NEW_LINE break NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "1", "code": "T = int ( input ( ) ) NEW_LINE for TT in range ( 1 , T + 1 ) : NEW_LINE INDENT x , y = [ int ( tmp ) for tmp in input ( ) . split ( ) ] NEW_LINE s = 0 NEW_LINE now = 1 NEW_LINE ans = \" \" NEW_LINE while s < abs ( x ) + abs ( y ) or s % 2 != abs ( x + y ) % 2 : NEW_LINE INDENT s += now NEW_LINE now += 1 NEW_LINE DEDENT for i in range ( now - 1 , 0 , - 1 ) : NEW_LINE INDENT s -= i NEW_LINE if abs ( x - i ) + abs ( y ) <= s : NEW_LINE INDENT x -= i NEW_LINE ans += ' E ' NEW_LINE DEDENT elif abs ( x + i ) + abs ( y ) <= s : NEW_LINE INDENT x += i NEW_LINE ans += ' W ' NEW_LINE DEDENT elif abs ( x ) + abs ( y - i ) <= s : NEW_LINE INDENT y -= i NEW_LINE ans += ' N ' NEW_LINE DEDENT else : NEW_LINE INDENT y += i NEW_LINE ans += ' S ' NEW_LINE DEDENT DEDENT ans = ans [ : : - 1 ] NEW_LINE print ( \" Case \u2581 # \" + str ( TT ) + \" : \u2581 \" + ans ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_13_02", "java": [{"id": "9", "code": "import java . util . * ; class Lawnmower { public static void main ( String ... args ) { Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int test = 1 ; test <= tests ; ++ test ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] lawn = new int [ n ] [ m ] ; int [ ] rowMaxes = new int [ n ] ; int [ ] colMaxes = new int [ m ] ; boolean possible = true ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { int a = sc . nextInt ( ) ; lawn [ i ] [ j ] = a ; rowMaxes [ i ] = Math . max ( a , rowMaxes [ i ] ) ; colMaxes [ j ] = Math . max ( a , colMaxes [ j ] ) ; if ( a > 100 ) { possible = false ; } } } for ( int i = 0 ; i < n & possible ; ++ i ) { for ( int j = 0 ; j < m & possible ; ++ j ) { if ( lawn [ i ] [ j ] < rowMaxes [ i ] && lawn [ i ] [ j ] < colMaxes [ j ] ) { possible = false ; } } } System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + ( possible ? \" YES \" : \" NO \" ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String ... args ) { Scanner sc = new Scanner ( System . in ) ; int tests = sc . nextInt ( ) ; for ( int test = 1 ; test <= tests ; ++ test ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] [ ] lawn = new int [ n ] [ m ] ; int [ ] rowMaxes = new int [ n ] ; int [ ] colMaxes = new int [ m ] ; boolean possible = true ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { int a = sc . nextInt ( ) ; lawn [ i ] [ j ] = a ; rowMaxes [ i ] = Math . max ( a , rowMaxes [ i ] ) ; colMaxes [ j ] = Math . max ( a , colMaxes [ j ] ) ; if ( a > 100 ) { possible = false ; } } } for ( int i = 0 ; i < n & possible ; ++ i ) { for ( int j = 0 ; j < m & possible ; ++ j ) { if ( lawn [ i ] [ j ] < rowMaxes [ i ] && lawn [ i ] [ j ] < colMaxes [ j ] ) { possible = false ; } } } System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + ( possible ? \" YES \" : \" NO \" ) ) ; } }"]], "functions_class": []}, {"id": "10", "code": "package lawnmower ; public class Lawnmower { public static String [ ] execute ( String [ ] input ) { String [ ] words = { \" NO \" , \" YES \" } ; String [ ] out ; String [ ] splitted ; int n , m ; int [ ] [ ] board ; int result ; int test = 1 ; int ntests ; ntests = Integer . parseInt ( input [ 0 ] ) ; out = new String [ ntests ] ; for ( int i = 1 ; test < 1 + ntests ; ) { splitted = input [ i ++ ] . split ( \" \\\\ s \" ) ; n = Integer . parseInt ( splitted [ 0 ] ) ; m = Integer . parseInt ( splitted [ 1 ] ) ; board = new int [ n ] [ m ] ; for ( int j = 0 ; j < n ; j ++ ) { splitted = input [ i ++ ] . split ( \" \\\\ s \" ) ; for ( int k = 0 ; k < m ; k ++ ) { board [ j ] [ k ] = Integer . parseInt ( splitted [ k ] ) ; } } result = isFeasible ( board , n , m ) ; out [ test - 1 ] = \" Case \u2581 # \" + test + \" : \u2581 \" + words [ result ] ; System . out . println ( out [ test - 1 ] ) ; test ++ ; } return out ; } private static int isFeasible ( int [ ] [ ] board , int n , int m ) { int [ ] maxrow = new int [ n ] ; int [ ] maxcol = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( board [ i ] [ j ] > maxrow [ i ] ) maxrow [ i ] = board [ i ] [ j ] ; if ( board [ i ] [ j ] > maxcol [ j ] ) maxcol [ j ] = board [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( board [ i ] [ j ] < maxrow [ i ] ) if ( board [ i ] [ j ] < maxcol [ j ] ) return 0 ; } } return 1 ; } }", "functions_standalone": [["execute", "public static String [ ] execute ( String [ ] input ) { String [ ] words = { \" NO \" , \" YES \" } ; String [ ] out ; String [ ] splitted ; int n , m ; int [ ] [ ] board ; int result ; int test = 1 ; int ntests ; ntests = Integer . parseInt ( input [ 0 ] ) ; out = new String [ ntests ] ; for ( int i = 1 ; test < 1 + ntests ; ) { splitted = input [ i ++ ] . split ( \" \\\\ s \" ) ; n = Integer . parseInt ( splitted [ 0 ] ) ; m = Integer . parseInt ( splitted [ 1 ] ) ; board = new int [ n ] [ m ] ; for ( int j = 0 ; j < n ; j ++ ) { splitted = input [ i ++ ] . split ( \" \\\\ s \" ) ; for ( int k = 0 ; k < m ; k ++ ) { board [ j ] [ k ] = Integer . parseInt ( splitted [ k ] ) ; } } result = isFeasible ( board , n , m ) ; out [ test - 1 ] = \" Case \u2581 # \" + test + \" : \u2581 \" + words [ result ] ; System . out . println ( out [ test - 1 ] ) ; test ++ ; } return out ; }"], ["isFeasible", "private static int isFeasible ( int [ ] [ ] board , int n , int m ) { int [ ] maxrow = new int [ n ] ; int [ ] maxcol = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( board [ i ] [ j ] > maxrow [ i ] ) maxrow [ i ] = board [ i ] [ j ] ; if ( board [ i ] [ j ] > maxcol [ j ] ) maxcol [ j ] = board [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( board [ i ] [ j ] < maxrow [ i ] ) if ( board [ i ] [ j ] < maxcol [ j ] ) return 0 ; } } return 1 ; }"]], "functions_class": []}, {"id": "18", "code": "import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Lawnmower { public static boolean check ( int [ ] [ ] map , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { boolean flag = true , flag2 = true ; for ( int k = 0 ; k < N ; k ++ ) { if ( map [ k ] [ j ] > map [ i ] [ j ] ) { flag = false ; break ; } } for ( int k = 0 ; k < M ; k ++ ) { if ( map [ i ] [ k ] > map [ i ] [ j ] ) { flag2 = false ; break ; } } if ( ! flag && ! flag2 ) return false ; } } return true ; } public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( new FileInputStream ( \" B - large . in \" ) ) ; PrintWriter writer = new PrintWriter ( new FileOutputStream ( \" B - large . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; int [ ] [ ] map = new int [ N ] [ M ] ; for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < M ; k ++ ) { map [ j ] [ k ] = in . nextInt ( ) ; } } boolean result = check ( map , N , M ) ; writer . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; writer . println ( result ? \" YES \" : \" NO \" ) ; } in . close ( ) ; writer . close ( ) ; } }", "functions_standalone": [["check", "public static boolean check ( int [ ] [ ] map , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { boolean flag = true , flag2 = true ; for ( int k = 0 ; k < N ; k ++ ) { if ( map [ k ] [ j ] > map [ i ] [ j ] ) { flag = false ; break ; } } for ( int k = 0 ; k < M ; k ++ ) { if ( map [ i ] [ k ] > map [ i ] [ j ] ) { flag2 = false ; break ; } } if ( ! flag && ! flag2 ) return false ; } } return true ; }"], ["main", "public static void main ( String args [ ] ) throws Exception { Scanner in = new Scanner ( new FileInputStream ( \" B - large . in \" ) ) ; PrintWriter writer = new PrintWriter ( new FileOutputStream ( \" B - large . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; int [ ] [ ] map = new int [ N ] [ M ] ; for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < M ; k ++ ) { map [ j ] [ k ] = in . nextInt ( ) ; } } boolean result = check ( map , N , M ) ; writer . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; writer . println ( result ? \" YES \" : \" NO \" ) ; } in . close ( ) ; writer . close ( ) ; }"]], "functions_class": []}, {"id": "12", "code": "import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Scanner ; public class ProblemB { static final String YES = \" YES \" ; static final String NO = \" NO \" ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int T = in . nextInt ( ) ; for ( int cn = 1 ; cn <= T ; cn ++ ) { int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; int [ ] [ ] a = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { a [ i ] [ j ] = in . nextInt ( ) ; } } out . println ( String . format ( \" Case \u2581 # % d : \u2581 % s \" , cn , ( solve ( a ) ? YES : NO ) ) ) ; } out . flush ( ) ; } private static boolean solve ( int [ ] [ ] board ) { int N = board . length ; int M = board [ 0 ] . length ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int a = board [ i ] [ j ] ; int rmax = 0 , cmax = 0 ; for ( int x = 0 ; x < M ; x ++ ) { if ( x != j ) { rmax = Math . max ( rmax , board [ i ] [ x ] ) ; } } for ( int y = 0 ; y < N ; y ++ ) { if ( y != i ) { cmax = Math . max ( cmax , board [ y ] [ j ] ) ; } } if ( rmax > a && cmax > a ) { return false ; } } } return true ; } public static void debug ( Object ... o ) { System . err . println ( Arrays . deepToString ( o ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int T = in . nextInt ( ) ; for ( int cn = 1 ; cn <= T ; cn ++ ) { int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; int [ ] [ ] a = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { a [ i ] [ j ] = in . nextInt ( ) ; } } out . println ( String . format ( \" Case \u2581 # % d : \u2581 % s \" , cn , ( solve ( a ) ? YES : NO ) ) ) ; } out . flush ( ) ; }"], ["solve", "private static boolean solve ( int [ ] [ ] board ) { int N = board . length ; int M = board [ 0 ] . length ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int a = board [ i ] [ j ] ; int rmax = 0 , cmax = 0 ; for ( int x = 0 ; x < M ; x ++ ) { if ( x != j ) { rmax = Math . max ( rmax , board [ i ] [ x ] ) ; } } for ( int y = 0 ; y < N ; y ++ ) { if ( y != i ) { cmax = Math . max ( cmax , board [ y ] [ j ] ) ; } } if ( rmax > a && cmax > a ) { return false ; } } } return true ; }"], ["debug", "public static void debug ( Object ... o ) { System . err . println ( Arrays . deepToString ( o ) ) ; }"]], "functions_class": []}, {"id": "16", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . StringTokenizer ; public class Lawnmower { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( new File ( \" in \" ) ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( \" out \" ) ) ) ; StringTokenizer st ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int cn = 1 ; cn <= T ; cn ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int M = Integer . parseInt ( st . nextToken ( ) ) ; int arr [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; for ( int j = 0 ; j < M ; j ++ ) { arr [ i ] [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } } boolean okay = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int h = arr [ i ] [ j ] ; boolean ok1 = true ; for ( int k = 0 ; k < N ; k ++ ) ok1 &= arr [ k ] [ j ] <= h ; boolean ok2 = true ; for ( int k = 0 ; k < M ; k ++ ) ok2 &= arr [ i ] [ k ] <= h ; if ( ! ( ok1 || ok2 ) ) okay = false ; } } if ( okay ) bw . append ( \" Case \u2581 # \" + cn + \" : \u2581 YES \\n \" ) ; else bw . append ( \" Case \u2581 # \" + cn + \" : \u2581 NO \\n \" ) ; } bw . flush ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( new File ( \" in \" ) ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( \" out \" ) ) ) ; StringTokenizer st ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int cn = 1 ; cn <= T ; cn ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int M = Integer . parseInt ( st . nextToken ( ) ) ; int arr [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; for ( int j = 0 ; j < M ; j ++ ) { arr [ i ] [ j ] = Integer . parseInt ( st . nextToken ( ) ) ; } } boolean okay = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int h = arr [ i ] [ j ] ; boolean ok1 = true ; for ( int k = 0 ; k < N ; k ++ ) ok1 &= arr [ k ] [ j ] <= h ; boolean ok2 = true ; for ( int k = 0 ; k < M ; k ++ ) ok2 &= arr [ i ] [ k ] <= h ; if ( ! ( ok1 || ok2 ) ) okay = false ; } } if ( okay ) bw . append ( \" Case \u2581 # \" + cn + \" : \u2581 YES \\n \" ) ; else bw . append ( \" Case \u2581 # \" + cn + \" : \u2581 NO \\n \" ) ; } bw . flush ( ) ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "def setup ( infile ) : NEW_LINE INDENT return locals ( ) NEW_LINE DEDENT def reader ( testcase , infile , ** ignore ) : NEW_LINE INDENT P = map ( int , infile . next ( ) . split ( ) ) NEW_LINE S = [ map ( int , infile . next ( ) . split ( ) ) for i in range ( P [ 0 ] ) ] NEW_LINE return locals ( ) NEW_LINE DEDENT def solver ( infile , testcase , N = None , P = None , I = None , T = None , S = None , C = None , ** ignore ) : NEW_LINE INDENT import numpypy as np NEW_LINE S = np . array ( S ) NEW_LINE done = np . zeros ( P , dtype = int ) NEW_LINE for row in range ( P [ 0 ] ) : NEW_LINE INDENT m = S [ row ] . max ( ) NEW_LINE done [ row ] [ S [ row ] == m ] = 1 NEW_LINE DEDENT for col in range ( P [ 1 ] ) : NEW_LINE INDENT m = S [ : , col ] . max ( ) NEW_LINE done [ : , col ] [ S [ : , col ] == m ] = 1 NEW_LINE DEDENT res = ' YES ' if done . sum ( ) == P [ 0 ] * P [ 1 ] else ' NO ' NEW_LINE return ' Case \u2581 # % s : \u2581 % s \\n ' % ( testcase , res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE T = int ( sys . stdin . next ( ) ) NEW_LINE common = setup ( sys . stdin ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT sys . stdout . write ( solver ( ** reader ( t , ** common ) ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["setup", "def setup ( infile ) : NEW_LINE INDENT return locals ( ) NEW_LINE DEDENT"], ["reader", "def reader ( testcase , infile , ** ignore ) : NEW_LINE INDENT P = map ( int , infile . next ( ) . split ( ) ) NEW_LINE S = [ map ( int , infile . next ( ) . split ( ) ) for i in range ( P [ 0 ] ) ] NEW_LINE return locals ( ) NEW_LINE DEDENT"], ["solver", "def solver ( infile , testcase , N = None , P = None , I = None , T = None , S = None , C = None , ** ignore ) : NEW_LINE INDENT import numpypy as np NEW_LINE S = np . array ( S ) NEW_LINE done = np . zeros ( P , dtype = int ) NEW_LINE for row in range ( P [ 0 ] ) : NEW_LINE INDENT m = S [ row ] . max ( ) NEW_LINE done [ row ] [ S [ row ] == m ] = 1 NEW_LINE DEDENT for col in range ( P [ 1 ] ) : NEW_LINE INDENT m = S [ : , col ] . max ( ) NEW_LINE done [ : , col ] [ S [ : , col ] == m ] = 1 NEW_LINE DEDENT res = ' YES ' if done . sum ( ) == P [ 0 ] * P [ 1 ] else ' NO ' NEW_LINE return ' Case \u2581 # % s : \u2581 % s \\n ' % ( testcase , res ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "8", "code": "from itertools import chain NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = dict ( chain . from_iterable ( map ( lambda j : zip ( zip ( [ j ] * m , range ( m ) ) , map ( int , input ( ) . split ( ) ) ) , range ( n ) ) ) ) NEW_LINE ans = \" YES \" NEW_LINE while len ( l ) : NEW_LINE INDENT ly , lx = min ( l , key = l . get ) NEW_LINE lowest = l [ ( ly , lx ) ] NEW_LINE if all ( map ( lambda j : l . get ( ( ly , j ) , lowest ) == lowest , range ( m ) ) ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT l . pop ( ( ly , j ) , None ) NEW_LINE DEDENT DEDENT elif all ( map ( lambda j : l . get ( ( j , lx ) , lowest ) == lowest , range ( n ) ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT l . pop ( ( j , lx ) , None ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = \" NO \" NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( i + 1 , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "6", "code": "import sys NEW_LINE from collections import defaultdict NEW_LINE def readline ( ) : NEW_LINE INDENT s = raw_input ( ) . strip ( ) NEW_LINE while s == \" \" : NEW_LINE INDENT s = raw_input ( ) . strip ( ) NEW_LINE DEDENT return s NEW_LINE DEDENT def readvals ( ) : NEW_LINE INDENT return map ( int , readline ( ) . split ( ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT r , c = readvals ( ) NEW_LINE grid = tuple ( readvals ( ) for i in range ( r ) ) NEW_LINE row_min = tuple ( map ( max , grid ) ) NEW_LINE col_min = tuple ( map ( max , zip ( * grid ) ) ) NEW_LINE for y in range ( r ) : NEW_LINE INDENT for x in range ( c ) : NEW_LINE INDENT if grid [ y ] [ x ] != min ( row_min [ y ] , col_min [ x ] ) : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT DEDENT return \" YES \" NEW_LINE DEDENT N = int ( readline ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sol = solve ( ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( i + 1 , sol ) ) NEW_LINE DEDENT", "functions_standalone": [["readline", "def readline ( ) : NEW_LINE INDENT s = raw_input ( ) . strip ( ) NEW_LINE while s == \" \" : NEW_LINE INDENT s = raw_input ( ) . strip ( ) NEW_LINE DEDENT return s NEW_LINE DEDENT"], ["readvals", "def readvals ( ) : NEW_LINE INDENT return map ( int , readline ( ) . split ( ) ) NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT r , c = readvals ( ) NEW_LINE grid = tuple ( readvals ( ) for i in range ( r ) ) NEW_LINE row_min = tuple ( map ( max , grid ) ) NEW_LINE col_min = tuple ( map ( max , zip ( * grid ) ) ) NEW_LINE for y in range ( r ) : NEW_LINE INDENT for x in range ( c ) : NEW_LINE INDENT if grid [ y ] [ x ] != min ( row_min [ y ] , col_min [ x ] ) : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT DEDENT return \" YES \" NEW_LINE DEDENT"]], "functions_class": []}, {"id": "0", "code": "import sys NEW_LINE import time NEW_LINE timeit = 1 NEW_LINE debugv = 0 NEW_LINE def main ( ) : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT doCase ( case ) NEW_LINE DEDENT DEDENT def doCase ( case ) : NEW_LINE INDENT N , M = [ int ( n ) for n in sys . stdin . readline ( ) . split ( ) ] NEW_LINE lawn = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT row = [ int ( n ) for n in sys . stdin . readline ( ) . split ( ) ] NEW_LINE if len ( row ) != M : NEW_LINE INDENT raise Exception ( \" incorrect \u2581 line \u2581 length \" ) NEW_LINE DEDENT lawn . append ( row ) NEW_LINE DEDENT lawn_possible = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT row_possible = 1 NEW_LINE for k in range ( N ) : NEW_LINE INDENT if lawn [ k ] [ j ] > lawn [ i ] [ j ] : NEW_LINE INDENT row_possible = 0 NEW_LINE DEDENT DEDENT col_possible = 1 NEW_LINE for k in range ( M ) : NEW_LINE INDENT if lawn [ i ] [ k ] > lawn [ i ] [ j ] : NEW_LINE INDENT col_possible = 0 NEW_LINE DEDENT DEDENT if not ( row_possible or col_possible ) : NEW_LINE INDENT lawn_possible = 0 NEW_LINE DEDENT DEDENT DEDENT result = ' YES ' if lawn_possible else ' NO ' NEW_LINE debug ( \" { } \\n \" . format ( result ) ) NEW_LINE sys . stdout . write ( \" Case \u2581 # { } : \u2581 { } \\n \" . format ( case , result ) ) NEW_LINE DEDENT def debug ( m ) : NEW_LINE INDENT if debugv : NEW_LINE INDENT sys . stderr . write ( m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT startTime = time . clock ( ) NEW_LINE main ( ) NEW_LINE if timeit : NEW_LINE INDENT sys . stderr . write ( \" Completed \u2581 in \u2581 { } \u2581 seconds . \\n \" . format ( time . clock ( ) - startTime ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["main", "def main ( ) : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT doCase ( case ) NEW_LINE DEDENT DEDENT"], ["doCase", "def doCase ( case ) : NEW_LINE INDENT N , M = [ int ( n ) for n in sys . stdin . readline ( ) . split ( ) ] NEW_LINE lawn = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT row = [ int ( n ) for n in sys . stdin . readline ( ) . split ( ) ] NEW_LINE if len ( row ) != M : NEW_LINE INDENT raise Exception ( \" incorrect \u2581 line \u2581 length \" ) NEW_LINE DEDENT lawn . append ( row ) NEW_LINE DEDENT lawn_possible = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT row_possible = 1 NEW_LINE for k in range ( N ) : NEW_LINE INDENT if lawn [ k ] [ j ] > lawn [ i ] [ j ] : NEW_LINE INDENT row_possible = 0 NEW_LINE DEDENT DEDENT col_possible = 1 NEW_LINE for k in range ( M ) : NEW_LINE INDENT if lawn [ i ] [ k ] > lawn [ i ] [ j ] : NEW_LINE INDENT col_possible = 0 NEW_LINE DEDENT DEDENT if not ( row_possible or col_possible ) : NEW_LINE INDENT lawn_possible = 0 NEW_LINE DEDENT DEDENT DEDENT result = ' YES ' if lawn_possible else ' NO ' NEW_LINE debug ( \" { } \\n \" . format ( result ) ) NEW_LINE sys . stdout . write ( \" Case \u2581 # { } : \u2581 { } \\n \" . format ( case , result ) ) NEW_LINE DEDENT"], ["debug", "def debug ( m ) : NEW_LINE INDENT if debugv : NEW_LINE INDENT sys . stderr . write ( m ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "4", "code": "filename = ' B - large . in ' NEW_LINE def getCol ( array , c ) : NEW_LINE INDENT return [ row [ c ] for row in array ] NEW_LINE DEDENT def mowable ( array ) : NEW_LINE INDENT for i , line in enumerate ( array ) : NEW_LINE INDENT for j , col in enumerate ( line ) : NEW_LINE INDENT if ( array [ i ] [ j ] < max ( array [ i ] ) ) and ( array [ i ] [ j ] < max ( getCol ( array , j ) ) ) : NEW_LINE INDENT return ' NO ' NEW_LINE DEDENT DEDENT DEDENT return ' YES ' NEW_LINE DEDENT FILE = open ( filename ) NEW_LINE T = int ( FILE . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT rawLine = FILE . readline ( ) . split ( ' \u2581 ' ) NEW_LINE rows , cols = int ( rawLine [ 0 ] ) , int ( rawLine [ 1 ] ) NEW_LINE array = [ 0 ] * rows NEW_LINE for r in range ( 0 , rows ) : NEW_LINE INDENT array [ r ] = [ int ( x ) for x in FILE . readline ( ) . split ( ' \u2581 ' ) ] NEW_LINE DEDENT print ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 ' + mowable ( array ) ) NEW_LINE DEDENT", "functions_standalone": [["getCol", "def getCol ( array , c ) : NEW_LINE INDENT return [ row [ c ] for row in array ] NEW_LINE DEDENT"], ["mowable", "def mowable ( array ) : NEW_LINE INDENT for i , line in enumerate ( array ) : NEW_LINE INDENT for j , col in enumerate ( line ) : NEW_LINE INDENT if ( array [ i ] [ j ] < max ( array [ i ] ) ) and ( array [ i ] [ j ] < max ( getCol ( array , j ) ) ) : NEW_LINE INDENT return ' NO ' NEW_LINE DEDENT DEDENT DEDENT return ' YES ' NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_11", "java": [{"id": "9", "code": "import java . util . * ; import java . io . * ; import java . math . * ; public class a { static InputReader in ; static PrintWriter out ; public static void main ( String args [ ] ) { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out ) ; int n = Integer . valueOf ( in . next ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i , solve ( ) ) ; } out . close ( ) ; } static BigInteger solve ( ) { BigInteger r = new BigInteger ( in . next ( ) ) ; BigInteger t = new BigInteger ( in . next ( ) ) ; BigInteger x = new BigInteger ( \"0\" ) ; BigInteger y = new BigInteger ( \"2000000000000000000\" ) ; BigInteger ans = new BigInteger ( \"0\" ) ; while ( x . compareTo ( y ) != 1 ) { BigInteger m = x . add ( y ) . shiftRight ( 1 ) ; BigInteger tmp = m . multiply ( r ) . shiftLeft ( 1 ) . add ( m . multiply ( m . multiply ( m ) . shiftLeft ( 2 ) . subtract ( BigInteger . ONE ) ) . divide ( new BigInteger ( \"3\" ) ) ) . subtract ( m . subtract ( BigInteger . ONE ) . shiftLeft ( 1 ) . multiply ( m ) . multiply ( m . shiftLeft ( 1 ) . subtract ( BigInteger . ONE ) ) . divide ( new BigInteger ( \"3\" ) ) ) ; if ( tmp . compareTo ( t ) != 1 ) { ans = m ; x = m . add ( BigInteger . ONE ) ; } else y = m . subtract ( BigInteger . ONE ) ; } return ans ; } } class InputReader { StringTokenizer tokenizer ; BufferedReader reader ; public InputReader ( InputStream stream ) { tokenizer = null ; reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException E ) { throw new RuntimeException ( E ) ; } } return tokenizer . nextToken ( ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { in = new InputReader ( System . in ) ; out = new PrintWriter ( System . out ) ; int n = Integer . valueOf ( in . next ( ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i , solve ( ) ) ; } out . close ( ) ; }"], ["solve", "static BigInteger solve ( ) { BigInteger r = new BigInteger ( in . next ( ) ) ; BigInteger t = new BigInteger ( in . next ( ) ) ; BigInteger x = new BigInteger ( \"0\" ) ; BigInteger y = new BigInteger ( \"2000000000000000000\" ) ; BigInteger ans = new BigInteger ( \"0\" ) ; while ( x . compareTo ( y ) != 1 ) { BigInteger m = x . add ( y ) . shiftRight ( 1 ) ; BigInteger tmp = m . multiply ( r ) . shiftLeft ( 1 ) . add ( m . multiply ( m . multiply ( m ) . shiftLeft ( 2 ) . subtract ( BigInteger . ONE ) ) . divide ( new BigInteger ( \"3\" ) ) ) . subtract ( m . subtract ( BigInteger . ONE ) . shiftLeft ( 1 ) . multiply ( m ) . multiply ( m . shiftLeft ( 1 ) . subtract ( BigInteger . ONE ) ) . divide ( new BigInteger ( \"3\" ) ) ) ; if ( tmp . compareTo ( t ) != 1 ) { ans = m ; x = m . add ( BigInteger . ONE ) ; } else y = m . subtract ( BigInteger . ONE ) ; } return ans ; }"]], "functions_class": [["InputReader", "public InputReader ( InputStream stream ) { tokenizer = null ; reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; }"], ["next", "public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException E ) { throw new RuntimeException ( E ) ; } } return tokenizer . nextToken ( ) ; }"]]}, {"id": "20", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; public class R1A { public static void main ( String [ ] args ) { String prblm = \" A \" ; boolean fl = true ; String filein = prblm + \" - \" + ( ( fl ) ? \" large \" : \" small \" ) + \" . in . txt \" ; String fileout = prblm + \" - \" + ( ( fl ) ? \" large \" : \" small \" ) + \" . out . txt \" ; try { BufferedReader fr = new BufferedReader ( new FileReader ( filein ) ) ; BufferedWriter fw = new BufferedWriter ( new FileWriter ( fileout ) ) ; String s = fr . readLine ( ) ; int T = Integer . parseInt ( s ) ; for ( int i = 1 ; i <= T ; i ++ ) { s = fr . readLine ( ) ; String [ ] tok = s . split ( \" \u2581 \" ) ; long r = Long . parseLong ( tok [ 0 ] ) ; long t = Long . parseLong ( tok [ 1 ] ) ; long mn = 0 , mx = 2000000000l ; while ( mx - mn > 0 ) { long v = ( mn + mx + 1 ) / 2 ; if ( Long . MAX_VALUE / ( 2 * r + 2 * v - 1 ) < v || v * ( 2 * r + 2 * v - 1 ) > t ) mx = v - 1 ; else mn = v ; } System . out . println ( mn ) ; fw . write ( \" Case \u2581 # \" + i + \" : \u2581 \" + mn + \" \\n \" ) ; } fr . close ( ) ; fw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { String prblm = \" A \" ; boolean fl = true ; String filein = prblm + \" - \" + ( ( fl ) ? \" large \" : \" small \" ) + \" . in . txt \" ; String fileout = prblm + \" - \" + ( ( fl ) ? \" large \" : \" small \" ) + \" . out . txt \" ; try { BufferedReader fr = new BufferedReader ( new FileReader ( filein ) ) ; BufferedWriter fw = new BufferedWriter ( new FileWriter ( fileout ) ) ; String s = fr . readLine ( ) ; int T = Integer . parseInt ( s ) ; for ( int i = 1 ; i <= T ; i ++ ) { s = fr . readLine ( ) ; String [ ] tok = s . split ( \" \u2581 \" ) ; long r = Long . parseLong ( tok [ 0 ] ) ; long t = Long . parseLong ( tok [ 1 ] ) ; long mn = 0 , mx = 2000000000l ; while ( mx - mn > 0 ) { long v = ( mn + mx + 1 ) / 2 ; if ( Long . MAX_VALUE / ( 2 * r + 2 * v - 1 ) < v || v * ( 2 * r + 2 * v - 1 ) > t ) mx = v - 1 ; else mn = v ; } System . out . println ( mn ) ; fw . write ( \" Case \u2581 # \" + i + \" : \u2581 \" + mn + \" \\n \" ) ; } fr . close ( ) ; fw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "10", "code": "import java . math . BigInteger ; import java . util . Scanner ; public class A { static BigInteger B ( long x ) { return BigInteger . valueOf ( x ) ; } static BigInteger r ; static BigInteger f ( long guess ) { BigInteger x = B ( guess ) ; BigInteger two_x_minus_one = x . multiply ( B ( 2 ) ) . subtract ( B ( 1 ) ) ; return B ( 2 ) . multiply ( x ) . multiply ( r ) . add ( x . multiply ( two_x_minus_one ) ) ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { r = BigInteger . valueOf ( in . nextLong ( ) ) ; BigInteger t = BigInteger . valueOf ( in . nextLong ( ) ) ; long lo = 0 ; long hi = t . longValue ( ) ; while ( lo < hi ) { long mid = ( lo + hi + 1 ) / 2 ; BigInteger score = f ( mid ) ; if ( score . compareTo ( t ) > 0 ) hi = mid - 1 ; else lo = mid ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , cas , lo ) ; } } }", "functions_standalone": [["B", "static BigInteger B ( long x ) { return BigInteger . valueOf ( x ) ; }"], ["f", "static BigInteger f ( long guess ) { BigInteger x = B ( guess ) ; BigInteger two_x_minus_one = x . multiply ( B ( 2 ) ) . subtract ( B ( 1 ) ) ; return B ( 2 ) . multiply ( x ) . multiply ( r ) . add ( x . multiply ( two_x_minus_one ) ) ; }"], ["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { r = BigInteger . valueOf ( in . nextLong ( ) ) ; BigInteger t = BigInteger . valueOf ( in . nextLong ( ) ) ; long lo = 0 ; long hi = t . longValue ( ) ; while ( lo < hi ) { long mid = ( lo + hi + 1 ) / 2 ; BigInteger score = f ( mid ) ; if ( score . compareTo ( t ) > 0 ) hi = mid - 1 ; else lo = mid ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , cas , lo ) ; } }"]], "functions_class": []}, {"id": "7", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintStream ; import java . math . BigInteger ; import java . util . Scanner ; public class A { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner scan = new Scanner ( System . in ) ; BigInteger TWO = BigInteger . valueOf ( 2 ) ; BigInteger FOUR = BigInteger . valueOf ( 4 ) ; int cases = scan . nextInt ( ) ; BigInteger r , t , res ; PrintStream outfile = new PrintStream ( \" C - large . out . txt \" ) ; for ( int c = 1 ; c <= cases ; c ++ ) { r = scan . nextBigInteger ( ) ; t = scan . nextBigInteger ( ) ; res = r . multiply ( r ) . subtract ( r ) ; res = res . add ( t . multiply ( TWO ) ) ; res = res . multiply ( FOUR ) . add ( BigInteger . ONE ) ; res = bigIntSqRootFloor ( res ) ; res = res . subtract ( r . mod ( TWO ) . equals ( BigInteger . ZERO ) ? BigInteger . valueOf ( 3 ) : BigInteger . valueOf ( 5 ) ) ; res = res . divide ( FOUR ) ; res = res . subtract ( r . divide ( TWO ) ) . add ( BigInteger . ONE ) ; outfile . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + res . toString ( ) ) ; } } public static BigInteger bigIntSqRootFloor ( BigInteger x ) throws IllegalArgumentException { if ( x . compareTo ( BigInteger . ZERO ) < 0 ) { throw new IllegalArgumentException ( \" Negative \u2581 argument . \" ) ; } if ( x == BigInteger . ZERO || x == BigInteger . ONE ) { return x ; } BigInteger two = BigInteger . valueOf ( 2L ) ; BigInteger y ; for ( y = x . divide ( two ) ; y . compareTo ( x . divide ( y ) ) > 0 ; y = ( ( x . divide ( y ) ) . add ( y ) ) . divide ( two ) ) ; return y ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner scan = new Scanner ( System . in ) ; BigInteger TWO = BigInteger . valueOf ( 2 ) ; BigInteger FOUR = BigInteger . valueOf ( 4 ) ; int cases = scan . nextInt ( ) ; BigInteger r , t , res ; PrintStream outfile = new PrintStream ( \" C - large . out . txt \" ) ; for ( int c = 1 ; c <= cases ; c ++ ) { r = scan . nextBigInteger ( ) ; t = scan . nextBigInteger ( ) ; res = r . multiply ( r ) . subtract ( r ) ; res = res . add ( t . multiply ( TWO ) ) ; res = res . multiply ( FOUR ) . add ( BigInteger . ONE ) ; res = bigIntSqRootFloor ( res ) ; res = res . subtract ( r . mod ( TWO ) . equals ( BigInteger . ZERO ) ? BigInteger . valueOf ( 3 ) : BigInteger . valueOf ( 5 ) ) ; res = res . divide ( FOUR ) ; res = res . subtract ( r . divide ( TWO ) ) . add ( BigInteger . ONE ) ; outfile . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + res . toString ( ) ) ; } }"], ["bigIntSqRootFloor", "public static BigInteger bigIntSqRootFloor ( BigInteger x ) throws IllegalArgumentException { if ( x . compareTo ( BigInteger . ZERO ) < 0 ) { throw new IllegalArgumentException ( \" Negative \u2581 argument . \" ) ; } if ( x == BigInteger . ZERO || x == BigInteger . ONE ) { return x ; } BigInteger two = BigInteger . valueOf ( 2L ) ; BigInteger y ; for ( y = x . divide ( two ) ; y . compareTo ( x . divide ( y ) ) > 0 ; y = ( ( x . divide ( y ) ) . add ( y ) ) . divide ( two ) ) ; return y ; }"]], "functions_class": []}, {"id": "15", "code": "import java . util . * ; import java . lang . * ; import java . math . * ; import java . io . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; public class A { Scanner sc = new Scanner ( System . in ) ; int INF = 1 << 28 ; double EPS = 1e-9 ; int caze , T ; long r , t ; void run ( ) { T = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( caze = 1 ; caze <= T ; caze ++ ) { r = sc . nextLong ( ) ; t = sc . nextLong ( ) ; solveSmall ( ) ; } } void solveSmall ( ) { long left = 0 , right = ( long ) 1e18 ; for ( ; right - left > 1 ; ) { long mid = ( left + right ) / 2 ; boolean ok = ( 2 * mid + 2 * r - 1 ) <= t / mid ; if ( ok ) { left = mid ; } else { right = mid ; } } answer ( \" \" + left ) ; } void solveLarge ( ) { } void answer ( String s ) { println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + s ) ; } void println ( String s ) { System . out . println ( s ) ; } void print ( String s ) { System . out . print ( s ) ; } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new A ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new A ( ) . run ( ) ; }"]], "functions_class": [["run", "void run ( ) { T = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( caze = 1 ; caze <= T ; caze ++ ) { r = sc . nextLong ( ) ; t = sc . nextLong ( ) ; solveSmall ( ) ; } }"], ["solveSmall", "void solveSmall ( ) { long left = 0 , right = ( long ) 1e18 ; for ( ; right - left > 1 ; ) { long mid = ( left + right ) / 2 ; boolean ok = ( 2 * mid + 2 * r - 1 ) <= t / mid ; if ( ok ) { left = mid ; } else { right = mid ; } } answer ( \" \" + left ) ; }"], ["solveLarge", "void solveLarge ( ) { }"], ["answer", "void answer ( String s ) { println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + s ) ; }"], ["println", "void println ( String s ) { System . out . println ( s ) ; }"], ["print", "void print ( String s ) { System . out . print ( s ) ; }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}], "python": [{"id": "8", "code": "tn = int ( input ( ) ) NEW_LINE for t in range ( 1 , tn + 1 ) : NEW_LINE INDENT r , v = map ( int , input ( ) . split ( ) ) NEW_LINE mn , mx = 0 , v NEW_LINE while mn < mx : NEW_LINE INDENT av = ( mn + mx + 1 ) // 2 NEW_LINE tt = 2 * av * ( r + av ) - av NEW_LINE if tt > v : NEW_LINE INDENT mx = av - 1 NEW_LINE DEDENT else : NEW_LINE INDENT mn = av NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( t , mn ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "9", "code": "def paint_needed ( r , n ) : return ( 2 * r + 1 + 2 * ( n - 1 ) ) * n NEW_LINE T = int ( input ( ) ) NEW_LINE for test in range ( 1 , T + 1 ) : NEW_LINE INDENT r , t = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE lo , hi = 1 , t + 1 NEW_LINE while hi - lo > 1 : NEW_LINE INDENT med = ( hi + lo ) // 2 NEW_LINE if paint_needed ( r , med ) <= t : lo = med NEW_LINE else : hi = med NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( test , lo ) ) NEW_LINE DEDENT", "functions_standalone": [["paint_needed", "def paint_needed ( r , n ) : return ( 2 * r + 1 + 2 * ( n - 1 ) ) * n NEW_LINE T = int ( input ( ) ) NEW_LINE for test in range ( 1 , T + 1 ) : NEW_LINE INDENT r , t = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE lo , hi = 1 , t + 1 NEW_LINE while hi - lo > 1 : NEW_LINE INDENT med = ( hi + lo ) // 2 NEW_LINE if paint_needed ( r , med ) <= t : lo = med NEW_LINE else : hi = med NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( test , lo ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "def comp ( x , r ) : NEW_LINE INDENT return 2 * x * x + ( 3 + 2 * r ) * x + 2 * r + 1 NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT R , T = map ( int , input ( ) . split ( ) ) NEW_LINE l = 0 NEW_LINE r = T + 1 NEW_LINE while l + 1 < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if comp ( m - 1 , R ) <= T : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for tn in range ( T ) : NEW_LINE INDENT print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( tn + 1 , solve ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["comp", "def comp ( x , r ) : NEW_LINE INDENT return 2 * x * x + ( 3 + 2 * r ) * x + 2 * r + 1 NEW_LINE DEDENT"], ["solve", "def solve ( ) : NEW_LINE INDENT R , T = map ( int , input ( ) . split ( ) ) NEW_LINE l = 0 NEW_LINE r = T + 1 NEW_LINE while l + 1 < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if comp ( m - 1 , R ) <= T : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT"]], "functions_class": []}, {"id": "7", "code": "def can ( r , t , n ) : NEW_LINE INDENT paint_needed = n * ( 2 * r + 1 ) + 2 * n * ( n - 1 ) NEW_LINE return paint_needed <= t NEW_LINE DEDENT def solve ( r , t ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = ( t + 1 ) // 2 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi + 1 ) // 2 NEW_LINE if can ( r , t , mid ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for tt in range ( T ) : NEW_LINE INDENT r , t = tuple ( int ( tok ) for tok in input ( ) . split ( ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( tt + 1 , solve ( r , t ) ) ) NEW_LINE DEDENT", "functions_standalone": [["can", "def can ( r , t , n ) : NEW_LINE INDENT paint_needed = n * ( 2 * r + 1 ) + 2 * n * ( n - 1 ) NEW_LINE return paint_needed <= t NEW_LINE DEDENT"], ["solve", "def solve ( r , t ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = ( t + 1 ) // 2 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi + 1 ) // 2 NEW_LINE if can ( r , t , mid ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "from functools import * NEW_LINE inf = open ( ' A - large . in ' ) NEW_LINE ouf = open ( ' output . txt ' , ' w ' ) NEW_LINE input = lambda : inf . readline ( ) . strip ( ) NEW_LINE print = partial ( print , file = ouf ) NEW_LINE def solve ( ) : NEW_LINE INDENT r , t = map ( int , input ( ) . split ( ) ) NEW_LINE le = 1 NEW_LINE ri = 10 ** 18 NEW_LINE while le + 1 < ri : NEW_LINE INDENT m = ( le + ri ) // 2 NEW_LINE if ( 2 * r + 1 ) * m + 2 * ( m - 1 ) * m <= t : NEW_LINE INDENT le = m NEW_LINE DEDENT else : NEW_LINE INDENT ri = m NEW_LINE DEDENT DEDENT print ( le ) NEW_LINE DEDENT tests = int ( input ( ) ) NEW_LINE for z in range ( tests ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 \" . format ( z + 1 ) , end = ' ' ) NEW_LINE solve ( ) NEW_LINE DEDENT ouf . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT r , t = map ( int , input ( ) . split ( ) ) NEW_LINE le = 1 NEW_LINE ri = 10 ** 18 NEW_LINE while le + 1 < ri : NEW_LINE INDENT m = ( le + ri ) // 2 NEW_LINE if ( 2 * r + 1 ) * m + 2 * ( m - 1 ) * m <= t : NEW_LINE INDENT le = m NEW_LINE DEDENT else : NEW_LINE INDENT ri = m NEW_LINE DEDENT DEDENT print ( le ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_42", "java": [{"id": "14", "code": "import java . util . Scanner ; public class B { static Scanner sc = new Scanner ( System . in ) ; static int N ; static long P ; public static void main ( String [ ] args ) throws Exception { int T = sc . nextInt ( ) ; for ( int t = 1 ; t <= T ; ++ t ) { N = sc . nextInt ( ) ; P = sc . nextLong ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + ( solveGuarantee ( 1L << N , P ) - 1 ) + \" \u2581 \" + ( solveCould ( 1L << N , P ) - 1 ) ) ; } } static long solveGuarantee ( long n , long p ) { if ( p == n ) return n ; if ( p <= n / 2 ) return 1 ; return solveGuarantee ( n / 2 , p - n / 2 ) * 2 + 1 ; } static long solveCould ( long n , long p ) { if ( p == n ) return n ; if ( p >= n / 2 ) return n - 1 ; long c = solveCould ( n / 2 , p ) ; return c + c - 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { int T = sc . nextInt ( ) ; for ( int t = 1 ; t <= T ; ++ t ) { N = sc . nextInt ( ) ; P = sc . nextLong ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + ( solveGuarantee ( 1L << N , P ) - 1 ) + \" \u2581 \" + ( solveCould ( 1L << N , P ) - 1 ) ) ; } }"], ["solveGuarantee", "static long solveGuarantee ( long n , long p ) { if ( p == n ) return n ; if ( p <= n / 2 ) return 1 ; return solveGuarantee ( n / 2 , p - n / 2 ) * 2 + 1 ; }"], ["solveCould", "static long solveCould ( long n , long p ) { if ( p == n ) return n ; if ( p >= n / 2 ) return n - 1 ; long c = solveCould ( n / 2 , p ) ; return c + c - 1 ; }"]], "functions_class": []}, {"id": "10", "code": "package contest ; import java . util . * ; import java . io . * ; public class ManyPrizes { final static String PROBLEM_NAME = \" mprizes \" ; final static String WORK_DIR = \" D : \\\\ Gcj \\ \\\" + PROBLEM_NAME + \" \\ \\\" ; void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; long P = sc . nextLong ( ) ; long ans1 = - 1 ; long sum = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { sum += ( 1L << i ) ; if ( P <= sum ) { ans1 = ( 1L << ( N - i ) ) - 1 ; break ; } } if ( ans1 == - 1 ) ans1 = ( 1L << N ) ; long ans2 = - 1 ; int needWins = 0 ; while ( ( 1L << ( N - needWins ) ) > P ) needWins ++ ; ans2 = ( 1L << N ) - ( 1L << needWins ) + 1 ; ans1 -- ; ans2 -- ; pw . println ( ans1 + \" \u2581 \" + ans2 ) ; } public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new ManyPrizes ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new ManyPrizes ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["solve", "void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; long P = sc . nextLong ( ) ; long ans1 = - 1 ; long sum = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { sum += ( 1L << i ) ; if ( P <= sum ) { ans1 = ( 1L << ( N - i ) ) - 1 ; break ; } } if ( ans1 == - 1 ) ans1 = ( 1L << N ) ; long ans2 = - 1 ; int needWins = 0 ; while ( ( 1L << ( N - needWins ) ) > P ) needWins ++ ; ans2 = ( 1L << N ) - ( 1L << needWins ) + 1 ; ans1 -- ; ans2 -- ; pw . println ( ans1 + \" \u2581 \" + ans2 ) ; }"]]}, {"id": "6", "code": "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class B { void solve ( ) throws IOException { int t = nextInt ( ) ; for ( int testCase = 0 ; testCase < t ; testCase ++ ) { long n = nextInt ( ) ; long p = nextLong ( ) ; long max = 1l << n ; long a1 = 0 , a2 = max - 2 ; if ( p == 1 ) { a1 = a2 = 0 ; } else if ( p == max ) { a1 = a2 = max - 1 ; } else { long x = max >> 1l ; long y = x >> 1l ; long z = 2 ; while ( p > x ) { a1 += z ; z <<= 1l ; x |= y ; y >>= 1l ; } x = max >> 1l ; z = 2 ; while ( p < x ) { a2 -= z ; z <<= 1l ; x >>= 1l ; } } out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , testCase + 1 , a1 , a2 ) ; } } public static void main ( String [ ] args ) throws IOException { new B ( ) . run ( ) ; } void run ( ) throws IOException { reader = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; tokenizer = null ; solve ( ) ; reader . close ( ) ; out . flush ( ) ; } BufferedReader reader ; StringTokenizer tokenizer ; PrintWriter out ; int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; } String nextToken ( ) throws IOException { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new B ( ) . run ( ) ; }"]], "functions_class": [["solve", "void solve ( ) throws IOException { int t = nextInt ( ) ; for ( int testCase = 0 ; testCase < t ; testCase ++ ) { long n = nextInt ( ) ; long p = nextLong ( ) ; long max = 1l << n ; long a1 = 0 , a2 = max - 2 ; if ( p == 1 ) { a1 = a2 = 0 ; } else if ( p == max ) { a1 = a2 = max - 1 ; } else { long x = max >> 1l ; long y = x >> 1l ; long z = 2 ; while ( p > x ) { a1 += z ; z <<= 1l ; x |= y ; y >>= 1l ; } x = max >> 1l ; z = 2 ; while ( p < x ) { a2 -= z ; z <<= 1l ; x >>= 1l ; } } out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , testCase + 1 , a1 , a2 ) ; } }"], ["run", "void run ( ) throws IOException { reader = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; tokenizer = null ; solve ( ) ; reader . close ( ) ; out . flush ( ) ; }"], ["nextInt", "int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; }"], ["nextToken", "String nextToken ( ) throws IOException { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; }"]]}, {"id": "11", "code": "import java . math . BigInteger ; import java . util . * ; public class B { static BigInteger B ( long n ) { return BigInteger . valueOf ( n ) ; } static BigInteger A ( BigInteger A , BigInteger B ) { return A . add ( B ) ; } static BigInteger M ( BigInteger A , BigInteger B ) { return A . multiply ( B ) ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { int n = in . nextInt ( ) ; BigInteger P = new BigInteger ( in . next ( ) ) ; BigInteger last_pos = B ( 2 ) . pow ( n ) . subtract ( P ) ; int min_ones = 0 ; for ( min_ones = 0 ; min_ones <= n ; min_ones ++ ) { BigInteger val = B ( 0 ) ; for ( int i = 0 ; i < min_ones ; i ++ ) val = A ( val , B ( 2 ) . pow ( n - 1 - i ) ) ; if ( val . compareTo ( last_pos ) >= 0 ) break ; } BigInteger last_win = B ( 2 ) . pow ( n ) . subtract ( B ( 2 ) . pow ( min_ones ) ) ; int min_zeroes = 0 ; for ( min_zeroes = 0 ; min_zeroes <= n ; min_zeroes ++ ) { BigInteger val = B ( 2 ) . pow ( n ) . subtract ( B ( 1 ) ) ; for ( int i = 0 ; i < min_zeroes ; i ++ ) val = val . subtract ( B ( 2 ) . pow ( n - 1 - i ) ) ; if ( val . compareTo ( last_pos ) < 0 ) break ; } BigInteger last_guarantee = B ( 2 ) . pow ( min_zeroes ) . subtract ( B ( 2 ) ) ; if ( last_pos . equals ( B ( 0 ) ) ) last_guarantee = B ( 2 ) . pow ( n ) . subtract ( B ( 1 ) ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s \u2581 % s \\n \" , cas , last_guarantee , last_win ) ; } } }", "functions_standalone": [["B", "static BigInteger B ( long n ) { return BigInteger . valueOf ( n ) ; }"], ["A", "static BigInteger A ( BigInteger A , BigInteger B ) { return A . add ( B ) ; }"], ["M", "static BigInteger M ( BigInteger A , BigInteger B ) { return A . multiply ( B ) ; }"], ["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { int n = in . nextInt ( ) ; BigInteger P = new BigInteger ( in . next ( ) ) ; BigInteger last_pos = B ( 2 ) . pow ( n ) . subtract ( P ) ; int min_ones = 0 ; for ( min_ones = 0 ; min_ones <= n ; min_ones ++ ) { BigInteger val = B ( 0 ) ; for ( int i = 0 ; i < min_ones ; i ++ ) val = A ( val , B ( 2 ) . pow ( n - 1 - i ) ) ; if ( val . compareTo ( last_pos ) >= 0 ) break ; } BigInteger last_win = B ( 2 ) . pow ( n ) . subtract ( B ( 2 ) . pow ( min_ones ) ) ; int min_zeroes = 0 ; for ( min_zeroes = 0 ; min_zeroes <= n ; min_zeroes ++ ) { BigInteger val = B ( 2 ) . pow ( n ) . subtract ( B ( 1 ) ) ; for ( int i = 0 ; i < min_zeroes ; i ++ ) val = val . subtract ( B ( 2 ) . pow ( n - 1 - i ) ) ; if ( val . compareTo ( last_pos ) < 0 ) break ; } BigInteger last_guarantee = B ( 2 ) . pow ( min_zeroes ) . subtract ( B ( 2 ) ) ; if ( last_pos . equals ( B ( 0 ) ) ) last_guarantee = B ( 2 ) . pow ( n ) . subtract ( B ( 1 ) ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s \u2581 % s \\n \" , cas , last_guarantee , last_win ) ; } }"]], "functions_class": []}, {"id": "2", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( B . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( B . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; } private String solve ( Scanner in ) { int n = in . nextInt ( ) ; long p = in . nextLong ( ) ; p -- ; long b = 1 ; if ( p == ( ( 1L << n ) - 1 ) ) { b = ( ( 1L << n ) - 1 ) + 2 ; } else { long pp = ( 1L << n ) - 1 - ( p + 1 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( ( pp >> i ) & 1 ) == 0 ) { b *= 2 ; } else { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( ( pp >> j ) & 1 ) == 0 ) { b *= 2 ; break ; } } break ; } } } long pp = ( 1L << n ) - 1 - p ; long c = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( ( pp >> i ) & 1 ) == 1 ) { c *= 2 ; } else { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( ( pp >> j ) & 1 ) == 1 ) { c *= 2 ; break ; } } break ; } } return ( b - 2 ) + \" \u2581 \" + ( ( 1L << n ) - c ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( B . class . getSimpleName ( ) + \" . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( B . class . getSimpleName ( ) + \" . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new B ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private String solve ( Scanner in ) { int n = in . nextInt ( ) ; long p = in . nextLong ( ) ; p -- ; long b = 1 ; if ( p == ( ( 1L << n ) - 1 ) ) { b = ( ( 1L << n ) - 1 ) + 2 ; } else { long pp = ( 1L << n ) - 1 - ( p + 1 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( ( pp >> i ) & 1 ) == 0 ) { b *= 2 ; } else { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( ( pp >> j ) & 1 ) == 0 ) { b *= 2 ; break ; } } break ; } } } long pp = ( 1L << n ) - 1 - p ; long c = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( ( pp >> i ) & 1 ) == 1 ) { c *= 2 ; } else { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( ( pp >> j ) & 1 ) == 1 ) { c *= 2 ; break ; } } break ; } } return ( b - 2 ) + \" \u2581 \" + ( ( 1L << n ) - c ) ; }"]]}], "python": [{"id": "2", "code": "def read ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE DEDENT def best ( rank , tot ) : NEW_LINE INDENT if rank == tot - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return tot // 2 + best ( ( rank + 1 ) // 2 , tot // 2 ) NEW_LINE DEDENT def worst ( rank , tot ) : NEW_LINE INDENT if rank == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return tot // 2 + worst ( ( rank - 1 ) // 2 , tot // 2 ) NEW_LINE DEDENT [ T ] = read ( ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT n , P = read ( ) NEW_LINE ans1 , ans2 = 0 , 2 ** n - 1 NEW_LINE L , R = 0 , 2 ** n - 1 NEW_LINE while L < R : NEW_LINE INDENT m = ( L + R + 1 ) // 2 NEW_LINE if worst ( m , 2 ** n ) >= P : NEW_LINE INDENT R = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT L = m NEW_LINE DEDENT DEDENT ans1 = L NEW_LINE L , R = 0 , 2 ** n - 1 NEW_LINE while L < R : NEW_LINE INDENT m = ( L + R + 1 ) // 2 NEW_LINE if best ( m , 2 ** n ) < 2 ** n - P : NEW_LINE INDENT R = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT L = m NEW_LINE DEDENT DEDENT ans2 = L NEW_LINE print ( ' Case \u2581 # % d : \u2581 % d \u2581 % d ' % ( i , ans1 , ans2 ) ) NEW_LINE DEDENT", "functions_standalone": [["read", "def read ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE DEDENT"], ["best", "def best ( rank , tot ) : NEW_LINE INDENT if rank == tot - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return tot // 2 + best ( ( rank + 1 ) // 2 , tot // 2 ) NEW_LINE DEDENT"], ["worst", "def worst ( rank , tot ) : NEW_LINE INDENT if rank == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return tot // 2 + worst ( ( rank - 1 ) // 2 , tot // 2 ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "import sys , os NEW_LINE in_file = None NEW_LINE out_file = None NEW_LINE def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in range ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT", "functions_standalone": [["run_main", "def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT"], ["run_tests", "def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT"], ["readline", "def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT"], ["writeline", "def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT"], ["readinteger", "def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readintegers", "def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in range ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT"]], "functions_class": []}, {"id": "18", "code": "from sys import * NEW_LINE from heapq import * NEW_LINE import math NEW_LINE def write ( msg ) : NEW_LINE INDENT stdout . write ( msg ) NEW_LINE fo . write ( msg ) NEW_LINE DEDENT def writeln ( msg ) : NEW_LINE INDENT write ( str ( msg ) + ' \\n ' ) NEW_LINE DEDENT def readint ( ) : NEW_LINE INDENT return int ( fi . readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT return [ int ( X ) for X in fi . readline ( ) . split ( ) ] NEW_LINE DEDENT def readstr ( ) : NEW_LINE INDENT return fi . readline ( ) . rstrip ( ) NEW_LINE DEDENT fni = \" % s - % s - % s . in \" % ( argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) NEW_LINE fno = \" % s - % s - % s . out \" % ( argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) NEW_LINE fi = open ( fni , ' r ' ) NEW_LINE fo = open ( fno , ' w ' ) NEW_LINE def ffail ( start , step , num , prizes ) : NEW_LINE INDENT if prizes >= num : NEW_LINE INDENT return start + step * ( num - 1 ) + 1 NEW_LINE DEDENT if prizes <= 0 : NEW_LINE INDENT return start NEW_LINE DEDENT if 2 * prizes <= num : NEW_LINE INDENT return start + step NEW_LINE DEDENT return ffail ( start + step , step * 2 , num / 2 , prizes - num / 2 ) NEW_LINE DEDENT def wwin ( start , step , num , prizes ) : NEW_LINE INDENT if prizes >= num : NEW_LINE INDENT return start + step * ( num - 1 ) NEW_LINE DEDENT if prizes <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return wwin ( start , step * 2 , num / 2 , prizes ) NEW_LINE DEDENT num_cases = readint ( ) NEW_LINE for case in range ( 1 , 1 + num_cases ) : NEW_LINE INDENT ( N , P ) = readints ( ) NEW_LINE g = ffail ( 0 , 1 , 2 ** N , P ) - 1 NEW_LINE w = wwin ( 0 , 1 , 2 ** N , P ) NEW_LINE writeln ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \" % ( case , g , w ) ) NEW_LINE DEDENT", "functions_standalone": [["write", "def write ( msg ) : NEW_LINE INDENT stdout . write ( msg ) NEW_LINE fo . write ( msg ) NEW_LINE DEDENT"], ["writeln", "def writeln ( msg ) : NEW_LINE INDENT write ( str ( msg ) + ' \\n ' ) NEW_LINE DEDENT"], ["readint", "def readint ( ) : NEW_LINE INDENT return int ( fi . readline ( ) ) NEW_LINE DEDENT"], ["readints", "def readints ( ) : NEW_LINE INDENT return [ int ( X ) for X in fi . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["readstr", "def readstr ( ) : NEW_LINE INDENT return fi . readline ( ) . rstrip ( ) NEW_LINE DEDENT"], ["ffail", "def ffail ( start , step , num , prizes ) : NEW_LINE INDENT if prizes >= num : NEW_LINE INDENT return start + step * ( num - 1 ) + 1 NEW_LINE DEDENT if prizes <= 0 : NEW_LINE INDENT return start NEW_LINE DEDENT if 2 * prizes <= num : NEW_LINE INDENT return start + step NEW_LINE DEDENT return ffail ( start + step , step * 2 , num / 2 , prizes - num / 2 ) NEW_LINE DEDENT"], ["wwin", "def wwin ( start , step , num , prizes ) : NEW_LINE INDENT if prizes >= num : NEW_LINE INDENT return start + step * ( num - 1 ) NEW_LINE DEDENT if prizes <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return wwin ( start , step * 2 , num / 2 , prizes ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "def get_guaranteed ( N , P ) : NEW_LINE INDENT assert P > 0 NEW_LINE if N == 0 : return 0 NEW_LINE total = 2 ** N NEW_LINE if P == total : return total - 1 NEW_LINE if 2 * P <= total : return 0 NEW_LINE tmp = get_guaranteed ( N - 1 , P - total // 2 ) NEW_LINE return 2 * tmp + 2 NEW_LINE DEDENT def get_possible ( N , P ) : NEW_LINE INDENT assert P > 0 NEW_LINE if N == 0 : return 0 NEW_LINE total = 2 ** N NEW_LINE if P == total : return total - 1 NEW_LINE if P == total // 2 : return total - 2 NEW_LINE if 2 * P <= total : NEW_LINE INDENT tmp = get_possible ( N - 1 , P ) NEW_LINE return 2 * tmp NEW_LINE DEDENT else : NEW_LINE INDENT return total - 2 NEW_LINE DEDENT DEDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT N , P = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \u2581 { } \" . format ( t , get_guaranteed ( N , P ) , get_possible ( N , P ) ) ) NEW_LINE DEDENT", "functions_standalone": [["get_guaranteed", "def get_guaranteed ( N , P ) : NEW_LINE INDENT assert P > 0 NEW_LINE if N == 0 : return 0 NEW_LINE total = 2 ** N NEW_LINE if P == total : return total - 1 NEW_LINE if 2 * P <= total : return 0 NEW_LINE tmp = get_guaranteed ( N - 1 , P - total // 2 ) NEW_LINE return 2 * tmp + 2 NEW_LINE DEDENT"], ["get_possible", "def get_possible ( N , P ) : NEW_LINE INDENT assert P > 0 NEW_LINE if N == 0 : return 0 NEW_LINE total = 2 ** N NEW_LINE if P == total : return total - 1 NEW_LINE if P == total // 2 : return total - 2 NEW_LINE if 2 * P <= total : NEW_LINE INDENT tmp = get_possible ( N - 1 , P ) NEW_LINE return 2 * tmp NEW_LINE DEDENT else : NEW_LINE INDENT return total - 2 NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "12", "code": "from functools import * NEW_LINE inf = open ( ' B - large . in ' ) NEW_LINE ouf = open ( ' output . txt ' , ' w ' ) NEW_LINE input = lambda : inf . readline ( ) . strip ( ) NEW_LINE print = partial ( print , file = ouf ) NEW_LINE def solve ( ) : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE y = max ( min ( 2 ** q - 2 , 2 ** n - 1 ) for q in range ( 1 , n + 2 ) if 2 ** n - 2 ** ( n - q + 1 ) < p ) NEW_LINE z = max ( 2 ** n - 2 ** q for q in range ( 0 , n + 1 ) if 2 ** ( n - q ) - 1 < p ) NEW_LINE print ( y , z ) NEW_LINE DEDENT tests = int ( input ( ) ) NEW_LINE for z in range ( tests ) : NEW_LINE INDENT print ( \" Case \u2581 # { } : \u2581 \" . format ( z + 1 ) , end = ' ' ) NEW_LINE solve ( ) NEW_LINE DEDENT ouf . close ( ) NEW_LINE", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE y = max ( min ( 2 ** q - 2 , 2 ** n - 1 ) for q in range ( 1 , n + 2 ) if 2 ** n - 2 ** ( n - q + 1 ) < p ) NEW_LINE z = max ( 2 ** n - 2 ** q for q in range ( 0 , n + 1 ) if 2 ** ( n - q ) - 1 < p ) NEW_LINE print ( y , z ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_21", "java": [{"id": "9", "code": "import gcj . GCJ ; import java . util . Arrays ; import java . util . Scanner ; public class Osmos { public static void main ( String [ ] args ) { Scanner s = GCJ . createScanner ( ' A ' , true ) ; int T = s . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int size = s . nextInt ( ) ; int N = s . nextInt ( ) ; int [ ] m = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { m [ j ] = s . nextInt ( ) ; } Arrays . sort ( m ) ; int min = N ; if ( size > 1 ) { int cnt = 0 ; for ( int j = 0 ; j < N ; j ++ ) { while ( size <= m [ j ] ) { cnt ++ ; size += size - 1 ; } size += m [ j ] ; min = Math . min ( min , cnt + N - j - 1 ) ; } } GCJ . out ( i , Integer . toString ( min ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner s = GCJ . createScanner ( ' A ' , true ) ; int T = s . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int size = s . nextInt ( ) ; int N = s . nextInt ( ) ; int [ ] m = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { m [ j ] = s . nextInt ( ) ; } Arrays . sort ( m ) ; int min = N ; if ( size > 1 ) { int cnt = 0 ; for ( int j = 0 ; j < N ; j ++ ) { while ( size <= m [ j ] ) { cnt ++ ; size += size - 1 ; } size += m [ j ] ; min = Math . min ( min , cnt + N - j - 1 ) ; } } GCJ . out ( i , Integer . toString ( min ) ) ; } }"]], "functions_class": []}, {"id": "3", "code": "import java . io . * ; import java . util . * ; public class A { private static String fileName = A . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) . toLowerCase ( ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; private static Scanner in ; private static PrintWriter out ; private void solve ( ) { long s = in . nextInt ( ) ; int n = in . nextInt ( ) ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; int ans = n ; int created = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s == 1 ) { break ; } while ( s <= a [ i ] ) { created ++ ; s += s - 1 ; } s += a [ i ] ; ans = Math . min ( ans , created + n - i - 1 ) ; } out . println ( ans ) ; } public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new A ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new A ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( ) { long s = in . nextInt ( ) ; int n = in . nextInt ( ) ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; int ans = n ; int created = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s == 1 ) { break ; } while ( s <= a [ i ] ) { created ++ ; s += s - 1 ; } s += a [ i ] ; ans = Math . min ( ans , created + n - i - 1 ) ; } out . println ( ans ) ; }"]]}, {"id": "1", "code": "package round1b ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . util . Arrays ; public class A { public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" src / round1b / A - large . in \" ) , new FileOutputStream ( \" src / round1b / A - large . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; new A ( ) . solve ( io ) ; } io . close ( ) ; } private void solve ( Kattio io ) { int mySize = io . getInt ( ) ; int n = io . getInt ( ) ; int size [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { size [ i ] = io . getInt ( ) ; } Arrays . sort ( size ) ; if ( mySize == 1 ) { io . println ( n ) ; return ; } int best = Integer . MAX_VALUE ; for ( int rem = 0 ; rem <= n ; rem ++ ) { int cur = mySize , added = 0 ; for ( int i = 0 ; i < n - rem ; i ++ ) { if ( cur <= size [ i ] ) { cur += ( cur - 1 ) ; added ++ ; i -- ; } else { cur += size [ i ] ; } } best = Math . min ( best , rem + added ) ; } io . println ( best ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" src / round1b / A - large . in \" ) , new FileOutputStream ( \" src / round1b / A - large . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; new A ( ) . solve ( io ) ; } io . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( Kattio io ) { int mySize = io . getInt ( ) ; int n = io . getInt ( ) ; int size [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { size [ i ] = io . getInt ( ) ; } Arrays . sort ( size ) ; if ( mySize == 1 ) { io . println ( n ) ; return ; } int best = Integer . MAX_VALUE ; for ( int rem = 0 ; rem <= n ; rem ++ ) { int cur = mySize , added = 0 ; for ( int i = 0 ; i < n - rem ; i ++ ) { if ( cur <= size [ i ] ) { cur += ( cur - 1 ) ; added ++ ; i -- ; } else { cur += size [ i ] ; } } best = Math . min ( best , rem + added ) ; } io . println ( best ) ; }"]]}, {"id": "17", "code": "import java . util . * ; import java . math . * ; public class Main { static long [ ] [ ] dp ; public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int taskCount = scan . nextInt ( ) ; dp = new long [ 101 ] [ 201 ] ; for ( int taskIndex = 1 ; taskIndex <= taskCount ; taskIndex ++ ) { int A = scan . nextInt ( ) ; int N = scan . nextInt ( ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = scan . nextInt ( ) ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= 200 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } dp [ 0 ] [ 0 ] = A ; for ( int i = 1 ; i <= N ; i ++ ) { long current = arr [ i - 1 ] ; for ( int j = 0 ; j <= 200 ; j ++ ) { if ( dp [ i - 1 ] [ j ] == - 1 ) { continue ; } dp [ i ] [ j + 1 ] = Math . max ( dp [ i ] [ j + 1 ] , dp [ i - 1 ] [ j ] ) ; if ( dp [ i - 1 ] [ j ] <= 1 ) { continue ; } long temp = dp [ i - 1 ] [ j ] ; int add = 0 ; while ( temp <= current ) { temp += temp - 1 ; add ++ ; } dp [ i ] [ j + add ] = Math . max ( dp [ i ] [ j + add ] , temp + current ) ; } } int res = - 1 ; for ( int i = 0 ; i <= 200 ; i ++ ) { if ( dp [ N ] [ i ] >= 0 ) { res = i ; break ; } } System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , taskIndex , res ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int taskCount = scan . nextInt ( ) ; dp = new long [ 101 ] [ 201 ] ; for ( int taskIndex = 1 ; taskIndex <= taskCount ; taskIndex ++ ) { int A = scan . nextInt ( ) ; int N = scan . nextInt ( ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = scan . nextInt ( ) ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= 200 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } dp [ 0 ] [ 0 ] = A ; for ( int i = 1 ; i <= N ; i ++ ) { long current = arr [ i - 1 ] ; for ( int j = 0 ; j <= 200 ; j ++ ) { if ( dp [ i - 1 ] [ j ] == - 1 ) { continue ; } dp [ i ] [ j + 1 ] = Math . max ( dp [ i ] [ j + 1 ] , dp [ i - 1 ] [ j ] ) ; if ( dp [ i - 1 ] [ j ] <= 1 ) { continue ; } long temp = dp [ i - 1 ] [ j ] ; int add = 0 ; while ( temp <= current ) { temp += temp - 1 ; add ++ ; } dp [ i ] [ j + add ] = Math . max ( dp [ i ] [ j + add ] , temp + current ) ; } } int res = - 1 ; for ( int i = 0 ; i <= 200 ; i ++ ) { if ( dp [ N ] [ i ] >= 0 ) { res = i ; break ; } } System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , taskIndex , res ) ) ; } }"]], "functions_class": []}, {"id": "10", "code": "import java . util . Arrays ; import java . util . Scanner ; public class A { int calc ( int a , int [ ] b ) { int i = 0 ; int res = 0 ; if ( a == 1 ) { return 100000 ; } while ( i < b . length ) { if ( b [ i ] < a ) { a += b [ i ] ; i ++ ; } else { a += a - 1 ; res ++ ; } } return res ; } void solve ( int a , int [ ] b ) { Arrays . sort ( b ) ; int best = b . length ; for ( int i = 0 ; i <= b . length ; i ++ ) { best = Math . min ( best , calc ( a , Arrays . copyOf ( b , i ) ) + ( b . length - i ) ) ; } System . out . println ( best ) ; } void run ( ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int it = 0 ; it < t ; it ++ ) { System . out . print ( \" Case \u2581 # \" + ( it + 1 ) + \" : \u2581 \" ) ; int a = in . nextInt ( ) ; int n = in . nextInt ( ) ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = in . nextInt ( ) ; } solve ( a , b ) ; } } public static void main ( String [ ] args ) { new A ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { new A ( ) . run ( ) ; }"]], "functions_class": [["calc", "int calc ( int a , int [ ] b ) { int i = 0 ; int res = 0 ; if ( a == 1 ) { return 100000 ; } while ( i < b . length ) { if ( b [ i ] < a ) { a += b [ i ] ; i ++ ; } else { a += a - 1 ; res ++ ; } } return res ; }"], ["solve", "void solve ( int a , int [ ] b ) { Arrays . sort ( b ) ; int best = b . length ; for ( int i = 0 ; i <= b . length ; i ++ ) { best = Math . min ( best , calc ( a , Arrays . copyOf ( b , i ) ) + ( b . length - i ) ) ; } System . out . println ( best ) ; }"], ["run", "void run ( ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int it = 0 ; it < t ; it ++ ) { System . out . print ( \" Case \u2581 # \" + ( it + 1 ) + \" : \u2581 \" ) ; int a = in . nextInt ( ) ; int n = in . nextInt ( ) ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = in . nextInt ( ) ; } solve ( a , b ) ; } }"]]}], "python": [{"id": "8", "code": "FILE_NAME_BASE = ' A - large ' NEW_LINE NUM_PROCESSES = 0 NEW_LINE MEM_LIMIT_GB = 1.5 NEW_LINE RECURSION_LIMIT = 1000 NEW_LINE def parse ( inp ) : NEW_LINE INDENT start , num = ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE motes = tuple ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE assert len ( motes ) == num NEW_LINE return start , motes NEW_LINE DEDENT def solve ( start , motes ) : NEW_LINE INDENT motes = sorted ( motes ) NEW_LINE num = len ( motes ) NEW_LINE best = num NEW_LINE size = start NEW_LINE added = 0 NEW_LINE i = 0 NEW_LINE while i < num : NEW_LINE INDENT if motes [ i ] < size : NEW_LINE INDENT size += motes [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT best = min ( best , added + num - i ) NEW_LINE if size <= 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT while motes [ i ] - size >= 0 : NEW_LINE INDENT size += size - 1 NEW_LINE added += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT best = min ( best , added ) NEW_LINE DEDENT return best NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT import sys NEW_LINE sys . setrecursionlimit ( RECURSION_LIMIT ) NEW_LINE import resource NEW_LINE soft , hard = resource . getrlimit ( resource . RLIMIT_AS ) NEW_LINE resource . setrlimit ( resource . RLIMIT_AS , ( MEM_LIMIT_GB * 1024 ** 3 , hard ) ) NEW_LINE inp = open ( FILE_NAME_BASE + ' . in ' , ' r ' ) NEW_LINE numCases = int ( inp . readline ( ) ) NEW_LINE if NUM_PROCESSES == 0 : NEW_LINE INDENT results = [ solve ( * parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT else : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE pool = Pool ( NUM_PROCESSES ) NEW_LINE results = [ pool . apply_async ( solve , parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT inp . close ( ) NEW_LINE out = open ( FILE_NAME_BASE + ' . out ' , ' w ' ) NEW_LINE for case , result in enumerate ( results ) : NEW_LINE INDENT value = result if NUM_PROCESSES == 0 else result . get ( ) NEW_LINE out . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( case + 1 , value ) ) NEW_LINE out . flush ( ) NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["parse", "def parse ( inp ) : NEW_LINE INDENT start , num = ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE motes = tuple ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE assert len ( motes ) == num NEW_LINE return start , motes NEW_LINE DEDENT"], ["solve", "def solve ( start , motes ) : NEW_LINE INDENT motes = sorted ( motes ) NEW_LINE num = len ( motes ) NEW_LINE best = num NEW_LINE size = start NEW_LINE added = 0 NEW_LINE i = 0 NEW_LINE while i < num : NEW_LINE INDENT if motes [ i ] < size : NEW_LINE INDENT size += motes [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT best = min ( best , added + num - i ) NEW_LINE if size <= 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT while motes [ i ] - size >= 0 : NEW_LINE INDENT size += size - 1 NEW_LINE added += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT best = min ( best , added ) NEW_LINE DEDENT return best NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT import sys NEW_LINE sys . setrecursionlimit ( RECURSION_LIMIT ) NEW_LINE import resource NEW_LINE soft , hard = resource . getrlimit ( resource . RLIMIT_AS ) NEW_LINE resource . setrlimit ( resource . RLIMIT_AS , ( MEM_LIMIT_GB * 1024 ** 3 , hard ) ) NEW_LINE inp = open ( FILE_NAME_BASE + ' . in ' , ' r ' ) NEW_LINE numCases = int ( inp . readline ( ) ) NEW_LINE if NUM_PROCESSES == 0 : NEW_LINE INDENT results = [ solve ( * parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT else : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE pool = Pool ( NUM_PROCESSES ) NEW_LINE results = [ pool . apply_async ( solve , parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT inp . close ( ) NEW_LINE out = open ( FILE_NAME_BASE + ' . out ' , ' w ' ) NEW_LINE for case , result in enumerate ( results ) : NEW_LINE INDENT value = result if NUM_PROCESSES == 0 else result . get ( ) NEW_LINE out . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( case + 1 , value ) ) NEW_LINE out . flush ( ) NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "7", "code": "import sys NEW_LINE fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT A , N = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE motes = list ( map ( int , fin . readline ( ) . split ( ) ) ) NEW_LINE limit = len ( motes ) NEW_LINE limit1 = limit + 1 NEW_LINE motes . sort ( ) NEW_LINE last = [ 0 ] * limit1 NEW_LINE last [ 0 ] = A NEW_LINE for mote in motes : NEW_LINE INDENT current = [ 0 ] * limit1 NEW_LINE for used , size in enumerate ( last ) : NEW_LINE INDENT newsize = size NEW_LINE for moves in range ( used , limit1 ) : NEW_LINE INDENT if newsize > mote : NEW_LINE INDENT current [ moves ] = max ( current [ moves ] , newsize + mote ) NEW_LINE DEDENT newsize = newsize * 2 - 1 NEW_LINE DEDENT if used < limit : NEW_LINE INDENT current [ used + 1 ] = max ( current [ used + 1 ] , size ) NEW_LINE DEDENT DEDENT last = current NEW_LINE DEDENT best = None NEW_LINE for used , size in enumerate ( last ) : NEW_LINE INDENT if size > 0 : NEW_LINE INDENT best = used NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , best ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "12", "code": "fin = open ( \" A - large . in \" ) NEW_LINE fout = open ( \" A . out \" , ' w ' ) NEW_LINE numtests = int ( fin . readline ( ) ) NEW_LINE for cas in xrange ( 1 , numtests + 1 ) : NEW_LINE INDENT fout . write ( \" Case \u2581 # \" + str ( cas ) + \" : \u2581 \" ) NEW_LINE a , n = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE s = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE s . sort ( ) NEW_LINE cost = [ 0 for i in xrange ( n + 1 ) ] NEW_LINE if a == 1 : NEW_LINE INDENT fout . write ( str ( n ) + \" \\n \" ) NEW_LINE continue NEW_LINE DEDENT for i in xrange ( n ) : NEW_LINE INDENT cost [ i + 1 ] = cost [ i ] NEW_LINE if ( s [ i ] < a ) : NEW_LINE INDENT a += s [ i ] NEW_LINE continue NEW_LINE DEDENT while ( a <= s [ i ] ) : NEW_LINE INDENT a = 2 * a - 1 NEW_LINE cost [ i + 1 ] += 1 NEW_LINE DEDENT a += s [ i ] NEW_LINE DEDENT t = [ cost [ i ] + ( n - i ) for i in xrange ( n + 1 ) ] NEW_LINE fout . write ( str ( min ( t ) ) + \" \\n \" ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "16", "code": "def getLine ( filename ) : NEW_LINE INDENT inputFile = open ( filename , ' r ' ) NEW_LINE for line in inputFile : NEW_LINE INDENT yield line NEW_LINE DEDENT inputFile . close ( ) NEW_LINE DEDENT inputFilename = ' A - large . in ' NEW_LINE outputFilename = ' A - large . txt ' NEW_LINE tokenIterator = getLine ( inputFilename ) NEW_LINE def get ( ) : return tokenIterator . next ( ) NEW_LINE def getint ( ) : return int ( get ( ) ) NEW_LINE outputFile = open ( outputFilename , ' w ' ) NEW_LINE caseNum = getint ( ) NEW_LINE for case in range ( caseNum ) : NEW_LINE INDENT tmp = get ( ) . split ( ) NEW_LINE a = int ( tmp [ 0 ] ) NEW_LINE n = int ( tmp [ 1 ] ) NEW_LINE tmp = get ( ) NEW_LINE x = [ int ( tmpi ) for tmpi in tmp . split ( ) ] NEW_LINE x . sort ( ) NEW_LINE ans = n NEW_LINE cnt = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if x [ i ] < a : NEW_LINE INDENT a += x [ i ] NEW_LINE DEDENT elif a == 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT while x [ i ] >= a : NEW_LINE INDENT a += a - 1 NEW_LINE cnt += 1 NEW_LINE DEDENT a += x [ i ] NEW_LINE DEDENT if ans > cnt + ( n - i - 1 ) : NEW_LINE INDENT ans = cnt + ( n - i - 1 ) NEW_LINE DEDENT DEDENT output = \" Case \u2581 # \" + str ( case + 1 ) + \" : \u2581 \" + str ( ans ) NEW_LINE outputFile . write ( output + \" \\n \" ) NEW_LINE DEDENT outputFile . close ( ) NEW_LINE", "functions_standalone": [["getLine", "def getLine ( filename ) : NEW_LINE INDENT inputFile = open ( filename , ' r ' ) NEW_LINE for line in inputFile : NEW_LINE INDENT yield line NEW_LINE DEDENT inputFile . close ( ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "import sys NEW_LINE def emit ( text , * args ) : NEW_LINE INDENT msg = text % args NEW_LINE sys . stderr . write ( msg ) NEW_LINE sys . stdout . write ( msg ) NEW_LINE DEDENT def solve ( moteA , motes ) : NEW_LINE INDENT while motes and moteA > motes [ 0 ] : NEW_LINE INDENT moteA += motes [ 0 ] NEW_LINE del motes [ 0 ] NEW_LINE DEDENT solve_by_del = len ( motes ) NEW_LINE if moteA == 1 or solve_by_del <= 1 : NEW_LINE INDENT return solve_by_del NEW_LINE DEDENT solve_by_add = 1 + solve ( moteA + moteA - 1 , motes ) NEW_LINE return min ( solve_by_del , solve_by_add ) NEW_LINE DEDENT def getline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT ncases = int ( getline ( ) ) NEW_LINE for casenr in range ( 1 , ncases + 1 ) : NEW_LINE INDENT moteA , nmotes = [ int ( s ) for s in getline ( ) . split ( ) ] NEW_LINE motes = [ int ( s ) for s in getline ( ) . split ( ) ] NEW_LINE motes . sort ( ) NEW_LINE emit ( \" Case \u2581 # % d : \u2581 % s \\n \" , casenr , solve ( moteA , motes ) ) NEW_LINE DEDENT", "functions_standalone": [["emit", "def emit ( text , * args ) : NEW_LINE INDENT msg = text % args NEW_LINE sys . stderr . write ( msg ) NEW_LINE sys . stdout . write ( msg ) NEW_LINE DEDENT"], ["solve", "def solve ( moteA , motes ) : NEW_LINE INDENT while motes and moteA > motes [ 0 ] : NEW_LINE INDENT moteA += motes [ 0 ] NEW_LINE del motes [ 0 ] NEW_LINE DEDENT solve_by_del = len ( motes ) NEW_LINE if moteA == 1 or solve_by_del <= 1 : NEW_LINE INDENT return solve_by_del NEW_LINE DEDENT solve_by_add = 1 + solve ( moteA + moteA - 1 , motes ) NEW_LINE return min ( solve_by_del , solve_by_add ) NEW_LINE DEDENT"], ["getline", "def getline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_31", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; public class A { static class Assert { static void check ( boolean e ) { if ( ! e ) { throw new Error ( ) ; } } } Scanner in ; PrintWriter out ; boolean isCons ( char c ) { return c != ' a ' && c != ' e ' && c != ' i ' && c != ' o ' && c != ' u ' ; } int getPos ( String word , int n , int from ) { int count = 0 ; for ( int i = from ; i < word . length ( ) ; i ++ ) { if ( isCons ( word . charAt ( i ) ) ) { count ++ ; if ( count == n ) { return i ; } } else { count = 0 ; } } return - 1 ; } long solveOne ( String word , int n ) { long count = 0 ; int pos = getPos ( word , n , 0 ) ; if ( pos == - 1 ) { return count ; } count += word . length ( ) - pos ; for ( int start = 1 ; start < word . length ( ) ; start ++ ) { if ( pos - start + 1 >= n ) { } else { Assert . check ( pos - start + 1 == n - 1 ) ; if ( pos == word . length ( ) - 1 ) { return count ; } if ( isCons ( word . charAt ( pos + 1 ) ) ) { pos ++ ; } else { pos = getPos ( word , n , pos + 2 ) ; if ( pos == - 1 ) { return count ; } } } count += word . length ( ) - pos ; } return count ; } void solve ( ) { int nTests = in . nextInt ( ) ; for ( int i = 1 ; i <= nTests ; i ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , i , solveOne ( in . next ( ) , in . nextInt ( ) ) ) ; } } void run ( ) { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; try { solve ( ) ; } finally { out . close ( ) ; } } public static void main ( String args [ ] ) { new A ( ) . run ( ) ; } }", "functions_standalone": [["check", "static void check ( boolean e ) { if ( ! e ) { throw new Error ( ) ; } }"], ["main", "public static void main ( String args [ ] ) { new A ( ) . run ( ) ; }"]], "functions_class": [["isCons", "boolean isCons ( char c ) { return c != ' a ' && c != ' e ' && c != ' i ' && c != ' o ' && c != ' u ' ; }"], ["getPos", "int getPos ( String word , int n , int from ) { int count = 0 ; for ( int i = from ; i < word . length ( ) ; i ++ ) { if ( isCons ( word . charAt ( i ) ) ) { count ++ ; if ( count == n ) { return i ; } } else { count = 0 ; } } return - 1 ; }"], ["solveOne", "long solveOne ( String word , int n ) { long count = 0 ; int pos = getPos ( word , n , 0 ) ; if ( pos == - 1 ) { return count ; } count += word . length ( ) - pos ; for ( int start = 1 ; start < word . length ( ) ; start ++ ) { if ( pos - start + 1 >= n ) { } else { Assert . check ( pos - start + 1 == n - 1 ) ; if ( pos == word . length ( ) - 1 ) { return count ; } if ( isCons ( word . charAt ( pos + 1 ) ) ) { pos ++ ; } else { pos = getPos ( word , n , pos + 2 ) ; if ( pos == - 1 ) { return count ; } } } count += word . length ( ) - pos ; } return count ; }"], ["solve", "void solve ( ) { int nTests = in . nextInt ( ) ; for ( int i = 1 ; i <= nTests ; i ++ ) { out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , i , solveOne ( in . next ( ) , in . nextInt ( ) ) ) ; } }"], ["run", "void run ( ) { in = new Scanner ( System . in ) ; out = new PrintWriter ( System . out ) ; try { solve ( ) ; } finally { out . close ( ) ; } }"]]}, {"id": "4", "code": "import java . io . File ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . util . Scanner ; public class GCJ_2013_C1 { public static long solve ( String s , long n ) { long bef_cont = 0 ; long bef_noncont = 0 ; long endpart = 0 ; System . out . println ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { long bef_cont_prev = bef_cont ; long bef_noncont_prev = bef_noncont ; char c = s . charAt ( i ) ; boolean cns = ! ( ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ) ; bef_noncont = bef_noncont_prev + bef_cont_prev ; if ( cns ) { endpart ++ ; if ( endpart >= n ) { bef_cont = ( i - n + 2 ) ; } else { bef_cont = bef_cont_prev ; } } else { bef_cont = bef_cont_prev ; endpart = 0 ; } } return bef_cont + bef_noncont ; } public static void main ( String [ ] args ) throws Exception { String fname = \" A _ large \" ; File file = new File ( fname + \" _ in . txt \" ) ; Scanner scanner = new Scanner ( file ) ; FileWriter outFile = new FileWriter ( fname + \" _ out . txt \" ) ; PrintWriter outp = new PrintWriter ( outFile ) ; int T = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { String s = scanner . nextLine ( ) ; String sin = s . split ( \" \u2581 \" ) [ 0 ] ; int n = Integer . parseInt ( s . split ( \" \u2581 \" ) [ 1 ] ) ; outp . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , i , solve ( sin , n ) ) ; } outp . close ( ) ; } }", "functions_standalone": [["solve", "public static long solve ( String s , long n ) { long bef_cont = 0 ; long bef_noncont = 0 ; long endpart = 0 ; System . out . println ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { long bef_cont_prev = bef_cont ; long bef_noncont_prev = bef_noncont ; char c = s . charAt ( i ) ; boolean cns = ! ( ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ) ; bef_noncont = bef_noncont_prev + bef_cont_prev ; if ( cns ) { endpart ++ ; if ( endpart >= n ) { bef_cont = ( i - n + 2 ) ; } else { bef_cont = bef_cont_prev ; } } else { bef_cont = bef_cont_prev ; endpart = 0 ; } } return bef_cont + bef_noncont ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { String fname = \" A _ large \" ; File file = new File ( fname + \" _ in . txt \" ) ; Scanner scanner = new Scanner ( file ) ; FileWriter outFile = new FileWriter ( fname + \" _ out . txt \" ) ; PrintWriter outp = new PrintWriter ( outFile ) ; int T = scanner . nextInt ( ) ; scanner . nextLine ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { String s = scanner . nextLine ( ) ; String sin = s . split ( \" \u2581 \" ) [ 0 ] ; int n = Integer . parseInt ( s . split ( \" \u2581 \" ) [ 1 ] ) ; outp . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , i , solve ( sin , n ) ) ; } outp . close ( ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; public class A { static long result ( String name , int n ) { int len = name . length ( ) ; boolean hasPrev = false ; int curr = 0 ; int prevStart = 0 ; long res = 0 ; int pos = 0 ; while ( pos < len ) { boolean is = \" aeiou \" . indexOf ( name . charAt ( pos ++ ) ) < 0 ; if ( is ) { curr ++ ; if ( curr >= n ) { hasPrev = true ; prevStart = pos - n ; res += 1 + pos - n ; continue ; } } else { curr = 0 ; } if ( hasPrev ) { res += 1 + prevStart ; } } return res ; } static void go ( String inputFile ) throws Exception { LineNumberReader in = new LineNumberReader ( new FileReader ( inputFile ) ) ; FileWriter out = new FileWriter ( inputFile + \" . out \" ) ; int nCases = Integer . parseInt ( in . readLine ( ) ) ; for ( int c = 1 ; c <= nCases ; c ++ ) { String [ ] tmp = in . readLine ( ) . split ( \" \u2581 \" ) ; long res = result ( tmp [ 0 ] , Integer . parseInt ( tmp [ 1 ] ) ) ; String line = \" Case \u2581 # \" + c + \" : \u2581 \" + res ; System . out . println ( line ) ; out . write ( line + \" \\n \" ) ; } out . close ( ) ; } public static void main ( String [ ] args ) throws Exception { LineNumberReader sysIn = new LineNumberReader ( new InputStreamReader ( System . in ) ) ; String line ; while ( ( line = sysIn . readLine ( ) ) != null ) { go ( line . trim ( ) ) ; } } }", "functions_standalone": [["result", "static long result ( String name , int n ) { int len = name . length ( ) ; boolean hasPrev = false ; int curr = 0 ; int prevStart = 0 ; long res = 0 ; int pos = 0 ; while ( pos < len ) { boolean is = \" aeiou \" . indexOf ( name . charAt ( pos ++ ) ) < 0 ; if ( is ) { curr ++ ; if ( curr >= n ) { hasPrev = true ; prevStart = pos - n ; res += 1 + pos - n ; continue ; } } else { curr = 0 ; } if ( hasPrev ) { res += 1 + prevStart ; } } return res ; }"], ["go", "static void go ( String inputFile ) throws Exception { LineNumberReader in = new LineNumberReader ( new FileReader ( inputFile ) ) ; FileWriter out = new FileWriter ( inputFile + \" . out \" ) ; int nCases = Integer . parseInt ( in . readLine ( ) ) ; for ( int c = 1 ; c <= nCases ; c ++ ) { String [ ] tmp = in . readLine ( ) . split ( \" \u2581 \" ) ; long res = result ( tmp [ 0 ] , Integer . parseInt ( tmp [ 1 ] ) ) ; String line = \" Case \u2581 # \" + c + \" : \u2581 \" + res ; System . out . println ( line ) ; out . write ( line + \" \\n \" ) ; } out . close ( ) ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { LineNumberReader sysIn = new LineNumberReader ( new InputStreamReader ( System . in ) ) ; String line ; while ( ( line = sysIn . readLine ( ) ) != null ) { go ( line . trim ( ) ) ; } }"]], "functions_class": []}, {"id": "14", "code": "import java . io . * ; import java . util . * ; public class Round1C_2013_A { private static void jam ( String inFile , String outFile ) throws Exception { BufferedReader brIn = new BufferedReader ( new FileReader ( inFile ) ) ; BufferedWriter bwOut = new BufferedWriter ( new FileWriter ( outFile ) ) ; String sLine ; int ca = 1 ; brIn . readLine ( ) ; int [ ] starts = new int [ 1000000 ] ; int [ ] ends = new int [ 1000000 ] ; while ( ( sLine = brIn . readLine ( ) ) != null ) { String [ ] fields = sLine . split ( \" \u2581 \" ) ; if ( fields . length != 2 ) { System . out . println ( \" skipping \u2581 mis - parse : \u2581 \" + sLine ) ; continue ; } String s = fields [ 0 ] ; int n = Integer . parseInt ( fields [ 1 ] ) ; int numSets = 0 ; int seqNum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c != ' a ' && c != ' e ' && c != ' i ' && c != ' o ' && c != ' u ' ) { seqNum ++ ; if ( seqNum >= n ) { starts [ numSets ] = i + 1 - n ; ends [ numSets ] = i + 1 ; numSets ++ ; } } else { seqNum = 0 ; } } int lastStart = - 1 ; long sum = 0 ; for ( int i = 0 ; i < numSets ; i ++ ) { int choicesLeft = starts [ i ] - lastStart ; int choicesRight = 1 + s . length ( ) - ends [ i ] ; sum += ( long ) choicesLeft * ( long ) choicesRight ; lastStart = starts [ i ] ; } String msg = \" \" + sum ; System . out . println ( \" \" + s . length ( ) ) ; bwOut . write ( \" Case \u2581 # \" + ca + \" : \u2581 \" + msg + \" \\r \\n \" ) ; ca ++ ; } brIn . close ( ) ; bwOut . close ( ) ; } public static void main ( String [ ] args ) throws Exception { jam ( args [ 0 ] , args [ 1 ] ) ; } }", "functions_standalone": [["jam", "private static void jam ( String inFile , String outFile ) throws Exception { BufferedReader brIn = new BufferedReader ( new FileReader ( inFile ) ) ; BufferedWriter bwOut = new BufferedWriter ( new FileWriter ( outFile ) ) ; String sLine ; int ca = 1 ; brIn . readLine ( ) ; int [ ] starts = new int [ 1000000 ] ; int [ ] ends = new int [ 1000000 ] ; while ( ( sLine = brIn . readLine ( ) ) != null ) { String [ ] fields = sLine . split ( \" \u2581 \" ) ; if ( fields . length != 2 ) { System . out . println ( \" skipping \u2581 mis - parse : \u2581 \" + sLine ) ; continue ; } String s = fields [ 0 ] ; int n = Integer . parseInt ( fields [ 1 ] ) ; int numSets = 0 ; int seqNum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c != ' a ' && c != ' e ' && c != ' i ' && c != ' o ' && c != ' u ' ) { seqNum ++ ; if ( seqNum >= n ) { starts [ numSets ] = i + 1 - n ; ends [ numSets ] = i + 1 ; numSets ++ ; } } else { seqNum = 0 ; } } int lastStart = - 1 ; long sum = 0 ; for ( int i = 0 ; i < numSets ; i ++ ) { int choicesLeft = starts [ i ] - lastStart ; int choicesRight = 1 + s . length ( ) - ends [ i ] ; sum += ( long ) choicesLeft * ( long ) choicesRight ; lastStart = starts [ i ] ; } String msg = \" \" + sum ; System . out . println ( \" \" + s . length ( ) ) ; bwOut . write ( \" Case \u2581 # \" + ca + \" : \u2581 \" + msg + \" \\r \\n \" ) ; ca ++ ; } brIn . close ( ) ; bwOut . close ( ) ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { jam ( args [ 0 ] , args [ 1 ] ) ; }"]], "functions_class": []}, {"id": "7", "code": "import java . awt . * ; import java . awt . event . * ; import java . awt . geom . * ; import java . io . * ; import java . math . * ; import java . text . * ; import java . util . * ; public class A { static BufferedReader br ; static StringTokenizer st ; static PrintWriter pw ; public static void main ( String [ ] args ) throws IOException { br = new BufferedReader ( new FileReader ( \" a . in \" ) ) ; pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" a . out \" ) ) ) ; final int MAX_CASES = readInt ( ) ; String vowel = \" aeiou \" ; for ( int casenum = 1 ; casenum <= MAX_CASES ; casenum ++ ) { pw . printf ( \" Case \u2581 # % d : \u2581 \" , casenum ) ; String str = nextToken ( ) ; int count = readInt ( ) ; long ret = 0 ; int curr = 0 ; int lastStart = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( vowel . indexOf ( str . charAt ( i ) + \" \" ) == - 1 ) { curr ++ ; } else { curr = 0 ; } if ( curr >= count ) { int begin = i - count + 1 ; int goAfter = i ; ret += ( begin - lastStart ) * 1L * ( str . length ( ) - goAfter ) ; lastStart = begin ; } } pw . println ( ret ) ; } pw . close ( ) ; } public static int readInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } public static long readLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } public static double readDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; } public static String nextToken ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { if ( ! br . ready ( ) ) { pw . close ( ) ; System . exit ( 0 ) ; } st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; } public static String readLine ( ) throws IOException { st = null ; return br . readLine ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { br = new BufferedReader ( new FileReader ( \" a . in \" ) ) ; pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( \" a . out \" ) ) ) ; final int MAX_CASES = readInt ( ) ; String vowel = \" aeiou \" ; for ( int casenum = 1 ; casenum <= MAX_CASES ; casenum ++ ) { pw . printf ( \" Case \u2581 # % d : \u2581 \" , casenum ) ; String str = nextToken ( ) ; int count = readInt ( ) ; long ret = 0 ; int curr = 0 ; int lastStart = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( vowel . indexOf ( str . charAt ( i ) + \" \" ) == - 1 ) { curr ++ ; } else { curr = 0 ; } if ( curr >= count ) { int begin = i - count + 1 ; int goAfter = i ; ret += ( begin - lastStart ) * 1L * ( str . length ( ) - goAfter ) ; lastStart = begin ; } } pw . println ( ret ) ; } pw . close ( ) ; }"], ["readInt", "public static int readInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }"], ["readLong", "public static long readLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; }"], ["readDouble", "public static double readDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; }"], ["nextToken", "public static String nextToken ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { if ( ! br . ready ( ) ) { pw . close ( ) ; System . exit ( 0 ) ; } st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; }"], ["readLine", "public static String readLine ( ) throws IOException { st = null ; return br . readLine ( ) ; }"]], "functions_class": []}], "python": [{"id": "20", "code": "import argparse NEW_LINE import collections NEW_LINE import fractions NEW_LINE import functools NEW_LINE import itertools NEW_LINE import math NEW_LINE import operator NEW_LINE from sys import exit , stdin NEW_LINE from multiprocessing import Pool NEW_LINE def solve_star ( args ) : NEW_LINE INDENT return solve ( * args ) NEW_LINE DEDENT def read_int ( ) : NEW_LINE INDENT return int ( stdin . readline ( ) . strip ( ) ) NEW_LINE DEDENT def read_ints ( ) : NEW_LINE INDENT return [ int ( n ) for n in stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT def read_words ( ) : NEW_LINE INDENT return stdin . readline ( ) . strip ( ) NEW_LINE DEDENT def parse ( ) : NEW_LINE INDENT name , n = read_words ( ) . split ( ) NEW_LINE return [ name , int ( n ) ] NEW_LINE DEDENT def solve ( name , n ) : NEW_LINE INDENT vowels = [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] NEW_LINE count = 0 NEW_LINE last = 0 NEW_LINE total = 0 NEW_LINE for e , c in enumerate ( name ) : NEW_LINE INDENT if c in vowels : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE if count == n : NEW_LINE INDENT this_string_starts = e - ( n - 1 ) NEW_LINE total += ( this_string_starts - last + 1 ) * ( len ( name ) - e ) NEW_LINE last = this_string_starts + 1 NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT parser = argparse . ArgumentParser ( ) NEW_LINE parser . add_argument ( \" - m \" , \" - - multi \" , help = \" turn \u2581 on \u2581 multiprocessing \" , action = \" store _ true \" ) NEW_LINE args = parser . parse_args ( ) NEW_LINE with open ( \" out . txt \" , \" w \" ) as f : NEW_LINE INDENT if args . multi : NEW_LINE INDENT pool = Pool ( ) NEW_LINE iter = pool . imap ( solve_star , ( parse ( ) for i in range ( read_int ( ) ) ) ) NEW_LINE for i , result in enumerate ( iter ) : NEW_LINE INDENT s = \" Case \u2581 # { } : \u2581 { } \" . format ( i + 1 , result ) NEW_LINE print ( s ) NEW_LINE f . write ( s + \" \\n \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( read_int ( ) ) : NEW_LINE INDENT s = \" Case \u2581 # { } : \u2581 { } \" . format ( i + 1 , solve ( * parse ( ) ) ) NEW_LINE print ( s ) NEW_LINE f . write ( s + \" \\n \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [["solve_star", "def solve_star ( args ) : NEW_LINE INDENT return solve ( * args ) NEW_LINE DEDENT"], ["read_int", "def read_int ( ) : NEW_LINE INDENT return int ( stdin . readline ( ) . strip ( ) ) NEW_LINE DEDENT"], ["read_ints", "def read_ints ( ) : NEW_LINE INDENT return [ int ( n ) for n in stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT"], ["read_words", "def read_words ( ) : NEW_LINE INDENT return stdin . readline ( ) . strip ( ) NEW_LINE DEDENT"], ["parse", "def parse ( ) : NEW_LINE INDENT name , n = read_words ( ) . split ( ) NEW_LINE return [ name , int ( n ) ] NEW_LINE DEDENT"], ["solve", "def solve ( name , n ) : NEW_LINE INDENT vowels = [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] NEW_LINE count = 0 NEW_LINE last = 0 NEW_LINE total = 0 NEW_LINE for e , c in enumerate ( name ) : NEW_LINE INDENT if c in vowels : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE if count == n : NEW_LINE INDENT this_string_starts = e - ( n - 1 ) NEW_LINE total += ( this_string_starts - last + 1 ) * ( len ( name ) - e ) NEW_LINE last = this_string_starts + 1 NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT DEDENT return total NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import math , os , sys , random NEW_LINE vowels = ' aeiou ' NEW_LINE consonants = ' bcdfghjklmnpqrstvwxyz ' NEW_LINE vowels_set = frozenset ( vowels ) NEW_LINE consonants_set = frozenset ( consonants ) NEW_LINE def single_test ( IN , OUT ) : NEW_LINE INDENT name , n = IN . readline ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE L = len ( name ) NEW_LINE data = ' ' NEW_LINE for l in name : data += ' v ' if l in vowels_set else ' c ' NEW_LINE starts = [ ] NEW_LINE count = 0 NEW_LINE for i , l in enumerate ( data ) : NEW_LINE INDENT if l == ' v ' : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE if count >= n : NEW_LINE INDENT starts . append ( i + 1 - n ) NEW_LINE DEDENT DEDENT DEDENT freespaces = [ ] NEW_LINE cs = 0 NEW_LINE for i in range ( L ) : NEW_LINE INDENT while cs != - 1 and cs < len ( starts ) and i > starts [ cs ] : NEW_LINE INDENT cs += 1 NEW_LINE DEDENT if cs == len ( starts ) : NEW_LINE INDENT cs = - 1 NEW_LINE DEDENT if cs == - 1 : NEW_LINE INDENT if i < L : freespaces . append ( ( i , L - i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if starts [ cs ] + n - 1 > i : freespaces . append ( ( i , starts [ cs ] + n - 1 - i ) ) NEW_LINE DEDENT DEDENT result = ( L * ( L + 1 ) ) // 2 NEW_LINE for f in freespaces : NEW_LINE INDENT result -= f [ 1 ] NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( IN , OUT ) : NEW_LINE INDENT T = int ( IN . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT OUT . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( i , single_test ( IN , OUT ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT assert len ( sys . argv ) == 2 NEW_LINE IN = open ( sys . argv [ 1 ] , ' rt ' ) NEW_LINE OUT = open ( ' % s . out ' % sys . argv [ 1 ] [ : - 3 ] , ' wt ' ) NEW_LINE main ( IN , OUT ) NEW_LINE OUT . close ( ) NEW_LINE IN . close ( ) NEW_LINE DEDENT", "functions_standalone": [["single_test", "def single_test ( IN , OUT ) : NEW_LINE INDENT name , n = IN . readline ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE L = len ( name ) NEW_LINE data = ' ' NEW_LINE for l in name : data += ' v ' if l in vowels_set else ' c ' NEW_LINE starts = [ ] NEW_LINE count = 0 NEW_LINE for i , l in enumerate ( data ) : NEW_LINE INDENT if l == ' v ' : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE if count >= n : NEW_LINE INDENT starts . append ( i + 1 - n ) NEW_LINE DEDENT DEDENT DEDENT freespaces = [ ] NEW_LINE cs = 0 NEW_LINE for i in range ( L ) : NEW_LINE INDENT while cs != - 1 and cs < len ( starts ) and i > starts [ cs ] : NEW_LINE INDENT cs += 1 NEW_LINE DEDENT if cs == len ( starts ) : NEW_LINE INDENT cs = - 1 NEW_LINE DEDENT if cs == - 1 : NEW_LINE INDENT if i < L : freespaces . append ( ( i , L - i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if starts [ cs ] + n - 1 > i : freespaces . append ( ( i , starts [ cs ] + n - 1 - i ) ) NEW_LINE DEDENT DEDENT result = ( L * ( L + 1 ) ) // 2 NEW_LINE for f in freespaces : NEW_LINE INDENT result -= f [ 1 ] NEW_LINE DEDENT return result NEW_LINE DEDENT"], ["main", "def main ( IN , OUT ) : NEW_LINE INDENT T = int ( IN . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT OUT . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( i , single_test ( IN , OUT ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "4", "code": "def puts ( s ) : NEW_LINE INDENT print ( s , end = ' ' ) NEW_LINE DEDENT vowels = \" aeiou \" NEW_LINE def solve ( case ) : NEW_LINE INDENT S , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE streak = 0 NEW_LINE cons = [ ] NEW_LINE for c in S : NEW_LINE INDENT if c in vowels : NEW_LINE INDENT streak = 0 NEW_LINE DEDENT else : NEW_LINE INDENT streak += 1 NEW_LINE DEDENT cons += [ streak ] NEW_LINE DEDENT count = 0 NEW_LINE m = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if cons [ i ] >= n : NEW_LINE INDENT m = i + 2 - n NEW_LINE DEDENT count += m NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT for case in range ( 1 , 1 + int ( input ( ) ) ) : NEW_LINE INDENT puts ( \" Case \u2581 # \" + str ( case ) + \" : \u2581 \" ) NEW_LINE solve ( case ) NEW_LINE DEDENT", "functions_standalone": [["puts", "def puts ( s ) : NEW_LINE INDENT print ( s , end = ' ' ) NEW_LINE DEDENT"], ["solve", "def solve ( case ) : NEW_LINE INDENT S , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE streak = 0 NEW_LINE cons = [ ] NEW_LINE for c in S : NEW_LINE INDENT if c in vowels : NEW_LINE INDENT streak = 0 NEW_LINE DEDENT else : NEW_LINE INDENT streak += 1 NEW_LINE DEDENT cons += [ streak ] NEW_LINE DEDENT count = 0 NEW_LINE m = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if cons [ i ] >= n : NEW_LINE INDENT m = i + 2 - n NEW_LINE DEDENT count += m NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "vowels = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE T = int ( input ( ) ) NEW_LINE for TT in range ( 1 , T + 1 ) : NEW_LINE INDENT s , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE ans = 0 NEW_LINE current = 0 NEW_LINE count = 0 NEW_LINE length = len ( s ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if s [ i ] in vowels : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT count -= 1 NEW_LINE ans += ( i - n + 2 - current ) * ( length - i ) NEW_LINE current = i - n + 2 NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # \" + str ( TT ) + \" : \u2581 \" + str ( ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "16", "code": "t = int ( raw_input ( ) ) NEW_LINE def vowel ( c ) : NEW_LINE INDENT return c in ' aeiou ' NEW_LINE DEDENT for kei in xrange ( t ) : NEW_LINE INDENT name , n = raw_input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE ctr = 0 NEW_LINE cons = 0 NEW_LINE start = [ ] NEW_LINE m = - 1 NEW_LINE while i < len ( name ) : NEW_LINE INDENT if not vowel ( name [ i ] ) : NEW_LINE INDENT while j < len ( name ) and not vowel ( name [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT while j - i >= n : NEW_LINE INDENT start . append ( i ) NEW_LINE m = max ( m , i ) NEW_LINE i += 1 NEW_LINE DEDENT i = j NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j = i NEW_LINE DEDENT DEDENT ctr = 0 NEW_LINE j = 0 NEW_LINE for i in xrange ( len ( name ) ) : NEW_LINE INDENT while j < len ( start ) and start [ j ] < i : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j >= len ( start ) : NEW_LINE INDENT break NEW_LINE DEDENT ctr += len ( name ) - ( start [ j ] + n - 1 ) NEW_LINE DEDENT print ( ' Case \u2581 # % d : \u2581 % d ' % ( kei + 1 , ctr ) ) NEW_LINE DEDENT", "functions_standalone": [["vowel", "def vowel ( c ) : NEW_LINE INDENT return c in ' aeiou ' NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_54", "java": [{"id": "19", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Scanner ; import java . util . SortedSet ; import java . util . TreeSet ; public class ObservationWheel { static Scanner sc ; static PrintWriter out ; public static void main ( String [ ] args ) throws IOException { sc = new Scanner ( new FileReader ( \" D - small - attempt0 . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" D - small - attempt0 . out \" ) ) ; int testCases = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { out . println ( String . format ( \" Case \u2581 # % s : \u2581 % s \" , testCase , solveCase ( ) ) ) ; } out . close ( ) ; } static double solveCase ( ) { String bits = sc . next ( ) ; N = bits . length ( ) ; memo = new double [ 1 << N ] ; Arrays . fill ( memo , - 1.0 ) ; int init = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( bits . charAt ( i ) == ' X ' ) init |= 1 << i ; return solve ( init ) ; } static double solve ( int mask ) { if ( mask == ( 1 << N ) - 1 ) { return 0 ; } if ( memo [ mask ] < - 0.5 ) { double res = 0.0 ; for ( int index = 0 ; index < N ; index ++ ) { for ( int wait = 0 ; wait < N ; wait ++ ) { int exactIndex = ( index + wait ) % N ; if ( ( mask >> exactIndex & 1 ) == 0 ) { res += ( N - wait + solve ( mask | 1 << exactIndex ) ) / N ; break ; } } } memo [ mask ] = res ; } return memo [ mask ] ; } static double [ ] memo ; static int N ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { sc = new Scanner ( new FileReader ( \" D - small - attempt0 . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" D - small - attempt0 . out \" ) ) ; int testCases = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { out . println ( String . format ( \" Case \u2581 # % s : \u2581 % s \" , testCase , solveCase ( ) ) ) ; } out . close ( ) ; }"], ["solveCase", "static double solveCase ( ) { String bits = sc . next ( ) ; N = bits . length ( ) ; memo = new double [ 1 << N ] ; Arrays . fill ( memo , - 1.0 ) ; int init = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( bits . charAt ( i ) == ' X ' ) init |= 1 << i ; return solve ( init ) ; }"], ["solve", "static double solve ( int mask ) { if ( mask == ( 1 << N ) - 1 ) { return 0 ; } if ( memo [ mask ] < - 0.5 ) { double res = 0.0 ; for ( int index = 0 ; index < N ; index ++ ) { for ( int wait = 0 ; wait < N ; wait ++ ) { int exactIndex = ( index + wait ) % N ; if ( ( mask >> exactIndex & 1 ) == 0 ) { res += ( N - wait + solve ( mask | 1 << exactIndex ) ) / N ; break ; } } } memo [ mask ] = res ; } return memo [ mask ] ; }"]], "functions_class": []}, {"id": "7", "code": "import java . util . * ; public class D { static boolean bit_set ( int set , int bit ) { return ( ( set >>> bit ) & 1 ) == 1 ; } static Double [ ] [ ] DP = new Double [ 21 ] [ 1 << 20 ] ; static double f ( int n , int used ) { if ( used == ( 1 << n ) - 1 ) return 0 ; if ( DP [ n ] [ used ] != null ) return DP [ n ] [ used ] ; double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int nxt = i ; int money = n ; while ( bit_set ( used , nxt ) ) { nxt = ( nxt + 1 ) % n ; money -- ; } ans += 1.0 / n * ( money + f ( n , used | 1 << nxt ) ) ; } return DP [ n ] [ used ] = ans ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { char [ ] S = in . next ( ) . toCharArray ( ) ; int used = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) if ( S [ i ] == ' X ' ) used |= 1 << i ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .10f \\n \" , cas , f ( S . length , used ) ) ; } } }", "functions_standalone": [["bit_set", "static boolean bit_set ( int set , int bit ) { return ( ( set >>> bit ) & 1 ) == 1 ; }"], ["f", "static double f ( int n , int used ) { if ( used == ( 1 << n ) - 1 ) return 0 ; if ( DP [ n ] [ used ] != null ) return DP [ n ] [ used ] ; double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int nxt = i ; int money = n ; while ( bit_set ( used , nxt ) ) { nxt = ( nxt + 1 ) % n ; money -- ; } ans += 1.0 / n * ( money + f ( n , used | 1 << nxt ) ) ; } return DP [ n ] [ used ] = ans ; }"], ["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { char [ ] S = in . next ( ) . toCharArray ( ) ; int used = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) if ( S [ i ] == ' X ' ) used |= 1 << i ; System . out . printf ( \" Case \u2581 # % d : \u2581 % .10f \\n \" , cas , f ( S . length , used ) ) ; } }"]], "functions_class": []}, {"id": "15", "code": "import java . io . * ; import java . util . * ; public class D { private static String fileName = D . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) . toLowerCase ( ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; private static Scanner in ; private static PrintWriter out ; private void solve ( ) { String s = in . next ( ) ; int n = s . length ( ) ; int init = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' . ' ) { init |= 1 << i ; } } double [ ] a = new double [ 1 << n ] ; for ( int mask = 1 ; mask <= init ; mask ++ ) { for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; int k = i ; for ( ; ; ) { if ( ( ( mask >> k ) & 1 ) == 1 ) { break ; } j ++ ; k ++ ; if ( k == n ) { k = 0 ; } } int nm = mask ^ ( 1 << k ) ; a [ mask ] += ( n - j + a [ nm ] ) / n ; } } out . println ( a [ init ] ) ; } public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new File ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new D ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; if ( args . length >= 2 ) { inputFileName = args [ 0 ] ; outputFileName = args [ 1 ] ; } in = new Scanner ( new File ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new D ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( ) { String s = in . next ( ) ; int n = s . length ( ) ; int init = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' . ' ) { init |= 1 << i ; } } double [ ] a = new double [ 1 << n ] ; for ( int mask = 1 ; mask <= init ; mask ++ ) { for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; int k = i ; for ( ; ; ) { if ( ( ( mask >> k ) & 1 ) == 1 ) { break ; } j ++ ; k ++ ; if ( k == n ) { k = 0 ; } } int nm = mask ^ ( 1 << k ) ; a [ mask ] += ( n - j + a [ nm ] ) / n ; } } out . println ( a [ init ] ) ; }"]]}, {"id": "8", "code": "import static java . lang . Math . * ; import static java . util . Arrays . * ; import java . io . * ; import java . util . * ; public class D { Scanner sc = new Scanner ( System . in ) ; int N ; char [ ] oc ; void read ( ) { oc = sc . next ( ) . toCharArray ( ) ; N = oc . length ; } void solve ( ) { double [ ] dp = new double [ 1 << N ] ; for ( int i = ( 1 << N ) - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) if ( ( i >> ( ( j + k ) % N ) & 1 ) == 0 ) { dp [ i ] += ( dp [ i | 1 << ( ( j + k ) % N ) ] + N - k ) / N ; break ; } } } int r = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( oc [ i ] == ' X ' ) r |= 1 << i ; System . out . printf ( \" % .10f % n \" , dp [ r ] ) ; } void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( D . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new D ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( D . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new D ( ) . run ( ) ; }"]], "functions_class": [["read", "void read ( ) { oc = sc . next ( ) . toCharArray ( ) ; N = oc . length ; }"], ["solve", "void solve ( ) { double [ ] dp = new double [ 1 << N ] ; for ( int i = ( 1 << N ) - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) if ( ( i >> ( ( j + k ) % N ) & 1 ) == 0 ) { dp [ i ] += ( dp [ i | 1 << ( ( j + k ) % N ) ] + N - k ) / N ; break ; } } } int r = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( oc [ i ] == ' X ' ) r |= 1 << i ; System . out . printf ( \" % .10f % n \" , dp [ r ] ) ; }"], ["run", "void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "0", "code": "import java . util . * ; import static java . lang . Math . * ; import java . io . * ; public class D { public static void p ( Object ... args ) { System . out . println ( Arrays . deepToString ( args ) ) ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { String start = in . next ( ) ; N = start . length ( ) ; int st = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( start . charAt ( i ) == ' X ' ) st |= 1 << i ; } DP = new double [ 1 << N ] ; Arrays . fill ( DP , - 1 ) ; DP [ ( 1 << N ) - 1 ] = 0 ; System . out . format ( \" Case \u2581 # % d : \u2581 % .12f \\n \" , zz , compute ( st ) ) ; } } static int N ; static double [ ] DP ; static double compute ( int at ) { if ( DP [ at ] != - 1 ) return DP [ at ] ; double ans = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { int cost = N ; int j = i ; while ( get ( at , j ) ) { j ++ ; cost -- ; if ( j == N ) j = 0 ; } ans += cost + compute ( at | ( 1 << j ) ) ; } ans /= N ; DP [ at ] = ans ; return ans ; } static boolean get ( int num , int bit ) { return ( num & ( 1 << bit ) ) != 0 ; } }", "functions_standalone": [["p", "public static void p ( Object ... args ) { System . out . println ( Arrays . deepToString ( args ) ) ; }"], ["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { String start = in . next ( ) ; N = start . length ( ) ; int st = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( start . charAt ( i ) == ' X ' ) st |= 1 << i ; } DP = new double [ 1 << N ] ; Arrays . fill ( DP , - 1 ) ; DP [ ( 1 << N ) - 1 ] = 0 ; System . out . format ( \" Case \u2581 # % d : \u2581 % .12f \\n \" , zz , compute ( st ) ) ; } }"], ["compute", "static double compute ( int at ) { if ( DP [ at ] != - 1 ) return DP [ at ] ; double ans = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { int cost = N ; int j = i ; while ( get ( at , j ) ) { j ++ ; cost -- ; if ( j == N ) j = 0 ; } ans += cost + compute ( at | ( 1 << j ) ) ; } ans /= N ; DP [ at ] = ans ; return ans ; }"], ["get", "static boolean get ( int num , int bit ) { return ( num & ( 1 << bit ) ) != 0 ; }"]], "functions_class": []}], "python": [{"id": "7", "code": "import sys NEW_LINE T = int ( sys . stdin . readline ( ) ) NEW_LINE def pay ( gondola ) : NEW_LINE INDENT n = len ( gondola ) NEW_LINE if gondola . count ( \" . \" ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if gondola in memo : NEW_LINE INDENT return memo [ gondola ] NEW_LINE DEDENT g2 = gondola + gondola NEW_LINE ans = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if gondola [ i ] == ' . ' : NEW_LINE INDENT ans += n + pay ( gondola [ : i ] + \" X \" + gondola [ i + 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT j = i NEW_LINE wait = 0 NEW_LINE while g2 [ j ] == ' X ' : NEW_LINE INDENT wait += 1 NEW_LINE j += 1 NEW_LINE DEDENT j %= n NEW_LINE ans += ( n - wait ) + pay ( gondola [ : j ] + \" X \" + gondola [ j + 1 : ] ) NEW_LINE DEDENT DEDENT memo [ gondola ] = ans / n NEW_LINE return memo [ gondola ] NEW_LINE DEDENT for test_case in range ( 1 , T + 1 ) : NEW_LINE INDENT gondola = sys . stdin . readline ( ) . strip ( ) NEW_LINE memo = { } NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( test_case , pay ( gondola ) ) ) NEW_LINE DEDENT", "functions_standalone": [["pay", "def pay ( gondola ) : NEW_LINE INDENT n = len ( gondola ) NEW_LINE if gondola . count ( \" . \" ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if gondola in memo : NEW_LINE INDENT return memo [ gondola ] NEW_LINE DEDENT g2 = gondola + gondola NEW_LINE ans = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if gondola [ i ] == ' . ' : NEW_LINE INDENT ans += n + pay ( gondola [ : i ] + \" X \" + gondola [ i + 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT j = i NEW_LINE wait = 0 NEW_LINE while g2 [ j ] == ' X ' : NEW_LINE INDENT wait += 1 NEW_LINE j += 1 NEW_LINE DEDENT j %= n NEW_LINE ans += ( n - wait ) + pay ( gondola [ : j ] + \" X \" + gondola [ j + 1 : ] ) NEW_LINE DEDENT DEDENT memo [ gondola ] = ans / n NEW_LINE return memo [ gondola ] NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "def reader ( inFile ) : NEW_LINE INDENT return inFile . readline ( ) NEW_LINE DEDENT from sys import stderr NEW_LINE def solver ( gonds ) : NEW_LINE INDENT n = len ( gonds ) NEW_LINE k = sum ( [ 1 << i for i in xrange ( n ) if gonds [ i ] == \" X \" ] ) NEW_LINE exps = [ 0.0 ] * ( 1 << n ) NEW_LINE for i in xrange ( ( 1 << n ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i & k ) == k : NEW_LINE INDENT tot = 0 NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT pay = n NEW_LINE w = j NEW_LINE while ( ( i >> w ) & 1 ) == 1 : NEW_LINE INDENT w = ( w + 1 ) % n NEW_LINE pay -= 1 NEW_LINE DEDENT tot += ( pay + exps [ i + ( 1 << w ) ] ) NEW_LINE DEDENT exps [ i ] = tot / n NEW_LINE DEDENT DEDENT return exps [ k ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT from GCJ import GCJ NEW_LINE GCJ ( reader , solver , \" / Users / lpebody / gcj / 2013_3 / d / \" , \" d \" ) . run ( ) NEW_LINE DEDENT", "functions_standalone": [["reader", "def reader ( inFile ) : NEW_LINE INDENT return inFile . readline ( ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_12", "java": [{"id": "9", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) throws Exception { String path = \" D : \\\\ B - large \" ; Scanner sc = new Scanner ( new File ( path + \" . in \" ) ) ; PrintWriter pw = new PrintWriter ( path + \" . out \" ) ; int testCases = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { long E = sc . nextInt ( ) ; long R = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; long [ ] v = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = sc . nextInt ( ) ; } long res = 0 ; long energy = E ; for ( int i = 0 ; i < n ; i ++ ) { long cur = energy ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( v [ j ] > v [ i ] ) { long d = j - i ; long regeneration = d * R ; long y = regeneration - ( E - energy ) ; cur = Math . min ( y , energy ) ; cur = Math . max ( cur , 0 ) ; break ; } } res += cur * v [ i ] ; energy = Math . min ( energy - cur + R , E ) ; } pw . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + res ) ; pw . flush ( ) ; } pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String path = \" D : \\\\ B - large \" ; Scanner sc = new Scanner ( new File ( path + \" . in \" ) ) ; PrintWriter pw = new PrintWriter ( path + \" . out \" ) ; int testCases = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { long E = sc . nextInt ( ) ; long R = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; long [ ] v = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = sc . nextInt ( ) ; } long res = 0 ; long energy = E ; for ( int i = 0 ; i < n ; i ++ ) { long cur = energy ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( v [ j ] > v [ i ] ) { long d = j - i ; long regeneration = d * R ; long y = regeneration - ( E - energy ) ; cur = Math . min ( y , energy ) ; cur = Math . max ( cur , 0 ) ; break ; } } res += cur * v [ i ] ; energy = Math . min ( energy - cur + R , E ) ; } pw . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + res ) ; pw . flush ( ) ; } pw . close ( ) ; }"]], "functions_class": []}, {"id": "3", "code": "import java . util . * ; public class Energy { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; StringBuilder out = new StringBuilder ( ) ; int numCases = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; ++ caseNum ) { out . append ( String . format ( \" Case \u2581 # % d : \u2581 \" , caseNum ) ) ; long maxEnergy = in . nextLong ( ) ; long currentEnergy = maxEnergy ; long regen = in . nextLong ( ) ; int numEvents = in . nextInt ( ) ; long [ ] values = new long [ numEvents ] ; for ( int i = 0 ; i < values . length ; ++ i ) values [ i ] = in . nextLong ( ) ; int curEvent = 0 ; long totalValue = 0 ; while ( curEvent != numEvents ) { int nextEvent = curEvent + 1 ; while ( nextEvent != numEvents && values [ nextEvent ] <= values [ curEvent ] ) ++ nextEvent ; if ( nextEvent == numEvents ) { totalValue += values [ curEvent ] * currentEnergy ; currentEnergy = 0 ; } else { long energyToLeave = Math . max ( maxEnergy - regen * ( nextEvent - curEvent ) , 0L ) ; if ( energyToLeave >= currentEnergy ) { } else { long energyToSpend = currentEnergy - energyToLeave ; totalValue += values [ curEvent ] * energyToSpend ; currentEnergy = energyToLeave ; } } currentEnergy += regen ; currentEnergy = Math . min ( currentEnergy , maxEnergy ) ; ++ curEvent ; } out . append ( totalValue ) ; out . append ( ' \\n ' ) ; } System . out . print ( out ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; StringBuilder out = new StringBuilder ( ) ; int numCases = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; ++ caseNum ) { out . append ( String . format ( \" Case \u2581 # % d : \u2581 \" , caseNum ) ) ; long maxEnergy = in . nextLong ( ) ; long currentEnergy = maxEnergy ; long regen = in . nextLong ( ) ; int numEvents = in . nextInt ( ) ; long [ ] values = new long [ numEvents ] ; for ( int i = 0 ; i < values . length ; ++ i ) values [ i ] = in . nextLong ( ) ; int curEvent = 0 ; long totalValue = 0 ; while ( curEvent != numEvents ) { int nextEvent = curEvent + 1 ; while ( nextEvent != numEvents && values [ nextEvent ] <= values [ curEvent ] ) ++ nextEvent ; if ( nextEvent == numEvents ) { totalValue += values [ curEvent ] * currentEnergy ; currentEnergy = 0 ; } else { long energyToLeave = Math . max ( maxEnergy - regen * ( nextEvent - curEvent ) , 0L ) ; if ( energyToLeave >= currentEnergy ) { } else { long energyToSpend = currentEnergy - energyToLeave ; totalValue += values [ curEvent ] * energyToSpend ; currentEnergy = energyToLeave ; } } currentEnergy += regen ; currentEnergy = Math . min ( currentEnergy , maxEnergy ) ; ++ curEvent ; } out . append ( totalValue ) ; out . append ( ' \\n ' ) ; } System . out . print ( out ) ; }"]], "functions_class": []}, {"id": "6", "code": "import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int cases = scan . nextInt ( ) ; int e , r , n ; long result ; int [ ] maxE , minE ; ArrayList < Activity > activities = new ArrayList < Activity > ( ) ; for ( int c = 1 ; c <= cases ; c ++ ) { e = scan . nextInt ( ) ; r = scan . nextInt ( ) ; if ( r > e ) r = e ; n = scan . nextInt ( ) ; activities . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) activities . add ( new Activity ( i , scan . nextInt ( ) ) ) ; Collections . sort ( activities ) ; maxE = new int [ n ] ; minE = new int [ n ] ; Arrays . fill ( maxE , e ) ; Arrays . fill ( minE , 0 ) ; result = 0 ; for ( Activity act : activities ) { result += ( maxE [ act . i ] - minE [ act . i ] ) * ( long ) act . v ; for ( int i = act . i + 1 , rNext = minE [ act . i ] + r ; i < n && rNext < maxE [ i ] ; i ++ , rNext += r ) maxE [ i ] = rNext ; for ( int i = act . i - 1 , rNext = maxE [ act . i ] - r ; i >= 0 && rNext >= minE [ i ] ; i -- , rNext -= r ) minE [ i ] = rNext ; } System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + result ) ; } } private static class Activity implements Comparable < Activity > { public final int i , v ; public Activity ( int i , int v ) { this . i = i ; this . v = v ; } public int compareTo ( Activity other ) { return - 1 * ( ( Integer ) v ) . compareTo ( other . v ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int cases = scan . nextInt ( ) ; int e , r , n ; long result ; int [ ] maxE , minE ; ArrayList < Activity > activities = new ArrayList < Activity > ( ) ; for ( int c = 1 ; c <= cases ; c ++ ) { e = scan . nextInt ( ) ; r = scan . nextInt ( ) ; if ( r > e ) r = e ; n = scan . nextInt ( ) ; activities . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) activities . add ( new Activity ( i , scan . nextInt ( ) ) ) ; Collections . sort ( activities ) ; maxE = new int [ n ] ; minE = new int [ n ] ; Arrays . fill ( maxE , e ) ; Arrays . fill ( minE , 0 ) ; result = 0 ; for ( Activity act : activities ) { result += ( maxE [ act . i ] - minE [ act . i ] ) * ( long ) act . v ; for ( int i = act . i + 1 , rNext = minE [ act . i ] + r ; i < n && rNext < maxE [ i ] ; i ++ , rNext += r ) maxE [ i ] = rNext ; for ( int i = act . i - 1 , rNext = maxE [ act . i ] - r ; i >= 0 && rNext >= minE [ i ] ; i -- , rNext -= r ) minE [ i ] = rNext ; } System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" + result ) ; } }"]], "functions_class": [["Activity", "public Activity ( int i , int v ) { this . i = i ; this . v = v ; }"], ["compareTo", "public int compareTo ( Activity other ) { return - 1 * ( ( Integer ) v ) . compareTo ( other . v ) ; }"]]}], "python": [{"id": "8", "code": "import sys , os NEW_LINE in_file = None NEW_LINE out_file = None NEW_LINE def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in range ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT", "functions_standalone": [["run_main", "def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT"], ["run_tests", "def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT"], ["readline", "def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT"], ["writeline", "def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT"], ["readinteger", "def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readintegers", "def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in range ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT"]], "functions_class": []}, {"id": "6", "code": "T = int ( input ( ) ) NEW_LINE for tc in range ( T ) : NEW_LINE INDENT E , R , N = map ( int , input ( ) . split ( ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE gainz = 0 NEW_LINE e = E NEW_LINE for i in range ( N ) : NEW_LINE INDENT spend = e NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT if v [ j ] > v [ i ] : NEW_LINE INDENT spend = min ( spend , e + R * ( j - i ) - E ) NEW_LINE DEDENT DEDENT spend = max ( spend , 0 ) NEW_LINE e -= spend NEW_LINE e = min ( e + R , E ) NEW_LINE gainz += v [ i ] * spend NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( tc + 1 , gainz ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_13_13", "java": [{"id": "19", "code": "import java . io . * ; import java . util . Scanner ; public class c { public static void main ( String [ ] args ) throws IOException { Scanner input = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( new File ( \" c . txt \" ) ) ; int T = input . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { out . print ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \\n \" ) ; int r = input . nextInt ( ) , n = input . nextInt ( ) , m = input . nextInt ( ) , k = input . nextInt ( ) ; for ( int rr = 0 ; rr < r ; rr ++ ) { int twopow = 0 , threepow = 0 , fivepow = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int p = input . nextInt ( ) ; int fives = 0 ; while ( p % 5 == 0 && p > 0 ) { p /= 5 ; fives ++ ; } fivepow = Math . max ( fives , fivepow ) ; int twos = 0 ; while ( p % 2 == 0 && p > 0 ) { p /= 2 ; twos ++ ; } twopow = Math . max ( twos , twopow ) ; int threes = 0 ; while ( p % 3 == 0 && p > 0 ) { p /= 3 ; threes ++ ; } threepow = Math . max ( threes , threepow ) ; } int used = 0 ; while ( fivepow > 0 ) { used ++ ; fivepow -- ; out . print ( 5 ) ; } while ( threepow > 0 ) { used ++ ; threepow -- ; out . print ( 3 ) ; } while ( twopow > n - used ) { twopow -= 2 ; used ++ ; out . print ( 4 ) ; } while ( used < n ) { used ++ ; out . print ( 2 ) ; } out . println ( ) ; } } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner input = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( new File ( \" c . txt \" ) ) ; int T = input . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { out . print ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \\n \" ) ; int r = input . nextInt ( ) , n = input . nextInt ( ) , m = input . nextInt ( ) , k = input . nextInt ( ) ; for ( int rr = 0 ; rr < r ; rr ++ ) { int twopow = 0 , threepow = 0 , fivepow = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int p = input . nextInt ( ) ; int fives = 0 ; while ( p % 5 == 0 && p > 0 ) { p /= 5 ; fives ++ ; } fivepow = Math . max ( fives , fivepow ) ; int twos = 0 ; while ( p % 2 == 0 && p > 0 ) { p /= 2 ; twos ++ ; } twopow = Math . max ( twos , twopow ) ; int threes = 0 ; while ( p % 3 == 0 && p > 0 ) { p /= 3 ; threes ++ ; } threepow = Math . max ( threes , threepow ) ; } int used = 0 ; while ( fivepow > 0 ) { used ++ ; fivepow -- ; out . print ( 5 ) ; } while ( threepow > 0 ) { used ++ ; threepow -- ; out . print ( 3 ) ; } while ( twopow > n - used ) { twopow -= 2 ; used ++ ; out . print ( 4 ) ; } while ( used < n ) { used ++ ; out . print ( 2 ) ; } out . println ( ) ; } } out . close ( ) ; }"]], "functions_class": []}, {"id": "20", "code": "package codejam2013 ; import java . io . IOException ; abstract public class CodeJam2013 { abstract public void solveCases ( String inputSize ) throws IOException ; public static void main ( String [ ] args ) { String inputSize = \" s1\" ; Round1AC . main ( inputSize ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { String inputSize = \" s1\" ; Round1AC . main ( inputSize ) ; }"]], "functions_class": []}, {"id": "3", "code": "import java . util . * ; public class Luck1 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numCases = in . nextInt ( ) ; int numRows = in . nextInt ( ) ; int setSize = in . nextInt ( ) ; int setLimit = in . nextInt ( ) ; int numProducts = in . nextInt ( ) ; long [ ] products = new long [ numProducts ] ; StringBuilder output = new StringBuilder ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; ++ caseNum ) { output . append ( String . format ( \" Case \u2581 # % d : \\n \" , caseNum ) ) ; for ( int curRow = 0 ; curRow < numRows ; ++ curRow ) { for ( int i = 0 ; i < numProducts ; ++ i ) products [ i ] = in . nextLong ( ) ; int [ ] best = new int [ setSize ] ; Arrays . fill ( best , 2 ) ; double bestProb = 0.0 ; for ( int e1 = 2 ; e1 <= setLimit ; ++ e1 ) { for ( int e2 = 2 ; e2 <= setLimit ; ++ e2 ) { for ( int e3 = 2 ; e3 <= setLimit ; ++ e3 ) { int [ ] tempSet = new int [ ] { e1 , e2 , e3 } ; double checkProb = 1.0 ; for ( int pCheck = 0 ; pCheck < products . length ; ++ pCheck ) { int counter = 0 ; for ( int bitMask = 0 ; bitMask < ( 1 << tempSet . length ) ; ++ bitMask ) { int checkProduct = 1 ; for ( int bit = 1 , idx = 0 ; bit <= bitMask ; bit <<= 1 , ++ idx ) { if ( ( bit & bitMask ) != 0 ) { checkProduct *= tempSet [ idx ] ; } } if ( checkProduct == products [ pCheck ] ) { ++ counter ; } } checkProb *= ( counter / 8.0 ) ; } if ( checkProb > bestProb ) { best = tempSet ; bestProb = checkProb ; } } } } output . append ( best [ 0 ] ) ; output . append ( best [ 1 ] ) ; output . append ( best [ 2 ] ) ; output . append ( ' \\n ' ) ; } } System . out . print ( output ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numCases = in . nextInt ( ) ; int numRows = in . nextInt ( ) ; int setSize = in . nextInt ( ) ; int setLimit = in . nextInt ( ) ; int numProducts = in . nextInt ( ) ; long [ ] products = new long [ numProducts ] ; StringBuilder output = new StringBuilder ( ) ; for ( int caseNum = 1 ; caseNum <= numCases ; ++ caseNum ) { output . append ( String . format ( \" Case \u2581 # % d : \\n \" , caseNum ) ) ; for ( int curRow = 0 ; curRow < numRows ; ++ curRow ) { for ( int i = 0 ; i < numProducts ; ++ i ) products [ i ] = in . nextLong ( ) ; int [ ] best = new int [ setSize ] ; Arrays . fill ( best , 2 ) ; double bestProb = 0.0 ; for ( int e1 = 2 ; e1 <= setLimit ; ++ e1 ) { for ( int e2 = 2 ; e2 <= setLimit ; ++ e2 ) { for ( int e3 = 2 ; e3 <= setLimit ; ++ e3 ) { int [ ] tempSet = new int [ ] { e1 , e2 , e3 } ; double checkProb = 1.0 ; for ( int pCheck = 0 ; pCheck < products . length ; ++ pCheck ) { int counter = 0 ; for ( int bitMask = 0 ; bitMask < ( 1 << tempSet . length ) ; ++ bitMask ) { int checkProduct = 1 ; for ( int bit = 1 , idx = 0 ; bit <= bitMask ; bit <<= 1 , ++ idx ) { if ( ( bit & bitMask ) != 0 ) { checkProduct *= tempSet [ idx ] ; } } if ( checkProduct == products [ pCheck ] ) { ++ counter ; } } checkProb *= ( counter / 8.0 ) ; } if ( checkProb > bestProb ) { best = tempSet ; bestProb = checkProb ; } } } } output . append ( best [ 0 ] ) ; output . append ( best [ 1 ] ) ; output . append ( best [ 2 ] ) ; output . append ( ' \\n ' ) ; } } System . out . print ( output ) ; }"]], "functions_class": []}, {"id": "8", "code": "import java . io . File ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; public class C { public static void main ( String [ ] args ) throws Exception { String path = \" D : \\\\ C - small - 1 - attempt0\" ; Scanner sc = new Scanner ( new File ( path + \" . in \" ) ) ; PrintWriter pw = new PrintWriter ( path + \" . out \" ) ; int testCases = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { int R = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; pw . println ( \" Case \u2581 # \" + testCase + \" : \" ) ; for ( int i = 0 ; i < R ; i ++ ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int j = 0 ; j < K ; j ++ ) { s . add ( sc . nextInt ( ) ) ; } int [ ] b = new int [ N + 1 ] ; Arrays . fill ( b , 2 ) ; while ( b [ N ] == 2 ) { Set < Integer > s1 = new HashSet < Integer > ( s ) ; for ( int mask = 0 ; mask < 1 << N ; mask ++ ) { int p = 1 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( mask & ( 1 << j ) ) != 0 ) { p *= b [ j ] ; } } s1 . remove ( p ) ; } if ( s1 . isEmpty ( ) ) { break ; } ++ b [ 0 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( b [ j ] > M ) { b [ j ] = 2 ; ++ b [ j + 1 ] ; } } } for ( int j = 0 ; j < N ; j ++ ) { pw . print ( b [ j ] ) ; } pw . println ( ) ; pw . flush ( ) ; } } pw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { String path = \" D : \\\\ C - small - 1 - attempt0\" ; Scanner sc = new Scanner ( new File ( path + \" . in \" ) ) ; PrintWriter pw = new PrintWriter ( path + \" . out \" ) ; int testCases = sc . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { int R = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; pw . println ( \" Case \u2581 # \" + testCase + \" : \" ) ; for ( int i = 0 ; i < R ; i ++ ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int j = 0 ; j < K ; j ++ ) { s . add ( sc . nextInt ( ) ) ; } int [ ] b = new int [ N + 1 ] ; Arrays . fill ( b , 2 ) ; while ( b [ N ] == 2 ) { Set < Integer > s1 = new HashSet < Integer > ( s ) ; for ( int mask = 0 ; mask < 1 << N ; mask ++ ) { int p = 1 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( mask & ( 1 << j ) ) != 0 ) { p *= b [ j ] ; } } s1 . remove ( p ) ; } if ( s1 . isEmpty ( ) ) { break ; } ++ b [ 0 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( b [ j ] > M ) { b [ j ] = 2 ; ++ b [ j + 1 ] ; } } } for ( int j = 0 ; j < N ; j ++ ) { pw . print ( b [ j ] ) ; } pw . println ( ) ; pw . flush ( ) ; } } pw . close ( ) ; }"]], "functions_class": []}, {"id": "5", "code": "import java . util . Scanner ; public class C { private static int [ ] SET = { 4 , 5 , 3 , 2 , 1 } ; public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int cases = scan . nextInt ( ) ; int r , n , m , k , count ; int [ ] res ; long lcmAll ; for ( int c = 1 ; c <= cases ; c ++ ) { r = scan . nextInt ( ) ; n = scan . nextInt ( ) ; m = scan . nextInt ( ) ; k = scan . nextInt ( ) ; res = new int [ n ] ; System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" ) ; for ( int i = 0 ; i < r ; i ++ ) { lcmAll = 1 ; for ( int j = 0 ; j < k ; j ++ ) lcmAll = lcm ( lcmAll , scan . nextInt ( ) ) ; count = 0 ; for ( int j : SET ) { while ( count < n && ( lcmAll % j ) == 0 ) { lcmAll /= j ; res [ count ] = j ; count ++ ; } } if ( res [ 0 ] == 4 && res [ n - 1 ] == 1 ) { res [ 0 ] = 2 ; res [ n - 1 ] = 2 ; } for ( int j : res ) System . out . print ( j == 1 ? 2 : j ) ; System . out . println ( ) ; } } } private static long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } private static long lcm ( long a , long b ) { return a / gcd ( a , b ) * b ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int cases = scan . nextInt ( ) ; int r , n , m , k , count ; int [ ] res ; long lcmAll ; for ( int c = 1 ; c <= cases ; c ++ ) { r = scan . nextInt ( ) ; n = scan . nextInt ( ) ; m = scan . nextInt ( ) ; k = scan . nextInt ( ) ; res = new int [ n ] ; System . out . println ( \" Case \u2581 # \" + c + \" : \u2581 \" ) ; for ( int i = 0 ; i < r ; i ++ ) { lcmAll = 1 ; for ( int j = 0 ; j < k ; j ++ ) lcmAll = lcm ( lcmAll , scan . nextInt ( ) ) ; count = 0 ; for ( int j : SET ) { while ( count < n && ( lcmAll % j ) == 0 ) { lcmAll /= j ; res [ count ] = j ; count ++ ; } } if ( res [ 0 ] == 4 && res [ n - 1 ] == 1 ) { res [ 0 ] = 2 ; res [ n - 1 ] = 2 ; } for ( int j : res ) System . out . print ( j == 1 ? 2 : j ) ; System . out . println ( ) ; } } }"], ["gcd", "private static long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"], ["lcm", "private static long lcm ( long a , long b ) { return a / gcd ( a , b ) * b ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "import sys , os NEW_LINE in_file = None NEW_LINE out_file = None NEW_LINE def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in range ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT", "functions_standalone": [["run_main", "def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT"], ["run_tests", "def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT"], ["readline", "def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT"], ["writeline", "def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT"], ["readinteger", "def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readintegers", "def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in range ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "from collections import defaultdict NEW_LINE T = int ( input ( ) ) NEW_LINE for tc in range ( T ) : NEW_LINE INDENT R , N , M , K = map ( int , input ( ) . split ( ) ) NEW_LINE def factor ( p ) : NEW_LINE INDENT fac = defaultdict ( int ) NEW_LINE for d in range ( 2 , M + 1 ) : NEW_LINE INDENT while p % d == 0 : NEW_LINE INDENT p /= d NEW_LINE fac [ d ] += 1 NEW_LINE DEDENT DEDENT return fac NEW_LINE DEDENT print ( \" Case \u2581 # { } : \" . format ( tc + 1 ) ) NEW_LINE for r in range ( R ) : NEW_LINE INDENT prod = map ( int , input ( ) . split ( ) ) NEW_LINE factors = [ factor ( p ) for p in prod ] NEW_LINE numtimes = defaultdict ( int ) NEW_LINE for k in range ( K ) : NEW_LINE INDENT for d in range ( 2 , M + 1 ) : NEW_LINE INDENT numtimes [ d ] = max ( numtimes [ d ] , factors [ k ] [ d ] ) NEW_LINE DEDENT DEDENT ans = \" \" NEW_LINE ans += '3' * numtimes [ 3 ] + '5' * numtimes [ 5 ] NEW_LINE if 3 - len ( ans ) == 1 : NEW_LINE INDENT if numtimes [ 2 ] == 1 : NEW_LINE INDENT ans += '2' NEW_LINE DEDENT else : NEW_LINE INDENT ans += '4' NEW_LINE DEDENT DEDENT elif 3 - len ( ans ) == 2 : NEW_LINE INDENT if numtimes [ 2 ] == 4 : NEW_LINE INDENT ans += '44' NEW_LINE DEDENT elif numtimes [ 2 ] == 3 : NEW_LINE INDENT ans += '42' NEW_LINE DEDENT else : NEW_LINE INDENT ans += '22' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT has2 = any ( factors [ k ] [ 2 ] % 2 == 1 for k in range ( K ) ) NEW_LINE if has2 : NEW_LINE INDENT ans += '2' NEW_LINE numtimes [ 2 ] -= 1 NEW_LINE DEDENT num4 = numtimes [ 2 ] // 2 NEW_LINE if numtimes [ 2 ] % 2 == 1 : NEW_LINE INDENT ans += '2' NEW_LINE DEDENT ans += '4' * num4 NEW_LINE DEDENT ans += '2' * ( 3 - len ( ans ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["factor", "def factor ( p ) : NEW_LINE INDENT fac = defaultdict ( int ) NEW_LINE for d in range ( 2 , M + 1 ) : NEW_LINE INDENT while p % d == 0 : NEW_LINE INDENT p /= d NEW_LINE fac [ d ] += 1 NEW_LINE DEDENT DEDENT return fac NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_13_22", "java": [{"id": "10", "code": "import gcj . GCJ ; import java . util . Scanner ; public class FallingDiamonds { public static void main ( String [ ] args ) { Scanner s = GCJ . createScanner ( ' B ' , true ) ; int T = s . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int n = s . nextInt ( ) ; int x = s . nextInt ( ) ; int y = s . nextInt ( ) ; double p = 0 ; int nn = 1 ; int total = 1 ; while ( total + nn + 1 + nn + 2 <= n ) { total += nn + 1 + nn + 2 ; nn += 2 ; } int xy = Math . abs ( x ) + y ; if ( xy < nn ) { p = 1 ; } else if ( xy >= nn + 2 ) { p = 0 ; } else { int left = n - total ; if ( left < y + 1 ) { p = 0 ; } else { nn ++ ; double [ ] [ ] cand = new double [ nn + 1 ] [ nn + 1 ] ; cand [ 0 ] [ 0 ] = 1 ; for ( int w = 1 ; w <= left ; w ++ ) { for ( int u = 0 ; u < w && u <= nn ; u ++ ) { int v = w - u - 1 ; if ( v > nn ) { continue ; } if ( u == nn ) { cand [ u ] [ v + 1 ] += cand [ u ] [ v ] ; } else if ( v == nn ) { cand [ u + 1 ] [ v ] += cand [ u ] [ v ] ; } else { cand [ u + 1 ] [ v ] += cand [ u ] [ v ] / 2 ; cand [ u ] [ v + 1 ] += cand [ u ] [ v ] / 2 ; } } } p = 0 ; for ( int u = y + 1 ; u <= left && u <= nn ; u ++ ) { int v = left - u ; if ( v > nn ) { continue ; } p += cand [ u ] [ v ] ; } } } GCJ . out ( i , Double . toString ( p ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner s = GCJ . createScanner ( ' B ' , true ) ; int T = s . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int n = s . nextInt ( ) ; int x = s . nextInt ( ) ; int y = s . nextInt ( ) ; double p = 0 ; int nn = 1 ; int total = 1 ; while ( total + nn + 1 + nn + 2 <= n ) { total += nn + 1 + nn + 2 ; nn += 2 ; } int xy = Math . abs ( x ) + y ; if ( xy < nn ) { p = 1 ; } else if ( xy >= nn + 2 ) { p = 0 ; } else { int left = n - total ; if ( left < y + 1 ) { p = 0 ; } else { nn ++ ; double [ ] [ ] cand = new double [ nn + 1 ] [ nn + 1 ] ; cand [ 0 ] [ 0 ] = 1 ; for ( int w = 1 ; w <= left ; w ++ ) { for ( int u = 0 ; u < w && u <= nn ; u ++ ) { int v = w - u - 1 ; if ( v > nn ) { continue ; } if ( u == nn ) { cand [ u ] [ v + 1 ] += cand [ u ] [ v ] ; } else if ( v == nn ) { cand [ u + 1 ] [ v ] += cand [ u ] [ v ] ; } else { cand [ u + 1 ] [ v ] += cand [ u ] [ v ] / 2 ; cand [ u ] [ v + 1 ] += cand [ u ] [ v ] / 2 ; } } } p = 0 ; for ( int u = y + 1 ; u <= left && u <= nn ; u ++ ) { int v = left - u ; if ( v > nn ) { continue ; } p += cand [ u ] [ v ] ; } } } GCJ . out ( i , Double . toString ( p ) ) ; } }"]], "functions_class": []}, {"id": "7", "code": "import java . io . * ; import java . util . * ; public class Main { static PrintWriter out ; static StreamTokenizer in ; static int next ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; } public static void main ( String [ ] args ) throws Exception { out = new PrintWriter ( System . out ) ; in = new StreamTokenizer ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int tests = next ( ) ; int m = 11000 ; double [ ] [ ] c = new double [ m ] [ m ] ; c [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { c [ i ] [ 0 ] = c [ i ] [ i ] = c [ i - 1 ] [ 0 ] / 2 ; for ( int j = 1 ; j < i ; j ++ ) c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) / 2 ; } for ( int test = 1 ; test <= tests ; test ++ ) { int n = next ( ) ; int x = Math . abs ( next ( ) ) ; int y = Math . abs ( next ( ) ) ; int level = ( x + y ) / 2 ; int sum = 0 ; int lev = 0 ; for ( ; ; lev ++ ) { sum += 4 * lev + 1 ; if ( sum >= n ) break ; } int kol = n - sum + 4 * lev + 1 ; double answ = 0 ; if ( level == lev ) { if ( x == 0 ) { if ( kol == 4 * lev + 1 ) answ = 1 ; } else { for ( int i = 0 ; i <= kol ; i ++ ) if ( i + Math . max ( 0 , kol - i - 2 * lev ) > y ) { answ += c [ kol ] [ i ] ; } } } else if ( level < lev ) answ = 1 ; out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; out . println ( answ ) ; } out . close ( ) ; } }", "functions_standalone": [["next", "static int next ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { out = new PrintWriter ( System . out ) ; in = new StreamTokenizer ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int tests = next ( ) ; int m = 11000 ; double [ ] [ ] c = new double [ m ] [ m ] ; c [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { c [ i ] [ 0 ] = c [ i ] [ i ] = c [ i - 1 ] [ 0 ] / 2 ; for ( int j = 1 ; j < i ; j ++ ) c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) / 2 ; } for ( int test = 1 ; test <= tests ; test ++ ) { int n = next ( ) ; int x = Math . abs ( next ( ) ) ; int y = Math . abs ( next ( ) ) ; int level = ( x + y ) / 2 ; int sum = 0 ; int lev = 0 ; for ( ; ; lev ++ ) { sum += 4 * lev + 1 ; if ( sum >= n ) break ; } int kol = n - sum + 4 * lev + 1 ; double answ = 0 ; if ( level == lev ) { if ( x == 0 ) { if ( kol == 4 * lev + 1 ) answ = 1 ; } else { for ( int i = 0 ; i <= kol ; i ++ ) if ( i + Math . max ( 0 , kol - i - 2 * lev ) > y ) { answ += c [ kol ] [ i ] ; } } } else if ( level < lev ) answ = 1 ; out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; out . println ( answ ) ; } out . close ( ) ; }"]], "functions_class": []}], "python": [{"id": "11", "code": "import math NEW_LINE def C ( k , a ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . factorial ( k ) / ( math . factorial ( a ) * math . factorial ( k - a ) ) NEW_LINE DEDENT def Cal ( k , a ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( a , k + 1 ) : NEW_LINE INDENT sum += C ( k , i ) NEW_LINE DEDENT return sum * 1.0 / 2 ** k NEW_LINE DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT input = raw_input ( ) NEW_LINE b = input . split ( \" \u2581 \" ) NEW_LINE c = [ int ( e ) for e in b ] NEW_LINE N = c [ 0 ] NEW_LINE X = c [ 1 ] NEW_LINE Y = c [ 2 ] NEW_LINE if X < 0 : NEW_LINE INDENT X = - X NEW_LINE DEDENT if ( X + Y ) % 2 == 1 : NEW_LINE INDENT p = 0 NEW_LINE DEDENT elif X + Y == 0 : NEW_LINE INDENT p = 1 NEW_LINE DEDENT elif X == 0 : NEW_LINE INDENT level = Y / 2 + 2 NEW_LINE btm = ( 2 * level - 3 ) * ( level - 1 ) NEW_LINE if N >= btm : NEW_LINE INDENT p = 1 NEW_LINE DEDENT else : NEW_LINE INDENT p = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT level = ( X + Y ) / 2 + 1 NEW_LINE btm = ( 2 * level - 3 ) * ( level - 1 ) + Y + 1 NEW_LINE level2 = level + 1 NEW_LINE upper = ( 2 * level2 - 3 ) * ( level2 - 1 ) - X NEW_LINE if N < btm : NEW_LINE INDENT p = 0 NEW_LINE DEDENT elif N >= upper : NEW_LINE INDENT p = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = N - ( 2 * level - 3 ) * ( level - 1 ) ; NEW_LINE a = Y + 1 NEW_LINE p = Cal ( left , a ) NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + str ( p ) ) NEW_LINE DEDENT", "functions_standalone": [["C", "def C ( k , a ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . factorial ( k ) / ( math . factorial ( a ) * math . factorial ( k - a ) ) NEW_LINE DEDENT"], ["Cal", "def Cal ( k , a ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( a , k + 1 ) : NEW_LINE INDENT sum += C ( k , i ) NEW_LINE DEDENT return sum * 1.0 / 2 ** k NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "import sys NEW_LINE def emit ( text , * args ) : NEW_LINE INDENT msg = text % args NEW_LINE sys . stderr . write ( msg ) NEW_LINE sys . stdout . write ( msg ) NEW_LINE DEDENT def choose ( n , k ) : NEW_LINE INDENT if 0 <= k <= n : NEW_LINE INDENT ntok = 1 NEW_LINE ktok = 1 NEW_LINE for t in xrange ( 1 , min ( k , n - k ) + 1 ) : NEW_LINE INDENT ntok *= n NEW_LINE ktok *= t NEW_LINE n -= 1 NEW_LINE DEDENT return ntok // ktok NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def pyramid_size ( height ) : NEW_LINE INDENT base = 2 * height + 1 NEW_LINE return ( base * ( base + 1 ) ) / 2 NEW_LINE DEDENT def solve ( n , x , y ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT if n >= pyramid_size ( y / 2 ) : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT DEDENT if x < 0 : NEW_LINE INDENT x = - x NEW_LINE DEDENT foundation_height = ( y + x ) / 2 - 1 NEW_LINE foundation = pyramid_size ( foundation_height ) NEW_LINE n = n - foundation NEW_LINE if n <= y : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT if n > ( foundation_height + 1 ) * 2 + y : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT options = 0 NEW_LINE for i in range ( y + 1 , n + 1 ) : NEW_LINE INDENT options += choose ( n , i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if options > 2 ** 30 : NEW_LINE INDENT options = options // 2 NEW_LINE DEDENT else : NEW_LINE INDENT options = options / 2.0 NEW_LINE DEDENT DEDENT return options NEW_LINE DEDENT def getline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT ncases = int ( getline ( ) ) NEW_LINE for casenr in range ( 1 , ncases + 1 ) : NEW_LINE INDENT n , x , y = [ int ( s ) for s in getline ( ) . split ( ) ] NEW_LINE emit ( \" Case \u2581 # % d : \u2581 % s \\n \" , casenr , solve ( n , x , y ) ) NEW_LINE DEDENT", "functions_standalone": [["emit", "def emit ( text , * args ) : NEW_LINE INDENT msg = text % args NEW_LINE sys . stderr . write ( msg ) NEW_LINE sys . stdout . write ( msg ) NEW_LINE DEDENT"], ["pyramid_size", "def pyramid_size ( height ) : NEW_LINE INDENT base = 2 * height + 1 NEW_LINE return ( base * ( base + 1 ) ) / 2 NEW_LINE DEDENT"], ["solve", "def solve ( n , x , y ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT if n >= pyramid_size ( y / 2 ) : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT DEDENT if x < 0 : NEW_LINE INDENT x = - x NEW_LINE DEDENT foundation_height = ( y + x ) / 2 - 1 NEW_LINE foundation = pyramid_size ( foundation_height ) NEW_LINE n = n - foundation NEW_LINE if n <= y : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT if n > ( foundation_height + 1 ) * 2 + y : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT options = 0 NEW_LINE for i in range ( y + 1 , n + 1 ) : NEW_LINE INDENT options += choose ( n , i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if options > 2 ** 30 : NEW_LINE INDENT options = options // 2 NEW_LINE DEDENT else : NEW_LINE INDENT options = options / 2.0 NEW_LINE DEDENT DEDENT return options NEW_LINE DEDENT"], ["getline", "def getline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "6", "code": "import sys , math NEW_LINE def ncr ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) // math . factorial ( r ) // math . factorial ( n - r ) NEW_LINE DEDENT def probability ( height , diamonds ) : NEW_LINE INDENT ways = 0 NEW_LINE for i in range ( height , diamonds + 1 ) : NEW_LINE INDENT ways += ncr ( diamonds , i ) NEW_LINE DEDENT return ways / ( 2 ** diamonds ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , X , Y = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE seq = ( abs ( X ) + Y ) // 2 NEW_LINE remaining = N NEW_LINE for i in range ( seq ) : NEW_LINE INDENT diamonds = i * 4 + 1 NEW_LINE remaining -= diamonds NEW_LINE DEDENT sidelen = seq * 2 + 1 NEW_LINE diamonds = seq * 4 + 1 NEW_LINE prob = 0.0 NEW_LINE if remaining >= diamonds : NEW_LINE INDENT prob = 1.0 NEW_LINE DEDENT elif remaining <= 0 : NEW_LINE INDENT prob = 0.0 NEW_LINE DEDENT else : NEW_LINE INDENT if X == 0 : NEW_LINE INDENT prob = 0.0 NEW_LINE DEDENT else : NEW_LINE INDENT if remaining - ( sidelen - 1 ) > Y : NEW_LINE INDENT prob = 1.0 NEW_LINE DEDENT else : NEW_LINE INDENT prob = probability ( Y + 1 , remaining ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % .10f \" % ( case , prob ) ) NEW_LINE DEDENT", "functions_standalone": [["ncr", "def ncr ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) // math . factorial ( r ) // math . factorial ( n - r ) NEW_LINE DEDENT"], ["probability", "def probability ( height , diamonds ) : NEW_LINE INDENT ways = 0 NEW_LINE for i in range ( height , diamonds + 1 ) : NEW_LINE INDENT ways += ncr ( diamonds , i ) NEW_LINE DEDENT return ways / ( 2 ** diamonds ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "4", "code": "tcs = int ( input ( ) ) NEW_LINE binom = [ [ 1 ] ] NEW_LINE for i in range ( 1 , 5001 ) : NEW_LINE INDENT binom . append ( [ ] ) NEW_LINE binom [ - 1 ] . append ( binom [ - 2 ] [ 0 ] / 2 ) NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT binom [ - 1 ] . append ( ( binom [ - 2 ] [ j - 1 ] + binom [ - 2 ] [ j ] ) / 2 ) NEW_LINE DEDENT binom [ - 1 ] . append ( binom [ - 2 ] [ - 1 ] / 2 ) NEW_LINE DEDENT for i in range ( len ( binom ) ) : NEW_LINE INDENT assert ( len ( binom [ i ] ) == i + 1 ) NEW_LINE for j in range ( 1 , len ( binom [ i ] ) ) : NEW_LINE INDENT binom [ i ] [ j ] += binom [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT for tc in range ( 1 , tcs + 1 ) : NEW_LINE INDENT n , x , y = ( int ( i ) for i in input ( ) . split ( ' \u2581 ' ) ) NEW_LINE level = ( abs ( x ) + y ) // 2 NEW_LINE l = 0 NEW_LINE while n > 0 : NEW_LINE INDENT k = 4 * l + 1 NEW_LINE if n >= k : NEW_LINE INDENT if level == l : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 1.0\" % tc ) NEW_LINE break NEW_LINE DEDENT n -= k NEW_LINE DEDENT else : NEW_LINE INDENT if level == l : NEW_LINE INDENT if y <= n - 1 - 2 * l : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 1.0\" % tc ) NEW_LINE DEDENT elif y >= min ( 2 * l , n ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 0.0\" % tc ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 % .15f \" % ( tc , 1 - binom [ n ] [ y ] ) ) NEW_LINE DEDENT break NEW_LINE DEDENT n = 0 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 0.0\" % tc ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_14_04", "java": [{"id": "9", "code": "import java . util . * ; import java . io . * ; public class D { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" D - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" D - large . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int x = 0 ; x < t ; x ++ ) { int n = in . nextInt ( ) ; double [ ] naomi = new double [ n ] ; for ( int y = 0 ; y < n ; y ++ ) { naomi [ y ] = in . nextDouble ( ) ; } double [ ] ken = new double [ n ] ; for ( int z = 0 ; z < n ; z ++ ) { ken [ z ] = in . nextDouble ( ) ; } Arrays . sort ( naomi ) ; Arrays . sort ( ken ) ; int index = 0 ; int win1 = 0 ; for ( int a = 0 ; a < ken . length ; a ++ ) { while ( index < n && naomi [ index ] < ken [ a ] ) { index ++ ; } if ( index < n ) { win1 ++ ; index ++ ; } } index = 0 ; int win2 = 0 ; for ( int b = 0 ; b < naomi . length ; b ++ ) { while ( index < n && ken [ index ] < naomi [ b ] ) { index ++ ; win2 ++ ; } index ++ ; } out . println ( \" Case \u2581 # \" + ( x + 1 ) + \" : \u2581 \" + win1 + \" \u2581 \" + win2 ) ; } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" D - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" D - large . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int x = 0 ; x < t ; x ++ ) { int n = in . nextInt ( ) ; double [ ] naomi = new double [ n ] ; for ( int y = 0 ; y < n ; y ++ ) { naomi [ y ] = in . nextDouble ( ) ; } double [ ] ken = new double [ n ] ; for ( int z = 0 ; z < n ; z ++ ) { ken [ z ] = in . nextDouble ( ) ; } Arrays . sort ( naomi ) ; Arrays . sort ( ken ) ; int index = 0 ; int win1 = 0 ; for ( int a = 0 ; a < ken . length ; a ++ ) { while ( index < n && naomi [ index ] < ken [ a ] ) { index ++ ; } if ( index < n ) { win1 ++ ; index ++ ; } } index = 0 ; int win2 = 0 ; for ( int b = 0 ; b < naomi . length ; b ++ ) { while ( index < n && ken [ index ] < naomi [ b ] ) { index ++ ; win2 ++ ; } index ++ ; } out . println ( \" Case \u2581 # \" + ( x + 1 ) + \" : \u2581 \" + win1 + \" \u2581 \" + win2 ) ; } out . close ( ) ; }"]], "functions_class": []}, {"id": "4", "code": "import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Scanner ; public class War { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" jam . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" jam . out \" ) ) ; int cases ; cases = sc . nextInt ( ) ; for ( int z = 1 ; z <= cases ; z ++ ) { int n = sc . nextInt ( ) ; double [ ] nami = new double [ n ] ; double [ ] ken = new double [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) nami [ i ] = sc . nextDouble ( ) ; for ( i = 0 ; i < n ; i ++ ) ken [ i ] = sc . nextDouble ( ) ; for ( i = 0 ; i < n ; i ++ ) for ( j = i + 1 ; j < n ; j ++ ) { double t ; if ( nami [ i ] > nami [ j ] ) { t = nami [ i ] ; nami [ i ] = nami [ j ] ; nami [ j ] = t ; } if ( ken [ i ] > ken [ j ] ) { t = ken [ i ] ; ken [ i ] = ken [ j ] ; ken [ j ] = t ; } } int q1 = 0 ; int q2 = n - 1 ; int ans1 = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( nami [ i ] > ken [ q1 ] ) { ans1 ++ ; q1 ++ ; } else { q2 -- ; } int ans2 = 0 ; q1 = 0 ; for ( i = 0 ; i < n ; i ++ ) { while ( q1 < n && ken [ q1 ] < nami [ i ] ) q1 ++ ; if ( q1 == n ) break ; ans2 ++ ; q1 ++ ; } bw . write ( \" Case \u2581 # \" + z + \" : \u2581 \" ) ; bw . write ( \" \" + ans1 + \" \u2581 \" + ( n - ans2 ) + \" \\n \" ) ; } sc . close ( ) ; bw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" jam . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" jam . out \" ) ) ; int cases ; cases = sc . nextInt ( ) ; for ( int z = 1 ; z <= cases ; z ++ ) { int n = sc . nextInt ( ) ; double [ ] nami = new double [ n ] ; double [ ] ken = new double [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) nami [ i ] = sc . nextDouble ( ) ; for ( i = 0 ; i < n ; i ++ ) ken [ i ] = sc . nextDouble ( ) ; for ( i = 0 ; i < n ; i ++ ) for ( j = i + 1 ; j < n ; j ++ ) { double t ; if ( nami [ i ] > nami [ j ] ) { t = nami [ i ] ; nami [ i ] = nami [ j ] ; nami [ j ] = t ; } if ( ken [ i ] > ken [ j ] ) { t = ken [ i ] ; ken [ i ] = ken [ j ] ; ken [ j ] = t ; } } int q1 = 0 ; int q2 = n - 1 ; int ans1 = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( nami [ i ] > ken [ q1 ] ) { ans1 ++ ; q1 ++ ; } else { q2 -- ; } int ans2 = 0 ; q1 = 0 ; for ( i = 0 ; i < n ; i ++ ) { while ( q1 < n && ken [ q1 ] < nami [ i ] ) q1 ++ ; if ( q1 == n ) break ; ans2 ++ ; q1 ++ ; } bw . write ( \" Case \u2581 # \" + z + \" : \u2581 \" ) ; bw . write ( \" \" + ans1 + \" \u2581 \" + ( n - ans2 ) + \" \\n \" ) ; } sc . close ( ) ; bw . close ( ) ; }"]], "functions_class": []}, {"id": "18", "code": "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . util . Arrays ; import java . util . Scanner ; public class Exe4 { public static void main ( String [ ] args ) throws Exception { Scanner input = new Scanner ( new File ( \" input \" ) ) ; BufferedWriter output = new BufferedWriter ( new FileWriter ( new File ( \" output \" ) ) ) ; int T = input . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { int N = input . nextInt ( ) ; double [ ] Noemi = new double [ N ] ; double [ ] Ken = new double [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { Noemi [ j ] = input . nextDouble ( ) ; } for ( int j = 0 ; j < N ; j ++ ) { Ken [ j ] = input . nextDouble ( ) ; } Arrays . sort ( Noemi ) ; Arrays . sort ( Ken ) ; int ans1 = 0 ; int ans2 = 0 ; int k ; int j ; k = 0 ; j = 0 ; while ( k < N ) { while ( k < N && Noemi [ j ] > Ken [ k ] ) { k ++ ; } if ( k < N ) { j ++ ; k ++ ; } } ans1 = N - j ; k = 0 ; j = 0 ; while ( j < N ) { while ( j < N && Noemi [ j ] < Ken [ k ] ) { j ++ ; } if ( j < N ) { j ++ ; k ++ ; } } ans2 = k ; output . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans2 + \" \u2581 \" + ans1 ) ; output . newLine ( ) ; output . flush ( ) ; } output . flush ( ) ; input . close ( ) ; output . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner input = new Scanner ( new File ( \" input \" ) ) ; BufferedWriter output = new BufferedWriter ( new FileWriter ( new File ( \" output \" ) ) ) ; int T = input . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { int N = input . nextInt ( ) ; double [ ] Noemi = new double [ N ] ; double [ ] Ken = new double [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { Noemi [ j ] = input . nextDouble ( ) ; } for ( int j = 0 ; j < N ; j ++ ) { Ken [ j ] = input . nextDouble ( ) ; } Arrays . sort ( Noemi ) ; Arrays . sort ( Ken ) ; int ans1 = 0 ; int ans2 = 0 ; int k ; int j ; k = 0 ; j = 0 ; while ( k < N ) { while ( k < N && Noemi [ j ] > Ken [ k ] ) { k ++ ; } if ( k < N ) { j ++ ; k ++ ; } } ans1 = N - j ; k = 0 ; j = 0 ; while ( j < N ) { while ( j < N && Noemi [ j ] < Ken [ k ] ) { j ++ ; } if ( j < N ) { j ++ ; k ++ ; } } ans2 = k ; output . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + ans2 + \" \u2581 \" + ans1 ) ; output . newLine ( ) ; output . flush ( ) ; } output . flush ( ) ; input . close ( ) ; output . close ( ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . util . * ; public class D { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int inputs = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= inputs ; caseNum ++ ) { int blocks = in . nextInt ( ) ; double [ ] naomi = new double [ blocks ] ; double [ ] ken = new double [ blocks ] ; for ( int i = 0 ; i < blocks ; i ++ ) { naomi [ i ] = in . nextDouble ( ) ; } for ( int i = 0 ; i < blocks ; i ++ ) { ken [ i ] = in . nextDouble ( ) ; } Arrays . sort ( ken ) ; Arrays . sort ( naomi ) ; int normal = 0 ; int i = 0 ; int j = 0 ; while ( i < blocks && j < blocks ) { if ( naomi [ i ] < ken [ j ] ) { i ++ ; j ++ ; normal ++ ; } else { j ++ ; } } normal = blocks - normal ; int cheat = 0 ; i = 0 ; j = 0 ; while ( i < blocks && j < blocks ) { if ( naomi [ i ] > ken [ j ] ) { i ++ ; j ++ ; cheat ++ ; } else { i ++ ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , caseNum , cheat , normal ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int inputs = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= inputs ; caseNum ++ ) { int blocks = in . nextInt ( ) ; double [ ] naomi = new double [ blocks ] ; double [ ] ken = new double [ blocks ] ; for ( int i = 0 ; i < blocks ; i ++ ) { naomi [ i ] = in . nextDouble ( ) ; } for ( int i = 0 ; i < blocks ; i ++ ) { ken [ i ] = in . nextDouble ( ) ; } Arrays . sort ( ken ) ; Arrays . sort ( naomi ) ; int normal = 0 ; int i = 0 ; int j = 0 ; while ( i < blocks && j < blocks ) { if ( naomi [ i ] < ken [ j ] ) { i ++ ; j ++ ; normal ++ ; } else { j ++ ; } } normal = blocks - normal ; int cheat = 0 ; i = 0 ; j = 0 ; while ( i < blocks && j < blocks ) { if ( naomi [ i ] > ken [ j ] ) { i ++ ; j ++ ; cheat ++ ; } else { i ++ ; } } System . out . printf ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \\n \" , caseNum , cheat , normal ) ; } }"]], "functions_class": []}, {"id": "6", "code": "import java . util . * ; public class d { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int T = input . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t + 1 ) ; int n = input . nextInt ( ) ; double [ ] as = new double [ n ] , bs = new double [ n ] ; TreeSet < Double > second = new TreeSet < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) as [ i ] = input . nextDouble ( ) ; for ( int i = 0 ; i < n ; i ++ ) bs [ i ] = input . nextDouble ( ) ; for ( double d : bs ) second . add ( d ) ; Arrays . sort ( as ) ; Arrays . sort ( bs ) ; int res1 = 0 , res2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Double cur = second . ceiling ( as [ i ] ) ; if ( cur == null ) { res2 ++ ; second . remove ( second . first ( ) ) ; } else second . remove ( cur ) ; } res1 = 0 ; for ( int elim = 0 ; elim < n ; elim ++ ) { int count = 0 ; for ( int i = elim ; i < n ; i ++ ) { if ( as [ i ] > bs [ i - elim ] ) count ++ ; } res1 = Math . max ( res1 , count ) ; } System . out . println ( res1 + \" \u2581 \" + res2 ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int T = input . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t + 1 ) ; int n = input . nextInt ( ) ; double [ ] as = new double [ n ] , bs = new double [ n ] ; TreeSet < Double > second = new TreeSet < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) as [ i ] = input . nextDouble ( ) ; for ( int i = 0 ; i < n ; i ++ ) bs [ i ] = input . nextDouble ( ) ; for ( double d : bs ) second . add ( d ) ; Arrays . sort ( as ) ; Arrays . sort ( bs ) ; int res1 = 0 , res2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Double cur = second . ceiling ( as [ i ] ) ; if ( cur == null ) { res2 ++ ; second . remove ( second . first ( ) ) ; } else second . remove ( cur ) ; } res1 = 0 ; for ( int elim = 0 ; elim < n ; elim ++ ) { int count = 0 ; for ( int i = elim ; i < n ; i ++ ) { if ( as [ i ] > bs [ i - elim ] ) count ++ ; } res1 = Math . max ( res1 , count ) ; } System . out . println ( res1 + \" \u2581 \" + res2 ) ; } }"]], "functions_class": []}], "python": [{"id": "15", "code": "def war ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" \u2581 \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" \u2581 \" ) ] NEW_LINE points = 0 NEW_LINE n = reversed ( sorted ( n ) ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > max ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( min ( [ block for block in k if block > nblock ] ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT def dwar ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" \u2581 \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" \u2581 \" ) ] NEW_LINE points = 0 NEW_LINE n = sorted ( n ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > min ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( max ( k ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT input_text = open ( \" input . in \" ) NEW_LINE lines = input_text . readlines ( ) NEW_LINE input_text . close ( ) NEW_LINE with open ( \" output \" , \" a \" ) as outputfile : NEW_LINE INDENT for num in range ( 0 , int ( lines [ 0 ] ) ) : NEW_LINE INDENT outputfile . write ( \" Case \u2581 # \" + str ( num + 1 ) + \" : \u2581 \" + dwar ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" \u2581 \" + war ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" \\n \" ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["war", "def war ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" \u2581 \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" \u2581 \" ) ] NEW_LINE points = 0 NEW_LINE n = reversed ( sorted ( n ) ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > max ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( min ( [ block for block in k if block > nblock ] ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT"], ["dwar", "def dwar ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" \u2581 \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" \u2581 \" ) ] NEW_LINE points = 0 NEW_LINE n = sorted ( n ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > min ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( max ( k ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "11", "code": "from collections import * NEW_LINE from sys import argv , stdin , stdout , stderr NEW_LINE Case = namedtuple ( ' Case ' , ' naomi , \u2581 ken ' ) NEW_LINE def readcase ( f ) : NEW_LINE INDENT blocks = int ( next ( f ) ) NEW_LINE naomi = sorted ( readfloats ( f ) ) NEW_LINE ken = sorted ( readfloats ( f ) ) NEW_LINE assert blocks == len ( ken ) == len ( naomi ) NEW_LINE return Case ( naomi , ken ) NEW_LINE DEDENT def solvecase ( case ) : NEW_LINE INDENT naomi , ken = case NEW_LINE return ' % d \u2581 % d ' % ( liewar ( ken = ken , naomi = naomi ) , war ( ken = ken , naomi = naomi ) ) NEW_LINE DEDENT def war ( ken , naomi ) : NEW_LINE INDENT kenwins = 0 NEW_LINE kencursor = 0 NEW_LINE for nweight in naomi : NEW_LINE INDENT while kencursor < len ( ken ) : NEW_LINE INDENT if ken [ kencursor ] > nweight : NEW_LINE INDENT kenwins += 1 NEW_LINE kencursor += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT kencursor += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( ken ) - kenwins NEW_LINE DEDENT def liewar ( ken , naomi ) : NEW_LINE INDENT return len ( ken ) - war ( naomi , ken ) NEW_LINE DEDENT def readfloats ( f ) : NEW_LINE INDENT return list ( map ( float , next ( f ) . split ( ' \u2581 ' ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( argv [ 1 ] ) as f , open ( argv [ 2 ] , ' w ' ) as out : NEW_LINE INDENT cases = int ( next ( f ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : \u2581 % s ' % ( case , solvecase ( readcase ( f ) ) ) , file = out ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE", "functions_standalone": [["readcase", "def readcase ( f ) : NEW_LINE INDENT blocks = int ( next ( f ) ) NEW_LINE naomi = sorted ( readfloats ( f ) ) NEW_LINE ken = sorted ( readfloats ( f ) ) NEW_LINE assert blocks == len ( ken ) == len ( naomi ) NEW_LINE return Case ( naomi , ken ) NEW_LINE DEDENT"], ["solvecase", "def solvecase ( case ) : NEW_LINE INDENT naomi , ken = case NEW_LINE return ' % d \u2581 % d ' % ( liewar ( ken = ken , naomi = naomi ) , war ( ken = ken , naomi = naomi ) ) NEW_LINE DEDENT"], ["war", "def war ( ken , naomi ) : NEW_LINE INDENT kenwins = 0 NEW_LINE kencursor = 0 NEW_LINE for nweight in naomi : NEW_LINE INDENT while kencursor < len ( ken ) : NEW_LINE INDENT if ken [ kencursor ] > nweight : NEW_LINE INDENT kenwins += 1 NEW_LINE kencursor += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT kencursor += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( ken ) - kenwins NEW_LINE DEDENT"], ["liewar", "def liewar ( ken , naomi ) : NEW_LINE INDENT return len ( ken ) - war ( naomi , ken ) NEW_LINE DEDENT"], ["readfloats", "def readfloats ( f ) : NEW_LINE INDENT return list ( map ( float , next ( f ) . split ( ' \u2581 ' ) ) ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT with open ( argv [ 1 ] ) as f , open ( argv [ 2 ] , ' w ' ) as out : NEW_LINE INDENT cases = int ( next ( f ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : \u2581 % s ' % ( case , solvecase ( readcase ( f ) ) ) , file = out ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE import itertools NEW_LINE from operator import itemgetter NEW_LINE import bisect NEW_LINE import math NEW_LINE import copy NEW_LINE from fractions import gcd NEW_LINE from utilities import * NEW_LINE sys . setrecursionlimit ( 1000 ) NEW_LINE Prep = [ ] NEW_LINE def preprocess ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT def readinput ( Input ) : NEW_LINE INDENT N = Input . readint ( ) NEW_LINE Naomi = Input . readfloats ( ) NEW_LINE Ken = Input . readfloats ( ) NEW_LINE Naomi . sort ( reverse = True ) NEW_LINE Ken . sort ( reverse = True ) NEW_LINE return Naomi , Ken NEW_LINE DEDENT def solve ( Problem , Prep ) : NEW_LINE INDENT Naomi , Ken = Problem NEW_LINE if len ( Naomi ) == 1 : NEW_LINE INDENT if Naomi [ 0 ] > Ken [ 0 ] : NEW_LINE INDENT return \"1 \u2581 1\" NEW_LINE DEDENT else : NEW_LINE INDENT return \"0 \u2581 0\" NEW_LINE DEDENT DEDENT N = Naomi [ : ] NEW_LINE K = Ken [ : ] NEW_LINE wins_fair = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT n = N . pop ( 0 ) NEW_LINE if n < K [ 0 ] : NEW_LINE INDENT K . pop ( 0 ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT K . pop ( ) NEW_LINE wins_fair += 1 NEW_LINE DEDENT DEDENT N = Naomi [ : ] NEW_LINE K = Ken [ : ] NEW_LINE wins_unfair = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT if N [ - 1 ] < K [ - 1 ] : NEW_LINE INDENT N . pop ( ) NEW_LINE K . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT N . pop ( ) NEW_LINE K . pop ( ) NEW_LINE wins_unfair += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT return str ( wins_unfair ) + \" \u2581 \" + str ( wins_fair ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT doit ( preprocess , readinput , solve , MultiCore = False , Verify = False , Input = LARGE , Filename = None , Problem = \" D \" , Attempt = 0 ) NEW_LINE DEDENT", "functions_standalone": [["preprocess", "def preprocess ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT"], ["readinput", "def readinput ( Input ) : NEW_LINE INDENT N = Input . readint ( ) NEW_LINE Naomi = Input . readfloats ( ) NEW_LINE Ken = Input . readfloats ( ) NEW_LINE Naomi . sort ( reverse = True ) NEW_LINE Ken . sort ( reverse = True ) NEW_LINE return Naomi , Ken NEW_LINE DEDENT"], ["solve", "def solve ( Problem , Prep ) : NEW_LINE INDENT Naomi , Ken = Problem NEW_LINE if len ( Naomi ) == 1 : NEW_LINE INDENT if Naomi [ 0 ] > Ken [ 0 ] : NEW_LINE INDENT return \"1 \u2581 1\" NEW_LINE DEDENT else : NEW_LINE INDENT return \"0 \u2581 0\" NEW_LINE DEDENT DEDENT N = Naomi [ : ] NEW_LINE K = Ken [ : ] NEW_LINE wins_fair = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT n = N . pop ( 0 ) NEW_LINE if n < K [ 0 ] : NEW_LINE INDENT K . pop ( 0 ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT K . pop ( ) NEW_LINE wins_fair += 1 NEW_LINE DEDENT DEDENT N = Naomi [ : ] NEW_LINE K = Ken [ : ] NEW_LINE wins_unfair = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT if N [ - 1 ] < K [ - 1 ] : NEW_LINE INDENT N . pop ( ) NEW_LINE K . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT N . pop ( ) NEW_LINE K . pop ( ) NEW_LINE wins_unfair += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT return str ( wins_unfair ) + \" \u2581 \" + str ( wins_fair ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "inputFile = open ( ' D - large . in ' , ' r ' ) NEW_LINE lines = inputFile . readlines ( ) NEW_LINE inputFile . close ( ) NEW_LINE outputFile = open ( ' D - large . out ' , ' w ' ) NEW_LINE numTests = int ( lines [ 0 ] ) NEW_LINE def scoreWar ( naomiNums , kenNums ) : NEW_LINE INDENT naomiInd = 0 NEW_LINE kenInd = 0 NEW_LINE while naomiInd < len ( naomiNums ) : NEW_LINE INDENT naomiPlay = naomiNums [ naomiInd ] NEW_LINE while kenInd < len ( kenNums ) and kenNums [ kenInd ] < naomiPlay : NEW_LINE INDENT kenInd += 1 NEW_LINE DEDENT if kenInd == len ( kenNums ) : NEW_LINE INDENT break NEW_LINE DEDENT naomiInd += 1 NEW_LINE kenInd += 1 NEW_LINE DEDENT return len ( naomiNums ) - naomiInd NEW_LINE DEDENT def scoreDeceit ( naomiNums , kenNums ) : NEW_LINE INDENT naomiInd = 0 NEW_LINE kenInd = 0 NEW_LINE while kenInd < len ( kenNums ) : NEW_LINE INDENT kenPlay = kenNums [ kenInd ] NEW_LINE while naomiInd < len ( naomiNums ) and naomiNums [ naomiInd ] < kenPlay : NEW_LINE INDENT naomiInd += 1 NEW_LINE DEDENT if naomiInd == len ( naomiNums ) : NEW_LINE INDENT break NEW_LINE DEDENT naomiInd += 1 NEW_LINE kenInd += 1 NEW_LINE DEDENT return kenInd NEW_LINE DEDENT for i in range ( 1 , numTests + 1 ) : NEW_LINE INDENT naomiNums = map ( lambda x : float ( x ) , lines [ 3 * i - 1 ] . split ( ) ) NEW_LINE kenNums = map ( lambda x : float ( x ) , lines [ 3 * i ] . split ( ) ) NEW_LINE naomiNums . sort ( ) NEW_LINE kenNums . sort ( ) NEW_LINE deceitScore = scoreDeceit ( naomiNums , kenNums ) NEW_LINE warScore = scoreWar ( naomiNums , kenNums ) NEW_LINE outputFile . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 ' + str ( deceitScore ) + ' \u2581 ' + str ( warScore ) + ' \\n ' ) NEW_LINE DEDENT outputFile . close ( ) NEW_LINE", "functions_standalone": [["scoreWar", "def scoreWar ( naomiNums , kenNums ) : NEW_LINE INDENT naomiInd = 0 NEW_LINE kenInd = 0 NEW_LINE while naomiInd < len ( naomiNums ) : NEW_LINE INDENT naomiPlay = naomiNums [ naomiInd ] NEW_LINE while kenInd < len ( kenNums ) and kenNums [ kenInd ] < naomiPlay : NEW_LINE INDENT kenInd += 1 NEW_LINE DEDENT if kenInd == len ( kenNums ) : NEW_LINE INDENT break NEW_LINE DEDENT naomiInd += 1 NEW_LINE kenInd += 1 NEW_LINE DEDENT return len ( naomiNums ) - naomiInd NEW_LINE DEDENT"], ["scoreDeceit", "def scoreDeceit ( naomiNums , kenNums ) : NEW_LINE INDENT naomiInd = 0 NEW_LINE kenInd = 0 NEW_LINE while kenInd < len ( kenNums ) : NEW_LINE INDENT kenPlay = kenNums [ kenInd ] NEW_LINE while naomiInd < len ( naomiNums ) and naomiNums [ naomiInd ] < kenPlay : NEW_LINE INDENT naomiInd += 1 NEW_LINE DEDENT if naomiInd == len ( naomiNums ) : NEW_LINE INDENT break NEW_LINE DEDENT naomiInd += 1 NEW_LINE kenInd += 1 NEW_LINE DEDENT return kenInd NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import numpy as np NEW_LINE import math NEW_LINE input_file_name = ' . / D - large . in ' NEW_LINE output_file_name = ' . / D - large . out ' NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input_file = open ( input_file_name , ' r ' ) NEW_LINE output_file = open ( output_file_name , ' w ' ) NEW_LINE file_line = input_file . readline ( ) NEW_LINE file_line = file_line . replace ( ' \\n ' , ' ' ) NEW_LINE num_cases = int ( file_line ) NEW_LINE case_num = 1 NEW_LINE while True : NEW_LINE INDENT file_line = input_file . readline ( ) NEW_LINE if file_line == ' ' or file_line == ' \\n ' : NEW_LINE INDENT input_file . close ( ) NEW_LINE break NEW_LINE DEDENT file_line = file_line . replace ( ' \\n ' , ' ' ) NEW_LINE N = int ( file_line ) NEW_LINE file_line = input_file . readline ( ) NEW_LINE N_list = map ( float , file_line . split ( ) ) NEW_LINE file_line = input_file . readline ( ) NEW_LINE K_list = map ( float , file_line . split ( ) ) NEW_LINE N_list . sort ( ) NEW_LINE K_list . sort ( ) NEW_LINE N_index = 0 NEW_LINE K_index = 0 NEW_LINE ken_wins = 0 NEW_LINE while True : NEW_LINE INDENT if N_index == N or K_index == N : NEW_LINE INDENT break NEW_LINE DEDENT if K_list [ K_index ] > N_list [ N_index ] : NEW_LINE INDENT ken_wins += 1 NEW_LINE N_index += 1 NEW_LINE K_index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT K_index += 1 NEW_LINE DEDENT DEDENT fair_wins = N - ken_wins NEW_LINE N_index = 0 NEW_LINE K_index = 0 NEW_LINE cheat_wins = 0 NEW_LINE while True : NEW_LINE INDENT if N_index == N or K_index == N : NEW_LINE INDENT break NEW_LINE DEDENT if N_list [ N_index ] > K_list [ K_index ] : NEW_LINE INDENT cheat_wins += 1 NEW_LINE N_index += 1 NEW_LINE K_index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT N_index += 1 NEW_LINE DEDENT DEDENT output_file . write ( ' Case \u2581 # ' + str ( case_num ) + ' : \u2581 ' + str ( cheat_wins ) + ' \u2581 ' + str ( fair_wins ) + ' \\n ' ) NEW_LINE print ( case_num ) NEW_LINE case_num += 1 NEW_LINE DEDENT output_file . close ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_14_51", "java": [{"id": "8", "code": "import java . util . * ; public class a { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int T = input . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t + 1 ) ; int n = input . nextInt ( ) ; int p = input . nextInt ( ) , q = input . nextInt ( ) , r = input . nextInt ( ) , s = input . nextInt ( ) ; int [ ] data = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { data [ i ] = ( int ) ( ( ( long ) i * p + q ) % r + s ) ; } long lo = 1 , hi = ( long ) 1e13 ; while ( lo < hi - 1 ) { long mid = ( lo + hi ) / 2 ; if ( canDo ( data , mid ) ) hi = mid ; else lo = mid ; } if ( ! canDo ( data , lo ) ) lo ++ ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += data [ i ] ; double res = 1. * lo / sum ; System . out . printf ( \" % .9f \\n \" , 1 - res ) ; } } static boolean canDo ( int [ ] data , long max ) { long count = 1 , sum = 0 ; int n = data . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( data [ i ] > max ) return false ; sum += data [ i ] ; if ( sum > max ) { count ++ ; sum = data [ i ] ; if ( count > 3 ) return false ; } } return count <= 3 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int T = input . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t + 1 ) ; int n = input . nextInt ( ) ; int p = input . nextInt ( ) , q = input . nextInt ( ) , r = input . nextInt ( ) , s = input . nextInt ( ) ; int [ ] data = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { data [ i ] = ( int ) ( ( ( long ) i * p + q ) % r + s ) ; } long lo = 1 , hi = ( long ) 1e13 ; while ( lo < hi - 1 ) { long mid = ( lo + hi ) / 2 ; if ( canDo ( data , mid ) ) hi = mid ; else lo = mid ; } if ( ! canDo ( data , lo ) ) lo ++ ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += data [ i ] ; double res = 1. * lo / sum ; System . out . printf ( \" % .9f \\n \" , 1 - res ) ; } }"], ["canDo", "static boolean canDo ( int [ ] data , long max ) { long count = 1 , sum = 0 ; int n = data . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( data [ i ] > max ) return false ; sum += data [ i ] ; if ( sum > max ) { count ++ ; sum = data [ i ] ; if ( count > 3 ) return false ; } } return count <= 3 ; }"]], "functions_class": []}], "python": [{"id": "5", "code": "for ti in range ( 1 , int ( input ( ) ) + 1 ) : NEW_LINE INDENT n , p , q , r , s = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE dev = [ ( i * p + q ) % r + s for i in range ( n ) ] NEW_LINE tot = sum ( dev ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE ltot = 0 NEW_LINE mtot = tot NEW_LINE rtot = 0 NEW_LINE best = 0 NEW_LINE while ltot < mtot > rtot : NEW_LINE INDENT if ltot + dev [ i ] < rtot + dev [ j ] : NEW_LINE INDENT ltot += dev [ i ] NEW_LINE mtot -= dev [ i ] NEW_LINE i += 1 NEW_LINE best = max ( best , tot - max ( ltot , mtot , rtot ) ) NEW_LINE DEDENT else : NEW_LINE INDENT rtot += dev [ j ] NEW_LINE mtot -= dev [ j ] NEW_LINE j -= 1 NEW_LINE best = max ( best , tot - max ( ltot , mtot , rtot ) ) NEW_LINE DEDENT DEDENT print ( ' Case \u2581 # ' + str ( ti ) + ' : ' , best / tot ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "13", "code": "import sys NEW_LINE t = int ( sys . stdin . readline ( ) ) NEW_LINE def solve ( n , p , q , r , s ) : NEW_LINE INDENT l = [ ( i * p + q ) % r + s for i in range ( n ) ] NEW_LINE vsota = sum ( l ) NEW_LINE cum = [ 0 ] NEW_LINE for x in l : NEW_LINE INDENT cum . append ( cum [ - 1 ] + x ) NEW_LINE DEDENT best = 0.0 NEW_LINE for b in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT rem = vsota - ( cum [ n ] - cum [ b ] ) NEW_LINE al = 0 NEW_LINE ar = b NEW_LINE while al + 1 < ar : NEW_LINE INDENT amid = ( al + ar ) // 2 NEW_LINE left = cum [ amid ] NEW_LINE right = cum [ b ] - cum [ amid ] NEW_LINE if left > right : NEW_LINE INDENT ar = amid NEW_LINE DEDENT else : NEW_LINE INDENT al = amid NEW_LINE DEDENT DEDENT s = [ cum [ al ] , cum [ b ] - cum [ al ] , cum [ n ] - cum [ b ] ] NEW_LINE s . sort ( ) NEW_LINE p = ( s [ 0 ] + s [ 1 ] ) / vsota NEW_LINE best = max ( best , p ) NEW_LINE s = [ cum [ ar ] , cum [ b ] - cum [ ar ] , cum [ n ] - cum [ b ] ] NEW_LINE s . sort ( ) NEW_LINE p = ( s [ 0 ] + s [ 1 ] ) / vsota NEW_LINE best = max ( best , p ) NEW_LINE DEDENT return best NEW_LINE DEDENT for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n , p , q , r , s = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( test_case , solve ( n , p , q , r , s ) ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( n , p , q , r , s ) : NEW_LINE INDENT l = [ ( i * p + q ) % r + s for i in range ( n ) ] NEW_LINE vsota = sum ( l ) NEW_LINE cum = [ 0 ] NEW_LINE for x in l : NEW_LINE INDENT cum . append ( cum [ - 1 ] + x ) NEW_LINE DEDENT best = 0.0 NEW_LINE for b in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT rem = vsota - ( cum [ n ] - cum [ b ] ) NEW_LINE al = 0 NEW_LINE ar = b NEW_LINE while al + 1 < ar : NEW_LINE INDENT amid = ( al + ar ) // 2 NEW_LINE left = cum [ amid ] NEW_LINE right = cum [ b ] - cum [ amid ] NEW_LINE if left > right : NEW_LINE INDENT ar = amid NEW_LINE DEDENT else : NEW_LINE INDENT al = amid NEW_LINE DEDENT DEDENT s = [ cum [ al ] , cum [ b ] - cum [ al ] , cum [ n ] - cum [ b ] ] NEW_LINE s . sort ( ) NEW_LINE p = ( s [ 0 ] + s [ 1 ] ) / vsota NEW_LINE best = max ( best , p ) NEW_LINE s = [ cum [ ar ] , cum [ b ] - cum [ ar ] , cum [ n ] - cum [ b ] ] NEW_LINE s . sort ( ) NEW_LINE p = ( s [ 0 ] + s [ 1 ] ) / vsota NEW_LINE best = max ( best , p ) NEW_LINE DEDENT return best NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "num_trials = int ( input ( ) ) NEW_LINE def in_range ( a , b , S ) : NEW_LINE INDENT return S [ b + 1 ] - S [ a ] NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT N , p , q , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ 0 ] * ( N + 1 ) NEW_LINE S [ 0 ] = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT S [ i + 1 ] = ( p * i + q ) % r + s + S [ i ] NEW_LINE DEDENT a_lo = 0 NEW_LINE a_hi = N - 1 NEW_LINE min_solveig_score = S [ N ] + 1 NEW_LINE while a_lo <= a_hi : NEW_LINE INDENT a_try = ( a_lo + a_hi ) // 2 NEW_LINE lo_range = S [ a_try ] NEW_LINE b_lo = a_try NEW_LINE b_hi = N - 1 NEW_LINE min_max_mid_hi = S [ N ] + 1 NEW_LINE while b_lo <= b_hi : NEW_LINE INDENT b_try = ( b_lo + b_hi ) // 2 NEW_LINE mid_range = S [ b_try + 1 ] - S [ a_try ] NEW_LINE hi_range = S [ N ] - S [ b_try + 1 ] NEW_LINE min_max_mid_hi = min ( min_max_mid_hi , max ( mid_range , hi_range ) ) NEW_LINE if mid_range > hi_range : NEW_LINE INDENT b_hi = b_try - 1 NEW_LINE DEDENT elif mid_range < hi_range : NEW_LINE INDENT b_lo = b_try + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT min_solveig_score = min ( min_solveig_score , max ( lo_range , min_max_mid_hi ) ) NEW_LINE if lo_range > min_max_mid_hi : NEW_LINE INDENT a_hi = a_try - 1 NEW_LINE DEDENT elif lo_range < min_max_mid_hi : NEW_LINE INDENT a_lo = a_try + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( \" % 1.10f \" % ( 1 - min_solveig_score / S [ N ] ) ) NEW_LINE DEDENT for i in range ( 0 , num_trials ) : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( compute ( ) ) ) NEW_LINE DEDENT", "functions_standalone": [["in_range", "def in_range ( a , b , S ) : NEW_LINE INDENT return S [ b + 1 ] - S [ a ] NEW_LINE DEDENT"], ["compute", "def compute ( ) : NEW_LINE INDENT N , p , q , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ 0 ] * ( N + 1 ) NEW_LINE S [ 0 ] = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT S [ i + 1 ] = ( p * i + q ) % r + s + S [ i ] NEW_LINE DEDENT a_lo = 0 NEW_LINE a_hi = N - 1 NEW_LINE min_solveig_score = S [ N ] + 1 NEW_LINE while a_lo <= a_hi : NEW_LINE INDENT a_try = ( a_lo + a_hi ) // 2 NEW_LINE lo_range = S [ a_try ] NEW_LINE b_lo = a_try NEW_LINE b_hi = N - 1 NEW_LINE min_max_mid_hi = S [ N ] + 1 NEW_LINE while b_lo <= b_hi : NEW_LINE INDENT b_try = ( b_lo + b_hi ) // 2 NEW_LINE mid_range = S [ b_try + 1 ] - S [ a_try ] NEW_LINE hi_range = S [ N ] - S [ b_try + 1 ] NEW_LINE min_max_mid_hi = min ( min_max_mid_hi , max ( mid_range , hi_range ) ) NEW_LINE if mid_range > hi_range : NEW_LINE INDENT b_hi = b_try - 1 NEW_LINE DEDENT elif mid_range < hi_range : NEW_LINE INDENT b_lo = b_try + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT min_solveig_score = min ( min_solveig_score , max ( lo_range , min_max_mid_hi ) ) NEW_LINE if lo_range > min_max_mid_hi : NEW_LINE INDENT a_hi = a_try - 1 NEW_LINE DEDENT elif lo_range < min_max_mid_hi : NEW_LINE INDENT a_lo = a_try + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( \" % 1.10f \" % ( 1 - min_solveig_score / S [ N ] ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_33", "java": [{"id": "15", "code": "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . StringTokenizer ; public class Enclosure { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( new File ( \" in \" ) ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( \" out \" ) ) ) ; StringTokenizer st ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int cn = 1 ; cn <= T ; cn ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int M = Integer . parseInt ( st . nextToken ( ) ) ; int K = Integer . parseInt ( st . nextToken ( ) ) ; int ans = K ; for ( int i = 3 ; i <= N ; i ++ ) { for ( int j = 3 ; j <= M ; j ++ ) { int stones = 2 * ( i - 2 ) + 2 * ( j - 2 ) ; int covered = i * j - 4 ; if ( K <= covered ) ans = Math . min ( ans , stones ) ; for ( int k = 1 ; k <= 4 ; k ++ ) if ( K <= covered + k ) ans = Math . min ( ans , stones + k ) ; if ( i < N || j < M ) if ( K <= covered + 2 ) ans = Math . min ( ans , stones + 1 ) ; } } System . out . println ( N + \" \u2581 \" + M + \" \u2581 \" + K + \" \u2581 \" + ans ) ; bw . append ( \" Case \u2581 # \" + cn + \" : \u2581 \" ) ; bw . append ( ans + \" \\n \" ) ; } bw . flush ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( new File ( \" in \" ) ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( \" out \" ) ) ) ; StringTokenizer st ; int T = Integer . parseInt ( br . readLine ( ) ) ; for ( int cn = 1 ; cn <= T ; cn ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int M = Integer . parseInt ( st . nextToken ( ) ) ; int K = Integer . parseInt ( st . nextToken ( ) ) ; int ans = K ; for ( int i = 3 ; i <= N ; i ++ ) { for ( int j = 3 ; j <= M ; j ++ ) { int stones = 2 * ( i - 2 ) + 2 * ( j - 2 ) ; int covered = i * j - 4 ; if ( K <= covered ) ans = Math . min ( ans , stones ) ; for ( int k = 1 ; k <= 4 ; k ++ ) if ( K <= covered + k ) ans = Math . min ( ans , stones + k ) ; if ( i < N || j < M ) if ( K <= covered + 2 ) ans = Math . min ( ans , stones + 1 ) ; } } System . out . println ( N + \" \u2581 \" + M + \" \u2581 \" + K + \" \u2581 \" + ans ) ; bw . append ( \" Case \u2581 # \" + cn + \" : \u2581 \" ) ; bw . append ( ans + \" \\n \" ) ; } bw . flush ( ) ; }"]], "functions_class": []}, {"id": "8", "code": "package codejam ; import java . io . * ; import java . util . Scanner ; public abstract class Task { protected abstract String getName ( ) ; protected abstract void runOne ( Scanner input , PrintWriter output ) ; void run ( InputStream input , OutputStream output ) { Scanner in = new Scanner ( input ) ; PrintWriter out = new PrintWriter ( output ) ; int testsCount = in . nextInt ( ) ; in . nextLine ( ) ; for ( int test = 1 ; test <= testsCount ; test ++ ) { System . out . println ( \" solving \u2581 \" + test ) ; out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; runOne ( in , out ) ; out . flush ( ) ; } } public static void runConsole ( Task task ) { task . run ( System . in , System . out ) ; } public static void runSmall ( Task task , int num ) throws IOException { runFiles ( task , new File ( \" . / \" + task . getName ( ) + \" - small - attempt \" + num + \" . in \" ) , new File ( \" . / \" + task . getName ( ) + \" - small - attempt \" + num + \" . out \" ) ) ; } public static void runLarge ( Task task ) throws IOException { runFiles ( task , new File ( \" . / \" + task . getName ( ) + \" - large . in \" ) , new File ( \" . / \" + task . getName ( ) + \" - large . out \" ) ) ; } private static void runFiles ( Task task , File input , File output ) throws IOException { InputStream is = new BufferedInputStream ( new FileInputStream ( input ) ) ; OutputStream os = new BufferedOutputStream ( new FileOutputStream ( output ) ) ; task . run ( is , os ) ; is . close ( ) ; os . close ( ) ; } }", "functions_standalone": [["runConsole", "public static void runConsole ( Task task ) { task . run ( System . in , System . out ) ; }"], ["runSmall", "public static void runSmall ( Task task , int num ) throws IOException { runFiles ( task , new File ( \" . / \" + task . getName ( ) + \" - small - attempt \" + num + \" . in \" ) , new File ( \" . / \" + task . getName ( ) + \" - small - attempt \" + num + \" . out \" ) ) ; }"], ["runLarge", "public static void runLarge ( Task task ) throws IOException { runFiles ( task , new File ( \" . / \" + task . getName ( ) + \" - large . in \" ) , new File ( \" . / \" + task . getName ( ) + \" - large . out \" ) ) ; }"], ["runFiles", "private static void runFiles ( Task task , File input , File output ) throws IOException { InputStream is = new BufferedInputStream ( new FileInputStream ( input ) ) ; OutputStream os = new BufferedOutputStream ( new FileOutputStream ( output ) ) ; task . run ( is , os ) ; is . close ( ) ; os . close ( ) ; }"]], "functions_class": [["run", "void run ( InputStream input , OutputStream output ) { Scanner in = new Scanner ( input ) ; PrintWriter out = new PrintWriter ( output ) ; int testsCount = in . nextInt ( ) ; in . nextLine ( ) ; for ( int test = 1 ; test <= testsCount ; test ++ ) { System . out . println ( \" solving \u2581 \" + test ) ; out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; runOne ( in , out ) ; out . flush ( ) ; } }"]]}, {"id": "3", "code": "import java . util . Scanner ; public class C2 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; if ( N == 1 || M == 1 ) { System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + K ) ; continue ; } int answer = 2 * N + 2 * M - 4 ; for ( int stones = 2 * N + 2 * M - 5 ; stones > 0 ; stones -- ) { int newEnclosed = Math . max ( temp ( M , N , stones ) , temp ( N , M , stones ) ) ; if ( newEnclosed >= K ) { answer = stones ; } else { break ; } } System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + answer ) ; } } private static int temp ( int N , int M , int stones ) { int diff = 2 * N + 2 * M - 4 - stones ; int d1 = diff / 4 ; int d2 = ( diff + 1 ) / 4 ; int d3 = ( diff + 2 ) / 4 ; int d4 = ( diff + 3 ) / 4 ; int newEnclosed = 0 ; for ( int n = 0 ; n < N ; n ++ ) { for ( int m = 0 ; m < M ; m ++ ) { if ( n + m >= d1 && n + ( M - 1 - m ) >= d2 && ( N - 1 - n ) + ( M - 1 - m ) >= d3 && ( N - 1 - n ) + m >= d4 ) { newEnclosed ++ ; } } } return newEnclosed ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; if ( N == 1 || M == 1 ) { System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + K ) ; continue ; } int answer = 2 * N + 2 * M - 4 ; for ( int stones = 2 * N + 2 * M - 5 ; stones > 0 ; stones -- ) { int newEnclosed = Math . max ( temp ( M , N , stones ) , temp ( N , M , stones ) ) ; if ( newEnclosed >= K ) { answer = stones ; } else { break ; } } System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + answer ) ; } }"], ["temp", "private static int temp ( int N , int M , int stones ) { int diff = 2 * N + 2 * M - 4 - stones ; int d1 = diff / 4 ; int d2 = ( diff + 1 ) / 4 ; int d3 = ( diff + 2 ) / 4 ; int d4 = ( diff + 3 ) / 4 ; int newEnclosed = 0 ; for ( int n = 0 ; n < N ; n ++ ) { for ( int m = 0 ; m < M ; m ++ ) { if ( n + m >= d1 && n + ( M - 1 - m ) >= d2 && ( N - 1 - n ) + ( M - 1 - m ) >= d3 && ( N - 1 - n ) + m >= d4 ) { newEnclosed ++ ; } } } return newEnclosed ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE size = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE N = int ( line [ 0 ] ) NEW_LINE M = int ( line [ 1 ] ) NEW_LINE K = int ( line [ 2 ] ) NEW_LINE stones = 0 NEW_LINE if K <= 4 : NEW_LINE INDENT stones = K NEW_LINE DEDENT elif min ( N , M ) <= 2 : NEW_LINE INDENT stones = K NEW_LINE DEDENT elif min ( N , M ) == 3 : NEW_LINE INDENT enclosed = int ( ( K - 2 ) / 3 ) NEW_LINE enclosed = min ( enclosed , max ( N , M ) - 2 ) NEW_LINE stones = K - enclosed NEW_LINE DEDENT else : NEW_LINE INDENT if K < 8 : NEW_LINE INDENT enclosed = 1 NEW_LINE DEDENT elif K < 10 : NEW_LINE INDENT enclosed = 2 NEW_LINE DEDENT elif K < 12 : NEW_LINE INDENT enclosed = 3 NEW_LINE DEDENT elif K < 14 or max ( N , M ) == 4 : NEW_LINE INDENT enclosed = 4 NEW_LINE DEDENT elif K < 16 : NEW_LINE INDENT enclosed = 5 NEW_LINE DEDENT else : NEW_LINE INDENT enclosed = 6 NEW_LINE DEDENT stones = K - enclosed NEW_LINE DEDENT output = str ( stones ) NEW_LINE print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "20", "code": "nR = int ( input ( ) ) NEW_LINE for run in range ( nR ) : NEW_LINE INDENT data = input ( ) . split ( ) NEW_LINE N = int ( data [ 0 ] ) NEW_LINE M = int ( data [ 1 ] ) NEW_LINE K = int ( data [ 2 ] ) NEW_LINE mini = K NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , M + 1 ) : NEW_LINE INDENT loss = 0 NEW_LINE rm = 0 NEW_LINE for k in range ( min ( i , j ) // 2 ) : NEW_LINE INDENT for m in range ( 5 ) : NEW_LINE INDENT if 2 * k == min ( i , j ) and m > 2 : NEW_LINE INDENT break NEW_LINE DEDENT if i * j - loss < K : NEW_LINE INDENT break NEW_LINE DEDENT if 2 * ( i + j ) - 4 - rm < mini : NEW_LINE INDENT mini = 2 * ( i + j ) - 4 - rm NEW_LINE DEDENT loss += ( k + 1 ) NEW_LINE rm += 1 NEW_LINE DEDENT if i * j - loss < K : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Case \u2581 # \" + str ( run + 1 ) + \" : \u2581 \" + str ( mini ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "16", "code": "from cmath import sqrt NEW_LINE import math NEW_LINE T = int ( input ( ) ) NEW_LINE test = 1 NEW_LINE while test <= T : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( test ) + \" : \u2581 \" , end = \" \" ) NEW_LINE test += 1 NEW_LINE mnk = input ( ) . split ( ) NEW_LINE m = int ( mnk [ 0 ] ) NEW_LINE n = int ( mnk [ 1 ] ) NEW_LINE k = int ( mnk [ 2 ] ) NEW_LINE if m > n : NEW_LINE INDENT tmp = n NEW_LINE n = m NEW_LINE m = tmp NEW_LINE DEDENT if m <= 2 : NEW_LINE INDENT print ( k ) NEW_LINE continue NEW_LINE DEDENT if m * n - k <= 4 : NEW_LINE INDENT print ( ( m + n - 4 ) * 2 - m * n + k + 4 ) NEW_LINE continue NEW_LINE DEDENT size = math . ceil ( sqrt ( k + 4 ) . real ) NEW_LINE w = 0 NEW_LINE if size > m : NEW_LINE INDENT w = m NEW_LINE DEDENT else : NEW_LINE INDENT w = size NEW_LINE DEDENT h = size - 1 NEW_LINE while w * h - 4 < k : NEW_LINE INDENT h += 1 NEW_LINE DEDENT ans = ( w + h - 4 ) * 2 NEW_LINE if h > w : NEW_LINE INDENT tmp = h NEW_LINE h = w NEW_LINE w = tmp NEW_LINE DEDENT if ( w * h - 4 ) - k >= 2 and m > 3 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT if ( w - 1 ) * h - 3 >= k : NEW_LINE INDENT ans = min ( ( w + h - 5 ) * 2 + 1 , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "11", "code": "import itertools NEW_LINE def valid ( seq ) : NEW_LINE INDENT for i in xrange ( len ( seq ) - 1 ) : NEW_LINE INDENT if abs ( seq [ i ] - seq [ i + 1 ] ) > 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def solve ( case ) : NEW_LINE INDENT n , m , k = case NEW_LINE if min ( n , m ) <= 2 : NEW_LINE INDENT return k NEW_LINE DEDENT if k <= 4 : NEW_LINE INDENT return k NEW_LINE DEDENT count = k NEW_LINE for i in xrange ( 1 , n + 1 ) : NEW_LINE INDENT for seq in itertools . product ( range ( 1 , m + 1 ) , repeat = i ) : NEW_LINE INDENT if sum ( seq ) == k and valid ( seq ) : NEW_LINE INDENT count = min ( count , seq [ 0 ] + seq [ - 1 ] + 2 * len ( seq ) - 4 ) NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT f = file ( ' c . in ' , ' r ' ) NEW_LINE lines = f . readlines ( ) NEW_LINE t = int ( lines [ 0 ] ) NEW_LINE f . close ( ) NEW_LINE g = file ( ' c . out ' , ' w ' ) NEW_LINE for i in xrange ( 1 , t + 1 ) : NEW_LINE INDENT s = solve ( map ( int , lines [ i ] . strip ( ) . split ( ) ) ) NEW_LINE g . write ( \" Case \u2581 # { } : \u2581 { } \\n \" . format ( i , s ) ) NEW_LINE DEDENT g . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "6", "code": "import math NEW_LINE import heapq NEW_LINE def test ( N , M , K , t , b , limit ) : NEW_LINE INDENT stone = t + b NEW_LINE cover = t + b NEW_LINE layer = 2 NEW_LINE while layer <= M : NEW_LINE INDENT if cover >= K and t - b <= 2 : NEW_LINE INDENT return stone NEW_LINE DEDENT else : NEW_LINE INDENT stone += 2 NEW_LINE b = min ( N , b + 2 ) NEW_LINE cover += b NEW_LINE if b > t : NEW_LINE INDENT t , b = b , t NEW_LINE DEDENT layer += 1 NEW_LINE DEDENT if stone > limit : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ifile = open ( ' c . in ' , ' r ' ) NEW_LINE ofile = open ( ' c . out ' , ' w ' ) NEW_LINE T = int ( ifile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , M , K = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE m = K NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT t = test ( N , M , K , i , j , m ) NEW_LINE if t > 0 and t < m : NEW_LINE INDENT m = t NEW_LINE DEDENT DEDENT DEDENT N , M = M , N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT t = test ( N , M , K , i , j , m ) NEW_LINE if t > 0 and t < m : NEW_LINE INDENT m = t NEW_LINE DEDENT DEDENT DEDENT ofile . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( case , m ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["test", "def test ( N , M , K , t , b , limit ) : NEW_LINE INDENT stone = t + b NEW_LINE cover = t + b NEW_LINE layer = 2 NEW_LINE while layer <= M : NEW_LINE INDENT if cover >= K and t - b <= 2 : NEW_LINE INDENT return stone NEW_LINE DEDENT else : NEW_LINE INDENT stone += 2 NEW_LINE b = min ( N , b + 2 ) NEW_LINE cover += b NEW_LINE if b > t : NEW_LINE INDENT t , b = b , t NEW_LINE DEDENT layer += 1 NEW_LINE DEDENT if stone > limit : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT ifile = open ( ' c . in ' , ' r ' ) NEW_LINE ofile = open ( ' c . out ' , ' w ' ) NEW_LINE T = int ( ifile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , M , K = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] NEW_LINE m = K NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT t = test ( N , M , K , i , j , m ) NEW_LINE if t > 0 and t < m : NEW_LINE INDENT m = t NEW_LINE DEDENT DEDENT DEDENT N , M = M , N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT t = test ( N , M , K , i , j , m ) NEW_LINE if t > 0 and t < m : NEW_LINE INDENT m = t NEW_LINE DEDENT DEDENT DEDENT ofile . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( case , m ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_02", "java": [{"id": "9", "code": "import java . util . * ; import java . io . * ; public class B { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" B - large . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int y = 0 ; y < t ; y ++ ) { double c = in . nextDouble ( ) ; double f = in . nextDouble ( ) ; double x = in . nextDouble ( ) ; long low = 0 ; long high = ( long ) 1E6 ; while ( low + 2 < high ) { long mid1 = low + ( high - low ) / 3 ; long mid2 = low + 2 * ( high - low ) / 3 ; if ( getTime ( mid1 , c , f , x ) < getTime ( mid2 , c , f , x ) ) { high = mid2 - 1 ; } else { low = mid1 ; } } double result = Double . POSITIVE_INFINITY ; for ( long z = low ; z <= high ; z ++ ) { result = Math . min ( result , getTime ( z , c , f , x ) ) ; } out . printf ( \" Case \u2581 # % d : \u2581 % .7f \\n \" , y + 1 , result ) ; } out . close ( ) ; } public static double getTime ( long buildings , double c , double f , double x ) { double time = 0 ; double rate = 2 ; for ( int i = 0 ; i < buildings ; i ++ ) { time += c / rate ; rate += f ; } return time + ( x / rate ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" B - large . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" B - large . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int y = 0 ; y < t ; y ++ ) { double c = in . nextDouble ( ) ; double f = in . nextDouble ( ) ; double x = in . nextDouble ( ) ; long low = 0 ; long high = ( long ) 1E6 ; while ( low + 2 < high ) { long mid1 = low + ( high - low ) / 3 ; long mid2 = low + 2 * ( high - low ) / 3 ; if ( getTime ( mid1 , c , f , x ) < getTime ( mid2 , c , f , x ) ) { high = mid2 - 1 ; } else { low = mid1 ; } } double result = Double . POSITIVE_INFINITY ; for ( long z = low ; z <= high ; z ++ ) { result = Math . min ( result , getTime ( z , c , f , x ) ) ; } out . printf ( \" Case \u2581 # % d : \u2581 % .7f \\n \" , y + 1 , result ) ; } out . close ( ) ; }"], ["getTime", "public static double getTime ( long buildings , double c , double f , double x ) { double time = 0 ; double rate = 2 ; for ( int i = 0 ; i < buildings ; i ++ ) { time += c / rate ; rate += f ; } return time + ( x / rate ) ; }"]], "functions_class": []}, {"id": "4", "code": "import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . text . DecimalFormat ; import java . util . Scanner ; public class Cookie { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" jam . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" jam . out \" ) ) ; int cases ; cases = sc . nextInt ( ) ; for ( int z = 1 ; z <= cases ; z ++ ) { double C = sc . nextDouble ( ) ; double F = sc . nextDouble ( ) ; double X = sc . nextDouble ( ) ; double product = 2 ; double ans = 0 ; while ( X / ( product + F ) + C / product < X / product ) { ans += C / product ; product += F ; } ans += X / product ; bw . write ( \" Case \u2581 # \" + z + \" : \u2581 \" ) ; DecimalFormat df = new DecimalFormat ( \"0.00000000\" ) ; bw . write ( \" \" + df . format ( ans ) + \" \\n \" ) ; } sc . close ( ) ; bw . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" jam . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" jam . out \" ) ) ; int cases ; cases = sc . nextInt ( ) ; for ( int z = 1 ; z <= cases ; z ++ ) { double C = sc . nextDouble ( ) ; double F = sc . nextDouble ( ) ; double X = sc . nextDouble ( ) ; double product = 2 ; double ans = 0 ; while ( X / ( product + F ) + C / product < X / product ) { ans += C / product ; product += F ; } ans += X / product ; bw . write ( \" Case \u2581 # \" + z + \" : \u2581 \" ) ; DecimalFormat df = new DecimalFormat ( \"0.00000000\" ) ; bw . write ( \" \" + df . format ( ans ) + \" \\n \" ) ; } sc . close ( ) ; bw . close ( ) ; }"]], "functions_class": []}, {"id": "10", "code": "package con2014Q ; import java . io . * ; import java . util . * ; public class B { private static final String islarge = \" - large \" ; private static final String fileName = \" results / con2014Q / \" + B . class . getSimpleName ( ) . toLowerCase ( ) + islarge ; private static final String inputFileName = fileName + \" . in \" ; private static final String outputFileName = fileName + \" . out \" ; private static Scanner in ; private static PrintWriter out ; private void solve ( ) { double C = Double . parseDouble ( in . next ( ) ) , F = Double . parseDouble ( in . next ( ) ) , X = Double . parseDouble ( in . next ( ) ) ; double best = X / 2 ; double cur = 0 ; int a_farms = 0 ; while ( cur < best ) { cur += C / ( 2 + ( a_farms * F ) ) ; a_farms ++ ; best = Math . min ( best , cur + ( X / ( 2 + ( a_farms * F ) ) ) ) ; } out . format ( \" % .7f % n \" , best ) ; } public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; long start = System . currentTimeMillis ( ) ; in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new B ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; long stop = System . currentTimeMillis ( ) ; System . out . println ( stop - start + \" \u2581 ms \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { Locale . setDefault ( Locale . US ) ; long start = System . currentTimeMillis ( ) ; in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new B ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; long stop = System . currentTimeMillis ( ) ; System . out . println ( stop - start + \" \u2581 ms \" ) ; }"]], "functions_class": [["solve", "private void solve ( ) { double C = Double . parseDouble ( in . next ( ) ) , F = Double . parseDouble ( in . next ( ) ) , X = Double . parseDouble ( in . next ( ) ) ; double best = X / 2 ; double cur = 0 ; int a_farms = 0 ; while ( cur < best ) { cur += C / ( 2 + ( a_farms * F ) ) ; a_farms ++ ; best = Math . min ( best , cur + ( X / ( 2 + ( a_farms * F ) ) ) ) ; } out . format ( \" % .7f % n \" , best ) ; }"]]}, {"id": "13", "code": "import java . io . File ; import java . io . PrintStream ; import java . util . Scanner ; public class B { static final Boolean SAMPLE = false ; static final String PROBLEM = \" B \" ; static final String INPUT = \" large \" ; static final String ID = \"0\" ; static final String PATH = \" F : \\\\ software \u2581 installation \\\\ codejam - commandline - 1.2 - beta1 \\\\ source \\ \\\" ; public static void main ( String args [ ] ) throws Throwable { Scanner in = SAMPLE ? new Scanner ( System . in ) : new Scanner ( new File ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . in \" ) ) ; PrintStream out = SAMPLE ? System . out : new PrintStream ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . out \" ) ; int test = in . nextInt ( ) ; for ( int t = 1 ; t <= test ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; double C = in . nextDouble ( ) ; double F = in . nextDouble ( ) ; double X = in . nextDouble ( ) ; double time = 0 ; double speed = 2 ; while ( X / speed > C / speed + X / ( speed + F ) ) { time += C / speed ; speed += F ; } time += X / speed ; out . println ( time ) ; } out . close ( ) ; in . close ( ) ; System . out . println ( \" finish ! \" ) ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) throws Throwable { Scanner in = SAMPLE ? new Scanner ( System . in ) : new Scanner ( new File ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . in \" ) ) ; PrintStream out = SAMPLE ? System . out : new PrintStream ( PATH + PROBLEM + \" - \" + INPUT + \" - \" + ID + \" . out \" ) ; int test = in . nextInt ( ) ; for ( int t = 1 ; t <= test ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; double C = in . nextDouble ( ) ; double F = in . nextDouble ( ) ; double X = in . nextDouble ( ) ; double time = 0 ; double speed = 2 ; while ( X / speed > C / speed + X / ( speed + F ) ) { time += C / speed ; speed += F ; } time += X / speed ; out . println ( time ) ; } out . close ( ) ; in . close ( ) ; System . out . println ( \" finish ! \" ) ; }"]], "functions_class": []}, {"id": "3", "code": "package exoB ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ExoB { public static void main ( String [ ] args ) { String base = \" / home / jean / gcj2014 / q / ExoB / \" ; String input = base + \" b1 . in \" ; String output = base + \" b1 . out \" ; try { Scanner sc = new Scanner ( new FileReader ( input ) ) ; PrintWriter pw = new PrintWriter ( output ) ; int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( ExoB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } private static void test ( Scanner sc , PrintWriter pw ) { double C = sc . nextDouble ( ) ; double F = sc . nextDouble ( ) ; double X = sc . nextDouble ( ) ; double r = 2.0 ; double t = 0.0 ; while ( X / r > C / r + X / ( r + F ) ) { t = t + C / r ; r += F ; } t = t + X / r ; pw . print ( t ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { String base = \" / home / jean / gcj2014 / q / ExoB / \" ; String input = base + \" b1 . in \" ; String output = base + \" b1 . out \" ; try { Scanner sc = new Scanner ( new FileReader ( input ) ) ; PrintWriter pw = new PrintWriter ( output ) ; int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( ExoB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"], ["test", "private static void test ( Scanner sc , PrintWriter pw ) { double C = sc . nextDouble ( ) ; double F = sc . nextDouble ( ) ; double X = sc . nextDouble ( ) ; double r = 2.0 ; double t = 0.0 ; while ( X / r > C / r + X / ( r + F ) ) { t = t + C / r ; r += F ; } t = t + X / r ; pw . print ( t ) ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "def bestCookieTime ( c , f , x ) : NEW_LINE INDENT zero_time = cookieTime ( c , f , x , 0 ) NEW_LINE best_time = zero_time NEW_LINE total_farms = 1000 NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 1000 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT total_farms -= 1900 NEW_LINE if total_farms < 10 : NEW_LINE INDENT total_farms = 10 NEW_LINE DEDENT best_time = zero_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 100 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT total_farms -= 190 NEW_LINE if total_farms < 10 : NEW_LINE INDENT total_farms = 10 NEW_LINE DEDENT best_time = zero_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 10 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT total_farms -= 19 NEW_LINE if total_farms < 1 : NEW_LINE INDENT total_farms = 1 NEW_LINE DEDENT best_time = zero_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 1 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT return str ( best_time ) NEW_LINE DEDENT def cookieTime ( c , f , x , total_farms ) : NEW_LINE INDENT if x < c : NEW_LINE INDENT return x / 2 NEW_LINE DEDENT farms = 0 NEW_LINE time = 0 NEW_LINE cookie_rate = 2 NEW_LINE while farms < total_farms : NEW_LINE INDENT time += c / cookie_rate NEW_LINE cookie_rate += f NEW_LINE farms += 1 NEW_LINE DEDENT return time + x / cookie_rate NEW_LINE DEDENT input_text = open ( \" input . in \" ) NEW_LINE lines = input_text . readlines ( ) NEW_LINE input_text . close ( ) NEW_LINE with open ( \" output \" , \" a \" ) as outputfile : NEW_LINE INDENT for num in range ( 0 , int ( lines [ 0 ] ) ) : NEW_LINE INDENT line = lines [ num + 1 ] . split ( \" \u2581 \" ) NEW_LINE outputfile . write ( \" Case \u2581 # \" + str ( num + 1 ) + \" : \u2581 \" + bestCookieTime ( float ( line [ 0 ] ) , float ( line [ 1 ] ) , float ( line [ 2 ] ) ) + \" \\n \" ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["bestCookieTime", "def bestCookieTime ( c , f , x ) : NEW_LINE INDENT zero_time = cookieTime ( c , f , x , 0 ) NEW_LINE best_time = zero_time NEW_LINE total_farms = 1000 NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 1000 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT total_farms -= 1900 NEW_LINE if total_farms < 10 : NEW_LINE INDENT total_farms = 10 NEW_LINE DEDENT best_time = zero_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 100 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT total_farms -= 190 NEW_LINE if total_farms < 10 : NEW_LINE INDENT total_farms = 10 NEW_LINE DEDENT best_time = zero_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 10 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT total_farms -= 19 NEW_LINE if total_farms < 1 : NEW_LINE INDENT total_farms = 1 NEW_LINE DEDENT best_time = zero_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE while new_time < best_time : NEW_LINE INDENT total_farms += 1 NEW_LINE best_time = new_time NEW_LINE new_time = cookieTime ( c , f , x , total_farms ) NEW_LINE DEDENT return str ( best_time ) NEW_LINE DEDENT"], ["cookieTime", "def cookieTime ( c , f , x , total_farms ) : NEW_LINE INDENT if x < c : NEW_LINE INDENT return x / 2 NEW_LINE DEDENT farms = 0 NEW_LINE time = 0 NEW_LINE cookie_rate = 2 NEW_LINE while farms < total_farms : NEW_LINE INDENT time += c / cookie_rate NEW_LINE cookie_rate += f NEW_LINE farms += 1 NEW_LINE DEDENT return time + x / cookie_rate NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import math NEW_LINE input_file_name = ' . / B - large . in ' NEW_LINE output_file_name = ' . / B - large . out ' NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input_file = open ( input_file_name , ' r ' ) NEW_LINE output_file = open ( output_file_name , ' w ' ) NEW_LINE file_line = input_file . readline ( ) NEW_LINE file_line = file_line . replace ( ' \\n ' , ' ' ) NEW_LINE num_cases = int ( file_line ) NEW_LINE case_num = 1 NEW_LINE while True : NEW_LINE INDENT file_line = input_file . readline ( ) NEW_LINE if file_line == ' ' or file_line == ' \\n ' : NEW_LINE INDENT input_file . close ( ) NEW_LINE break NEW_LINE DEDENT file_line = file_line . replace ( ' \\n ' , ' ' ) NEW_LINE file_line_list = file_line . split ( ) NEW_LINE C = float ( file_line_list [ 0 ] ) NEW_LINE F = float ( file_line_list [ 1 ] ) NEW_LINE X = float ( file_line_list [ 2 ] ) NEW_LINE if C >= X : NEW_LINE INDENT total_time = X / 2.0 NEW_LINE DEDENT else : NEW_LINE INDENT n = max ( 0.0 , float ( math . floor ( ( F * X - 2.0 * C ) / ( C * F ) ) ) ) NEW_LINE total_time = 0.0 NEW_LINE for n_i in range ( int ( n ) ) : NEW_LINE INDENT total_time += C / ( 2.0 + n_i * F ) NEW_LINE DEDENT total_time += X / ( 2.0 + n * F ) NEW_LINE DEDENT output_file . write ( ' Case \u2581 # ' + str ( case_num ) + ' : \u2581 % 0.7f \\n ' % total_time ) NEW_LINE print ( case_num ) NEW_LINE case_num += 1 NEW_LINE DEDENT output_file . close ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE import itertools NEW_LINE from operator import itemgetter NEW_LINE import bisect NEW_LINE import math NEW_LINE import copy NEW_LINE from fractions import gcd NEW_LINE from utilities import * NEW_LINE sys . setrecursionlimit ( 1000 ) NEW_LINE Prep = [ ] NEW_LINE def preprocess ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT def readinput ( Input ) : NEW_LINE INDENT C , F , X = Input . readfloats ( ) NEW_LINE return C , F , X NEW_LINE DEDENT def solve ( Problem , Prep ) : NEW_LINE INDENT C , F , X = Problem NEW_LINE S = 2.0 NEW_LINE Farms = 0.0 NEW_LINE Time = 0.0 NEW_LINE cookies = 0.0 NEW_LINE while True : NEW_LINE INDENT timeToNewFarm = C / S NEW_LINE timeToFinish = X / S NEW_LINE if timeToFinish < timeToNewFarm : NEW_LINE INDENT return \" % .7f \" % ( Time + timeToFinish ) NEW_LINE DEDENT timeDiff = timeToFinish - timeToNewFarm NEW_LINE if timeDiff * F < C : NEW_LINE INDENT return \" % .7f \" % ( Time + timeToFinish ) NEW_LINE DEDENT Time += timeToNewFarm NEW_LINE S += F NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT doit ( preprocess , readinput , solve , MultiCore = True , Verify = False , Input = LARGE , Filename = None , Problem = \" B \" , Attempt = 0 ) NEW_LINE DEDENT", "functions_standalone": [["preprocess", "def preprocess ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT"], ["readinput", "def readinput ( Input ) : NEW_LINE INDENT C , F , X = Input . readfloats ( ) NEW_LINE return C , F , X NEW_LINE DEDENT"], ["solve", "def solve ( Problem , Prep ) : NEW_LINE INDENT C , F , X = Problem NEW_LINE S = 2.0 NEW_LINE Farms = 0.0 NEW_LINE Time = 0.0 NEW_LINE cookies = 0.0 NEW_LINE while True : NEW_LINE INDENT timeToNewFarm = C / S NEW_LINE timeToFinish = X / S NEW_LINE if timeToFinish < timeToNewFarm : NEW_LINE INDENT return \" % .7f \" % ( Time + timeToFinish ) NEW_LINE DEDENT timeDiff = timeToFinish - timeToNewFarm NEW_LINE if timeDiff * F < C : NEW_LINE INDENT return \" % .7f \" % ( Time + timeToFinish ) NEW_LINE DEDENT Time += timeToNewFarm NEW_LINE S += F NEW_LINE DEDENT return 0 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "inputFile = open ( ' B - large . in ' , ' r ' ) NEW_LINE lines = inputFile . readlines ( ) NEW_LINE inputFile . close ( ) NEW_LINE outputFile = open ( ' B - large . out ' , ' w ' ) NEW_LINE numTests = int ( lines [ 0 ] ) NEW_LINE def solveCookies ( c , f , x ) : NEW_LINE INDENT accumTime = 0 NEW_LINE farmRate = 0 NEW_LINE while True : NEW_LINE INDENT timeToWait = x / ( 2.0 + farmRate ) NEW_LINE timeIfBuyFarm = ( c / ( 2.0 + farmRate ) + x / ( 2.0 + farmRate + f ) ) NEW_LINE if timeToWait <= timeIfBuyFarm : NEW_LINE INDENT return accumTime + timeToWait NEW_LINE DEDENT else : NEW_LINE INDENT accumTime += c / ( 2.0 + farmRate ) NEW_LINE farmRate += f NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , numTests + 1 ) : NEW_LINE INDENT [ c , f , x ] = map ( lambda x : float ( x ) , lines [ i ] . split ( ) ) NEW_LINE outputFile . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 ' + str ( solveCookies ( c , f , x ) ) + ' \\n ' ) NEW_LINE DEDENT outputFile . close ( ) NEW_LINE", "functions_standalone": [["solveCookies", "def solveCookies ( c , f , x ) : NEW_LINE INDENT accumTime = 0 NEW_LINE farmRate = 0 NEW_LINE while True : NEW_LINE INDENT timeToWait = x / ( 2.0 + farmRate ) NEW_LINE timeIfBuyFarm = ( c / ( 2.0 + farmRate ) + x / ( 2.0 + farmRate + f ) ) NEW_LINE if timeToWait <= timeIfBuyFarm : NEW_LINE INDENT return accumTime + timeToWait NEW_LINE DEDENT else : NEW_LINE INDENT accumTime += c / ( 2.0 + farmRate ) NEW_LINE farmRate += f NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "10", "code": "def reader ( f ) : NEW_LINE INDENT f = open ( f ) NEW_LINE for line in f : NEW_LINE INDENT yield line . strip ( ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT def write ( f , lst ) : NEW_LINE INDENT for i in xrange ( len ( lst ) ) : NEW_LINE INDENT lst [ i ] = \" Case \u2581 # % s : \u2581 % s \" % ( i + 1 , lst [ i ] ) NEW_LINE DEDENT f = open ( f , ' w ' ) NEW_LINE f . write ( ' \\n ' . join ( lst ) ) NEW_LINE f . close ( ) NEW_LINE DEDENT", "functions_standalone": [["reader", "def reader ( f ) : NEW_LINE INDENT f = open ( f ) NEW_LINE for line in f : NEW_LINE INDENT yield line . strip ( ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_11", "java": [{"id": "12", "code": "package round1a ; import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; public class A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; Set < Long > need = new HashSet < Long > ( ) , have = new HashSet < Long > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { String tmp = sc . next ( ) ; long tmp2 = 0 ; for ( int j = 0 ; j < L ; j ++ ) if ( tmp . charAt ( j ) == '1' ) tmp2 |= ( 1L << j ) ; have . add ( tmp2 ) ; } long lastNeeded = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String tmp = sc . next ( ) ; long tmp2 = 0 ; for ( int j = 0 ; j < L ; j ++ ) if ( tmp . charAt ( j ) == '1' ) tmp2 |= ( 1L << j ) ; need . add ( tmp2 ) ; lastNeeded = tmp2 ; } int ans = L + 1 ; for ( Long elem : have ) { long flip = lastNeeded ^ elem ; Set < Long > got = new HashSet < Long > ( ) ; for ( Long e : need ) { got . add ( e ^ flip ) ; } if ( got . equals ( have ) ) { ans = Math . min ( ans , Long . bitCount ( flip ) ) ; } } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ( ans > L ? \" NOT \u2581 POSSIBLE \" : ans ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; for ( int caze = 1 ; caze <= cases ; caze ++ ) { int N = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; Set < Long > need = new HashSet < Long > ( ) , have = new HashSet < Long > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { String tmp = sc . next ( ) ; long tmp2 = 0 ; for ( int j = 0 ; j < L ; j ++ ) if ( tmp . charAt ( j ) == '1' ) tmp2 |= ( 1L << j ) ; have . add ( tmp2 ) ; } long lastNeeded = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String tmp = sc . next ( ) ; long tmp2 = 0 ; for ( int j = 0 ; j < L ; j ++ ) if ( tmp . charAt ( j ) == '1' ) tmp2 |= ( 1L << j ) ; need . add ( tmp2 ) ; lastNeeded = tmp2 ; } int ans = L + 1 ; for ( Long elem : have ) { long flip = lastNeeded ^ elem ; Set < Long > got = new HashSet < Long > ( ) ; for ( Long e : need ) { got . add ( e ^ flip ) ; } if ( got . equals ( have ) ) { ans = Math . min ( ans , Long . bitCount ( flip ) ) ; } } System . out . println ( \" Case \u2581 # \" + caze + \" : \u2581 \" + ( ans > L ? \" NOT \u2581 POSSIBLE \" : ans ) ) ; } }"]], "functions_class": []}, {"id": "1", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Scanner ; public class ChargingChaos { public static void main ( String [ ] Args ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( \" A - large \u2581 ( 1 ) . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" things . out \" ) ) ; int t = sc . nextInt ( ) , cc = 0 ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int l = sc . nextInt ( ) ; long [ ] things = new long [ n ] ; long [ ] things2 = new long [ n ] ; HashSet < Long > hs = new HashSet < Long > ( ) ; for ( int k = 0 ; k < n ; k ++ ) things [ k ] = make ( sc . next ( ) ) ; for ( int k = 0 ; k < n ; k ++ ) { things2 [ k ] = make ( sc . next ( ) ) ; hs . add ( things2 [ k ] ) ; } int ans = l + 1 ; for ( int k = 0 ; k < n ; k ++ ) { long swit = things [ 0 ] ^ things2 [ k ] ; boolean good = true ; for ( int j = 0 ; good && j < n ; j ++ ) if ( ! hs . contains ( things [ j ] ^ swit ) ) good = false ; if ( good ) ans = Math . min ( Long . bitCount ( swit ) , ans ) ; } if ( ans != l + 1 ) out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , ++ cc , ans ) ; else out . printf ( \" Case \u2581 # % d : \u2581 NOT \u2581 POSSIBLE % n \" , ++ cc ) ; } out . close ( ) ; } private static long make ( String s ) { return Long . parseLong ( s , 2 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] Args ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( \" A - large \u2581 ( 1 ) . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" things . out \" ) ) ; int t = sc . nextInt ( ) , cc = 0 ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int l = sc . nextInt ( ) ; long [ ] things = new long [ n ] ; long [ ] things2 = new long [ n ] ; HashSet < Long > hs = new HashSet < Long > ( ) ; for ( int k = 0 ; k < n ; k ++ ) things [ k ] = make ( sc . next ( ) ) ; for ( int k = 0 ; k < n ; k ++ ) { things2 [ k ] = make ( sc . next ( ) ) ; hs . add ( things2 [ k ] ) ; } int ans = l + 1 ; for ( int k = 0 ; k < n ; k ++ ) { long swit = things [ 0 ] ^ things2 [ k ] ; boolean good = true ; for ( int j = 0 ; good && j < n ; j ++ ) if ( ! hs . contains ( things [ j ] ^ swit ) ) good = false ; if ( good ) ans = Math . min ( Long . bitCount ( swit ) , ans ) ; } if ( ans != l + 1 ) out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , ++ cc , ans ) ; else out . printf ( \" Case \u2581 # % d : \u2581 NOT \u2581 POSSIBLE % n \" , ++ cc ) ; } out . close ( ) ; }"], ["make", "private static long make ( String s ) { return Long . parseLong ( s , 2 ) ; }"]], "functions_class": []}, {"id": "17", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class Ae { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new Ae ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; } private String solve ( Scanner in ) { int n = in . nextInt ( ) ; int l = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( in . next ( ) , 2 ) ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = Integer . parseInt ( in . next ( ) , 2 ) ; } int res = l + 1 ; Arrays . sort ( a ) ; for ( int m = 0 ; m < ( 1 << l ) ; m ++ ) { for ( int i = 0 ; i < n ; i ++ ) { b [ i ] ^= m ; } Arrays . sort ( b ) ; boolean ok = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { ok = false ; break ; } } if ( ok ) { res = Math . min ( res , Integer . bitCount ( m ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] ^= m ; } } return res > l ? \" NOT \u2581 POSSIBLE \" : ( \" \" + res ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + new Ae ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; }"]], "functions_class": [["solve", "private String solve ( Scanner in ) { int n = in . nextInt ( ) ; int l = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( in . next ( ) , 2 ) ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = Integer . parseInt ( in . next ( ) , 2 ) ; } int res = l + 1 ; Arrays . sort ( a ) ; for ( int m = 0 ; m < ( 1 << l ) ; m ++ ) { for ( int i = 0 ; i < n ; i ++ ) { b [ i ] ^= m ; } Arrays . sort ( b ) ; boolean ok = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { ok = false ; break ; } } if ( ok ) { res = Math . min ( res , Integer . bitCount ( m ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] ^= m ; } } return res > l ? \" NOT \u2581 POSSIBLE \" : ( \" \" + res ) ; }"]]}], "python": [{"id": "8", "code": "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , L = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE a = sorted ( int ( i , 2 ) for i in input ( ) . split ( ) ) NEW_LINE b = sorted ( int ( i , 2 ) for i in input ( ) . split ( ) ) NEW_LINE ans = L + 1 NEW_LINE for i in b : NEW_LINE INDENT if sorted ( a [ 0 ] ^ i ^ j for j in a ) == b : NEW_LINE INDENT ans = min ( ans , bin ( a [ 0 ] ^ i ) . count ( '1' ) ) NEW_LINE DEDENT DEDENT if ans == L + 1 : NEW_LINE INDENT ans = ' NOT \u2581 POSSIBLE ' NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "14", "code": "fin = open ( ' A - large . in ' , ' r ' ) NEW_LINE fout = open ( ' out . txt ' , ' w ' ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for casecount in range ( 1 , t + 1 ) : NEW_LINE INDENT n , l = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE outlet = [ list ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE device = [ list ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE device . sort ( ) NEW_LINE smallest = 41 NEW_LINE for func in range ( 0 , n ) : NEW_LINE INDENT switch = [ ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if outlet [ 0 ] [ i ] != device [ func ] [ i ] : NEW_LINE INDENT switch . append ( i ) NEW_LINE DEDENT DEDENT output = [ ] NEW_LINE for x in outlet : NEW_LINE INDENT x1 = x . copy ( ) NEW_LINE for y in switch : NEW_LINE INDENT if x1 [ y ] == '0' : NEW_LINE INDENT x1 [ y ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT x1 [ y ] = '0' NEW_LINE DEDENT DEDENT output . append ( x1 ) NEW_LINE DEDENT output . sort ( ) NEW_LINE if smallest > len ( switch ) and output == device : NEW_LINE INDENT smallest = len ( switch ) NEW_LINE DEDENT DEDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % casecount ) NEW_LINE if smallest == 41 : NEW_LINE INDENT fout . write ( ' NOT \u2581 POSSIBLE \\n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT fout . write ( ' % d \\n ' % smallest ) NEW_LINE DEDENT DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}, {"id": "5", "code": "import sys NEW_LINE fin = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fout = open ( \" p1 . out \" , \" w \" ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE def conv ( s ) : NEW_LINE INDENT return int ( s , 2 ) NEW_LINE DEDENT for i in range ( T ) : NEW_LINE INDENT N , L = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE ans = L + 1 NEW_LINE device = sorted ( map ( conv , fin . readline ( ) . split ( ) ) ) NEW_LINE outlet = map ( conv , fin . readline ( ) . split ( ) ) NEW_LINE for j in range ( len ( outlet ) ) : NEW_LINE INDENT bits = device [ 0 ] ^ outlet [ j ] NEW_LINE def flip ( t ) : NEW_LINE INDENT return t ^ bits NEW_LINE DEDENT new_out = sorted ( map ( flip , outlet ) ) NEW_LINE if new_out == device : NEW_LINE INDENT ans = min ( ans , bin ( bits ) . count ( \"1\" ) ) NEW_LINE DEDENT DEDENT fout . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" ) NEW_LINE if ans == L + 1 : NEW_LINE INDENT fout . write ( \" NOT \u2581 POSSIBLE \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT fout . write ( str ( ans ) + \" \\n \" ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["conv", "def conv ( s ) : NEW_LINE INDENT return int ( s , 2 ) NEW_LINE DEDENT"], ["flip", "def flip ( t ) : NEW_LINE INDENT return t ^ bits NEW_LINE DEDENT"]], "functions_class": []}, {"id": "16", "code": "def reader ( f ) : NEW_LINE INDENT f = open ( f ) NEW_LINE for line in f : NEW_LINE INDENT yield line . strip ( ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT def write ( f , lst ) : NEW_LINE INDENT for i in xrange ( len ( lst ) ) : NEW_LINE INDENT lst [ i ] = \" Case \u2581 # % s : \u2581 % s \" % ( i + 1 , lst [ i ] ) NEW_LINE DEDENT f = open ( f , ' w ' ) NEW_LINE f . write ( ' \\n ' . join ( lst ) ) NEW_LINE f . close ( ) NEW_LINE DEDENT", "functions_standalone": [["reader", "def reader ( f ) : NEW_LINE INDENT f = open ( f ) NEW_LINE for line in f : NEW_LINE INDENT yield line . strip ( ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "12", "code": "def flips ( a , b ) : NEW_LINE INDENT result = ' ' NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT result += '0' if a [ i ] == b [ i ] else '1' NEW_LINE DEDENT return result NEW_LINE DEDENT def flop ( a , b ) : NEW_LINE INDENT result = ' ' NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT result += a [ i ] if b [ i ] == '0' else '1' if a [ i ] == '0' else '0' NEW_LINE DEDENT return result NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT N , L = map ( int , input ( ) . split ( ) ) NEW_LINE start = input ( ) . split ( ) NEW_LINE goal = input ( ) . split ( ) NEW_LINE minimum = 1000 NEW_LINE first = start [ 0 ] NEW_LINE for g in goal : NEW_LINE INDENT flip = flips ( g , first ) NEW_LINE popcount = flip . count ( '1' ) NEW_LINE if popcount < minimum : NEW_LINE INDENT outlets = set ( start ) NEW_LINE devices = set ( map ( lambda a : flop ( a , flip ) , goal ) ) NEW_LINE if outlets == devices : NEW_LINE INDENT minimum = popcount NEW_LINE DEDENT DEDENT DEDENT result = 0 NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( t + 1 , minimum if minimum != 1000 else ' NOT \u2581 POSSIBLE ' ) ) NEW_LINE DEDENT", "functions_standalone": [["flips", "def flips ( a , b ) : NEW_LINE INDENT result = ' ' NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT result += '0' if a [ i ] == b [ i ] else '1' NEW_LINE DEDENT return result NEW_LINE DEDENT"], ["flop", "def flop ( a , b ) : NEW_LINE INDENT result = ' ' NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT result += a [ i ] if b [ i ] == '0' else '1' if a [ i ] == '0' else '0' NEW_LINE DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_42", "java": [{"id": "19", "code": "import java . util . * ; import java . io . * ; import java . math . * ; import static java . lang . Math . * ; import static java . lang . Integer . * ; import static java . lang . System . * ; public class B { public static String [ ] parts ( BufferedReader br ) throws Exception { String line = br . readLine ( ) ; if ( line == null ) return null ; return line . trim ( ) . split ( \" \\\\ s + \" ) ; } public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int cas = parseInt ( br . readLine ( ) ) ; for ( int z = 1 ; z <= cas ; z ++ ) { int n = parseInt ( br . readLine ( ) ) ; String [ ] ss = parts ( br ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = parseInt ( ss [ i ] ) ; int [ ] cl = new int [ n ] ; int [ ] cr = new int [ n ] ; HashMap < Integer , Integer > where = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { where . put ( arr [ i ] , i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( i < j && arr [ j ] > arr [ i ] ) cl [ i ] ++ ; if ( i > j && arr [ j ] > arr [ i ] ) cr [ i ] ++ ; } } int ans = 0 ; Arrays . sort ( arr ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = arr [ i ] ; int j = where . get ( x ) ; ans += min ( cl [ j ] , cr [ j ] ) ; } out . println ( \" Case \u2581 # \" + z + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["parts", "public static String [ ] parts ( BufferedReader br ) throws Exception { String line = br . readLine ( ) ; if ( line == null ) return null ; return line . trim ( ) . split ( \" \\\\ s + \" ) ; }"], ["main", "public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int cas = parseInt ( br . readLine ( ) ) ; for ( int z = 1 ; z <= cas ; z ++ ) { int n = parseInt ( br . readLine ( ) ) ; String [ ] ss = parts ( br ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = parseInt ( ss [ i ] ) ; int [ ] cl = new int [ n ] ; int [ ] cr = new int [ n ] ; HashMap < Integer , Integer > where = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { where . put ( arr [ i ] , i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( i < j && arr [ j ] > arr [ i ] ) cl [ i ] ++ ; if ( i > j && arr [ j ] > arr [ i ] ) cr [ i ] ++ ; } } int ans = 0 ; Arrays . sort ( arr ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = arr [ i ] ; int j = where . get ( x ) ; ans += min ( cl [ j ] , cr [ j ] ) ; } out . println ( \" Case \u2581 # \" + z + \" : \u2581 \" + ans ) ; } }"]], "functions_class": []}, {"id": "15", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . util . Scanner ; public class UpAndDown { private static Scanner input ; private static PrintWriter out ; public static void main ( String [ ] args ) throws Exception { input = new Scanner ( new FileReader ( \" B - large . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" B - large . out \" ) ) ; int testCases = input . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + solveCase ( ) ) ; } out . close ( ) ; } public static int solveCase ( ) { int n = input . nextInt ( ) ; int [ ] values = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { values [ i ] = input . nextInt ( ) ; } boolean [ ] done = new boolean [ n ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! done [ j ] && ( index == - 1 || values [ j ] < values [ index ] ) ) index = j ; } int left = 0 , right = 0 ; for ( int j = 0 ; j < index ; j ++ ) if ( ! done [ j ] ) left ++ ; for ( int j = index + 1 ; j < n ; j ++ ) if ( ! done [ j ] ) right ++ ; res += Math . min ( left , right ) ; done [ index ] = true ; } return res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { input = new Scanner ( new FileReader ( \" B - large . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" B - large . out \" ) ) ; int testCases = input . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + solveCase ( ) ) ; } out . close ( ) ; }"], ["solveCase", "public static int solveCase ( ) { int n = input . nextInt ( ) ; int [ ] values = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { values [ i ] = input . nextInt ( ) ; } boolean [ ] done = new boolean [ n ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! done [ j ] && ( index == - 1 || values [ j ] < values [ index ] ) ) index = j ; } int left = 0 , right = 0 ; for ( int j = 0 ; j < index ; j ++ ) if ( ! done [ j ] ) left ++ ; for ( int j = index + 1 ; j < n ; j ++ ) if ( ! done [ j ] ) right ++ ; res += Math . min ( left , right ) ; done [ index ] = true ; } return res ; }"]], "functions_class": []}, {"id": "0", "code": "import static java . lang . Math . * ; import static java . util . Arrays . * ; import java . io . * ; import java . util . * ; public class B { Scanner sc = new Scanner ( System . in ) ; int N ; int [ ] A ; void read ( ) { N = sc . nextInt ( ) ; A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = sc . nextInt ( ) ; } void solve ( ) { int num = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < N - i ; j ++ ) if ( A [ p ] > A [ j ] ) { p = j ; } num += min ( p , N - i - 1 - p ) ; for ( int j = p ; j < N - i - 1 ; j ++ ) A [ j ] = A [ j + 1 ] ; } System . out . println ( num ) ; } void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( B . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new B ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( B . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new B ( ) . run ( ) ; }"]], "functions_class": [["read", "void read ( ) { N = sc . nextInt ( ) ; A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = sc . nextInt ( ) ; }"], ["solve", "void solve ( ) { int num = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < N - i ; j ++ ) if ( A [ p ] > A [ j ] ) { p = j ; } num += min ( p , N - i - 1 - p ) ; for ( int j = p ; j < N - i - 1 ; j ++ ) A [ j ] = A [ j + 1 ] ; } System . out . println ( num ) ; }"], ["run", "void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}, {"id": "16", "code": "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class SolB3 { public static void main ( String [ ] args ) { try { new SolB3 ( ) . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public void run ( ) throws IOException { br = new BufferedReader ( new FileReader ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( FNAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } BufferedReader br ; PrintWriter out ; StringTokenizer st ; boolean eof ; String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \\n \\ t / \" ) ; } catch ( IOException e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } String FNAME = \" B - large \" ; void solve ( ) { int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextInt ( ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int imin = 0 ; for ( int j = 0 ; j < n - i ; j ++ ) { if ( a [ j ] < a [ imin ] ) { imin = j ; } } ans += Math . min ( imin , n - 1 - i - imin ) ; for ( int j = imin ; j < n - i - 1 ; j ++ ) { a [ j ] = a [ j + 1 ] ; } } out . println ( ans ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { new SolB3 ( ) . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": [["run", "public void run ( ) throws IOException { br = new BufferedReader ( new FileReader ( FNAME + \" . in \" ) ) ; out = new PrintWriter ( FNAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; }"], ["nextToken", "String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) , \" \u2581 \\n \\ t / \" ) ; } catch ( IOException e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; }"], ["solve", "void solve ( ) { int tests = nextInt ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; int n = nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextInt ( ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int imin = 0 ; for ( int j = 0 ; j < n - i ; j ++ ) { if ( a [ j ] < a [ imin ] ) { imin = j ; } } ans += Math . min ( imin , n - 1 - i - imin ) ; for ( int j = imin ; j < n - i - 1 ; j ++ ) { a [ j ] = a [ j + 1 ] ; } } out . println ( ans ) ; } }"]]}], "python": [{"id": "15", "code": "import sys NEW_LINE def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] < s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += min ( m , n - 1 - m ) NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ int ( y ) for y in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( ' Case \u2581 # % d : \u2581 % d ' % ( test_case , solve ( n , s ) ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] < s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += min ( m , n - 1 - m ) NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import io , sys NEW_LINE import datetime NEW_LINE fin = None NEW_LINE def solve ( ) : NEW_LINE INDENT n = num ( ) NEW_LINE a = nums ( ) NEW_LINE res = 0 NEW_LINE while a : NEW_LINE INDENT t = min ( a ) NEW_LINE idx = a . index ( t ) NEW_LINE res += min ( idx , len ( a ) - idx - 1 ) NEW_LINE a . remove ( t ) NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT fname = ' a . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . txt ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( ) : NEW_LINE INDENT n = num ( ) NEW_LINE a = nums ( ) NEW_LINE res = 0 NEW_LINE while a : NEW_LINE INDENT t = min ( a ) NEW_LINE idx = a . index ( t ) NEW_LINE res += min ( idx , len ( a ) - idx - 1 ) NEW_LINE a . remove ( t ) NEW_LINE DEDENT return res NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT fname = ' a . in ' NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT fname = sys . argv [ 1 ] NEW_LINE DEDENT global fin NEW_LINE fin = io . open ( fname ) NEW_LINE fout = io . open ( fname + ' . txt ' , ' w ' ) NEW_LINE t0 = datetime . datetime . now ( ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT fout . write ( ' Case \u2581 # % d : \u2581 ' % ( i + 1 ) ) NEW_LINE fout . write ( ' % s \\n ' % str ( solve ( ) ) ) NEW_LINE DEDENT print ( ' Time \u2581 = \u2581 % s ' % str ( datetime . datetime . now ( ) - t0 ) ) NEW_LINE fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE DEDENT"], ["nums", "def nums ( ) : NEW_LINE INDENT return [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["fnums", "def fnums ( ) : NEW_LINE INDENT return [ float ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE DEDENT"], ["num", "def num ( ) : NEW_LINE INDENT return int ( fin . readline ( ) ) NEW_LINE DEDENT"], ["sstrip", "def sstrip ( ) : NEW_LINE INDENT return fin . readline ( ) . strip ( ) NEW_LINE DEDENT"], ["strs", "def strs ( ) : NEW_LINE INDENT return fin . readline ( ) . split ( ) NEW_LINE DEDENT"], ["arrstr", "def arrstr ( a , sep = ' \u2581 ' ) : NEW_LINE INDENT return sep . join ( [ str ( x ) for x in a ] ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "def solve ( N , A ) : NEW_LINE INDENT count = 0 NEW_LINE while A : NEW_LINE INDENT size = len ( A ) NEW_LINE if size == 1 : break NEW_LINE m = min ( A ) NEW_LINE i = A . index ( m ) NEW_LINE if i < size - i - 1 : NEW_LINE INDENT count += i NEW_LINE DEDENT else : NEW_LINE INDENT count += size - i - 1 NEW_LINE DEDENT A . pop ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT def parse ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE return N , A NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT params = parse ( ) NEW_LINE result = solve ( * params ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % s ' % ( t , result ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( N , A ) : NEW_LINE INDENT count = 0 NEW_LINE while A : NEW_LINE INDENT size = len ( A ) NEW_LINE if size == 1 : break NEW_LINE m = min ( A ) NEW_LINE i = A . index ( m ) NEW_LINE if i < size - i - 1 : NEW_LINE INDENT count += i NEW_LINE DEDENT else : NEW_LINE INDENT count += size - i - 1 NEW_LINE DEDENT A . pop ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT"], ["parse", "def parse ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE return N , A NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT params = parse ( ) NEW_LINE result = solve ( * params ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % s ' % ( t , result ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "0", "code": "import sys NEW_LINE fin = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fout = open ( \" p2 . out \" , \" w \" ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT N = int ( fin . readline ( ) ) NEW_LINE A = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for j in xrange ( len ( A ) ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE for k in xrange ( len ( A ) ) : NEW_LINE INDENT if A [ k ] > A [ j ] : NEW_LINE INDENT if k < j : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT DEDENT ans += min ( l , r ) NEW_LINE DEDENT fout . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( ans ) + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "5", "code": "import sys NEW_LINE def rl ( T ) : NEW_LINE INDENT return list ( map ( T , input ( ) . split ( ) ) ) NEW_LINE DEDENT def up_solve ( A ) : NEW_LINE INDENT iv = 0 NEW_LINE n = len ( A ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ i ] > A [ j ] : NEW_LINE INDENT iv += 1 NEW_LINE DEDENT DEDENT DEDENT return iv NEW_LINE DEDENT def down_solve ( A ) : NEW_LINE INDENT return up_solve ( A [ : : - 1 ] ) NEW_LINE DEDENT def count_larger ( l , v ) : NEW_LINE INDENT return len ( [ _ for _ in l if _ > v ] ) NEW_LINE DEDENT def solve ( A ) : NEW_LINE INDENT return sum ( min ( count_larger ( A [ : i ] , A [ i ] ) , count_larger ( A [ i : ] , A [ i ] ) ) for i in range ( len ( A ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 100000 ) NEW_LINE T , = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT N , = rl ( int ) NEW_LINE A = rl ( int ) NEW_LINE ans = solve ( A ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % d ' % ( C , ans ) ) NEW_LINE DEDENT pass NEW_LINE DEDENT main ( ) NEW_LINE", "functions_standalone": [["rl", "def rl ( T ) : NEW_LINE INDENT return list ( map ( T , input ( ) . split ( ) ) ) NEW_LINE DEDENT"], ["up_solve", "def up_solve ( A ) : NEW_LINE INDENT iv = 0 NEW_LINE n = len ( A ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ i ] > A [ j ] : NEW_LINE INDENT iv += 1 NEW_LINE DEDENT DEDENT DEDENT return iv NEW_LINE DEDENT"], ["down_solve", "def down_solve ( A ) : NEW_LINE INDENT return up_solve ( A [ : : - 1 ] ) NEW_LINE DEDENT"], ["count_larger", "def count_larger ( l , v ) : NEW_LINE INDENT return len ( [ _ for _ in l if _ > v ] ) NEW_LINE DEDENT"], ["solve", "def solve ( A ) : NEW_LINE INDENT return sum ( min ( count_larger ( A [ : i ] , A [ i ] ) , count_larger ( A [ i : ] , A [ i ] ) ) for i in range ( len ( A ) ) ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 100000 ) NEW_LINE T , = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT N , = rl ( int ) NEW_LINE A = rl ( int ) NEW_LINE ans = solve ( A ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % d ' % ( C , ans ) ) NEW_LINE DEDENT pass NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_21", "java": [{"id": "9", "code": "import java . io . * ; import java . util . * ; class A { static int calc ( int [ ] q ) { int res = 1234567 ; for ( int a = 0 ; a <= 100 ; a ++ ) { int cur = 0 ; for ( int i = 0 ; i < q . length ; i ++ ) cur += Math . abs ( q [ i ] - a ) ; res = Math . min ( res , cur ) ; } return res ; } public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int numTests = sc . nextInt ( ) ; for ( int test = 1 ; test <= numTests ; test ++ ) { int n = sc . nextInt ( ) ; String must = \" \" ; int [ ] [ ] q = new int [ 111 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) + \" ? \" ; String t = \" \" ; int ind = 0 ; char c = ' ? ' ; int cnt = 1 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == c ) cnt ++ ; else { t += c ; q [ ind ] [ i ] = cnt ; cnt = 0 ; ind ++ ; c = s . charAt ( j ) ; } } if ( i == 0 ) must = t ; else if ( ! must . equals ( t ) ) must = \" ? \" ; } String lost = \" Fegla \u2581 Won \" ; if ( must . equals ( \" ? \" ) ) { System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + lost ) ; } else { int res = 0 ; for ( int i = 0 ; i < 111 ; i ++ ) res += calc ( q [ i ] ) ; System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + res ) ; } } } }", "functions_standalone": [["calc", "static int calc ( int [ ] q ) { int res = 1234567 ; for ( int a = 0 ; a <= 100 ; a ++ ) { int cur = 0 ; for ( int i = 0 ; i < q . length ; i ++ ) cur += Math . abs ( q [ i ] - a ) ; res = Math . min ( res , cur ) ; } return res ; }"], ["main", "public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int numTests = sc . nextInt ( ) ; for ( int test = 1 ; test <= numTests ; test ++ ) { int n = sc . nextInt ( ) ; String must = \" \" ; int [ ] [ ] q = new int [ 111 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) + \" ? \" ; String t = \" \" ; int ind = 0 ; char c = ' ? ' ; int cnt = 1 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == c ) cnt ++ ; else { t += c ; q [ ind ] [ i ] = cnt ; cnt = 0 ; ind ++ ; c = s . charAt ( j ) ; } } if ( i == 0 ) must = t ; else if ( ! must . equals ( t ) ) must = \" ? \" ; } String lost = \" Fegla \u2581 Won \" ; if ( must . equals ( \" ? \" ) ) { System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + lost ) ; } else { int res = 0 ; for ( int i = 0 ; i < 111 ; i ++ ) res += calc ( q [ i ] ) ; System . out . println ( \" Case \u2581 # \" + test + \" : \u2581 \" + res ) ; } } }"]], "functions_class": []}, {"id": "10", "code": "import java . util . Scanner ; public class A { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i , solve ( ) ) ; } } static String solve ( ) { int N = sc . nextInt ( ) ; String [ ] str = new String [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { str [ i ] = sc . next ( ) ; } int [ ] [ ] count = new int [ N ] [ 101 ] ; int [ ] pos = new int [ N ] ; for ( int i = 0 ; pos [ 0 ] < str [ 0 ] . length ( ) ; ++ i ) { char c = str [ 0 ] . charAt ( pos [ 0 ] ) ; for ( int j = 0 ; j < N ; ++ j ) { if ( pos [ j ] >= str [ j ] . length ( ) || str [ j ] . charAt ( pos [ j ] ) != c ) { return \" Fegla \u2581 Won \" ; } while ( pos [ j ] < str [ j ] . length ( ) && str [ j ] . charAt ( pos [ j ] ) == c ) { ++ pos [ j ] ; ++ count [ j ] [ i ] ; } } } for ( int i = 0 ; i < N ; ++ i ) { if ( pos [ i ] != str [ i ] . length ( ) ) { return \" Fegla \u2581 Won \" ; } } int ans = 0 ; for ( int i = 0 ; count [ 0 ] [ i ] > 0 ; ++ i ) { int min = 1 << 30 ; for ( int j = 1 ; j <= 100 ; ++ j ) { int sum = 0 ; for ( int k = 0 ; k < N ; ++ k ) { sum += Math . abs ( count [ k ] [ i ] - j ) ; } min = Math . min ( min , sum ) ; } ans += min ; } return \" \" + ans ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i , solve ( ) ) ; } }"], ["solve", "static String solve ( ) { int N = sc . nextInt ( ) ; String [ ] str = new String [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { str [ i ] = sc . next ( ) ; } int [ ] [ ] count = new int [ N ] [ 101 ] ; int [ ] pos = new int [ N ] ; for ( int i = 0 ; pos [ 0 ] < str [ 0 ] . length ( ) ; ++ i ) { char c = str [ 0 ] . charAt ( pos [ 0 ] ) ; for ( int j = 0 ; j < N ; ++ j ) { if ( pos [ j ] >= str [ j ] . length ( ) || str [ j ] . charAt ( pos [ j ] ) != c ) { return \" Fegla \u2581 Won \" ; } while ( pos [ j ] < str [ j ] . length ( ) && str [ j ] . charAt ( pos [ j ] ) == c ) { ++ pos [ j ] ; ++ count [ j ] [ i ] ; } } } for ( int i = 0 ; i < N ; ++ i ) { if ( pos [ i ] != str [ i ] . length ( ) ) { return \" Fegla \u2581 Won \" ; } } int ans = 0 ; for ( int i = 0 ; count [ 0 ] [ i ] > 0 ; ++ i ) { int min = 1 << 30 ; for ( int j = 1 ; j <= 100 ; ++ j ) { int sum = 0 ; for ( int k = 0 ; k < N ; ++ k ) { sum += Math . abs ( count [ k ] [ i ] - j ) ; } min = Math . min ( min , sum ) ; } ans += min ; } return \" \" + ans ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "import sys NEW_LINE from itertools import zip_longest as zip NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE def cost ( v ) : NEW_LINE INDENT v . sort ( ) NEW_LINE m = v [ len ( v ) // 2 ] NEW_LINE return sum ( abs ( i - m ) for i in v ) NEW_LINE DEDENT def partition ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( s ) and s [ i ] == s [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT yield ( s [ i ] , j - i ) NEW_LINE i = j NEW_LINE DEDENT DEDENT for t in range ( T ) : NEW_LINE INDENT N = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE ss = list ( sys . stdin . readline ( ) . strip ( ) for _ in range ( N ) ) NEW_LINE res = 0 NEW_LINE for items in zip ( * list ( partition ( s ) for s in ss ) ) : NEW_LINE INDENT if any ( i is None for i in items ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 Fegla \u2581 Won \" % ( t + 1 ) ) NEW_LINE break NEW_LINE DEDENT if any ( a != items [ 0 ] [ 0 ] for a , _ in items [ 1 : ] ) : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 Fegla \u2581 Won \" % ( t + 1 ) ) NEW_LINE break NEW_LINE DEDENT res += cost ( list ( b for _ , b in items ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( t + 1 , res ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["cost", "def cost ( v ) : NEW_LINE INDENT v . sort ( ) NEW_LINE m = v [ len ( v ) // 2 ] NEW_LINE return sum ( abs ( i - m ) for i in v ) NEW_LINE DEDENT"], ["partition", "def partition ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( s ) and s [ i ] == s [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT yield ( s [ i ] , j - i ) NEW_LINE i = j NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "19", "code": "def compress ( s ) : NEW_LINE INDENT t = [ ] NEW_LINE prev = ' # ' NEW_LINE for c in s : NEW_LINE INDENT if c != prev : NEW_LINE INDENT t . append ( c ) NEW_LINE DEDENT prev = c NEW_LINE DEDENT return t NEW_LINE DEDENT def extract ( s ) : NEW_LINE INDENT res = [ ] NEW_LINE prev = ' # ' NEW_LINE cnt = 1 NEW_LINE for c in s : NEW_LINE INDENT if c != prev and prev != ' # ' : NEW_LINE INDENT res . append ( cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT prev = c NEW_LINE DEDENT res . append ( cnt ) NEW_LINE return res NEW_LINE DEDENT for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT data . append ( list ( input ( ) ) ) NEW_LINE DEDENT compressed = compress ( data [ 0 ] ) NEW_LINE valid = True NEW_LINE for s in data : NEW_LINE INDENT if compressed != compress ( s ) : NEW_LINE INDENT valid = False NEW_LINE break NEW_LINE DEDENT DEDENT if not valid : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 Fegla \u2581 Won ' . format ( tc + 1 ) ) NEW_LINE continue NEW_LINE DEDENT ext = [ extract ( s ) for s in data ] NEW_LINE M = len ( ext [ 0 ] ) NEW_LINE res = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT res += min ( sum ( abs ( j - ext [ k ] [ i ] ) for k in range ( N ) ) for j in range ( 1 , 201 ) ) NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( tc + 1 , res ) ) NEW_LINE DEDENT", "functions_standalone": [["compress", "def compress ( s ) : NEW_LINE INDENT t = [ ] NEW_LINE prev = ' # ' NEW_LINE for c in s : NEW_LINE INDENT if c != prev : NEW_LINE INDENT t . append ( c ) NEW_LINE DEDENT prev = c NEW_LINE DEDENT return t NEW_LINE DEDENT"], ["extract", "def extract ( s ) : NEW_LINE INDENT res = [ ] NEW_LINE prev = ' # ' NEW_LINE cnt = 1 NEW_LINE for c in s : NEW_LINE INDENT if c != prev and prev != ' # ' : NEW_LINE INDENT res . append ( cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT prev = c NEW_LINE DEDENT res . append ( cnt ) NEW_LINE return res NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "file_in = open ( ' a . in ' , ' r ' ) NEW_LINE file_out = open ( ' a . out ' , ' w ' ) NEW_LINE n_case = int ( file_in . readline ( ) ) NEW_LINE class Word : NEW_LINE INDENT def __init__ ( self , s ) : NEW_LINE INDENT char = '0' NEW_LINE self . chars = [ ] NEW_LINE self . counts = [ ] NEW_LINE for c in s : NEW_LINE INDENT if c != char : NEW_LINE INDENT self . chars . append ( c ) NEW_LINE self . counts . append ( 1 ) NEW_LINE char = c NEW_LINE DEDENT else : NEW_LINE INDENT self . counts [ - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i_case in range ( n_case ) : NEW_LINE INDENT N = int ( file_in . readline ( ) ) NEW_LINE words = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT words . append ( Word ( file_in . readline ( ) . strip ( ) ) ) NEW_LINE DEDENT chars = words [ 0 ] . chars NEW_LINE def check_equal ( ) : NEW_LINE INDENT for word in words : NEW_LINE INDENT if word . chars != chars : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if not check_equal ( ) : NEW_LINE INDENT file_out . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( i_case + 1 , \" Fegla \u2581 Won \" ) ) NEW_LINE continue NEW_LINE DEDENT def median ( arr ) : NEW_LINE INDENT s = sorted ( arr ) NEW_LINE return s [ len ( s ) / 2 ] NEW_LINE DEDENT def actions_needed ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE med = median ( arr ) NEW_LINE for a in arr : NEW_LINE INDENT count += abs ( med - a ) NEW_LINE DEDENT return count NEW_LINE DEDENT actions = 0 NEW_LINE for i_char in range ( len ( chars ) ) : NEW_LINE INDENT arr = [ ] NEW_LINE for word in words : NEW_LINE INDENT arr . append ( word . counts [ i_char ] ) NEW_LINE DEDENT actions += actions_needed ( arr ) NEW_LINE DEDENT file_out . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( i_case + 1 , str ( actions ) ) ) NEW_LINE DEDENT file_in . close ( ) NEW_LINE file_out . close ( ) NEW_LINE", "functions_standalone": [["check_equal", "def check_equal ( ) : NEW_LINE INDENT for word in words : NEW_LINE INDENT if word . chars != chars : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT"], ["median", "def median ( arr ) : NEW_LINE INDENT s = sorted ( arr ) NEW_LINE return s [ len ( s ) / 2 ] NEW_LINE DEDENT"], ["actions_needed", "def actions_needed ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE med = median ( arr ) NEW_LINE for a in arr : NEW_LINE INDENT count += abs ( med - a ) NEW_LINE DEDENT return count NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self , s ) : NEW_LINE INDENT char = '0' NEW_LINE self . chars = [ ] NEW_LINE self . counts = [ ] NEW_LINE for c in s : NEW_LINE INDENT if c != char : NEW_LINE INDENT self . chars . append ( c ) NEW_LINE self . counts . append ( 1 ) NEW_LINE char = c NEW_LINE DEDENT else : NEW_LINE INDENT self . counts [ - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT"]]}, {"id": "3", "code": "import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ int ( x ) for x in xs ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ float ( x ) for x in xs ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE if len ( args ) == 1 : NEW_LINE INDENT infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE DEDENT elif len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] == ' - ' : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 args , \u2581 not \u2581 { : d } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["readline", "def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT"], ["readint", "def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readfloat", "def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT"], ["readints", "def readints ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ int ( x ) for x in xs ] NEW_LINE DEDENT"], ["readfloats", "def readfloats ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ float ( x ) for x in xs ] NEW_LINE DEDENT"], ["writeline", "def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT"], ["run", "def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE if len ( args ) == 1 : NEW_LINE INDENT infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE DEDENT elif len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] == ' - ' : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 args , \u2581 not \u2581 { : d } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "2", "code": "n = int ( input ( ) ) NEW_LINE for case_no in range ( 1 , n + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE words = [ input ( ) . strip ( ) for _ in range ( n ) ] NEW_LINE accs = [ ] NEW_LINE for word in words : NEW_LINE INDENT acc = [ ] NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT if i > 0 and word [ i ] == word [ i - 1 ] : NEW_LINE INDENT acc [ - 1 ] [ 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT acc . append ( [ word [ i ] , 1 ] ) NEW_LINE DEDENT DEDENT accs . append ( acc ) NEW_LINE DEDENT acclens = list ( map ( len , accs ) ) NEW_LINE fail = any ( [ x != acclens [ 0 ] for x in acclens ] ) NEW_LINE answer = 0 NEW_LINE if not fail : NEW_LINE INDENT for i in range ( acclens [ 0 ] ) : NEW_LINE INDENT if any ( [ accs [ 0 ] [ i ] [ 0 ] != acc [ i ] [ 0 ] for acc in accs ] ) : NEW_LINE INDENT fail = True NEW_LINE break NEW_LINE DEDENT nums = [ acc [ i ] [ 1 ] for acc in accs ] NEW_LINE nums . sort ( ) NEW_LINE total = 0 NEW_LINE for num in nums : NEW_LINE INDENT total += abs ( num - nums [ len ( nums ) // 2 ] ) NEW_LINE DEDENT answer += total NEW_LINE DEDENT DEDENT if fail : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( case_no ) + \" : \u2581 Fegla \u2581 Won \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( case_no ) + \" : \u2581 \" + str ( answer ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_14_31", "java": [{"id": "9", "code": "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class Solution { BufferedReader in ; PrintWriter out ; StringTokenizer st ; String nextToken ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( in . readLine ( ) ) ; } return st . nextToken ( ) ; } int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; } void solve ( ) throws IOException { st = new StringTokenizer ( in . readLine ( ) , \" / \" ) ; long p = nextLong ( ) ; long q = nextLong ( ) ; long gcd = BigInteger . valueOf ( p ) . gcd ( BigInteger . valueOf ( q ) ) . longValue ( ) ; long qq = q / gcd ; if ( ( qq & ( qq - 1 ) ) == 0 ) { p /= gcd ; int ans = 1 ; while ( p < qq / 2 ) { ans ++ ; qq /= 2 ; } out . println ( ans ) ; } else { out . println ( \" impossible \" ) ; } } void run ( ) { try { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; Locale . setDefault ( Locale . UK ) ; int tt = nextInt ( ) ; for ( int t = 1 ; t <= tt ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; solve ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { out . close ( ) ; } } public static void main ( String Args [ ] ) { new Solution ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String Args [ ] ) { new Solution ( ) . run ( ) ; }"]], "functions_class": [["nextToken", "String nextToken ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( in . readLine ( ) ) ; } return st . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; }"], ["solve", "void solve ( ) throws IOException { st = new StringTokenizer ( in . readLine ( ) , \" / \" ) ; long p = nextLong ( ) ; long q = nextLong ( ) ; long gcd = BigInteger . valueOf ( p ) . gcd ( BigInteger . valueOf ( q ) ) . longValue ( ) ; long qq = q / gcd ; if ( ( qq & ( qq - 1 ) ) == 0 ) { p /= gcd ; int ans = 1 ; while ( p < qq / 2 ) { ans ++ ; qq /= 2 ; } out . println ( ans ) ; } else { out . println ( \" impossible \" ) ; } }"], ["run", "void run ( ) { try { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; Locale . setDefault ( Locale . UK ) ; int tt = nextInt ( ) ; for ( int t = 1 ; t <= tt ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; solve ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { out . close ( ) ; } }"]]}, {"id": "4", "code": "import java . io . File ; import java . io . FileReader ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . * ; public class A { private final Scanner in ; private final PrintWriter out ; public A ( Scanner in , PrintWriter out ) { this . in = in ; this . out = out ; } public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( new FileReader ( new File ( \" A - large . in \" ) ) ) ; PrintWriter out = new PrintWriter ( \" A - large . out \" ) ) { new A ( in , out ) . solve ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . exit ( - 1 ) ; } } private void solve ( ) { int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; ++ test ) { StringTokenizer st = new StringTokenizer ( in . next ( ) , \" / \" ) ; BigInteger P = new BigInteger ( st . nextToken ( ) ) ; BigInteger Q = new BigInteger ( st . nextToken ( ) ) ; BigInteger d = P . gcd ( Q ) ; P = P . divide ( d ) ; Q = Q . divide ( d ) ; long p = P . longValue ( ) ; long q = Q . longValue ( ) ; out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; if ( q != Long . highestOneBit ( q ) ) { out . println ( \" impossible \" ) ; } else { int ans ; for ( ans = 0 ; p < q ; ++ ans , q >>= 1 ) ; out . println ( ans ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( new FileReader ( new File ( \" A - large . in \" ) ) ) ; PrintWriter out = new PrintWriter ( \" A - large . out \" ) ) { new A ( in , out ) . solve ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . exit ( - 1 ) ; } }"]], "functions_class": [["A", "public A ( Scanner in , PrintWriter out ) { this . in = in ; this . out = out ; }"], ["solve", "private void solve ( ) { int tests = in . nextInt ( ) ; for ( int test = 1 ; test <= tests ; ++ test ) { StringTokenizer st = new StringTokenizer ( in . next ( ) , \" / \" ) ; BigInteger P = new BigInteger ( st . nextToken ( ) ) ; BigInteger Q = new BigInteger ( st . nextToken ( ) ) ; BigInteger d = P . gcd ( Q ) ; P = P . divide ( d ) ; Q = Q . divide ( d ) ; long p = P . longValue ( ) ; long q = Q . longValue ( ) ; out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; if ( q != Long . highestOneBit ( q ) ) { out . println ( \" impossible \" ) ; } else { int ans ; for ( ans = 0 ; p < q ; ++ ans , q >>= 1 ) ; out . println ( ans ) ; } } }"]]}, {"id": "5", "code": "package contest ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . util . Scanner ; public class PartElf { final static String PROBLEM_NAME = \" PartElf \" ; final static String WORK_DIR = \" D : \\\\ GCJ \\ \\\" + PROBLEM_NAME + \" \\ \\\" ; long gcd ( long P , long Q ) { while ( P > 0 && Q > 0 ) if ( P > Q ) P %= Q ; else Q %= P ; return P + Q ; } void solve ( Scanner sc , PrintWriter pw ) { String s = sc . next ( ) ; String [ ] items = s . split ( \" / \" ) ; long P = Long . parseLong ( items [ 0 ] ) ; long Q = Long . parseLong ( items [ 1 ] ) ; long G = gcd ( P , Q ) ; P /= G ; Q /= G ; if ( ( Q & ( Q - 1 ) ) != 0 ) { pw . println ( \" impossible \" ) ; return ; } int ans = 0 ; while ( P < Q ) { P *= 2 ; ans ++ ; } pw . println ( ans ) ; } public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new PartElf ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new PartElf ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["gcd", "long gcd ( long P , long Q ) { while ( P > 0 && Q > 0 ) if ( P > Q ) P %= Q ; else Q %= P ; return P + Q ; }"], ["solve", "void solve ( Scanner sc , PrintWriter pw ) { String s = sc . next ( ) ; String [ ] items = s . split ( \" / \" ) ; long P = Long . parseLong ( items [ 0 ] ) ; long Q = Long . parseLong ( items [ 1 ] ) ; long G = gcd ( P , Q ) ; P /= G ; Q /= G ; if ( ( Q & ( Q - 1 ) ) != 0 ) { pw . println ( \" impossible \" ) ; return ; } int ans = 0 ; while ( P < Q ) { P *= 2 ; ans ++ ; } pw . println ( ans ) ; }"]]}, {"id": "17", "code": "package at . jaki . round1C . A ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintWriter ; public class A { private static final String INPUT = \" A - small - attempt0 . in \" ; private static final String OUTPUT = \" A - small - attempt0 . out \" ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( INPUT ) ) ; PrintWriter pw = new PrintWriter ( OUTPUT ) ; int totalTests = Integer . parseInt ( br . readLine ( ) ) ; for ( int testNo = 1 ; testNo <= totalTests ; testNo ++ ) { String [ ] temp = br . readLine ( ) . split ( \" / \" ) ; long p = Long . parseLong ( temp [ 0 ] ) ; long q = Long . parseLong ( temp [ 1 ] ) ; System . out . println ( p + \" \u2581 / \u2581 \" + q ) ; while ( p % 2 == 0 && q % 2 == 0 ) { p /= 2 ; q /= 2 ; } for ( long i = 3 ; i <= Math . sqrt ( p ) ; i += 2 ) { if ( p % i == 0 && q % i == 0 ) { p /= i ; q /= i ; } } if ( q % p == 0 ) { q /= p ; p = 1 ; } String result ; if ( ! is2Fac ( q ) ) { result = \" impossible \" ; } else { while ( p > 1 ) { q /= 2 ; p /= 2 ; } result = \" \" + count ( q ) ; } System . out . println ( p + \" \u2581 / \u2581 \" + q ) ; pw . print ( \" Case \u2581 # \" + testNo + \" : \u2581 \" ) ; pw . println ( result ) ; System . out . println ( result ) ; } pw . flush ( ) ; pw . close ( ) ; } private static int count ( long q ) { int total = 0 ; while ( q > 1 ) { q /= 2 ; total ++ ; } return total ; } private static boolean is2Fac ( long q ) { while ( q > 1 ) { if ( q % 2 == 0 ) { q /= 2 ; } else { return false ; } } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( INPUT ) ) ; PrintWriter pw = new PrintWriter ( OUTPUT ) ; int totalTests = Integer . parseInt ( br . readLine ( ) ) ; for ( int testNo = 1 ; testNo <= totalTests ; testNo ++ ) { String [ ] temp = br . readLine ( ) . split ( \" / \" ) ; long p = Long . parseLong ( temp [ 0 ] ) ; long q = Long . parseLong ( temp [ 1 ] ) ; System . out . println ( p + \" \u2581 / \u2581 \" + q ) ; while ( p % 2 == 0 && q % 2 == 0 ) { p /= 2 ; q /= 2 ; } for ( long i = 3 ; i <= Math . sqrt ( p ) ; i += 2 ) { if ( p % i == 0 && q % i == 0 ) { p /= i ; q /= i ; } } if ( q % p == 0 ) { q /= p ; p = 1 ; } String result ; if ( ! is2Fac ( q ) ) { result = \" impossible \" ; } else { while ( p > 1 ) { q /= 2 ; p /= 2 ; } result = \" \" + count ( q ) ; } System . out . println ( p + \" \u2581 / \u2581 \" + q ) ; pw . print ( \" Case \u2581 # \" + testNo + \" : \u2581 \" ) ; pw . println ( result ) ; System . out . println ( result ) ; } pw . flush ( ) ; pw . close ( ) ; }"], ["count", "private static int count ( long q ) { int total = 0 ; while ( q > 1 ) { q /= 2 ; total ++ ; } return total ; }"], ["is2Fac", "private static boolean is2Fac ( long q ) { while ( q > 1 ) { if ( q % 2 == 0 ) { q /= 2 ; } else { return false ; } } return true ; }"]], "functions_class": []}, {"id": "13", "code": "import java . io . * ; import java . util . HashSet ; import java . util . Set ; public class CodeJam2014R1C1 { public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" A - large . in \" ) ) ) ; PrintWriter pw = new PrintWriter ( new FileOutputStream ( \" A - large . out \" ) ) ; String line = br . readLine ( ) ; int T = Integer . parseInt ( line ) ; for ( int i = 0 ; i < T ; i ++ ) { System . out . println ( ( i + 1 ) + \" \u2581 / \u2581 \" + T + \" . . . \" ) ; line = br . readLine ( ) ; String [ ] values = line . split ( \" / \" ) ; long P = Long . parseLong ( values [ 0 ] ) ; long Q = Long . parseLong ( values [ 1 ] ) ; long cmmdc = cmmdc ( P , Q ) ; P /= cmmdc ; Q /= cmmdc ; System . out . println ( cmmdc ) ; int total = 0 ; while ( P < Q ) { P *= 2 ; total ++ ; } int result = total ; while ( P % Q != 0 && result < 40 ) { P *= 2 ; result ++ ; } if ( P % Q == 0 ) { pw . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + total ) ; } else { pw . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 impossible \" ) ; } } pw . close ( ) ; System . out . println ( \" DONE \" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private static long cmmdc ( long P , long Q ) { return Q == 0 ? P : cmmdc ( Q , P % Q ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( \" A - large . in \" ) ) ) ; PrintWriter pw = new PrintWriter ( new FileOutputStream ( \" A - large . out \" ) ) ; String line = br . readLine ( ) ; int T = Integer . parseInt ( line ) ; for ( int i = 0 ; i < T ; i ++ ) { System . out . println ( ( i + 1 ) + \" \u2581 / \u2581 \" + T + \" . . . \" ) ; line = br . readLine ( ) ; String [ ] values = line . split ( \" / \" ) ; long P = Long . parseLong ( values [ 0 ] ) ; long Q = Long . parseLong ( values [ 1 ] ) ; long cmmdc = cmmdc ( P , Q ) ; P /= cmmdc ; Q /= cmmdc ; System . out . println ( cmmdc ) ; int total = 0 ; while ( P < Q ) { P *= 2 ; total ++ ; } int result = total ; while ( P % Q != 0 && result < 40 ) { P *= 2 ; result ++ ; } if ( P % Q == 0 ) { pw . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + total ) ; } else { pw . println ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 impossible \" ) ; } } pw . close ( ) ; System . out . println ( \" DONE \" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"], ["cmmdc", "private static long cmmdc ( long P , long Q ) { return Q == 0 ? P : cmmdc ( Q , P % Q ) ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "import functools NEW_LINE import multiprocessing NEW_LINE import fractions NEW_LINE def pow2 ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT def solve ( cs , f ) : NEW_LINE INDENT if not pow2 ( f . denominator ) : NEW_LINE INDENT return cs , ' impossible ' NEW_LINE DEDENT ret = 1 NEW_LINE while f < fractions . Fraction ( 1 , 2 ) : NEW_LINE INDENT ret += 1 NEW_LINE f *= 2 NEW_LINE DEDENT return cs , ret NEW_LINE DEDENT def reducer ( l , result ) : NEW_LINE INDENT l . append ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE with multiprocessing . Pool ( processes = 8 ) as pool : NEW_LINE INDENT for cs in range ( T ) : NEW_LINE INDENT f = fractions . Fraction ( input ( ) ) NEW_LINE solve ( cs , f ) NEW_LINE pool . apply_async ( solve , args = ( cs + 1 , f , ) , callback = functools . partial ( reducer , l ) ) NEW_LINE DEDENT pool . close ( ) NEW_LINE pool . join ( ) NEW_LINE DEDENT for cs , result in sorted ( l , key = lambda x : x [ 0 ] ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( cs , result ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["pow2", "def pow2 ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT"], ["solve", "def solve ( cs , f ) : NEW_LINE INDENT if not pow2 ( f . denominator ) : NEW_LINE INDENT return cs , ' impossible ' NEW_LINE DEDENT ret = 1 NEW_LINE while f < fractions . Fraction ( 1 , 2 ) : NEW_LINE INDENT ret += 1 NEW_LINE f *= 2 NEW_LINE DEDENT return cs , ret NEW_LINE DEDENT"], ["reducer", "def reducer ( l , result ) : NEW_LINE INDENT l . append ( result ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "6", "code": "import sys NEW_LINE from fractions import gcd NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT p , q = map ( int , fin . readline ( ) . split ( ' / ' ) ) NEW_LINE g = gcd ( p , q ) NEW_LINE p //= g NEW_LINE q //= g NEW_LINE result = None NEW_LINE if p > q : NEW_LINE INDENT result = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT is_power = None NEW_LINE for i in range ( 0 , 41 ) : NEW_LINE INDENT power = 2 ** i NEW_LINE if q == power : NEW_LINE INDENT is_power = power NEW_LINE DEDENT DEDENT if is_power is None : NEW_LINE INDENT result = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT result = \" broken \" NEW_LINE for i in range ( 1 , 41 ) : NEW_LINE INDENT qq = 2 ** i NEW_LINE if p * qq >= q : NEW_LINE INDENT result = str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , result ) ) NEW_LINE DEDENT", "functions_standalone": [["debug", "def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "1", "code": "T = int ( raw_input ( ) ) NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT r = a % b NEW_LINE if r == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , r ) NEW_LINE DEDENT DEDENT def p2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * p2 ( x - 1 ) NEW_LINE DEDENT DEDENT for t in range ( T ) : NEW_LINE INDENT inpArr = raw_input ( ) . strip ( ) . split ( ' / ' ) NEW_LINE P = int ( inpArr [ 0 ] ) NEW_LINE Q = int ( inpArr [ 1 ] ) NEW_LINE g = gcd ( P , Q ) NEW_LINE P /= g NEW_LINE Q /= g NEW_LINE if ( P * p2 ( 40 ) ) % Q == 0 : NEW_LINE INDENT gen = 0 NEW_LINE while P < Q : NEW_LINE INDENT gen += 1 NEW_LINE P *= 2 NEW_LINE DEDENT print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 \" + str ( gen ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 impossible \" ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["gcd", "def gcd ( a , b ) : NEW_LINE INDENT r = a % b NEW_LINE if r == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , r ) NEW_LINE DEDENT DEDENT"], ["p2", "def p2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * p2 ( x - 1 ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "3", "code": "def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def IsPower ( n ) : NEW_LINE INDENT while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT def solve ( num ) : NEW_LINE INDENT P , Q = map ( int , input ( ) . split ( \" / \" ) ) NEW_LINE d = gcd ( P , Q ) NEW_LINE P //= d NEW_LINE Q //= d NEW_LINE if not IsPower ( Q ) : NEW_LINE INDENT ans = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE while 2 * P < Q : NEW_LINE INDENT ans += 1 NEW_LINE P *= 2 NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # \" + str ( num ) + \" : \" , ans ) NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT solve ( i + 1 ) NEW_LINE DEDENT", "functions_standalone": [["gcd", "def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT"], ["IsPower", "def IsPower ( n ) : NEW_LINE INDENT while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT"], ["solve", "def solve ( num ) : NEW_LINE INDENT P , Q = map ( int , input ( ) . split ( \" / \" ) ) NEW_LINE d = gcd ( P , Q ) NEW_LINE P //= d NEW_LINE Q //= d NEW_LINE if not IsPower ( Q ) : NEW_LINE INDENT ans = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE while 2 * P < Q : NEW_LINE INDENT ans += 1 NEW_LINE P *= 2 NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # \" + str ( num ) + \" : \" , ans ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "import sys NEW_LINE from fractions import gcd NEW_LINE with open ( \" in . txt \" , \" r \" ) as f : NEW_LINE INDENT with open ( \" out . txt \" , \" w \" ) as fout : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = f . readline ( ) NEW_LINE p , q = map ( int , line . strip ( ) . split ( ' / ' ) ) NEW_LINE x = gcd ( p , q ) NEW_LINE p /= x NEW_LINE q /= x NEW_LINE k , ss = 0 , 1 NEW_LINE res = \" \" NEW_LINE while k < 41 and ss * p % q != 0 : NEW_LINE INDENT k += 1 NEW_LINE ss *= 2 NEW_LINE if ss * p >= q and res == \" \" : NEW_LINE INDENT res = k NEW_LINE DEDENT DEDENT if k == 41 : NEW_LINE INDENT res = \" impossible \" NEW_LINE DEDENT print >> fout , \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , res ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_14_01", "java": [{"id": "9", "code": "import java . util . * ; import java . io . * ; public class A { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" A - small - attempt0 . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" A - small . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int x = 0 ; x < t ; x ++ ) { int row1 = in . nextInt ( ) - 1 ; HashSet < Integer > cards = new HashSet < Integer > ( ) ; for ( int y = 0 ; y < 4 ; y ++ ) { for ( int z = 0 ; z < 4 ; z ++ ) { int card = in . nextInt ( ) ; if ( y == row1 ) { cards . add ( card ) ; } } } int row2 = in . nextInt ( ) - 1 ; int chosen = - 1 ; int count = 0 ; for ( int a = 0 ; a < 4 ; a ++ ) { for ( int b = 0 ; b < 4 ; b ++ ) { int card = in . nextInt ( ) ; if ( a == row2 && cards . contains ( card ) ) { chosen = card ; count ++ ; } } } out . print ( \" Case \u2581 # \" + ( x + 1 ) + \" : \u2581 \" ) ; if ( count == 1 ) { out . println ( chosen ) ; } else if ( count == 0 ) { out . println ( \" Volunteer \u2581 cheated ! \" ) ; } else { out . println ( \" Bad \u2581 magician ! \" ) ; } } out . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( \" A - small - attempt0 . in \" ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( new File ( \" A - small . out \" ) ) ) ; int t = in . nextInt ( ) ; for ( int x = 0 ; x < t ; x ++ ) { int row1 = in . nextInt ( ) - 1 ; HashSet < Integer > cards = new HashSet < Integer > ( ) ; for ( int y = 0 ; y < 4 ; y ++ ) { for ( int z = 0 ; z < 4 ; z ++ ) { int card = in . nextInt ( ) ; if ( y == row1 ) { cards . add ( card ) ; } } } int row2 = in . nextInt ( ) - 1 ; int chosen = - 1 ; int count = 0 ; for ( int a = 0 ; a < 4 ; a ++ ) { for ( int b = 0 ; b < 4 ; b ++ ) { int card = in . nextInt ( ) ; if ( a == row2 && cards . contains ( card ) ) { chosen = card ; count ++ ; } } } out . print ( \" Case \u2581 # \" + ( x + 1 ) + \" : \u2581 \" ) ; if ( count == 1 ) { out . println ( chosen ) ; } else if ( count == 0 ) { out . println ( \" Volunteer \u2581 cheated ! \" ) ; } else { out . println ( \" Bad \u2581 magician ! \" ) ; } } out . close ( ) ; }"]], "functions_class": []}, {"id": "2", "code": "import java . util . Scanner ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int cases = in . nextInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { int poss = 0 ; int ans = - 1 ; int a = in . nextInt ( ) - 1 ; int [ ] [ ] first = new int [ 4 ] [ 4 ] ; int [ ] [ ] second = new int [ 4 ] [ 4 ] ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { first [ j ] [ k ] = in . nextInt ( ) ; } } int b = in . nextInt ( ) - 1 ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { second [ j ] [ k ] = in . nextInt ( ) ; } } for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { if ( first [ a ] [ k ] == second [ b ] [ j ] ) { ans = first [ a ] [ k ] ; poss ++ ; } } } if ( poss > 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 Bad \u2581 magician ! \\n \" , i ) ; } else if ( poss == 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , i , ans ) ; } else { System . out . printf ( \" Case \u2581 # % d : \u2581 Volunteer \u2581 cheated ! \\n \" , i ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int cases = in . nextInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { int poss = 0 ; int ans = - 1 ; int a = in . nextInt ( ) - 1 ; int [ ] [ ] first = new int [ 4 ] [ 4 ] ; int [ ] [ ] second = new int [ 4 ] [ 4 ] ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { first [ j ] [ k ] = in . nextInt ( ) ; } } int b = in . nextInt ( ) - 1 ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { second [ j ] [ k ] = in . nextInt ( ) ; } } for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { if ( first [ a ] [ k ] == second [ b ] [ j ] ) { ans = first [ a ] [ k ] ; poss ++ ; } } } if ( poss > 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 Bad \u2581 magician ! \\n \" , i ) ; } else if ( poss == 1 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % d \\n \" , i , ans ) ; } else { System . out . printf ( \" Case \u2581 # % d : \u2581 Volunteer \u2581 cheated ! \\n \" , i ) ; } } }"]], "functions_class": []}, {"id": "4", "code": "import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Scanner ; public class MagicTrick { public void magic ( ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" jam . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" jam . out \" ) ) ; int cases ; cases = sc . nextInt ( ) ; for ( int z = 1 ; z <= cases ; z ++ ) { int [ ] [ ] map1 = new int [ 4 ] [ 4 ] ; int [ ] [ ] map2 = new int [ 4 ] [ 4 ] ; int i , j ; int r1 , r2 ; r1 = sc . nextInt ( ) - 1 ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) map1 [ i ] [ j ] = sc . nextInt ( ) ; r2 = sc . nextInt ( ) - 1 ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) map2 [ i ] [ j ] = sc . nextInt ( ) ; int ans = 0 ; int sameNum = 0 ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) if ( map1 [ r1 ] [ i ] == map2 [ r2 ] [ j ] ) { sameNum ++ ; ans = map1 [ r1 ] [ i ] ; } bw . write ( \" Case \u2581 # \" + z + \" : \u2581 \" ) ; if ( sameNum == 0 ) bw . write ( \" Volunteer \u2581 cheated ! \" ) ; else if ( sameNum == 1 ) bw . write ( \" \" + ans ) ; else bw . write ( \" Bad \u2581 magician ! \" ) ; bw . write ( \" \\n \" ) ; } bw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [], "functions_class": [["magic", "public void magic ( ) throws IOException { Scanner sc = new Scanner ( new FileReader ( \" jam . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" jam . out \" ) ) ; int cases ; cases = sc . nextInt ( ) ; for ( int z = 1 ; z <= cases ; z ++ ) { int [ ] [ ] map1 = new int [ 4 ] [ 4 ] ; int [ ] [ ] map2 = new int [ 4 ] [ 4 ] ; int i , j ; int r1 , r2 ; r1 = sc . nextInt ( ) - 1 ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) map1 [ i ] [ j ] = sc . nextInt ( ) ; r2 = sc . nextInt ( ) - 1 ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) map2 [ i ] [ j ] = sc . nextInt ( ) ; int ans = 0 ; int sameNum = 0 ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) if ( map1 [ r1 ] [ i ] == map2 [ r2 ] [ j ] ) { sameNum ++ ; ans = map1 [ r1 ] [ i ] ; } bw . write ( \" Case \u2581 # \" + z + \" : \u2581 \" ) ; if ( sameNum == 0 ) bw . write ( \" Volunteer \u2581 cheated ! \" ) ; else if ( sameNum == 1 ) bw . write ( \" \" + ans ) ; else bw . write ( \" Bad \u2581 magician ! \" ) ; bw . write ( \" \\n \" ) ; } bw . close ( ) ; sc . close ( ) ; }"]]}, {"id": "10", "code": "package con2014Q ; import java . io . * ; import java . util . * ; public class A { private static final String fileName = \" results / con2014Q / \" + A . class . getSimpleName ( ) . toLowerCase ( ) ; private static final String inputFileName = fileName + \" . in \" ; private static final String outputFileName = fileName + \" . out \" ; private static Scanner in ; private static PrintWriter out ; static final String BAD = \" Bad \u2581 magician ! \" , CHEAT = \" Volunteer \u2581 cheated ! \" ; private void solve ( ) { int R1 = in . nextInt ( ) ; int possible = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { int n = in . nextInt ( ) ; if ( i == R1 ) { possible |= ( 1 << n ) ; } } } { R1 = in . nextInt ( ) ; int possible2 = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { int n = in . nextInt ( ) ; if ( i == R1 ) { possible2 |= ( 1 << n ) ; } } } possible &= possible2 ; } if ( possible == 0 ) { out . println ( CHEAT ) ; } else { int res = - 1 ; for ( int i = 0 ; i <= 16 ; i ++ ) { if ( ( possible & ( 1 << i ) ) == 0 ) continue ; if ( res != - 1 ) { out . println ( BAD ) ; return ; } res = i ; } out . println ( res ) ; } } public static void main ( String [ ] args ) throws IOException { long start = System . currentTimeMillis ( ) ; in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new A ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; long stop = System . currentTimeMillis ( ) ; System . out . println ( stop - start + \" \u2581 ms \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { long start = System . currentTimeMillis ( ) ; in = new Scanner ( new FileReader ( inputFileName ) ) ; out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; for ( int t = 1 ; t <= tests ; t ++ ) { out . print ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; new A ( ) . solve ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 solved \" ) ; } in . close ( ) ; out . close ( ) ; long stop = System . currentTimeMillis ( ) ; System . out . println ( stop - start + \" \u2581 ms \" ) ; }"]], "functions_class": [["solve", "private void solve ( ) { int R1 = in . nextInt ( ) ; int possible = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { int n = in . nextInt ( ) ; if ( i == R1 ) { possible |= ( 1 << n ) ; } } } { R1 = in . nextInt ( ) ; int possible2 = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { int n = in . nextInt ( ) ; if ( i == R1 ) { possible2 |= ( 1 << n ) ; } } } possible &= possible2 ; } if ( possible == 0 ) { out . println ( CHEAT ) ; } else { int res = - 1 ; for ( int i = 0 ; i <= 16 ; i ++ ) { if ( ( possible & ( 1 << i ) ) == 0 ) continue ; if ( res != - 1 ) { out . println ( BAD ) ; return ; } res = i ; } out . println ( res ) ; } }"]]}, {"id": "8", "code": "import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . PrintStream ; import java . util . Scanner ; public class ProblemA { public static void main ( String [ ] args ) throws Exception { System . setIn ( new FileInputStream ( \" A - small - attempt0 . in \" ) ) ; System . setOut ( new PrintStream ( new FileOutputStream ( \" A - small - attempt0 . out \" ) ) ) ; Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { int [ ] counts = new int [ 17 ] ; for ( int turn = 0 ; turn < 2 ; turn ++ ) { int row = in . nextInt ( ) - 1 ; for ( int r = 0 ; r < 4 ; r ++ ) { for ( int c = 0 ; c < 4 ; c ++ ) { int n = in . nextInt ( ) ; if ( r == row ) { counts [ n ] ++ ; } } } } int res = - 2 ; for ( int i = 1 ; i <= 16 ; i ++ ) { if ( counts [ i ] == 2 ) { if ( res == - 2 ) { res = i ; } else { res = - 1 ; } } } if ( res > 0 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , caseNum , res ) ; } else { System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , caseNum , ( res == - 2 ) ? \" Volunteer \u2581 cheated ! \" : \" Bad \u2581 magician ! \" ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { System . setIn ( new FileInputStream ( \" A - small - attempt0 . in \" ) ) ; System . setOut ( new PrintStream ( new FileOutputStream ( \" A - small - attempt0 . out \" ) ) ) ; Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= T ; caseNum ++ ) { int [ ] counts = new int [ 17 ] ; for ( int turn = 0 ; turn < 2 ; turn ++ ) { int row = in . nextInt ( ) - 1 ; for ( int r = 0 ; r < 4 ; r ++ ) { for ( int c = 0 ; c < 4 ; c ++ ) { int n = in . nextInt ( ) ; if ( r == row ) { counts [ n ] ++ ; } } } } int res = - 2 ; for ( int i = 1 ; i <= 16 ; i ++ ) { if ( counts [ i ] == 2 ) { if ( res == - 2 ) { res = i ; } else { res = - 1 ; } } } if ( res > 0 ) { System . out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , caseNum , res ) ; } else { System . out . printf ( \" Case \u2581 # % d : \u2581 % s % n \" , caseNum , ( res == - 2 ) ? \" Volunteer \u2581 cheated ! \" : \" Bad \u2581 magician ! \" ) ; } } }"]], "functions_class": []}], "python": [{"id": "11", "code": "from util import * NEW_LINE def main ( ) : NEW_LINE INDENT r = reader ( \" input \" ) NEW_LINE num = int ( r . next ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in xrange ( num ) : NEW_LINE INDENT g1 = int ( r . next ( ) ) NEW_LINE row1 = [ ] NEW_LINE for j in xrange ( 4 ) : NEW_LINE INDENT if j == g1 - 1 : NEW_LINE INDENT row1 = map ( int , r . next ( ) . split ( \" \u2581 \" ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r . next ( ) NEW_LINE DEDENT DEDENT g2 = int ( r . next ( ) ) NEW_LINE row2 = [ ] NEW_LINE for j in xrange ( 4 ) : NEW_LINE INDENT if j == g2 - 1 : NEW_LINE INDENT row2 = map ( int , r . next ( ) . split ( \" \u2581 \" ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r . next ( ) NEW_LINE DEDENT DEDENT intersection = [ x for x in row1 if x in row2 ] NEW_LINE if len ( intersection ) == 0 : NEW_LINE INDENT ans . append ( \" Volunteer \u2581 cheated ! \" ) NEW_LINE DEDENT elif len ( intersection ) == 1 : NEW_LINE INDENT ans . append ( intersection [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( \" Bad \u2581 magician ! \" ) NEW_LINE DEDENT DEDENT write ( \" output \" , ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "13", "code": "import math NEW_LINE import sys NEW_LINE def findsol ( C1 , C2 ) : NEW_LINE INDENT a = set ( C1 ) . intersection ( set ( C2 ) ) NEW_LINE if len ( a ) == 0 : NEW_LINE INDENT b = ' Volunteer \u2581 cheated ! ' NEW_LINE DEDENT if len ( a ) == 1 : NEW_LINE INDENT b = str ( a . pop ( ) ) NEW_LINE DEDENT if len ( a ) > 1 : NEW_LINE INDENT b = ' Bad \u2581 magician ! ' NEW_LINE DEDENT return b NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT fidi = open ( ' A - small - attempt0 . in ' , ' r ' ) NEW_LINE fido = open ( ' a . out ' , ' w ' ) NEW_LINE T = fidi . readline ( ) NEW_LINE T = int ( T ) NEW_LINE for ii in range ( 1 , T + 1 ) : NEW_LINE INDENT R1 = fidi . readline ( ) NEW_LINE R1 = int ( R1 ) NEW_LINE for jj in range ( 4 ) : NEW_LINE INDENT C = fidi . readline ( ) NEW_LINE if ( jj == R1 - 1 ) : NEW_LINE INDENT C1 = convertnums ( C ) NEW_LINE DEDENT DEDENT R2 = fidi . readline ( ) NEW_LINE R2 = int ( R2 ) NEW_LINE for jj in range ( 4 ) : NEW_LINE INDENT C = fidi . readline ( ) NEW_LINE if ( jj == R2 - 1 ) : NEW_LINE INDENT C2 = convertnums ( C ) NEW_LINE DEDENT DEDENT a = findsol ( C1 , C2 ) NEW_LINE fido . write ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' + str ( a ) + ' \\n ' ) NEW_LINE print ( ' Case \u2581 # ' , str ( ii ) , ' : \u2581 ' , str ( a ) ) NEW_LINE DEDENT fidi . close ( ) NEW_LINE fido . close ( ) NEW_LINE", "functions_standalone": [["findsol", "def findsol ( C1 , C2 ) : NEW_LINE INDENT a = set ( C1 ) . intersection ( set ( C2 ) ) NEW_LINE if len ( a ) == 0 : NEW_LINE INDENT b = ' Volunteer \u2581 cheated ! ' NEW_LINE DEDENT if len ( a ) == 1 : NEW_LINE INDENT b = str ( a . pop ( ) ) NEW_LINE DEDENT if len ( a ) > 1 : NEW_LINE INDENT b = ' Bad \u2581 magician ! ' NEW_LINE DEDENT return b NEW_LINE DEDENT"], ["convertnums", "def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT"]], "functions_class": []}, {"id": "12", "code": "from collections import * NEW_LINE from sys import argv , stdin , stdout , stderr NEW_LINE Case = namedtuple ( ' Case ' , ' selection , \u2581 array ' ) NEW_LINE def readcase ( f ) : NEW_LINE INDENT selection = [ int ( next ( f ) ) ] NEW_LINE array = [ [ readints ( f ) for _ in range ( 4 ) ] ] NEW_LINE selection . append ( int ( next ( f ) ) ) NEW_LINE array . append ( [ readints ( f ) for _ in range ( 4 ) ] ) NEW_LINE return Case ( selection , array ) NEW_LINE DEDENT def solvecase ( case ) : NEW_LINE INDENT sets = [ set ( arr [ sel - 1 ] ) for sel , arr in zip ( * case ) ] NEW_LINE possible = sets [ 0 ] & sets [ 1 ] NEW_LINE if not possible : NEW_LINE INDENT return \" Volunteer \u2581 cheated ! \" NEW_LINE DEDENT elif len ( possible ) > 1 : NEW_LINE INDENT return ' Bad \u2581 magician ! ' NEW_LINE DEDENT else : NEW_LINE INDENT return str ( possible . pop ( ) ) NEW_LINE DEDENT DEDENT def readints ( f ) : NEW_LINE INDENT return list ( map ( int , next ( f ) . split ( ' \u2581 ' ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( argv [ 1 ] ) as f , open ( argv [ 2 ] , ' w ' ) as out : NEW_LINE INDENT cases = int ( next ( f ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : \u2581 % s ' % ( case , solvecase ( readcase ( f ) ) ) , file = out ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE", "functions_standalone": [["readcase", "def readcase ( f ) : NEW_LINE INDENT selection = [ int ( next ( f ) ) ] NEW_LINE array = [ [ readints ( f ) for _ in range ( 4 ) ] ] NEW_LINE selection . append ( int ( next ( f ) ) ) NEW_LINE array . append ( [ readints ( f ) for _ in range ( 4 ) ] ) NEW_LINE return Case ( selection , array ) NEW_LINE DEDENT"], ["solvecase", "def solvecase ( case ) : NEW_LINE INDENT sets = [ set ( arr [ sel - 1 ] ) for sel , arr in zip ( * case ) ] NEW_LINE possible = sets [ 0 ] & sets [ 1 ] NEW_LINE if not possible : NEW_LINE INDENT return \" Volunteer \u2581 cheated ! \" NEW_LINE DEDENT elif len ( possible ) > 1 : NEW_LINE INDENT return ' Bad \u2581 magician ! ' NEW_LINE DEDENT else : NEW_LINE INDENT return str ( possible . pop ( ) ) NEW_LINE DEDENT DEDENT"], ["readints", "def readints ( f ) : NEW_LINE INDENT return list ( map ( int , next ( f ) . split ( ' \u2581 ' ) ) ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT with open ( argv [ 1 ] ) as f , open ( argv [ 2 ] , ' w ' ) as out : NEW_LINE INDENT cases = int ( next ( f ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT print ( ' Case \u2581 # % d : \u2581 % s ' % ( case , solvecase ( readcase ( f ) ) ) , file = out ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}, {"id": "1", "code": "import sys NEW_LINE import itertools NEW_LINE from operator import itemgetter NEW_LINE import bisect NEW_LINE import math NEW_LINE import copy NEW_LINE from fractions import gcd NEW_LINE from utilities import * NEW_LINE sys . setrecursionlimit ( 1000 ) NEW_LINE Prep = [ ] NEW_LINE def preprocess ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT def readinput ( Input ) : NEW_LINE INDENT A1 = Input . readint ( ) NEW_LINE R1 = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT R1 . append ( Input . readints ( ) ) NEW_LINE DEDENT A2 = Input . readint ( ) NEW_LINE R2 = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT R2 . append ( Input . readints ( ) ) NEW_LINE DEDENT return set ( R1 [ A1 - 1 ] ) , set ( R2 [ A2 - 1 ] ) NEW_LINE DEDENT def solve ( Problem , Prep ) : NEW_LINE INDENT R1 , R2 = Problem NEW_LINE B = R1 . intersection ( R2 ) NEW_LINE if len ( B ) == 0 : NEW_LINE INDENT return \" Volunteer \u2581 cheated ! \" NEW_LINE DEDENT if len ( B ) == 1 : NEW_LINE INDENT return B . pop ( ) NEW_LINE DEDENT return \" Bad \u2581 magician ! \" NEW_LINE return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT doit ( preprocess , readinput , solve , MultiCore = False , Verify = False , Input = SMALL , Filename = None , Problem = \" A \" , Attempt = 0 ) NEW_LINE DEDENT", "functions_standalone": [["preprocess", "def preprocess ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT"], ["readinput", "def readinput ( Input ) : NEW_LINE INDENT A1 = Input . readint ( ) NEW_LINE R1 = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT R1 . append ( Input . readints ( ) ) NEW_LINE DEDENT A2 = Input . readint ( ) NEW_LINE R2 = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT R2 . append ( Input . readints ( ) ) NEW_LINE DEDENT return set ( R1 [ A1 - 1 ] ) , set ( R2 [ A2 - 1 ] ) NEW_LINE DEDENT"], ["solve", "def solve ( Problem , Prep ) : NEW_LINE INDENT R1 , R2 = Problem NEW_LINE B = R1 . intersection ( R2 ) NEW_LINE if len ( B ) == 0 : NEW_LINE INDENT return \" Volunteer \u2581 cheated ! \" NEW_LINE DEDENT if len ( B ) == 1 : NEW_LINE INDENT return B . pop ( ) NEW_LINE DEDENT return \" Bad \u2581 magician ! \" NEW_LINE return 0 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "19", "code": "inputFile = open ( ' A - small - attempt0 . in ' , ' r ' ) NEW_LINE lines = inputFile . readlines ( ) NEW_LINE inputFile . close ( ) NEW_LINE outputFile = open ( ' A - small - attempt0 . out ' , ' w ' ) NEW_LINE numTests = int ( lines [ 0 ] ) NEW_LINE currLine = 1 NEW_LINE for i in range ( 1 , numTests + 1 ) : NEW_LINE INDENT firstRow = lines [ int ( lines [ currLine ] ) + currLine ] NEW_LINE currLine += 5 NEW_LINE secondRow = lines [ int ( lines [ currLine ] ) + currLine ] NEW_LINE currLine += 5 NEW_LINE firstNums = map ( lambda x : int ( x ) , firstRow . split ( ) ) NEW_LINE secondNums = map ( lambda x : int ( x ) , secondRow . split ( ) ) NEW_LINE intersect = [ v for v in firstNums if v in secondNums ] NEW_LINE outputFile . write ( ' Case \u2581 # ' + str ( i ) + ' : \u2581 ' ) NEW_LINE if len ( intersect ) == 1 : NEW_LINE INDENT outputFile . write ( str ( intersect [ 0 ] ) + ' \\n ' ) NEW_LINE DEDENT elif len ( intersect ) == 0 : NEW_LINE INDENT outputFile . write ( ' Volunteer \u2581 cheated ! \\n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT outputFile . write ( ' Bad \u2581 magician ! \\n ' ) NEW_LINE DEDENT DEDENT outputFile . close ( ) NEW_LINE", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_14_52", "java": [{"id": "19", "code": "import java . util . * ; public class Main { public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; } void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { int P = cin . nextInt ( ) ; int Q = cin . nextInt ( ) ; int N = cin . nextInt ( ) ; int HP [ ] = new int [ N ] ; int GOLD [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { HP [ i ] = cin . nextInt ( ) ; GOLD [ i ] = cin . nextInt ( ) ; } System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( P , Q , HP , GOLD , N ) ) ; } } int solve ( int P , int Q , int HP [ ] , int GOLD [ ] , int N ) { int SIZE = N * 10 + 100 ; int score [ ] = new int [ SIZE ] ; score [ 1 ] = 1 ; for ( int i = 0 ; i < N ; ++ i ) { int next [ ] = new int [ SIZE ] ; int turn = HP [ i ] / Q ; int rest = HP [ i ] - Q * turn ; if ( rest == 0 ) { rest = Q ; -- turn ; } int req = ( rest + P - 1 ) / P ; for ( int j = 0 ; j < SIZE ; ++ j ) { if ( score [ j ] == 0 ) { continue ; } int index = j + turn + 1 ; next [ index ] = Math . max ( next [ index ] , score [ j ] ) ; if ( req <= j + turn ) { int index2 = j + turn - req ; next [ index2 ] = Math . max ( next [ index2 ] , score [ j ] + GOLD [ i ] ) ; } } score = next ; } int ret = 0 ; for ( int i = 0 ; i < SIZE ; ++ i ) { ret = Math . max ( ret , score [ i ] ) ; } return ret - 1 ; } }", "functions_standalone": [["main", "public static void main ( String args [ ] ) { ( new Main ( ) ) . solve ( ) ; }"]], "functions_class": [["solve", "void solve ( ) { Scanner cin = new Scanner ( System . in ) ; int T = cin . nextInt ( ) ; for ( int C = 1 ; C <= T ; ++ C ) { int P = cin . nextInt ( ) ; int Q = cin . nextInt ( ) ; int N = cin . nextInt ( ) ; int HP [ ] = new int [ N ] ; int GOLD [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { HP [ i ] = cin . nextInt ( ) ; GOLD [ i ] = cin . nextInt ( ) ; } System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( P , Q , HP , GOLD , N ) ) ; } }"], ["solve", "int solve ( int P , int Q , int HP [ ] , int GOLD [ ] , int N ) { int SIZE = N * 10 + 100 ; int score [ ] = new int [ SIZE ] ; score [ 1 ] = 1 ; for ( int i = 0 ; i < N ; ++ i ) { int next [ ] = new int [ SIZE ] ; int turn = HP [ i ] / Q ; int rest = HP [ i ] - Q * turn ; if ( rest == 0 ) { rest = Q ; -- turn ; } int req = ( rest + P - 1 ) / P ; for ( int j = 0 ; j < SIZE ; ++ j ) { if ( score [ j ] == 0 ) { continue ; } int index = j + turn + 1 ; next [ index ] = Math . max ( next [ index ] , score [ j ] ) ; if ( req <= j + turn ) { int index2 = j + turn - req ; next [ index2 ] = Math . max ( next [ index2 ] , score [ j ] + GOLD [ i ] ) ; } } score = next ; } int ret = 0 ; for ( int i = 0 ; i < SIZE ; ++ i ) { ret = Math . max ( ret , score [ i ] ) ; } return ret - 1 ; }"]]}, {"id": "7", "code": "package round3 ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; public class B { public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" round3 / B - large - 0 . in \" ) , new FileOutputStream ( \" round3 / B - large - 0 . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; System . err . println ( i ) ; new B ( ) . solve ( io ) ; } io . close ( ) ; } int myPower , towerPower ; int health [ ] , gold [ ] ; private void solve ( Kattio io ) { myPower = io . getInt ( ) ; towerPower = io . getInt ( ) ; int n = io . getInt ( ) ; health = new int [ n ] ; gold = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { health [ i ] = io . getInt ( ) ; gold [ i ] = io . getInt ( ) ; } memo = new int [ n ] [ 201 * n + 10 ] ; io . println ( go ( 0 , 1 ) ) ; } int memo [ ] [ ] ; private int go ( int monster , int savedTurns ) { if ( monster == health . length ) return 0 ; int orgSavedTurns = savedTurns ; if ( memo [ monster ] [ savedTurns ] > 0 ) return memo [ monster ] [ savedTurns ] - 1 ; int towerShots = ( health [ monster ] + towerPower - 1 ) / towerPower ; int best = go ( monster + 1 , savedTurns + towerShots ) ; int h = health [ monster ] % towerPower ; if ( h == 0 ) h = towerPower ; int shotsReq = ( h + myPower - 1 ) / myPower ; savedTurns += towerShots - 1 ; if ( shotsReq <= savedTurns ) { best = Math . max ( best , gold [ monster ] + go ( monster + 1 , savedTurns - shotsReq ) ) ; } memo [ monster ] [ orgSavedTurns ] = best + 1 ; return best ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws FileNotFoundException { Kattio io ; io = new Kattio ( new FileInputStream ( \" round3 / B - large - 0 . in \" ) , new FileOutputStream ( \" round3 / B - large - 0 . out \" ) ) ; int cases = io . getInt ( ) ; for ( int i = 1 ; i <= cases ; i ++ ) { io . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; System . err . println ( i ) ; new B ( ) . solve ( io ) ; } io . close ( ) ; }"]], "functions_class": [["solve", "private void solve ( Kattio io ) { myPower = io . getInt ( ) ; towerPower = io . getInt ( ) ; int n = io . getInt ( ) ; health = new int [ n ] ; gold = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { health [ i ] = io . getInt ( ) ; gold [ i ] = io . getInt ( ) ; } memo = new int [ n ] [ 201 * n + 10 ] ; io . println ( go ( 0 , 1 ) ) ; }"], ["go", "private int go ( int monster , int savedTurns ) { if ( monster == health . length ) return 0 ; int orgSavedTurns = savedTurns ; if ( memo [ monster ] [ savedTurns ] > 0 ) return memo [ monster ] [ savedTurns ] - 1 ; int towerShots = ( health [ monster ] + towerPower - 1 ) / towerPower ; int best = go ( monster + 1 , savedTurns + towerShots ) ; int h = health [ monster ] % towerPower ; if ( h == 0 ) h = towerPower ; int shotsReq = ( h + myPower - 1 ) / myPower ; savedTurns += towerShots - 1 ; if ( shotsReq <= savedTurns ) { best = Math . max ( best , gold [ monster ] + go ( monster + 1 , savedTurns - shotsReq ) ) ; } memo [ monster ] [ orgSavedTurns ] = best + 1 ; return best ; }"]]}], "python": [{"id": "9", "code": "def claim_differ ( hp , mydmg , twrdmg ) : NEW_LINE INDENT towShots = hp / twrdmg NEW_LINE hp %= twrdmg NEW_LINE if hp == 0 : NEW_LINE INDENT towShots -= 1 NEW_LINE hp += twrdmg NEW_LINE DEDENT myShots = hp / mydmg NEW_LINE hp %= mydmg NEW_LINE if hp > 0 : NEW_LINE INDENT myShots += 1 NEW_LINE hp = 0 NEW_LINE DEDENT return towShots - myShots NEW_LINE DEDENT def leave_differ ( hp , twrdmg ) : NEW_LINE INDENT towShots = hp / twrdmg NEW_LINE hp %= twrdmg NEW_LINE if hp > 0 : NEW_LINE INDENT towShots += 1 NEW_LINE hp = 0 NEW_LINE DEDENT return towShots NEW_LINE DEDENT INF = 10 ** 12 NEW_LINE def max_gain ( mem , hps , glds , mydmg , twrdmg , mstr , extra_shots ) : NEW_LINE INDENT if extra_shots < 0 : NEW_LINE INDENT return - INF NEW_LINE DEDENT if len ( hps ) == mstr : NEW_LINE INDENT return 0 NEW_LINE DEDENT key = ( mstr , extra_shots ) NEW_LINE if key in mem : NEW_LINE INDENT return mem [ key ] NEW_LINE DEDENT cd = claim_differ ( hps [ mstr ] , mydmg , twrdmg ) NEW_LINE res1 = glds [ mstr ] + max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + cd ) NEW_LINE ld = leave_differ ( hps [ mstr ] , twrdmg ) NEW_LINE res2 = max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + ld ) NEW_LINE best = max ( res1 , res2 ) NEW_LINE mem [ key ] = best NEW_LINE return best NEW_LINE DEDENT import sys NEW_LINE infname = sys . argv [ 1 ] NEW_LINE with open ( infname ) as inf : NEW_LINE INDENT with open ( infname . replace ( ' . in ' , ' . out ' ) , ' w ' ) as outf : NEW_LINE INDENT T = int ( inf . readline ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT mydmg , twrdmg , N = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE hps , glds = [ ] , [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT hp , gld = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE hps . append ( hp ) NEW_LINE glds . append ( gld ) NEW_LINE DEDENT outf . write ( ' Case \u2581 # { } : \u2581 { } \\n ' . format ( t , max_gain ( { } , hps , glds , mydmg , twrdmg , 0 , 1 ) ) ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["claim_differ", "def claim_differ ( hp , mydmg , twrdmg ) : NEW_LINE INDENT towShots = hp / twrdmg NEW_LINE hp %= twrdmg NEW_LINE if hp == 0 : NEW_LINE INDENT towShots -= 1 NEW_LINE hp += twrdmg NEW_LINE DEDENT myShots = hp / mydmg NEW_LINE hp %= mydmg NEW_LINE if hp > 0 : NEW_LINE INDENT myShots += 1 NEW_LINE hp = 0 NEW_LINE DEDENT return towShots - myShots NEW_LINE DEDENT"], ["leave_differ", "def leave_differ ( hp , twrdmg ) : NEW_LINE INDENT towShots = hp / twrdmg NEW_LINE hp %= twrdmg NEW_LINE if hp > 0 : NEW_LINE INDENT towShots += 1 NEW_LINE hp = 0 NEW_LINE DEDENT return towShots NEW_LINE DEDENT"], ["max_gain", "def max_gain ( mem , hps , glds , mydmg , twrdmg , mstr , extra_shots ) : NEW_LINE INDENT if extra_shots < 0 : NEW_LINE INDENT return - INF NEW_LINE DEDENT if len ( hps ) == mstr : NEW_LINE INDENT return 0 NEW_LINE DEDENT key = ( mstr , extra_shots ) NEW_LINE if key in mem : NEW_LINE INDENT return mem [ key ] NEW_LINE DEDENT cd = claim_differ ( hps [ mstr ] , mydmg , twrdmg ) NEW_LINE res1 = glds [ mstr ] + max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + cd ) NEW_LINE ld = leave_differ ( hps [ mstr ] , twrdmg ) NEW_LINE res2 = max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + ld ) NEW_LINE best = max ( res1 , res2 ) NEW_LINE mem [ key ] = best NEW_LINE return best NEW_LINE DEDENT"]], "functions_class": []}, {"id": "4", "code": "for ti in range ( 1 , int ( input ( ) ) + 1 ) : NEW_LINE INDENT p , q , n = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE bests = [ ( 0 , 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT h , g = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE towershots = ( h + q - 1 ) // q NEW_LINE bestdiff = 100 NEW_LINE for j in range ( towershots ) : NEW_LINE INDENT k = ( h - q * j + p - 1 ) // p NEW_LINE if k - j < bestdiff : NEW_LINE INDENT bestdiff = k - j NEW_LINE DEDENT DEDENT newbests = [ ] NEW_LINE for best in bests : NEW_LINE INDENT newbests . append ( ( best [ 0 ] , best [ 1 ] + towershots ) ) NEW_LINE if best [ 1 ] >= bestdiff : NEW_LINE INDENT newbests . append ( ( best [ 0 ] + g , best [ 1 ] - bestdiff ) ) NEW_LINE DEDENT DEDENT newbests = sorted ( newbests ) NEW_LINE last = newbests [ - 1 ] NEW_LINE bests = [ last ] NEW_LINE for i in reversed ( range ( 0 , len ( newbests ) - 1 ) ) : NEW_LINE INDENT if newbests [ i ] [ 0 ] > last [ 0 ] or newbests [ i ] [ 1 ] > last [ 1 ] : NEW_LINE INDENT bests . append ( newbests [ i ] ) NEW_LINE last = newbests [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( ' Case \u2581 # ' + str ( ti ) + ' : ' , bests [ 0 ] [ 0 ] ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "12", "code": "import sys NEW_LINE t = int ( sys . stdin . readline ( ) ) NEW_LINE def solve ( p , q , monsters , diana ) : NEW_LINE INDENT if len ( monsters ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT hp , gold = monsters [ 0 ] NEW_LINE shoots = hp // q + ( 1 if hp % q != 0 else 0 ) NEW_LINE best = solve ( p , q , monsters [ 1 : ] , diana + shoots ) NEW_LINE while hp - q > 0 : NEW_LINE INDENT diana += 1 NEW_LINE hp -= q NEW_LINE DEDENT shoots = hp // p + ( 1 if hp % p != 0 else 0 ) NEW_LINE if shoots <= diana : NEW_LINE INDENT value = gold + solve ( p , q , monsters [ 1 : ] , diana - shoots ) NEW_LINE best = max ( best , value ) NEW_LINE DEDENT return best NEW_LINE DEDENT for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT p , q , n = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE monsters = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT h , g = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE monsters . append ( ( h , g ) ) NEW_LINE DEDENT print ( \" Case \u2581 # { 0 } : \u2581 { 1 } \" . format ( test_case , solve ( p , q , monsters , 1 ) ) ) NEW_LINE DEDENT", "functions_standalone": [["solve", "def solve ( p , q , monsters , diana ) : NEW_LINE INDENT if len ( monsters ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT hp , gold = monsters [ 0 ] NEW_LINE shoots = hp // q + ( 1 if hp % q != 0 else 0 ) NEW_LINE best = solve ( p , q , monsters [ 1 : ] , diana + shoots ) NEW_LINE while hp - q > 0 : NEW_LINE INDENT diana += 1 NEW_LINE hp -= q NEW_LINE DEDENT shoots = hp // p + ( 1 if hp % p != 0 else 0 ) NEW_LINE if shoots <= diana : NEW_LINE INDENT value = gold + solve ( p , q , monsters [ 1 : ] , diana - shoots ) NEW_LINE best = max ( best , value ) NEW_LINE DEDENT return best NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_41", "java": [{"id": "19", "code": "import java . util . * ; import java . io . * ; import java . math . * ; import static java . lang . Math . * ; import static java . lang . Integer . * ; import static java . lang . System . * ; public class A { public static String [ ] parts ( BufferedReader br ) throws Exception { String line = br . readLine ( ) ; if ( line == null ) return null ; return line . trim ( ) . split ( \" \\\\ s + \" ) ; } public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int cas = parseInt ( br . readLine ( ) ) ; for ( int z = 1 ; z <= cas ; z ++ ) { String [ ] ss = parts ( br ) ; int n = parseInt ( ss [ 0 ] ) ; int m = parseInt ( ss [ 1 ] ) ; ss = parts ( br ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = parseInt ( ss [ i ] ) ; Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { while ( i < j && arr [ i ] + arr [ j ] > m ) { j -- ; ans ++ ; } i ++ ; j -- ; ans ++ ; } out . println ( \" Case \u2581 # \" + z + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["parts", "public static String [ ] parts ( BufferedReader br ) throws Exception { String line = br . readLine ( ) ; if ( line == null ) return null ; return line . trim ( ) . split ( \" \\\\ s + \" ) ; }"], ["main", "public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int cas = parseInt ( br . readLine ( ) ) ; for ( int z = 1 ; z <= cas ; z ++ ) { String [ ] ss = parts ( br ) ; int n = parseInt ( ss [ 0 ] ) ; int m = parseInt ( ss [ 1 ] ) ; ss = parts ( br ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = parseInt ( ss [ i ] ) ; Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { while ( i < j && arr [ i ] + arr [ j ] > m ) { j -- ; ans ++ ; } i ++ ; j -- ; ans ++ ; } out . println ( \" Case \u2581 # \" + z + \" : \u2581 \" + ans ) ; } }"]], "functions_class": []}, {"id": "4", "code": "package contest ; import java . util . * ; import java . io . * ; import java . math . * ; public class DataPacking { final static String PROBLEM_NAME = \" dpack \" ; final static String WORK_DIR = \" D : \\\\ GCJ \\ \\\" + PROBLEM_NAME + \" \\ \\\" ; void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; int X = sc . nextInt ( ) ; int [ ] sz = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) sz [ i ] = sc . nextInt ( ) ; Arrays . sort ( sz ) ; int ans = N ; for ( int t = 0 ; 2 * t <= N ; t ++ ) { boolean ok = true ; for ( int i = 0 , j = 2 * t - 1 ; i < j ; i ++ , j -- ) if ( sz [ i ] + sz [ j ] > X ) ok = false ; if ( ok ) ans = Math . min ( ans , N - t ) ; } pw . println ( ans ) ; } public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new DataPacking ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( new FileReader ( WORK_DIR + \" input . txt \" ) ) ; PrintWriter pw = new PrintWriter ( new FileWriter ( WORK_DIR + \" output . txt \" ) ) ; int caseCnt = sc . nextInt ( ) ; for ( int caseNum = 0 ; caseNum < caseCnt ; caseNum ++ ) { System . out . println ( \" Processing \u2581 test \u2581 case \u2581 \" + ( caseNum + 1 ) ) ; pw . print ( \" Case \u2581 # \" + ( caseNum + 1 ) + \" : \u2581 \" ) ; new DataPacking ( ) . solve ( sc , pw ) ; } pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; }"]], "functions_class": [["solve", "void solve ( Scanner sc , PrintWriter pw ) { int N = sc . nextInt ( ) ; int X = sc . nextInt ( ) ; int [ ] sz = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) sz [ i ] = sc . nextInt ( ) ; Arrays . sort ( sz ) ; int ans = N ; for ( int t = 0 ; 2 * t <= N ; t ++ ) { boolean ok = true ; for ( int i = 0 , j = 2 * t - 1 ; i < j ; i ++ , j -- ) if ( sz [ i ] + sz [ j ] > X ) ok = false ; if ( ok ) ans = Math . min ( ans , N - t ) ; } pw . println ( ans ) ; }"]]}, {"id": "18", "code": "package com . google . codejam2014 . round2 ; import java . io . * ; import java . util . Arrays ; import java . util . StringTokenizer ; public class DataPacking { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter writer = new PrintWriter ( System . out ) ; StringTokenizer stringTokenizer ; DataPacking ( ) throws IOException { reader = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; writer = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; } String next ( ) throws IOException { while ( stringTokenizer == null || ! stringTokenizer . hasMoreTokens ( ) ) { stringTokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return stringTokenizer . nextToken ( ) ; } int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } void solveTestCase ( int testNumber ) throws IOException { writer . printf ( \" Case \u2581 # % d : \u2581 \" , testNumber ) ; int n = nextInt ( ) ; int x = nextInt ( ) ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = nextInt ( ) ; } Arrays . sort ( s ) ; int limit = x / 2 ; int i1 = 0 ; int i2 = n - 1 ; int ans = 0 ; while ( s [ i2 ] > limit && i2 > i1 ) { ans ++ ; if ( s [ i2 ] + s [ i1 ] <= x ) { i1 ++ ; } i2 -- ; } int left = i2 - i1 + 1 ; ans += left / 2 + left % 2 ; writer . println ( ans ) ; } void solve ( ) throws IOException { int testsNumber = nextInt ( ) ; for ( int i = 1 ; i <= testsNumber ; i ++ ) { solveTestCase ( i ) ; writer . flush ( ) ; } writer . close ( ) ; } public static void main ( String [ ] args ) throws IOException { new DataPacking ( ) . solve ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws IOException { new DataPacking ( ) . solve ( ) ; }"]], "functions_class": [["DataPacking", "DataPacking ( ) throws IOException { reader = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; writer = new PrintWriter ( new FileWriter ( \" output . txt \" ) ) ; }"], ["next", "String next ( ) throws IOException { while ( stringTokenizer == null || ! stringTokenizer . hasMoreTokens ( ) ) { stringTokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return stringTokenizer . nextToken ( ) ; }"], ["nextInt", "int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }"], ["nextLong", "long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; }"], ["nextDouble", "double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; }"], ["solveTestCase", "void solveTestCase ( int testNumber ) throws IOException { writer . printf ( \" Case \u2581 # % d : \u2581 \" , testNumber ) ; int n = nextInt ( ) ; int x = nextInt ( ) ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = nextInt ( ) ; } Arrays . sort ( s ) ; int limit = x / 2 ; int i1 = 0 ; int i2 = n - 1 ; int ans = 0 ; while ( s [ i2 ] > limit && i2 > i1 ) { ans ++ ; if ( s [ i2 ] + s [ i1 ] <= x ) { i1 ++ ; } i2 -- ; } int left = i2 - i1 + 1 ; ans += left / 2 + left % 2 ; writer . println ( ans ) ; }"], ["solve", "void solve ( ) throws IOException { int testsNumber = nextInt ( ) ; for ( int i = 1 ; i <= testsNumber ; i ++ ) { solveTestCase ( i ) ; writer . flush ( ) ; } writer . close ( ) ; }"]]}, {"id": "15", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class DataPacking { private static Scanner input ; private static PrintWriter out ; public static void main ( String [ ] args ) throws Exception { input = new Scanner ( new FileReader ( \" A - large . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" A - large . out \" ) ) ; int testCases = input . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + solveCase ( ) ) ; } out . close ( ) ; } public static int solveCase ( ) { int n = input . nextInt ( ) , max = input . nextInt ( ) ; int [ ] values = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) values [ i ] = input . nextInt ( ) ; Arrays . sort ( values ) ; int lower = 0 , upper = n - 1 , res = 0 ; while ( lower <= upper ) { if ( lower == upper ) { res ++ ; lower ++ ; } else { if ( values [ upper ] + values [ lower ] <= max ) { res ++ ; lower ++ ; upper -- ; } else { res ++ ; upper -- ; } } } return res ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { input = new Scanner ( new FileReader ( \" A - large . in \" ) ) ; out = new PrintWriter ( new FileWriter ( \" A - large . out \" ) ) ; int testCases = input . nextInt ( ) ; for ( int testCase = 1 ; testCase <= testCases ; testCase ++ ) { out . println ( \" Case \u2581 # \" + testCase + \" : \u2581 \" + solveCase ( ) ) ; } out . close ( ) ; }"], ["solveCase", "public static int solveCase ( ) { int n = input . nextInt ( ) , max = input . nextInt ( ) ; int [ ] values = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) values [ i ] = input . nextInt ( ) ; Arrays . sort ( values ) ; int lower = 0 , upper = n - 1 , res = 0 ; while ( lower <= upper ) { if ( lower == upper ) { res ++ ; lower ++ ; } else { if ( values [ upper ] + values [ lower ] <= max ) { res ++ ; lower ++ ; upper -- ; } else { res ++ ; upper -- ; } } } return res ; }"]], "functions_class": []}, {"id": "0", "code": "import static java . lang . Math . * ; import static java . util . Arrays . * ; import java . io . * ; import java . util . * ; public class A { Scanner sc = new Scanner ( System . in ) ; int N , X ; int [ ] S ; void read ( ) { N = sc . nextInt ( ) ; X = sc . nextInt ( ) ; S = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) S [ i ] = sc . nextInt ( ) ; } void solve ( ) { boolean [ ] used = new boolean [ N ] ; int num = 0 ; sort ( S ) ; for ( int i = 0 ; i < N ; i ++ ) if ( ! used [ i ] ) { used [ i ] = true ; for ( int j = N - 1 ; j >= 0 ; j -- ) if ( ! used [ j ] && S [ i ] + S [ j ] <= X ) { used [ i ] = used [ j ] = true ; break ; } num ++ ; } System . out . println ( num ) ; } void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( A . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new A ( ) . run ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try { System . setIn ( new BufferedInputStream ( new FileInputStream ( args . length > 0 ? args [ 0 ] : ( A . class . getName ( ) + \" . in \" ) ) ) ) ; } catch ( Exception e ) { } new A ( ) . run ( ) ; }"]], "functions_class": [["read", "void read ( ) { N = sc . nextInt ( ) ; X = sc . nextInt ( ) ; S = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) S [ i ] = sc . nextInt ( ) ; }"], ["solve", "void solve ( ) { boolean [ ] used = new boolean [ N ] ; int num = 0 ; sort ( S ) ; for ( int i = 0 ; i < N ; i ++ ) if ( ! used [ i ] ) { used [ i ] = true ; for ( int j = N - 1 ; j >= 0 ; j -- ) if ( ! used [ j ] && S [ i ] + S [ j ] <= X ) { used [ i ] = used [ j ] = true ; break ; } num ++ ; } System . out . println ( num ) ; }"], ["run", "void run ( ) { int caseN = sc . nextInt ( ) ; for ( int caseID = 1 ; caseID <= caseN ; caseID ++ ) { read ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , caseID ) ; solve ( ) ; System . out . flush ( ) ; } }"], ["debug", "void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; }"]]}], "python": [{"id": "8", "code": "__author__ = ' Pavel \u2581 Mavrin ' NEW_LINE fin = open ( \" A . in \" ) NEW_LINE fout = open ( \" A . out \" , \" w \" ) NEW_LINE test_num = int ( fin . readline ( ) ) NEW_LINE def solve_test ( ) : NEW_LINE INDENT n , x = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s . sort ( ) NEW_LINE res = 0 NEW_LINE j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j > i and s [ i ] + s [ j ] > x : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j > i : NEW_LINE INDENT res += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( res + ( n - 2 * res ) ) NEW_LINE DEDENT for test_i in range ( test_num ) : NEW_LINE INDENT s = \" Case \u2581 # \" + str ( test_i + 1 ) + \" : \u2581 \" + solve_test ( ) NEW_LINE print ( s ) NEW_LINE print ( s , file = fout ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [["solve_test", "def solve_test ( ) : NEW_LINE INDENT n , x = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s . sort ( ) NEW_LINE res = 0 NEW_LINE j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j > i and s [ i ] + s [ j ] > x : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j > i : NEW_LINE INDENT res += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( res + ( n - 2 * res ) ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "import sys NEW_LINE def rl ( T ) : NEW_LINE INDENT return list ( map ( T , input ( ) . split ( ) ) ) NEW_LINE DEDENT def solve ( X , S ) : NEW_LINE INDENT if len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( S ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if S [ 0 ] + S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 1 : len ( S ) - 1 ] ) NEW_LINE DEDENT if S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 0 : len ( S ) - 1 ] ) NEW_LINE DEDENT raise Exception NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 100000 ) NEW_LINE T , = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT N , X = rl ( int ) NEW_LINE S = rl ( int ) NEW_LINE S . sort ( ) NEW_LINE ans = solve ( X , S ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % d ' % ( C , ans ) ) NEW_LINE DEDENT pass NEW_LINE DEDENT main ( ) NEW_LINE", "functions_standalone": [["rl", "def rl ( T ) : NEW_LINE INDENT return list ( map ( T , input ( ) . split ( ) ) ) NEW_LINE DEDENT"], ["solve", "def solve ( X , S ) : NEW_LINE INDENT if len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( S ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if S [ 0 ] + S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 1 : len ( S ) - 1 ] ) NEW_LINE DEDENT if S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 0 : len ( S ) - 1 ] ) NEW_LINE DEDENT raise Exception NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 100000 ) NEW_LINE T , = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT N , X = rl ( int ) NEW_LINE S = rl ( int ) NEW_LINE S . sort ( ) NEW_LINE ans = solve ( X , S ) NEW_LINE print ( ' Case \u2581 # % d : \u2581 % d ' % ( C , ans ) ) NEW_LINE DEDENT pass NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "def solve ( dsize , fsizes ) : NEW_LINE INDENT cnt = 0 NEW_LINE fsizes . sort ( reverse = True ) NEW_LINE while True : NEW_LINE INDENT s , k = None , None NEW_LINE for i in range ( len ( fsizes ) ) : NEW_LINE INDENT if fsizes [ i ] != - 1 : NEW_LINE INDENT s , k = fsizes [ i ] , i NEW_LINE break NEW_LINE DEDENT DEDENT if not s : NEW_LINE INDENT return cnt NEW_LINE DEDENT if k > 100 : NEW_LINE INDENT fsizes = fsizes [ k : ] NEW_LINE k = 0 NEW_LINE DEDENT fsizes [ k ] = - 1 NEW_LINE cnt += 1 NEW_LINE d = None NEW_LINE for i in range ( len ( fsizes ) ) : NEW_LINE INDENT if dsize - s >= fsizes [ i ] and fsizes [ i ] != - 1 : NEW_LINE INDENT d = fsizes [ i ] NEW_LINE j = i NEW_LINE break NEW_LINE DEDENT DEDENT if d and d != - 1 : NEW_LINE INDENT fsizes [ j ] = - 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT import sys NEW_LINE infname = sys . argv [ 1 ] NEW_LINE with open ( infname ) as inf : NEW_LINE INDENT with open ( infname . replace ( ' . in ' , ' . out ' ) , ' w ' ) as outf : NEW_LINE INDENT T = int ( inf . readline ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT n , dsize = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE fsizes = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE outf . write ( ' Case \u2581 # { } : \u2581 { } \\n ' . format ( t , solve ( dsize , fsizes ) ) ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [["solve", "def solve ( dsize , fsizes ) : NEW_LINE INDENT cnt = 0 NEW_LINE fsizes . sort ( reverse = True ) NEW_LINE while True : NEW_LINE INDENT s , k = None , None NEW_LINE for i in range ( len ( fsizes ) ) : NEW_LINE INDENT if fsizes [ i ] != - 1 : NEW_LINE INDENT s , k = fsizes [ i ] , i NEW_LINE break NEW_LINE DEDENT DEDENT if not s : NEW_LINE INDENT return cnt NEW_LINE DEDENT if k > 100 : NEW_LINE INDENT fsizes = fsizes [ k : ] NEW_LINE k = 0 NEW_LINE DEDENT fsizes [ k ] = - 1 NEW_LINE cnt += 1 NEW_LINE d = None NEW_LINE for i in range ( len ( fsizes ) ) : NEW_LINE INDENT if dsize - s >= fsizes [ i ] and fsizes [ i ] != - 1 : NEW_LINE INDENT d = fsizes [ i ] NEW_LINE j = i NEW_LINE break NEW_LINE DEDENT DEDENT if d and d != - 1 : NEW_LINE INDENT fsizes [ j ] = - 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT"]], "functions_class": []}, {"id": "0", "code": "import sys NEW_LINE fin = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE fout = open ( \" p1 . out \" , \" w \" ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT N , X = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE S = sorted ( map ( int , fin . readline ( ) . split ( ) ) ) NEW_LINE cur = 0 NEW_LINE for j in reversed ( xrange ( len ( S ) ) ) : NEW_LINE INDENT if j <= cur : NEW_LINE INDENT break NEW_LINE DEDENT elif S [ cur ] + S [ j ] <= X : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT DEDENT fout . write ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + str ( N - cur ) + \" \\n \" ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "17", "code": "for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT ( N , X ) = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE S = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE S = list ( reversed ( sorted ( S ) ) ) NEW_LINE res = 0 NEW_LINE while S : NEW_LINE INDENT a = S [ 0 ] NEW_LINE found = False NEW_LINE for i , b in enumerate ( S ) : NEW_LINE INDENT if i > 0 and a + b <= X : NEW_LINE INDENT del S [ i ] NEW_LINE del S [ 0 ] NEW_LINE res += 1 NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if not found : NEW_LINE INDENT del S [ 0 ] NEW_LINE res += 1 NEW_LINE DEDENT DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( tc + 1 , res ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "codejam_14_12", "java": [{"id": "13", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Scanner ; public class FullBinaryTree { public final static String INPUT_FILE_NAME = \" B - large ( 1 ) . in \" ; public final static String OUTPUT_FILE_NAME = \" FullBinaryTree . out \" ; public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( new FileReader ( INPUT_FILE_NAME ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( OUTPUT_FILE_NAME ) ) ) { int numT = in . nextInt ( ) ; for ( int t = 1 ; t <= numT ; t ++ ) { System . out . println ( \" Case \u2581 \" + t ) ; int numNode = in . nextInt ( ) ; ArrayList < Node > nodes = new ArrayList < > ( ) ; for ( int i = 0 ; i < numNode ; i ++ ) { nodes . add ( new Node ( ) ) ; } for ( int i = 0 ; i < numNode - 1 ; i ++ ) { int a = in . nextInt ( ) - 1 ; int b = in . nextInt ( ) - 1 ; nodes . get ( a ) . addChild ( nodes . get ( b ) ) ; nodes . get ( b ) . addChild ( nodes . get ( a ) ) ; } int best = 0 ; for ( Node n : nodes ) { best = Math . max ( best , n . maxChildren ( null ) ) ; } int res = numNode - best ; out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + res ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static class Node { ArrayList < Node > children ; public Node ( ) { children = new ArrayList < > ( ) ; } public void addChild ( Node n ) { children . add ( n ) ; } public int maxChildren ( Node parent ) { int best = 0 ; int best2 = 0 ; for ( Node n : children ) { if ( n != parent ) { int nv = n . maxChildren ( this ) ; if ( nv > best ) { best2 = best ; best = nv ; } else if ( nv > best2 ) { best2 = nv ; } } } if ( best2 == 0 ) return 1 ; return best + best2 + 1 ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( new FileReader ( INPUT_FILE_NAME ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( OUTPUT_FILE_NAME ) ) ) { int numT = in . nextInt ( ) ; for ( int t = 1 ; t <= numT ; t ++ ) { System . out . println ( \" Case \u2581 \" + t ) ; int numNode = in . nextInt ( ) ; ArrayList < Node > nodes = new ArrayList < > ( ) ; for ( int i = 0 ; i < numNode ; i ++ ) { nodes . add ( new Node ( ) ) ; } for ( int i = 0 ; i < numNode - 1 ; i ++ ) { int a = in . nextInt ( ) - 1 ; int b = in . nextInt ( ) - 1 ; nodes . get ( a ) . addChild ( nodes . get ( b ) ) ; nodes . get ( b ) . addChild ( nodes . get ( a ) ) ; } int best = 0 ; for ( Node n : nodes ) { best = Math . max ( best , n . maxChildren ( null ) ) ; } int res = numNode - best ; out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + res ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": [["Node", "public Node ( ) { children = new ArrayList < > ( ) ; }"], ["addChild", "public void addChild ( Node n ) { children . add ( n ) ; }"], ["maxChildren", "public int maxChildren ( Node parent ) { int best = 0 ; int best2 = 0 ; for ( Node n : children ) { if ( n != parent ) { int nv = n . maxChildren ( this ) ; if ( nv > best ) { best2 = best ; best = nv ; } else if ( nv > best2 ) { best2 = nv ; } } } if ( best2 == 0 ) return 1 ; return best + best2 + 1 ; }"]]}, {"id": "1", "code": "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . Scanner ; public class FullBinaryTree { public static int ans ; public static int tans ; public static boolean [ ] vis ; public static ArrayList < Integer > [ ] adj ; public static void main ( String [ ] Args ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( \" B - large \u2581 ( 2 ) . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" things . out \" ) ) ; int t = sc . nextInt ( ) , cc = 0 ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; adj = new ArrayList [ n ] ; for ( int k = 0 ; k < n ; k ++ ) adj [ k ] = new ArrayList < Integer > ( ) ; for ( int k = 0 ; k < n - 1 ; k ++ ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; adj [ a ] . add ( b ) ; adj [ b ] . add ( a ) ; } vis = new boolean [ n ] ; ans = n ; for ( int k = 0 ; k < n ; k ++ ) { Arrays . fill ( vis , false ) ; ans = Math . min ( n - dfs ( k ) , ans ) ; } out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , ++ cc , ans ) ; } out . close ( ) ; } private static int dfs ( int k ) { vis [ k ] = true ; ArrayList < Integer > al = new ArrayList < Integer > ( ) ; for ( Integer i : adj [ k ] ) if ( ! vis [ i ] ) al . add ( dfs ( i ) ) ; if ( al . size ( ) < 2 ) return 1 ; Collections . sort ( al ) ; return 1 + al . get ( al . size ( ) - 1 ) + al . get ( al . size ( ) - 2 ) ; } private static long make ( String s ) { return Long . parseLong ( s , 2 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] Args ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( \" B - large \u2581 ( 2 ) . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" things . out \" ) ) ; int t = sc . nextInt ( ) , cc = 0 ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; adj = new ArrayList [ n ] ; for ( int k = 0 ; k < n ; k ++ ) adj [ k ] = new ArrayList < Integer > ( ) ; for ( int k = 0 ; k < n - 1 ; k ++ ) { int a = sc . nextInt ( ) - 1 ; int b = sc . nextInt ( ) - 1 ; adj [ a ] . add ( b ) ; adj [ b ] . add ( a ) ; } vis = new boolean [ n ] ; ans = n ; for ( int k = 0 ; k < n ; k ++ ) { Arrays . fill ( vis , false ) ; ans = Math . min ( n - dfs ( k ) , ans ) ; } out . printf ( \" Case \u2581 # % d : \u2581 % d % n \" , ++ cc , ans ) ; } out . close ( ) ; }"], ["dfs", "private static int dfs ( int k ) { vis [ k ] = true ; ArrayList < Integer > al = new ArrayList < Integer > ( ) ; for ( Integer i : adj [ k ] ) if ( ! vis [ i ] ) al . add ( dfs ( i ) ) ; if ( al . size ( ) < 2 ) return 1 ; Collections . sort ( al ) ; return 1 + al . get ( al . size ( ) - 1 ) + al . get ( al . size ( ) - 2 ) ; }"], ["make", "private static long make ( String s ) { return Long . parseLong ( s , 2 ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "from collections import defaultdict NEW_LINE from heapq import nlargest NEW_LINE def maxSize ( adj , node , parent ) : NEW_LINE INDENT children = adj [ node ] - { parent } NEW_LINE if len ( children ) == 1 : return 1 NEW_LINE return sum ( nlargest ( 2 , ( maxSize ( adj , child , node ) for child in children ) ) ) + 1 NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE adj = defaultdict ( set ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . add ( b ) NEW_LINE adj [ b ] . add ( a ) NEW_LINE DEDENT result = N - max ( maxSize ( adj , root , None ) for root in range ( 1 , N + 1 ) ) NEW_LINE assert 0 <= result <= N NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( t + 1 , result ) ) NEW_LINE DEDENT", "functions_standalone": [["maxSize", "def maxSize ( adj , node , parent ) : NEW_LINE INDENT children = adj [ node ] - { parent } NEW_LINE if len ( children ) == 1 : return 1 NEW_LINE return sum ( nlargest ( 2 , ( maxSize ( adj , child , node ) for child in children ) ) ) + 1 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "10", "code": "def search ( tree , root , parent ) : NEW_LINE INDENT children = tree [ root ] . copy ( ) NEW_LINE if parent != 0 : NEW_LINE INDENT del children [ children . index ( parent ) ] NEW_LINE DEDENT if len ( children ) <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT firstlarge = 0 NEW_LINE secondlarge = 0 NEW_LINE for child in children : NEW_LINE INDENT result = search ( tree , child , root ) NEW_LINE if result > firstlarge : NEW_LINE INDENT secondlarge = firstlarge NEW_LINE firstlarge = result NEW_LINE DEDENT elif result > secondlarge : NEW_LINE INDENT secondlarge = result NEW_LINE DEDENT DEDENT return firstlarge + secondlarge + 1 NEW_LINE DEDENT fin = open ( ' B - large . in ' , ' r ' ) NEW_LINE fout = open ( ' out . txt ' , ' w ' ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for casecount in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( fin . readline ( ) ) NEW_LINE tree = [ [ ] for x in range ( 0 , n + 1 ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT xi , yi = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE tree [ xi ] . append ( yi ) NEW_LINE tree [ yi ] . append ( xi ) NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = search ( tree , i , 0 ) NEW_LINE if temp > result : NEW_LINE INDENT result = temp NEW_LINE DEDENT DEDENT fout . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( casecount , n - result ) ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE", "functions_standalone": [["search", "def search ( tree , root , parent ) : NEW_LINE INDENT children = tree [ root ] . copy ( ) NEW_LINE if parent != 0 : NEW_LINE INDENT del children [ children . index ( parent ) ] NEW_LINE DEDENT if len ( children ) <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT firstlarge = 0 NEW_LINE secondlarge = 0 NEW_LINE for child in children : NEW_LINE INDENT result = search ( tree , child , root ) NEW_LINE if result > firstlarge : NEW_LINE INDENT secondlarge = firstlarge NEW_LINE firstlarge = result NEW_LINE DEDENT elif result > secondlarge : NEW_LINE INDENT secondlarge = result NEW_LINE DEDENT DEDENT return firstlarge + secondlarge + 1 NEW_LINE DEDENT"]], "functions_class": []}, {"id": "5", "code": "from collections import deque NEW_LINE T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE edges = [ tuple ( int ( i ) - 1 for i in input ( ) . split ( ) ) for i in range ( N - 1 ) ] NEW_LINE neigh = [ [ ] for i in range ( N ) ] NEW_LINE for i , j in edges : NEW_LINE INDENT neigh [ i ] . append ( j ) NEW_LINE neigh [ j ] . append ( i ) NEW_LINE DEDENT ans = N NEW_LINE for root in range ( N ) : NEW_LINE INDENT parent = [ None for i in range ( N ) ] NEW_LINE children = [ [ ] for i in range ( N ) ] NEW_LINE queue = deque ( [ root ] ) NEW_LINE order = [ root ] NEW_LINE while queue : NEW_LINE INDENT cur = queue . popleft ( ) NEW_LINE for i in neigh [ cur ] : NEW_LINE INDENT if parent [ i ] == None and i != root : NEW_LINE INDENT parent [ i ] = cur NEW_LINE children [ cur ] . append ( i ) NEW_LINE queue . append ( i ) NEW_LINE order . append ( i ) NEW_LINE DEDENT DEDENT DEDENT order = list ( reversed ( order ) ) NEW_LINE size = [ None for i in range ( N ) ] NEW_LINE cost = [ None for i in range ( N ) ] NEW_LINE for i in order : NEW_LINE INDENT c = children [ i ] NEW_LINE d = len ( c ) NEW_LINE size [ i ] = sum ( size [ j ] for j in c ) + 1 NEW_LINE if d == 0 : NEW_LINE INDENT cost [ i ] = 0 NEW_LINE DEDENT elif d == 1 : NEW_LINE INDENT cost [ i ] = size [ c [ 0 ] ] NEW_LINE DEDENT elif d == 2 : NEW_LINE INDENT cost [ i ] = cost [ c [ 0 ] ] + cost [ c [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT cost [ i ] = size [ i ] - 1 - sum ( sorted ( size [ j ] - cost [ j ] for j in c ) [ - 2 : ] ) NEW_LINE DEDENT DEDENT ans = min ( ans , cost [ root ] ) NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , ans ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "16", "code": "import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE parents = [ ] NEW_LINE edgecopy = [ ] NEW_LINE def DP ( node ) : NEW_LINE INDENT childsizes = [ ] NEW_LINE aScores = [ ] NEW_LINE for child in edges [ node ] : NEW_LINE INDENT if child == parents [ node ] : NEW_LINE INDENT continue NEW_LINE DEDENT parents [ child ] = node ; NEW_LINE size , score = DP ( child ) NEW_LINE childsizes . append ( size ) NEW_LINE aScores . append ( size - score ) NEW_LINE DEDENT totalsize = sum ( childsizes ) + 1 NEW_LINE if len ( childsizes ) < 2 : NEW_LINE INDENT return ( totalsize , totalsize - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT aScores . sort ( ) NEW_LINE return ( totalsize , totalsize - 1 - aScores [ - 1 ] - aScores [ - 2 ] ) NEW_LINE DEDENT DEDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE edges = [ [ ] for i in range ( N ) ] NEW_LINE for e in range ( N - 1 ) : NEW_LINE INDENT x , y = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE edges [ x - 1 ] . append ( y - 1 ) NEW_LINE edges [ y - 1 ] . append ( x - 1 ) NEW_LINE DEDENT ans = N NEW_LINE for root in range ( N ) : NEW_LINE INDENT edgecopy [ : ] = [ edges [ x ] [ : ] for x in range ( N ) ] NEW_LINE parents [ : ] = [ - 1 ] * N NEW_LINE parents [ root ] = root NEW_LINE ( size , score ) = DP ( root ) NEW_LINE ans = min ( ans , score ) NEW_LINE DEDENT print ( \" Case \u2581 # \" , case , \" : \u2581 \" , ans , sep = ' ' ) NEW_LINE DEDENT", "functions_standalone": [["DP", "def DP ( node ) : NEW_LINE INDENT childsizes = [ ] NEW_LINE aScores = [ ] NEW_LINE for child in edges [ node ] : NEW_LINE INDENT if child == parents [ node ] : NEW_LINE INDENT continue NEW_LINE DEDENT parents [ child ] = node ; NEW_LINE size , score = DP ( child ) NEW_LINE childsizes . append ( size ) NEW_LINE aScores . append ( size - score ) NEW_LINE DEDENT totalsize = sum ( childsizes ) + 1 NEW_LINE if len ( childsizes ) < 2 : NEW_LINE INDENT return ( totalsize , totalsize - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT aScores . sort ( ) NEW_LINE return ( totalsize , totalsize - 1 - aScores [ - 1 ] - aScores [ - 2 ] ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "6", "code": "from collections import defaultdict NEW_LINE def rl ( t ) : NEW_LINE INDENT return [ t ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE DEDENT def solve ( n , edges ) : NEW_LINE INDENT e = [ [ ] for i in range ( n ) ] NEW_LINE for a , b in edges : NEW_LINE INDENT e [ a - 1 ] . append ( b - 1 ) NEW_LINE e [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT def f ( i , p ) : NEW_LINE INDENT childs = [ j for j in e [ i ] if j != p ] NEW_LINE if len ( childs ) < 2 : NEW_LINE INDENT res = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d = [ f ( j , i ) for j in childs ] NEW_LINE d . sort ( reverse = True ) NEW_LINE res = d [ 0 ] + d [ 1 ] + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT ds = [ f ( root , - 1 ) for root in range ( n ) ] NEW_LINE return n - max ( ds ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T , * _ = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT n , * _ = rl ( int ) NEW_LINE edges = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = rl ( int ) NEW_LINE edges . append ( ( a , b ) ) NEW_LINE DEDENT answer = solve ( n , edges ) NEW_LINE print ( ' Case \u2581 # % d : ' % C , answer ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "functions_standalone": [["rl", "def rl ( t ) : NEW_LINE INDENT return [ t ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE DEDENT"], ["solve", "def solve ( n , edges ) : NEW_LINE INDENT e = [ [ ] for i in range ( n ) ] NEW_LINE for a , b in edges : NEW_LINE INDENT e [ a - 1 ] . append ( b - 1 ) NEW_LINE e [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT def f ( i , p ) : NEW_LINE INDENT childs = [ j for j in e [ i ] if j != p ] NEW_LINE if len ( childs ) < 2 : NEW_LINE INDENT res = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d = [ f ( j , i ) for j in childs ] NEW_LINE d . sort ( reverse = True ) NEW_LINE res = d [ 0 ] + d [ 1 ] + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT ds = [ f ( root , - 1 ) for root in range ( n ) ] NEW_LINE return n - max ( ds ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT T , * _ = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT n , * _ = rl ( int ) NEW_LINE edges = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = rl ( int ) NEW_LINE edges . append ( ( a , b ) ) NEW_LINE DEDENT answer = solve ( n , edges ) NEW_LINE print ( ' Case \u2581 # % d : ' % C , answer ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_13", "java": [{"id": "4", "code": "import java . util . * ; import java . io . * ; public class C { public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = input . nextInt ( ) ; int [ ] data = new int [ 2 * N ] ; for ( int i = 0 ; i < N ; i ++ ) data [ arr [ i ] - i + N ] ++ ; double score = 0 ; for ( int i = 700 ; i < 1000 ; i ++ ) score += data [ i ] ; for ( int i = 1000 ; i < 1300 ; i ++ ) score -= data [ i ] ; boolean good = score > - 40 ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; if ( good ) System . out . println ( \" GOOD \" ) ; else System . out . println ( \" BAD \" ) ; } } }", "functions_standalone": [["main", "public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = input . nextInt ( ) ; int [ ] data = new int [ 2 * N ] ; for ( int i = 0 ; i < N ; i ++ ) data [ arr [ i ] - i + N ] ++ ; double score = 0 ; for ( int i = 700 ; i < 1000 ; i ++ ) score += data [ i ] ; for ( int i = 1000 ; i < 1300 ; i ++ ) score -= data [ i ] ; boolean good = score > - 40 ; System . out . printf ( \" Case \u2581 # % d : \u2581 \" , n + 1 ) ; if ( good ) System . out . println ( \" GOOD \" ) ; else System . out . println ( \" BAD \" ) ; } }"]], "functions_class": []}, {"id": "13", "code": "import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class ProperShuffle { public final static String INPUT_FILE_NAME = \" C - small - attempt0(1 ) . in \" ; public final static String OUTPUT_FILE_NAME = \" ProperShuffle . out \" ; public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( new FileReader ( INPUT_FILE_NAME ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( OUTPUT_FILE_NAME ) ) ) { double [ ] [ ] rv = new double [ 1000 ] [ 1000 ] ; for ( int t = 0 ; t < 1000 ; t ++ ) { double [ ] cv = new double [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( i == t ) { cv [ i ] = 1 ; } else { cv [ i ] = 0 ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { double [ ] nv = new double [ 1000 ] ; for ( int j = 0 ; j < 1000 ; j ++ ) { if ( i != j ) { nv [ j ] = cv [ j ] * .999 + cv [ i ] * .001 ; } } nv [ i ] = .001 ; cv = nv ; } rv [ t ] = cv ; } System . out . println ( \" done \" ) ; int numT = in . nextInt ( ) ; int res = 0 ; for ( int t = 1 ; t <= numT ; t ++ ) { in . nextInt ( ) ; double total = 0 ; for ( int i = 0 ; i < 1000 ; i ++ ) { int v = in . nextInt ( ) ; total += rv [ v ] [ i ] ; } if ( total <= 1.005 ) { out . println ( \" Case \u2581 # \" + t + \" : \u2581 GOOD \" ) ; res ++ ; } else { out . println ( \" Case \u2581 # \" + t + \" : \u2581 BAD \" ) ; } } System . out . println ( res ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( new FileReader ( INPUT_FILE_NAME ) ) ; PrintWriter out = new PrintWriter ( new FileWriter ( OUTPUT_FILE_NAME ) ) ) { double [ ] [ ] rv = new double [ 1000 ] [ 1000 ] ; for ( int t = 0 ; t < 1000 ; t ++ ) { double [ ] cv = new double [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( i == t ) { cv [ i ] = 1 ; } else { cv [ i ] = 0 ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { double [ ] nv = new double [ 1000 ] ; for ( int j = 0 ; j < 1000 ; j ++ ) { if ( i != j ) { nv [ j ] = cv [ j ] * .999 + cv [ i ] * .001 ; } } nv [ i ] = .001 ; cv = nv ; } rv [ t ] = cv ; } System . out . println ( \" done \" ) ; int numT = in . nextInt ( ) ; int res = 0 ; for ( int t = 1 ; t <= numT ; t ++ ) { in . nextInt ( ) ; double total = 0 ; for ( int i = 0 ; i < 1000 ; i ++ ) { int v = in . nextInt ( ) ; total += rv [ v ] [ i ] ; } if ( total <= 1.005 ) { out . println ( \" Case \u2581 # \" + t + \" : \u2581 GOOD \" ) ; res ++ ; } else { out . println ( \" Case \u2581 # \" + t + \" : \u2581 BAD \" ) ; } } System . out . println ( res ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"]], "functions_class": []}, {"id": "11", "code": "import java . io . File ; import java . io . FileInputStream ; import java . util . Arrays ; import java . util . Random ; import java . util . Scanner ; public class ProperShuffle { static Random random = new Random ( ) ; private static String file = \" data / r1c - C - small - attempt0 . in \" ; private static final int LEN = 1000 ; private static final int TRY_COUNT = 1000 * LEN ; public static void main ( String [ ] args ) throws Exception { FileInputStream is = new FileInputStream ( new File ( file ) ) ; Scanner scanner = new Scanner ( is ) ; int [ ] [ ] count = new int [ LEN ] [ LEN ] ; int [ ] arr = new int [ LEN ] ; for ( int i = 0 ; i < LEN ; i ++ ) { arr [ i ] = i ; } for ( int i = 0 ; i < TRY_COUNT ; i ++ ) { int [ ] copy = arr . clone ( ) ; shuffle ( copy ) ; for ( int j = 0 ; j < LEN ; j ++ ) { count [ copy [ j ] ] [ j ] ++ ; } } int T = scanner . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int n = scanner . nextInt ( ) ; double prob = 1.0 ; for ( int i = 0 ; i < n ; i ++ ) { int s = scanner . nextInt ( ) ; prob *= ( double ) count [ s ] [ i ] / ( double ) ( TRY_COUNT / LEN ) ; } if ( prob > 1.0 ) { out ( t , \" BAD \" ) ; } else { out ( t , \" GOOD \" ) ; } } } static void shuffle ( int arr [ ] ) { int len = arr . length ; for ( int k = 0 ; k < len ; k ++ ) { int p = random . nextInt ( len ) ; int t = arr [ p ] ; arr [ p ] = arr [ k ] ; arr [ k ] = t ; } } static void out ( int t , Object ans ) { System . out . println ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + ans ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) throws Exception { FileInputStream is = new FileInputStream ( new File ( file ) ) ; Scanner scanner = new Scanner ( is ) ; int [ ] [ ] count = new int [ LEN ] [ LEN ] ; int [ ] arr = new int [ LEN ] ; for ( int i = 0 ; i < LEN ; i ++ ) { arr [ i ] = i ; } for ( int i = 0 ; i < TRY_COUNT ; i ++ ) { int [ ] copy = arr . clone ( ) ; shuffle ( copy ) ; for ( int j = 0 ; j < LEN ; j ++ ) { count [ copy [ j ] ] [ j ] ++ ; } } int T = scanner . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int n = scanner . nextInt ( ) ; double prob = 1.0 ; for ( int i = 0 ; i < n ; i ++ ) { int s = scanner . nextInt ( ) ; prob *= ( double ) count [ s ] [ i ] / ( double ) ( TRY_COUNT / LEN ) ; } if ( prob > 1.0 ) { out ( t , \" BAD \" ) ; } else { out ( t , \" GOOD \" ) ; } } }"], ["shuffle", "static void shuffle ( int arr [ ] ) { int len = arr . length ; for ( int k = 0 ; k < len ; k ++ ) { int p = random . nextInt ( len ) ; int t = arr [ p ] ; arr [ p ] = arr [ k ] ; arr [ k ] = t ; } }"], ["out", "static void out ( int t , Object ans ) { System . out . println ( \" Case \u2581 # \" + ( t + 1 ) + \" : \u2581 \" + ans ) ; }"]], "functions_class": []}], "python": [{"id": "15", "code": "import sys NEW_LINE def prework ( argv ) : NEW_LINE INDENT l = range ( 1000 ) NEW_LINE def test ( func ) : NEW_LINE INDENT lg = list ( l ) NEW_LINE func ( lg ) NEW_LINE return check ( lg ) NEW_LINE DEDENT ans = [ ( test ( good ) , test ( bad ) ) for _ in range ( 20 ) ] NEW_LINE print ( * ans , sep = ' \\n ' , file = sys . stderr ) NEW_LINE return \" above \" NEW_LINE DEDENT import random NEW_LINE def good ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( k , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT def bad ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( 0 , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT def check ( l ) : NEW_LINE INDENT a = len ( [ 1 for i , x in enumerate ( l ) if i - x > 0 ] ) NEW_LINE b = len ( [ 1 for i , x in enumerate ( l ) if i - x < 0 ] ) NEW_LINE r = a / b NEW_LINE return r > 0.94 NEW_LINE DEDENT def once ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE return \" GOOD \" if check ( l ) else \" BAD \" NEW_LINE pass NEW_LINE DEDENT def printerr ( * v ) : NEW_LINE INDENT print ( * v , file = sys . stderr ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT TT = int ( input ( ) ) NEW_LINE for tt in range ( 1 , TT + 1 ) : NEW_LINE INDENT printerr ( \" coping \u2581 Case \u2581 % d . . \" % ( tt ) ) NEW_LINE ans = once ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( tt , ( ans ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT msg = prework ( sys . argv ) NEW_LINE print ( \" prework \u2581 down \u2581 with \" , msg , file = sys . stderr ) NEW_LINE main ( ) NEW_LINE DEDENT", "functions_standalone": [["prework", "def prework ( argv ) : NEW_LINE INDENT l = range ( 1000 ) NEW_LINE def test ( func ) : NEW_LINE INDENT lg = list ( l ) NEW_LINE func ( lg ) NEW_LINE return check ( lg ) NEW_LINE DEDENT ans = [ ( test ( good ) , test ( bad ) ) for _ in range ( 20 ) ] NEW_LINE print ( * ans , sep = ' \\n ' , file = sys . stderr ) NEW_LINE return \" above \" NEW_LINE DEDENT"], ["good", "def good ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( k , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT"], ["bad", "def bad ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( 0 , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT"], ["check", "def check ( l ) : NEW_LINE INDENT a = len ( [ 1 for i , x in enumerate ( l ) if i - x > 0 ] ) NEW_LINE b = len ( [ 1 for i , x in enumerate ( l ) if i - x < 0 ] ) NEW_LINE r = a / b NEW_LINE return r > 0.94 NEW_LINE DEDENT"], ["once", "def once ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE return \" GOOD \" if check ( l ) else \" BAD \" NEW_LINE pass NEW_LINE DEDENT"], ["printerr", "def printerr ( * v ) : NEW_LINE INDENT print ( * v , file = sys . stderr ) NEW_LINE DEDENT"], ["main", "def main ( ) : NEW_LINE INDENT TT = int ( input ( ) ) NEW_LINE for tt in range ( 1 , TT + 1 ) : NEW_LINE INDENT printerr ( \" coping \u2581 Case \u2581 % d . . \" % ( tt ) ) NEW_LINE ans = once ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( tt , ( ans ) ) ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "14", "code": "def reader ( f ) : NEW_LINE INDENT f = open ( f ) NEW_LINE for line in f : NEW_LINE INDENT yield line . strip ( ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT def write ( f , lst ) : NEW_LINE INDENT for i in xrange ( len ( lst ) ) : NEW_LINE INDENT lst [ i ] = \" Case \u2581 # % s : % s \" % ( i + 1 , lst [ i ] ) NEW_LINE DEDENT f = open ( f , ' w ' ) NEW_LINE f . write ( ' \\n ' . join ( lst ) ) NEW_LINE f . close ( ) NEW_LINE DEDENT", "functions_standalone": [["reader", "def reader ( f ) : NEW_LINE INDENT f = open ( f ) NEW_LINE for line in f : NEW_LINE INDENT yield line . strip ( ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "20", "code": "import math NEW_LINE SCALEFACTOR = 2 NEW_LINE SCALEFACTOR2 = 0.8 NEW_LINE def getProbability ( position , number , N = 1000 ) : NEW_LINE INDENT N = float ( N ) NEW_LINE if number > position : NEW_LINE INDENT p = math . sqrt ( position ** 2 + ( N - number ) ** 2 ) / N NEW_LINE DEDENT else : NEW_LINE INDENT p = math . sqrt ( ( position - N / 2 ) ** 2 + ( number - N / 2 ) ** 2 ) / N * SCALEFACTOR2 NEW_LINE DEDENT return 1 / N - ( 1 / N ) * SCALEFACTOR + ( p * 2 * ( 1 / N ) * SCALEFACTOR ) NEW_LINE DEDENT with open ( ' C . in ' ) as f : NEW_LINE INDENT with open ( ' C . out ' , ' w ' ) as f2 : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE output = \" \" NEW_LINE scores = [ ] NEW_LINE for i in range ( int ( lines [ 0 ] ) ) : NEW_LINE INDENT permutation = [ int ( n ) for n in lines [ 2 + i * 2 ] . split ( \" \u2581 \" ) ] NEW_LINE score = 0 NEW_LINE for q in range ( len ( permutation ) ) : NEW_LINE INDENT score = score + getProbability ( q , permutation [ q ] , len ( permutation ) ) NEW_LINE DEDENT scores . append ( score ) NEW_LINE DEDENT median = sorted ( scores ) [ 60 ] NEW_LINE for i in range ( len ( scores ) ) : NEW_LINE INDENT score = scores [ i ] NEW_LINE output += \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" NEW_LINE if score > median : NEW_LINE INDENT output += \" BAD \" NEW_LINE DEDENT else : NEW_LINE INDENT output += \" GOOD \" NEW_LINE DEDENT output += \" \\n \" NEW_LINE DEDENT print ( output ) NEW_LINE f2 . write ( output ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["getProbability", "def getProbability ( position , number , N = 1000 ) : NEW_LINE INDENT N = float ( N ) NEW_LINE if number > position : NEW_LINE INDENT p = math . sqrt ( position ** 2 + ( N - number ) ** 2 ) / N NEW_LINE DEDENT else : NEW_LINE INDENT p = math . sqrt ( ( position - N / 2 ) ** 2 + ( number - N / 2 ) ** 2 ) / N * SCALEFACTOR2 NEW_LINE DEDENT return 1 / N - ( 1 / N ) * SCALEFACTOR + ( p * 2 * ( 1 / N ) * SCALEFACTOR ) NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "import random NEW_LINE import numpy as np NEW_LINE import sys NEW_LINE import math NEW_LINE def bad ( n ) : NEW_LINE INDENT xs = list ( range ( n ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = random . randint ( 0 , n - 1 ) NEW_LINE xs [ i ] , xs [ p ] = xs [ p ] , xs [ i ] NEW_LINE DEDENT return xs NEW_LINE DEDENT def bad_dist ( n ) : NEW_LINE INDENT ds = np . eye ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ds_new = ds . copy ( ) NEW_LINE ds /= n NEW_LINE for p in range ( n ) : NEW_LINE INDENT if i == p : NEW_LINE INDENT continue NEW_LINE DEDENT ds_new [ i ] -= ds [ i ] NEW_LINE ds_new [ p ] -= ds [ p ] NEW_LINE ds_new [ i ] += ds [ p ] NEW_LINE ds_new [ p ] += ds [ i ] NEW_LINE DEDENT ds = ds_new NEW_LINE DEDENT return ds NEW_LINE DEDENT len_seq = 1000 NEW_LINE bd = bad_dist ( len_seq ) NEW_LINE log_bd = np . log ( bd ) NEW_LINE n_cases = int ( sys . stdin . readline ( ) ) NEW_LINE for i_case in range ( n_cases ) : NEW_LINE INDENT sys . stdin . readline ( ) NEW_LINE ns = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE log_p_good = math . log ( 1 / len_seq ) * len_seq + math . log ( 0.5 ) NEW_LINE log_p_s_bad = 0 NEW_LINE for ( i , n ) in enumerate ( ns ) : NEW_LINE INDENT log_p_s_bad += log_bd [ i ] [ n ] NEW_LINE DEDENT log_p_bad = log_p_s_bad + math . log ( 0.5 ) NEW_LINE res = ' GOOD ' if log_p_good > log_p_bad else ' BAD ' NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i_case + 1 , res ) ) NEW_LINE DEDENT", "functions_standalone": [["bad", "def bad ( n ) : NEW_LINE INDENT xs = list ( range ( n ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = random . randint ( 0 , n - 1 ) NEW_LINE xs [ i ] , xs [ p ] = xs [ p ] , xs [ i ] NEW_LINE DEDENT return xs NEW_LINE DEDENT"], ["bad_dist", "def bad_dist ( n ) : NEW_LINE INDENT ds = np . eye ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ds_new = ds . copy ( ) NEW_LINE ds /= n NEW_LINE for p in range ( n ) : NEW_LINE INDENT if i == p : NEW_LINE INDENT continue NEW_LINE DEDENT ds_new [ i ] -= ds [ i ] NEW_LINE ds_new [ p ] -= ds [ p ] NEW_LINE ds_new [ i ] += ds [ p ] NEW_LINE ds_new [ p ] += ds [ i ] NEW_LINE DEDENT ds = ds_new NEW_LINE DEDENT return ds NEW_LINE DEDENT"]], "functions_class": []}, {"id": "9", "code": "def countBA ( perm ) : NEW_LINE INDENT b = 0 NEW_LINE for i in range ( len ( perm ) ) : NEW_LINE INDENT if perm . index ( i ) < i : b += 1 NEW_LINE DEDENT return b NEW_LINE DEDENT def determine ( perm ) : NEW_LINE INDENT return ' BAD ' if countBA ( perm ) > 515 else ' GOOD ' NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE perm = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { } ' . format ( t + 1 , determine ( perm ) ) ) NEW_LINE DEDENT", "functions_standalone": [["countBA", "def countBA ( perm ) : NEW_LINE INDENT b = 0 NEW_LINE for i in range ( len ( perm ) ) : NEW_LINE INDENT if perm . index ( i ) < i : b += 1 NEW_LINE DEDENT return b NEW_LINE DEDENT"], ["determine", "def determine ( perm ) : NEW_LINE INDENT return ' BAD ' if countBA ( perm ) > 515 else ' GOOD ' NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "codejam_14_22", "java": [{"id": "15", "code": "import java . util . * ; public class B { static int a , b , k ; static long doit ( ) { int i , j ; long l = 0 ; if ( a < 1001 && b < 1001 && k < 1001 ) { for ( i = 0 ; i < a ; i ++ ) for ( j = 0 ; j < b ; j ++ ) if ( ( i & j ) < k ) l ++ ; } return l ; } public static void main ( String arg [ ] ) throws Exception { int tc , t ; long ans ; Scanner s = new Scanner ( System . in ) ; String line = s . nextLine ( ) ; tc = Integer . parseInt ( line ) ; for ( t = 1 ; t <= tc ; t ++ ) { line = s . nextLine ( ) ; String ss [ ] = line . split ( \" \u2581 + \" ) ; a = Integer . parseInt ( ss [ 0 ] ) ; b = Integer . parseInt ( ss [ 1 ] ) ; k = Integer . parseInt ( ss [ 2 ] ) ; ans = doit ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + ans ) ; } } }", "functions_standalone": [["doit", "static long doit ( ) { int i , j ; long l = 0 ; if ( a < 1001 && b < 1001 && k < 1001 ) { for ( i = 0 ; i < a ; i ++ ) for ( j = 0 ; j < b ; j ++ ) if ( ( i & j ) < k ) l ++ ; } return l ; }"], ["main", "public static void main ( String arg [ ] ) throws Exception { int tc , t ; long ans ; Scanner s = new Scanner ( System . in ) ; String line = s . nextLine ( ) ; tc = Integer . parseInt ( line ) ; for ( t = 1 ; t <= tc ; t ++ ) { line = s . nextLine ( ) ; String ss [ ] = line . split ( \" \u2581 + \" ) ; a = Integer . parseInt ( ss [ 0 ] ) ; b = Integer . parseInt ( ss [ 1 ] ) ; k = Integer . parseInt ( ss [ 2 ] ) ; ans = doit ( ) ; System . out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + ans ) ; } }"]], "functions_class": []}, {"id": "16", "code": "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Lottery { static BufferedReader stdin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static StringTokenizer st = new StringTokenizer ( \" \" ) ; static String readString ( ) throws Exception { while ( ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( stdin . readLine ( ) ) ; } return st . nextToken ( ) ; } static int readInt ( ) throws Exception { return Integer . parseInt ( readString ( ) ) ; } static double readDouble ( ) throws Exception { return Double . parseDouble ( readString ( ) ) ; } public static void main ( String [ ] args ) throws Exception { int T = readInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t ) ; solve ( ) ; } } static void solve ( ) throws Exception { int A , B , K ; A = readInt ( ) ; B = readInt ( ) ; K = readInt ( ) ; long total = 0L ; for ( int a = 0 ; a < A ; a ++ ) { for ( int b = 0 ; b < B ; b ++ ) { if ( ( a & b ) < K ) total ++ ; } } System . out . printf ( \" % d \\n \" , total ) ; } }", "functions_standalone": [["readString", "static String readString ( ) throws Exception { while ( ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( stdin . readLine ( ) ) ; } return st . nextToken ( ) ; }"], ["readInt", "static int readInt ( ) throws Exception { return Integer . parseInt ( readString ( ) ) ; }"], ["readDouble", "static double readDouble ( ) throws Exception { return Double . parseDouble ( readString ( ) ) ; }"], ["main", "public static void main ( String [ ] args ) throws Exception { int T = readInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { System . out . printf ( \" Case \u2581 # % d : \u2581 \" , t ) ; solve ( ) ; } }"], ["solve", "static void solve ( ) throws Exception { int A , B , K ; A = readInt ( ) ; B = readInt ( ) ; K = readInt ( ) ; long total = 0L ; for ( int a = 0 ; a < A ; a ++ ) { for ( int b = 0 ; b < B ; b ++ ) { if ( ( a & b ) < K ) total ++ ; } } System . out . printf ( \" % d \\n \" , total ) ; }"]], "functions_class": []}], "python": [{"id": "8", "code": "import sys NEW_LINE from itertools import zip_longest as zip NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT A , B , K = tuple ( int ( i ) for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT for b in range ( B ) : NEW_LINE INDENT if a & b < K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( t + 1 , cnt ) ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": []}, {"id": "2", "code": "import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ int ( x ) for x in xs ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ float ( x ) for x in xs ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE if len ( args ) == 1 : NEW_LINE INDENT infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE DEDENT elif len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] == ' - ' : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 args , \u2581 not \u2581 { : d } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [["readline", "def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT"], ["readint", "def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT"], ["readfloat", "def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT"], ["readints", "def readints ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ int ( x ) for x in xs ] NEW_LINE DEDENT"], ["readfloats", "def readfloats ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ float ( x ) for x in xs ] NEW_LINE DEDENT"], ["writeline", "def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT"], ["run", "def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE if len ( args ) == 1 : NEW_LINE INDENT infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE DEDENT elif len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] == ' - ' : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Expected \u2581 0 , \u2581 1 , \u2581 or \u2581 2 \u2581 args , \u2581 not \u2581 { : d } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}, {"id": "7", "code": "import sys NEW_LINE def emit ( text , * args ) : NEW_LINE INDENT msg = text % args NEW_LINE sys . stderr . write ( msg ) NEW_LINE sys . stdout . write ( msg ) NEW_LINE DEDENT def getline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT def solve ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( b ) : NEW_LINE INDENT if ( i & j ) < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT ncases = int ( getline ( ) ) NEW_LINE for casenr in range ( 1 , ncases + 1 ) : NEW_LINE INDENT a , b , k = [ int ( s ) for s in getline ( ) . split ( ) ] NEW_LINE emit ( \" Case \u2581 # % d : \u2581 % s \\n \" , casenr , solve ( a , b , k ) ) NEW_LINE DEDENT", "functions_standalone": [["emit", "def emit ( text , * args ) : NEW_LINE INDENT msg = text % args NEW_LINE sys . stderr . write ( msg ) NEW_LINE sys . stdout . write ( msg ) NEW_LINE DEDENT"], ["getline", "def getline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT"], ["solve", "def solve ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( b ) : NEW_LINE INDENT if ( i & j ) < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT"]], "functions_class": []}, {"id": "17", "code": "for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT A , B , K = ( int ( x ) - 1 for x in input ( ) . split ( ) ) NEW_LINE dp = [ [ - 1 ] * 8 for i in range ( 31 ) ] NEW_LINE def DP ( pos , a , b , k ) : NEW_LINE INDENT if pos < 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ pos ] [ a * 4 + b * 2 + k ] == - 1 : NEW_LINE INDENT dp [ pos ] [ a * 4 + b * 2 + k ] = 0 NEW_LINE bita = 0 if ( A & ( 1 << pos ) ) == 0 else 1 NEW_LINE bitb = 0 if ( B & ( 1 << pos ) ) == 0 else 1 NEW_LINE bitk = 0 if ( K & ( 1 << pos ) ) == 0 else 1 NEW_LINE for xa in range ( 2 ) : NEW_LINE INDENT for xb in range ( 2 ) : NEW_LINE INDENT if a == 0 and bita == 0 and xa == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if b == 0 and bitb == 0 and xb == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT xk = xa & xb NEW_LINE if k == 0 and bitk == 0 and xk == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT na = 1 if xa < bita else a NEW_LINE nb = 1 if xb < bitb else b NEW_LINE nk = 1 if xk < bitk else k NEW_LINE dp [ pos ] [ a * 4 + b * 2 + k ] += DP ( pos - 1 , na , nb , nk ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ pos ] [ a * 4 + b * 2 + k ] NEW_LINE DEDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( tc + 1 , DP ( 30 , 0 , 0 , 0 ) ) ) NEW_LINE DEDENT", "functions_standalone": [["DP", "def DP ( pos , a , b , k ) : NEW_LINE INDENT if pos < 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ pos ] [ a * 4 + b * 2 + k ] == - 1 : NEW_LINE INDENT dp [ pos ] [ a * 4 + b * 2 + k ] = 0 NEW_LINE bita = 0 if ( A & ( 1 << pos ) ) == 0 else 1 NEW_LINE bitb = 0 if ( B & ( 1 << pos ) ) == 0 else 1 NEW_LINE bitk = 0 if ( K & ( 1 << pos ) ) == 0 else 1 NEW_LINE for xa in range ( 2 ) : NEW_LINE INDENT for xb in range ( 2 ) : NEW_LINE INDENT if a == 0 and bita == 0 and xa == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if b == 0 and bitb == 0 and xb == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT xk = xa & xb NEW_LINE if k == 0 and bitk == 0 and xk == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT na = 1 if xa < bita else a NEW_LINE nb = 1 if xb < bitb else b NEW_LINE nk = 1 if xk < bitk else k NEW_LINE dp [ pos ] [ a * 4 + b * 2 + k ] += DP ( pos - 1 , na , nb , nk ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ pos ] [ a * 4 + b * 2 + k ] NEW_LINE DEDENT"]], "functions_class": []}]}