public class Improve { static int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " + calculateSquareSum ( n ) ) ; } }
import java . util . Scanner ; public class NewProblem { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; String start = s . next ( ) ; String end = s . next ( ) ; int n = start . length ( ) ; int k = s . nextInt ( ) ; int amount = 0 ; for ( int i = 1 ; i < n ; i ++ ) { String str = start . substring ( i , n ) + start . substring ( 0 , i ) ; if ( str . equals ( end ) ) amount ++ ; } if ( amount == 0 && ! start . equals ( end ) ) { System . out . println ( 0 ) ; System . exit ( 0 ) ; } long x = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( i % 2 == 0 ) x = ( x * ( n - 1 ) + 1 ) % 1000000007 ; else x = ( x * ( n - 1 ) - 1 ) % 1000000007 ; } long ans = amount * x ; if ( start . equals ( end ) ) { if ( k % 2 == 0 ) ans += x + 1 ; else ans += x - 1 ; } System . out . println ( ans % 1000000007 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; boolean go = false ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; if ( go == true ) System . out . println ( ) ; go = true ; int max = 0 ; int [ ] sum = new int [ n ] ; String [ ] name = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { name [ i ] = sc . next ( ) ; sum [ i ] = sc . nextInt ( ) * 3 + sc . nextInt ( ) * 0 + sc . nextInt ( ) * 1 ; max = Math . max ( max , sum [ i ] ) ; } for ( int i = max ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( sum [ j ] == i ) System . out . println ( name [ j ] + " , " + sum [ j ] ) ; } } } } }
import java . util . Scanner ; import java . util . Arrays ; public class MainClass { public static void main ( String [ ] agrs ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] lst = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lst [ i ] = sc . nextInt ( ) ; int res = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( lst [ i ] == 0 && lst [ i - 1 ] == 1 && lst [ i + 1 ] == 1 ) { res += 1 ; if ( i <= n - 4 ) { if ( lst [ i + 2 ] == 0 && lst [ i + 3 ] == 1 ) { i += 3 ; } } } } System . out . println ( res ) ; } }
public class GFG { static int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } static int toDeci ( String str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str . charAt ( i ) ) >= base ) { return - 1 ; } num += val ( str . charAt ( i ) ) * power ; power = power * base ; } return num ; } static void checkCorrespond ( String [ ] str , int x ) { int counter = 0 ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 ; j <= 36 ; j ++ ) { if ( toDeci ( str [ i ] , j ) == x ) { counter ++ ; break ; } } } if ( counter == n ) System . out . print ( " YES " + " \n " ) ; else System . out . print ( " NO " + " \n " ) ; } public static void main ( String [ ] args ) { int x = 16 ; String [ ] str = { "10000" , "20" , "16" } ; checkCorrespond ( str , x ) ; } }
import java . util . Scanner ; public class B770 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char [ ] S = in . next ( ) . toCharArray ( ) ; long maxNumber = Long . parseLong ( new String ( S ) ) ; long max = sumOfDigits ( maxNumber ) ; S [ S . length - 1 ] = '9' ; for ( int pos = S . length - 2 ; pos >= 0 ; pos -- ) { if ( S [ pos ] != '0' ) { S [ pos ] -- ; long number = Long . parseLong ( new String ( S ) ) ; int sum = sumOfDigits ( number ) ; if ( sum > max ) { max = sum ; maxNumber = number ; } } S [ pos ] = '9' ; } System . out . println ( maxNumber ) ; } static int sumOfDigits ( long number ) { int result = 0 ; while ( number != 0 ) { result += number % 10 ; number /= 10 ; } return result ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) , k = sc . nextInt ( ) ; if ( n > m ) { System . out . println ( " YES " ) ; return ; } int [ ] a = new int [ n ] , b = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int j = 0 ; j < m ; j ++ ) { b [ j ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = n - 1 , j = m - 1 ; i >= 0 && j >= 0 ; i -- , j -- ) { if ( a [ i ] > b [ j ] ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } }
import java . io . IOException ; import java . util . Arrays ; import java . util . PriorityQueue ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; Pair [ ] pairs = new Pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; pairs [ i ] = new Pair ( a , b ) ; } Arrays . sort ( pairs ) ; PriorityQueue < Pair > pq = new PriorityQueue < Pair > ( ) ; long sum = 0 ; long ret = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pq . offer ( new Pair ( pairs [ i ] . s , pairs [ i ] . f ) ) ; sum += pairs [ i ] . f ; while ( ! pq . isEmpty ( ) && pq . peek ( ) . f * pq . size ( ) < sum ) sum -= pq . poll ( ) . s ; ret = Math . max ( ret , pq . size ( ) ) ; } System . out . println ( ret ) ; } class Pair implements Comparable < Pair > { long f , s ; @ Override public String toString ( ) { return " Pair ▁ [ f = " + f + " , ▁ s = " + s + " ] " ; } public Pair ( long f , long s ) { super ( ) ; this . f = f ; this . s = s ; } @ Override public int compareTo ( Pair o ) { return ( int ) ( f - o . f ) ; } } }
public class GFG { static int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; } static int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; } static int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; } public static void main ( String args [ ] ) { int no = getNthUglyNo ( 150 ) ; System . out . println ( " 150th ▁ ugly ▁ " + " no . ▁ is ▁ " + no ) ; } }
import java . util . * ; import java . io . * ; public class _1157B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] num = sc . next ( ) . toCharArray ( ) ; int [ ] map = new int [ 10 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) map [ i ] = sc . nextInt ( ) ; int idx = n ; for ( int i = 0 ; i < n ; i ++ ) { int digit = num [ i ] - '0' ; if ( map [ digit ] > digit ) { idx = i ; break ; } } for ( int i = idx ; i < num . length ; i ++ ) { int digit = num [ i ] - '0' ; if ( map [ digit ] < digit ) break ; num [ i ] = ( char ) ( map [ digit ] + '0' ) ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( num [ i ] ) ; } public static int gcd ( int a , int b ) { return ( a == 0 ) ? b : gcd ( b % a , a ) ; } static int power ( int x , int y ) { int ans = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) ans *= x ; y = y >> 1 ; x *= x ; } return ans ; } public static List < Integer > sieve ( int n ) { List < Integer > primes = new LinkedList < > ( ) ; boolean [ ] composite = new boolean [ n + 1 ] ; for ( int i = 2 ; i * i <= n ; i ++ ) for ( int j = i * i ; j <= n && ! composite [ i ] ; j += i ) composite [ j ] = true ; for ( int j = 2 ; j < composite . length ; j ++ ) if ( ! composite [ j ] ) primes . add ( j ) ; return primes ; } }
public class GFG { static void perfectSquares ( float l , float r ) { int number = ( int ) Math . ceil ( Math . sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { System . out . print ( n2 + " ▁ " ) ; n2 = n2 + number ; number += 2 ; } } public static void main ( String [ ] args ) { int l = 2 , r = 24 ; perfectSquares ( l , r ) ; } }
import java . util . ArrayList ; public class GFG { static boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; ArrayList < Integer > freq = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { freq . add ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = ( int ) Math . sqrt ( prod ) ; if ( root * root == prod ) { if ( freq . contains ( root ) & freq . lastIndexOf ( root ) != ( freq . size ( ) ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 12 , 3 , 2 } ; int n = arr . length ; if ( CheckArray ( arr , n ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; public class GFG { static void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + " ▁ " ) ; i ++ ; } } public static void main ( String [ ] args ) { int N = 4 ; findNumbers ( N ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int n = stdIn . nextInt ( ) ; int m = stdIn . nextInt ( ) ; int [ ] money = new int [ 10 ] ; int [ ] ans = new int [ n ] ; int min = 10000 ; int minNumber = - 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { money [ i ] = stdIn . nextInt ( ) ; if ( money [ i ] < min ) { min = money [ i ] ; minNumber = i ; } } Arrays . fill ( ans , minNumber ) ; if ( ( m -= money [ minNumber ] * n ) < 0 ) { System . out . println ( " NA " ) ; return ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( m - money [ i ] + money [ ans [ j ] ] ) >= 0 ) && ( i < ans [ j ] ) ) { m = m - money [ i ] + money [ ans [ j ] ] ; ans [ j ] = i ; } } } Arrays . sort ( ans ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] ) ; } System . out . println ( ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class SubsetMex { public static void main ( String [ ] args ) { Scanner iScanner = new Scanner ( System . in ) ; int test = iScanner . nextInt ( ) ; while ( test > 0 ) { test -- ; int n = iScanner . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = iScanner . nextInt ( ) ; } Arrays . sort ( arr ) ; int min = arr [ 0 ] ; int max = arr [ n - 1 ] ; int count = 0 ; int [ ] arr2 = new int [ max + 2 ] ; for ( int i = 0 ; i < max + 2 ; i ++ ) arr2 [ i ] = 0 ; if ( min == 0 ) { for ( int i = 0 ; i < n ; i ++ ) arr2 [ arr [ i ] ] ++ ; int a = 0 ; int b = 0 ; for ( int i = 0 ; i < max + 2 ; i ++ ) { if ( arr2 [ i ] == 0 ) { a = i ; break ; } arr2 [ i ] = arr2 [ i ] - 1 ; } for ( int i = 0 ; i < max + 2 ; i ++ ) { if ( arr2 [ i ] == 0 ) { b = i ; break ; } } System . out . println ( a + b ) ; } else System . out . println ( 0 ) ; } } }
import java . util . * ; import java . io . * ; import java . math . * ; public class Contest666B { public static PrintWriter pw = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; long [ ] test = Arrays . stream ( br . readLine ( ) . split ( " ▁ " ) ) . mapToLong ( Long :: parseLong ) . toArray ( ) ; Arrays . sort ( test ) ; long ans1 = 0 , ans2 = 0 , ans3 = 0 ; long c1 = ( long ) Math . ceil ( Math . pow ( ( double ) test [ n - 1 ] , ( double ) 1 / ( n - 1 ) ) ) ; long c2 = ( long ) Math . floor ( Math . pow ( ( double ) test [ n - 1 ] , ( double ) 1 / ( n - 1 ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( test [ i ] != ( long ) Math . pow ( c1 , i ) ) { ans1 += Math . abs ( test [ i ] - ( long ) Math . pow ( c1 , i ) ) ; } if ( test [ i ] != ( long ) Math . pow ( c2 , i ) ) { ans2 += Math . abs ( test [ i ] - ( long ) Math . pow ( c2 , i ) ) ; } } if ( ans1 < 0 ) { pw . println ( ans2 ) ; } else if ( ans2 < 0 ) { pw . println ( ans1 ) ; } else { pw . println ( Math . min ( ans1 , ans2 ) ) ; } pw . close ( ) ; } }
import static java . lang . Math . max ; import static java . lang . Math . min ; import static java . lang . Math . abs ; import static java . lang . System . out ; import java . util . * ; import java . io . * ; import java . math . * ; public class x930B { public static void main ( String hi [ ] ) throws Exception { BufferedReader infile = new BufferedReader ( new InputStreamReader ( System . in ) ) ; char [ ] arr = infile . readLine ( ) . toCharArray ( ) ; int N = arr . length ; int [ ] [ ] [ ] guesses = new int [ 26 ] [ N ] [ 26 ] ; for ( int head = 0 ; head < N ; head ++ ) for ( int i = 1 ; i < N ; i ++ ) { int loc = ( head + i ) % N ; guesses [ arr [ head ] - ' a ' ] [ i ] [ arr [ loc ] - ' a ' ] ++ ; } int [ ] freq = new int [ 26 ] ; for ( char c : arr ) freq [ c - ' a ' ] ++ ; double res = 0.0 ; for ( int a = 0 ; a < 26 ; a ++ ) { int [ ] [ ] grid = guesses [ a ] ; double temp = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { int cnt = 0 ; int total = 0 ; for ( int b = 0 ; b < 26 ; b ++ ) { if ( grid [ i ] [ b ] == 1 ) cnt ++ ; total += grid [ i ] [ b ] ; } if ( total > 0 ) temp = max ( temp , 1.0 * cnt / total ) ; } res += ( 1.0 * freq [ a ] / N ) * temp ; } System . out . println ( res ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class GFG { static int countIntervals ( int [ ] [ ] arr , int V , int N ) { int count = 0 ; int li , ri ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; ri = arr [ i ] [ 1 ] ; if ( V >= li && V <= ri ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int [ ] [ ] arr = { { 1 , 10 } , { 5 , 10 } , { 15 , 25 } , { 7 , 12 } , { 20 , 25 } } ; int V = 7 ; int N = arr . length ; System . out . println ( countIntervals ( arr , V , N ) ) ; } }
public class GFG { static int msbPos ( long n ) { int msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; } static long andOperator ( long x , long y ) { long res = 0 ; while ( x > 0 && y > 0 ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; long msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; } public static void main ( String [ ] args ) { long x = 10 , y = 15 ; System . out . println ( andOperator ( x , y ) ) ; } }
public class GFG { public int lengthOfLastWord ( final String a ) { boolean char_flag = false ; int len = 0 ; for ( int i = a . length ( ) - 1 ; i >= 0 ; i -- ) { if ( Character . isLetter ( a . charAt ( i ) ) ) { char_flag = true ; len ++ ; } else { if ( char_flag == true ) return len ; } } return len ; } public static void main ( String [ ] args ) { String input = " Geeks ▁ For ▁ Geeks ▁ ▁ " ; GFG gfg = new GFG ( ) ; System . out . println ( " The ▁ length ▁ of ▁ last ▁ word ▁ is ▁ " + gfg . lengthOfLastWord ( input ) ) ; } }
import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int R = sc . nextInt ( ) ; double X = sc . nextInt ( ) ; double Y = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int P = sc . nextInt ( ) ; double x1 = R * Math . cos ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; double y1 = R * Math . sin ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; sum += P ; double x2 = R * Math . cos ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; double y2 = R * Math . sin ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; double SO = Math . PI * R * R * P / 100.0 ; double DS1 = area ( 0 , 0 , x2 , y2 , X , Y ) ; double DS2 = area ( 0 , 0 , X , Y , x1 , y1 ) ; double SN = SO + DS1 + DS2 ; if ( i != 0 ) System . out . print ( " ▁ " ) ; System . out . print ( ( int ) ( 100 * SN / SO ) ) ; } System . out . println ( ) ; } static double area ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 ) { double dx1 = x1 - x0 ; double dy1 = y1 - y0 ; double dx2 = x2 - x0 ; double dy2 = y2 - y0 ; return ( - dy2 * dx1 + dy1 * dx2 ) / 2 ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int j = n - 1 ; j >= 0 ; j -- ) { int t = ( int ) Math . sqrt ( a [ j ] ) ; if ( ( t * t ) != a [ j ] ) { System . out . println ( a [ j ] ) ; break ; } } } }
import java . io . * ; public class GFG { static int countSolutions ( int a ) { int count = Integer . bitCount ( a ) ; count = ( int ) Math . pow ( 2 , count ) ; return count ; } public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }
import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Solution { static PrintWriter pw ; static FastScanner s ; public static void main ( String [ ] args ) throws Exception { pw = new PrintWriter ( System . out ) ; s = new FastScanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { long n = s . nextLong ( ) ; long m = s . nextLong ( ) ; long ans = ( n * ( n + 1 ) ) / 2 ; ans -- ; ans *= m ; ans += ( m * ( m + 1 ) ) / 2 ; pw . println ( ans ) ; } pw . flush ( ) ; } } class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public FastScanner ( String s ) throws Exception { br = new BufferedReader ( new FileReader ( new File ( s ) ) ) ; } public String next ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws Exception { return Long . parseLong ( next ( ) ) ; } }
import java . util . * ; public class GFG { static int N = 1000005 ; static long MAX = ( long ) 1e18 ; static Vector < Long > powers = new Vector < > ( ) ; static TreeSet < Long > squares = new TreeSet < > ( ) ; static TreeSet < Long > s = new TreeSet < > ( ) ; static void powersPrecomputation ( ) { for ( long i = 2 ; i < N ; i ++ ) { squares . add ( i * i ) ; if ( squares . contains ( i ) ) continue ; long temp = i ; while ( i * i <= MAX / temp ) { temp *= ( i * i ) ; s . add ( temp ) ; } } for ( long x : s ) powers . add ( x ) ; } static long calculateAnswer ( long L , long R ) { powersPrecomputation ( ) ; long perfectSquares = ( long ) ( Math . floor ( Math . sqrt ( R ) ) - Math . floor ( Math . sqrt ( L - 1 ) ) ) ; long high = Collections . binarySearch ( powers , R ) ; long low = Collections . binarySearch ( powers , L ) ; long perfectPowers = perfectSquares + ( high - low ) ; long ans = ( R - L + 1 ) - perfectPowers ; return ans ; } public static void main ( String [ ] args ) { long L = 13 , R = 20 ; System . out . println ( calculateAnswer ( L , R ) ) ; } }
import java . io . * ; import java . math . * ; public class GFG { static long dp [ ] [ ] = new long [ 1000 ] [ 1000 ] ; static long sum ( int a [ ] , int i , int j ) { long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; } static long solve ( int a [ ] , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = 100000000 ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; } static void intialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = - 1 ; } public static void main ( String args [ ] ) { int a [ ] = { 40 , 60 , 20 } ; int n = a . length ; intialize ( n ) ; System . out . println ( solve ( a , 0 , n - 1 ) ) ; } }
public class GFG { static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; return ; } static void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } static void printSequences ( int n , int k ) { int arr [ ] = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } public static void main ( String [ ] args ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int chohoke = 0 ; int hisi = 0 ; for ( String str ; ( str = br . readLine ( ) ) != null ; ) { String [ ] data = str . split ( " , " ) ; int a = Integer . parseInt ( data [ 0 ] ) ; int b = Integer . parseInt ( data [ 1 ] ) ; int c = Integer . parseInt ( data [ 2 ] ) ; if ( a * a + b * b == c * c ) chohoke ++ ; if ( a == b ) hisi ++ ; } System . out . println ( chohoke ) ; System . out . println ( hisi ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int maxValue ( int a [ ] , int n ) { HashMap < Integer , Integer > first = new HashMap < > ( ) ; HashMap < Integer , Integer > last = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { first . put ( a [ i ] , 0 ) ; last . put ( a [ i ] , 0 ) ; } int [ ] pr = new int [ n ] ; pr [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pr [ i ] = pr [ i - 1 ] + a [ i ] ; if ( Integer . parseInt ( String . valueOf ( first . get ( a [ i ] ) ) ) == 0 ) first . put ( a [ i ] , i ) ; last . put ( a [ i ] , i ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int start = Integer . parseInt ( String . valueOf ( first . get ( a [ i ] ) ) ) ; int end = Integer . parseInt ( String . valueOf ( last . get ( a [ i ] ) ) ) ; if ( start != 0 ) ans = Math . max ( ans , pr [ end ] - pr [ start - 1 ] ) ; } return ans ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 3 , 5 , 2 , 4 , 18 , 2 , 3 } ; int n = arr . length ; System . out . println ( maxValue ( arr , n ) ) ; } }
import java . util . HashSet ; public class GFG { static int getPairs ( int a [ ] , int n ) { HashSet < Integer > visited1 = new HashSet < Integer > ( ) ; int un [ ] = new int [ n ] ; un [ n - 1 ] = 0 ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( visited1 . contains ( a [ i ] ) ) un [ i - 1 ] = count ; else un [ i - 1 ] = ++ count ; visited1 . add ( a [ i ] ) ; } HashSet < Integer > visited2 = new HashSet < Integer > ( ) ; int answer = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( visited2 . contains ( a [ i ] ) ) continue ; answer += un [ i ] ; visited2 . add ( a [ i ] ) ; } return answer ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 } ; int n = a . length ; System . out . println ( getPairs ( a , n ) ) ; } }
import java . io . * ; public class GFG { static boolean isTwoAlter ( String s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 2 ) ) { return false ; } } if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; return true ; } public static void main ( String [ ] args ) { String str = " ABAB " ; if ( isTwoAlter ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; System . out . println ( remainder ) ; } public static void main ( String [ ] args ) { int n = 5223 ; findRemainder ( n ) ; } }
import java . util . * ; import java . io . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; String [ ] names = new String [ ] { " Sheldon " , " Leonard " , " Penny " , " Rajesh " , " Howard " } ; long N = in . nextLong ( ) ; long round = 5 ; while ( N > round ) { N -= round ; round *= 2 ; } long sectionLength = round / 5 ; int person = ( int ) ( ( N - 1 ) / sectionLength ) ; pw . println ( names [ person ] ) ; pw . close ( ) ; } }
public class GFG { static int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; } public static void main ( String [ ] args ) { int [ ] arr1 = { 1 , 2 , 3 , 4 , 7 , 9 } ; int [ ] arr2 = { 0 , 1 , 2 , 1 , 1 , 4 } ; int k = 2 ; int m = arr1 . length ; int n = arr2 . length ; System . out . println ( findSumofEle ( arr1 , m , arr2 , n , k ) ) ; } }
import java . io . * ; public class GFG { static int CountWays ( int n , boolean flag ) { if ( n == 0 ) return 1 ; int sum = 0 ; if ( flag == false && n > 1 ) sum = sum + CountWays ( n - 1 , false ) + CountWays ( n - 2 , true ) ; else sum = sum + CountWays ( n - 1 , false ) ; return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n , false ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int MaxSumDifference ( Integer [ ] a , int n ) { List < Integer > finalSequence = new ArrayList < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . add ( a [ n / 2 ] ) ; int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return MaximumSum ; } public static void main ( String args [ ] ) { Integer [ ] a = { 1 , 2 , 4 , 8 } ; int n = a . length ; System . out . println ( MaxSumDifference ( a , n ) ) ; } }
public class GFG { static int reverse ( int n ) { int rev = 0 ; while ( n > 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n = n / 10 ; } return rev ; } static boolean isPalin ( int n ) { return ( n == reverse ( n ) ) ; } static int countDigits ( int n ) { int c = 0 ; while ( n > 0 ) { n = n / 10 ; c ++ ; } return c ; } static int countPalinDigits ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 10 || isPalin ( arr [ i ] ) ) { s += countDigits ( arr [ i ] ) ; } } return s ; } public static void main ( String [ ] args ) { int [ ] arr = { 121 , 56 , 434 } ; int n = arr . length ; System . out . println ( countPalinDigits ( arr , n ) ) ; } }
import java . util . Arrays ; import java . lang . Math ; public class GFG { public static int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; else len ++ ; max1 = Math . max ( max1 , len + 1 ) ; } if ( max1 == 1 ) return 0 ; else return max1 ; } public static void main ( String [ ] args ) { String s = " synapse " ; System . out . println ( lenoflongestnonpalindrome ( s ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; import java . util . stream . Collectors ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; ++ i ) { a [ i ] = sc . nextInt ( ) ; } System . out . println ( solve ( a , k ) ) ; } sc . close ( ) ; } static String solve ( int [ ] a , int k ) { for ( int i = 0 ; i < a . length - 1 ; ++ i ) { while ( a [ i ] != 0 && k != 0 ) { -- a [ i ] ; ++ a [ a . length - 1 ] ; -- k ; } } return Arrays . stream ( a ) . mapToObj ( String :: valueOf ) . collect ( Collectors . joining ( " ▁ " ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static float ellipse ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; } public static void main ( String args [ ] ) { float a = 5 , b = 3 ; System . out . println ( ellipse ( a , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; TreeSet < Integer > plusSet = new TreeSet < > ( ) ; TreeSet < Integer > minusOneSet = new TreeSet < > ( ) ; TreeMap < Integer , Integer > minusMap = new TreeMap < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int x = sc . nextInt ( ) ; if ( x > 1 ) { plusSet . add ( i ) ; } else if ( x == - 1 ) { minusOneSet . add ( i ) ; } else if ( x < - 1 ) { minusMap . put ( i , x ) ; } } if ( minusMap . size ( ) % 2 == 1 ) { if ( minusOneSet . size ( ) > 0 ) { plusSet . addAll ( minusMap . keySet ( ) ) ; plusSet . add ( minusOneSet . first ( ) ) ; } else { int min = Integer . MAX_VALUE ; int minIdx = 0 ; for ( Map . Entry < Integer , Integer > entry : minusMap . entrySet ( ) ) { if ( min >= entry . getValue ( ) ) { min = entry . getValue ( ) ; minIdx = entry . getKey ( ) ; } } minusMap . remove ( minIdx ) ; plusSet . addAll ( minusMap . keySet ( ) ) ; } } else { plusSet . addAll ( minusMap . keySet ( ) ) ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( plusSet . size ( ) ) . append ( " \n " ) ; for ( int x : plusSet ) { sb . append ( x ) . append ( " \n " ) ; } System . out . print ( sb ) ; } }
public class GFG { static int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; } public static void main ( String [ ] args ) { int a = - 10 ; int b = 15 ; int x = a ; System . out . print ( " x ▁ is ▁ : ▁ " + x ) ; x = alternate ( a , b , x ) ; System . out . print ( " \n After ▁ exchange ▁ " ) ; System . out . println ( " \n x ▁ is ▁ : ▁ " + x ) ; } }
import java . util . ArrayList ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Scanner ; import java . util . Set ; public class CsAcademy { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int n = cin . nextInt ( ) ; Set < Integer > prime = new LinkedHashSet < > ( ) ; for ( int i = 2 ; i <= 3000 ; i ++ ) { if ( isPrime ( i ) ) { prime . add ( i ) ; } } int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int temp = 0 ; for ( Integer pr : prime ) { if ( i % pr == 0 ) { temp ++ ; } } if ( temp == 2 ) ans ++ ; } System . out . println ( ans ) ; } public static boolean isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static void main ( String args [ ] ) { float x1 = 1 , x2 = 3 , x3 = 6 ; float y1 = 2 , y2 = - 4 , y3 = - 7 ; float x = ( x1 + x2 + x3 ) / 3 ; float y = ( y1 + y2 + y3 ) / 3 ; System . out . println ( " Centroid ▁ = ▁ " + " ( ▁ " + String . format ( " % . 2 f " , x ) + " ▁ , ▁ " + y + " ▁ ) " ) ; } }
import java . util . * ; public class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static void count_ ( int count [ ] , int e ) { boolean hash [ ] = new boolean [ 10 ] ; while ( e > 0 ) { if ( hash [ e % 10 ] == false ) count [ e % 10 ] ++ ; hash [ e % 10 ] = true ; e /= 10 ; } } static void find_subsequence ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { count_ ( count , arr [ i ] ) ; } int longest = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) longest = Math . max ( count [ i ] , longest ) ; System . out . println ( longest ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 12 , 23 , 74 , 13 } ; int n = arr . length ; find_subsequence ( arr , n ) ; } }
import java . io . * ; import java . util . * ; public class GFG { public static int MAXN = 1000001 ; public static int [ ] spf = new int [ MAXN ] ; static void sieve ( ) { for ( int i = 1 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static int countSubArray ( int arr [ ] , int n ) { int [ ] ind = new int [ MAXN ] ; Arrays . fill ( ind , - 1 ) ; int count = 0 ; int last_ind = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( arr [ i ] > 1 ) { int div = spf [ arr [ i ] ] ; last_ind = Math . max ( last_ind , ind [ div ] ) ; ind [ div ] = i + 1 ; arr [ i ] /= div ; } count += i - last_ind + 1 ; } return count ; } public static void main ( String [ ] args ) { sieve ( ) ; int arr [ ] = { 2 , 3 , 9 } ; int n = arr . length ; System . out . println ( countSubArray ( arr , n ) ) ; int arr1 [ ] = { 2 , 3 , 5 , 15 , 7 , 2 } ; int n1 = arr1 . length ; System . out . println ( countSubArray ( arr1 , n1 ) ) ; } }
import java . io . * ; public class GFG { static int N = 3 ; static void multiply ( int mat [ ] [ ] , int res [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int k = 0 ; k < N ; k ++ ) res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; } } } static boolean InvolutoryMatrix ( int mat [ ] [ ] ) { int res [ ] [ ] = new int [ N ] [ N ] ; multiply ( mat , res ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j && res [ i ] [ j ] != 1 ) return false ; if ( i != j && res [ i ] [ j ] != 0 ) return false ; } } return true ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 0 } , { 0 , - 1 , 0 } , { 0 , 0 , - 1 } } ; if ( InvolutoryMatrix ( mat ) ) System . out . println ( " Involutory ▁ Matrix " ) ; else System . out . println ( " Not ▁ Involutory ▁ Matrix " ) ; } }
import java . lang . * ; public class crazy_number { public static int first ( int n ) { int a = n ; int c = 1 ; while ( a != 0 ) { a /= 10 ; c = c * 10 ; } c = c / 10 ; int fi = n / c ; return fi ; } public static boolean prime ( int n ) { switch ( n ) { case 2 : return true ; case 3 : return true ; case 5 : return true ; case 7 : return true ; default : return false ; } } public static void check ( int n , int k ) { int l = n % 10 ; int f = first ( n ) ; boolean lp = prime ( l ) ; boolean fp = prime ( f ) ; if ( lp && fp ) { if ( l + f < k ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String args [ ] ) { int n = 322223 ; int k = 10 ; check ( n , k ) ; n = 62531561 ; k = 15 ; check ( n , k ) ; } }
import java . awt . Point ; import static java . lang . Math . PI ; import static java . lang . Math . sqrt ; import static java . lang . Math . acos ; class Test { static int lengthSquare ( Point p1 , Point p2 ) { int xDiff = p1 . x - p2 . x ; int yDiff = p1 . y - p2 . y ; return xDiff * xDiff + yDiff * yDiff ; } static void printAngle ( Point A , Point B , Point C ) { int a2 = lengthSquare ( B , C ) ; int b2 = lengthSquare ( A , C ) ; int c2 = lengthSquare ( A , B ) ; float a = ( float ) sqrt ( a2 ) ; float b = ( float ) sqrt ( b2 ) ; float c = ( float ) sqrt ( c2 ) ; float alpha = ( float ) acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) ; float betta = ( float ) acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) ; float gamma = ( float ) acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) ; alpha = ( float ) ( alpha * 180 / PI ) ; betta = ( float ) ( betta * 180 / PI ) ; gamma = ( float ) ( gamma * 180 / PI ) ; System . out . println ( " alpha ▁ : ▁ " + String . format ( " % . 1 f " , alpha ) ) ; System . out . println ( " betta ▁ : ▁ " + String . format ( " % . 1 f " , betta ) ) ; System . out . println ( " gamma ▁ : ▁ " + String . format ( " % . 1 f " , gamma ) ) ; } public static void main ( String [ ] args ) { Point A = new Point ( 0 , 0 ) ; Point B = new Point ( 0 , 1 ) ; Point C = new Point ( 1 , 0 ) ; printAngle ( A , B , C ) ; } }
import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { int size = sc . nextInt ( ) ; int [ ] arr = new int [ size ] ; for ( int j = 0 ; j < size ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } for ( int j = size - 2 ; j >= 0 ; j -- ) { arr [ j ] = Math . max ( arr [ j ] , arr [ j + 1 ] ) ; } int ans = 0 ; int ele = arr [ size - 1 ] ; for ( int j = size - 2 ; j >= 0 ; j -- ) { if ( ele != arr [ j ] ) { ele = arr [ j ] ; ans ++ ; } } System . out . println ( ans ) ; } } }
class MaxevenSum { static int maxEvenSum ( int arr [ ] , int n ) { int pos_sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; if ( pos_sum % 2 == 0 ) return pos_sum ; int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) { if ( arr [ i ] > 0 ) ans = ans > ( pos_sum - arr [ i ] ) ? ans : ( pos_sum - arr [ i ] ) ; else ans = ans > ( pos_sum + arr [ i ] ) ? ans : ( pos_sum + arr [ i ] ) ; } } return ans ; } public static void main ( String s [ ] ) { int a [ ] = { - 2 , 2 , - 3 , 1 } ; System . out . println ( maxEvenSum ( a , a . length ) ) ; } }
public class GFG { static int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = arr . length ; System . out . println ( xorOfArray ( arr , n ) ) ; } }
public class GFG { static final int TEN = 10 ; static void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } } static boolean areAnagrams ( int a , int b ) { int [ ] freqA = new int [ TEN ] ; int [ ] freqB = new int [ TEN ] ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; } public static void main ( String [ ] args ) { int a = 204 , b = 240 ; if ( areAnagrams ( a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( evenFib ( n ) ) ; } }
public class GFG { static int minOperations ( int N ) { double x = Math . log ( N ) / Math . log ( 2 ) ; int ans = ( int ) ( Math . ceil ( x ) ) ; return ans ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( minOperations ( N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long [ ] t = new long [ N ] ; long [ ] a = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { t [ i ] = sc . nextLong ( ) ; a [ i ] = sc . nextLong ( ) ; } long [ ] dp = new long [ N ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { long takahashi = ( t [ i - 1 ] * dp [ i - 1 ] + t [ i ] - 1 ) / t [ i ] ; long aoki = ( a [ i - 1 ] * dp [ i - 1 ] + a [ i ] - 1 ) / a [ i ] ; dp [ i ] = Math . max ( takahashi , aoki ) ; } System . out . println ( ( t [ N - 1 ] + a [ N - 1 ] ) * dp [ N - 1 ] ) ; } }
import java . util . * ; import java . io . * ; public class GFG { static String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; } public static void main ( String [ ] args ) { int k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; System . out . println ( check ( k , d0 , d1 ) ) ; k = 5 ; d0 = 3 ; d1 = 4 ; System . out . println ( check ( k , d0 , d1 ) ) ; } }
import java . util . * ; import java . io . * ; import static java . lang . Math . * ; public class Practice { static Scanner scn ; static StringBuilder sb ; public static void main ( String [ ] ScoobyDoobyDo ) { scn = new Scanner ( System . in ) ; sb = new StringBuilder ( ) ; int t = scn . nextInt ( ) ; for ( int tests = 0 ; tests < t ; tests ++ ) solve ( ) ; System . out . println ( sb ) ; } public static void solve ( ) { int l1 = scn . nextInt ( ) , r1 = scn . nextInt ( ) ; int l2 = scn . nextInt ( ) , r2 = scn . nextInt ( ) ; for ( int i = l1 ; i <= r1 ; i ++ ) { for ( int j = l2 ; j <= r2 ; j ++ ) { if ( i != j ) { sb . append ( i + " ▁ " + j + " \n " ) ; return ; } } } } }
import java . util . * ; import java . io . * ; class Main { public static final int N = 9 ; public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; char c [ ] = new char [ N ] ; String end = "123456780" ; String puzzle = " " ; int index [ ] = { 1 , - 1 , - 3 , 3 } ; HashMap < String , Integer > hash = new HashMap < String , Integer > ( ) ; Queue < String > queue = new ArrayDeque < String > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { c [ i ] += ( char ) ( sc . nextInt ( ) + 48 ) ; puzzle += c [ i ] ; } queue . add ( puzzle ) ; hash . put ( puzzle , 0 ) ; while ( ! queue . isEmpty ( ) ) { String comfirm = queue . remove ( ) ; if ( comfirm . equals ( end ) ) { System . out . println ( hash . get ( comfirm ) ) ; break ; } StringBuffer s = new StringBuffer ( comfirm ) ; int vacancy = s . indexOf ( "0" ) ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( vacancy + index [ i ] >= 0 && vacancy + index [ i ] < N ) { if ( ! ( ( index [ i ] == - 1 ) && ( ( index [ i ] + vacancy ) % 3 == 2 ) ) && ! ( ( index [ i ] == 1 ) && ( ( index [ i ] + vacancy ) % 3 == 0 ) ) ) { s . setCharAt ( vacancy , s . charAt ( vacancy + index [ i ] ) ) ; s . setCharAt ( vacancy + index [ i ] , '0' ) ; if ( ! hash . containsKey ( s . toString ( ) ) ) { queue . add ( s . toString ( ) ) ; hash . put ( s . toString ( ) , hash . get ( comfirm ) + 1 ) ; } s . setCharAt ( vacancy + index [ i ] , s . charAt ( vacancy ) ) ; s . setCharAt ( vacancy , '0' ) ; } } } } } }
public final class p171 { public static void main ( String [ ] args ) { System . out . println ( new p171 ( ) . run ( ) ) ; } private static final int LENGTH = 20 ; private static final int BASE = 10 ; private static final int MODULUS = Library . pow ( 10 , 9 ) ; public String run ( ) { int MAX_SQR_DIGIT_SUM = ( BASE - 1 ) * ( BASE - 1 ) * LENGTH ; long [ ] [ ] sum = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; long [ ] [ ] count = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; count [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= LENGTH ; i ++ ) { for ( int j = 0 ; j < BASE ; j ++ ) { for ( int k = 0 ; k + j * j <= MAX_SQR_DIGIT_SUM ; k ++ ) { sum [ i ] [ k + j * j ] = ( sum [ i ] [ k + j * j ] + sum [ i - 1 ] [ k ] + Library . powMod ( BASE , i - 1 , MODULUS ) * j % MODULUS * count [ i - 1 ] [ k ] ) % MODULUS ; count [ i ] [ k + j * j ] = ( count [ i ] [ k + j * j ] + count [ i - 1 ] [ k ] ) % MODULUS ; } } } long s = 0 ; for ( int i = 1 ; i * i <= MAX_SQR_DIGIT_SUM ; i ++ ) s = ( s + sum [ LENGTH ] [ i * i ] ) % MODULUS ; return String . format ( " % 09d " , s ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; Set < Integer > S = new HashSet < > ( ) ; int q = Integer . parseInt ( in . next ( ) ) ; for ( int i = 0 ; i < q ; i ++ ) { int odr = Integer . parseInt ( in . next ( ) ) ; if ( odr == 0 ) { int x = Integer . parseInt ( in . next ( ) ) ; S . add ( x ) ; out . println ( S . size ( ) ) ; } else if ( odr == 1 ) { int x = Integer . parseInt ( in . next ( ) ) ; out . println ( ( S . contains ( x ) ) ? 1 : 0 ) ; } else { int x = Integer . parseInt ( in . next ( ) ) ; S . remove ( x ) ; } } out . flush ( ) ; } }
import java . util . Arrays ; public class GFG { final static int MAX = 10000002 ; static int prime [ ] = new int [ MAX ] ; static int prime_count [ ] = new int [ MAX ] ; static void sieve ( ) { Arrays . fill ( prime , 0 , MAX , 0 ) ; prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < MAX ; j += i ) { if ( prime [ j ] == 0 ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { prime [ i ] = i ; } } } static long numberOfDivisorsOfProduct ( int [ ] arr , int n ) { Arrays . fill ( prime_count , 0 , MAX , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = arr [ i ] ; while ( temp != 1 ) { prime_count [ prime [ temp ] ] ++ ; temp = temp / prime [ temp ] ; } } long ans = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { ans = ans * ( prime_count [ i ] + 1 ) ; } return ans ; } public static void main ( String [ ] args ) { sieve ( ) ; int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( numberOfDivisorsOfProduct ( arr , n ) ) ; } }
public class GFG { static int check ( int num ) { int digitSum = 0 ; while ( num > 0 ) { digitSum = digitSum + num % 10 ; num = num / 10 ; } int temp = digitSum ; int reverseDigitSum = 0 ; while ( temp > 0 ) { int rem = temp % 10 ; reverseDigitSum = reverseDigitSum * 10 + rem ; temp = temp / 10 ; } int number = digitSum * reverseDigitSum ; return number ; } public static void main ( String args [ ] ) { int num = 1729 ; int x = check ( num ) ; if ( num == x ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Test { static int arr [ ] = { 12 , 3 , 4 , 15 } ; static int sum ( ) { int sum = 0 ; int i ; for ( i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; return sum ; } public static void main ( String [ ] args ) { System . out . println ( " Sum ▁ of ▁ given ▁ array ▁ is ▁ " + sum ( ) ) ; } }
public class GFG { static int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( " Total ▁ ways ▁ are : ▁ " + ways ( n ) ) ; } }
public class demo { static float pi = ( float ) Math . PI ; public static float volume ( float r , float R , float h ) { return ( float ) 1 / 3 * pi * h * ( r * r + R * R + r * R ) ; } public static float curved_surface_area ( float r , float R , float l ) { return pi * l * ( R + r ) ; } public static float total_surface_area ( float r , float R , float l , float h ) { return pi * l * ( R + r ) + pi * ( r * r + R * R ) ; } public static void main ( String args [ ] ) { float small_radius = 3 ; float big_radius = 8 ; float slant_height = 13 ; float height = 12 ; System . out . print ( " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; System . out . println ( String . format ( " % . 3 f " , volume ( small_radius , big_radius , height ) ) ) ; System . out . print ( " Curved ▁ Surface ▁ Area ▁ Of " + " ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; System . out . println ( String . format ( " % . 3 f " , curved_surface_area ( small_radius , big_radius , slant_height ) ) ) ; System . out . print ( " Total ▁ Surface ▁ Area ▁ Of " + " ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; System . out . println ( String . format ( " % . 3 f " , total_surface_area ( small_radius , big_radius , slant_height , height ) ) ) ; } }
import java . util . * ; public class GFG { static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; } static boolean isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } static boolean isDigitSumPalindrome ( int n ) { int sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 56 ; if ( isDigitSumPalindrome ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Scanner ; public class PizzaForces { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int test = sc . nextInt ( ) ; while ( test > 0 ) { long n = sc . nextLong ( ) ; long ans = 0 ; if ( n <= 6 ) System . out . println ( "15" ) ; else { if ( n % 2 == 1 ) n ++ ; n = n / 2 ; ans = ( long ) ( n * 5 ) ; System . out . println ( ans ) ; } test -- ; } } }
import java . util . * ; public class GFG { static float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; } public static void main ( String [ ] args ) { int your_rank = 805 ; int total_students = 97481 ; System . out . println ( String . format ( " % . 3 f " , getPercentile ( your_rank , total_students ) ) ) ; } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isPrime ( n ) && ( n % 4 == 1 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } public static void main ( String [ ] args ) { int n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; import java . util . * ; public class Main { public static double aver ( int [ ] arr ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum = sum + arr [ i ] ; } return sum / arr . length ; } public static int fac ( int x ) { int sum = 1 ; while ( x > 0 ) { sum = sum * x ; x = x - 1 ; } return sum ; } public static int comb ( int x , int y ) { int sum = 0 ; sum = fac ( x ) ; int temp = ( fac ( y ) * fac ( x - y ) ) ; return sum / temp ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n > 0 ) { int [ ] arr = new int [ 3 ] ; int max = 0 ; int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( arr [ i ] > max ) max = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == max ) count += 1 ; arr [ i ] = max - arr [ i ] + 1 ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == 1 && max != 0 && count == 1 ) System . out . print ( 0 + " ▁ " ) ; else System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; n = n - 1 ; } } }
import java . io . * ; public class GFG { static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; } static public void main ( String [ ] args ) { String s = "10010" ; int K = 1 ; System . out . println ( countOfSubstringWithKOnes ( s , K ) ) ; } }
class Main { static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ ] = { 1 , 4 , 8 , 10 } ; int k = 5 ; System . out . println ( kth ( arr1 , arr2 , 5 , 4 , k ) ) ; } }
public class GFG { static final int MAX = 256 ; static int freq [ ] [ ] ; static void preCalculate ( String str , int n ) { freq [ ( int ) str . charAt ( 0 ) ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } } static int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; } static String firstNonRepeating ( String str , int n , int l , int r ) { for ( int i = l ; i < r ; i ++ ) { char ch = str . charAt ( i ) ; if ( getFrequency ( ch , l , r ) == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int n = str . length ( ) ; int queries [ ] [ ] = { { 0 , 3 } , { 2 , 3 } , { 5 , 12 } } ; int q = queries . length ; freq = new int [ MAX ] [ n ] ; preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( firstNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } } }
public class GFG { static final int MAX = 256 ; static int freq [ ] [ ] ; static void preCalculate ( String str , int n ) { freq [ ( int ) str . charAt ( 0 ) ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } } static int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; } static String lastNonRepeating ( String str , int n , int l , int r ) { for ( int i = r ; i >= l ; i -- ) { char ch = str . charAt ( i ) ; if ( getFrequency ( ch , l , r ) == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int n = str . length ( ) ; int queries [ ] [ ] = { { 2 , 9 } , { 2 , 3 } , { 0 , 12 } } ; int q = queries . length ; freq = new int [ MAX ] [ n ] ; preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( lastNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } } }
import java . util . * ; class solution { static void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } System . out . println ( " A ▁ = ▁ " + a + " ▁ , ▁ B ▁ = ▁ " + b ) ; } public static void main ( String args [ ] ) { int A = 10 , B = 15 ; divide ( A , B ) ; } }
import java . util . Vector ; public class GFG { static Vector < Integer > permutation = new Vector < > ( ) ; static void printPermutation ( ) { permutation . stream ( ) . forEach ( ( i ) -> { System . out . print ( i + " ▁ " ) ; } ) ; } static int give_random_number ( int l , int r ) { int x = ( int ) ( Math . random ( ) % ( r - l + 1 ) + l ) ; return x ; } static void generate_random_permutation ( int l , int r ) { if ( l > r ) return ; int n = give_random_number ( l , r ) ; permutation . add ( n ) ; generate_random_permutation ( l , n - 1 ) ; generate_random_permutation ( n + 1 , r ) ; } public static void main ( String [ ] args ) { int l = 5 ; int r = 15 ; generate_random_permutation ( l , r ) ; printPermutation ( ) ; } }
import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { long N = sc . nextLong ( ) ; long D = sc . nextLong ( ) ; long ans ; if ( D == 1 ) { ans = N * ( N - 1 ) / 2 ; } else { long dense = N - D ; ans = dense * ( dense - 1 ) / 2 ; ans += 2 * dense ; ans += D - 2 ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; public class Game23 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int no = sc . nextInt ( ) ; int dest = sc . nextInt ( ) ; int res = - 1 ; if ( no == dest ) { System . out . println ( "0" ) ; } else if ( dest % no == 0 ) { res = 0 ; int d = dest / no ; while ( d % 2 == 0 ) { d = d / 2 ; res ++ ; } while ( d % 3 == 0 ) { d = d / 3 ; res ++ ; } if ( d != 1 ) res = - 1 ; System . out . println ( res ) ; } else { System . out . println ( res ) ; } } }
import java . util . Scanner ; public class B_Restricted_RPS { static Scanner in = new Scanner ( System . in ) ; static int testCases , n , a , b , c ; static char bobs_move [ ] ; static void solve ( ) { int bobs_rock = 0 , bobs_paper = 0 , bobs_sissor = 0 ; int alice_can_bit = 0 ; for ( char i : bobs_move ) { if ( i == ' R ' ) { bobs_rock ++ ; } else if ( i == ' P ' ) { bobs_paper ++ ; } else { ++ bobs_sissor ; } } alice_can_bit += Math . min ( bobs_paper , c ) + Math . min ( bobs_rock , b ) + Math . min ( bobs_sissor , a ) ; if ( 2 * alice_can_bit < n ) { System . out . println ( " NO " ) ; return ; } char alice_moves [ ] = new char [ n ] ; int index = 0 ; for ( char i : bobs_move ) { if ( i == ' R ' && b > 0 ) { alice_moves [ index ] = ' P ' ; -- b ; } else if ( i == ' P ' && c > 0 ) { alice_moves [ index ] = ' S ' ; -- c ; } else if ( i == ' S ' && a > 0 ) { -- a ; alice_moves [ index ] = ' R ' ; } else { alice_moves [ index ] = ' L ' ; } ++ index ; } System . out . println ( " YES " ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( alice_moves [ i ] == ' L ' ) { if ( a > 0 ) { alice_moves [ i ] = ' R ' ; -- a ; } else if ( b > 0 ) { alice_moves [ i ] = ' P ' ; -- b ; } else if ( c > 0 ) { alice_moves [ i ] = ' S ' ; -- c ; } } } System . out . println ( new String ( alice_moves ) ) ; } public static void main ( String [ ] amit ) { testCases = in . nextInt ( ) ; for ( int t = 0 ; t < testCases ; ++ t ) { n = in . nextInt ( ) ; a = in . nextInt ( ) ; b = in . nextInt ( ) ; c = in . nextInt ( ) ; bobs_move = in . next ( ) . toCharArray ( ) ; solve ( ) ; } } }
import java . util . Scanner ; public class NewClass25 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; int z = in . nextInt ( ) ; String x [ ] [ ] = new String [ t ] [ z ] ; int b = 0 ; int w = 0 ; int c = 0 ; int g = 0 ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < z ; j ++ ) { String colour = in . next ( ) ; if ( colour . equals ( " C " ) || colour . equals ( " M " ) || colour . equals ( " Y " ) ) { c = 1 ; break ; } } if ( c == 1 ) { break ; } } if ( c == 1 ) { System . out . println ( " # Color " ) ; } else { System . out . println ( " # Black & White " ) ; } } }
import java . lang . Math ; public class GFG { static int exponent ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; int y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; } static int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; int K = 3 ; System . out . println ( sum ( K , n ) ) ; } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; sc . close ( ) ; for ( int i = 0 ; ( 2 * i ) < s . length ( ) ; i ++ ) { System . out . print ( s . charAt ( 2 * i ) ) ; } } }
import java . util . * ; public class GFG { static int [ ] pref = new int [ 100001 ] ; static int checkPalindrome ( int num ) { String str = String . valueOf ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { return 0 ; } l ++ ; r -- ; } return num ; } static void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; } } static void printSum ( int L , int R ) { System . out . print ( pref [ R ] - pref [ L - 1 ] + " \n " ) ; } static void printSumPalindromic ( int arr [ ] [ ] , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } public static void main ( String [ ] args ) { int Q = 2 ; int arr [ ] [ ] = { { 10 , 13 } , { 12 , 21 } } ; printSumPalindromic ( arr , Q ) ; } }
import java . util . * ; public class Main { final static long MODULO = 1_000_000_000 + 7 ; static ArrayList < Integer > divs ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long K = sc . nextLong ( ) ; divs = new ArrayList < > ( ) ; for ( int i = 1 ; i * i <= N ; ++ i ) { if ( N % i == 0 ) { divs . add ( i ) ; if ( i * i != N ) { divs . add ( N / i ) ; } } } Collections . sort ( divs ) ; HashMap < Integer , Long > dp = new HashMap < > ( ) ; for ( int d : divs ) { dp . put ( d , pow ( K , ( d + 1 ) / 2 ) ) ; for ( int i = 0 ; divs . get ( i ) < d ; ++ i ) { if ( d % divs . get ( i ) == 0 ) dp . put ( d , ( dp . get ( d ) - dp . get ( divs . get ( i ) ) + MODULO ) % MODULO ) ; } } long ans = 0 ; for ( int d : divs ) { ans = ( ans + dp . get ( d ) * ( d % 2 == 0 ? d / 2 : d ) ) % MODULO ; } System . out . println ( ans ) ; } static class Div { int div ; int num ; public Div ( int div , int num ) { this . div = div ; this . num = num ; } } static long pow ( long a , long n ) { long ret = 1 ; for ( ; n > 0 ; n >>= 1 , a = ( a * a ) % MODULO ) { if ( n % 2 == 1 ) { ret = ( ret * a ) % MODULO ; } } return ret ; } }
import java . io . * ; public class GFG { public static int N = 3 ; static void interchangeDiagonals ( int array [ ] [ ] ) { for ( int i = 0 ; i < N ; ++ i ) if ( i != N / 2 ) { int temp = array [ i ] [ i ] ; array [ i ] [ i ] = array [ i ] [ N - i - 1 ] ; array [ i ] [ N - i - 1 ] = temp ; } for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) System . out . print ( array [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int array [ ] [ ] = { { 4 , 5 , 6 } , { 1 , 2 , 3 } , { 7 , 8 , 9 } } ; interchangeDiagonals ( array ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; public class P1065A { public static void main ( String [ ] args ) throws IOException { BufferedReader io = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer cnt = Integer . valueOf ( io . readLine ( ) ) ; List < Long > rs = new ArrayList < Long > ( ) ; while ( cnt > 0 ) { cnt -- ; String [ ] input = io . readLine ( ) . split ( " ▁ " ) ; Long s = Long . valueOf ( input [ 0 ] ) ; Long a = Long . valueOf ( input [ 1 ] ) ; Long b = Long . valueOf ( input [ 2 ] ) ; Long c = Long . valueOf ( input [ 3 ] ) ; Long tmp = s / c ; tmp = ( tmp / a ) * b + tmp ; rs . add ( tmp ) ; } for ( Long long1 : rs ) { System . out . println ( long1 ) ; } } }
public class GFG { static int MAX = 100000 ; static boolean [ ] prime = new boolean [ 100002 ] ; static void SieveOfEratosthenes ( ) { for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } static int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( ! prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; } public static void main ( String [ ] args ) { int n = 256 ; System . out . println ( superpower ( n ) ) ; } }
class solution { static void printSubArrays ( int [ ] arr , int start , int end ) { if ( end == arr . length ) return ; else if ( start > end ) printSubArrays ( arr , 0 , end + 1 ) ; else { System . out . print ( " [ " ) ; for ( int i = start ; i < end ; i ++ ) { System . out . print ( arr [ i ] + " , ▁ " ) ; } System . out . println ( arr [ end ] + " ] " ) ; printSubArrays ( arr , start + 1 , end ) ; } return ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 2 , 3 } ; printSubArrays ( arr , 0 , 0 ) ; } }
class Test { static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num . charAt ( i ++ ) - '0' ) * 100 ; group += ( num . charAt ( i ++ ) - '0' ) * 10 ; group += num . charAt ( i ) - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = Integer . toString ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ? 1 : 0 ; } return ( gSum == 999 ) ; } public static void main ( String args [ ] ) { String num = "1998" ; System . out . println ( isDivisible999 ( num ) ? " Divisible " : " Not ▁ divisible " ) ; } }
public class Straight_A { public static void main ( String [ ] args ) { java . util . Scanner kbd = new java . util . Scanner ( System . in ) ; int n = kbd . nextInt ( ) ; int k = kbd . nextInt ( ) ; int [ ] marks = new int [ n ] ; int c = 0 ; double cur_gr = 0 ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { marks [ i ] = kbd . nextInt ( ) ; total += marks [ i ] ; cur_gr = Math . round ( total / n ) ; } double r = 0 ; do { r = Math . round ( ( ( double ) total + ( c * k ) ) / ( n ) ) ; c ++ ; n ++ ; } while ( r < k ) ; System . out . println ( c - 1 ) ; } }
import java . io . * ; public class GFG { public static void main ( String [ ] args ) { double n = 5 , a = 2 ; System . out . println ( String . format ( " % . 3 f " , sumOfSeries ( a , n ) ) ) ; } static double sumOfSeries ( double a , double n ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; } }
import java . util . * ; public class GFG { static void printTheArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } static void generateAllBinaryStrings ( int n , int arr [ ] , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; int [ ] arr = new int [ n ] ; generateAllBinaryStrings ( n , arr , 0 ) ; } }
public class GFG { static int numberSequence ( int n ) { int num = ( int ) ( Math . pow ( 4 , n ) - Math . pow ( 2 , n ) ) - 1 ; return num ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( numberSequence ( n ) ) ; } }
import java . io . * ; public class GFG { static int digitProduct ( int n ) { int prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; } static void printMultiplicativePrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 10 ; printMultiplicativePrimes ( n ) ; } }
import java . io . * ; public class GFG { static int minMoves ( int arr [ ] , int n ) { int expectedItem = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == expectedItem ) expectedItem -- ; } return expectedItem ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( minMoves ( arr , n ) ) ; } }
import java . util . Arrays ; public class GFG { static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 2 , 5 , 4 } ; int size = arr . length ; System . out . println ( largestGCDSubsequence ( arr , size ) ) ; } }
import java . io . * ; public class GFG { static int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
public class GFG { static void count ( String str1 , String str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . indexOf ( str1 . charAt ( i ) ) >= 0 ) { c += 1 ; } } System . out . println ( " No . ▁ of ▁ matching ▁ characters ▁ are : ▁ " + c ) ; } public static void main ( String [ ] args ) { String str1 = " aabcddekll12 @ " ; String str2 = " bb2211@55k " ; count ( str1 , str2 ) ; } }
public class GFG { static int MinimumX ( int a , int b , int c , int k ) { int x = Integer . MAX_VALUE ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; } public static void main ( String [ ] args ) { int a = 3 , b = 2 , c = 4 , k = 15 ; System . out . println ( MinimumX ( a , b , c , k ) ) ; } }
public class GFG { static int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; } public static void main ( String args [ ] ) { int n = 52 ; System . out . println ( minLettersNeeded ( n ) ) ; } }
import java . util . Scanner ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; int [ ] arr = new int [ 26 ] ; int [ ] arr2 = new int [ 26 ] ; in . nextLine ( ) ; String s = in . nextLine ( ) ; char [ ] chars = s . toCharArray ( ) ; for ( char c : chars ) { arr [ c - ' a ' ] ++ ; } StringBuilder ans = new StringBuilder ( ) ; int i ; for ( i = 1 ; i < 25 ; i ++ ) arr [ i ] = Math . min ( arr [ i ] , arr [ i - 1 ] ) ; arr [ Math . min ( 25 , n / k ) ] = 0 ; for ( i = Math . min ( 24 , n / k - 1 ) ; i >= 0 ; i -- ) arr2 [ i ] = arr [ i ] - arr [ i + 1 ] ; for ( i = 0 ; i < 25 ; i ++ ) if ( arr2 [ i ] == 0 ) break ; int h = 0 ; for ( i = Math . min ( 25 , n / k - 1 ) ; i >= 0 ; i -- ) { if ( k >= arr2 [ i ] ) { int q = arr2 [ i ] ; while ( ( q -- ) > 0 ) System . out . print ( ( char ) ( ' a ' + i + 1 ) ) ; k -= arr2 [ i ] ; } else while ( k -- > 0 ) System . out . print ( ( char ) ( ' a ' + i + 1 ) ) ; } while ( k -- > 0 ) System . out . print ( ( char ) ( ' a ' + i + 1 ) ) ; System . out . println ( ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; if ( Math . max ( 3 * a / 10 , a - a * c / 250 ) > Math . max ( 3 * b / 10 , b - b * d / 250 ) ) { System . out . println ( " Misha " ) ; } else if ( Math . max ( 3 * a / 10 , a - a * c / 250 ) < Math . max ( 3 * b / 10 , b - b * d / 250 ) ) { System . out . println ( " Vasya " ) ; } else { System . out . println ( " Tie " ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = Integer . parseInt ( sc . next ( ) ) ; int B = Integer . parseInt ( sc . next ( ) ) ; sc . close ( ) ; if ( Math . abs ( A - B ) < 2 ) { System . out . println ( " Yay ! " ) ; } else { System . out . println ( " : ( " ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a > b ? a - 1 : a ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } UnionFind uf = new UnionFind ( ) ; for ( int ai : a ) { int value = ai ; for ( int i = 2 ; i * i <= ai ; i ++ ) { if ( value % i == 0 ) { uf . unite ( ai , i ) ; while ( value % i == 0 ) value /= i ; } } if ( value != 1 ) { uf . unite ( ai , value ) ; } } int [ ] asorted = a . clone ( ) ; Arrays . sort ( asorted ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! uf . isSameRoot ( a [ i ] , asorted [ i ] ) ) { System . out . println ( 0 ) ; return ; } } System . out . println ( 1 ) ; } } class UnionFind { int [ ] data = new int [ 100010 ] ; UnionFind ( ) { for ( int i = 0 ; i < 100010 ; i ++ ) { data [ i ] = i ; } } void unite ( int left , int right ) { data [ root ( left ) ] = root ( right ) ; } int root ( int i ) { if ( data [ i ] == i ) return i ; else return data [ i ] = root ( data [ i ] ) ; } boolean isSameRoot ( int x , int y ) { return root ( x ) == root ( y ) ; } }
public class GFG { static int ways ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { String temp = " " ; for ( int j = i ; j < n ; j ++ ) { temp += s . charAt ( j ) ; String test = " " ; for ( int k = i - 1 ; k >= 0 ; k -- ) { test += s . charAt ( k ) ; if ( test . compareTo ( temp ) < 0 ) { dp [ i ] [ j ] += dp [ k ] [ i - 1 ] ; } } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += dp [ i ] [ n - 1 ] ; } return ans ; } public static void main ( String [ ] args ) { String s = " aabc " ; int n = s . length ( ) ; System . out . println ( ways ( s , n ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . lang . Math ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Random ; import java . util . StringTokenizer ; public class Main { public static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } public static char different ( String s1 , String s2 , int i ) { char check [ ] = { ' a ' , ' b ' , ' c ' } ; for ( char ch : check ) { if ( ch != s1 . charAt ( i ) && ch != s2 . charAt ( i ) ) { return ch ; } } return ' z ' ; } public static void main ( String [ ] args ) throws java . lang . Exception { FastScanner fs = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int t = fs . nextInt ( ) ; while ( t -- > 0 ) { int n = fs . nextInt ( ) ; long x = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { x *= 2 ; } out . println ( x - 1 ) ; } out . close ( ) ; } }
public class GFG { static boolean isOdd ( int [ ] arr , int n ) { int l , r , flag = 0 , flag1 = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % 2 == 0 && flag == 0 ) { flag = 1 ; l = arr [ i ] ; } if ( arr [ i ] % 2 != 0 && flag1 == 0 ) { r = arr [ i ] ; flag1 = 1 ; } } if ( sum % 2 != 0 ) { return true ; } else { if ( flag1 == 1 && flag == 1 ) return true ; else return false ; } } public static void main ( String [ ] args ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . length ; boolean res = isOdd ( ar , n ) ; if ( res == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; sc . nextLine ( ) ; String val = sc . nextLine ( ) ; int i = 0 , j = val . length ( ) - 1 ; while ( k > 0 ) { if ( val . charAt ( i ) != val . charAt ( j ) ) break ; k -- ; i ++ ; j -- ; } if ( k > 0 ) System . out . println ( " NO " ) ; else if ( i > j ) { System . out . println ( " NO " ) ; } else System . out . println ( " YES " ) ; } } }
public class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int maxCommonFactors ( int a , int b ) { int __gcd = gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd /= i ; } } if ( __gcd != 1 ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int a = 12 , b = 18 ; System . out . println ( maxCommonFactors ( a , b ) ) ; } }
import java . io . * ; public class GFG { static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; } static public void main ( String [ ] args ) { String s = " aaa " ; if ( allCharactersSame ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class CardGame { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; while ( t -- > 0 ) { int n , a , b ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; n = Integer . parseInt ( st . nextToken ( ) ) ; a = Integer . parseInt ( st . nextToken ( ) ) ; b = Integer . parseInt ( st . nextToken ( ) ) ; int ma , mb , ta = 0 , tb = 0 ; st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < a ; i ++ ) { ma = Integer . parseInt ( st . nextToken ( ) ) ; ; if ( ma > ta ) ta = ma ; } st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < b ; i ++ ) { mb = Integer . parseInt ( st . nextToken ( ) ) ; ; if ( mb > tb ) tb = mb ; } System . out . println ( ( ta > tb ) ? " YES " : " NO " ) ; } } }
class Main { static void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies ▁ between ▁ the ▁ indices ▁ " + s + " ▁ and ▁ " + e ) ; return ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = arr . length ; printUnsorted ( arr , arr_size ) ; } }
import java . util . * ; public class QQQ { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; int c = 1 ; int [ ] a = new int [ t ] ; int [ ] k = new int [ t + 1 ] ; int k1 = 0 ; for ( int i = 0 ; i < t ; i ++ ) { a [ i ] = in . nextInt ( ) ; } for ( int i = 1 ; i < t ; i ++ ) { if ( a [ i ] >= a [ i - 1 ] ) { c ++ ; } else { k [ k1 ++ ] = c ; c = 1 ; } } k [ t ] = c ; Arrays . sort ( k ) ; System . out . println ( k [ k . length - 1 ] ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sin = new Scanner ( System . in ) ; int L = sin . nextInt ( ) ; int D = sin . nextInt ( ) ; int result = L / D + L % D ; System . out . println ( result ) ; } }
class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; } public static void main ( String [ ] args ) { String str = "99333" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; } public static void main ( String [ ] args ) { String str = "1332" ; if ( check ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class Solution { public List < String > letterCasePermutation ( String S ) { List < StringBuilder > ans = new ArrayList ( ) ; ans . add ( new StringBuilder ( ) ) ; for ( char c : S . toCharArray ( ) ) { int n = ans . size ( ) ; if ( Character . isLetter ( c ) ) { for ( int i = 0 ; i < n ; ++ i ) { ans . add ( new StringBuilder ( ans . get ( i ) ) ) ; ans . get ( i ) . append ( Character . toLowerCase ( c ) ) ; ans . get ( n + i ) . append ( Character . toUpperCase ( c ) ) ; } } else { for ( int i = 0 ; i < n ; ++ i ) ans . get ( i ) . append ( c ) ; } } List < String > finalans = new ArrayList ( ) ; for ( StringBuilder sb : ans ) finalans . add ( sb . toString ( ) ) ; return finalans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String S = " a1b2" ; List < String > out = sObj . letterCasePermutation ( S ) ; System . out . println ( out ) ; } }
import java . util . * ; public class GFG { static int countDigits ( int n ) { return ( int ) ( n * Math . log10 ( 2 ) + 1 ) ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( countDigits ( n ) ) ; } }
public class GFG { static boolean isPerfectSquare ( int N ) { double sr = Math . sqrt ( N ) ; return ( sr - Math . floor ( sr ) ) == 0 ; } static void BetrothedNumbers ( int n , int m ) { int Sum1 = 1 ; int Sum2 = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { Sum1 += i + ( isPerfectSquare ( n ) ? 0 : n / i ) ; } } for ( int i = 2 ; i <= Math . sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { Sum2 += i + ( isPerfectSquare ( m ) ? 0 : m / i ) ; } } if ( ( n + 1 == Sum2 ) && ( m + 1 == Sum1 ) ) { System . out . print ( " YES " + " \n " ) ; } else { System . out . print ( " NO " + " \n " ) ; } } public static void main ( String [ ] args ) { int N = 9504 ; int M = 20734 ; BetrothedNumbers ( N , M ) ; } }
public final class p214 { public static void main ( String [ ] args ) { System . out . println ( new p214 ( ) . run ( ) ) ; } private static final int LIMIT = 40000000 ; public String run ( ) { int [ ] totient = Library . listTotients ( LIMIT - 1 ) ; int [ ] totientChainLength = new int [ totient . length ] ; totientChainLength [ 0 ] = 0 ; long sum = 0 ; for ( int i = 1 ; i < totient . length ; i ++ ) { int chainlen = totientChainLength [ totient [ i ] ] + 1 ; totientChainLength [ i ] = chainlen ; if ( chainlen == 25 && totient [ i ] == i - 1 ) sum += i ; } return Long . toString ( sum ) ; } }
import java . util . * ; import java . io . * ; public class LastMinuteEnhancements { public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; StringTokenizer st = new StringTokenizer ( in . readLine ( ) ) ; int t = Integer . parseInt ( st . nextToken ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { StringTokenizer st1 = new StringTokenizer ( in . readLine ( ) ) ; int n = Integer . parseInt ( st1 . nextToken ( ) ) ; StringTokenizer st2 = new StringTokenizer ( in . readLine ( ) ) ; int [ ] array = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { array [ j ] = Integer . parseInt ( st2 . nextToken ( ) ) ; } Arrays . sort ( array ) ; array [ n - 1 ] ++ ; int cnt = 1 ; for ( int k = n - 2 ; k >= 0 ; k -- ) { if ( array [ k ] + 1 < array [ k + 1 ] ) { cnt ++ ; array [ k ] ++ ; } else if ( array [ k ] != array [ k + 1 ] ) { cnt ++ ; } } out . println ( cnt ) ; } out . close ( ) ; } }
import java . util . * ; class Main { static void solve ( int n ) { int [ ] [ ] jpeg = new int [ n ] [ n ] ; int x = 0 ; int y = 0 ; boolean ascending = true ; for ( int i = 1 ; i <= n * n ; i ++ ) { jpeg [ x ] [ y ] = i ; if ( ascending && y == 0 && x != n - 1 ) { x += 1 ; ascending = false ; } else if ( ( ! ascending ) && x == 0 && y != n - 1 ) { y += 1 ; ascending = true ; } else if ( ascending && x == n - 1 ) { y += 1 ; ascending = false ; } else if ( ( ! ascending ) && y == n - 1 ) { x += 1 ; ascending = true ; } else if ( ascending ) { x += 1 ; y -= 1 ; } else { x -= 1 ; y += 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . printf ( " % 3d " , jpeg [ j ] [ i ] ) ; } System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int times = 1 ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; System . out . printf ( " Case ▁ % d : \n " , times ) ; solve ( n ) ; times += 1 ; } } }
import java . io . * ; public class GFG { static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; } static public void main ( String [ ] args ) { int [ ] arr = { 30 , 10 , 9 , 3 , 35 } ; int n = arr . length ; System . out . println ( findGreatest ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int XorSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int k = 0 ; for ( int j = 1 ; j <= arr [ i ] ; j ++ ) k ^= arr [ i ] ; result += k ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( XorSum ( arr , n ) ) ; } }
import java . io . * ; import java . util . StringTokenizer ; public final class cp { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( " \n " ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } void close ( ) throws IOException { br . close ( ) ; } } public static void main ( String [ ] args ) throws IOException { FastReader r = new FastReader ( ) ; PrintWriter w = new PrintWriter ( System . out , true ) ; int n = r . nextInt ( ) ; String str = r . next ( ) ; int max , j ; String res = " " ; int [ ] freq ; boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { max = Integer . MIN_VALUE ; freq = new int [ 26 ] ; for ( j = i ; j < n ; j ++ ) { int val = str . charAt ( j ) - ' a ' ; freq [ val ] ++ ; if ( freq [ val ] > max ) { max = freq [ val ] ; } if ( max <= ( j - i + 1 ) >> 1 ) { res = str . substring ( i , j + 1 ) ; flag = true ; break ; } } if ( flag ) break ; } w . println ( ( res . equals ( " " ) ? " NO " : " YES \n " + res ) ) ; r . close ( ) ; } }
public class GFG { static final int MAX = 256 ; static boolean compare ( char arr1 [ ] , char arr2 [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; char [ ] countP = new char [ MAX ] ; char [ ] countTW = new char [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat . charAt ( i ) ] ) ++ ; ( countTW [ txt . charAt ( i ) ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) System . out . println ( " Found ▁ at ▁ Index ▁ " + ( i - M ) ) ; ( countTW [ txt . charAt ( i ) ] ) ++ ; countTW [ txt . charAt ( i - M ) ] -- ; } if ( compare ( countP , countTW ) ) System . out . println ( " Found ▁ at ▁ Index ▁ " + ( N - M ) ) ; } public static void main ( String args [ ] ) { String txt = " BACDGABCDA " ; String pat = " ABCD " ; search ( pat , txt ) ; } }
import java . util . Scanner ; public class Main { static int MOD = 1000000007 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; long xSum = 0 ; long ySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xSum = ( xSum + ( 2 * i - n + 1 ) * sc . nextLong ( ) ) % MOD ; } for ( int i = 0 ; i < m ; i ++ ) { ySum = ( ySum + ( 2 * i - m + 1 ) * sc . nextLong ( ) ) % MOD ; } System . out . println ( ( ( ( xSum * ySum ) % MOD ) + MOD ) % MOD ) ; } }
import java . io . PrintWriter ; import java . util . Scanner ; public class PermutationFinder { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out , true ) ; int N = in . nextInt ( ) ; long K = in . nextLong ( ) ; long [ ] fib = new long [ N + 1 ] ; fib [ 0 ] = fib [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int idx = 0 ; int [ ] res = new int [ N ] ; while ( idx < N ) { if ( K <= fib [ N - idx - 1 ] ) { res [ idx ] = idx + 1 ; idx ++ ; } else { K -= fib [ N - idx - 1 ] ; res [ idx ] = idx + 2 ; res [ idx + 1 ] = idx + 1 ; idx += 2 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) out . print ( " ▁ " ) ; out . print ( res [ i ] ) ; } out . println ( ) ; out . close ( ) ; System . exit ( 0 ) ; } }
import java . util . ArrayList ; import java . util . LinkedHashMap ; import java . util . Scanner ; public class B46 { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; LinkedHashMap < String , Integer > n = new LinkedHashMap < String , Integer > ( ) ; n . put ( " S " , sc . nextInt ( ) ) ; n . put ( " M " , sc . nextInt ( ) ) ; n . put ( " L " , sc . nextInt ( ) ) ; n . put ( " XL " , sc . nextInt ( ) ) ; n . put ( " XXL " , sc . nextInt ( ) ) ; int k = sc . nextInt ( ) ; for ( int i = 0 ; i < k ; i ++ ) { String size = sc . next ( ) ; if ( n . get ( size ) > 0 ) { System . out . println ( size ) ; n . put ( size , n . get ( size ) - 1 ) ; } else { ArrayList < String > keys = new ArrayList < String > ( n . keySet ( ) ) ; boolean found = false ; int ind = 0 ; int d = 1 ; while ( true ) { ind = keys . indexOf ( size ) + d ; if ( ind < keys . size ( ) ) { if ( n . get ( keys . get ( ind ) ) > 0 ) { System . out . println ( keys . get ( ind ) ) ; n . put ( keys . get ( ind ) , n . get ( keys . get ( ind ) ) - 1 ) ; found = true ; break ; } } if ( ! found && keys . indexOf ( size ) - d >= 0 ) { ind = keys . indexOf ( size ) - d ; if ( n . get ( keys . get ( ind ) ) > 0 ) { System . out . println ( keys . get ( ind ) ) ; n . put ( keys . get ( ind ) , n . get ( keys . get ( ind ) ) - 1 ) ; break ; } } d ++ ; } } } } }
import java . util . * ; public class ArrayRearrangment { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int q = sc . nextInt ( ) ; while ( q -- > 0 ) { int n = sc . nextInt ( ) , x = sc . nextInt ( ) , flag = 0 ; List < Integer > list = new ArrayList < > ( ) ; List < Integer > list1 = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( sc . nextInt ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { list1 . add ( sc . nextInt ( ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( list . get ( i ) + list1 . get ( i ) > x ) { flag = 1 ; break ; } } if ( flag == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } } }
public class GFG { public static int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( solve ( n ) ) ; } }
import java . util . * ; public class A { public static void main ( String args [ ] ) { Scanner Sc = new Scanner ( System . in ) ; int t = Sc . nextInt ( ) ; while ( t -- > 0 ) { int n = Sc . nextInt ( ) ; int size = 2 * n ; counter = 0 ; helper ( " ( " , 1 , 0 , size , n ) ; } } static int counter ; static void helper ( String str , int o , int c , int size , int n ) { if ( counter == n ) return ; if ( o > n || c > n ) return ; if ( o == c && ( o + c ) == size ) { counter ++ ; System . out . println ( str ) ; return ; } helper ( str + ' ( ' , o + 1 , c , size , n ) ; helper ( str + ' ) ' , o , c + 1 , size , n ) ; } }
public class GFG { public static int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) == 1 ) System . out . println ( " Valid ▁ quadilateral " ) ; else System . out . println ( " Invalid ▁ quadilateral " ) ; } }
import java . util . Scanner ; public class Solution20200410 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; double R = scanner . nextDouble ( ) ; double r = scanner . nextDouble ( ) ; double angle = 360.0 / ( n * 2 ) ; double minR = r / Math . sin ( Math . toRadians ( angle ) ) + r ; if ( n == 1 ) { if ( R >= r ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else if ( n == 2 ) { if ( R >= r * 2 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { if ( R >= minR ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
public class GFG { static int MAX = 100001 ; static int [ ] prime = new int [ MAX + 1 ] ; static int [ ] countdiv = new int [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; } static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ; while ( element > 1 ) { int div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int arr [ ] = { 10 , 15 , 7 , 25 , 9 , 35 } ; int size = arr . length ; System . out . println ( largestGCDSubsequence ( arr , size ) ) ; } }
public class GFG { static int Count ( String s , int pos ) { int c = s . charAt ( pos - 1 ) ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s . charAt ( i ) == c ) counter = counter + 1 ; } return counter ; } public static void main ( String [ ] args ) { String s = " abacsddaa " ; int pos ; int n = s . length ( ) ; int query [ ] = { 9 , 3 , 2 } ; int Q = query . length ; for ( int i = 0 ; i < Q ; i ++ ) { pos = query [ i ] ; System . out . println ( Count ( s , pos ) ) ; } } }
import java . util . Scanner ; public class AlarmClock { public static void main ( String [ ] args ) { Scanner iScanner = new Scanner ( System . in ) ; int test = iScanner . nextInt ( ) ; while ( test > 0 ) { test -- ; long a = iScanner . nextLong ( ) ; long b = iScanner . nextLong ( ) ; long c = iScanner . nextLong ( ) ; long d = iScanner . nextLong ( ) ; if ( b >= a ) { System . out . println ( b ) ; } else { if ( d >= c ) System . out . println ( " - 1" ) ; else { long rest = a - b ; long restAlarm = c - d ; long totalRest = 0 ; if ( rest % restAlarm != 0 ) totalRest = ( rest / restAlarm ) + 1 ; else totalRest = rest / restAlarm ; System . out . println ( b + totalRest * c ) ; } } } } }
import java . util . HashMap ; import java . util . Map ; import java . util . Map . Entry ; public class FindDuplicatedInArray { public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 } ; int n = arr . length ; printDuplicates ( arr , n ) ; } private static void printDuplicates ( int [ ] arr , int n ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int count = 0 ; boolean dup = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , count + 1 ) ; } else { map . put ( arr [ i ] , 1 ) ; } } for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { System . out . print ( entry . getKey ( ) + " ▁ " ) ; dup = true ; } } System . out . println ( " \n " ) ; if ( ! dup ) { System . out . println ( " - 1" ) ; } } }
import java . io . * ; import java . util . * ; public class Main { private static MyScanner scanner ; public static void main ( String [ ] args ) { Main instance = new Main ( ) ; scanner = instance . new MyScanner ( ) ; instance . solve ( ) ; } private void solve ( ) { try { int N = scanner . nextInt ( ) ; int kisu = 0 , gusu = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long ai = scanner . nextLong ( ) ; if ( ai % 2 == 0 ) { gusu ++ ; } else { kisu ++ ; } } gusu += kisu / 2 ; kisu = kisu - kisu / 2 * 2 ; if ( kisu == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private class MyScanner { String [ ] s ; int i ; BufferedReader br ; String reg = " ▁ " ; MyScanner ( ) { s = new String [ 0 ] ; i = 0 ; br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public String next ( ) throws IOException { if ( i < s . length ) return s [ i ++ ] ; String line = br . readLine ( ) ; while ( line . equals ( " " ) ) { line = br . readLine ( ) ; } s = line . split ( reg , 0 ) ; i = 0 ; return s [ i ++ ] ; } public int nextInt ( ) throws NumberFormatException , IOException { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) throws NumberFormatException , IOException { return Double . parseDouble ( next ( ) ) ; } public long nextLong ( ) throws NumberFormatException , IOException { return Long . parseLong ( next ( ) ) ; } } }
import java . io . * ; public class GFG { static int findMissingUtil ( int arr [ ] , int low , int high , int diff ) { if ( high <= low ) return Integer . MAX_VALUE ; int mid = low + ( high - low ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissingUtil ( arr , mid + 1 , high , diff ) ; return findMissingUtil ( arr , low , mid - 1 , diff ) ; } static int findMissing ( int arr [ ] , int n ) { int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissingUtil ( arr , 0 , n - 1 , diff ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 8 , 10 , 12 , 14 } ; int n = arr . length ; System . out . println ( " The ▁ missing ▁ element ▁ is ▁ " + findMissing ( arr , n ) ) ; } }
public class GFG { static void findPair ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( " - 1" ) ; return ; } int i , first , second ; first = second = - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } System . out . println ( " n ▁ = ▁ " + first + " ▁ and ▁ r ▁ = ▁ " + second ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 } ; int n = arr . length ; findPair ( arr , n ) ; } }
import java . io . * ; import java . util . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; Arrays . setAll ( a , i -> in . nextInt ( ) ) ; int ans = Integer . MAX_VALUE ; int T = 0 ; for ( int k = 1 ; k <= 100 ; k ++ ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k == a [ i ] ) continue ; int v1 = Math . abs ( ( k + 1 ) - a [ i ] ) ; int v2 = Math . abs ( ( k - 1 ) - a [ i ] ) ; res += Math . min ( v1 , v2 ) ; } if ( ans > res ) { ans = res ; T = k ; } } pw . println ( T + " ▁ " + ans ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = in . readLine ( ) ; String [ ] vowel = { " w " , " " , " k " , " s " , " t " , " n " , " h " , " m " , " y " , " r " } ; for ( int i = 0 ; i < str . length ( ) ; i += 2 ) { char m = str . charAt ( i ) ; char c = str . charAt ( i + 1 ) ; if ( m == '0' && c == ' U ' ) { System . out . print ( " nn " ) ; } else { System . out . print ( vowel [ m - '0' ] ) ; switch ( c ) { case ' T ' : System . out . print ( ' a ' ) ; break ; case ' L ' : System . out . print ( ' i ' ) ; break ; case ' U ' : System . out . print ( ' u ' ) ; break ; case ' R ' : System . out . print ( ' e ' ) ; break ; case ' D ' : System . out . print ( ' o ' ) ; break ; } } } System . out . println ( ) ; } }
public class GFG { static int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; } public static void main ( String [ ] args ) { int R = 4 , C = 5 , M = 2 ; System . out . println ( Square ( R , C , M ) ) ; } }
import java . io . * ; import java . util . * ; public class Main { static PrintWriter out = new PrintWriter ( System . out ) ; static Scanner in = new Scanner ( System . in ) ; static BufferedReader re = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter wr = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; public static void main ( String [ ] args ) throws IOException { PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int T = in . nextInt ( ) ; while ( T > 0 ) { long a = in . nextLong ( ) ; long b = in . nextLong ( ) ; long c = in . nextLong ( ) ; long res = ( a + 2 * b + 3 * c ) % 2 ; out . println ( res ) ; T -- ; } out . flush ( ) ; } }
public class GFG { static int powmod ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int [ ] value = new int [ m ] ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , m = 5 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; } }
import java . io . * ; public class GFG { static int Circumference ( int l , int w ) { return ( 2 * ( l + w ) ) ; } static public void main ( String [ ] args ) { int l = 8 , w = 4 ; int c = Circumference ( l , w ) ; System . out . println ( " Circumference ▁ of ▁ " + " a ▁ rectangle ▁ is ▁ " + c ) ; } }
import java . io . * ; public class GFG { static double edgeDisjoint ( int n ) { double result = 0 ; result = Math . floor ( n / 2 ) ; return result ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( ( int ) edgeDisjoint ( n ) ) ; } }
import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; public class B792 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; int [ ] A = new int [ K ] ; for ( int k = 0 ; k < K ; k ++ ) { A [ k ] = in . nextInt ( ) ; } List < Integer > list = new LinkedList < > ( ) ; for ( int n = 1 ; n <= N ; n ++ ) { list . add ( n ) ; } StringBuilder output = new StringBuilder ( ) ; int pos = 0 ; for ( int k = 0 ; k < K ; k ++ ) { pos += A [ k ] ; pos %= list . size ( ) ; output . append ( list . get ( pos ) ) . append ( ' ▁ ' ) ; list . remove ( pos ) ; } System . out . println ( output ) ; } }
public class GFG { static int sum [ ] = new int [ 1000005 ] ; static int toInt ( char x ) { return x - '0' ; } static void prepareSum ( String s ) { sum [ 0 ] = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum [ i + 1 ] = sum [ i ] + toInt ( s . charAt ( i ) ) ; } } static void query ( int l , int r ) { if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) { System . out . println ( " Divisible ▁ by ▁ 3" ) ; } else { System . out . println ( " Not ▁ divisible ▁ by ▁ 3" ) ; } } public static void main ( String [ ] args ) { String n = "12468236544" ; prepareSum ( n ) ; query ( 0 , 1 ) ; query ( 1 , 2 ) ; query ( 3 , 6 ) ; query ( 0 , 10 ) ; } }
import java . util . Arrays ; public final class p124 { public static void main ( String [ ] args ) { System . out . println ( new p124 ( ) . run ( ) ) ; } private static final int LIMIT = 100000 ; public String run ( ) { int [ ] rads = new int [ LIMIT + 1 ] ; Arrays . fill ( rads , 1 , rads . length , 1 ) ; for ( int i = 2 ; i < rads . length ; i ++ ) { if ( rads [ i ] == 1 ) { for ( int j = i ; j < rads . length ; j += i ) rads [ j ] *= i ; } } IntPair [ ] data = new IntPair [ LIMIT ] ; for ( int i = 0 ; i < data . length ; i ++ ) data [ i ] = new IntPair ( rads [ i + 1 ] , i + 1 ) ; Arrays . sort ( data ) ; return Integer . toString ( data [ 10000 - 1 ] . b ) ; } private static final class IntPair implements Comparable < IntPair > { public final int a ; public final int b ; public IntPair ( int a , int b ) { this . a = a ; this . b = b ; } public int compareTo ( IntPair other ) { if ( a != other . a ) return Integer . compare ( a , other . a ) ; else return Integer . compare ( b , other . b ) ; } } }
import java . util . * ; import java . io . * ; public class MyClass { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String s [ ] = br . readLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { long x = Long . parseLong ( s [ i ] ) ; if ( x < 15 ) { System . out . println ( " NO " ) ; continue ; } x = x % 14 ; if ( x >= 1 && x <= 6 ) { System . out . println ( " YES " ) ; } else System . out . println ( " NO " ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long N = sc . nextLong ( ) ; long M = sc . nextLong ( ) ; if ( N >= M / 2 ) { System . out . println ( M / 2 ) ; return ; } System . out . println ( N + ( M - 2 * N ) / 4 ) ; } }
import java . util . * ; public class GFG { static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { LinkedList < Integer > Di = new LinkedList < > ( ) ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) Di . add ( i ) ; for ( ; i < n ; i ++ ) { if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; while ( ( ! Di . isEmpty ( ) ) && Di . peek ( ) < ( i - k + 1 ) ) Di . remove ( ) ; if ( arr [ i ] < 0 ) Di . add ( i ) ; } if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " ▁ " ) ; else System . out . println ( " 0 " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 } ; int n = arr . length ; int k = 3 ; printFirstNegativeInteger ( arr , n , k ) ; } }
import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = sc . nextInt ( ) ; int [ ] v = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { v [ i ] = sc . nextInt ( ) ; } ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( v [ 0 ] ) ; ++ i ) { if ( v [ 0 ] % i != 0 ) continue ; boolean ok = true ; for ( int j = 1 ; j < N ; ++ j ) { if ( v [ j ] % i != 0 ) { ok = false ; break ; } } if ( ok ) ans . add ( i ) ; if ( i * i != v [ 0 ] ) { ok = true ; for ( int j = 1 ; j < N ; ++ j ) { if ( v [ j ] % ( v [ 0 ] / i ) != 0 ) { ok = false ; break ; } } if ( ok ) ans . add ( v [ 0 ] / i ) ; } } Collections . sort ( ans ) ; for ( int a : ans ) { System . out . println ( a ) ; } } }
import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static String name ; static int num ; public static void main ( String [ ] args ) { for ( int i = 0 ; i < 9 ; i ++ ) { read_and_solve ( ) ; } } static void read_and_solve ( ) { int res = 0 ; int temp = 0 ; name = sc . next ( ) ; num = sc . nextInt ( ) ; temp = num ; res = num * 200 ; num = sc . nextInt ( ) ; res = res + num * 300 ; num = num + temp ; System . out . println ( name + " ▁ " + num + " ▁ " + res ) ; } }
import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; double x1 , y1 , x2 , y2 , xq , yq , ax , ay ; double m1 , m2 , l1 , l2 ; int q ; x1 = scan . nextDouble ( ) ; y1 = scan . nextDouble ( ) ; x2 = scan . nextDouble ( ) ; y2 = scan . nextDouble ( ) ; m1 = ( y2 - y1 ) / ( x2 - x1 ) ; l1 = y1 - ( m1 * x1 ) ; m2 = - 1.0 / m1 ; q = scan . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { xq = scan . nextDouble ( ) ; yq = scan . nextDouble ( ) ; if ( x1 == x2 ) { ax = x1 ; ay = yq ; } else if ( y1 == y2 ) { ax = xq ; ay = y1 ; } else { l2 = yq - ( m2 * xq ) ; ax = ( l2 - l1 ) / ( m1 - m2 ) ; ay = ( l2 * m1 - l1 * m2 ) / ( m1 - m2 ) ; } System . out . println ( ax + " ▁ " + ay ) ; } scan . close ( ) ; } }
public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; double xp1 , xp2 , yp1 , yp2 ; int q ; double [ ] xp , yp ; double ansx , ansy , t ; int i ; xp1 = sc . nextDouble ( ) ; yp1 = sc . nextDouble ( ) ; xp2 = sc . nextDouble ( ) ; yp2 = sc . nextDouble ( ) ; q = sc . nextInt ( ) ; xp = new double [ q ] ; yp = new double [ q ] ; for ( i = 0 ; i < q ; i ++ ) { xp [ i ] = sc . nextDouble ( ) ; yp [ i ] = sc . nextDouble ( ) ; } sc . close ( ) ; for ( i = 0 ; i < q ; i ++ ) { t = ( xp2 - xp1 ) * ( xp [ i ] - xp1 ) + ( yp2 - yp1 ) * ( yp [ i ] - yp1 ) ; t = t / ( ( xp2 - xp1 ) * ( xp2 - xp1 ) + ( yp2 - yp1 ) * ( yp2 - yp1 ) ) ; ansx = xp1 + t * ( xp2 - xp1 ) ; ansx = ansx + ( ansx - xp [ i ] ) ; ; ansy = yp1 + t * ( yp2 - yp1 ) ; ansy = ansy + ( ansy - yp [ i ] ) ; System . out . printf ( " % .10f ▁ % .10f % n " , ansx , ansy ) ; } } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }
import java . util . * ; class Initials { public static void printInitials ( String str ) { int len = str . length ( ) ; str = str . trim ( ) ; String t = " " ; for ( int i = 0 ; i < len ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' ▁ ' ) { t = t + ch ; } else { System . out . print ( Character . toUpperCase ( t . charAt ( 0 ) ) + " . ▁ " ) ; t = " " ; } } String temp = " " ; for ( int j = 0 ; j < t . length ( ) ; j ++ ) { if ( j == 0 ) temp = temp + Character . toUpperCase ( t . charAt ( 0 ) ) ; else temp = temp + Character . toLowerCase ( t . charAt ( j ) ) ; } System . out . println ( temp ) ; } public static void main ( String [ ] args ) { String str = " ishita ▁ bhuiya " ; printInitials ( str ) ; } }
public class GFG { static int max_sum ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = Math . max ( 0 , arr [ 0 ] ) ; int i = 1 ; while ( i < k ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] ) ; i ++ ; } i = k ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; i ++ ; } return dp [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , - 2 , 4 , 3 , 1 } ; int n = arr . length ; int k = 4 ; System . out . println ( max_sum ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . * ; public class Run { public static int [ ] getMin ( char [ ] [ ] grid , boolean forCol ) { int n = grid . length ; int m = grid [ 0 ] . length ; int [ ] ans ; if ( ! forCol ) { ans = new int [ n ] ; int i = 0 ; for ( char [ ] row : grid ) { int currAns = m ; for ( char c : row ) { if ( c == ' * ' ) -- currAns ; } ans [ i ] = currAns ; ++ i ; } } else { ans = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { int currAns = n ; for ( char [ ] chars : grid ) { if ( chars [ j ] == ' * ' ) -- currAns ; } ans [ j ] = currAns ; } } return ans ; } public static void main ( String [ ] Z ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder op = new StringBuilder ( ) ; int k = Integer . parseInt ( br . readLine ( ) ) ; StringBuilder s = new StringBuilder ( k ) ; int dig = 1 ; while ( s . length ( ) < k ) { s . append ( dig ) ; ++ dig ; } op . append ( s . charAt ( k - 1 ) ) ; System . out . println ( op ) ; } }
public class GFG { static int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } } static public void main ( String args [ ] ) { int a = 21 , b = 5 ; System . out . println ( countX ( a , b ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; ArrayList < Pair > [ ] g = new ArrayList [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { g [ i ] = new ArrayList < > ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { int l = sc . nextInt ( ) - 1 ; int r = sc . nextInt ( ) - 1 ; int d = sc . nextInt ( ) ; g [ l ] . add ( new Pair ( r , d ) ) ; g [ r ] . add ( new Pair ( l , - d ) ) ; } int [ ] p = new int [ n ] ; boolean [ ] used = new boolean [ n ] ; boolean ans = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( used [ i ] ) continue ; ArrayDeque < Integer > q = new ArrayDeque < > ( ) ; q . add ( i ) ; used [ i ] = true ; while ( ! q . isEmpty ( ) ) { int v = q . poll ( ) ; for ( Pair na : g [ v ] ) { int nv = na . x , nd = na . y ; if ( used [ nv ] ) { if ( p [ nv ] != p [ v ] + nd ) { ans = false ; break ; } } else { p [ nv ] = p [ v ] + nd ; used [ nv ] = true ; q . add ( nv ) ; } } if ( ! ans ) break ; } if ( ! ans ) break ; } System . out . println ( ans ? " Yes " : " No " ) ; sc . close ( ) ; } static class Pair { final int x ; final int y ; Pair ( int x , int y ) { this . x = x ; this . y = y ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int nA = sc . nextInt ( ) ; int nB = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ nA ] ; int [ ] b = new int [ nB ] ; for ( int i = 0 ; i < nA ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < nB ; i ++ ) b [ i ] = sc . nextInt ( ) ; if ( a [ k - 1 ] < b [ nB - m ] ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } catch ( Exception e ) { } } }
import java . util . * ; import java . math . * ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; long A = s . nextLong ( ) , B = s . nextLong ( ) , C = s . nextLong ( ) ; if ( A == 0 && B == 0 ) { System . out . println ( C == 0 ? - 1 : 0 ) ; } else if ( A == 0 ) { System . out . println ( 1 ) ; System . out . println ( 1.0 * - C / B ) ; } else { long discriminant = B * B - 4 * A * C ; if ( discriminant < 0 ) System . out . println ( 0 ) ; else if ( discriminant == 0 ) { System . out . println ( 1 ) ; System . out . println ( 1.0 * - B / ( 2.0 * A ) ) ; } else { System . out . println ( 2 ) ; double num1 = ( - B - Math . sqrt ( discriminant ) ) / ( 2.0 * A ) ; double num2 = ( - B + Math . sqrt ( discriminant ) ) / ( 2.0 * A ) ; if ( num1 < num2 ) { System . out . println ( num1 ) ; System . out . println ( num2 ) ; } else { System . out . println ( num2 ) ; System . out . println ( num1 ) ; } } } s . close ( ) ; } }
public class GFG { static double average ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return sum / n ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( average ( arr , n ) ) ; } }
import java . util . Arrays ; class Test { static String isKSortedArray ( int arr [ ] , int n , int k ) { int aux [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = arr [ i ] ; Arrays . sort ( aux ) ; for ( int i = 0 ; i < n ; i ++ ) { int j = Arrays . binarySearch ( aux , arr [ i ] ) ; if ( Math . abs ( i - j ) > k ) return " No " ; } return " Yes " ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 2 , 1 , 5 , 6 , 4 } ; int k = 2 ; System . out . println ( " Is ▁ it ▁ a ▁ k ▁ sorted ▁ array ? : ▁ " + isKSortedArray ( arr , arr . length , k ) ) ; } }
import java . io . * ; public class GFG { static int nCr ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static double resultOfAllSubsets ( int arr [ ] , int N ) { double result = 0.0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int N = arr . length ; System . out . println ( resultOfAllSubsets ( arr , N ) ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { public static long productPrimeFactors ( int n ) { long product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; } public static void main ( String [ ] args ) { int n = 44 ; System . out . println ( productPrimeFactors ( n ) ) ; } }
import java . util . * ; public class Codeforces { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int temp = 0 ; String s = in . next ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { temp ++ ; } } System . out . println ( temp ) ; in . close ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] nums = new int [ n ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { nums [ i ] = sc . nextInt ( ) ; if ( nums [ i ] < 0 ) { count ++ ; nums [ i ] = - nums [ i ] ; } } int i = 0 ; while ( count -- > 0 ) { nums [ i ] = - nums [ i ] ; i ++ ; } int flag = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( nums [ j ] < nums [ j - 1 ] ) { flag ++ ; } } if ( flag == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Comparator ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; Integer [ ] a = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = in . nextInt ( ) ; Arrays . sort ( a ) ; int num = n ; int num1 = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] <= a [ i - 1 ] + k ) num -= num1 ; else if ( a [ i ] . equals ( a [ i - 1 ] ) ) num1 ++ ; if ( ! a [ i ] . equals ( a [ i - 1 ] ) ) num1 = 1 ; } out . println ( num ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }
public class GFG { static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . println ( power ( x , y ) ) ; } }
public class GFG { static int charVal ( String s , int i ) { if ( s . charAt ( i ) == '0' ) { return 0 ; } else if ( s . charAt ( i ) == '1' ) { return 1 ; } else { return 2 ; } } static int countMinimalReplacements ( String s , int i , int prev , int dp [ ] [ ] , int n ) { if ( i == n ) { return 0 ; } if ( dp [ i ] [ prev ] != - 1 ) { return dp [ i ] [ prev ] ; } int val = charVal ( s , i ) ; int ans = Integer . MAX_VALUE ; if ( val == prev ) { val = 0 ; for ( int cur = 0 ; cur <= 2 ; cur ++ ) { if ( cur == prev ) { continue ; } val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) ; ans = Math . min ( ans , val ) ; } } else { ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) ; } return dp [ i ] [ val ] = ans ; } public static void main ( String [ ] args ) { String s = "201220211" ; int n = s . length ( ) ; int dp [ ] [ ] = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } int val = charVal ( s , 0 ) ; System . out . println ( countMinimalReplacements ( s , 1 , val , dp , n ) ) ; } }
import java . util . * ; public class GFG { static int xorRange ( int pre [ ] , int l , int r ) { int cntOnes = pre [ r ] ; if ( l - 1 >= 0 ) cntOnes -= pre [ l - 1 ] ; if ( cntOnes % 2 == 0 ) return 0 ; else return 1 ; } static void performQueries ( int queries [ ] [ ] , int q , int a [ ] , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + a [ i ] ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 } ; int n = a . length ; int queries [ ] [ ] = { { 0 , 3 } , { 0 , 2 } } ; int q = queries . length ; performQueries ( queries , q , a , n ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class ProblemC { public static void main ( String [ ] args ) throws Exception { try ( Scanner sc = new Scanner ( System . in ) ) { int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { solve ( sc , caseNum ) ; } } } static void solve ( Scanner sc , int caseNum ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; double U = sc . nextDouble ( ) ; double [ ] P = new double [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = sc . nextDouble ( ) ; } Arrays . sort ( P ) ; double eps = 1e-8 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { double add = P [ i + 1 ] - P [ i ] ; if ( add * ( i + 1 ) > U + eps ) { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += U / ( i + 1 ) ; } U = 0 ; break ; } else { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += add ; } U -= add * ( i + 1 ) ; } } if ( U > 0 ) { for ( int j = 0 ; j < N ; j ++ ) { P [ j ] += U / N ; } } double res = 1 ; for ( int j = 0 ; j < N ; j ++ ) { res *= P [ j ] ; } System . out . printf ( " Case ▁ # % d : ▁ % .8f \n " , caseNum , res ) ; } }
import java . io . * ; public class GFG { static void printArray ( int [ ] A , int n , int K ) { int minEle = Integer . MAX_VALUE , maxEle = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minEle = Math . min ( minEle , A [ i ] ) ; maxEle = Math . max ( maxEle , A [ i ] ) ; } if ( K != 0 ) { if ( K % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) A [ i ] = maxEle - A [ i ] ; } else { for ( int i = 0 ; i < n ; i ++ ) A [ i ] = A [ i ] - minEle ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 12 , 16 } ; int K = 4 ; int N = arr . length ; printArray ( arr , N , K ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class Main { Scanner sc = new Scanner ( System . in ) ; void run ( ) { boolean [ ] isPrime = new boolean [ 1121 ] ; Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1120 ; i ++ ) { if ( ! isPrime [ i ] ) continue ; for ( int j = i * 2 ; j <= 1120 ; j += i ) isPrime [ j ] = false ; } ArrayList < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= 1120 ; i ++ ) { if ( isPrime [ i ] ) l . add ( i ) ; } int [ ] [ ] dp = new int [ 15 ] [ 1121 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { for ( int j = 13 ; j >= 0 ; j -- ) { for ( int k = 0 ; k <= 1120 ; k ++ ) { if ( dp [ j ] [ k ] != 0 && k + l . get ( i ) <= 1120 ) { dp [ j + 1 ] [ k + l . get ( i ) ] += dp [ j ] [ k ] ; } } } } for ( ; ; ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( ( n | k ) == 0 ) return ; System . out . println ( dp [ k ] [ n ] ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }
public class GFG { static int MAX = 64 ; static int maxOR ( int L , int R ) { if ( L == R ) { return L ; } int ans = 0 ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { int p , lbit , rbit ; p = 1 << i ; lbit = ( L >> i ) & 1 ; rbit = ( R >> i ) & 1 ; if ( ( rbit == 1 ) && ( lbit == 0 ) ) { ans += ( p << 1 ) - 1 ; break ; } if ( rbit == 1 ) { ans += p ; } } return ans ; } public static void main ( String [ ] args ) { int L = 4 , R = 5 ; System . out . println ( maxOR ( L , R ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main p = new Main ( ) ; } public Main ( ) { Scanner sc = new Scanner ( System . in ) ; alphav = new boolean [ 11 ] ; while ( true ) { String s = sc . next ( ) ; if ( s . equals ( " # " ) ) break ; solve ( s ) ; } } public void solve ( String s ) { String [ ] fs = s . split ( " = " ) ; boolean res = true ; for ( int i = 0 ; i < ( 1 << 11 ) ; i ++ ) { for ( int j = 0 ; j < alphav . length ; j ++ ) alphav [ j ] = ( i & ( 1 << j ) ) > 0 ; cur = 0 ; f = fs [ 0 ] ; boolean r0 = fomula ( ) ; cur = 0 ; f = fs [ 1 ] ; boolean r1 = fomula ( ) ; if ( r0 != r1 ) { res = false ; break ; } } System . out . println ( res ? " YES " : " NO " ) ; } boolean [ ] alphav ; String f ; int cur = 0 ; private boolean fomula ( ) { boolean ret = false ; char nc = nextc ( ) ; if ( ' a ' <= nc && nc <= ' k ' ) return alphav [ nc - ' a ' ] ; switch ( nc ) { case ' T ' : ret = true ; break ; case ' F ' : ret = false ; break ; case ' - ' : ret = ! fomula ( ) ; break ; case ' ( ' : ret = fomula ( ) ; nc = nextc ( ) ; switch ( nc ) { case ' * ' : ret &= fomula ( ) ; break ; case ' + ' : ret |= fomula ( ) ; break ; case ' - ' : nextc ( ) ; ret = ! ( ! fomula ( ) && ret ) ; break ; } nextc ( ) ; break ; } return ret ; } private char nextc ( ) { char c = f . charAt ( cur ) ; cur ++ ; return c ; } }
import java . io . * ; import java . util . * ; public class GFG { static int findSplit ( int [ ] arr , int n ) { int i ; int preSum = 0 ; int ind1 = - 1 , ind2 = - 1 ; int S ; S = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) S += arr [ i ] ; if ( S % 3 != 0 ) return 0 ; int S1 = S / 3 ; int S2 = 2 * S1 ; for ( i = 0 ; i < n ; i ++ ) { preSum += arr [ i ] ; if ( preSum % S1 == 0 && ind1 == - 1 ) ind1 = i ; else if ( preSum % S2 == 0 ) { ind2 = i ; break ; } } if ( ind1 != - 1 && ind2 != - 1 ) { System . out . println ( " ( " + ind1 + " , ▁ " + ind2 + " ) " ) ; return 1 ; } return 0 ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 3 , 4 , 0 , 4 } ; int n = arr . length ; if ( findSplit ( arr , n ) == 0 ) System . out . println ( " - 1" ) ; } }
import java . util . Arrays ; public class GFG { static int NoofTriplets ( int N , int K ) { int [ ] cnt = new int [ K ] ; Arrays . fill ( cnt , 0 , cnt . length , 0 ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( ( K & 1 ) != 0 ) { return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; } else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } } public static void main ( String [ ] args ) { int N = 3 , K = 2 ; System . out . println ( NoofTriplets ( N , K ) ) ; } }
import java . io . * ; public class GFG { static void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { System . out . print ( ( ( 1 << x ) + ( 1 << y ) ) + " ▁ " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } } public static void main ( String [ ] args ) { int n = 4 ; printTwoSetBitNums ( n ) ; } }
import java . util . Arrays ; public class GFG { static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; } public static void main ( String [ ] args ) { int val [ ] = { 7 , 8 , 4 } , wt [ ] = { 3 , 8 , 6 } , W = 10 , n = 3 ; System . out . println ( KnapSack ( val , wt , n , W ) ) ; } }
import java . io . * ; public class GFG { static int twoEggDrop ( int k ) { return ( int ) Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; } public static void main ( String [ ] args ) { int k = 100 ; System . out . println ( twoEggDrop ( k ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; } public static void main ( String args [ ] ) { int n = 35 ; System . out . println ( nextPerfectSquare ( n ) ) ; } }
import java . util . Scanner ; import java . math . BigDecimal ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; System . out . print ( x / y + " ▁ " + x % y ) ; System . out . printf ( " ▁ % 5.8f \n " , ( double ) x / y ) ; } }
public class GFG { final static double eps = ( double ) 1e-6 ; static double getArea ( double base , double hypotenuse ) { double height = Math . sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; } static void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = Math . sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { System . out . print ( " Not ▁ possible " ) ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base = 0 ; while ( Math . abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) { high = base ; } else { low = base ; } } double height = Math . sqrt ( hsquare - base * base ) ; System . out . println ( Math . round ( base ) + " ▁ " + Math . round ( height ) ) ; } static public void main ( String [ ] args ) { int hypotenuse = 5 ; int area = 6 ; printRightAngleTriangle ( hypotenuse , area ) ; } }
public class GFG { static int n = 3 ; static int MAX = 30 ; static int dp [ ] [ ] [ ] = new int [ n ] [ n ] [ MAX ] ; static boolean v [ ] [ ] [ ] = new boolean [ n ] [ n ] [ MAX ] ; static int findCount ( int mat [ ] [ ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 || j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int m = 5 ; System . out . println ( findCount ( mat , n - 1 , n - 1 , m ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . solver ( ) ; } void solver ( ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long p = sc . nextLong ( ) ; if ( a == 0 && b == 0 && p == 0 ) break ; long [ ] dp = new long [ 111111 ] ; dp [ 0 ] = 1 ; long ans = 0 ; for ( long i = a ; i <= b ; i ++ ) { if ( i > a ) { dp [ ( int ) ( i - a ) ] += dp [ ( int ) ( i - a - 1 ) ] ; } ans += dp [ ( int ) ( i - a ) ] ; ans %= p ; for ( long j = i ; j <= b ; j *= 10 ) { long t = 1 ; while ( t <= j ) t *= 10 ; long l = Math . max ( i - a + 1 , j - a ) , r = Math . min ( b - a + 1 , t - a ) ; dp [ ( int ) l ] += dp [ ( int ) ( i - a ) ] ; dp [ ( int ) r ] -= dp [ ( int ) ( i - a ) ] ; dp [ ( int ) l ] %= p ; dp [ ( int ) r ] %= p ; } } System . out . println ( ans ) ; } } }
import java . io . * ; public class GFG { static void findNormal ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . println ( ( 0 - dif ) + " y ▁ = ▁ " + " x " + ( ( 0 - x ) + ( y * dif ) ) ) ; else if ( dif > 0 ) System . out . println ( dif + " y ▁ = ▁ " + " - x + " + ( x + dif * y ) ) ; else System . out . println ( " x ▁ = ▁ " + x ) ; } else System . out . println ( " Not ▁ possible " ) ; } public static void main ( String [ ] args ) { int A = 2 , x = 2 , y = 0 ; findNormal ( A , x , y ) ; ; } }
import java . io . * ; public class GFG { static void pattern ( ) { int i , j , k = 0 , spaces = 1 , n = 7 ; for ( i = n ; i >= 1 ; i -- ) { for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( i ) ; } if ( i != n ) { for ( k = 1 ; k <= spaces ; k ++ ) { System . out . print ( " ▁ " ) ; } spaces = spaces + 2 ; } for ( j = i ; j >= 1 ; j -- ) { if ( j != n ) System . out . print ( i ) ; } System . out . println ( ) ; } spaces = spaces - 4 ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( i ) ; } if ( i != n ) { for ( k = 1 ; k <= spaces ; k ++ ) { System . out . printf ( " ▁ " ) ; } spaces = spaces - 2 ; } for ( j = i ; j >= 1 ; j -- ) { if ( j != n ) System . out . print ( i ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { pattern ( ) ; } }
public class GFG { static long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } public static void main ( String args [ ] ) { long n = 7 ; System . out . println ( answer ( n ) ) ; } }
import java . util . * ; public class GFG { static void nPermute ( char [ ] str , int n ) { Arrays . sort ( str ) ; int i = 1 ; do { if ( i == n ) break ; i ++ ; } while ( next_permutation ( str ) ) ; System . out . println ( String . valueOf ( str ) ) ; } static boolean next_permutation ( char [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { char t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void main ( String [ ] args ) { String str = " GEEKSFORGEEKS " ; int n = 100 ; nPermute ( str . toCharArray ( ) , n ) ; } }
import java . util . Scanner ; public class Main { static Scanner scanner ; public static void main ( String [ ] args ) { scanner = new Scanner ( System . in ) ; int H = gi ( ) ; int W = gi ( ) ; int k = 0 ; for ( int i = 0 ; i < H ; i ++ ) { String s = gs ( ) ; for ( int j = 0 ; j < W ; j ++ ) { char c = s . charAt ( j ) ; if ( c == ' # ' ) k ++ ; } } if ( k == H + W - 1 ) { System . out . println ( " Possible " ) ; } else { System . out . println ( " Impossible " ) ; } } public static String gs ( ) { return scanner . next ( ) ; } public static int gi ( ) { return Integer . parseInt ( scanner . next ( ) ) ; } public static long gl ( ) { return Long . parseLong ( scanner . next ( ) ) ; } public static double gd ( ) { return Double . parseDouble ( scanner . next ( ) ) ; } }
public final class p116 { public static void main ( String [ ] args ) { System . out . println ( new p116 ( ) . run ( ) ) ; } private static final int LENGTH = 50 ; public String run ( ) { return Long . toString ( countWays ( LENGTH , 2 ) + countWays ( LENGTH , 3 ) + countWays ( LENGTH , 4 ) ) ; } private static long countWays ( int length , int m ) { long [ ] ways = new long [ length + 1 ] ; ways [ 0 ] = 1 ; for ( int n = 1 ; n <= length ; n ++ ) { ways [ n ] += ways [ n - 1 ] ; if ( n >= m ) ways [ n ] += ways [ n - m ] ; } return ways [ length ] - 1 ; } }
import java . util . * ; public class GFG { static boolean check ( int arr [ ] , int n ) { int k = Integer . MIN_VALUE ; int r = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { k = Math . max ( k , arr [ i ] ) ; r = Math . min ( r , arr [ i ] ) ; } k += 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = k - arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) - 1 < n && arr [ Math . abs ( arr [ i ] ) - 1 ] > 0 ) { arr [ Math . abs ( arr [ i ] ) - 1 ] = - arr [ Math . abs ( arr [ i ] ) - 1 ] ; } } int flag = 0 ; for ( int i = 0 ; i <= k - r - 1 ; i ++ ) { if ( arr [ i ] > 0 ) { flag = 1 ; break ; } } return flag == 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( check ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } static void sieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static boolean leftTruPrime ( int n ) { int temp = n , cnt = 0 , temp1 ; while ( temp != 0 ) { cnt ++ ; temp1 = temp % 10 ; if ( temp1 == 0 ) return false ; temp = temp / 10 ; } boolean isPrime [ ] = new boolean [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; for ( int i = cnt ; i > 0 ; i -- ) { int mod = power ( 10 , i ) ; if ( ! isPrime [ n % mod ] ) return false ; } return true ; } public static void main ( String args [ ] ) { int n = 113 ; if ( leftTruPrime ( n ) ) System . out . println ( n + " ▁ is ▁ left ▁ truncatable ▁ prime " ) ; else System . out . println ( n + " ▁ is ▁ not ▁ left ▁ truncatable ▁ prime " ) ; } }
public class GFG { static int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '1' ) ans ++ ; if ( i % 2 == 1 && s . charAt ( i ) == '0' ) ans ++ ; } return Math . min ( ans , len - ans ) ; } public static void main ( String args [ ] ) { String s = "1100" ; int len = s . length ( ) ; System . out . println ( minReplacement ( s , len ) ) ; } }
import java . util . * ; public class GFG { static void right_left ( int a [ ] , int n ) { Map < Integer , Integer > total = new HashMap < > ( ) ; Map < Integer , Integer > left = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) total . put ( a [ i ] , total . get ( a [ i ] ) == null ? 1 : total . get ( a [ i ] ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ( total . get ( a [ i ] ) - 1 - ( 2 * ( left . containsKey ( a [ i ] ) == true ? left . get ( a [ i ] ) : 0 ) ) ) + " ▁ " ) ; left . put ( a [ i ] , left . get ( a [ i ] ) == null ? 1 : left . get ( a [ i ] ) + 1 ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 2 , 1 } ; int n = a . length ; right_left ( a , n ) ; } }
import java . util . Scanner ; public class Main { public Main ( ) { } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } private Scanner sc ; private void solve ( ) { sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } boolean flag = true ; int cnt = 0 ; int i = 0 ; while ( flag ) { flag = false ; for ( int j = N - 1 ; j >= i + 1 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { int tmp = A [ j - 1 ] ; A [ j - 1 ] = A [ j ] ; A [ j ] = tmp ; flag = true ; cnt ++ ; } } i ++ ; } String ans = " " ; for ( int num : A ) { ans += num ; ans += " ▁ " ; } System . out . println ( ans . trim ( ) ) ; System . out . println ( cnt ) ; } }
import java . util . * ; class solution { static int countPattern ( int n , String pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat . charAt ( i ) - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; } public static void main ( String args [ ] ) { int n = 500 ; String pat = "10" ; System . out . println ( countPattern ( n , pat ) ) ; } }
import java . util . Scanner ; public class test2 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] mCnt = new int [ m ] ; int totalCnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = sc . nextInt ( ) - 1 ; mCnt [ temp ] ++ ; if ( mCnt [ temp ] == 1 ) { totalCnt ++ ; } if ( totalCnt < m ) { System . out . print ( 0 ) ; } else { System . out . print ( 1 ) ; totalCnt = 0 ; for ( int j = 0 ; j < m ; j ++ ) { mCnt [ j ] -- ; if ( mCnt [ j ] >= 1 ) { totalCnt ++ ; } } } } } }
import java . io . * ; public class GFG { static int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . pow ( 4 , num ) ; num = ( int ) Math . floor ( num / 3.0 ) ; return num ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( findNumber ( n ) ) ; } }
public class GFG { static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; } public static void main ( String [ ] args ) { System . out . println ( multiply ( 5 , - 11 ) ) ; } }
import java . util . * ; public class GFG { static int sz = ( int ) 1e3 ; static HashSet < Integer > fib = new HashSet < Integer > ( ) ; static void fibonacci ( ) { int prev = 0 , curr = 1 , len = 2 ; fib . add ( prev ) ; fib . add ( curr ) ; while ( len <= sz ) { int temp = curr + prev ; fib . add ( temp ) ; prev = curr ; curr = temp ; len ++ ; } } static void printArray ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } static void removeFibonacci ( int arr [ ] , int len ) { fibonacci ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( fib . contains ( arr [ i ] ) ) { for ( int j = i ; j < len - 1 ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 } ; int len = arr . length ; removeFibonacci ( arr , len ) ; } }
public class GFG { static int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( minAbsDiff ( n ) ) ; } }
import java . util . Arrays ; public class GFG { static void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { arr = swap ( arr , i , j ) ; i += 2 ; j -= 2 ; } Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ; Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ; int low = ( n + 1 ) / 2 , high = n - 1 ; while ( low < high ) { Integer temp = arr [ low ] ; arr [ low ] = arr [ high ] ; arr [ high ] = temp ; low ++ ; high -- ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; bitonicGenerator ( arr , n ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
public class GFG { static final int n = 5 ; static void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String arg [ ] ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } } ; int k = 3 ; printSumSimple ( mat , k ) ; } }
import java . util . * ; import java . io . * ; import java . math . BigDecimal ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a + b - 1 ) ; int i = 1 ; while ( i <= b ) { System . out . println ( "1 ▁ " + i ) ; i ++ ; } i = 2 ; while ( i <= a ) { System . out . println ( i + " ▁ 1" ) ; i ++ ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int a ; int i ; char [ ] ch ; int x ; String [ ] c = { "0" , "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" , " A " , " B " , " C " , " D " , " E " , " F " , } ; String s = " " ; if ( n == 0 ) { System . out . println ( 1 ) ; } else { while ( n != 0 ) { a = n % 16 ; s = c [ a ] + s ; n = n / 16 ; } ch = s . toCharArray ( ) ; x = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ch [ i ] == '0' || ch [ i ] == '4' || ch [ i ] == '6' || ch [ i ] == '9' || ch [ i ] == ' A ' || ch [ i ] == ' D ' ) { x ++ ; } else if ( ch [ i ] == '8' || ch [ i ] == ' B ' ) { x += 2 ; } } System . out . println ( x ) ; } } }
import java . util . Arrays ; public class GFG { static int numOfWhiteHats ( int arr [ ] , int n ) { int freq [ ] = new int [ n + 1 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= n ) return - 1 ; freq [ arr [ i ] ] ++ ; } int diffFreq = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( freq [ i ] > 0 ) diffFreq ++ ; if ( diffFreq == 1 && freq [ n - 1 ] == n ) return n ; if ( diffFreq == 1 && freq [ 0 ] == n ) return 0 ; if ( diffFreq != 2 ) return - 1 ; int k ; for ( k = n - 1 ; k >= 1 ; k -- ) if ( freq [ k ] > 0 ) break ; if ( freq [ k - 1 ] == k && freq [ k ] + k == n ) return freq [ k - 1 ] ; else return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 , 3 , 3 } ; int n = arr . length ; System . out . println ( numOfWhiteHats ( arr , n ) ) ; } }
public class GFG { static boolean canBeBalanced ( String s , int n ) { int count = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) count ++ ; else count -- ; count_1 = Math . min ( count_1 , count ) ; } if ( count_1 >= - 1 && count == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { String s = " ( ) ) ( ) ( " ; int n = s . length ( ) ; if ( canBeBalanced ( s , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; int arr [ ] [ ] = new int [ ( int ) ( 2 * ( 1e5 ) + 1 ) ] [ 31 ] ; int ans = Integer . bitCount ( ( int ) 1e9 ) ; int x = 1 ; int presum [ ] = new int [ ( int ) ( 2 * 1e5 ) + 1 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr [ i ] . length ; j ++ ) { if ( ( i & 1 << j ) == 0 ) arr [ i ] [ j ] = 1 ; else arr [ i ] [ j ] = 0 ; arr [ i ] [ j ] += arr [ i - 1 ] [ j ] ; } } while ( t -- > 0 ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int l = Integer . parseInt ( st . nextToken ( ) ) ; int r = Integer . parseInt ( st . nextToken ( ) ) ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < 31 ; i ++ ) { min = Math . min ( min , arr [ r ] [ i ] - arr [ l - 1 ] [ i ] ) ; } System . out . println ( min ) ; } } }
import java . util . * ; public class GFG { static String minInt ( String str ) { String s = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '5' ) { s += ( char ) ( ( '9' - str . charAt ( i ) ) + '0' ) ; } else { s += str . charAt ( i ) ; } } if ( str . charAt ( 0 ) == '0' ) s += '9' ; return s ; } public static void main ( String [ ] args ) { String str = "589" ; System . out . println ( minInt ( str ) ) ; } }
import java . io . * ; public class GFG { static int MAX = 100001 ; static int prefix [ ] = new int [ MAX ] ; static void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; } static int sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } public static void main ( String [ ] args ) { sieve_modified ( ) ; int l = 6 , r = 10 ; System . out . println ( sumOddFactors ( l , r ) ) ; } }
import java . util . Scanner ; public class test170 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { if ( in . nextInt ( ) % 4 == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } in . close ( ) ; } }
import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { waterLily1199B ( ) ; } public static void waterLily1199B ( ) { Scanner scan = new Scanner ( System . in ) ; long h = scan . nextLong ( ) ; long l = scan . nextLong ( ) ; double l2 = l * l ; double h2 = h * h ; double twoh = 2 * h ; System . out . println ( ( l2 - h2 ) / ( twoh ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; } public static void main ( String [ ] args ) { System . out . println ( findDigits ( 1 ) ) ; System . out . println ( findDigits ( 5 ) ) ; System . out . println ( findDigits ( 10 ) ) ; System . out . println ( findDigits ( 120 ) ) ; } }
import java . util . * ; class Solution { static float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . sqrt ( 3 ) ; return a ; } public static void main ( String args [ ] ) { float r = 5 ; System . out . println ( String . format ( " % . 6 f " , largestCube ( r ) ) ) ; } }
public class GFG { static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; } public static void main ( String [ ] args ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . HashSet ; import java . util . Set ; import static java . lang . Integer . parseInt ; public class Main { static final long B = 37 ; static final long Binv = 1495681951922396077L ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; line = br . readLine ( ) ; int n , m ; n = parseInt ( line . substring ( 0 , line . indexOf ( ' ▁ ' ) ) ) ; m = parseInt ( line . substring ( line . indexOf ( ' ▁ ' ) + 1 ) ) ; char [ ] s = br . readLine ( ) . toCharArray ( ) ; int l = 0 , r = 0 ; long hash = s [ 0 ] ; Set < Long > hashs = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { switch ( br . readLine ( ) ) { case " L + + " : hash -= s [ l ] * power ( B , r - l ) ; l ++ ; break ; case " L - - " : l -- ; hash += s [ l ] * power ( B , r - l ) ; break ; case " R + + " : r ++ ; hash = hash * B + s [ r ] ; break ; case " R - - " : hash = ( hash - s [ r ] ) * Binv ; r -- ; break ; } hashs . add ( hash ) ; } System . out . println ( hashs . size ( ) ) ; } static long power ( long m , long n ) { if ( n == 0 ) return 1 ; if ( n % 2 == 0 ) { return power ( m * m , n / 2 ) ; } else { return power ( m * m , n / 2 ) * m ; } } }
import java . io . * ; import java . util . * ; class Node { int data ; Node left , right ; Node ( int key ) { data = key ; left = right = null ; } } public class GFG { static int maxOfRightElement ( Node root ) { int res = Integer . MIN_VALUE ; if ( root == null ) return - 1 ; if ( root . right != null ) res = root . right . data ; return Math . max ( maxOfRightElement ( root . right ) , Math . max ( res , maxOfRightElement ( root . left ) ) ) ; } public static void main ( String args [ ] ) { Node root = new Node ( 7 ) ; root . left = new Node ( 6 ) ; root . right = new Node ( 5 ) ; root . left . left = new Node ( 4 ) ; root . left . right = new Node ( 3 ) ; root . right . left = new Node ( 2 ) ; root . right . right = new Node ( 1 ) ; System . out . println ( maxOfRightElement ( root ) ) ; } }
public class GFG { static void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( brr [ i ] + " ▁ " ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 12 , 9 , 10 , 2 , 13 , 14 } ; int n = arr . length ; removeElements ( arr , n ) ; } }
import java . util . * ; public class GFG { static class Node { int elementID ; int stepsToeliminate ; public Node ( int elementID , int stepsToeliminate ) { super ( ) ; this . elementID = elementID ; this . stepsToeliminate = stepsToeliminate ; } } ; static void minSteps ( int arr [ ] , int N ) { Stack < Node > s = new Stack < Node > ( ) ; s . add ( new Node ( 0 , - 1 ) ) ; int maxStepsToeliminate = - 1 ; for ( int i = 1 ; i < N ; i ++ ) { int stepsToeliminate = 1 ; while ( ! s . isEmpty ( ) ) { if ( arr [ s . peek ( ) . elementID ] >= arr [ i ] ) { stepsToeliminate = Math . max ( stepsToeliminate , s . peek ( ) . stepsToeliminate + 1 ) ; s . pop ( ) ; } else { break ; } } if ( s . isEmpty ( ) ) { stepsToeliminate = - 1 ; } maxStepsToeliminate = Math . max ( maxStepsToeliminate , stepsToeliminate ) ; s . add ( new Node ( i , stepsToeliminate ) ) ; } System . out . print ( ( maxStepsToeliminate < 0 ? 0 : maxStepsToeliminate ) + " \n " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 , 7 , 5 } ; int size = arr . length ; minSteps ( arr , size ) ; } }
import java . util . * ; public class B499 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; ArrayList < String > arr = new ArrayList < String > ( ) ; String [ ] [ ] w = new String [ m ] [ 2 ] ; String s = " " ; for ( int k = 0 ; k < m ; k ++ ) { for ( int y = 0 ; y < 2 ; y ++ ) { w [ k ] [ y ] = sc . next ( ) ; } } for ( int i = 0 ; i < n ; i ++ ) { arr . add ( i , sc . next ( ) ) ; } for ( int k = 0 ; k < n ; k ++ ) { for ( int x = 0 ; x < m ; x ++ ) { if ( arr . get ( k ) . equals ( w [ x ] [ 0 ] ) ) { if ( w [ x ] [ 0 ] . length ( ) <= w [ x ] [ 1 ] . length ( ) ) { s = w [ x ] [ 0 ] ; arr . set ( k , s ) ; } else { s = w [ x ] [ 1 ] ; arr . set ( k , s ) ; } break ; } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr . get ( i ) + " ▁ " ) ; } } }
public class GFG { static boolean check ( int H , int S ) { return H * H >= 4 * S ; } static int findPairs ( int H [ ] , int n , int S [ ] , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( check ( H [ i ] , S [ j ] ) ) count ++ ; } } return count ; } public static void main ( String args [ ] ) { int H [ ] = { 1 , 6 , 4 } ; int n = H . length ; int S [ ] = { 23 , 3 , 42 , 14 } ; int m = S . length ; System . out . println ( findPairs ( H , n , S , m ) ) ; } }
import java . util . * ; public class GFG { static void Print3Smallest ( int array [ ] , int n ) { int firstmin = Integer . MAX_VALUE ; int secmin = Integer . MAX_VALUE ; int thirdmin = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] < firstmin ) { thirdmin = secmin ; secmin = firstmin ; firstmin = array [ i ] ; } else if ( array [ i ] < secmin ) { thirdmin = secmin ; secmin = array [ i ] ; } else if ( array [ i ] < thirdmin ) thirdmin = array [ i ] ; } System . out . println ( " First ▁ min ▁ = ▁ " + firstmin ) ; System . out . println ( " Second ▁ min ▁ = ▁ " + secmin ) ; System . out . println ( " Third ▁ min ▁ = ▁ " + thirdmin ) ; } public static void main ( String [ ] args ) { int array [ ] = { 4 , 9 , 1 , 32 , 12 } ; int n = array . length ; Print3Smallest ( array , n ) ; } }
import java . io . * ; import java . util . * ; import java . text . * ; import java . math . * ; import java . util . regex . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; char [ ] garlands = st . nextToken ( ) . toCharArray ( ) ; int [ ] counts = new int [ 4 ] ; char [ ] colors = new char [ 4 ] ; for ( int i = 0 ; i < garlands . length ; i ++ ) { char current = garlands [ i ] ; if ( current == ' ! ' ) { counts [ i % 4 ] ++ ; continue ; } colors [ i % 4 ] = current ; } for ( int i = 0 ; i < 4 ; i ++ ) { if ( ( int ) colors [ i ] != 0 ) continue ; colors [ i ] = ( char ) ( ( int ) colors [ 0 ] + ( int ) colors [ 1 ] + ( int ) colors [ 2 ] + ( int ) colors [ 3 ] ) ; break ; } char [ ] c = { ' R ' , ' B ' , ' Y ' , ' G ' } ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( colors [ j ] == c [ i ] ) { System . out . print ( counts [ j ] + " ▁ " ) ; break ; } } } } }
public class GFG { static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; } public static void main ( String arg [ ] ) { int day = dayofweek ( 30 , 8 , 2010 ) ; System . out . println ( day ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int powerNumbers ( int n ) { HashSet < Integer > v = new HashSet < Integer > ( ) ; v . add ( 1 ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i * i ; v . add ( j ) ; while ( j * i <= n ) { v . add ( j * i ) ; j = j * i ; } } return v . size ( ) ; } public static void main ( String args [ ] ) { System . out . println ( powerNumbers ( 50 ) ) ; } }
public class GFG { static boolean productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) { product *= n % 10 ; } n = n / 10 ; position ++ ; } if ( product % k == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 321922 ; int k = 3 ; if ( productDivisible ( n , k ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; public class GFG { static boolean isDivisibleBy10 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } static boolean isDivisibleBy20 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; return isDivisibleBy10 ( bin , n - 1 ) ; } public static void main ( String args [ ] ) { char bin [ ] = "101000" . toCharArray ( ) ; int n = bin . length ; if ( isDivisibleBy20 ( bin , n - 1 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; public class GFG { static void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x || half == x - 1 ) && ( half == y || half == y - 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int n = 100 ; int x = 51 , y = 100 ; halfsquare ( n , x , y ) ; } }
import java . io . * ; public class GFG { static int gcd ( int a , int b ) { int c ; while ( a != 0 ) { c = a ; a = b % a ; b = c ; } return b ; } static void forbenius ( int X , int Y ) { if ( gcd ( X , Y ) != 1 ) { System . out . println ( " NA " ) ; return ; } int A = ( X * Y ) - ( X + Y ) ; int N = ( X - 1 ) * ( Y - 1 ) / 2 ; System . out . println ( " Largest ▁ Amount ▁ = ▁ " + A ) ; System . out . println ( " Total ▁ Count ▁ = ▁ " + N ) ; } public static void main ( String [ ] args ) { int X = 2 , Y = 5 ; forbenius ( X , Y ) ; X = 5 ; Y = 10 ; System . out . println ( ) ; forbenius ( X , Y ) ; } }
import java . util . * ; public class GFG { static void reverse ( int a [ ] ) { int i , k , n = a . length ; int t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; Arrays . sort ( arr ) ; reverse ( arr ) ; System . out . println ( " Array ▁ after ▁ sorting ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; ++ i ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . io . * ; import static java . lang . Math . pow ; public class A { static void bestApproximate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; System . out . println ( " m ▁ = ▁ " + m ) ; System . out . println ( " c ▁ = ▁ " + c ) ; } public static void main ( String args [ ] ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; bestApproximate ( x , y ) ; } }
import java . util . * ; public class GFG { static class Node { int data ; Node next ; } ; static Node head ; static void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; ( head_ref ) = new_node ; head = head_ref ; } static int productOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; Stack < Integer > st = new Stack < Integer > ( ) ; int prod = 1 ; while ( head != null ) { st . push ( head . data ) ; head = head . next ; } while ( n -- > 0 ) { prod *= st . peek ( ) ; st . pop ( ) ; } return prod ; } public static void main ( String [ ] args ) { head = null ; push ( head , 12 ) ; push ( head , 4 ) ; push ( head , 8 ) ; push ( head , 6 ) ; push ( head , 10 ) ; int n = 2 ; System . out . println ( productOfLastN_NodesUtil ( head , n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class GFG { static int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } static int check ( int num ) { if ( num == 1 || num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; } public static void main ( String [ ] args ) { int num = 10 ; System . out . println ( check ( num ) ) ; } }
import java . util . * ; public class GFG { static int findMaxDiff ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( " Invalid ▁ " ) ; return 0 ; } int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) res = ( arr [ i ] - arr [ j ] - i + j ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 15 , 4 , 12 , 13 } ; int n = arr . length ; System . out . println ( findMaxDiff ( arr , n ) ) ; } }
import java . util . Scanner ; public class GFG { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a , b , i , j , flag ; System . out . printf ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) ; a = sc . nextInt ( ) ; System . out . printf ( " \n Enter ▁ upper ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) ; b = sc . nextInt ( ) ; System . out . printf ( " \n Prime ▁ numbers ▁ between ▁ % d ▁ and ▁ % d ▁ are : ▁ " , a , b ) ; if ( a == 1 ) { System . out . println ( a ) ; a ++ ; if ( b >= 2 ) { System . out . println ( a ) ; a ++ ; } } if ( a == 2 ) System . out . println ( a ) ; if ( a % 2 == 0 ) a ++ ; for ( i = a ; i <= b ; i = i + 2 ) { flag = 1 ; for ( j = 2 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . println ( i ) ; } } }
import java . util . Scanner ; public class GFG { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a , b , i , j , flag ; System . out . printf ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) ; a = sc . nextInt ( ) ; System . out . printf ( " \n Enter ▁ upper ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) ; b = sc . nextInt ( ) ; System . out . printf ( " \n Prime ▁ numbers ▁ between ▁ % d ▁ and ▁ % d ▁ are : ▁ " , a , b ) ; for ( i = a ; i <= b ; i ++ ) { if ( i == 1 || i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . println ( i ) ; } } }
public class GFG { final static int MAX = 100 ; static void smallestInRow ( int mat [ ] [ ] , int n , int m ) { System . out . print ( " { ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { int minm = mat [ i ] [ 0 ] ; for ( int j = 1 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] < minm ) { minm = mat [ i ] [ j ] ; } } System . out . print ( minm + " , ▁ " ) ; } System . out . println ( " } " ) ; } static void smallestInCol ( int mat [ ] [ ] , int n , int m ) { System . out . print ( " { ▁ " ) ; for ( int i = 0 ; i < m ; i ++ ) { int minm = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ j ] [ i ] < minm ) { minm = mat [ j ] [ i ] ; } } System . out . print ( minm + " , ▁ " ) ; } System . out . println ( " } " ) ; } public static void main ( String args [ ] ) { int n = 3 , m = 3 ; int mat [ ] [ ] = { { 2 , 1 , 7 } , { 3 , 7 , 2 } , { 5 , 4 , 9 } } ; System . out . print ( " Minimum ▁ element ▁ of ▁ each ▁ row ▁ is ▁ " ) ; smallestInRow ( mat , n , m ) ; System . out . print ( " Minimum ▁ element ▁ of ▁ each ▁ column ▁ is ▁ " ) ; smallestInCol ( mat , n , m ) ; } }
public class GFG { static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 || mod == 3 ) { return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; while ( true ) { int n = stdIn . nextInt ( ) ; int k = stdIn . nextInt ( ) ; int s = stdIn . nextInt ( ) ; if ( n == 0 && k == 0 && s == 0 ) break ; int ans = solve ( n , k , s ) ; System . out . println ( ans ) ; } } public static int solve ( int n , int k , int s ) { int ret = 0 ; for ( int i = n ; i > 0 ; i -- ) { ret += solv ( n , k - 1 , s - i , i ) ; } return ret ; } public static int solv ( int n , int k , int s , int l ) { if ( s < 0 ) return 0 ; if ( s == 0 && k == 0 ) return 1 ; if ( s == 0 && k > 0 ) return 0 ; if ( s != 0 && k < 0 ) return 0 ; int ret = 0 ; for ( int i = l - 1 ; i > 0 ; i -- ) { ret += solv ( n , k - 1 , s - i , i ) ; } return ret ; } }
import java . io . * ; public class GFG { public static int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; } public static void main ( String args [ ] ) { System . out . println ( countP ( 3 , 2 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char arr [ ] [ ] = new char [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { String str = sc . nextLine ( ) ; arr [ i ] [ 0 ] = str . charAt ( 0 ) ; arr [ i ] [ 1 ] = str . charAt ( 1 ) ; arr [ i ] [ 2 ] = str . charAt ( 2 ) ; } int flag = 0 ; if ( arr [ 0 ] [ 0 ] == arr [ 2 ] [ 2 ] && arr [ 0 ] [ 2 ] == arr [ 2 ] [ 0 ] && arr [ 1 ] [ 0 ] == arr [ 1 ] [ 2 ] && arr [ 0 ] [ 1 ] == arr [ 2 ] [ 1 ] ) { flag = 1 ; } if ( flag == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } sc . close ( ) ; } }
import java . util . * ; public class GFG { static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { String N = "2202200" ; System . out . println ( calculate ( N ) ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int N = Integer . parseInt ( s . next ( ) ) ; int Q = Integer . parseInt ( s . next ( ) ) ; int [ ] ar = new int [ N ] ; TreeSet < Integer > set = new TreeSet < Integer > ( ) ; int max_val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int c = Integer . parseInt ( s . next ( ) ) ; ar [ i ] = c ; set . add ( c ) ; max_val = Math . max ( max_val , c ) ; } for ( int i = 0 ; i < Q ; i ++ ) { int q = Integer . parseInt ( s . next ( ) ) ; int ans = 0 ; if ( q < 100 ) { for ( int j = 0 ; j < N ; j ++ ) { ans = Math . max ( ans , ar [ j ] % q ) ; } } else { for ( int j = q ; j <= max_val ; j += q ) { Integer v = set . lower ( j ) ; if ( v == null ) continue ; ans = Math . max ( ans , ( int ) ( v ) % q ) ; } } System . out . println ( ans ) ; } } }
import java . util . * ; public class GFG { static class pair { int first , second ; pair ( ) { first = 0 ; second = 0 ; } } static void printIndices ( int n , pair a [ ] ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] . second + " ▁ " ) ; System . out . println ( ) ; } static class sort implements Comparator < pair > { public int compare ( pair a , pair b ) { return a . first < b . first ? - 1 : 1 ; } } static void printPermutations ( int n , int a [ ] , int k ) { pair arr [ ] = new pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = new pair ( ) ; arr [ i ] . first = a [ i ] ; arr [ i ] . second = i ; } Arrays . sort ( arr , new sort ( ) ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . first == arr [ i - 1 ] . first ) count ++ ; if ( count < k ) { System . out . print ( " - 1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) { printIndices ( n , arr ) ; for ( int j = 1 ; j < n ; j ++ ) { if ( arr [ j ] . first == arr [ j - 1 ] . first ) { pair t = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = t ; break ; } } } printIndices ( n , arr ) ; } public static void main ( String arsg [ ] ) { int a [ ] = { 1 , 3 , 3 , 1 } ; int n = a . length ; int k = 3 ; printPermutations ( n , a , k ) ; } }
public class GFG { static int countNumbers ( int n ) { int c = 0 ; int limit = ( int ) Math . sqrt ( n ) ; int prime [ ] = new int [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; } public static void main ( String [ ] args ) { int n = 1000 ; System . out . println ( countNumbers ( n ) ) ; } }
import java . util . Scanner ; public class Solution { public static int solve ( int n , int m , int k ) { int t = n / k ; if ( m <= t ) return m ; m = m - t ; if ( m % ( k - 1 ) == 0 ) m = m / ( k - 1 ) ; else m = m / ( k - 1 ) + 1 ; return t - m ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; System . out . println ( solve ( n , m , k ) ) ; } } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) , Q = sc . nextInt ( ) ; int A [ ] = new int [ Q ] , B [ ] = new int [ N ] ; for ( int i = 0 ; i < Q ; i ++ ) A [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = sc . nextInt ( ) ; if ( A [ i ] == r ) B [ j ] ++ ; else B [ A [ i ] - 1 ] ++ ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . println ( B [ i ] ) ; } }
public class GFG { static String smallestPoss ( String s , int n ) { String ans = " " ; int arr [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + String . valueOf ( i ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 15 ; String K = "325343273113434" ; System . out . println ( smallestPoss ( K , N ) ) ; } }
import java . util . * ; public class Assignment2 { static Long n ; static Set < Long > s ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextLong ( ) ; s = new HashSet < > ( ) ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) find ( i , j , 0L ) ; System . out . println ( s . size ( ) - 1 ) ; } public static void find ( int x , int y , Long c ) { s . add ( c ) ; Long xx = x + 10 * c ; Long yy = y + 10 * c ; if ( xx <= n && xx != 0 ) find ( x , y , xx ) ; if ( yy <= n && yy != 0 ) find ( x , y , yy ) ; return ; } }
import java . util . Scanner ; public class MrKitayutasGift { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String s = scan . nextLine ( ) ; char [ ] letter = new char [ 26 ] ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) letter [ c - ' a ' ] = c ; for ( int i = 0 ; i <= s . length ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { String curr = s . substring ( 0 , i ) + letter [ j ] + s . substring ( i , s . length ( ) ) ; if ( check ( curr ) ) { System . out . println ( curr ) ; return ; } } } System . out . println ( " NA " ) ; } static boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) return false ; return true ; } }
public final class p123 { public static void main ( String [ ] args ) { System . out . println ( new p123 ( ) . run ( ) ) ; } private static final int PRIME_LIMIT = 1000000 ; private static final long THRESHOLD = 10000000000L ; public String run ( ) { int [ ] primes = Library . listPrimes ( PRIME_LIMIT ) ; for ( int n = 5 ; n <= primes . length ; n += 2 ) { long rem = ( long ) n * primes [ n - 1 ] * 2 ; if ( rem > THRESHOLD ) return Integer . toString ( n ) ; } throw new AssertionError ( " Not ▁ found " ) ; } }
import java . io . * ; import java . util . StringTokenizer ; import static java . lang . Double . parseDouble ; import static java . lang . Integer . parseInt ; import static java . lang . Long . parseLong ; public class Main { static BufferedWriter of = null ; static { try { of = new BufferedWriter ( new FileWriter ( new File ( " filee . txt " ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private static BufferedWriter ifile = null ; static { try { ifile = new BufferedWriter ( new FileWriter ( String . valueOf ( System . in ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private static final BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; private static final Fast in = new Fast ( ) ; public static void main ( String [ ] args ) throws IOException { String s = in . next ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' - ' ) c1 ++ ; else c2 ++ ; } if ( c2 == 0 ) System . out . println ( " YES " ) ; else if ( c1 % c2 == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static class Fast { BufferedReader br ; StringTokenizer st ; public Fast ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public Fast ( FileReader f ) { br = new BufferedReader ( f ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return parseDouble ( next ( ) ) ; } public float nextFloat ( ) throws IOException { return Float . parseFloat ( next ( ) ) ; } } }
import java . util . * ; public class Main { static public int n ; static int [ ] A = new int [ 50 ] ; static int [ ] B = new int [ 50 ] ; public Boolean fun ( Long bit ) { boolean [ ] [ ] arr = new boolean [ 51 ] [ 51 ] ; for ( int i = 0 ; i <= 50 ; i ++ ) { arr [ i ] [ i ] = true ; } for ( int i = 1 ; i <= 50 ; i ++ ) { if ( ( bit & ( 1L << i ) ) != 0 ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ j ] [ j % i ] = true ; } } } for ( int k = 0 ; k <= 50 ; k ++ ) { for ( int i = 0 ; i <= 50 ; i ++ ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ i ] [ j ] |= arr [ i ] [ k ] & arr [ k ] [ j ] ; } } } Boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! arr [ A [ i ] ] [ B [ i ] ] ) flag = false ; } return flag ; } public void solve ( ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = sc . nextInt ( ) ; } Long ans = ( 1L << 51 ) - 1 ; if ( ! fun ( ans ) ) { System . out . println ( - 1 ) ; return ; } for ( int i = 51 ; i >= 0 ; i -- ) { Long tmp = ans & ~ ( 1L << i ) ; if ( fun ( tmp ) ) ans = tmp ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } } ;
public class GFG { static final int INT_SIZE = 32 ; static class TrieNode { int value ; TrieNode [ ] arr = new TrieNode [ 2 ] ; public TrieNode ( ) { value = 0 ; arr [ 0 ] = null ; arr [ 1 ] = null ; } } static TrieNode root ; static void insert ( int pre_xor ) { TrieNode temp = root ; for ( int i = INT_SIZE - 1 ; i >= 0 ; i -- ) { int val = ( pre_xor & ( 1 << i ) ) >= 1 ? 1 : 0 ; if ( temp . arr [ val ] == null ) temp . arr [ val ] = new TrieNode ( ) ; temp = temp . arr [ val ] ; } temp . value = pre_xor ; } static int query ( int pre_xor ) { TrieNode temp = root ; for ( int i = INT_SIZE - 1 ; i >= 0 ; i -- ) { int val = ( pre_xor & ( 1 << i ) ) >= 1 ? 1 : 0 ; if ( temp . arr [ 1 - val ] != null ) temp = temp . arr [ 1 - val ] ; else if ( temp . arr [ val ] != null ) temp = temp . arr [ val ] ; } return pre_xor ^ ( temp . value ) ; } static int maxSubarrayXOR ( int arr [ ] , int n ) { root = new TrieNode ( ) ; insert ( 0 ) ; int result = Integer . MIN_VALUE ; int pre_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre_xor = pre_xor ^ arr [ i ] ; insert ( pre_xor ) ; result = Math . max ( result , query ( pre_xor ) ) ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 1 , 2 , 12 } ; int n = arr . length ; System . out . println ( " Max ▁ subarray ▁ XOR ▁ is ▁ " + maxSubarrayXOR ( arr , n ) ) ; } }
import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; ArrayList < Integer > arr = new ArrayList < > ( 100 ) ; Integer n = scanner . nextInt ( ) ; Integer one = 1 , lar = 1 ; for ( int i = 0 ; i < n ; i ++ ) { arr . add ( scanner . nextInt ( ) ) ; if ( arr . get ( i ) == 1 ) one = i ; if ( arr . get ( i ) == n ) lar = i ; } ArrayList < Integer > ans = new ArrayList < > ( 5 ) ; ans . add ( one ) ; ans . add ( n - one - 1 ) ; ans . add ( lar ) ; ans . add ( n - lar - 1 ) ; Integer Answer = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( Answer < ans . get ( i ) ) Answer = ans . get ( i ) ; } System . out . println ( Answer ) ; } }
import java . util . * ; public class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int sumSubarrayMins ( int A [ ] , int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; Stack < pair > s1 = new Stack < pair > ( ) ; Stack < pair > s2 = new Stack < pair > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int cnt = 1 ; while ( ! s1 . isEmpty ( ) && ( s1 . peek ( ) . first ) > A [ i ] ) { cnt += s1 . peek ( ) . second ; s1 . pop ( ) ; } s1 . push ( new pair ( A [ i ] , cnt ) ) ; left [ i ] = cnt ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { int cnt = 1 ; while ( ! s2 . isEmpty ( ) && ( s2 . peek ( ) . first ) >= A [ i ] ) { cnt += s2 . peek ( ) . second ; s2 . pop ( ) ; } s2 . push ( new pair ( A [ i ] , cnt ) ) ; right [ i ] = cnt ; } int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) result = ( result + A [ i ] * left [ i ] * right [ i ] ) ; return result ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 1 , 2 , 4 } ; int n = A . length ; System . out . println ( sumSubarrayMins ( A , n ) ) ; } }
import java . io . * ; class Numbers { static boolean isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d || digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return true ; } static void printGoodNumber ( int L , int R , int d ) { for ( int i = L ; i <= R ; i ++ ) { if ( isValid ( i , d ) ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int L = 410 , R = 520 , d = 3 ; printGoodNumber ( L , R , d ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; int count = 0 ; for ( int i = 1 ; i <= N ; i += 2 ) { int divisor = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( i % j == 0 ) { divisor ++ ; } } if ( divisor == 8 ) count ++ ; } System . out . println ( count ) ; } }
import static java . lang . Math . pow ; class Test { static void nthprimedigitsnumber ( long n ) { long len = 1 ; long prev_count = 0 ; while ( true ) { long curr_count = ( long ) ( prev_count + pow ( 4 , len ) ) ; if ( prev_count < n && curr_count >= n ) break ; len ++ ; prev_count = curr_count ; } for ( int i = 1 ; i <= len ; i ++ ) { for ( long j = 1 ; j <= 4 ; j ++ ) { if ( prev_count + pow ( 4 , len - i ) < n ) prev_count += pow ( 4 , len - i ) ; else { if ( j == 1 ) System . out . print ( "2" ) ; else if ( j == 2 ) System . out . print ( "3" ) ; else if ( j == 3 ) System . out . print ( "5" ) ; else if ( j == 4 ) System . out . print ( "7" ) ; break ; } } } System . out . println ( ) ; } public static void main ( String args [ ] ) { nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; } }
import java . util . * ; import java . io . * ; public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char [ ] string = in . next ( ) . toCharArray ( ) ; int left = 0 ; int right = 0 ; int min = Integer . MAX_VALUE ; Map < Character , Integer > unique = new HashMap < > ( ) ; while ( right < string . length ) { while ( right < string . length && unique . size ( ) < 3 ) { unique . merge ( string [ right ] , 1 , Integer :: sum ) ; right ++ ; } while ( left < right && unique . size ( ) == 3 ) { min = Math . min ( min , right - left ) ; unique . merge ( string [ left ] , - 1 , Integer :: sum ) ; if ( unique . get ( string [ left ] ) == 0 ) { unique . remove ( string [ left ] ) ; } left ++ ; } } System . out . println ( min == Integer . MAX_VALUE ? 0 : min ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class SeatingOnBus { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] str = br . readLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int m = Integer . parseInt ( str [ 1 ] ) ; int bus [ ] [ ] = new int [ n ] [ 4 ] ; int person = 1 ; int currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 0 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 3 ] = person ; person ++ ; } currentRow ++ ; } currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 1 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 2 ] = person ; person ++ ; } currentRow ++ ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( bus [ i ] [ 1 ] != 0 ) { sb . append ( bus [ i ] [ 1 ] ) ; sb . append ( " ▁ " ) ; } if ( bus [ i ] [ 0 ] != 0 ) { sb . append ( bus [ i ] [ 0 ] ) ; sb . append ( " ▁ " ) ; } if ( bus [ i ] [ 2 ] != 0 ) { sb . append ( bus [ i ] [ 2 ] ) ; sb . append ( " ▁ " ) ; } if ( bus [ i ] [ 3 ] != 0 ) { sb . append ( bus [ i ] [ 3 ] ) ; sb . append ( " ▁ " ) ; } } System . out . print ( sb . toString ( ) ) ; } }
public class GFG { static int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; } public static void main ( String [ ] args ) { int L = 1 , R = 632 ; System . out . println ( maxAND ( L , R ) ) ; } }
public class GFG { static int Minimum_Operations ( int [ ] a , int n ) { int [ ] np = new int [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . min ( ans , pos + np [ i + 1 ] ) ; } return ans ; } public static void main ( String args [ ] ) { int [ ] a = { - 1 , 0 , 1 , 2 } ; int n = a . length ; System . out . println ( Minimum_Operations ( a , n ) ) ; } }
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( A + i <= B ) { System . out . println ( A + i ) ; } } for ( int j = K - 1 ; j >= 0 ; j -- ) { if ( B - j > A + K - 1 ) { System . out . println ( B - j ) ; } } } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; FastReader in = new FastReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , FastReader in , PrintWriter out ) { int n = in . nextInt ( ) ; int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { mat [ i ] [ j ] = in . nextInt ( ) ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int col = 0 , raw = 0 ; for ( int k = 0 ; k < n ; k ++ ) { col += mat [ i ] [ k ] ; raw += mat [ k ] [ j ] ; } if ( col < raw ) res ++ ; } } out . println ( res ) ; } } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public FastReader ( InputStream is ) { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }
public class GFG { static String toNegativeBase ( int n , int negBase ) { if ( n == 0 ) return "0" ; String converted = " " ; while ( n != 0 ) { int remainder = n % negBase ; n /= negBase ; if ( remainder < 0 ) { remainder += ( - negBase ) ; n += 1 ; } converted = String . valueOf ( remainder ) + converted ; } return converted ; } public static void main ( String [ ] args ) { int n = 13 ; int negBase = - 2 ; System . out . println ( toNegativeBase ( n , negBase ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String line = sc . nextLine ( ) ; String [ ] s = line . split ( " ▁ " , 0 ) ; int n = s . length ; int num [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { num [ i ] = Integer . parseInt ( s [ i ] ) ; } Arrays . sort ( num ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += num [ i + 1 ] - num [ i ] ; } System . out . println ( ans ) ; } }
public class GFG { static int RSF ( int n ) { while ( n >= 10 ) { int x = n ; int l = 0 ; while ( n > 0 ) { n = n / 10 ; l ++ ; } int a [ ] = new int [ l ] ; int i = l - 1 ; while ( x > 0 ) { a [ i ] = x % 10 ; x = x / 10 ; i -- ; } for ( int j = 0 ; j < l - 1 ; j ++ ) { n = n * 10 + Math . abs ( a [ j ] - a [ j + 1 ] ) ; } } return n ; } public static void main ( String [ ] arg ) { int n = 6972 ; int ans = RSF ( n ) ; System . out . println ( ans ) ; } }
public class GFG { static class Node { int data ; Node next ; } ; static Node circular ( Node head ) { Node start = head ; while ( head . next != null ) head = head . next ; head . next = start ; return start ; } static Node push ( Node head , int data ) { Node newNode = new Node ( ) ; newNode . data = data ; newNode . next = ( head ) ; ( head ) = newNode ; return head ; } static void displayList ( Node node ) { Node start = node ; while ( node . next != start ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } System . out . print ( node . data + " ▁ " ) ; } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 15 ) ; head = push ( head , 14 ) ; head = push ( head , 13 ) ; head = push ( head , 22 ) ; head = push ( head , 17 ) ; circular ( head ) ; System . out . print ( " Display ▁ List : \n " ) ; displayList ( head ) ; } }
class Solution { public String licenseKeyFormatting ( String s , int k ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) != ' - ' ) sb . append ( sb . length ( ) % ( k + 1 ) == k ? ' - ' : " " ) . append ( s . charAt ( i ) ) ; return sb . reverse ( ) . toString ( ) . toUpperCase ( ) ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; String s = "5F3Z - 2e - 9 - w " ; int k = 4 ; String out = sObj . licenseKeyFormatting ( s , k ) ; System . out . println ( out ) ; } }
public class GFG { static double EPS = 1E-15 ; static double findMinValue ( double arr [ ] , double n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( double ) Math . log10 ( arr [ i ] ) + EPS ; double xl = ( double ) ( sum / n + EPS ) ; double res = Math . pow ( ( double ) 10.0 , ( double ) xl ) + EPS ; return ( double ) Math . ceil ( res + EPS ) ; } public static void main ( String [ ] args ) { double arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; double n = arr . length ; System . out . println ( findMinValue ( arr , n ) ) ; } }
import java . util . * ; public class GfG { static int digroot ( int n ) { int root = 0 ; while ( n > 0 || root > 9 ) { if ( n == 0 ) { n = root ; root = 0 ; } root += n % 10 ; n /= 10 ; } return root ; } public static void main ( String argc [ ] ) { int n = 65785412 ; System . out . println ( digroot ( n ) ) ; } }
import java . util . * ; import java . io . * ; public class Solution { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str [ ] = br . readLine ( ) . split ( " ▁ " ) ; int m = Integer . parseInt ( str [ 0 ] ) ; int n = Integer . parseInt ( str [ 1 ] ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; if ( check ( m , n , ans ) ) { System . out . println ( " YES " ) ; System . out . println ( ans . size ( ) ) ; for ( int i = ans . size ( ) - 1 ; i >= 0 ; i -- ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } else { System . out . println ( " NO " ) ; } } public static boolean check ( int m , int n , ArrayList < Integer > ans ) { if ( m == n ) { ans . add ( m ) ; return true ; } else if ( n < m ) return false ; if ( n % 10 == 1 ) { ans . add ( n ) ; n = n / 10 ; } else if ( n % 2 == 0 ) { ans . add ( n ) ; n = n / 2 ; } else return false ; return check ( m , n , ans ) ; } }
public class GFG { static int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 1 , 2 , 7 } , k = 10 ; int n = a . length ; System . out . println ( k_sum ( a , n , k ) ) ; } }
public class GFG { static char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str . charAt ( i ) - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } } public static void main ( String [ ] args ) { String str = " gfg " ; System . out . println ( getChar ( str ) ) ; } }
public class GFG { static int sumNth ( int A [ ] , int B [ ] , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int f [ ] = new int [ n ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int n = 3 ; int m = A . length ; System . out . println ( sumNth ( A , B , m , n ) ) ; } }
import java . util . * ; public class GFG { static void odd_even ( int arr [ ] , int n ) { Vector < Integer > odd_indexes = new Vector < Integer > ( ) ; Vector < Integer > even_indexes = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . add ( arr [ i ] ) ; else even_indexes . add ( arr [ i ] ) ; } Collections . sort ( odd_indexes ) ; Collections . sort ( even_indexes ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) System . out . print ( odd_indexes . get ( i ) + " ▁ " ) ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) System . out . print ( even_indexes . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 7 , 6 , 8 } ; int n = arr . length ; odd_even ( arr , n ) ; } }
import java . util . * ; class solution { static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + " ▁ " ) ; flag = true ; break ; } } if ( ! flag ) System . out . print ( "0" + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 } ; int n = arr . length ; int k = 3 ; printFirstNegativeInteger ( arr , n , k ) ; } }
class Prefix { static void fillPrefixSum ( int arr [ ] , int n , int prefixSum [ ] ) { prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 4 , 16 , 20 } ; int n = arr . length ; int prefixSum [ ] = new int [ n ] ; fillPrefixSum ( arr , n , prefixSum ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( prefixSum [ i ] + " ▁ " ) ; } }
import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String format = " % .6f ▁ % .6f % n " ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] input = line . split ( " , " ) ; double x1 = Double . parseDouble ( input [ 0 ] ) ; double y1 = Double . parseDouble ( input [ 1 ] ) ; double x2 = Double . parseDouble ( input [ 2 ] ) ; double y2 = Double . parseDouble ( input [ 3 ] ) ; double xq = Double . parseDouble ( input [ 4 ] ) ; double yq = Double . parseDouble ( input [ 5 ] ) ; if ( x1 == x2 ) { double x = ( x1 - xq ) + x1 ; System . out . printf ( format , x , yq ) ; } else if ( y1 == y2 ) { double y = ( y1 - yq ) + y1 ; System . out . printf ( format , xq , y ) ; } else { double alpha = ( y2 - y1 ) / ( x2 - x1 ) ; double x = ( ( 1 - alpha * alpha ) * xq + 2 * alpha * yq + 2 * alpha * alpha * x1 - 2 * alpha * y1 ) / ( alpha * alpha + 1 ) ; double y = ( xq - x ) / alpha + yq ; System . out . printf ( format , x , y ) ; } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class cobb { public static void main ( String [ ] args ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int tcase = Integer . parseInt ( f . readLine ( ) ) ; for ( int p = 0 ; p < tcase ; p ++ ) { StringTokenizer st1 = new StringTokenizer ( f . readLine ( ) ) ; int n = Integer . parseInt ( st1 . nextToken ( ) ) ; int k = Integer . parseInt ( st1 . nextToken ( ) ) ; long [ ] vals = new long [ n ] ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { vals [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } long ans = Long . MIN_VALUE ; int start = Math . max ( 0 , n - 201 ) ; for ( int i = start ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , ( ( long ) ( i + 1 ) * ( long ) ( j + 1 ) ) - k * ( vals [ i ] | vals [ j ] ) ) ; } } System . out . println ( ans ) ; } } }
import java . util . * ; import java . lang . * ; public class GFG { static int MAX_CHAR = 26 ; public static void commonCharacters ( String str [ ] , int n ) { Boolean [ ] prim = new Boolean [ MAX_CHAR ] ; Arrays . fill ( prim , new Boolean ( true ) ) ; for ( int i = 0 ; i < n ; i ++ ) { Boolean [ ] sec = new Boolean [ MAX_CHAR ] ; Arrays . fill ( sec , new Boolean ( false ) ) ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { if ( prim [ str [ i ] . charAt ( j ) - ' a ' ] ) sec [ str [ i ] . charAt ( j ) - ' a ' ] = true ; } System . arraycopy ( sec , 0 , prim , 0 , MAX_CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) { System . out . print ( Character . toChars ( i + 97 ) ) ; System . out . print ( " ▁ " ) ; } } public static void main ( String [ ] args ) { String str [ ] = { " geeksforgeeks " , " gemkstones " , " acknowledges " , " aguelikes " } ; int n = str . length ; commonCharacters ( str , n ) ; } }
import java . util . * ; class Solution { public List < Integer > findDisappearedNumbers ( int [ ] nums ) { List < Integer > ret = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { int val = Math . abs ( nums [ i ] ) - 1 ; if ( nums [ val ] > 0 ) { nums [ val ] = - nums [ val ] ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { ret . add ( i + 1 ) ; } } return ret ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 } ; List < Integer > out = sObj . findDisappearedNumbers ( nums ) ; System . out . println ( out ) ; } }
import java . io . * ; import java . util . * ; public class GFG { public static int findMaxValue ( ) { int res = 2 ; long fact = 2 ; while ( true ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } public static void main ( String [ ] args ) { System . out . println ( " Maximum ▁ value ▁ of ▁ integer : ▁ " + findMaxValue ( ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { static String [ ] a ; static String [ ] b ; static String temp ; public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; a = scanner . nextLine ( ) . split ( " ▁ " ) ; b = scanner . nextLine ( ) . split ( " ▁ " ) ; char [ ] c = { ' E ' , ' E ' , ' E ' , ' N ' , ' W ' , ' W ' , ' W ' , ' S ' } ; boolean flag = false ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( char d : c ) { roll ( d ) ; if ( Arrays . equals ( a , b ) ) { flag = true ; break ; } } } if ( flag ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void roll ( char c ) { switch ( c ) { case ' E ' : temp = a [ 0 ] ; a [ 0 ] = a [ 3 ] ; a [ 3 ] = a [ 5 ] ; a [ 5 ] = a [ 2 ] ; a [ 2 ] = temp ; break ; case ' N ' : temp = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = a [ 5 ] ; a [ 5 ] = a [ 4 ] ; a [ 4 ] = temp ; break ; case ' W ' : temp = a [ 0 ] ; a [ 0 ] = a [ 2 ] ; a [ 2 ] = a [ 5 ] ; a [ 5 ] = a [ 3 ] ; a [ 3 ] = temp ; break ; default : temp = a [ 0 ] ; a [ 0 ] = a [ 4 ] ; a [ 4 ] = a [ 5 ] ; a [ 5 ] = a [ 1 ] ; a [ 1 ] = temp ; break ; } } }
import java . util . * ; public class MainClass { public static int count ( String s , char value ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == value ) cnt ++ ; return cnt ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; HashSet < Integer > ss = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = sc . nextInt ( ) ; if ( ss . contains ( k ) ) { ss . add ( - k ) ; } else ss . add ( k ) ; } System . out . println ( ss . size ( ) ) ; } } }
import java . util . * ; public class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void primesieve ( boolean [ ] prime ) { prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 650 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 650 ; i += p ) prime [ i ] = false ; } } } static pair sum_sqsum ( int n ) { int sum = 0 ; int sqsum = 0 ; int x ; while ( n > 0 ) { x = n % 10 ; sum += x ; sqsum += x * x ; n /= 10 ; } return ( new pair ( sum , sqsum ) ) ; } static int countnumber ( int L , int R ) { boolean [ ] prime = new boolean [ 651 ] ; Arrays . fill ( prime , true ) ; primesieve ( prime ) ; int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { pair digit = sum_sqsum ( i ) ; if ( prime [ digit . first ] && prime [ digit . second ] ) { cnt += 1 ; } } return cnt ; } public static void main ( String [ ] args ) { int L = 10 ; int R = 20 ; System . out . println ( countnumber ( L , R ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static void printRepeating ( Integer [ ] arr , int size ) { SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ; System . out . print ( s ) ; } public static void main ( String args [ ] ) { Integer [ ] arr = { 1 , 3 , 2 , 2 , 1 } ; int n = arr . length ; printRepeating ( arr , n ) ; } }
import java . util . Arrays ; public final class p225 { public static void main ( String [ ] args ) { System . out . println ( new p225 ( ) . run ( ) ) ; } private static final int INDEX = 124 ; public String run ( ) { int count = 0 ; for ( int i = 1 ; ; i += 2 ) { if ( ! hasTribonacciMultiple ( i ) ) { count ++ ; if ( count == INDEX ) return Integer . toString ( i ) ; } } } private static boolean hasTribonacciMultiple ( int modulus ) { int [ ] slow = { 1 , 1 , 1 } ; int [ ] fast = slow . clone ( ) ; for ( boolean head = true ; ; head = false ) { if ( slow [ 0 ] % modulus == 0 ) return true ; if ( ! head && Arrays . equals ( slow , fast ) ) return false ; tribonacci ( slow , modulus ) ; tribonacci ( fast , modulus ) ; tribonacci ( fast , modulus ) ; } } private static void tribonacci ( int [ ] state , int mod ) { int a = state [ 0 ] ; int b = state [ 1 ] ; int c = state [ 2 ] ; state [ 0 ] = b ; state [ 1 ] = c ; state [ 2 ] = ( a + b + c ) % mod ; } }
import java . io . * ; public class GFG { static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( " No ▁ solution " ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ; } }
import java . util . Scanner ; public class HighSchool987B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long x = in . nextInt ( ) ; long y = in . nextInt ( ) ; long x_y = ( long ) Math . pow ( x , y ) ; long y_x = ( long ) Math . pow ( y , x ) ; if ( x_y > y_x ) { System . out . println ( ' > ' ) ; return ; } else if ( x_y < y_x ) { System . out . println ( ' < ' ) ; return ; } else if ( x == y || x_y == y_x && x_y < 999999999 ) { System . out . println ( ' = ' ) ; return ; } if ( x > y ) System . out . println ( ' < ' ) ; else System . out . println ( ' > ' ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; int N = parseInt ( br . readLine ( ) ) ; String S = br . readLine ( ) ; int ans = S . indexOf ( " xx " ) + 1 ; System . out . println ( ans > 0 ? ans : N ) ; } }
import java . io . PrintWriter ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int H = sc . nextInt ( ) ; int W = sc . nextInt ( ) ; boolean [ ] [ ] a = new boolean [ H ] [ W ] ; for ( int i = 0 ; i < H ; i ++ ) { String str = sc . next ( ) ; for ( int j = 0 ; j < W ; j ++ ) a [ i ] [ j ] = str . charAt ( j ) == ' # ' ; } for ( int i = 0 ; i < H ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { pw . print ( ( i == 0 || ( i < H - 1 && ( j % 2 == 0 || a [ i ] [ j ] ) ) ) ? ' # ' : ' . ' ) ; } pw . println ( ) ; } pw . println ( ) ; for ( int i = 0 ; i < H ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { pw . print ( ( i == H - 1 || ( i > 0 && ( j % 2 == 1 || a [ i ] [ j ] ) ) ) ? ' # ' : ' . ' ) ; } pw . println ( ) ; } sc . close ( ) ; pw . close ( ) ; } }
import java . io . * ; public class GFG { static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; } public static void main ( String args [ ] ) throws IOException { System . out . println ( unitDigitXRaisedY ( 4 , 2 ) ) ; } }
import java . util . Scanner ; public class FafaAndHisCompany { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int X = 0 ; for ( int l = 1 ; l <= N / 2 ; l ++ ) { if ( N % l == 0 ) { X ++ ; } } System . out . println ( X ) ; sc . close ( ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . StringTokenizer ; public class Pairs_of_toys { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; long n = sc . nextLong ( ) ; long k = sc . nextLong ( ) ; { System . out . print ( Math . max ( 0 , Math . min ( n , k - 1 ) - k / 2 ) ) ; } } }
import java . io . * ; public class GFG { static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( " Touch " ) ; else if ( radius > dist ) System . out . println ( " Intersect " ) ; else System . out . println ( " Outside " ) ; } public static void main ( String [ ] args ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Long n = sc . nextLong ( ) ; Long k = sc . nextLong ( ) ; if ( n == 1 ) { System . out . println ( 0 ) ; return ; } Long max = ( k * ( k - 1 ) ) / 2 ; if ( n > 1 + max ) { System . out . println ( - 1 ) ; return ; } else if ( n == 1 + max ) { System . out . println ( k - 1 ) ; return ; } Long l = 2L ; Long h = k ; Long ans = k + 1 ; boolean exact = false ; while ( l <= h ) { Long mid = l + ( h - l ) / 2 ; Long all = ( ( k - mid + 1 ) * ( mid + k ) ) / 2 ; all -= ( k - mid + 1 ) ; Long rem = n - ( all + 1 ) ; if ( rem < 0 ) { l = mid + 1 ; } else if ( rem < mid - 1 ) { ans = mid ; if ( rem == 0 ) { exact = true ; break ; } l = mid + 1 ; } else { h = mid - 1 ; } } int add = exact ? 0 : 1 ; System . out . println ( ( k - ans + 1 ) + add ) ; } }
import java . io . * ; public class GFG { static boolean DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ ] = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . run ( ) ; } int f [ ] = { - 1 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; public void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int dp [ ] = new int [ n + 1 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( i - f [ a [ j ] ] >= 0 && dp [ i - f [ a [ j ] ] ] >= 0 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - f [ a [ j ] ] ] + 1 ) ; } } } int keta = dp [ n ] ; int rem = n ; StringBuilder sb = new StringBuilder ( ) ; while ( rem > 0 ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( rem - f [ a [ i ] ] >= 0 && keta == dp [ rem - f [ a [ i ] ] ] + 1 ) { sb . append ( a [ i ] ) ; keta -- ; rem -= f [ a [ i ] ] ; break ; } } } System . out . println ( sb ) ; sc . close ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int Case = 1 ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; double a [ ] [ ] = new double [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] [ 0 ] = sc . nextDouble ( ) ; a [ i ] [ 1 ] = sc . nextDouble ( ) ; } double area = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) area += ( a [ i ] [ 0 ] * a [ i + 1 ] [ 1 ] - a [ i ] [ 1 ] * a [ i + 1 ] [ 0 ] ) / 2 ; area += ( a [ n - 1 ] [ 0 ] * a [ 0 ] [ 1 ] - a [ n - 1 ] [ 1 ] * a [ 0 ] [ 0 ] ) / 2 ; System . out . printf ( " % d ▁ % .1f \n " , Case ++ , - area ) ; } } }
import java . util . * ; import java . io . * ; public class A758 { static Scanner sc = new Scanner ( ) ; public static void main ( String [ ] args ) { solve ( ) ; } public static void solve ( ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int result = 0 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( max <= arr [ i ] ) max = arr [ i ] ; } for ( int j = 0 ; j < n ; j ++ ) { result += max - arr [ j ] ; } System . out . print ( result ) ; } static class Scanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int testcases = sc . nextInt ( ) ; int hour ; int minute ; for ( int i = 0 ; i < testcases ; i ++ ) { hour = sc . nextInt ( ) ; int hoursto = 24 - hour ; int minutes1 = hoursto * 60 ; minute = sc . nextInt ( ) ; int totaltimeto = minutes1 - minute ; System . out . println ( totaltimeto ) ; } } }
import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { final int n = sc . nextInt ( ) ; if ( n == 0 ) { break ; } for ( int i = 0 ; i < n ; i ++ ) { int pm = sc . nextInt ( ) , pe = sc . nextInt ( ) , pj = sc . nextInt ( ) ; if ( Math . max ( Math . max ( pm , pe ) , pj ) == 100 ) { System . out . println ( " A " ) ; } else if ( ( pm + pe ) / 2 >= 90 ) { System . out . println ( " A " ) ; } else if ( ( pm + pe + pj ) / 3 >= 80 ) { System . out . println ( " A " ) ; } else if ( ( pm + pe + pj ) / 3 >= 70 ) { System . out . println ( " B " ) ; } else if ( ( pm + pe + pj ) / 3 >= 50 && Math . max ( pm , pe ) >= 80 ) { System . out . println ( " B " ) ; } else { System . out . println ( " C " ) ; } } } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( arr [ n - k ] ) ; } catch ( Exception e ) { } } }
import java . util . Scanner ; public class Ex1 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int length = in . nextInt ( ) ; int balance = in . nextInt ( ) ; String s = in . next ( ) ; int val = 0 ; int min = 0 ; int max = 0 ; int counter = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( ( s . charAt ( i ) == '0' ) ) { val ++ ; } else { val -- ; } min = Math . min ( val , min ) ; max = Math . max ( val , max ) ; } if ( val == 0 && balance >= min && balance <= max ) { System . out . println ( " - 1" ) ; continue ; } else if ( val == 0 ) { System . out . println ( "0" ) ; continue ; } int totalVal = val ; val = 0 ; if ( balance == 0 ) { counter ++ ; } for ( int i = 0 ; i < length ; i ++ ) { if ( ( s . charAt ( i ) == '0' ) ) { val ++ ; } else { val -- ; } if ( ( balance - val ) % totalVal == 0 && ( balance - val ) / totalVal >= 0 ) { counter ++ ; } } System . out . println ( counter ) ; } } }
class Main { static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = arr . length ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) System . out . println ( " Index : ▁ " + i ) ; else System . out . println ( " Key ▁ not ▁ found " ) ; } }
import java . util . Arrays ; public class GFG { static void fillWithFreq ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; Arrays . fill ( temp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] += 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fillWithFreq ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; public class GFG { static void convert_To_Len_th_base ( int n , int arr [ ] , int len , int L ) { for ( int i = 0 ; i < L ; i ++ ) { System . out . print ( arr [ n % len ] ) ; n /= len ; } System . out . println ( ) ; } static void print ( int arr [ ] , int len , int L ) { for ( int i = 0 ; i < ( int ) Math . pow ( len , L ) ; i ++ ) { convert_To_Len_th_base ( i , arr , len , L ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int len = arr . length ; int L = 2 ; print ( arr , len , L ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int nodes = input . nextInt ( ) ; int edges = input . nextInt ( ) ; int [ ] arr = new int [ nodes ] ; for ( int i = 0 ; i < edges ; i ++ ) { int n1 = input . nextInt ( ) ; int n2 = input . nextInt ( ) ; arr [ n1 - 1 ] ++ ; arr [ n2 - 1 ] ++ ; } int deg1 = 0 ; int deg2 = 0 ; int deg3 = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == 1 ) { deg1 ++ ; } else if ( arr [ i ] == 2 ) { deg2 ++ ; } else if ( arr [ i ] == nodes - 1 ) { deg3 ++ ; } else { System . out . println ( " unknown ▁ topology " ) ; return ; } } if ( deg2 == nodes ) { System . out . println ( " ring ▁ topology " ) ; } else if ( deg2 == nodes - 2 && deg1 == 2 ) { System . out . println ( " bus ▁ topology " ) ; } else if ( deg3 == 1 && deg1 == nodes - 1 ) { System . out . println ( " star ▁ topology " ) ; } else { System . out . println ( " unknown ▁ topology " ) ; } } }
public class GFG { static long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) Math . pow ( 2 , count / n ) ; for ( long i = 3 ; i <= Math . sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) Math . pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) Math . pow ( p , 1 / n ) ; return gcd ; } public static void main ( String [ ] args ) { long n = 3 ; long p = 80 ; System . out . println ( max_gcd ( n , p ) ) ; } }
import java . io . * ; public class GFG { static int maxArea ( float perimeter ) { int length = ( int ) Math . ceil ( perimeter / 4 ) ; int breadth = ( int ) Math . floor ( perimeter / 4 ) ; return length * breadth ; } public static void main ( String [ ] args ) { float n = 38 ; System . out . println ( " Maximum ▁ Area ▁ = ▁ " + maxArea ( n ) ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = s . nextInt ( ) ; Arrays . sort ( a ) ; int c = 0 ; int st = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( a [ j ] == 2 && a [ i ] + a [ j ] == 3 ) { c ++ ; } else { st = i ; break ; } } int one = 0 ; for ( int i = st ; i < n ; i ++ ) { if ( a [ i ] == 1 ) one ++ ; else break ; } System . out . println ( c + one / 3 ) ; } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; double [ ] a = new double [ n ] ; int [ ] b = new int [ n ] ; double [ ] c = new double [ n ] ; Arrays . setAll ( a , i -> sc . nextInt ( ) ) ; Arrays . setAll ( b , i -> sc . nextInt ( ) ) ; Arrays . setAll ( c , i -> sc . nextInt ( ) ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int idxA = ~ Arrays . binarySearch ( a , b [ i ] - 0.1 ) ; if ( idxA < 0 ) continue ; long numA = idxA ; int idxC = ~ Arrays . binarySearch ( c , b [ i ] + 0.1 ) ; if ( idxC < 0 ) continue ; long numC = n - idxC ; ans += numA * numC ; } System . out . println ( ans ) ; sc . close ( ) ; } }
public class GFG { static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }
public class GFG { static int solve ( int [ ] arr , int n ) { int k = arr . length ; int mp [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i <= n ; i ++ ) { mp [ i ] = 0 ; } for ( int i = 0 ; i < k ; i ++ ) { mp [ arr [ i ] ] = 1 ; } int leftSegment = arr [ 0 ] - 1 ; for ( int i = 1 ; i < k ; i ++ ) { leftSegment = Math . max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) ; } int rightSegment = n - arr [ k - 1 ] ; int maxSegment = Math . max ( leftSegment , rightSegment ) ; int tim ; if ( ( maxSegment & 1 ) == 1 ) tim = ( maxSegment / 2 ) + 1 ; else tim = maxSegment / 2 ; return tim ; } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , 4 } ; System . out . println ( solve ( arr , N ) ) ; } }
import java . util . * ; public class GFG { static void findCombinationsUtil ( int arr [ ] , int index , int n , int red_num ) { HashSet < Integer > s = new HashSet < > ( ) ; int sum = 0 ; if ( red_num < 0 ) { return ; } if ( red_num == 0 ) { for ( int i = 0 ; i < index ; i ++ ) { s . add ( arr [ i ] ) ; } for ( Integer itr : s ) { sum = sum + itr ; } if ( sum == n ) { for ( Integer i : s ) { System . out . print ( i + " ▁ " ) ; } System . out . println ( ) ; return ; } } int prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ; for ( int k = prev ; k <= n ; k ++ ) { if ( index < n ) { arr [ index ] = k ; findCombinationsUtil ( arr , index + 1 , n , red_num - k ) ; } } } static void findCombinations ( int n ) { int [ ] a = new int [ n ] ; findCombinationsUtil ( a , 0 , n , n ) ; } public static void main ( String arr [ ] ) { int n = 7 ; findCombinations ( n ) ; } }
import java . util . ArrayList ; import java . util . Collections ; public class GFG { static int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { ArrayList V = new ArrayList ( ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { V . add ( A [ j ] ) ; } } Collections . sort ( V ) ; return ( ( int ) V . get ( K - 1 ) ) ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 1 , 2 } ; int M = 3 , K = 4 ; int N = A . length ; System . out . println ( KthMinValAfterMconcatenate ( A , N , M , K ) ) ; } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayDeque ; import java . util . Queue ; import java . util . Scanner ; public class Main { private static BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; private static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int start = sc . nextInt ( ) ; int target = sc . nextInt ( ) ; boolean [ ] vis = new boolean [ 20005 ] ; Queue < Integer > queue = new ArrayDeque < > ( ) ; queue . offer ( start ) ; vis [ start ] = true ; int step = 0 ; a : while ( ! queue . isEmpty ( ) ) { int n = queue . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int poll = queue . poll ( ) ; if ( poll == target ) { break a ; } if ( poll * 2 < 20005 && ! vis [ poll * 2 ] ) { vis [ poll * 2 ] = true ; queue . offer ( poll * 2 ) ; } if ( poll - 1 > 0 && ! vis [ poll - 1 ] ) { vis [ poll - 1 ] = true ; queue . offer ( poll - 1 ) ; } } step ++ ; } System . out . println ( step ) ; } }
import java . io . * ; public class GFG { static int numberOfSolutions ( int n ) { int c = 0 ; while ( n > 0 ) { c += n % 2 ; n /= 2 ; } return ( int ) Math . pow ( 2 , c ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( numberOfSolutions ( n ) ) ; } }
import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . PriorityQueue ; import java . util . Queue ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . util . TreeMap ; public class Practice1 { public static void main ( String [ ] args ) { PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; FastReader sc = new FastReader ( ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; long [ ] arr = new long [ n ] ; long sum = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextLong ( ) ; sum += arr [ i ] ; } if ( x == sum ) { out . println ( " YES " ) ; } else { out . println ( " NO " ) ; } out . close ( ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . math . BigInteger ; public final class p005 { public static void main ( String [ ] args ) { System . out . println ( new p005 ( ) . run ( ) ) ; } public String run ( ) { BigInteger allLcm = BigInteger . ONE ; for ( int i = 1 ; i <= 20 ; i ++ ) allLcm = lcm ( BigInteger . valueOf ( i ) , allLcm ) ; return allLcm . toString ( ) ; } private static BigInteger lcm ( BigInteger x , BigInteger y ) { return x . divide ( x . gcd ( y ) ) . multiply ( y ) ; } }
public class GFG { static int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; } static int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; } public static void main ( String [ ] args ) { int costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) System . out . println ( " No ▁ profit ▁ nor ▁ Loss " ) ; else if ( sellingPrice > costPrice ) System . out . println ( Profit ( costPrice , sellingPrice ) + " ▁ Profit ▁ " ) ; else System . out . println ( Loss ( costPrice , sellingPrice ) + " ▁ Loss ▁ " ) ; } }
import java . util . Scanner ; public class JavaApplication40 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numOfEntrance = sc . nextInt ( ) ; int herEnterance = sc . nextInt ( ) ; int count = sc . nextInt ( ) ; int num = herEnterance + ( numOfEntrance + count ) ; while ( num > numOfEntrance ) { num -= numOfEntrance ; } while ( num <= 0 ) { num += numOfEntrance ; } System . out . println ( num ) ; } }
import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Set < Integer > set = new HashSet < Integer > ( ) ; int s = sc . nextInt ( ) ; set . add ( s ) ; int before = s ; for ( int i = 2 ; ; i ++ ) { if ( set . contains ( f ( before ) ) ) { System . out . println ( i ) ; break ; } else { before = f ( before ) ; set . add ( before ) ; } } } static int f ( int x ) { if ( x % 2 == 0 ) { return x / 2 ; } else { return ( x * 3 + 1 ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; if ( N == 0 ) break ; int ans = 0 ; int price = M / N ; for ( int i = 0 ; i < N ; i ++ ) { int a = sc . nextInt ( ) ; if ( a < price ) ans += a ; else ans += price ; } System . out . println ( ans ) ; } } }
import java . util . * ; public class GFG { static Vector < Long > pr = new Vector < > ( ) ; static boolean prime [ ] = new boolean [ 10000000 + 1 ] ; static void sieve ( long n ) { for ( int i = 2 ; i <= n ; i += 1 ) { prime [ i ] = true ; } for ( int p = 2 ; ( int ) p * ( int ) p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = ( int ) p * ( int ) p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) pr . add ( ( long ) p ) ; } static long SemiPrimeSum ( long N ) { long ans = 0 ; for ( int i = 0 ; i < pr . size ( ) ; i += 1 ) { for ( int j = i ; j < pr . size ( ) ; j += 1 ) { if ( ( long ) pr . get ( i ) * ( long ) pr . get ( j ) > N ) break ; ans += ( long ) pr . get ( i ) * ( long ) pr . get ( j ) ; } } return ans ; } public static void main ( String [ ] args ) { long N = 6 ; sieve ( N ) ; System . out . println ( SemiPrimeSum ( N ) ) ; } }
import java . util . Scanner ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . nio . charset . MalformedInputException ; import java . util . StringTokenizer ; import java . util . Arrays ; public class Cv { public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; Scanner sc = new Scanner ( System . in ) ; PrintWriter o = new PrintWriter ( System . out ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) , k = sc . nextInt ( ) , m = 2 ; if ( n % 2 == 0 ) { o . println ( n + k * 2 ) ; } else { while ( n % m != 0 ) { m ++ ; } o . println ( n + m + k * 2 - 2 ) ; } } o . close ( ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; public String next ( ) { while ( ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } byte nextByte ( ) { return Byte . parseByte ( next ( ) ) ; } short nextShort ( ) { return Short . parseShort ( next ( ) ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return java . lang . Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }
import java . util . * ; public class GFG { static boolean isPrime ( int N ) { if ( N < 2 ) return false ; if ( N < 4 ) return true ; if ( ( N & 1 ) == 0 ) return false ; if ( N % 3 == 0 ) return false ; int curr = 5 , s = ( int ) Math . sqrt ( N ) ; while ( curr <= s ) { if ( N % curr == 0 ) return false ; curr += 2 ; if ( N % curr == 0 ) return false ; curr += 4 ; } return true ; } static boolean check ( int s , int p , int prefix_sum [ ] , int n ) { boolean satisfies = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + s - 1 >= n ) break ; if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) < p ) satisfies = false ; } return satisfies ; } static int minimumWindowSize ( int x , int y , int p ) { int [ ] prefix_sum = new int [ y - x + 1 ] ; for ( int i = x ; i <= y ; i ++ ) { if ( isPrime ( i ) ) prefix_sum [ i - x ] = 1 ; } for ( int i = 1 ; i < y - x + 1 ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int low = 1 , high = y - x + 1 ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , p , prefix_sum , y - x + 1 ) ) { high = mid ; } else low = mid ; } if ( check ( low , p , prefix_sum , y - x + 1 ) ) return low ; return high ; } public static void main ( String [ ] args ) { int x = 12 ; int y = 42 ; int p = 3 ; System . out . println ( minimumWindowSize ( x , y , p ) ) ; } }
import java . lang . Math ; import java . io . * ; public class GFG { static boolean checkPerfectSquare ( double n ) { double d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestPerfectSquareNumber ( int a [ ] , double n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } public static void main ( String [ ] args ) { int [ ] a = { 16 , 20 , 25 , 2 , 3 , 10 } ; double n = a . length ; System . out . println ( largestPerfectSquareNumber ( a , n ) ) ; } }
class Solution { public int compress ( char [ ] chars ) { int anchor = 0 , write = 0 ; for ( int read = 0 ; read < chars . length ; read ++ ) { if ( read + 1 == chars . length || chars [ read + 1 ] != chars [ read ] ) { chars [ write ++ ] = chars [ anchor ] ; if ( read > anchor ) { for ( char c : ( " " + ( read - anchor + 1 ) ) . toCharArray ( ) ) { chars [ write ++ ] = c ; } } anchor = read + 1 ; } } return write ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; char [ ] chars = { ' a ' , ' a ' , ' b ' , ' b ' , ' c ' , ' c ' , ' c ' } ; int out = sObj . compress ( chars ) ; System . out . println ( out ) ; } }
import java . util . * ; public class GFG { static void checkPalindrome ( int num ) { String str = Integer . toString ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { System . out . println ( " No " ) ; return ; } l ++ ; r -- ; } System . out . println ( " Yes " ) ; return ; } public static void main ( String args [ ] ) { int n = 19 , k = 3 ; checkPalindrome ( n + k ) ; } }
import java . util . * ; public class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } static int countSubstringsUtil ( char [ ] s ) { int count = 0 ; Map < Character , Integer > mp = new HashMap < > ( ) ; int n = s . length ; int start = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( s [ i ] ) ) { mp . put ( s [ i ] , mp . get ( s [ i ] ) + 1 ) ; } else { mp . put ( s [ i ] , 1 ) ; } while ( mp . containsKey ( ' a ' ) && mp . containsKey ( ' e ' ) && mp . containsKey ( ' i ' ) && mp . containsKey ( ' o ' ) && mp . containsKey ( ' u ' ) && mp . get ( ' a ' ) > 0 && mp . get ( ' e ' ) > 0 && mp . get ( ' i ' ) > 0 && mp . get ( ' o ' ) > 0 && mp . get ( ' u ' ) > 0 ) { count += n - i ; mp . put ( s [ start ] , mp . get ( s [ start ] ) - 1 ) ; start ++ ; } } return count ; } static int countSubstrings ( String s ) { int count = 0 ; String temp = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) ) { temp += s . charAt ( i ) ; } else { if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp . toCharArray ( ) ) ; temp = " " ; } } if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp . toCharArray ( ) ) ; return count ; } public static void main ( String [ ] args ) { String s = " aeouisddaaeeiouua " ; System . out . println ( countSubstrings ( s ) ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class CF239B { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int q = s . nextInt ( ) ; String str = s . next ( ) ; while ( q -- > 0 ) { int [ ] count = new int [ 10 ] ; StringBuilder sb = new StringBuilder ( " " ) ; int l = s . nextInt ( ) - 1 ; int r = s . nextInt ( ) - 1 ; int pointer = 0 ; sb = sb . append ( str . substring ( l , r + 1 ) ) ; boolean flag1 = false , flag2 = false ; while ( pointer >= 0 && pointer < sb . length ( ) ) { if ( sb . charAt ( pointer ) == '0' ) { count [ 0 ] ++ ; sb . deleteCharAt ( pointer ) ; if ( flag2 ) pointer -= 1 ; } else if ( sb . charAt ( pointer ) >= '1' && sb . charAt ( pointer ) <= '9' ) { count [ sb . charAt ( pointer ) - '0' ] ++ ; sb . replace ( pointer , pointer + 1 , Character . toString ( ( char ) ( ( int ) sb . charAt ( pointer ) - 1 ) ) ) ; if ( flag2 ) pointer -= 1 ; else pointer += 1 ; } else { int intial = pointer ; if ( sb . charAt ( pointer ) == ' > ' ) { flag1 = true ; flag2 = false ; } else { flag1 = false ; flag2 = true ; } pointer += ( flag1 ? 1 : - 1 ) ; if ( pointer >= 0 && pointer < sb . length ( ) && ( sb . charAt ( pointer ) == ' > ' || sb . charAt ( pointer ) == ' < ' ) ) { sb . deleteCharAt ( intial ) ; if ( flag1 ) pointer -= 1 ; } } } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( count [ i ] + " ▁ " ) ; } System . out . println ( ) ; } } }
public class GFG { static int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } static int toggle ( int n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; } public static void main ( String arg [ ] ) { int n = 10 ; n = toggle ( n ) ; System . out . println ( n ) ; } }
public class GFG { static class Data { double x , y ; public Data ( double x , double y ) { super ( ) ; this . x = x ; this . y = y ; } } ; static double inv_interpolate ( Data [ ] d , int n , double y ) { double x = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { double xi = d [ i ] . x ; for ( j = 0 ; j < n ; j ++ ) { if ( j != i ) { xi = xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ; } } x += xi ; } return x ; } public static void main ( String [ ] args ) { Data [ ] d = { new Data ( 1.27 , 2.3 ) , new Data ( 2.25 , 2.95 ) , new Data ( 2.5 , 3.5 ) , new Data ( 3.6 , 5.1 ) } ; int n = 4 ; double y = 4.5 ; System . out . println ( " Value ▁ of ▁ x ▁ at ▁ y ▁ = ▁ 4.5 ▁ : ▁ " + String . format ( " % . 5 f " , inv_interpolate ( d , n , y ) ) ) ; } }
public class GFG { static int findElement ( int arr [ ] , int n ) { int prefixMul [ ] = new int [ n ] ; prefixMul [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixMul [ i ] = prefixMul [ i - 1 ] * arr [ i ] ; int suffixMul [ ] = new int [ n ] ; suffixMul [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( prefixMul [ i ] == suffixMul [ i ] ) return arr [ i ] ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 1 , 4 , 6 } ; int n = arr . length ; System . out . println ( findElement ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } public static void main ( String [ ] args ) { int a = 10 , b = 20 , n = 5 ; System . out . println ( numberOfDays ( a , b , n ) ) ; } }
import java . util . Scanner ; public class hw13 { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; { } { int t = scan . nextInt ( ) ; while ( t -- > 0 ) { int n = scan . nextInt ( ) ; String in = scan . next ( ) ; int letter = in . charAt ( 0 ) ; StringBuilder toPrint = new StringBuilder ( ) ; toPrint . append ( in . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( letter > in . charAt ( i ) && i == 1 ) { letter = in . charAt ( i ) ; toPrint . append ( in . charAt ( i ) ) ; } else if ( letter >= in . charAt ( i ) && i > 1 ) { letter = in . charAt ( i ) ; toPrint . append ( in . charAt ( i ) ) ; } else { break ; } } StringBuilder rev = new StringBuilder ( toPrint . reverse ( ) ) ; toPrint . reverse ( ) ; toPrint . append ( rev ) ; System . out . println ( toPrint ) ; } } } }
import java . util . * ; public class GFG { static final int MAX = 100005 ; static HashSet < Integer > fibonacci = new HashSet < Integer > ( ) ; static void createHash ( ) { int prev = 0 , curr = 1 ; fibonacci . add ( prev ) ; fibonacci . add ( curr ) ; while ( curr <= MAX ) { int temp = curr + prev ; fibonacci . add ( temp ) ; prev = curr ; curr = temp ; } } static boolean checkArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( fibonacci . contains ( arr [ i ] ) ) sum += arr [ i ] ; if ( fibonacci . contains ( sum ) ) return true ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 2 } ; int n = arr . length ; createHash ( ) ; if ( checkArray ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int solve ( int health [ ] , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; } public static void main ( String args [ ] ) { int health [ ] = { 4 , 6 , 8 , 12 } ; int n = health . length ; System . out . println ( solve ( health , n ) ) ; } }
import java . io . * ; public class GFG { static float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . pow ( r , 2 ) / 5 ) ; return a ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( ( int ) squarearea ( r ) ) ; } }
import java . util . * ; public class GFG { static class Graph { int V ; LinkedList < Integer > [ ] adj ; Graph ( int V ) { this . V = V ; adj = new LinkedList [ V ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new LinkedList < Integer > ( ) ; } void addEdge ( int v , int w ) { adj [ v ] . add ( w ) ; } void DFSUtil ( int s , Vector < Boolean > visited ) { Stack < Integer > stack = new Stack < > ( ) ; stack . push ( s ) ; while ( stack . empty ( ) == false ) { s = stack . peek ( ) ; stack . pop ( ) ; if ( visited . get ( s ) == false ) { System . out . print ( s + " ▁ " ) ; visited . set ( s , true ) ; } Iterator < Integer > itr = adj [ s ] . iterator ( ) ; while ( itr . hasNext ( ) ) { int v = itr . next ( ) ; if ( ! visited . get ( v ) ) stack . push ( v ) ; } } } void DFS ( ) { Vector < Boolean > visited = new Vector < Boolean > ( V ) ; for ( int i = 0 ; i < V ; i ++ ) visited . add ( false ) ; for ( int i = 0 ; i < V ; i ++ ) if ( ! visited . get ( i ) ) DFSUtil ( i , visited ) ; } } public static void main ( String [ ] args ) { Graph g = new Graph ( 5 ) ; g . addEdge ( 1 , 0 ) ; g . addEdge ( 2 , 1 ) ; g . addEdge ( 3 , 4 ) ; g . addEdge ( 4 , 0 ) ; System . out . println ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal " ) ; g . DFS ( ) ; } }
import java . util . * ; public class GFG { static class Graph { int V ; LinkedList < Integer > [ ] adj ; Graph ( int V ) { this . V = V ; adj = new LinkedList [ V ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new LinkedList < Integer > ( ) ; } void addEdge ( int v , int w ) { adj [ v ] . add ( w ) ; } void DFS ( int s ) { Vector < Boolean > visited = new Vector < Boolean > ( V ) ; for ( int i = 0 ; i < V ; i ++ ) visited . add ( false ) ; Stack < Integer > stack = new Stack < > ( ) ; stack . push ( s ) ; while ( stack . empty ( ) == false ) { s = stack . peek ( ) ; stack . pop ( ) ; if ( visited . get ( s ) == false ) { System . out . print ( s + " ▁ " ) ; visited . set ( s , true ) ; } Iterator < Integer > itr = adj [ s ] . iterator ( ) ; while ( itr . hasNext ( ) ) { int v = itr . next ( ) ; if ( ! visited . get ( v ) ) stack . push ( v ) ; } } } } public static void main ( String [ ] args ) { Graph g = new Graph ( 5 ) ; g . addEdge ( 1 , 0 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 2 , 1 ) ; g . addEdge ( 0 , 3 ) ; g . addEdge ( 1 , 4 ) ; System . out . println ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal " ) ; g . DFS ( 0 ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { new Main ( ) ; } FS in = new FS ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int len ; char [ ] str ; boolean found = false ; Main ( ) { len = ( str = in . next ( ) . toCharArray ( ) ) . length ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { out . printf ( " % d ▁ % d % n " , i + 1 , i + 2 ) ; found = true ; break ; } if ( i < len - 2 && str [ i ] == str [ i + 2 ] ) { out . printf ( " % d ▁ % d % n " , i + 1 , i + 3 ) ; found = true ; break ; } } if ( ! found ) out . printf ( " % d ▁ % d % n " , - 1 , - 1 ) ; out . close ( ) ; } class FS { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }
public class GFG { public static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " ▁ " + f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 13 ; sequence ( n ) ; } }
import java . util . Scanner ; public class B855 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; long P = in . nextLong ( ) ; long Q = in . nextLong ( ) ; long R = in . nextLong ( ) ; long [ ] A = new long [ N ] ; for ( int n = 0 ; n < N ; n ++ ) { A [ n ] = in . nextInt ( ) ; } long [ ] maxP = new long [ N ] ; maxP [ 0 ] = P * A [ 0 ] ; for ( int n = 1 ; n < N ; n ++ ) { maxP [ n ] = Math . max ( maxP [ n - 1 ] , P * A [ n ] ) ; } long [ ] maxQ = new long [ N ] ; maxQ [ 0 ] = maxP [ 0 ] + Q * A [ 0 ] ; for ( int n = 1 ; n < N ; n ++ ) { maxQ [ n ] = Math . max ( maxQ [ n - 1 ] , Q * A [ n ] + maxP [ n ] ) ; } long answer = maxQ [ 0 ] + R * A [ 0 ] ; for ( int n = 1 ; n < N ; n ++ ) { answer = Math . max ( answer , R * A [ n ] + maxQ [ n ] ) ; } System . out . println ( answer ) ; } }
import java . math . BigInteger ; public final class p063 { public static void main ( String [ ] args ) { System . out . println ( new p063 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int n = 1 ; n <= 9 ; n ++ ) { for ( int k = 1 ; k <= 21 ; k ++ ) { if ( BigInteger . valueOf ( n ) . pow ( k ) . toString ( ) . length ( ) == k ) count ++ ; } } return Integer . toString ( count ) ; } }
import java . io . * ; public class GFG { public static void main ( String [ ] args ) { double n = 12 ; System . out . println ( Math . sqrt ( n ) ) ; } }
import java . io . * ; public class GFG { static double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { long n = 10 ; System . out . println ( findSum ( n ) ) ; } }
import java . lang . Math ; public class GFG { public static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; } public static void main ( String [ ] args ) { System . out . println ( findNth ( 5 ) ) ; } }
import java . lang . * ; public class GFG { public static double per ( double a , double b ) { return ( a + b ) ; } public static double area ( double s ) { return ( s / 2 ) ; } public static void main ( String [ ] args ) { double a = 7 , b = 8 , s = 10 ; System . out . println ( per ( a , b ) ) ; System . out . println ( area ( s ) ) ; } }
import java . util . * ; class Solution { static boolean isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; } static void formBinaryStr ( int n , int a [ ] ) { boolean flag = true ; String s = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( isBinary ( a [ i ] ) ) s += " " + a [ i ] ; else { flag = false ; break ; } } if ( flag ) System . out . print ( s + " \n " ) ; else System . out . print ( " - 1 \n " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 10 , 1 , 0 , 11 , 10 } ; int N = a . length ; formBinaryStr ( N , a ) ; } }
import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class GFG { static int getMax ( int [ ] A ) { int max = Integer . MIN_VALUE ; for ( int i : A ) { max = Math . max ( max , i ) ; } return max ; } static int calculateAND ( int arr [ ] , int n ) { int max_val = getMax ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; int i ; for ( i = 0 ; i < max_val + 1 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return ( S1 & S2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 6 , 7 } ; int n = arr . length ; System . out . println ( calculateAND ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int suma = 0 ; int sumb = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; suma += a [ i ] ; sumb += b [ i ] ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; int W = 0 ; if ( suma - a [ n - 1 ] < a [ n - 1 ] ) W = a [ n - 1 ] - ( suma - a [ n - 1 ] ) ; if ( W == 0 ) { System . out . println ( suma + sumb ) ; } else { int [ ] [ ] dp = new int [ n ] [ W + 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j <= W ; j ++ ) { if ( j < b [ i ] ) dp [ i + 1 ] [ j ] = dp [ i ] [ j ] ; else dp [ i + 1 ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ j - b [ i ] ] + b [ i ] ) ; } } System . out . println ( 2 * a [ n - 1 ] + ( sumb - dp [ n - 1 ] [ W ] ) ) ; } } } }
public class GFG { static int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == ' ( ' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ' ) ' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; } public static void main ( String [ ] args ) { String str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " ; System . out . println ( findIndex ( str ) ) ; } }
class Test { static int sumOfDigit ( int K ) { int sod = 0 ; while ( K != 0 ) { sod += K % 10 ; K /= 10 ; } return sod ; } static int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; } public static void main ( String args [ ] ) { int N = 13 ; int diff = 2 ; System . out . println ( totalNumbersWithSpecificDifference ( N , diff ) ) ; } }
public class GFG { static int numOfsubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int product = arr [ i ] ; int sum = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( product == sum ) count ++ ; product *= arr [ j ] ; sum += arr [ j ] ; } if ( product == sum ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 2 } ; int n = arr . length ; System . out . println ( numOfsubarrays ( arr , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; TreeSet < Long > nums = new TreeSet < > ( ) ; for ( long i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { nums . add ( - i ) ; nums . add ( - n / i ) ; } } int max = nums . size ( ) + 1 ; int min = 0 ; HashSet < Long > used = new HashSet < > ( ) ; for ( long x : nums ) { if ( used . contains ( - x ) ) { continue ; } min ++ ; for ( long i = 2 ; i <= Math . sqrt ( - x ) ; i ++ ) { if ( - x % i == 0 ) { used . add ( i ) ; used . add ( - x / i ) ; } } } if ( min == 0 ) { min ++ ; } System . out . println ( min + " ▁ " + max ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long m = sc . nextLong ( ) ; long min = Math . max ( 0 , n - 2 * m ) ; long vertex = 1 ; long rem = m ; while ( rem > 0 ) { long d = Math . min ( vertex , rem ) ; vertex ++ ; rem -= d ; } long max = n - ( vertex == 1 ? 0 : vertex ) ; System . out . println ( min + " ▁ " + max ) ; sc . close ( ) ; writer . flush ( ) ; writer . close ( ) ; reader . close ( ) ; } }
import java . io . * ; public class GFG { static int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 10 , c = 3 ; System . out . println ( getMaxNum ( a , b , c ) ) ; } }
import java . util . Scanner ; public class Problem3 { static int Cmtoinch ( int cm ) { int inch = ( int ) ( cm / 3 ) ; double modl = cm % 3 ; if ( modl >= 2 ) { inch ++ ; } return inch ; } public static void main ( String [ ] arr ) { Scanner sc = new Scanner ( System . in ) ; int cm = sc . nextInt ( ) ; int inches = Cmtoinch ( cm ) ; int feet = inches / 12 ; int op = 12 * feet ; int returned = inches - op ; System . out . println ( feet + " ▁ " + returned ) ; } }
import java . util . * ; public class GFG { static int c ; static int HailstoneNumbers ( int N ) { System . out . print ( N + " ▁ " ) ; if ( N == 1 && c == 0 ) { return c ; } else if ( N == 1 && c != 0 ) { c ++ ; return c ; } else if ( N % 2 == 0 ) { c ++ ; HailstoneNumbers ( N / 2 ) ; } else if ( N % 2 != 0 ) { c ++ ; HailstoneNumbers ( 3 * N + 1 ) ; } return c ; } public static void main ( String [ ] args ) { int N = 7 ; int x ; x = HailstoneNumbers ( N ) ; System . out . println ( ) ; System . out . println ( " Number ▁ of ▁ Steps : ▁ " + x ) ; } }
class Solution { public int binaryGap ( int N ) { int last = - 1 , ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ( ( ( N >> i ) & 1 ) > 0 ) { if ( last >= 0 ) ans = Math . max ( ans , i - last ) ; last = i ; } return ans ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int N = 22 ; int out = sObj . binaryGap ( N ) ; System . out . println ( out ) ; } }
import java . util . Scanner ; public class ImportantExam { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int snoozeInterval = scanner . nextInt ( ) , hh = scanner . nextInt ( ) , mm = scanner . nextInt ( ) ; int noOfTimeSnooze = 0 ; boolean flag = true ; while ( flag ) { if ( hh == 7 || hh == 17 || mm == 7 || mm % 10 == 7 ) { flag = false ; System . out . println ( noOfTimeSnooze ) ; } mm -= snoozeInterval ; noOfTimeSnooze ++ ; if ( mm < 0 ) { mm += 60 ; hh -= 1 ; if ( hh < 0 ) hh = 23 ; } } } }
public class GFG { static boolean canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; } static int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; } public static void main ( String args [ ] ) { int n = 4 , m = 5 ; System . out . println ( maxTeams ( n , m ) ) ; } }
public class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) { k = n - k ; } for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( catalan ( i ) + " ▁ " ) ; } } }
public class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( catalan ( n ) ) ; } }
import java . util . * ; class RemoveDuplicates { void removeDuplicates ( String str ) { LinkedHashSet < Character > lhs = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) lhs . add ( str . charAt ( i ) ) ; for ( Character ch : lhs ) System . out . print ( ch ) ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; RemoveDuplicates r = new RemoveDuplicates ( ) ; r . removeDuplicates ( str ) ; } }
import java . util . * ; class solution { static int getPosition ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } int ans = - 1 , max = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; } public static void main ( String args [ ] ) { int a [ ] = { 2 , 5 , 4 } ; int n = a . length ; int m = 2 ; System . out . println ( getPosition ( a , n , m ) ) ; } }
public class GFG { static int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; static int dayOfYear ( String date ) { int year = Integer . parseInt ( date . substring ( 0 , 4 ) ) ; int month = Integer . parseInt ( date . substring ( 5 , 7 ) ) ; int day = Integer . parseInt ( date . substring ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) { ++ day ; } while ( -- month > 0 ) { day = day + days [ month - 1 ] ; } return day ; } public static void main ( String [ ] args ) { String date = "2019-01-09" ; System . out . println ( dayOfYear ( date ) ) ; } }
import java . util . Scanner ; public class test215 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int n = in . nextInt ( ) ; if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { System . out . print ( ( i - 1 ) + " ▁ " ) ; } else { System . out . print ( ( i + 1 ) + " ▁ " ) ; } } } else { for ( int i = 1 ; i <= n - 3 ; i ++ ) { if ( i % 2 == 0 ) { System . out . print ( ( i - 1 ) + " ▁ " ) ; } else { System . out . print ( ( i + 1 ) + " ▁ " ) ; } } System . out . print ( n + " ▁ " ) ; System . out . print ( ( n - 2 ) + " ▁ " ) ; System . out . print ( ( n - 1 ) + " ▁ " ) ; } System . out . println ( ) ; } in . close ( ) ; } }
import java . util . * ; public class GFG { static int cnt = 0 ; static Vector < Vector < Integer > > graph = new Vector < Vector < Integer > > ( ) ; static Vector < String > weight = new Vector < String > ( ) ; static boolean isPalindrome ( String x ) { int n = x . length ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( x . charAt ( i ) != x . charAt ( n - 1 - i ) ) return false ; } return true ; } static void dfs ( int node , int parent ) { String x = weight . get ( node ) ; if ( isPalindrome ( x ) ) cnt += 1 ; for ( int i = 0 ; i < graph . get ( node ) . size ( ) ; i ++ ) { if ( graph . get ( node ) . get ( i ) == parent ) continue ; dfs ( graph . get ( node ) . get ( i ) , node ) ; } } public static void main ( String args [ ] ) { weight . add ( " " ) ; weight . add ( " abc " ) ; weight . add ( " aba " ) ; weight . add ( " bcb " ) ; weight . add ( " moh " ) ; weight . add ( " aa " ) ; for ( int i = 0 ; i < 100 ; i ++ ) graph . add ( new Vector < Integer > ( ) ) ; graph . get ( 1 ) . add ( 2 ) ; graph . get ( 2 ) . add ( 3 ) ; graph . get ( 2 ) . add ( 4 ) ; graph . get ( 1 ) . add ( 5 ) ; dfs ( 1 , 1 ) ; System . out . println ( cnt ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { boolean [ ] used = new boolean [ 14 ] ; boolean ans = false ; for ( int i = 0 ; i < 6 ; i ++ ) { used [ sc . nextInt ( ) ] = true ; } if ( used [ 1 ] == used [ 13 ] ) ans = ! used [ 1 ] ; else { int l = 6 , r = 8 ; boolean t = false ; for ( ; ; ) { if ( t == used [ 1 ] ) { if ( used [ r ] ^ t ) r ++ ; else if ( used [ l ] ^ t ) l -- ; } else { if ( used [ l ] ^ t ) l -- ; else if ( used [ r ] ^ t ) r ++ ; } if ( r == 13 ) { ans = ! used [ 1 ] ; break ; } if ( l == 1 ) { ans = used [ 1 ] ; break ; } t = ! t ; } } System . out . println ( ans ? " yes " : " no " ) ; } } }
public class Main { public static long low = 1 , high = ( long ) Math . pow ( 3 , 32 ) , n ; public static void main ( String [ ] args ) { n = new java . util . Scanner ( System . in ) . nextLong ( ) ; long ans = ( n == 0 ) ? - 1 : dfs ( 1 , 1 ) ; System . out . println ( ans + 1 ) ; } public static long dfs ( long pos , long pace ) { if ( pos > n ) return 0 ; if ( pace < high ) { long npace = 3 * pace ; long npos = pos + npace ; if ( npos == n & ( npace == 1 | npace == 3 ) ) return 1 ; else { long temp = dfs ( npos , npace ) ; if ( temp != 0 ) return 1 + temp ; } } { long npace = pace ; long npos = npace + pos ; if ( npos == n & ( npace == 1 | npace == 3 ) ) return 1 ; else { long temp = dfs ( npos , npace ) ; if ( temp != 0 ) return 1 + temp ; } } if ( pace > low ) { long npace = pace / 3 ; long npos = pos + npace ; if ( npos == n & ( npace == 3 | npace == 1 ) ) return 1 ; else { long temp = dfs ( npos , npace ) ; if ( temp != 0 ) return 1 + temp ; } } return 0 ; } }
import java . util . Arrays ; import java . util . Scanner ; import java . util . Set ; import java . util . stream . Collectors ; public class Main { static final char [ ] VALUES = { ' S ' , ' E ' , ' T ' } ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; sc . nextInt ( ) ; String [ ] cards = new String [ n ] ; for ( int i = 0 ; i < cards . length ; ++ i ) { cards [ i ] = sc . next ( ) ; } System . out . println ( solve ( cards ) ) ; sc . close ( ) ; } static int solve ( String [ ] cards ) { Set < String > cardSet = Arrays . stream ( cards ) . collect ( Collectors . toSet ( ) ) ; int result = 0 ; for ( int i = 0 ; i < cards . length ; ++ i ) { for ( int j = i + 1 ; j < cards . length ; ++ j ) { if ( cardSet . contains ( computeTarget ( cards [ i ] , cards [ j ] ) ) ) { ++ result ; } } } result /= 3 ; return result ; } static String computeTarget ( String card1 , String card2 ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < card1 . length ( ) ; ++ i ) { char ch1 = card1 . charAt ( i ) ; char ch2 = card2 . charAt ( i ) ; char ch ; if ( ch1 == ch2 ) { ch = ch1 ; } else { for ( int j = 0 ; ; ++ j ) { if ( VALUES [ j ] != ch1 && VALUES [ j ] != ch2 ) { ch = VALUES [ j ] ; break ; } } } result . append ( ch ) ; } return result . toString ( ) ; } }
import java . util . * ; class Main { static int mat [ ] [ ] = new int [ 105 ] [ 105 ] ; public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; for ( ; ; ) { int w = in . nextInt ( ) , h = in . nextInt ( ) ; if ( w == 0 && h == 0 ) return ; int sx = in . nextInt ( ) , sy = in . nextInt ( ) ; int gx = in . nextInt ( ) , gy = in . nextInt ( ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < 105 ; i ++ ) for ( int j = 0 ; j < 105 ; j ++ ) mat [ i ] [ j ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int c = in . nextInt ( ) , d = in . nextInt ( ) , x = in . nextInt ( ) , y = in . nextInt ( ) ; if ( d == 1 ) { for ( int j = 0 ; j < 2 ; j ++ ) for ( int k = 0 ; k < 4 ; k ++ ) mat [ x + j ] [ y + k ] = c ; } else { for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) mat [ x + j ] [ y + k ] = c ; } } if ( mat [ sx ] [ sy ] == - 1 ) { System . out . println ( " NG " ) ; continue ; } dfs ( sx , sy , mat [ sx ] [ sy ] ) ; System . out . println ( ( mat [ gx ] [ gy ] == - 2 ) ? " OK " : " NG " ) ; } } static void dfs ( int i , int j , int col ) { if ( mat [ i ] [ j ] != col ) return ; mat [ i ] [ j ] = - 2 ; dfs ( i + 1 , j , col ) ; dfs ( i , j + 1 , col ) ; dfs ( i - 1 , j , col ) ; dfs ( i , j - 1 , col ) ; return ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( " LCM ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + lcm ( a , b ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( " LCM ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + lcm ( a , b ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
public final class p188 { public static void main ( String [ ] args ) { System . out . println ( new p188 ( ) . run ( ) ) ; } public String run ( ) { return Integer . toString ( tetrationMod ( 1777 , 1855 , Library . pow ( 10 , 8 ) ) ) ; } private static int tetrationMod ( int x , int y , int m ) { if ( y == 1 ) return x % m ; else return Library . powMod ( x , tetrationMod ( x , y - 1 , Library . totient ( m ) ) , m ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int min_sum ( int n , int k , int a [ ] ) { Arrays . sort ( a ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int K = 1 ; int N = arr . length ; System . out . println ( min_sum ( N , K , arr ) ) ; } }
class ListNode { int val ; ListNode next ; ListNode ( int v ) { this . val = v ; this . next = null ; } } public class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow , fast , curr ; slow = head ; fast = head ; for ( int i = 0 ; i < n ; i ++ ) fast = fast . next ; if ( fast == null ) { head = head . next ; return head ; } while ( fast . next != null ) { fast = fast . next ; slow = slow . next ; } curr = slow . next ; slow . next = curr . next ; return head ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 1 , 2 , 3 , 4 , 5 } ; int n = 2 ; ListNode head = null ; ListNode lastNode = null ; for ( int num : nums ) { ListNode lnn = new ListNode ( num ) ; if ( head == null ) { head = lastNode = lnn ; } else { lastNode . next = lnn ; lastNode = lnn ; } } ListNode out = sObj . removeNthFromEnd ( head , n ) ; while ( out . next != null ) { System . out . print ( out . val + " ▁ - - > ▁ " ) ; out = out . next ; } System . out . println ( out . val + " ▁ - - > ▁ end " ) ; } }
public class GFG { static String findMaxLenEven ( String str ) { int n = str . length ( ) ; int i = 0 ; int currlen = 0 ; int maxlen = 0 ; int st = - 1 ; while ( i < n ) { if ( str . charAt ( i ) == ' ▁ ' ) { if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } currlen = 0 ; } else { currlen ++ ; } i ++ ; } if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } if ( st == - 1 ) return " - 1" ; return str . substring ( st , st + maxlen ) ; } public static void main ( String args [ ] ) { String str = " this ▁ is ▁ a ▁ test ▁ string " ; System . out . println ( findMaxLenEven ( str ) ) ; } }
import java . io . * ; public class GFG { static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 7 , 9 , 10 } ; int sum = 16 ; int n = arr . length ; System . out . println ( pairsInSortedRotated ( arr , n , sum ) ) ; } }
public final class p129 { public static void main ( String [ ] args ) { System . out . println ( new p129 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { for ( int n = LIMIT ; ; n ++ ) { if ( findLeastDivisibleRepunit ( n ) > LIMIT ) return Integer . toString ( n ) ; } } private static int findLeastDivisibleRepunit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; if ( n > Integer . MAX_VALUE / 10 ) throw new IllegalArgumentException ( " Arithmetic ▁ overflow " ) ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; } }
public class GFG { static int getPassingCars ( int A [ ] , int n ) { int countOne = 0 , result = 0 ; while ( n >= 1 ) { if ( A [ n - 1 ] == 1 ) countOne ++ ; else result += countOne ; n -- ; } return result ; } public static void main ( String [ ] args ) { int A [ ] = { 0 , 1 , 0 , 1 , 1 } ; int n = A . length ; System . out . println ( getPassingCars ( A , n ) ) ; } }
public final class p046 { public static void main ( String [ ] args ) { System . out . println ( new p046 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 9 ; ; i += 2 ) { if ( ! satisfiesConjecture ( i ) ) return Integer . toString ( i ) ; } } private static boolean satisfiesConjecture ( int n ) { if ( n % 2 == 0 || Library . isPrime ( n ) ) return true ; for ( int i = 1 ; i * i * 2 <= n ; i ++ ) { if ( Library . isPrime ( n - i * i * 2 ) ) return true ; } return false ; } }
import java . util . Scanner ; public class BlockAdventure { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; for ( int t = in . nextInt ( ) ; t > 0 ; t -- ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int k = in . nextInt ( ) ; int prev = in . nextInt ( ) ; boolean answer = true ; for ( int i = 1 ; i < n ; i ++ ) { int next = in . nextInt ( ) ; m += prev - Math . max ( 0 , ( next - k ) ) ; prev = next ; if ( m < 0 ) { answer = false ; } } System . out . println ( answer ? " YES " : " NO " ) ; } } }
public class GFG { static int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 2 , 10 } ; int n = arr . length ; System . out . print ( findMinRemoval ( arr , n ) + " \n " ) ; } }
import java . io . * ; public class GFG { static void find ( int n ) { String [ ] arr = new String [ n + 1 ] ; arr [ 0 ] = " " ; int size = 1 , m = 1 ; while ( size <= n ) { for ( int i = 0 ; i < m && ( size + i ) <= n ; i ++ ) arr [ size + i ] = "3" + arr [ size - m + i ] ; for ( int i = 0 ; i < m && ( size + m + i ) <= n ; i ++ ) arr [ size + m + i ] = "4" + arr [ size - m + i ] ; m = m << 1 ; size = size + m ; } System . out . println ( arr [ n ] ) ; } public static void main ( String [ ] args ) { for ( int i = 1 ; i < 16 ; i ++ ) find ( i ) ; } }
import java . util . * ; public class GFG { static String maxValue ( char [ ] a , char [ ] b ) { Arrays . sort ( b ) ; int n = a . length ; int m = b . length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String a = "1234" ; String b = "4321" ; System . out . println ( maxValue ( a . toCharArray ( ) , b . toCharArray ( ) ) ) ; } }
import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; ArrayList < Pair < Integer , Integer > > N_arr = new ArrayList < Pair < Integer , Integer > > ( ) ; ArrayList < Pair < Integer , Integer > > P_arr = new ArrayList < Pair < Integer , Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) , a = sc . nextInt ( ) ; if ( x < 0 ) N_arr . add ( new Pair < > ( x , a ) ) ; else P_arr . add ( new Pair < > ( x , a ) ) ; } Collections . sort ( N_arr , Comparator . comparing ( p -> - p . getKey ( ) ) ) ; Collections . sort ( P_arr , Comparator . comparing ( p -> p . getKey ( ) ) ) ; int sum = 0 ; if ( N_arr . size ( ) == P_arr . size ( ) ) { for ( int i = 0 ; i < N_arr . size ( ) ; i ++ ) sum += N_arr . get ( i ) . getValue ( ) + P_arr . get ( i ) . getValue ( ) ; } else if ( N_arr . size ( ) < P_arr . size ( ) ) { for ( int i = 0 ; i < N_arr . size ( ) ; i ++ ) sum += N_arr . get ( i ) . getValue ( ) + P_arr . get ( i ) . getValue ( ) ; sum += P_arr . get ( N_arr . size ( ) ) . getValue ( ) ; } else { for ( int i = 0 ; i < P_arr . size ( ) ; i ++ ) sum += N_arr . get ( i ) . getValue ( ) + P_arr . get ( i ) . getValue ( ) ; sum += N_arr . get ( P_arr . size ( ) ) . getValue ( ) ; } System . out . println ( sum ) ; } }
import java . math . * ; public class GFG { static float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . pow ( product , ( float ) 1 / n ) ; return gm ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . length ; System . out . println ( String . format ( " % . 6 f " , geometricMean ( arr , n ) ) ) ; } }
import java . util . Scanner ; class Pattern { static void display ( int n ) { int i , j , k ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 , k = i ; j <= i ; j ++ , k -- ) { if ( k % 2 == 0 ) { System . out . print ( j ) ; } else { System . out . print ( " * " ) ; } } System . out . print ( " \n " ) ; } } public static void main ( String [ ] args ) { int n = 5 ; display ( n ) ; } }
public class CountXor { static int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; System . out . println ( countXorPair ( arr , arr . length ) ) ; } }
import java . util . * ; public class GFG { static double Square ( double n , double i , double j ) { double mid = ( i + j ) / 2 ; double mul = mid * mid ; if ( ( mul == n ) || ( Math . abs ( mul - n ) < 0.00001 ) ) return mid ; else if ( mul < n ) return Square ( n , mid , j ) ; else return Square ( n , i , mid ) ; } static void findSqrt ( double n ) { double i = 1 ; boolean found = false ; while ( ! found ) { if ( i * i == n ) { System . out . println ( i ) ; found = true ; } else if ( i * i > n ) { double res = Square ( n , i - 1 , i ) ; System . out . println ( String . format ( " % . 5 f " , res ) ) ; found = true ; } i ++ ; } } public static void main ( String [ ] args ) { double n = 3 ; findSqrt ( n ) ; } }
import java . util . Scanner ; public class Main { static int [ ] a ; static int [ ] b ; static boolean [ ] k ; static int z ; static void dfs ( int x , int pa , int pb ) { if ( x == 9 ) { z += pb < pa ? 1 : 0 ; return ; } for ( int i = 0 ; i < 9 ; i ++ ) { if ( k [ i ] ) continue ; k [ i ] = true ; dfs ( x + 1 , pa + ( b [ x ] < a [ i ] ? a [ i ] + b [ x ] : 0 ) , pb + ( b [ x ] < a [ i ] ? 0 : a [ i ] + b [ x ] ) ) ; k [ i ] = false ; } } public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int N = sc . nextInt ( ) ; while ( N -- != 0 ) { a = new int [ 9 ] ; b = new int [ 9 ] ; k = new boolean [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) b [ i ] = sc . nextInt ( ) ; z = 0 ; dfs ( 0 , 0 , 0 ) ; int bb = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 ; double t = z * 1.0 / bb ; System . out . printf ( " % .5f ▁ % .5f \n " , t , 1 - t ) ; } } } }
import java . io . * ; class Combination { static void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + " ▁ " ) ; System . out . println ( " " ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } static void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }
import java . io . * ; class Combination { static void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + " ▁ " ) ; System . out . println ( " " ) ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } static void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }
public class GFG { static int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class GFG { static void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x " + ( x * dif + y ) ) ; else if ( dif > 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x + " + - x * dif + y ) ; else System . out . println ( " Not ▁ possible " ) ; } } public static void main ( String args [ ] ) { int A = 2 , x = 2 , y = 0 ; findTangent ( A , x , y ) ; } }
import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Fast f = new Fast ( System . in ) ; int t = f . nextInt ( ) ; while ( t -- != 0 ) { int n = f . nextInt ( ) ; int max = Integer . MIN_VALUE , min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = f . nextInt ( ) ; if ( x > max ) max = x ; if ( x < min ) min = x ; } System . out . println ( max - min ) ; } System . out . flush ( ) ; System . out . close ( ) ; } } class Fast { StringTokenizer st ; BufferedReader br ; public Fast ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Fast ( String file ) throws IOException { br = new BufferedReader ( new FileReader ( file ) ) ; } public Fast ( FileReader r ) { br = new BufferedReader ( r ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public String readAllLines ( BufferedReader reader ) throws IOException { StringBuilder content = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { content . append ( line ) ; content . append ( System . lineSeparator ( ) ) ; } return content . toString ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public int [ ] nextIntArray ( int n ) throws IOException { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } }
import java . io . * ; public class GFG { static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { String n = "43262488612" ; System . out . println ( " Rotations : ▁ " + countRotationsDivBy8 ( n ) ) ; } }
import java . util . * ; public class GFG { static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; } static int primeCount ( int arr [ ] , int n ) { int max_val = max_element ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ; int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ; System . out . println ( primeCount ( pre , n ) ) ; } }
import java . util . * ; public class GFG { static void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) ; Stack < Integer > s = new Stack < > ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } } public static void main ( String [ ] args ) { Queue < Integer > q = new java . util . LinkedList < > ( ) ; q . add ( 11 ) ; q . add ( 12 ) ; q . add ( 13 ) ; q . add ( 14 ) ; q . add ( 15 ) ; q . add ( 16 ) ; q . add ( 17 ) ; q . add ( 18 ) ; q . add ( 19 ) ; q . add ( 20 ) ; interLeaveQueue ( q ) ; int length = q . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { System . out . print ( q . peek ( ) + " ▁ " ) ; q . poll ( ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numberOfTestCases = sc . nextInt ( ) ; List < Case > testCases = new ArrayList < > ( ) ; for ( int i = 0 ; i < numberOfTestCases ; i ++ ) { int numberOfFloors = sc . nextInt ( ) ; int currentFloor = sc . nextInt ( ) ; int numberOfClosedFloors = sc . nextInt ( ) ; testCases . add ( new Case ( numberOfFloors , currentFloor , numberOfClosedFloors ) ) ; for ( int j = 0 ; j < testCases . get ( i ) . numberOfClosedFloors ; j ++ ) { testCases . get ( i ) . closedFloors . add ( sc . nextInt ( ) ) ; } } for ( Case t : testCases ) { int i = 0 ; while ( true ) { int up = t . currentFloor + i ; int down = t . currentFloor - i ; if ( ( up <= t . numberOfFloors && ( ! t . closedFloors . contains ( up ) ) || ( down > 0 && ! t . closedFloors . contains ( down ) ) ) ) { System . out . println ( i ) ; break ; } i ++ ; } } } } class Case { int numberOfFloors ; int currentFloor ; int numberOfClosedFloors ; Set < Integer > closedFloors ; public Case ( int numberOfFloors , int currentFloor , int numberOfClosedFloors ) { this . numberOfFloors = numberOfFloors ; this . currentFloor = currentFloor ; this . numberOfClosedFloors = numberOfClosedFloors ; this . closedFloors = new HashSet < > ( ) ; } }
public class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static void findRatio ( int m , int n ) { int Am = m - 5 , An = n - 5 ; int numerator = Am / GCD ( Am , An ) ; int denominator = An / GCD ( Am , An ) ; System . out . println ( numerator + " ▁ / ▁ " + denominator ) ; } public static void main ( String args [ ] ) { int m = 10 , n = 20 ; findRatio ( m , n ) ; } }
import java . io . * ; import java . util . * ; public class GFG { public static double M_E = 2.71828182845904523536 ; public static double M_PI = 3.141592654 ; static long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; } public static void main ( String [ ] args ) { System . out . println ( findDigits ( 1 ) ) ; System . out . println ( findDigits ( 50000000 ) ) ; System . out . println ( findDigits ( 1000000000 ) ) ; System . out . println ( findDigits ( 120 ) ) ; } }
import java . io . * ; public class GFG { static int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; } public static void main ( String [ ] args ) { int n = 11 , k = 2 ; System . out . println ( find_sum ( n , k ) ) ; } }
class Test { static int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . floor ( S ) ; int ans = ( int ) Math . pow ( 10 , fract_S ) ; return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 8 , 3 , 7 } ; System . out . println ( FirstDigit ( arr , arr . length ) ) ; } }
import java . io . * ; public class GFG { static int findSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { sum += arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 16 , 10 , 9 , 6 , 7 , 17 } ; int n = arr . length ; int k = 3 ; System . out . println ( findSum ( arr , n , k ) ) ; } }
import java . util . * ; public class JavaApplication91 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num1 = sc . nextInt ( ) ; int num2 = sc . nextInt ( ) ; int counter = 0 ; ArrayList < Integer > arr = new ArrayList < > ( ) ; for ( int i = 0 ; i < num1 ; i ++ ) { arr . add ( 0 ) ; } for ( int i = 0 ; i < num2 ; i ++ ) { int num3 = sc . nextInt ( ) ; int num4 = sc . nextInt ( ) ; int num5 = sc . nextInt ( ) ; arr . set ( num3 - 1 , arr . get ( num3 - 1 ) + num5 ) ; arr . set ( num4 - 1 , arr . get ( num4 - 1 ) - num5 ) ; } for ( int i = 0 ; i < num1 ; i ++ ) { counter += Math . abs ( arr . get ( i ) ) ; } System . out . println ( counter / 2 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n == 0 && m == 0 ) break ; int [ ] ns = new int [ n ] ; int [ ] ms = new int [ m ] ; int nsum = 0 ; int msum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ns [ i ] = sc . nextInt ( ) ; nsum += ns [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { ms [ i ] = sc . nextInt ( ) ; msum += ms [ i ] ; } int sn = - 1 ; int sm = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( nsum - ns [ i ] + ms [ j ] == msum - ms [ j ] + ns [ i ] ) { if ( sn == - 1 ) { sn = ns [ i ] ; sm = ms [ j ] ; } else if ( ns [ i ] + ms [ j ] < sn + sm ) { sn = ns [ i ] ; sm = ms [ j ] ; } } } } System . out . println ( sn == - 1 ? sn : sn + " ▁ " + sm ) ; } } }
class Solution { public int fixedPoint ( int [ ] A ) { int l = 0 ; int h = A . length ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( A [ mid ] > mid ) h = mid - 1 ; else if ( A [ mid ] < mid ) l = mid + 1 ; else return mid ; } return - 1 ; } public static void main ( String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] A = { - 10 , - 5 , 0 , 3 , 7 } ; int out = sObj . fixedPoint ( A ) ; System . out . println ( out ) ; } }
import java . util . Scanner ; public class Main { public static int INF = 1 << 24 ; public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int n = stdIn . nextInt ( ) ; int cost [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cost [ i ] [ j ] = stdIn . nextInt ( ) ; } } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans += Math . min ( cost [ i ] [ j ] , cost [ j ] [ i ] ) ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class GFG { static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } public static void main ( String [ ] args ) { String str1 = " bcadeh " , str2 = " hea " ; System . out . println ( remAnagram ( str1 , str2 ) ) ; } }
import java . util . * ; public class GFG { static double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } public static void main ( String [ ] args ) { float r = 9 , n = 6 ; System . out . println ( String . format ( " % . 3 f " , polyarea ( n , r ) ) ) ; } }
import java . util . * ; public class code { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int t = sc . nextInt ( ) ; while ( t -- > 0 ) { solve ( ) ; } } static void solve ( ) { String s = sc . next ( ) ; Set < Character > ori = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { ori . add ( s . charAt ( i ) ) ; } if ( ori . size ( ) == 1 || ori . size ( ) == s . length ( ) ) { System . out . println ( " Yes " ) ; return ; } int n = ori . size ( ) ; ori . clear ( ) ; int i = 0 , j = 0 ; while ( j < s . length ( ) ) { ori . add ( s . charAt ( j ) ) ; if ( j - i + 1 == n ) { if ( ori . size ( ) < n ) { System . out . println ( " no " ) ; return ; } else { ori . remove ( s . charAt ( i ++ ) ) ; } } j ++ ; } System . out . println ( " Yes " ) ; } }
import java . io . * ; public class GFG { static int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; } public static void main ( String [ ] args ) { int b = 3 , s = 4 ; System . out . println ( surfaceArea ( b , s ) ) ; } }
import java . io . * ; public class GFG { static int count ( String s , int len ) { int MAX = 1000 ; int cur = 0 , dig = 0 ; int [ ] sum = new int [ MAX ] ; int [ ] [ ] dp = new int [ MAX ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; if ( dig == 8 ) ans ++ ; if ( i - 2 >= 0 ) { dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ; } if ( i - 3 >= 0 ) { dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ; dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) continue ; ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; } public static void main ( String [ ] args ) { String str = "6564525600" ; int len = str . length ( ) ; System . out . println ( count ( str , len ) ) ; } }
public class GFG { static void sieve ( int maxm , int [ ] prime ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxm ; i ++ ) if ( prime [ i ] == 0 ) for ( int j = 2 * i ; j <= maxm ; j += i ) prime [ j ] = 1 ; } static long countPair ( int [ ] a , int n ) { int maxm = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) if ( a [ i ] > maxm ) maxm = a [ i ] ; int [ ] prime = new int [ maxm + 1 ] ; for ( i = 0 ; i < maxm + 1 ; i ++ ) prime [ i ] = 0 ; sieve ( maxm , prime ) ; int countPrimes = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( prime [ a [ i ] ] == 0 ) countPrimes ++ ; int nonPrimes = n - countPrimes ; long pairswith1Prime = nonPrimes * countPrimes ; long pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) / 2 ; return pairswith1Prime + pairsWith2Primes ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 4 , 7 } ; int n = arr . length ; System . out . println ( countPair ( arr , n ) ) ; } }
import java . util . Scanner ; public class A332 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; char [ ] S = in . next ( ) . toCharArray ( ) ; int pos = N ; int answer = 0 ; while ( pos < S . length ) { if ( S [ pos - 1 ] == S [ pos - 2 ] && S [ pos - 2 ] == S [ pos - 3 ] ) { answer ++ ; } pos += N ; } System . out . println ( answer ) ; } }
import java . util . Arrays ; public class GFG { static void sortString ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . println ( String . valueOf ( arr ) ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; sortString ( s ) ; } }
import java . io . * ; import java . util . * ; public class Main { public static PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; static void solve ( int n ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } out . println ( n ) ; print1DArray ( arr ) ; for ( int t = 1 ; t < n ; t ++ ) { int temp = arr [ t ] ; arr [ t ] = arr [ t - 1 ] ; arr [ t - 1 ] = temp ; print1DArray ( arr ) ; } } static void print1DArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { out . print ( arr [ i ] ) ; if ( i < arr . length - 1 ) { out . print ( ' ▁ ' ) ; } } out . print ( ' \n ' ) ; } public static void main ( String [ ] args ) { MyScanner scanner = new MyScanner ( ) ; int testCount = scanner . nextInt ( ) ; for ( int testIdx = 1 ; testIdx <= testCount ; testIdx ++ ) { int n = scanner . nextInt ( ) ; solve ( n ) ; } out . close ( ) ; } public static class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . io . * ; public class GFG { static void printNumber ( int n ) { int count [ ] = new int [ 10 ] ; while ( n > 0 ) { count [ n % 10 ] ++ ; n /= 10 ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < count [ i ] * i ; j ++ ) System . out . print ( i ) ; } } public static void main ( String [ ] args ) { int n = 3225 ; printNumber ( n ) ; } }
public class GFG { static int getMax ( int [ ] Arr ) { int max = Arr [ 0 ] ; for ( int i = 1 ; i < Arr . length ; i ++ ) if ( Arr [ i ] > max ) max = Arr [ i ] ; return max ; } static int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int prev = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; if ( x <= prev ) { count ++ ; } prev = x ; } System . out . println ( count ) ; System . out . println ( n ) ; } }